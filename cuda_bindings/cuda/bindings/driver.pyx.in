# SPDX-FileCopyrightText: Copyright (c) 2021-2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: LicenseRef-NVIDIA-SOFTWARE-LICENSE

# This code was automatically generated with version 13.0.0. Do not modify it directly.
from typing import Any, Optional
from enum import IntEnum
import cython
import ctypes
from libc.stdlib cimport calloc, malloc, free
from libc cimport string
from libc.stdint cimport int32_t, uint32_t, int64_t, uint64_t, uintptr_t
from libc.stddef cimport wchar_t
from libc.limits cimport CHAR_MIN
from libcpp.vector cimport vector
from cpython.buffer cimport PyObject_CheckBuffer, PyObject_GetBuffer, PyBuffer_Release, PyBUF_SIMPLE, PyBUF_ANY_CONTIGUOUS
from cpython.bytes cimport PyBytes_FromStringAndSize
import cuda.bindings.driver
from libcpp.map cimport map

_driver = globals()
include "_lib/utils.pxi"

ctypedef unsigned long long signed_char_ptr
ctypedef unsigned long long unsigned_char_ptr
ctypedef unsigned long long char_ptr
ctypedef unsigned long long short_ptr
ctypedef unsigned long long unsigned_short_ptr
ctypedef unsigned long long int_ptr
ctypedef unsigned long long long_int_ptr
ctypedef unsigned long long long_long_int_ptr
ctypedef unsigned long long unsigned_int_ptr
ctypedef unsigned long long unsigned_long_int_ptr
ctypedef unsigned long long unsigned_long_long_int_ptr
ctypedef unsigned long long uint32_t_ptr
ctypedef unsigned long long uint64_t_ptr
ctypedef unsigned long long int32_t_ptr
ctypedef unsigned long long int64_t_ptr
ctypedef unsigned long long unsigned_ptr
ctypedef unsigned long long unsigned_long_long_ptr
ctypedef unsigned long long long_long_ptr
ctypedef unsigned long long size_t_ptr
ctypedef unsigned long long long_ptr
ctypedef unsigned long long float_ptr
ctypedef unsigned long long double_ptr
ctypedef unsigned long long void_ptr

#: CUDA API version number
CUDA_VERSION = cydriver.CUDA_VERSION

#: CUDA IPC handle size
CU_IPC_HANDLE_SIZE = cydriver.CU_IPC_HANDLE_SIZE

#: Legacy stream handle
#:
#: Stream handle that can be passed as a CUstream to use an implicit stream
#: with legacy synchronization behavior.
#:
#: See details of the \link_sync_behavior
CU_STREAM_LEGACY = cydriver.CU_STREAM_LEGACY

#: Per-thread stream handle
#:
#: Stream handle that can be passed as a CUstream to use an implicit stream
#: with per-thread synchronization behavior.
#:
#: See details of the \link_sync_behavior
CU_STREAM_PER_THREAD = cydriver.CU_STREAM_PER_THREAD

CU_COMPUTE_ACCELERATED_TARGET_BASE = cydriver.CU_COMPUTE_ACCELERATED_TARGET_BASE

CU_COMPUTE_FAMILY_TARGET_BASE = cydriver.CU_COMPUTE_FAMILY_TARGET_BASE

#: Conditional node handle flags Default value is applied when graph is
#: launched.
CU_GRAPH_COND_ASSIGN_DEFAULT = cydriver.CU_GRAPH_COND_ASSIGN_DEFAULT

#: This port activates when the kernel has finished executing.
CU_GRAPH_KERNEL_NODE_PORT_DEFAULT = cydriver.CU_GRAPH_KERNEL_NODE_PORT_DEFAULT

#: This port activates when all blocks of the kernel have performed
#: cudaTriggerProgrammaticLaunchCompletion() or have terminated. It must be
#: used with edge type :py:obj:`~.CU_GRAPH_DEPENDENCY_TYPE_PROGRAMMATIC`.
#: See also :py:obj:`~.CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT`.
CU_GRAPH_KERNEL_NODE_PORT_PROGRAMMATIC = cydriver.CU_GRAPH_KERNEL_NODE_PORT_PROGRAMMATIC

#: This port activates when all blocks of the kernel have begun execution.
#: See also :py:obj:`~.CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT`.
CU_GRAPH_KERNEL_NODE_PORT_LAUNCH_ORDER = cydriver.CU_GRAPH_KERNEL_NODE_PORT_LAUNCH_ORDER

CU_KERNEL_NODE_ATTRIBUTE_ACCESS_POLICY_WINDOW = cydriver.CU_KERNEL_NODE_ATTRIBUTE_ACCESS_POLICY_WINDOW

CU_KERNEL_NODE_ATTRIBUTE_COOPERATIVE = cydriver.CU_KERNEL_NODE_ATTRIBUTE_COOPERATIVE

CU_KERNEL_NODE_ATTRIBUTE_CLUSTER_DIMENSION = cydriver.CU_KERNEL_NODE_ATTRIBUTE_CLUSTER_DIMENSION

CU_KERNEL_NODE_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE = cydriver.CU_KERNEL_NODE_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE

CU_KERNEL_NODE_ATTRIBUTE_PRIORITY = cydriver.CU_KERNEL_NODE_ATTRIBUTE_PRIORITY

CU_KERNEL_NODE_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP = cydriver.CU_KERNEL_NODE_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP

CU_KERNEL_NODE_ATTRIBUTE_MEM_SYNC_DOMAIN = cydriver.CU_KERNEL_NODE_ATTRIBUTE_MEM_SYNC_DOMAIN

CU_KERNEL_NODE_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION = cydriver.CU_KERNEL_NODE_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION

CU_KERNEL_NODE_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE = cydriver.CU_KERNEL_NODE_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE

CU_KERNEL_NODE_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = cydriver.CU_KERNEL_NODE_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT

CU_STREAM_ATTRIBUTE_ACCESS_POLICY_WINDOW = cydriver.CU_STREAM_ATTRIBUTE_ACCESS_POLICY_WINDOW

CU_STREAM_ATTRIBUTE_SYNCHRONIZATION_POLICY = cydriver.CU_STREAM_ATTRIBUTE_SYNCHRONIZATION_POLICY

CU_STREAM_ATTRIBUTE_PRIORITY = cydriver.CU_STREAM_ATTRIBUTE_PRIORITY

CU_STREAM_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP = cydriver.CU_STREAM_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP

CU_STREAM_ATTRIBUTE_MEM_SYNC_DOMAIN = cydriver.CU_STREAM_ATTRIBUTE_MEM_SYNC_DOMAIN

#: If set, host memory is portable between CUDA contexts. Flag for
#: :py:obj:`~.cuMemHostAlloc()`
CU_MEMHOSTALLOC_PORTABLE = cydriver.CU_MEMHOSTALLOC_PORTABLE

#: If set, host memory is mapped into CUDA address space and
#: :py:obj:`~.cuMemHostGetDevicePointer()` may be called on the host
#: pointer. Flag for :py:obj:`~.cuMemHostAlloc()`
CU_MEMHOSTALLOC_DEVICEMAP = cydriver.CU_MEMHOSTALLOC_DEVICEMAP

#: If set, host memory is allocated as write-combined - fast to write,
#: faster to DMA, slow to read except via SSE4 streaming load instruction
#: (MOVNTDQA). Flag for :py:obj:`~.cuMemHostAlloc()`
CU_MEMHOSTALLOC_WRITECOMBINED = cydriver.CU_MEMHOSTALLOC_WRITECOMBINED

#: If set, host memory is portable between CUDA contexts. Flag for
#: :py:obj:`~.cuMemHostRegister()`
CU_MEMHOSTREGISTER_PORTABLE = cydriver.CU_MEMHOSTREGISTER_PORTABLE

#: If set, host memory is mapped into CUDA address space and
#: :py:obj:`~.cuMemHostGetDevicePointer()` may be called on the host
#: pointer. Flag for :py:obj:`~.cuMemHostRegister()`
CU_MEMHOSTREGISTER_DEVICEMAP = cydriver.CU_MEMHOSTREGISTER_DEVICEMAP

#: If set, the passed memory pointer is treated as pointing to some memory-
#: mapped I/O space, e.g. belonging to a third-party PCIe device. On
#: Windows the flag is a no-op. On Linux that memory is marked as non
#: cache-coherent for the GPU and is expected to be physically contiguous.
#: It may return :py:obj:`~.CUDA_ERROR_NOT_PERMITTED` if run as an
#: unprivileged user, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED` on older Linux
#: kernel versions. On all other platforms, it is not supported and
#: :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED` is returned. Flag for
#: :py:obj:`~.cuMemHostRegister()`
CU_MEMHOSTREGISTER_IOMEMORY = cydriver.CU_MEMHOSTREGISTER_IOMEMORY

#: If set, the passed memory pointer is treated as pointing to memory that
#: is considered read-only by the device. On platforms without
#: :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
#: this flag is required in order to register memory mapped to the CPU as
#: read-only. Support for the use of this flag can be queried from the
#: device attribute
#: :py:obj:`~.CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED`. Using
#: this flag with a current context associated with a device that does not
#: have this attribute set will cause :py:obj:`~.cuMemHostRegister` to
#: error with :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`.
CU_MEMHOSTREGISTER_READ_ONLY = cydriver.CU_MEMHOSTREGISTER_READ_ONLY

#: Indicates that the layered sparse CUDA array or CUDA mipmapped array has
#: a single mip tail region for all layers
CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL = cydriver.CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL

#: Size of tensor map descriptor
CU_TENSOR_MAP_NUM_QWORDS = cydriver.CU_TENSOR_MAP_NUM_QWORDS

#: Indicates that the external memory object is a dedicated resource
CUDA_EXTERNAL_MEMORY_DEDICATED = cydriver.CUDA_EXTERNAL_MEMORY_DEDICATED

#: When the `flags` parameter of
#: :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS` contains this flag, it
#: indicates that signaling an external semaphore object should skip
#: performing appropriate memory synchronization operations over all the
#: external memory objects that are imported as
#: :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF`, which otherwise are
#: performed by default to ensure data coherency with other importers of
#: the same NvSciBuf memory objects.
CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC = cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC

#: When the `flags` parameter of
#: :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS` contains this flag, it
#: indicates that waiting on an external semaphore object should skip
#: performing appropriate memory synchronization operations over all the
#: external memory objects that are imported as
#: :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF`, which otherwise are
#: performed by default to ensure data coherency with other importers of
#: the same NvSciBuf memory objects.
CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC = cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC

#: When `flags` of :py:obj:`~.cuDeviceGetNvSciSyncAttributes` is set to
#: this, it indicates that application needs signaler specific
#: NvSciSyncAttr to be filled by
#: :py:obj:`~.cuDeviceGetNvSciSyncAttributes`.
CUDA_NVSCISYNC_ATTR_SIGNAL = cydriver.CUDA_NVSCISYNC_ATTR_SIGNAL

#: When `flags` of :py:obj:`~.cuDeviceGetNvSciSyncAttributes` is set to
#: this, it indicates that application needs waiter specific NvSciSyncAttr
#: to be filled by :py:obj:`~.cuDeviceGetNvSciSyncAttributes`.
CUDA_NVSCISYNC_ATTR_WAIT = cydriver.CUDA_NVSCISYNC_ATTR_WAIT

#: This flag if set indicates that the memory will be used as a tile pool.
CU_MEM_CREATE_USAGE_TILE_POOL = cydriver.CU_MEM_CREATE_USAGE_TILE_POOL

#: This flag, if set, indicates that the memory will be used as a buffer
#: for hardware accelerated decompression.
CU_MEM_CREATE_USAGE_HW_DECOMPRESS = cydriver.CU_MEM_CREATE_USAGE_HW_DECOMPRESS

#: This flag, if set, indicates that the memory will be used as a buffer
#: for hardware accelerated decompression.
CU_MEM_POOL_CREATE_USAGE_HW_DECOMPRESS = cydriver.CU_MEM_POOL_CREATE_USAGE_HW_DECOMPRESS

#: If set, each kernel launched as part of
#: :py:obj:`~.cuLaunchCooperativeKernelMultiDevice` only waits for prior
#: work in the stream corresponding to that GPU to complete before the
#: kernel begins execution.
CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC = cydriver.CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC

#: If set, any subsequent work pushed in a stream that participated in a
#: call to :py:obj:`~.cuLaunchCooperativeKernelMultiDevice` will only wait
#: for the kernel launched on the GPU corresponding to that stream to
#: complete before it begins execution.
CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC = cydriver.CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC

#: If set, the CUDA array is a collection of layers, where each layer is
#: either a 1D or a 2D array and the Depth member of
#: CUDA_ARRAY3D_DESCRIPTOR specifies the number of layers, not the depth of
#: a 3D array.
CUDA_ARRAY3D_LAYERED = cydriver.CUDA_ARRAY3D_LAYERED

#: Deprecated, use CUDA_ARRAY3D_LAYERED
CUDA_ARRAY3D_2DARRAY = cydriver.CUDA_ARRAY3D_2DARRAY

#: This flag must be set in order to bind a surface reference to the CUDA
#: array
CUDA_ARRAY3D_SURFACE_LDST = cydriver.CUDA_ARRAY3D_SURFACE_LDST

#: If set, the CUDA array is a collection of six 2D arrays, representing
#: faces of a cube. The width of such a CUDA array must be equal to its
#: height, and Depth must be six. If :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag
#: is also set, then the CUDA array is a collection of cubemaps and Depth
#: must be a multiple of six.
CUDA_ARRAY3D_CUBEMAP = cydriver.CUDA_ARRAY3D_CUBEMAP

#: This flag must be set in order to perform texture gather operations on a
#: CUDA array.
CUDA_ARRAY3D_TEXTURE_GATHER = cydriver.CUDA_ARRAY3D_TEXTURE_GATHER

#: This flag if set indicates that the CUDA array is a DEPTH_TEXTURE.
CUDA_ARRAY3D_DEPTH_TEXTURE = cydriver.CUDA_ARRAY3D_DEPTH_TEXTURE

#: This flag indicates that the CUDA array may be bound as a color target
#: in an external graphics API
CUDA_ARRAY3D_COLOR_ATTACHMENT = cydriver.CUDA_ARRAY3D_COLOR_ATTACHMENT

#: This flag if set indicates that the CUDA array or CUDA mipmapped array
#: is a sparse CUDA array or CUDA mipmapped array respectively
CUDA_ARRAY3D_SPARSE = cydriver.CUDA_ARRAY3D_SPARSE

#: This flag if set indicates that the CUDA array or CUDA mipmapped array
#: will allow deferred memory mapping
CUDA_ARRAY3D_DEFERRED_MAPPING = cydriver.CUDA_ARRAY3D_DEFERRED_MAPPING

#: This flag indicates that the CUDA array will be used for hardware
#: accelerated video encode/decode operations.
CUDA_ARRAY3D_VIDEO_ENCODE_DECODE = cydriver.CUDA_ARRAY3D_VIDEO_ENCODE_DECODE

#: Override the texref format with a format inferred from the array. Flag
#: for :py:obj:`~.cuTexRefSetArray()`
CU_TRSA_OVERRIDE_FORMAT = cydriver.CU_TRSA_OVERRIDE_FORMAT

#: Read the texture as integers rather than promoting the values to floats
#: in the range [0,1]. Flag for :py:obj:`~.cuTexRefSetFlags()` and
#: :py:obj:`~.cuTexObjectCreate()`
CU_TRSF_READ_AS_INTEGER = cydriver.CU_TRSF_READ_AS_INTEGER

#: Use normalized texture coordinates in the range [0,1) instead of
#: [0,dim). Flag for :py:obj:`~.cuTexRefSetFlags()` and
#: :py:obj:`~.cuTexObjectCreate()`
CU_TRSF_NORMALIZED_COORDINATES = cydriver.CU_TRSF_NORMALIZED_COORDINATES

#: Perform sRGB->linear conversion during texture read. Flag for
#: :py:obj:`~.cuTexRefSetFlags()` and :py:obj:`~.cuTexObjectCreate()`
CU_TRSF_SRGB = cydriver.CU_TRSF_SRGB

#: Disable any trilinear filtering optimizations. Flag for
#: :py:obj:`~.cuTexRefSetFlags()` and :py:obj:`~.cuTexObjectCreate()`
CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION = cydriver.CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION

#: Enable seamless cube map filtering. Flag for
#: :py:obj:`~.cuTexObjectCreate()`
CU_TRSF_SEAMLESS_CUBEMAP = cydriver.CU_TRSF_SEAMLESS_CUBEMAP

#: Launch with the required block dimension.
CU_LAUNCH_KERNEL_REQUIRED_BLOCK_DIM = cydriver.CU_LAUNCH_KERNEL_REQUIRED_BLOCK_DIM

#: C++ compile time constant for CU_LAUNCH_PARAM_END
CU_LAUNCH_PARAM_END_AS_INT = cydriver.CU_LAUNCH_PARAM_END_AS_INT

#: End of array terminator for the `extra` parameter to
#: :py:obj:`~.cuLaunchKernel`
CU_LAUNCH_PARAM_END = cydriver.CU_LAUNCH_PARAM_END

#: C++ compile time constant for CU_LAUNCH_PARAM_BUFFER_POINTER
CU_LAUNCH_PARAM_BUFFER_POINTER_AS_INT = cydriver.CU_LAUNCH_PARAM_BUFFER_POINTER_AS_INT

#: Indicator that the next value in the `extra` parameter to
#: :py:obj:`~.cuLaunchKernel` will be a pointer to a buffer containing all
#: kernel parameters used for launching kernel `f`. This buffer needs to
#: honor all alignment/padding requirements of the individual parameters.
#: If :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_SIZE` is not also specified in the
#: `extra` array, then :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER` will have
#: no effect.
CU_LAUNCH_PARAM_BUFFER_POINTER = cydriver.CU_LAUNCH_PARAM_BUFFER_POINTER

#: C++ compile time constant for CU_LAUNCH_PARAM_BUFFER_SIZE
CU_LAUNCH_PARAM_BUFFER_SIZE_AS_INT = cydriver.CU_LAUNCH_PARAM_BUFFER_SIZE_AS_INT

#: Indicator that the next value in the `extra` parameter to
#: :py:obj:`~.cuLaunchKernel` will be a pointer to a size_t which contains
#: the size of the buffer specified with
#: :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER`. It is required that
#: :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER` also be specified in the
#: `extra` array if the value associated with
#: :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_SIZE` is not zero.
CU_LAUNCH_PARAM_BUFFER_SIZE = cydriver.CU_LAUNCH_PARAM_BUFFER_SIZE

#: For texture references loaded into the module, use default texunit from
#: texture reference.
CU_PARAM_TR_DEFAULT = cydriver.CU_PARAM_TR_DEFAULT

#: Device that represents the CPU
CU_DEVICE_CPU = cydriver.CU_DEVICE_CPU

#: Device that represents an invalid device
CU_DEVICE_INVALID = cydriver.CU_DEVICE_INVALID

RESOURCE_ABI_VERSION = cydriver.RESOURCE_ABI_VERSION

RESOURCE_ABI_EXTERNAL_BYTES = cydriver.RESOURCE_ABI_EXTERNAL_BYTES

#: Maximum number of planes per frame
MAX_PLANES = cydriver.MAX_PLANES

#: Indicates that timeout for :py:obj:`~.cuEGLStreamConsumerAcquireFrame`
#: is infinite.
CUDA_EGL_INFINITE_TIMEOUT = cydriver.CUDA_EGL_INFINITE_TIMEOUT

{{if 'CUipcMem_flags_enum' in found_types}}

class CUipcMem_flags(IntEnum):
    """
    CUDA Ipc Mem Flags
    """
    {{if 'CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS' in found_values}}

    #: Automatically enable peer access between remote devices as needed
    CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = cydriver.CUipcMem_flags_enum.CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS{{endif}}

_dict_CUipcMem_flags = dict(((int(v), v) for k, v in CUipcMem_flags.__members__.items()))
{{endif}}
{{if 'CUmemAttach_flags_enum' in found_types}}

class CUmemAttach_flags(IntEnum):
    """
    CUDA Mem Attach Flags
    """
    {{if 'CU_MEM_ATTACH_GLOBAL' in found_values}}

    #: Memory can be accessed by any stream on any device
    CU_MEM_ATTACH_GLOBAL = cydriver.CUmemAttach_flags_enum.CU_MEM_ATTACH_GLOBAL{{endif}}
    {{if 'CU_MEM_ATTACH_HOST' in found_values}}

    #: Memory cannot be accessed by any stream on any device
    CU_MEM_ATTACH_HOST = cydriver.CUmemAttach_flags_enum.CU_MEM_ATTACH_HOST{{endif}}
    {{if 'CU_MEM_ATTACH_SINGLE' in found_values}}

    #: Memory can only be accessed by a single stream on the associated
    #: device
    CU_MEM_ATTACH_SINGLE = cydriver.CUmemAttach_flags_enum.CU_MEM_ATTACH_SINGLE{{endif}}

_dict_CUmemAttach_flags = dict(((int(v), v) for k, v in CUmemAttach_flags.__members__.items()))
{{endif}}
{{if 'CUctx_flags_enum' in found_types}}

class CUctx_flags(IntEnum):
    """
    Context creation flags
    """
    {{if 'CU_CTX_SCHED_AUTO' in found_values}}

    #: Automatic scheduling
    CU_CTX_SCHED_AUTO = cydriver.CUctx_flags_enum.CU_CTX_SCHED_AUTO{{endif}}
    {{if 'CU_CTX_SCHED_SPIN' in found_values}}

    #: Set spin as default scheduling
    CU_CTX_SCHED_SPIN = cydriver.CUctx_flags_enum.CU_CTX_SCHED_SPIN{{endif}}
    {{if 'CU_CTX_SCHED_YIELD' in found_values}}

    #: Set yield as default scheduling
    CU_CTX_SCHED_YIELD = cydriver.CUctx_flags_enum.CU_CTX_SCHED_YIELD{{endif}}
    {{if 'CU_CTX_SCHED_BLOCKING_SYNC' in found_values}}

    #: Set blocking synchronization as default scheduling
    CU_CTX_SCHED_BLOCKING_SYNC = cydriver.CUctx_flags_enum.CU_CTX_SCHED_BLOCKING_SYNC{{endif}}
    {{if 'CU_CTX_BLOCKING_SYNC' in found_values}}

    #: Set blocking synchronization as default scheduling [Deprecated]
    CU_CTX_BLOCKING_SYNC = cydriver.CUctx_flags_enum.CU_CTX_BLOCKING_SYNC{{endif}}
    {{if 'CU_CTX_SCHED_MASK' in found_values}}
    CU_CTX_SCHED_MASK = cydriver.CUctx_flags_enum.CU_CTX_SCHED_MASK{{endif}}
    {{if 'CU_CTX_MAP_HOST' in found_values}}

    #: [Deprecated]
    CU_CTX_MAP_HOST = cydriver.CUctx_flags_enum.CU_CTX_MAP_HOST{{endif}}
    {{if 'CU_CTX_LMEM_RESIZE_TO_MAX' in found_values}}

    #: Keep local memory allocation after launch
    CU_CTX_LMEM_RESIZE_TO_MAX = cydriver.CUctx_flags_enum.CU_CTX_LMEM_RESIZE_TO_MAX{{endif}}
    {{if 'CU_CTX_COREDUMP_ENABLE' in found_values}}

    #: Trigger coredumps from exceptions in this context
    CU_CTX_COREDUMP_ENABLE = cydriver.CUctx_flags_enum.CU_CTX_COREDUMP_ENABLE{{endif}}
    {{if 'CU_CTX_USER_COREDUMP_ENABLE' in found_values}}

    #: Enable user pipe to trigger coredumps in this context
    CU_CTX_USER_COREDUMP_ENABLE = cydriver.CUctx_flags_enum.CU_CTX_USER_COREDUMP_ENABLE{{endif}}
    {{if 'CU_CTX_SYNC_MEMOPS' in found_values}}

    #: Ensure synchronous memory operations on this context will
    #: synchronize
    CU_CTX_SYNC_MEMOPS = cydriver.CUctx_flags_enum.CU_CTX_SYNC_MEMOPS{{endif}}
    {{if 'CU_CTX_FLAGS_MASK' in found_values}}
    CU_CTX_FLAGS_MASK = cydriver.CUctx_flags_enum.CU_CTX_FLAGS_MASK{{endif}}

_dict_CUctx_flags = dict(((int(v), v) for k, v in CUctx_flags.__members__.items()))
{{endif}}
{{if 'CUevent_sched_flags_enum' in found_types}}

class CUevent_sched_flags(IntEnum):
    """
    Event sched flags
    """
    {{if 'CU_EVENT_SCHED_AUTO' in found_values}}

    #: Automatic scheduling
    CU_EVENT_SCHED_AUTO = cydriver.CUevent_sched_flags_enum.CU_EVENT_SCHED_AUTO{{endif}}
    {{if 'CU_EVENT_SCHED_SPIN' in found_values}}

    #: Set spin as default scheduling
    CU_EVENT_SCHED_SPIN = cydriver.CUevent_sched_flags_enum.CU_EVENT_SCHED_SPIN{{endif}}
    {{if 'CU_EVENT_SCHED_YIELD' in found_values}}

    #: Set yield as default scheduling
    CU_EVENT_SCHED_YIELD = cydriver.CUevent_sched_flags_enum.CU_EVENT_SCHED_YIELD{{endif}}
    {{if 'CU_EVENT_SCHED_BLOCKING_SYNC' in found_values}}

    #: Set blocking synchronization as default scheduling
    CU_EVENT_SCHED_BLOCKING_SYNC = cydriver.CUevent_sched_flags_enum.CU_EVENT_SCHED_BLOCKING_SYNC{{endif}}

_dict_CUevent_sched_flags = dict(((int(v), v) for k, v in CUevent_sched_flags.__members__.items()))
{{endif}}
{{if 'cl_event_flags_enum' in found_types}}

class cl_event_flags(IntEnum):
    """
    NVCL event scheduling flags
    """
    {{if 'NVCL_EVENT_SCHED_AUTO' in found_values}}

    #: Automatic scheduling
    NVCL_EVENT_SCHED_AUTO = cydriver.cl_event_flags_enum.NVCL_EVENT_SCHED_AUTO{{endif}}
    {{if 'NVCL_EVENT_SCHED_SPIN' in found_values}}

    #: Set spin as default scheduling
    NVCL_EVENT_SCHED_SPIN = cydriver.cl_event_flags_enum.NVCL_EVENT_SCHED_SPIN{{endif}}
    {{if 'NVCL_EVENT_SCHED_YIELD' in found_values}}

    #: Set yield as default scheduling
    NVCL_EVENT_SCHED_YIELD = cydriver.cl_event_flags_enum.NVCL_EVENT_SCHED_YIELD{{endif}}
    {{if 'NVCL_EVENT_SCHED_BLOCKING_SYNC' in found_values}}

    #: Set blocking synchronization as default scheduling
    NVCL_EVENT_SCHED_BLOCKING_SYNC = cydriver.cl_event_flags_enum.NVCL_EVENT_SCHED_BLOCKING_SYNC{{endif}}

_dict_cl_event_flags = dict(((int(v), v) for k, v in cl_event_flags.__members__.items()))
{{endif}}
{{if 'cl_context_flags_enum' in found_types}}

class cl_context_flags(IntEnum):
    """
    NVCL context scheduling flags
    """
    {{if 'NVCL_CTX_SCHED_AUTO' in found_values}}

    #: Automatic scheduling
    NVCL_CTX_SCHED_AUTO = cydriver.cl_context_flags_enum.NVCL_CTX_SCHED_AUTO{{endif}}
    {{if 'NVCL_CTX_SCHED_SPIN' in found_values}}

    #: Set spin as default scheduling
    NVCL_CTX_SCHED_SPIN = cydriver.cl_context_flags_enum.NVCL_CTX_SCHED_SPIN{{endif}}
    {{if 'NVCL_CTX_SCHED_YIELD' in found_values}}

    #: Set yield as default scheduling
    NVCL_CTX_SCHED_YIELD = cydriver.cl_context_flags_enum.NVCL_CTX_SCHED_YIELD{{endif}}
    {{if 'NVCL_CTX_SCHED_BLOCKING_SYNC' in found_values}}

    #: Set blocking synchronization as default scheduling
    NVCL_CTX_SCHED_BLOCKING_SYNC = cydriver.cl_context_flags_enum.NVCL_CTX_SCHED_BLOCKING_SYNC{{endif}}

_dict_cl_context_flags = dict(((int(v), v) for k, v in cl_context_flags.__members__.items()))
{{endif}}
{{if 'CUstream_flags_enum' in found_types}}

class CUstream_flags(IntEnum):
    """
    Stream creation flags
    """
    {{if 'CU_STREAM_DEFAULT' in found_values}}

    #: Default stream flag
    CU_STREAM_DEFAULT = cydriver.CUstream_flags_enum.CU_STREAM_DEFAULT{{endif}}
    {{if 'CU_STREAM_NON_BLOCKING' in found_values}}

    #: Stream does not synchronize with stream 0 (the NULL stream)
    CU_STREAM_NON_BLOCKING = cydriver.CUstream_flags_enum.CU_STREAM_NON_BLOCKING{{endif}}

_dict_CUstream_flags = dict(((int(v), v) for k, v in CUstream_flags.__members__.items()))
{{endif}}
{{if 'CUevent_flags_enum' in found_types}}

class CUevent_flags(IntEnum):
    """
    Event creation flags
    """
    {{if 'CU_EVENT_DEFAULT' in found_values}}

    #: Default event flag
    CU_EVENT_DEFAULT = cydriver.CUevent_flags_enum.CU_EVENT_DEFAULT{{endif}}
    {{if 'CU_EVENT_BLOCKING_SYNC' in found_values}}

    #: Event uses blocking synchronization
    CU_EVENT_BLOCKING_SYNC = cydriver.CUevent_flags_enum.CU_EVENT_BLOCKING_SYNC{{endif}}
    {{if 'CU_EVENT_DISABLE_TIMING' in found_values}}

    #: Event will not record timing data
    CU_EVENT_DISABLE_TIMING = cydriver.CUevent_flags_enum.CU_EVENT_DISABLE_TIMING{{endif}}
    {{if 'CU_EVENT_INTERPROCESS' in found_values}}

    #: Event is suitable for interprocess use. CU_EVENT_DISABLE_TIMING must
    #: be set
    CU_EVENT_INTERPROCESS = cydriver.CUevent_flags_enum.CU_EVENT_INTERPROCESS{{endif}}

_dict_CUevent_flags = dict(((int(v), v) for k, v in CUevent_flags.__members__.items()))
{{endif}}
{{if 'CUevent_record_flags_enum' in found_types}}

class CUevent_record_flags(IntEnum):
    """
    Event record flags
    """
    {{if 'CU_EVENT_RECORD_DEFAULT' in found_values}}

    #: Default event record flag
    CU_EVENT_RECORD_DEFAULT = cydriver.CUevent_record_flags_enum.CU_EVENT_RECORD_DEFAULT{{endif}}
    {{if 'CU_EVENT_RECORD_EXTERNAL' in found_values}}

    #: When using stream capture, create an event record node instead of
    #: the default behavior. This flag is invalid when used outside of
    #: capture.
    CU_EVENT_RECORD_EXTERNAL = cydriver.CUevent_record_flags_enum.CU_EVENT_RECORD_EXTERNAL{{endif}}

_dict_CUevent_record_flags = dict(((int(v), v) for k, v in CUevent_record_flags.__members__.items()))
{{endif}}
{{if 'CUevent_wait_flags_enum' in found_types}}

class CUevent_wait_flags(IntEnum):
    """
    Event wait flags
    """
    {{if 'CU_EVENT_WAIT_DEFAULT' in found_values}}

    #: Default event wait flag
    CU_EVENT_WAIT_DEFAULT = cydriver.CUevent_wait_flags_enum.CU_EVENT_WAIT_DEFAULT{{endif}}
    {{if 'CU_EVENT_WAIT_EXTERNAL' in found_values}}

    #: When using stream capture, create an event wait node instead of the
    #: default behavior. This flag is invalid when used outside of capture.
    CU_EVENT_WAIT_EXTERNAL = cydriver.CUevent_wait_flags_enum.CU_EVENT_WAIT_EXTERNAL{{endif}}

_dict_CUevent_wait_flags = dict(((int(v), v) for k, v in CUevent_wait_flags.__members__.items()))
{{endif}}
{{if 'CUstreamWaitValue_flags_enum' in found_types}}

class CUstreamWaitValue_flags(IntEnum):
    """
    Flags for :py:obj:`~.cuStreamWaitValue32` and
    :py:obj:`~.cuStreamWaitValue64`
    """
    {{if 'CU_STREAM_WAIT_VALUE_GEQ' in found_values}}

    #: Wait until (int32_t)(*addr - value) >= 0 (or int64_t for 64 bit
    #: values). Note this is a cyclic comparison which ignores wraparound.
    #: (Default behavior.)
    CU_STREAM_WAIT_VALUE_GEQ = cydriver.CUstreamWaitValue_flags_enum.CU_STREAM_WAIT_VALUE_GEQ{{endif}}
    {{if 'CU_STREAM_WAIT_VALUE_EQ' in found_values}}

    #: Wait until *addr == value.
    CU_STREAM_WAIT_VALUE_EQ = cydriver.CUstreamWaitValue_flags_enum.CU_STREAM_WAIT_VALUE_EQ{{endif}}
    {{if 'CU_STREAM_WAIT_VALUE_AND' in found_values}}

    #: Wait until (*addr & value) != 0.
    CU_STREAM_WAIT_VALUE_AND = cydriver.CUstreamWaitValue_flags_enum.CU_STREAM_WAIT_VALUE_AND{{endif}}
    {{if 'CU_STREAM_WAIT_VALUE_NOR' in found_values}}

    #: Wait until ~(*addr | value) != 0. Support for this operation can be
    #: queried with :py:obj:`~.cuDeviceGetAttribute()` and
    #: :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR`.
    CU_STREAM_WAIT_VALUE_NOR = cydriver.CUstreamWaitValue_flags_enum.CU_STREAM_WAIT_VALUE_NOR{{endif}}
    {{if 'CU_STREAM_WAIT_VALUE_FLUSH' in found_values}}

    #: Follow the wait operation with a flush of outstanding remote writes.
    #: This means that, if a remote write operation is guaranteed to have
    #: reached the device before the wait can be satisfied, that write is
    #: guaranteed to be visible to downstream device work. The device is
    #: permitted to reorder remote writes internally. For example, this
    #: flag would be required if two remote writes arrive in a defined
    #: order, the wait is satisfied by the second write, and downstream
    #: work needs to observe the first write. Support for this operation is
    #: restricted to selected platforms and can be queried with
    #: :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES`.
    CU_STREAM_WAIT_VALUE_FLUSH = cydriver.CUstreamWaitValue_flags_enum.CU_STREAM_WAIT_VALUE_FLUSH{{endif}}

_dict_CUstreamWaitValue_flags = dict(((int(v), v) for k, v in CUstreamWaitValue_flags.__members__.items()))
{{endif}}
{{if 'CUstreamWriteValue_flags_enum' in found_types}}

class CUstreamWriteValue_flags(IntEnum):
    """
    Flags for :py:obj:`~.cuStreamWriteValue32`
    """
    {{if 'CU_STREAM_WRITE_VALUE_DEFAULT' in found_values}}

    #: Default behavior
    CU_STREAM_WRITE_VALUE_DEFAULT = cydriver.CUstreamWriteValue_flags_enum.CU_STREAM_WRITE_VALUE_DEFAULT{{endif}}
    {{if 'CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER' in found_values}}

    #: Permits the write to be reordered with writes which were issued
    #: before it, as a performance optimization. Normally,
    #: :py:obj:`~.cuStreamWriteValue32` will provide a memory fence before
    #: the write, which has similar semantics to __threadfence_system() but
    #: is scoped to the stream rather than a CUDA thread. This flag is not
    #: supported in the v2 API.
    CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER = cydriver.CUstreamWriteValue_flags_enum.CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER{{endif}}

_dict_CUstreamWriteValue_flags = dict(((int(v), v) for k, v in CUstreamWriteValue_flags.__members__.items()))
{{endif}}
{{if 'CUstreamBatchMemOpType_enum' in found_types}}

class CUstreamBatchMemOpType(IntEnum):
    """
    Operations for :py:obj:`~.cuStreamBatchMemOp`
    """
    {{if 'CU_STREAM_MEM_OP_WAIT_VALUE_32' in found_values}}

    #: Represents a :py:obj:`~.cuStreamWaitValue32` operation
    CU_STREAM_MEM_OP_WAIT_VALUE_32 = cydriver.CUstreamBatchMemOpType_enum.CU_STREAM_MEM_OP_WAIT_VALUE_32{{endif}}
    {{if 'CU_STREAM_MEM_OP_WRITE_VALUE_32' in found_values}}

    #: Represents a :py:obj:`~.cuStreamWriteValue32` operation
    CU_STREAM_MEM_OP_WRITE_VALUE_32 = cydriver.CUstreamBatchMemOpType_enum.CU_STREAM_MEM_OP_WRITE_VALUE_32{{endif}}
    {{if 'CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES' in found_values}}

    #: This has the same effect as :py:obj:`~.CU_STREAM_WAIT_VALUE_FLUSH`,
    #: but as a standalone operation.
    CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES = cydriver.CUstreamBatchMemOpType_enum.CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES{{endif}}
    {{if 'CU_STREAM_MEM_OP_WAIT_VALUE_64' in found_values}}

    #: Represents a :py:obj:`~.cuStreamWaitValue64` operation
    CU_STREAM_MEM_OP_WAIT_VALUE_64 = cydriver.CUstreamBatchMemOpType_enum.CU_STREAM_MEM_OP_WAIT_VALUE_64{{endif}}
    {{if 'CU_STREAM_MEM_OP_WRITE_VALUE_64' in found_values}}

    #: Represents a :py:obj:`~.cuStreamWriteValue64` operation
    CU_STREAM_MEM_OP_WRITE_VALUE_64 = cydriver.CUstreamBatchMemOpType_enum.CU_STREAM_MEM_OP_WRITE_VALUE_64{{endif}}
    {{if 'CU_STREAM_MEM_OP_BARRIER' in found_values}}

    #: Insert a memory barrier of the specified type
    CU_STREAM_MEM_OP_BARRIER = cydriver.CUstreamBatchMemOpType_enum.CU_STREAM_MEM_OP_BARRIER{{endif}}

_dict_CUstreamBatchMemOpType = dict(((int(v), v) for k, v in CUstreamBatchMemOpType.__members__.items()))
{{endif}}
{{if 'CUstreamMemoryBarrier_flags_enum' in found_types}}

class CUstreamMemoryBarrier_flags(IntEnum):
    """
    Flags for :py:obj:`~.CUstreamBatchMemOpParams.memoryBarrier`
    """
    {{if 'CU_STREAM_MEMORY_BARRIER_TYPE_SYS' in found_values}}

    #: System-wide memory barrier.
    CU_STREAM_MEMORY_BARRIER_TYPE_SYS = cydriver.CUstreamMemoryBarrier_flags_enum.CU_STREAM_MEMORY_BARRIER_TYPE_SYS{{endif}}
    {{if 'CU_STREAM_MEMORY_BARRIER_TYPE_GPU' in found_values}}

    #: Limit memory barrier scope to the GPU.
    CU_STREAM_MEMORY_BARRIER_TYPE_GPU = cydriver.CUstreamMemoryBarrier_flags_enum.CU_STREAM_MEMORY_BARRIER_TYPE_GPU{{endif}}

_dict_CUstreamMemoryBarrier_flags = dict(((int(v), v) for k, v in CUstreamMemoryBarrier_flags.__members__.items()))
{{endif}}
{{if 'CUoccupancy_flags_enum' in found_types}}

class CUoccupancy_flags(IntEnum):
    """
    Occupancy calculator flag
    """
    {{if 'CU_OCCUPANCY_DEFAULT' in found_values}}

    #: Default behavior
    CU_OCCUPANCY_DEFAULT = cydriver.CUoccupancy_flags_enum.CU_OCCUPANCY_DEFAULT{{endif}}
    {{if 'CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE' in found_values}}

    #: Assume global caching is enabled and cannot be automatically turned
    #: off
    CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE = cydriver.CUoccupancy_flags_enum.CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE{{endif}}

_dict_CUoccupancy_flags = dict(((int(v), v) for k, v in CUoccupancy_flags.__members__.items()))
{{endif}}
{{if 'CUstreamUpdateCaptureDependencies_flags_enum' in found_types}}

class CUstreamUpdateCaptureDependencies_flags(IntEnum):
    """
    Flags for :py:obj:`~.cuStreamUpdateCaptureDependencies`
    """
    {{if 'CU_STREAM_ADD_CAPTURE_DEPENDENCIES' in found_values}}

    #: Add new nodes to the dependency set
    CU_STREAM_ADD_CAPTURE_DEPENDENCIES = cydriver.CUstreamUpdateCaptureDependencies_flags_enum.CU_STREAM_ADD_CAPTURE_DEPENDENCIES{{endif}}
    {{if 'CU_STREAM_SET_CAPTURE_DEPENDENCIES' in found_values}}

    #: Replace the dependency set with the new nodes
    CU_STREAM_SET_CAPTURE_DEPENDENCIES = cydriver.CUstreamUpdateCaptureDependencies_flags_enum.CU_STREAM_SET_CAPTURE_DEPENDENCIES{{endif}}

_dict_CUstreamUpdateCaptureDependencies_flags = dict(((int(v), v) for k, v in CUstreamUpdateCaptureDependencies_flags.__members__.items()))
{{endif}}
{{if 'CUasyncNotificationType_enum' in found_types}}

class CUasyncNotificationType(IntEnum):
    """
    Types of async notification that can be sent
    """
    {{if 'CU_ASYNC_NOTIFICATION_TYPE_OVER_BUDGET' in found_values}}

    #: Sent when the process has exceeded its device memory budget
    CU_ASYNC_NOTIFICATION_TYPE_OVER_BUDGET = cydriver.CUasyncNotificationType_enum.CU_ASYNC_NOTIFICATION_TYPE_OVER_BUDGET{{endif}}

_dict_CUasyncNotificationType = dict(((int(v), v) for k, v in CUasyncNotificationType.__members__.items()))
{{endif}}
{{if 'CUarray_format_enum' in found_types}}

class CUarray_format(IntEnum):
    """
    Array formats
    """
    {{if 'CU_AD_FORMAT_UNSIGNED_INT8' in found_values}}

    #: Unsigned 8-bit integers
    CU_AD_FORMAT_UNSIGNED_INT8 = cydriver.CUarray_format_enum.CU_AD_FORMAT_UNSIGNED_INT8{{endif}}
    {{if 'CU_AD_FORMAT_UNSIGNED_INT16' in found_values}}

    #: Unsigned 16-bit integers
    CU_AD_FORMAT_UNSIGNED_INT16 = cydriver.CUarray_format_enum.CU_AD_FORMAT_UNSIGNED_INT16{{endif}}
    {{if 'CU_AD_FORMAT_UNSIGNED_INT32' in found_values}}

    #: Unsigned 32-bit integers
    CU_AD_FORMAT_UNSIGNED_INT32 = cydriver.CUarray_format_enum.CU_AD_FORMAT_UNSIGNED_INT32{{endif}}
    {{if 'CU_AD_FORMAT_SIGNED_INT8' in found_values}}

    #: Signed 8-bit integers
    CU_AD_FORMAT_SIGNED_INT8 = cydriver.CUarray_format_enum.CU_AD_FORMAT_SIGNED_INT8{{endif}}
    {{if 'CU_AD_FORMAT_SIGNED_INT16' in found_values}}

    #: Signed 16-bit integers
    CU_AD_FORMAT_SIGNED_INT16 = cydriver.CUarray_format_enum.CU_AD_FORMAT_SIGNED_INT16{{endif}}
    {{if 'CU_AD_FORMAT_SIGNED_INT32' in found_values}}

    #: Signed 32-bit integers
    CU_AD_FORMAT_SIGNED_INT32 = cydriver.CUarray_format_enum.CU_AD_FORMAT_SIGNED_INT32{{endif}}
    {{if 'CU_AD_FORMAT_HALF' in found_values}}

    #: 16-bit floating point
    CU_AD_FORMAT_HALF = cydriver.CUarray_format_enum.CU_AD_FORMAT_HALF{{endif}}
    {{if 'CU_AD_FORMAT_FLOAT' in found_values}}

    #: 32-bit floating point
    CU_AD_FORMAT_FLOAT = cydriver.CUarray_format_enum.CU_AD_FORMAT_FLOAT{{endif}}
    {{if 'CU_AD_FORMAT_UNORM_INT_101010_2' in found_values}}

    #: 4 channel unorm R10G10B10A2 RGB format
    CU_AD_FORMAT_UNORM_INT_101010_2 = cydriver.CUarray_format_enum.CU_AD_FORMAT_UNORM_INT_101010_2{{endif}}
    {{if 'CU_AD_FORMAT_BC1_UNORM' in found_values}}

    #: 4 channel unsigned normalized block-compressed (BC1 compression)
    #: format
    CU_AD_FORMAT_BC1_UNORM = cydriver.CUarray_format_enum.CU_AD_FORMAT_BC1_UNORM{{endif}}
    {{if 'CU_AD_FORMAT_BC1_UNORM_SRGB' in found_values}}

    #: 4 channel unsigned normalized block-compressed (BC1 compression)
    #: format with sRGB encoding
    CU_AD_FORMAT_BC1_UNORM_SRGB = cydriver.CUarray_format_enum.CU_AD_FORMAT_BC1_UNORM_SRGB{{endif}}
    {{if 'CU_AD_FORMAT_BC2_UNORM' in found_values}}

    #: 4 channel unsigned normalized block-compressed (BC2 compression)
    #: format
    CU_AD_FORMAT_BC2_UNORM = cydriver.CUarray_format_enum.CU_AD_FORMAT_BC2_UNORM{{endif}}
    {{if 'CU_AD_FORMAT_BC2_UNORM_SRGB' in found_values}}

    #: 4 channel unsigned normalized block-compressed (BC2 compression)
    #: format with sRGB encoding
    CU_AD_FORMAT_BC2_UNORM_SRGB = cydriver.CUarray_format_enum.CU_AD_FORMAT_BC2_UNORM_SRGB{{endif}}
    {{if 'CU_AD_FORMAT_BC3_UNORM' in found_values}}

    #: 4 channel unsigned normalized block-compressed (BC3 compression)
    #: format
    CU_AD_FORMAT_BC3_UNORM = cydriver.CUarray_format_enum.CU_AD_FORMAT_BC3_UNORM{{endif}}
    {{if 'CU_AD_FORMAT_BC3_UNORM_SRGB' in found_values}}

    #: 4 channel unsigned normalized block-compressed (BC3 compression)
    #: format with sRGB encoding
    CU_AD_FORMAT_BC3_UNORM_SRGB = cydriver.CUarray_format_enum.CU_AD_FORMAT_BC3_UNORM_SRGB{{endif}}
    {{if 'CU_AD_FORMAT_BC4_UNORM' in found_values}}

    #: 1 channel unsigned normalized block-compressed (BC4 compression)
    #: format
    CU_AD_FORMAT_BC4_UNORM = cydriver.CUarray_format_enum.CU_AD_FORMAT_BC4_UNORM{{endif}}
    {{if 'CU_AD_FORMAT_BC4_SNORM' in found_values}}

    #: 1 channel signed normalized block-compressed (BC4 compression)
    #: format
    CU_AD_FORMAT_BC4_SNORM = cydriver.CUarray_format_enum.CU_AD_FORMAT_BC4_SNORM{{endif}}
    {{if 'CU_AD_FORMAT_BC5_UNORM' in found_values}}

    #: 2 channel unsigned normalized block-compressed (BC5 compression)
    #: format
    CU_AD_FORMAT_BC5_UNORM = cydriver.CUarray_format_enum.CU_AD_FORMAT_BC5_UNORM{{endif}}
    {{if 'CU_AD_FORMAT_BC5_SNORM' in found_values}}

    #: 2 channel signed normalized block-compressed (BC5 compression)
    #: format
    CU_AD_FORMAT_BC5_SNORM = cydriver.CUarray_format_enum.CU_AD_FORMAT_BC5_SNORM{{endif}}
    {{if 'CU_AD_FORMAT_BC6H_UF16' in found_values}}

    #: 3 channel unsigned half-float block-compressed (BC6H compression)
    #: format
    CU_AD_FORMAT_BC6H_UF16 = cydriver.CUarray_format_enum.CU_AD_FORMAT_BC6H_UF16{{endif}}
    {{if 'CU_AD_FORMAT_BC6H_SF16' in found_values}}

    #: 3 channel signed half-float block-compressed (BC6H compression)
    #: format
    CU_AD_FORMAT_BC6H_SF16 = cydriver.CUarray_format_enum.CU_AD_FORMAT_BC6H_SF16{{endif}}
    {{if 'CU_AD_FORMAT_BC7_UNORM' in found_values}}

    #: 4 channel unsigned normalized block-compressed (BC7 compression)
    #: format
    CU_AD_FORMAT_BC7_UNORM = cydriver.CUarray_format_enum.CU_AD_FORMAT_BC7_UNORM{{endif}}
    {{if 'CU_AD_FORMAT_BC7_UNORM_SRGB' in found_values}}

    #: 4 channel unsigned normalized block-compressed (BC7 compression)
    #: format with sRGB encoding
    CU_AD_FORMAT_BC7_UNORM_SRGB = cydriver.CUarray_format_enum.CU_AD_FORMAT_BC7_UNORM_SRGB{{endif}}
    {{if 'CU_AD_FORMAT_P010' in found_values}}

    #: 10-bit YUV planar format, with 4:2:0 sampling
    CU_AD_FORMAT_P010 = cydriver.CUarray_format_enum.CU_AD_FORMAT_P010{{endif}}
    {{if 'CU_AD_FORMAT_P016' in found_values}}

    #: 16-bit YUV planar format, with 4:2:0 sampling
    CU_AD_FORMAT_P016 = cydriver.CUarray_format_enum.CU_AD_FORMAT_P016{{endif}}
    {{if 'CU_AD_FORMAT_NV16' in found_values}}

    #: 8-bit YUV planar format, with 4:2:2 sampling
    CU_AD_FORMAT_NV16 = cydriver.CUarray_format_enum.CU_AD_FORMAT_NV16{{endif}}
    {{if 'CU_AD_FORMAT_P210' in found_values}}

    #: 10-bit YUV planar format, with 4:2:2 sampling
    CU_AD_FORMAT_P210 = cydriver.CUarray_format_enum.CU_AD_FORMAT_P210{{endif}}
    {{if 'CU_AD_FORMAT_P216' in found_values}}

    #: 16-bit YUV planar format, with 4:2:2 sampling
    CU_AD_FORMAT_P216 = cydriver.CUarray_format_enum.CU_AD_FORMAT_P216{{endif}}
    {{if 'CU_AD_FORMAT_YUY2' in found_values}}

    #: 2 channel, 8-bit YUV packed planar format, with 4:2:2 sampling
    CU_AD_FORMAT_YUY2 = cydriver.CUarray_format_enum.CU_AD_FORMAT_YUY2{{endif}}
    {{if 'CU_AD_FORMAT_Y210' in found_values}}

    #: 2 channel, 10-bit YUV packed planar format, with 4:2:2 sampling
    CU_AD_FORMAT_Y210 = cydriver.CUarray_format_enum.CU_AD_FORMAT_Y210{{endif}}
    {{if 'CU_AD_FORMAT_Y216' in found_values}}

    #: 2 channel, 16-bit YUV packed planar format, with 4:2:2 sampling
    CU_AD_FORMAT_Y216 = cydriver.CUarray_format_enum.CU_AD_FORMAT_Y216{{endif}}
    {{if 'CU_AD_FORMAT_AYUV' in found_values}}

    #: 4 channel, 8-bit YUV packed planar format, with 4:4:4 sampling
    CU_AD_FORMAT_AYUV = cydriver.CUarray_format_enum.CU_AD_FORMAT_AYUV{{endif}}
    {{if 'CU_AD_FORMAT_Y410' in found_values}}

    #: 10-bit YUV packed planar format, with 4:4:4 sampling
    CU_AD_FORMAT_Y410 = cydriver.CUarray_format_enum.CU_AD_FORMAT_Y410{{endif}}
    {{if 'CU_AD_FORMAT_NV12' in found_values}}

    #: 8-bit YUV planar format, with 4:2:0 sampling
    CU_AD_FORMAT_NV12 = cydriver.CUarray_format_enum.CU_AD_FORMAT_NV12{{endif}}
    {{if 'CU_AD_FORMAT_Y416' in found_values}}

    #: 4 channel, 12-bit YUV packed planar format, with 4:4:4 sampling
    CU_AD_FORMAT_Y416 = cydriver.CUarray_format_enum.CU_AD_FORMAT_Y416{{endif}}
    {{if 'CU_AD_FORMAT_Y444_PLANAR8' in found_values}}

    #: 3 channel 8-bit YUV planar format, with 4:4:4 sampling
    CU_AD_FORMAT_Y444_PLANAR8 = cydriver.CUarray_format_enum.CU_AD_FORMAT_Y444_PLANAR8{{endif}}
    {{if 'CU_AD_FORMAT_Y444_PLANAR10' in found_values}}

    #: 3 channel 10-bit YUV planar format, with 4:4:4 sampling
    CU_AD_FORMAT_Y444_PLANAR10 = cydriver.CUarray_format_enum.CU_AD_FORMAT_Y444_PLANAR10{{endif}}
    {{if 'CU_AD_FORMAT_YUV444_8bit_SemiPlanar' in found_values}}

    #: 3 channel 8-bit YUV semi-planar format, with 4:4:4 sampling
    CU_AD_FORMAT_YUV444_8bit_SemiPlanar = cydriver.CUarray_format_enum.CU_AD_FORMAT_YUV444_8bit_SemiPlanar{{endif}}
    {{if 'CU_AD_FORMAT_YUV444_16bit_SemiPlanar' in found_values}}

    #: 3 channel 16-bit YUV semi-planar format, with 4:4:4 sampling
    CU_AD_FORMAT_YUV444_16bit_SemiPlanar = cydriver.CUarray_format_enum.CU_AD_FORMAT_YUV444_16bit_SemiPlanar{{endif}}
    {{if 'CU_AD_FORMAT_UNORM_INT8X1' in found_values}}

    #: 1 channel unsigned 8-bit normalized integer
    CU_AD_FORMAT_UNORM_INT8X1 = cydriver.CUarray_format_enum.CU_AD_FORMAT_UNORM_INT8X1{{endif}}
    {{if 'CU_AD_FORMAT_UNORM_INT8X2' in found_values}}

    #: 2 channel unsigned 8-bit normalized integer
    CU_AD_FORMAT_UNORM_INT8X2 = cydriver.CUarray_format_enum.CU_AD_FORMAT_UNORM_INT8X2{{endif}}
    {{if 'CU_AD_FORMAT_UNORM_INT8X4' in found_values}}

    #: 4 channel unsigned 8-bit normalized integer
    CU_AD_FORMAT_UNORM_INT8X4 = cydriver.CUarray_format_enum.CU_AD_FORMAT_UNORM_INT8X4{{endif}}
    {{if 'CU_AD_FORMAT_UNORM_INT16X1' in found_values}}

    #: 1 channel unsigned 16-bit normalized integer
    CU_AD_FORMAT_UNORM_INT16X1 = cydriver.CUarray_format_enum.CU_AD_FORMAT_UNORM_INT16X1{{endif}}
    {{if 'CU_AD_FORMAT_UNORM_INT16X2' in found_values}}

    #: 2 channel unsigned 16-bit normalized integer
    CU_AD_FORMAT_UNORM_INT16X2 = cydriver.CUarray_format_enum.CU_AD_FORMAT_UNORM_INT16X2{{endif}}
    {{if 'CU_AD_FORMAT_UNORM_INT16X4' in found_values}}

    #: 4 channel unsigned 16-bit normalized integer
    CU_AD_FORMAT_UNORM_INT16X4 = cydriver.CUarray_format_enum.CU_AD_FORMAT_UNORM_INT16X4{{endif}}
    {{if 'CU_AD_FORMAT_SNORM_INT8X1' in found_values}}

    #: 1 channel signed 8-bit normalized integer
    CU_AD_FORMAT_SNORM_INT8X1 = cydriver.CUarray_format_enum.CU_AD_FORMAT_SNORM_INT8X1{{endif}}
    {{if 'CU_AD_FORMAT_SNORM_INT8X2' in found_values}}

    #: 2 channel signed 8-bit normalized integer
    CU_AD_FORMAT_SNORM_INT8X2 = cydriver.CUarray_format_enum.CU_AD_FORMAT_SNORM_INT8X2{{endif}}
    {{if 'CU_AD_FORMAT_SNORM_INT8X4' in found_values}}

    #: 4 channel signed 8-bit normalized integer
    CU_AD_FORMAT_SNORM_INT8X4 = cydriver.CUarray_format_enum.CU_AD_FORMAT_SNORM_INT8X4{{endif}}
    {{if 'CU_AD_FORMAT_SNORM_INT16X1' in found_values}}

    #: 1 channel signed 16-bit normalized integer
    CU_AD_FORMAT_SNORM_INT16X1 = cydriver.CUarray_format_enum.CU_AD_FORMAT_SNORM_INT16X1{{endif}}
    {{if 'CU_AD_FORMAT_SNORM_INT16X2' in found_values}}

    #: 2 channel signed 16-bit normalized integer
    CU_AD_FORMAT_SNORM_INT16X2 = cydriver.CUarray_format_enum.CU_AD_FORMAT_SNORM_INT16X2{{endif}}
    {{if 'CU_AD_FORMAT_SNORM_INT16X4' in found_values}}

    #: 4 channel signed 16-bit normalized integer
    CU_AD_FORMAT_SNORM_INT16X4 = cydriver.CUarray_format_enum.CU_AD_FORMAT_SNORM_INT16X4{{endif}}
    {{if 'CU_AD_FORMAT_MAX' in found_values}}
    CU_AD_FORMAT_MAX = cydriver.CUarray_format_enum.CU_AD_FORMAT_MAX{{endif}}

_dict_CUarray_format = dict(((int(v), v) for k, v in CUarray_format.__members__.items()))
{{endif}}
{{if 'CUaddress_mode_enum' in found_types}}

class CUaddress_mode(IntEnum):
    """
    Texture reference addressing modes
    """
    {{if 'CU_TR_ADDRESS_MODE_WRAP' in found_values}}

    #: Wrapping address mode
    CU_TR_ADDRESS_MODE_WRAP = cydriver.CUaddress_mode_enum.CU_TR_ADDRESS_MODE_WRAP{{endif}}
    {{if 'CU_TR_ADDRESS_MODE_CLAMP' in found_values}}

    #: Clamp to edge address mode
    CU_TR_ADDRESS_MODE_CLAMP = cydriver.CUaddress_mode_enum.CU_TR_ADDRESS_MODE_CLAMP{{endif}}
    {{if 'CU_TR_ADDRESS_MODE_MIRROR' in found_values}}

    #: Mirror address mode
    CU_TR_ADDRESS_MODE_MIRROR = cydriver.CUaddress_mode_enum.CU_TR_ADDRESS_MODE_MIRROR{{endif}}
    {{if 'CU_TR_ADDRESS_MODE_BORDER' in found_values}}

    #: Border address mode
    CU_TR_ADDRESS_MODE_BORDER = cydriver.CUaddress_mode_enum.CU_TR_ADDRESS_MODE_BORDER{{endif}}

_dict_CUaddress_mode = dict(((int(v), v) for k, v in CUaddress_mode.__members__.items()))
{{endif}}
{{if 'CUfilter_mode_enum' in found_types}}

class CUfilter_mode(IntEnum):
    """
    Texture reference filtering modes
    """
    {{if 'CU_TR_FILTER_MODE_POINT' in found_values}}

    #: Point filter mode
    CU_TR_FILTER_MODE_POINT = cydriver.CUfilter_mode_enum.CU_TR_FILTER_MODE_POINT{{endif}}
    {{if 'CU_TR_FILTER_MODE_LINEAR' in found_values}}

    #: Linear filter mode
    CU_TR_FILTER_MODE_LINEAR = cydriver.CUfilter_mode_enum.CU_TR_FILTER_MODE_LINEAR{{endif}}

_dict_CUfilter_mode = dict(((int(v), v) for k, v in CUfilter_mode.__members__.items()))
{{endif}}
{{if 'CUdevice_attribute_enum' in found_types}}

class CUdevice_attribute(IntEnum):
    """
    Device properties
    """
    {{if 'CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK' in found_values}}

    #: Maximum number of threads per block
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X' in found_values}}

    #: Maximum block dimension X
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y' in found_values}}

    #: Maximum block dimension Y
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z' in found_values}}

    #: Maximum block dimension Z
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X' in found_values}}

    #: Maximum grid dimension X
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y' in found_values}}

    #: Maximum grid dimension Y
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z' in found_values}}

    #: Maximum grid dimension Z
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK' in found_values}}

    #: Maximum shared memory available per block in bytes
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK' in found_values}}

    #: Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK
    CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY' in found_values}}

    #: Memory available on device for constant variables in a CUDA C kernel
    #: in bytes
    CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_WARP_SIZE' in found_values}}

    #: Warp size in threads
    CU_DEVICE_ATTRIBUTE_WARP_SIZE = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_WARP_SIZE{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAX_PITCH' in found_values}}

    #: Maximum pitch in bytes allowed by memory copies
    CU_DEVICE_ATTRIBUTE_MAX_PITCH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_PITCH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK' in found_values}}

    #: Maximum number of 32-bit registers available per block
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK' in found_values}}

    #: Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK
    CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_CLOCK_RATE' in found_values}}

    #: Typical clock frequency in kilohertz
    CU_DEVICE_ATTRIBUTE_CLOCK_RATE = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CLOCK_RATE{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT' in found_values}}

    #: Alignment requirement for textures
    CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_GPU_OVERLAP' in found_values}}

    #: Device can possibly copy memory and execute a kernel concurrently.
    #: Deprecated. Use instead CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT.
    CU_DEVICE_ATTRIBUTE_GPU_OVERLAP = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GPU_OVERLAP{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT' in found_values}}

    #: Number of multiprocessors on device
    CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT' in found_values}}

    #: Specifies whether there is a run time limit on kernels
    CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_INTEGRATED' in found_values}}

    #: Device is integrated with host memory
    CU_DEVICE_ATTRIBUTE_INTEGRATED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_INTEGRATED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY' in found_values}}

    #: Device can map host memory into CUDA address space
    CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_COMPUTE_MODE' in found_values}}

    #: Compute mode (See :py:obj:`~.CUcomputemode` for details)
    CU_DEVICE_ATTRIBUTE_COMPUTE_MODE = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COMPUTE_MODE{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH' in found_values}}

    #: Maximum 1D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH' in found_values}}

    #: Maximum 2D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT' in found_values}}

    #: Maximum 2D texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH' in found_values}}

    #: Maximum 3D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT' in found_values}}

    #: Maximum 3D texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH' in found_values}}

    #: Maximum 3D texture depth
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH' in found_values}}

    #: Maximum 2D layered texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH' in found_values}}

    #: Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT' in found_values}}

    #: Maximum 2D layered texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT' in found_values}}

    #: Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS' in found_values}}

    #: Maximum layers in a 2D layered texture
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES' in found_values}}

    #: Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT' in found_values}}

    #: Alignment requirement for surfaces
    CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS' in found_values}}

    #: Device can possibly execute multiple kernels concurrently
    CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_ECC_ENABLED' in found_values}}

    #: Device has ECC support enabled
    CU_DEVICE_ATTRIBUTE_ECC_ENABLED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_ECC_ENABLED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_PCI_BUS_ID' in found_values}}

    #: PCI bus ID of the device
    CU_DEVICE_ATTRIBUTE_PCI_BUS_ID = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_PCI_BUS_ID{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID' in found_values}}

    #: PCI device ID of the device
    CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_TCC_DRIVER' in found_values}}

    #: Device is using TCC driver model
    CU_DEVICE_ATTRIBUTE_TCC_DRIVER = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_TCC_DRIVER{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE' in found_values}}

    #: Peak memory clock frequency in kilohertz
    CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH' in found_values}}

    #: Global memory bus width in bits
    CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE' in found_values}}

    #: Size of L2 cache in bytes
    CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR' in found_values}}

    #: Maximum resident threads per multiprocessor
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT' in found_values}}

    #: Number of asynchronous engines
    CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING' in found_values}}

    #: Device shares a unified address space with the host
    CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH' in found_values}}

    #: Maximum 1D layered texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS' in found_values}}

    #: Maximum layers in a 1D layered texture
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER' in found_values}}

    #: Deprecated, do not use.
    CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH' in found_values}}

    #: Maximum 2D texture width if CUDA_ARRAY3D_TEXTURE_GATHER is set
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT' in found_values}}

    #: Maximum 2D texture height if CUDA_ARRAY3D_TEXTURE_GATHER is set
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE' in found_values}}

    #: Alternate maximum 3D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE' in found_values}}

    #: Alternate maximum 3D texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE' in found_values}}

    #: Alternate maximum 3D texture depth
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID' in found_values}}

    #: PCI domain ID of the device
    CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT' in found_values}}

    #: Pitch alignment requirement for textures
    CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH' in found_values}}

    #: Maximum cubemap texture width/height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH' in found_values}}

    #: Maximum cubemap layered texture width/height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS' in found_values}}

    #: Maximum layers in a cubemap layered texture
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH' in found_values}}

    #: Maximum 1D surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH' in found_values}}

    #: Maximum 2D surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT' in found_values}}

    #: Maximum 2D surface height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH' in found_values}}

    #: Maximum 3D surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT' in found_values}}

    #: Maximum 3D surface height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH' in found_values}}

    #: Maximum 3D surface depth
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH' in found_values}}

    #: Maximum 1D layered surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS' in found_values}}

    #: Maximum layers in a 1D layered surface
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH' in found_values}}

    #: Maximum 2D layered surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT' in found_values}}

    #: Maximum 2D layered surface height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS' in found_values}}

    #: Maximum layers in a 2D layered surface
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH' in found_values}}

    #: Maximum cubemap surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH' in found_values}}

    #: Maximum cubemap layered surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS' in found_values}}

    #: Maximum layers in a cubemap layered surface
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH' in found_values}}

    #: Deprecated, do not use. Use cudaDeviceGetTexture1DLinearMaxWidth()
    #: or :py:obj:`~.cuDeviceGetTexture1DLinearMaxWidth()` instead.
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH' in found_values}}

    #: Maximum 2D linear texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT' in found_values}}

    #: Maximum 2D linear texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH' in found_values}}

    #: Maximum 2D linear texture pitch in bytes
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH' in found_values}}

    #: Maximum mipmapped 2D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT' in found_values}}

    #: Maximum mipmapped 2D texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR' in found_values}}

    #: Major compute capability version number
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR' in found_values}}

    #: Minor compute capability version number
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH' in found_values}}

    #: Maximum mipmapped 1D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED' in found_values}}

    #: Device supports stream priorities
    CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED' in found_values}}

    #: Device supports caching globals in L1
    CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED' in found_values}}

    #: Device supports caching locals in L1
    CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR' in found_values}}

    #: Maximum shared memory available per multiprocessor in bytes
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR' in found_values}}

    #: Maximum number of 32-bit registers available per multiprocessor
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY' in found_values}}

    #: Device can allocate managed memory on this system
    CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD' in found_values}}

    #: Device is on a multi-GPU board
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID' in found_values}}

    #: Unique id for a group of devices on the same multi-GPU board
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED' in found_values}}

    #: Link between the device and the host supports all native atomic
    #: operations
    CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO' in found_values}}

    #: Ratio of single precision performance (in floating-point operations
    #: per second) to double precision performance
    CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS' in found_values}}

    #: Device supports coherently accessing pageable memory without calling
    #: cudaHostRegister on it
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS' in found_values}}

    #: Device can coherently access managed memory concurrently with the
    #: CPU
    CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED' in found_values}}

    #: Device supports compute preemption.
    CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM' in found_values}}

    #: Device can access host registered memory at the same virtual address
    #: as the CPU
    CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS_V1' in found_values}}

    #: Deprecated, along with v1 MemOps API, :py:obj:`~.cuStreamBatchMemOp`
    #: and related APIs are supported.
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS_V1 = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS_V1{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V1' in found_values}}

    #: Deprecated, along with v1 MemOps API, 64-bit operations are
    #: supported in :py:obj:`~.cuStreamBatchMemOp` and related APIs.
    CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V1 = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V1{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V1' in found_values}}

    #: Deprecated, along with v1 MemOps API,
    #: :py:obj:`~.CU_STREAM_WAIT_VALUE_NOR` is supported.
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V1 = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V1{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH' in found_values}}

    #: Device supports launching cooperative kernels via
    #: :py:obj:`~.cuLaunchCooperativeKernel`
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH' in found_values}}

    #: Deprecated, :py:obj:`~.cuLaunchCooperativeKernelMultiDevice` is
    #: deprecated.
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN' in found_values}}

    #: Maximum optin shared memory per block
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES' in found_values}}

    #: The :py:obj:`~.CU_STREAM_WAIT_VALUE_FLUSH` flag and the
    #: :py:obj:`~.CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES` MemOp are supported
    #: on the device. See :py:obj:`~.Stream Memory Operations` for
    #: additional details.
    CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED' in found_values}}

    #: Device supports host memory registration via
    #: :py:obj:`~.cudaHostRegister`.
    CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES' in found_values}}

    #: Device accesses pageable memory via the host's page tables.
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST' in found_values}}

    #: The host can directly access managed memory on the device without
    #: migration.
    CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED' in found_values}}

    #: Deprecated, Use
    #: CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED
    CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED' in found_values}}

    #: Device supports virtual memory management APIs like
    #: :py:obj:`~.cuMemAddressReserve`, :py:obj:`~.cuMemCreate`,
    #: :py:obj:`~.cuMemMap` and related APIs
    CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED' in found_values}}

    #: Device supports exporting memory to a posix file descriptor with
    #: :py:obj:`~.cuMemExportToShareableHandle`, if requested via
    #: :py:obj:`~.cuMemCreate`
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED' in found_values}}

    #: Device supports exporting memory to a Win32 NT handle with
    #: :py:obj:`~.cuMemExportToShareableHandle`, if requested via
    #: :py:obj:`~.cuMemCreate`
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED' in found_values}}

    #: Device supports exporting memory to a Win32 KMT handle with
    #: :py:obj:`~.cuMemExportToShareableHandle`, if requested via
    #: :py:obj:`~.cuMemCreate`
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR' in found_values}}

    #: Maximum number of blocks per multiprocessor
    CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED' in found_values}}

    #: Device supports compression of memory
    CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE' in found_values}}

    #: Maximum L2 persisting lines capacity setting in bytes.
    CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE' in found_values}}

    #: Maximum value of :py:obj:`~.CUaccessPolicyWindow.num_bytes`.
    CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED' in found_values}}

    #: Device supports specifying the GPUDirect RDMA flag with
    #: :py:obj:`~.cuMemCreate`
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK' in found_values}}

    #: Shared memory reserved by CUDA driver per block in bytes
    CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED' in found_values}}

    #: Device supports sparse CUDA arrays and sparse CUDA mipmapped arrays
    CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED' in found_values}}

    #: Device supports using the :py:obj:`~.cuMemHostRegister` flag
    #: :py:obj:`~.CU_MEMHOSTERGISTER_READ_ONLY` to register memory that
    #: must be mapped as read-only to the GPU
    CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED' in found_values}}

    #: External timeline semaphore interop is supported on the device
    CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED' in found_values}}

    #: Device supports using the :py:obj:`~.cuMemAllocAsync` and
    #: :py:obj:`~.cuMemPool` family of APIs
    CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED' in found_values}}

    #: Device supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see
    #: https://docs.nvidia.com/cuda/gpudirect-rdma for more information)
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS' in found_values}}

    #: The returned attribute shall be interpreted as a bitmask, where the
    #: individual bits are described by the
    #: :py:obj:`~.CUflushGPUDirectRDMAWritesOptions` enum
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING' in found_values}}

    #: GPUDirect RDMA writes to the device do not need to be flushed for
    #: consumers within the scope indicated by the returned attribute. See
    #: :py:obj:`~.CUGPUDirectRDMAWritesOrdering` for the numerical values
    #: returned here.
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES' in found_values}}

    #: Handle types supported with mempool based IPC
    CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_CLUSTER_LAUNCH' in found_values}}

    #: Indicates device supports cluster launch
    CU_DEVICE_ATTRIBUTE_CLUSTER_LAUNCH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CLUSTER_LAUNCH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED' in found_values}}

    #: Device supports deferred mapping CUDA arrays and CUDA mipmapped
    #: arrays
    CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS' in found_values}}

    #: 64-bit operations are supported in :py:obj:`~.cuStreamBatchMemOp`
    #: and related MemOp APIs.
    CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR' in found_values}}

    #: :py:obj:`~.CU_STREAM_WAIT_VALUE_NOR` is supported by MemOp APIs.
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED' in found_values}}

    #: Device supports buffer sharing with dma_buf mechanism.
    CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED' in found_values}}

    #: Device supports IPC Events.
    CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT' in found_values}}

    #: Number of memory domains the device supports.
    CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_TENSOR_MAP_ACCESS_SUPPORTED' in found_values}}

    #: Device supports accessing memory using Tensor Map.
    CU_DEVICE_ATTRIBUTE_TENSOR_MAP_ACCESS_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_TENSOR_MAP_ACCESS_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_FABRIC_SUPPORTED' in found_values}}

    #: Device supports exporting memory to a fabric handle with
    #: :py:obj:`~.cuMemExportToShareableHandle()` or requested with
    #: :py:obj:`~.cuMemCreate()`
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_FABRIC_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_FABRIC_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_UNIFIED_FUNCTION_POINTERS' in found_values}}

    #: Device supports unified function pointers.
    CU_DEVICE_ATTRIBUTE_UNIFIED_FUNCTION_POINTERS = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_UNIFIED_FUNCTION_POINTERS{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_NUMA_CONFIG' in found_values}}

    #: NUMA configuration of a device: value is of type
    #: :py:obj:`~.CUdeviceNumaConfig` enum
    CU_DEVICE_ATTRIBUTE_NUMA_CONFIG = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_NUMA_CONFIG{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_NUMA_ID' in found_values}}

    #: NUMA node ID of the GPU memory
    CU_DEVICE_ATTRIBUTE_NUMA_ID = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_NUMA_ID{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MULTICAST_SUPPORTED' in found_values}}

    #: Device supports switch multicast and reduction operations.
    CU_DEVICE_ATTRIBUTE_MULTICAST_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MULTICAST_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MPS_ENABLED' in found_values}}

    #: Indicates if contexts created on this device will be shared via MPS
    CU_DEVICE_ATTRIBUTE_MPS_ENABLED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MPS_ENABLED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_HOST_NUMA_ID' in found_values}}

    #: NUMA ID of the host node closest to the device. Returns -1 when
    #: system does not support NUMA.
    CU_DEVICE_ATTRIBUTE_HOST_NUMA_ID = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HOST_NUMA_ID{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_D3D12_CIG_SUPPORTED' in found_values}}

    #: Device supports CIG with D3D12.
    CU_DEVICE_ATTRIBUTE_D3D12_CIG_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_D3D12_CIG_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_ALGORITHM_MASK' in found_values}}

    #: The returned valued shall be interpreted as a bitmask, where the
    #: individual bits are described by the
    #: :py:obj:`~.CUmemDecompressAlgorithm` enum.
    CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_ALGORITHM_MASK = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_ALGORITHM_MASK{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_MAXIMUM_LENGTH' in found_values}}

    #: The returned valued is the maximum length in bytes of a single
    #: decompress operation that is allowed.
    CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_MAXIMUM_LENGTH = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_MAXIMUM_LENGTH{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_VULKAN_CIG_SUPPORTED' in found_values}}

    #: Device supports CIG with Vulkan.
    CU_DEVICE_ATTRIBUTE_VULKAN_CIG_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_VULKAN_CIG_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_GPU_PCI_DEVICE_ID' in found_values}}

    #: The combined 16-bit PCI device ID and 16-bit PCI vendor ID.
    CU_DEVICE_ATTRIBUTE_GPU_PCI_DEVICE_ID = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GPU_PCI_DEVICE_ID{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_GPU_PCI_SUBSYSTEM_ID' in found_values}}

    #: The combined 16-bit PCI subsystem ID and 16-bit PCI subsystem vendor
    #: ID.
    CU_DEVICE_ATTRIBUTE_GPU_PCI_SUBSYSTEM_ID = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GPU_PCI_SUBSYSTEM_ID{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_HOST_NUMA_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED' in found_values}}

    #: Device supports HOST_NUMA location with the virtual memory
    #: management APIs like :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemMap`
    #: and related APIs
    CU_DEVICE_ATTRIBUTE_HOST_NUMA_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HOST_NUMA_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_HOST_NUMA_MEMORY_POOLS_SUPPORTED' in found_values}}

    #: Device supports HOST_NUMA location with the
    #: :py:obj:`~.cuMemAllocAsync` and :py:obj:`~.cuMemPool` family of APIs
    CU_DEVICE_ATTRIBUTE_HOST_NUMA_MEMORY_POOLS_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HOST_NUMA_MEMORY_POOLS_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_HOST_NUMA_MULTINODE_IPC_SUPPORTED' in found_values}}

    #: Device supports HOST_NUMA location IPC between nodes in a multi-node
    #: system.
    CU_DEVICE_ATTRIBUTE_HOST_NUMA_MULTINODE_IPC_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HOST_NUMA_MULTINODE_IPC_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_HOST_MEMORY_POOLS_SUPPORTED' in found_values}}

    #: Device suports HOST location with the :py:obj:`~.cuMemAllocAsync`
    #: and :py:obj:`~.cuMemPool` family of APIs
    CU_DEVICE_ATTRIBUTE_HOST_MEMORY_POOLS_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HOST_MEMORY_POOLS_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_HOST_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED' in found_values}}

    #: Device supports HOST location with the virtual memory management
    #: APIs like :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemMap` and related
    #: APIs
    CU_DEVICE_ATTRIBUTE_HOST_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HOST_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_HOST_ALLOC_DMA_BUF_SUPPORTED' in found_values}}

    #: Device supports page-locked host memory buffer sharing with dma_buf
    #: mechanism.
    CU_DEVICE_ATTRIBUTE_HOST_ALLOC_DMA_BUF_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HOST_ALLOC_DMA_BUF_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_ONLY_PARTIAL_HOST_NATIVE_ATOMIC_SUPPORTED' in found_values}}

    #: Link between the device and the host supports only some native
    #: atomic operations
    CU_DEVICE_ATTRIBUTE_ONLY_PARTIAL_HOST_NATIVE_ATOMIC_SUPPORTED = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_ONLY_PARTIAL_HOST_NATIVE_ATOMIC_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_ATTRIBUTE_MAX' in found_values}}
    CU_DEVICE_ATTRIBUTE_MAX = cydriver.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX{{endif}}

_dict_CUdevice_attribute = dict(((int(v), v) for k, v in CUdevice_attribute.__members__.items()))
{{endif}}
{{if 'CUpointer_attribute_enum' in found_types}}

class CUpointer_attribute(IntEnum):
    """
    Pointer information
    """
    {{if 'CU_POINTER_ATTRIBUTE_CONTEXT' in found_values}}

    #: The :py:obj:`~.CUcontext` on which a pointer was allocated or
    #: registered
    CU_POINTER_ATTRIBUTE_CONTEXT = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_CONTEXT{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_MEMORY_TYPE' in found_values}}

    #: The :py:obj:`~.CUmemorytype` describing the physical location of a
    #: pointer
    CU_POINTER_ATTRIBUTE_MEMORY_TYPE = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_MEMORY_TYPE{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_DEVICE_POINTER' in found_values}}

    #: The address at which a pointer's memory may be accessed on the
    #: device
    CU_POINTER_ATTRIBUTE_DEVICE_POINTER = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_DEVICE_POINTER{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_HOST_POINTER' in found_values}}

    #: The address at which a pointer's memory may be accessed on the host
    CU_POINTER_ATTRIBUTE_HOST_POINTER = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_HOST_POINTER{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_P2P_TOKENS' in found_values}}

    #: A pair of tokens for use with the nv-p2p.h Linux kernel interface
    CU_POINTER_ATTRIBUTE_P2P_TOKENS = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_P2P_TOKENS{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_SYNC_MEMOPS' in found_values}}

    #: Synchronize every synchronous memory operation initiated on this
    #: region
    CU_POINTER_ATTRIBUTE_SYNC_MEMOPS = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_SYNC_MEMOPS{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_BUFFER_ID' in found_values}}

    #: A process-wide unique ID for an allocated memory region
    CU_POINTER_ATTRIBUTE_BUFFER_ID = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_BUFFER_ID{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_IS_MANAGED' in found_values}}

    #: Indicates if the pointer points to managed memory
    CU_POINTER_ATTRIBUTE_IS_MANAGED = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_IS_MANAGED{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL' in found_values}}

    #: A device ordinal of a device on which a pointer was allocated or
    #: registered
    CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE' in found_values}}

    #: 1 if this pointer maps to an allocation that is suitable for
    #: :py:obj:`~.cudaIpcGetMemHandle`, 0 otherwise
    CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_RANGE_START_ADDR' in found_values}}

    #: Starting address for this requested pointer
    CU_POINTER_ATTRIBUTE_RANGE_START_ADDR = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_RANGE_START_ADDR{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_RANGE_SIZE' in found_values}}

    #: Size of the address range for this requested pointer
    CU_POINTER_ATTRIBUTE_RANGE_SIZE = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_RANGE_SIZE{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_MAPPED' in found_values}}

    #: 1 if this pointer is in a valid address range that is mapped to a
    #: backing allocation, 0 otherwise
    CU_POINTER_ATTRIBUTE_MAPPED = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_MAPPED{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES' in found_values}}

    #: Bitmask of allowed :py:obj:`~.CUmemAllocationHandleType` for this
    #: allocation
    CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE' in found_values}}

    #: 1 if the memory this pointer is referencing can be used with the
    #: GPUDirect RDMA API
    CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_ACCESS_FLAGS' in found_values}}

    #: Returns the access flags the device associated with the current
    #: context has on the corresponding memory referenced by the pointer
    #: given
    CU_POINTER_ATTRIBUTE_ACCESS_FLAGS = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_ACCESS_FLAGS{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE' in found_values}}

    #: Returns the mempool handle for the allocation if it was allocated
    #: from a mempool. Otherwise returns NULL.
    CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_MAPPING_SIZE' in found_values}}

    #: Size of the actual underlying mapping that the pointer belongs to
    CU_POINTER_ATTRIBUTE_MAPPING_SIZE = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_MAPPING_SIZE{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_MAPPING_BASE_ADDR' in found_values}}

    #: The start address of the mapping that the pointer belongs to
    CU_POINTER_ATTRIBUTE_MAPPING_BASE_ADDR = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_MAPPING_BASE_ADDR{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_MEMORY_BLOCK_ID' in found_values}}

    #: A process-wide unique id corresponding to the physical allocation
    #: the pointer belongs to
    CU_POINTER_ATTRIBUTE_MEMORY_BLOCK_ID = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_MEMORY_BLOCK_ID{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE' in found_values}}

    #: Returns in `*data` a boolean that indicates whether the pointer
    #: points to memory that is capable to be used for hardware accelerated
    #: decompression.
    CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE = cydriver.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE{{endif}}

_dict_CUpointer_attribute = dict(((int(v), v) for k, v in CUpointer_attribute.__members__.items()))
{{endif}}
{{if 'CUfunction_attribute_enum' in found_types}}

class CUfunction_attribute(IntEnum):
    """
    Function properties
    """
    {{if 'CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK' in found_values}}

    #: The maximum number of threads per block, beyond which a launch of
    #: the function would fail. This number depends on both the function
    #: and the device on which the function is currently loaded.
    CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = cydriver.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK{{endif}}
    {{if 'CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES' in found_values}}

    #: The size in bytes of statically-allocated shared memory required by
    #: this function. This does not include dynamically-allocated shared
    #: memory requested by the user at runtime.
    CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = cydriver.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES{{endif}}
    {{if 'CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES' in found_values}}

    #: The size in bytes of user-allocated constant memory required by this
    #: function.
    CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = cydriver.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES{{endif}}
    {{if 'CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES' in found_values}}

    #: The size in bytes of local memory used by each thread of this
    #: function.
    CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = cydriver.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES{{endif}}
    {{if 'CU_FUNC_ATTRIBUTE_NUM_REGS' in found_values}}

    #: The number of registers used by each thread of this function.
    CU_FUNC_ATTRIBUTE_NUM_REGS = cydriver.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_NUM_REGS{{endif}}
    {{if 'CU_FUNC_ATTRIBUTE_PTX_VERSION' in found_values}}

    #: The PTX virtual architecture version for which the function was
    #: compiled. This value is the major PTX version * 10 + the minor PTX
    #: version, so a PTX version 1.3 function would return the value 13.
    #: Note that this may return the undefined value of 0 for cubins
    #: compiled prior to CUDA 3.0.
    CU_FUNC_ATTRIBUTE_PTX_VERSION = cydriver.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_PTX_VERSION{{endif}}
    {{if 'CU_FUNC_ATTRIBUTE_BINARY_VERSION' in found_values}}

    #: The binary architecture version for which the function was compiled.
    #: This value is the major binary version * 10 + the minor binary
    #: version, so a binary version 1.3 function would return the value 13.
    #: Note that this will return a value of 10 for legacy cubins that do
    #: not have a properly-encoded binary architecture version.
    CU_FUNC_ATTRIBUTE_BINARY_VERSION = cydriver.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_BINARY_VERSION{{endif}}
    {{if 'CU_FUNC_ATTRIBUTE_CACHE_MODE_CA' in found_values}}

    #: The attribute to indicate whether the function has been compiled
    #: with user specified option "-Xptxas --dlcm=ca" set .
    CU_FUNC_ATTRIBUTE_CACHE_MODE_CA = cydriver.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_CACHE_MODE_CA{{endif}}
    {{if 'CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES' in found_values}}

    #: The maximum size in bytes of dynamically-allocated shared memory
    #: that can be used by this function. If the user-specified dynamic
    #: shared memory size is larger than this value, the launch will fail.
    #: The default value of this attribute is
    #: :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK` -
    #: :py:obj:`~.CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES`, except when
    #: :py:obj:`~.CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES` is greater than
    #: :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK`, then
    #: the default value of this attribute is 0. The value can be increased
    #: to :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN`
    #: - :py:obj:`~.CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES`. See
    #: :py:obj:`~.cuFuncSetAttribute`, :py:obj:`~.cuKernelSetAttribute`
    CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = cydriver.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES{{endif}}
    {{if 'CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT' in found_values}}

    #: On devices where the L1 cache and shared memory use the same
    #: hardware resources, this sets the shared memory carveout preference,
    #: in percent of the total shared memory. Refer to
    #: :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR`.
    #: This is only a hint, and the driver can choose a different ratio if
    #: required to execute the function. See
    #: :py:obj:`~.cuFuncSetAttribute`, :py:obj:`~.cuKernelSetAttribute`
    CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = cydriver.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT{{endif}}
    {{if 'CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET' in found_values}}

    #: If this attribute is set, the kernel must launch with a valid
    #: cluster size specified. See :py:obj:`~.cuFuncSetAttribute`,
    #: :py:obj:`~.cuKernelSetAttribute`
    CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET = cydriver.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET{{endif}}
    {{if 'CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH' in found_values}}

    #: The required cluster width in blocks. The values must either all be
    #: 0 or all be positive. The validity of the cluster dimensions is
    #: otherwise checked at launch time.
    #:
    #: If the value is set during compile time, it cannot be set at
    #: runtime. Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.
    #: See :py:obj:`~.cuFuncSetAttribute`, :py:obj:`~.cuKernelSetAttribute`
    CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH = cydriver.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH{{endif}}
    {{if 'CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT' in found_values}}

    #: The required cluster height in blocks. The values must either all be
    #: 0 or all be positive. The validity of the cluster dimensions is
    #: otherwise checked at launch time.
    #:
    #: If the value is set during compile time, it cannot be set at
    #: runtime. Setting it at runtime should return
    #: CUDA_ERROR_NOT_PERMITTED. See :py:obj:`~.cuFuncSetAttribute`,
    #: :py:obj:`~.cuKernelSetAttribute`
    CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT = cydriver.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT{{endif}}
    {{if 'CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH' in found_values}}

    #: The required cluster depth in blocks. The values must either all be
    #: 0 or all be positive. The validity of the cluster dimensions is
    #: otherwise checked at launch time.
    #:
    #: If the value is set during compile time, it cannot be set at
    #: runtime. Setting it at runtime should return
    #: CUDA_ERROR_NOT_PERMITTED. See :py:obj:`~.cuFuncSetAttribute`,
    #: :py:obj:`~.cuKernelSetAttribute`
    CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH = cydriver.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH{{endif}}
    {{if 'CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED' in found_values}}

    #: Whether the function can be launched with non-portable cluster size.
    #: 1 is allowed, 0 is disallowed. A non-portable cluster size may only
    #: function on the specific SKUs the program is tested on. The launch
    #: might fail if the program is run on a different hardware platform.
    #:
    #: CUDA API provides cudaOccupancyMaxActiveClusters to assist with
    #: checking whether the desired size can be launched on the current
    #: device.
    #:
    #: Portable Cluster Size
    #:
    #: A portable cluster size is guaranteed to be functional on all
    #: compute capabilities higher than the target compute capability. The
    #: portable cluster size for sm_90 is 8 blocks per cluster. This value
    #: may increase for future compute capabilities.
    #:
    #: The specific hardware unit may support higher cluster sizes thats
    #: not guaranteed to be portable. See :py:obj:`~.cuFuncSetAttribute`,
    #: :py:obj:`~.cuKernelSetAttribute`
    CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED = cydriver.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED{{endif}}
    {{if 'CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE' in found_values}}

    #: The block scheduling policy of a function. The value type is
    #: CUclusterSchedulingPolicy / cudaClusterSchedulingPolicy. See
    #: :py:obj:`~.cuFuncSetAttribute`, :py:obj:`~.cuKernelSetAttribute`
    CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE = cydriver.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE{{endif}}
    {{if 'CU_FUNC_ATTRIBUTE_MAX' in found_values}}
    CU_FUNC_ATTRIBUTE_MAX = cydriver.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_MAX{{endif}}

_dict_CUfunction_attribute = dict(((int(v), v) for k, v in CUfunction_attribute.__members__.items()))
{{endif}}
{{if 'CUfunc_cache_enum' in found_types}}

class CUfunc_cache(IntEnum):
    """
    Function cache configurations
    """
    {{if 'CU_FUNC_CACHE_PREFER_NONE' in found_values}}

    #: no preference for shared memory or L1 (default)
    CU_FUNC_CACHE_PREFER_NONE = cydriver.CUfunc_cache_enum.CU_FUNC_CACHE_PREFER_NONE{{endif}}
    {{if 'CU_FUNC_CACHE_PREFER_SHARED' in found_values}}

    #: prefer larger shared memory and smaller L1 cache
    CU_FUNC_CACHE_PREFER_SHARED = cydriver.CUfunc_cache_enum.CU_FUNC_CACHE_PREFER_SHARED{{endif}}
    {{if 'CU_FUNC_CACHE_PREFER_L1' in found_values}}

    #: prefer larger L1 cache and smaller shared memory
    CU_FUNC_CACHE_PREFER_L1 = cydriver.CUfunc_cache_enum.CU_FUNC_CACHE_PREFER_L1{{endif}}
    {{if 'CU_FUNC_CACHE_PREFER_EQUAL' in found_values}}

    #: prefer equal sized L1 cache and shared memory
    CU_FUNC_CACHE_PREFER_EQUAL = cydriver.CUfunc_cache_enum.CU_FUNC_CACHE_PREFER_EQUAL{{endif}}

_dict_CUfunc_cache = dict(((int(v), v) for k, v in CUfunc_cache.__members__.items()))
{{endif}}
{{if 'CUsharedconfig_enum' in found_types}}

class CUsharedconfig(IntEnum):
    """
    [Deprecated]  Shared memory configurations
    """
    {{if 'CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE' in found_values}}

    #: set default shared memory bank size
    CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE = cydriver.CUsharedconfig_enum.CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE{{endif}}
    {{if 'CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE' in found_values}}

    #: set shared memory bank width to four bytes
    CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE = cydriver.CUsharedconfig_enum.CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE{{endif}}
    {{if 'CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE' in found_values}}

    #: set shared memory bank width to eight bytes
    CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE = cydriver.CUsharedconfig_enum.CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE{{endif}}

_dict_CUsharedconfig = dict(((int(v), v) for k, v in CUsharedconfig.__members__.items()))
{{endif}}
{{if 'CUshared_carveout_enum' in found_types}}

class CUshared_carveout(IntEnum):
    """
    Shared memory carveout configurations. These may be passed to
    :py:obj:`~.cuFuncSetAttribute` or :py:obj:`~.cuKernelSetAttribute`
    """
    {{if 'CU_SHAREDMEM_CARVEOUT_DEFAULT' in found_values}}

    #: No preference for shared memory or L1 (default)
    CU_SHAREDMEM_CARVEOUT_DEFAULT = cydriver.CUshared_carveout_enum.CU_SHAREDMEM_CARVEOUT_DEFAULT{{endif}}
    {{if 'CU_SHAREDMEM_CARVEOUT_MAX_L1' in found_values}}

    #: Prefer maximum available L1 cache, minimum shared memory
    CU_SHAREDMEM_CARVEOUT_MAX_L1 = cydriver.CUshared_carveout_enum.CU_SHAREDMEM_CARVEOUT_MAX_L1{{endif}}
    {{if 'CU_SHAREDMEM_CARVEOUT_MAX_SHARED' in found_values}}

    #: Prefer maximum available shared memory, minimum L1 cache
    CU_SHAREDMEM_CARVEOUT_MAX_SHARED = cydriver.CUshared_carveout_enum.CU_SHAREDMEM_CARVEOUT_MAX_SHARED{{endif}}

_dict_CUshared_carveout = dict(((int(v), v) for k, v in CUshared_carveout.__members__.items()))
{{endif}}
{{if 'CUmemorytype_enum' in found_types}}

class CUmemorytype(IntEnum):
    """
    Memory types
    """
    {{if 'CU_MEMORYTYPE_HOST' in found_values}}

    #: Host memory
    CU_MEMORYTYPE_HOST = cydriver.CUmemorytype_enum.CU_MEMORYTYPE_HOST{{endif}}
    {{if 'CU_MEMORYTYPE_DEVICE' in found_values}}

    #: Device memory
    CU_MEMORYTYPE_DEVICE = cydriver.CUmemorytype_enum.CU_MEMORYTYPE_DEVICE{{endif}}
    {{if 'CU_MEMORYTYPE_ARRAY' in found_values}}

    #: Array memory
    CU_MEMORYTYPE_ARRAY = cydriver.CUmemorytype_enum.CU_MEMORYTYPE_ARRAY{{endif}}
    {{if 'CU_MEMORYTYPE_UNIFIED' in found_values}}

    #: Unified device or host memory
    CU_MEMORYTYPE_UNIFIED = cydriver.CUmemorytype_enum.CU_MEMORYTYPE_UNIFIED{{endif}}

_dict_CUmemorytype = dict(((int(v), v) for k, v in CUmemorytype.__members__.items()))
{{endif}}
{{if 'CUcomputemode_enum' in found_types}}

class CUcomputemode(IntEnum):
    """
    Compute Modes
    """
    {{if 'CU_COMPUTEMODE_DEFAULT' in found_values}}

    #: Default compute mode (Multiple contexts allowed per device)
    CU_COMPUTEMODE_DEFAULT = cydriver.CUcomputemode_enum.CU_COMPUTEMODE_DEFAULT{{endif}}
    {{if 'CU_COMPUTEMODE_PROHIBITED' in found_values}}

    #: Compute-prohibited mode (No contexts can be created on this device
    #: at this time)
    CU_COMPUTEMODE_PROHIBITED = cydriver.CUcomputemode_enum.CU_COMPUTEMODE_PROHIBITED{{endif}}
    {{if 'CU_COMPUTEMODE_EXCLUSIVE_PROCESS' in found_values}}

    #: Compute-exclusive-process mode (Only one context used by a single
    #: process can be present on this device at a time)
    CU_COMPUTEMODE_EXCLUSIVE_PROCESS = cydriver.CUcomputemode_enum.CU_COMPUTEMODE_EXCLUSIVE_PROCESS{{endif}}

_dict_CUcomputemode = dict(((int(v), v) for k, v in CUcomputemode.__members__.items()))
{{endif}}
{{if 'CUmem_advise_enum' in found_types}}

class CUmem_advise(IntEnum):
    """
    Memory advise values
    """
    {{if 'CU_MEM_ADVISE_SET_READ_MOSTLY' in found_values}}

    #: Data will mostly be read and only occasionally be written to
    CU_MEM_ADVISE_SET_READ_MOSTLY = cydriver.CUmem_advise_enum.CU_MEM_ADVISE_SET_READ_MOSTLY{{endif}}
    {{if 'CU_MEM_ADVISE_UNSET_READ_MOSTLY' in found_values}}

    #: Undo the effect of :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY`
    CU_MEM_ADVISE_UNSET_READ_MOSTLY = cydriver.CUmem_advise_enum.CU_MEM_ADVISE_UNSET_READ_MOSTLY{{endif}}
    {{if 'CU_MEM_ADVISE_SET_PREFERRED_LOCATION' in found_values}}

    #: Set the preferred location for the data as the specified device
    CU_MEM_ADVISE_SET_PREFERRED_LOCATION = cydriver.CUmem_advise_enum.CU_MEM_ADVISE_SET_PREFERRED_LOCATION{{endif}}
    {{if 'CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION' in found_values}}

    #: Clear the preferred location for the data
    CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION = cydriver.CUmem_advise_enum.CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION{{endif}}
    {{if 'CU_MEM_ADVISE_SET_ACCESSED_BY' in found_values}}

    #: Data will be accessed by the specified device, so prevent page
    #: faults as much as possible
    CU_MEM_ADVISE_SET_ACCESSED_BY = cydriver.CUmem_advise_enum.CU_MEM_ADVISE_SET_ACCESSED_BY{{endif}}
    {{if 'CU_MEM_ADVISE_UNSET_ACCESSED_BY' in found_values}}

    #: Let the Unified Memory subsystem decide on the page faulting policy
    #: for the specified device
    CU_MEM_ADVISE_UNSET_ACCESSED_BY = cydriver.CUmem_advise_enum.CU_MEM_ADVISE_UNSET_ACCESSED_BY{{endif}}

_dict_CUmem_advise = dict(((int(v), v) for k, v in CUmem_advise.__members__.items()))
{{endif}}
{{if 'CUmem_range_attribute_enum' in found_types}}

class CUmem_range_attribute(IntEnum):
    """

    """
    {{if 'CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY' in found_values}}

    #: Whether the range will mostly be read and only occasionally be
    #: written to
    CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY = cydriver.CUmem_range_attribute_enum.CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY{{endif}}
    {{if 'CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION' in found_values}}

    #: The preferred location of the range
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION = cydriver.CUmem_range_attribute_enum.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION{{endif}}
    {{if 'CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY' in found_values}}

    #: Memory range has :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY` set for
    #: specified device
    CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY = cydriver.CUmem_range_attribute_enum.CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY{{endif}}
    {{if 'CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION' in found_values}}

    #: The last location to which the range was prefetched
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION = cydriver.CUmem_range_attribute_enum.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION{{endif}}
    {{if 'CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE' in found_values}}

    #: The preferred location type of the range
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE = cydriver.CUmem_range_attribute_enum.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE{{endif}}
    {{if 'CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_ID' in found_values}}

    #: The preferred location id of the range
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_ID = cydriver.CUmem_range_attribute_enum.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_ID{{endif}}
    {{if 'CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE' in found_values}}

    #: The last location type to which the range was prefetched
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE = cydriver.CUmem_range_attribute_enum.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE{{endif}}
    {{if 'CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_ID' in found_values}}

    #: The last location id to which the range was prefetched
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_ID = cydriver.CUmem_range_attribute_enum.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_ID{{endif}}

_dict_CUmem_range_attribute = dict(((int(v), v) for k, v in CUmem_range_attribute.__members__.items()))
{{endif}}
{{if 'CUjit_option_enum' in found_types}}

class CUjit_option(IntEnum):
    """
    Online compiler and linker options
    """
    {{if 'CU_JIT_MAX_REGISTERS' in found_values}}

    #: Max number of registers that a thread may use.
    #: Option type: unsigned int
    #: Applies to: compiler only
    CU_JIT_MAX_REGISTERS = cydriver.CUjit_option_enum.CU_JIT_MAX_REGISTERS{{endif}}
    {{if 'CU_JIT_THREADS_PER_BLOCK' in found_values}}

    #: IN: Specifies minimum number of threads per block to target
    #: compilation for
    #: OUT: Returns the number of threads the compiler actually targeted.
    #: This restricts the resource utilization of the compiler (e.g. max
    #: registers) such that a block with the given number of threads should
    #: be able to launch based on register limitations. Note, this option
    #: does not currently take into account any other resource limitations,
    #: such as shared memory utilization.
    #: Cannot be combined with :py:obj:`~.CU_JIT_TARGET`.
    #: Option type: unsigned int
    #: Applies to: compiler only
    CU_JIT_THREADS_PER_BLOCK = cydriver.CUjit_option_enum.CU_JIT_THREADS_PER_BLOCK{{endif}}
    {{if 'CU_JIT_WALL_TIME' in found_values}}

    #: Overwrites the option value with the total wall clock time, in
    #: milliseconds, spent in the compiler and linker
    #: Option type: float
    #: Applies to: compiler and linker
    CU_JIT_WALL_TIME = cydriver.CUjit_option_enum.CU_JIT_WALL_TIME{{endif}}
    {{if 'CU_JIT_INFO_LOG_BUFFER' in found_values}}

    #: Pointer to a buffer in which to print any log messages that are
    #: informational in nature (the buffer size is specified via option
    #: :py:obj:`~.CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES`)
    #: Option type: char *
    #: Applies to: compiler and linker
    CU_JIT_INFO_LOG_BUFFER = cydriver.CUjit_option_enum.CU_JIT_INFO_LOG_BUFFER{{endif}}
    {{if 'CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES' in found_values}}

    #: IN: Log buffer size in bytes. Log messages will be capped at this
    #: size (including null terminator)
    #: OUT: Amount of log buffer filled with messages
    #: Option type: unsigned int
    #: Applies to: compiler and linker
    CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES = cydriver.CUjit_option_enum.CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES{{endif}}
    {{if 'CU_JIT_ERROR_LOG_BUFFER' in found_values}}

    #: Pointer to a buffer in which to print any log messages that reflect
    #: errors (the buffer size is specified via option
    #: :py:obj:`~.CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES`)
    #: Option type: char *
    #: Applies to: compiler and linker
    CU_JIT_ERROR_LOG_BUFFER = cydriver.CUjit_option_enum.CU_JIT_ERROR_LOG_BUFFER{{endif}}
    {{if 'CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES' in found_values}}

    #: IN: Log buffer size in bytes. Log messages will be capped at this
    #: size (including null terminator)
    #: OUT: Amount of log buffer filled with messages
    #: Option type: unsigned int
    #: Applies to: compiler and linker
    CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES = cydriver.CUjit_option_enum.CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES{{endif}}
    {{if 'CU_JIT_OPTIMIZATION_LEVEL' in found_values}}

    #: Level of optimizations to apply to generated code (0 - 4), with 4
    #: being the default and highest level of optimizations.
    #: Option type: unsigned int
    #: Applies to: compiler only
    CU_JIT_OPTIMIZATION_LEVEL = cydriver.CUjit_option_enum.CU_JIT_OPTIMIZATION_LEVEL{{endif}}
    {{if 'CU_JIT_TARGET_FROM_CUCONTEXT' in found_values}}

    #: No option value required. Determines the target based on the current
    #: attached context (default)
    #: Option type: No option value needed
    #: Applies to: compiler and linker
    CU_JIT_TARGET_FROM_CUCONTEXT = cydriver.CUjit_option_enum.CU_JIT_TARGET_FROM_CUCONTEXT{{endif}}
    {{if 'CU_JIT_TARGET' in found_values}}

    #: Target is chosen based on supplied :py:obj:`~.CUjit_target`. Cannot
    #: be combined with :py:obj:`~.CU_JIT_THREADS_PER_BLOCK`.
    #: Option type: unsigned int for enumerated type
    #: :py:obj:`~.CUjit_target`
    #: Applies to: compiler and linker
    CU_JIT_TARGET = cydriver.CUjit_option_enum.CU_JIT_TARGET{{endif}}
    {{if 'CU_JIT_FALLBACK_STRATEGY' in found_values}}

    #: Specifies choice of fallback strategy if matching cubin is not
    #: found. Choice is based on supplied :py:obj:`~.CUjit_fallback`. This
    #: option cannot be used with cuLink* APIs as the linker requires exact
    #: matches.
    #: Option type: unsigned int for enumerated type
    #: :py:obj:`~.CUjit_fallback`
    #: Applies to: compiler only
    CU_JIT_FALLBACK_STRATEGY = cydriver.CUjit_option_enum.CU_JIT_FALLBACK_STRATEGY{{endif}}
    {{if 'CU_JIT_GENERATE_DEBUG_INFO' in found_values}}

    #: Specifies whether to create debug information in output (-g) (0:
    #: false, default)
    #: Option type: int
    #: Applies to: compiler and linker
    CU_JIT_GENERATE_DEBUG_INFO = cydriver.CUjit_option_enum.CU_JIT_GENERATE_DEBUG_INFO{{endif}}
    {{if 'CU_JIT_LOG_VERBOSE' in found_values}}

    #: Generate verbose log messages (0: false, default)
    #: Option type: int
    #: Applies to: compiler and linker
    CU_JIT_LOG_VERBOSE = cydriver.CUjit_option_enum.CU_JIT_LOG_VERBOSE{{endif}}
    {{if 'CU_JIT_GENERATE_LINE_INFO' in found_values}}

    #: Generate line number information (-lineinfo) (0: false, default)
    #: Option type: int
    #: Applies to: compiler only
    CU_JIT_GENERATE_LINE_INFO = cydriver.CUjit_option_enum.CU_JIT_GENERATE_LINE_INFO{{endif}}
    {{if 'CU_JIT_CACHE_MODE' in found_values}}

    #: Specifies whether to enable caching explicitly (-dlcm)
    #: Choice is based on supplied :py:obj:`~.CUjit_cacheMode_enum`.
    #: Option type: unsigned int for enumerated type
    #: :py:obj:`~.CUjit_cacheMode_enum`
    #: Applies to: compiler only
    CU_JIT_CACHE_MODE = cydriver.CUjit_option_enum.CU_JIT_CACHE_MODE{{endif}}
    {{if 'CU_JIT_NEW_SM3X_OPT' in found_values}}

    #: [Deprecated]
    CU_JIT_NEW_SM3X_OPT = cydriver.CUjit_option_enum.CU_JIT_NEW_SM3X_OPT{{endif}}
    {{if 'CU_JIT_FAST_COMPILE' in found_values}}

    #: This jit option is used for internal purpose only.
    CU_JIT_FAST_COMPILE = cydriver.CUjit_option_enum.CU_JIT_FAST_COMPILE{{endif}}
    {{if 'CU_JIT_GLOBAL_SYMBOL_NAMES' in found_values}}

    #: Array of device symbol names that will be relocated to the
    #: corresponding host addresses stored in
    #: :py:obj:`~.CU_JIT_GLOBAL_SYMBOL_ADDRESSES`.
    #: Must contain :py:obj:`~.CU_JIT_GLOBAL_SYMBOL_COUNT` entries.
    #: When loading a device module, driver will relocate all encountered
    #: unresolved symbols to the host addresses.
    #: It is only allowed to register symbols that correspond to unresolved
    #: global variables.
    #: It is illegal to register the same device symbol at multiple
    #: addresses.
    #: Option type: const char **
    #: Applies to: dynamic linker only
    CU_JIT_GLOBAL_SYMBOL_NAMES = cydriver.CUjit_option_enum.CU_JIT_GLOBAL_SYMBOL_NAMES{{endif}}
    {{if 'CU_JIT_GLOBAL_SYMBOL_ADDRESSES' in found_values}}

    #: Array of host addresses that will be used to relocate corresponding
    #: device symbols stored in :py:obj:`~.CU_JIT_GLOBAL_SYMBOL_NAMES`.
    #: Must contain :py:obj:`~.CU_JIT_GLOBAL_SYMBOL_COUNT` entries.
    #: Option type: void **
    #: Applies to: dynamic linker only
    CU_JIT_GLOBAL_SYMBOL_ADDRESSES = cydriver.CUjit_option_enum.CU_JIT_GLOBAL_SYMBOL_ADDRESSES{{endif}}
    {{if 'CU_JIT_GLOBAL_SYMBOL_COUNT' in found_values}}

    #: Number of entries in :py:obj:`~.CU_JIT_GLOBAL_SYMBOL_NAMES` and
    #: :py:obj:`~.CU_JIT_GLOBAL_SYMBOL_ADDRESSES` arrays.
    #: Option type: unsigned int
    #: Applies to: dynamic linker only
    CU_JIT_GLOBAL_SYMBOL_COUNT = cydriver.CUjit_option_enum.CU_JIT_GLOBAL_SYMBOL_COUNT{{endif}}
    {{if 'CU_JIT_LTO' in found_values}}

    #: [Deprecated]
    #:
    #: Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0
    CU_JIT_LTO = cydriver.CUjit_option_enum.CU_JIT_LTO{{endif}}
    {{if 'CU_JIT_FTZ' in found_values}}

    #: [Deprecated]
    #:
    #: Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0
    CU_JIT_FTZ = cydriver.CUjit_option_enum.CU_JIT_FTZ{{endif}}
    {{if 'CU_JIT_PREC_DIV' in found_values}}

    #: [Deprecated]
    #:
    #: Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0
    CU_JIT_PREC_DIV = cydriver.CUjit_option_enum.CU_JIT_PREC_DIV{{endif}}
    {{if 'CU_JIT_PREC_SQRT' in found_values}}

    #: [Deprecated]
    #:
    #: Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0
    CU_JIT_PREC_SQRT = cydriver.CUjit_option_enum.CU_JIT_PREC_SQRT{{endif}}
    {{if 'CU_JIT_FMA' in found_values}}

    #: [Deprecated]
    #:
    #: Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0
    CU_JIT_FMA = cydriver.CUjit_option_enum.CU_JIT_FMA{{endif}}
    {{if 'CU_JIT_REFERENCED_KERNEL_NAMES' in found_values}}

    #: [Deprecated]
    #:
    #: Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0
    CU_JIT_REFERENCED_KERNEL_NAMES = cydriver.CUjit_option_enum.CU_JIT_REFERENCED_KERNEL_NAMES{{endif}}
    {{if 'CU_JIT_REFERENCED_KERNEL_COUNT' in found_values}}

    #: [Deprecated]
    #:
    #: Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0
    CU_JIT_REFERENCED_KERNEL_COUNT = cydriver.CUjit_option_enum.CU_JIT_REFERENCED_KERNEL_COUNT{{endif}}
    {{if 'CU_JIT_REFERENCED_VARIABLE_NAMES' in found_values}}

    #: [Deprecated]
    #:
    #: Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0
    CU_JIT_REFERENCED_VARIABLE_NAMES = cydriver.CUjit_option_enum.CU_JIT_REFERENCED_VARIABLE_NAMES{{endif}}
    {{if 'CU_JIT_REFERENCED_VARIABLE_COUNT' in found_values}}

    #: [Deprecated]
    #:
    #: Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0
    CU_JIT_REFERENCED_VARIABLE_COUNT = cydriver.CUjit_option_enum.CU_JIT_REFERENCED_VARIABLE_COUNT{{endif}}
    {{if 'CU_JIT_OPTIMIZE_UNUSED_DEVICE_VARIABLES' in found_values}}

    #: [Deprecated]
    #:
    #: Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0
    CU_JIT_OPTIMIZE_UNUSED_DEVICE_VARIABLES = cydriver.CUjit_option_enum.CU_JIT_OPTIMIZE_UNUSED_DEVICE_VARIABLES{{endif}}
    {{if 'CU_JIT_POSITION_INDEPENDENT_CODE' in found_values}}

    #: Generate position independent code (0: false)
    #: Option type: int
    #: Applies to: compiler only
    CU_JIT_POSITION_INDEPENDENT_CODE = cydriver.CUjit_option_enum.CU_JIT_POSITION_INDEPENDENT_CODE{{endif}}
    {{if 'CU_JIT_MIN_CTA_PER_SM' in found_values}}

    #: This option hints to the JIT compiler the minimum number of CTAs
    #: from the kernels grid to be mapped to a SM. This option is ignored
    #: when used together with :py:obj:`~.CU_JIT_MAX_REGISTERS` or
    #: :py:obj:`~.CU_JIT_THREADS_PER_BLOCK`. Optimizations based on this
    #: option need :py:obj:`~.CU_JIT_MAX_THREADS_PER_BLOCK` to be specified
    #: as well. For kernels already using PTX directive .minnctapersm, this
    #: option will be ignored by default. Use
    #: :py:obj:`~.CU_JIT_OVERRIDE_DIRECTIVE_VALUES` to let this option take
    #: precedence over the PTX directive. Option type: unsigned int
    #: Applies to: compiler only
    CU_JIT_MIN_CTA_PER_SM = cydriver.CUjit_option_enum.CU_JIT_MIN_CTA_PER_SM{{endif}}
    {{if 'CU_JIT_MAX_THREADS_PER_BLOCK' in found_values}}

    #: Maximum number threads in a thread block, computed as the product of
    #: the maximum extent specifed for each dimension of the block. This
    #: limit is guaranteed not to be exeeded in any invocation of the
    #: kernel. Exceeding the the maximum number of threads results in
    #: runtime error or kernel launch failure. For kernels already using
    #: PTX directive .maxntid, this option will be ignored by default. Use
    #: :py:obj:`~.CU_JIT_OVERRIDE_DIRECTIVE_VALUES` to let this option take
    #: precedence over the PTX directive. Option type: int
    #: Applies to: compiler only
    CU_JIT_MAX_THREADS_PER_BLOCK = cydriver.CUjit_option_enum.CU_JIT_MAX_THREADS_PER_BLOCK{{endif}}
    {{if 'CU_JIT_OVERRIDE_DIRECTIVE_VALUES' in found_values}}

    #: This option lets the values specified using
    #: :py:obj:`~.CU_JIT_MAX_REGISTERS`,
    #: :py:obj:`~.CU_JIT_THREADS_PER_BLOCK`,
    #: :py:obj:`~.CU_JIT_MAX_THREADS_PER_BLOCK` and
    #: :py:obj:`~.CU_JIT_MIN_CTA_PER_SM` take precedence over any PTX
    #: directives. (0: Disable, default; 1: Enable) Option type: int
    #: Applies to: compiler only
    CU_JIT_OVERRIDE_DIRECTIVE_VALUES = cydriver.CUjit_option_enum.CU_JIT_OVERRIDE_DIRECTIVE_VALUES{{endif}}
    {{if 'CU_JIT_SPLIT_COMPILE' in found_values}}

    #: This option specifies the maximum number of concurrent threads to
    #: use when running compiler optimizations. If the specified value is
    #: 1, the option will be ignored. If the specified value is 0, the
    #: number of threads will match the number of CPUs on the underlying
    #: machine. Otherwise, if the option is N, then up to N threads will be
    #: used. Option type: unsigned int
    #: Applies to: compiler only
    CU_JIT_SPLIT_COMPILE = cydriver.CUjit_option_enum.CU_JIT_SPLIT_COMPILE{{endif}}
    {{if 'CU_JIT_NUM_OPTIONS' in found_values}}
    CU_JIT_NUM_OPTIONS = cydriver.CUjit_option_enum.CU_JIT_NUM_OPTIONS{{endif}}

_dict_CUjit_option = dict(((int(v), v) for k, v in CUjit_option.__members__.items()))
{{endif}}
{{if 'CUjit_target_enum' in found_types}}

class CUjit_target(IntEnum):
    """
    Online compilation targets
    """
    {{if 'CU_TARGET_COMPUTE_30' in found_values}}

    #: Compute device class 3.0
    CU_TARGET_COMPUTE_30 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_30{{endif}}
    {{if 'CU_TARGET_COMPUTE_32' in found_values}}

    #: Compute device class 3.2
    CU_TARGET_COMPUTE_32 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_32{{endif}}
    {{if 'CU_TARGET_COMPUTE_35' in found_values}}

    #: Compute device class 3.5
    CU_TARGET_COMPUTE_35 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_35{{endif}}
    {{if 'CU_TARGET_COMPUTE_37' in found_values}}

    #: Compute device class 3.7
    CU_TARGET_COMPUTE_37 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_37{{endif}}
    {{if 'CU_TARGET_COMPUTE_50' in found_values}}

    #: Compute device class 5.0
    CU_TARGET_COMPUTE_50 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_50{{endif}}
    {{if 'CU_TARGET_COMPUTE_52' in found_values}}

    #: Compute device class 5.2
    CU_TARGET_COMPUTE_52 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_52{{endif}}
    {{if 'CU_TARGET_COMPUTE_53' in found_values}}

    #: Compute device class 5.3
    CU_TARGET_COMPUTE_53 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_53{{endif}}
    {{if 'CU_TARGET_COMPUTE_60' in found_values}}

    #: Compute device class 6.0.
    CU_TARGET_COMPUTE_60 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_60{{endif}}
    {{if 'CU_TARGET_COMPUTE_61' in found_values}}

    #: Compute device class 6.1.
    CU_TARGET_COMPUTE_61 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_61{{endif}}
    {{if 'CU_TARGET_COMPUTE_62' in found_values}}

    #: Compute device class 6.2.
    CU_TARGET_COMPUTE_62 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_62{{endif}}
    {{if 'CU_TARGET_COMPUTE_70' in found_values}}

    #: Compute device class 7.0.
    CU_TARGET_COMPUTE_70 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_70{{endif}}
    {{if 'CU_TARGET_COMPUTE_72' in found_values}}

    #: Compute device class 7.2.
    CU_TARGET_COMPUTE_72 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_72{{endif}}
    {{if 'CU_TARGET_COMPUTE_75' in found_values}}

    #: Compute device class 7.5.
    CU_TARGET_COMPUTE_75 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_75{{endif}}
    {{if 'CU_TARGET_COMPUTE_80' in found_values}}

    #: Compute device class 8.0.
    CU_TARGET_COMPUTE_80 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_80{{endif}}
    {{if 'CU_TARGET_COMPUTE_86' in found_values}}

    #: Compute device class 8.6.
    CU_TARGET_COMPUTE_86 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_86{{endif}}
    {{if 'CU_TARGET_COMPUTE_87' in found_values}}

    #: Compute device class 8.7.
    CU_TARGET_COMPUTE_87 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_87{{endif}}
    {{if 'CU_TARGET_COMPUTE_89' in found_values}}

    #: Compute device class 8.9.
    CU_TARGET_COMPUTE_89 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_89{{endif}}
    {{if 'CU_TARGET_COMPUTE_90' in found_values}}

    #: Compute device class 9.0.
    CU_TARGET_COMPUTE_90 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_90{{endif}}
    {{if 'CU_TARGET_COMPUTE_100' in found_values}}

    #: Compute device class 10.0.
    CU_TARGET_COMPUTE_100 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_100{{endif}}
    {{if 'CU_TARGET_COMPUTE_103' in found_values}}

    #: Compute device class 10.3.
    CU_TARGET_COMPUTE_103 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_103{{endif}}
    {{if 'CU_TARGET_COMPUTE_110' in found_values}}

    #: Compute device class 11.0.
    CU_TARGET_COMPUTE_110 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_110{{endif}}
    {{if 'CU_TARGET_COMPUTE_120' in found_values}}

    #: Compute device class 12.0.
    CU_TARGET_COMPUTE_120 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_120{{endif}}
    {{if 'CU_TARGET_COMPUTE_121' in found_values}}

    #: Compute device class 12.1. Compute device class 9.0. with
    #: accelerated features.
    CU_TARGET_COMPUTE_121 = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_121{{endif}}
    {{if 'CU_TARGET_COMPUTE_90A' in found_values}}

    #: Compute device class 10.0. with accelerated features.
    CU_TARGET_COMPUTE_90A = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_90A{{endif}}
    {{if 'CU_TARGET_COMPUTE_100A' in found_values}}

    #: Compute device class 11.0 with accelerated features.
    CU_TARGET_COMPUTE_100A = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_100A{{endif}}
    {{if 'CU_TARGET_COMPUTE_103A' in found_values}}

    #: Compute device class 12.0. with accelerated features.
    CU_TARGET_COMPUTE_103A = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_103A{{endif}}
    {{if 'CU_TARGET_COMPUTE_110A' in found_values}}

    #: Compute device class 10.3. with accelerated features.
    CU_TARGET_COMPUTE_110A = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_110A{{endif}}
    {{if 'CU_TARGET_COMPUTE_120A' in found_values}}

    #: Compute device class 12.1. with accelerated features.
    CU_TARGET_COMPUTE_120A = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_120A{{endif}}
    {{if 'CU_TARGET_COMPUTE_121A' in found_values}}

    #: Compute device class 10.x with family features.
    CU_TARGET_COMPUTE_121A = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_121A{{endif}}
    {{if 'CU_TARGET_COMPUTE_100F' in found_values}}

    #: Compute device class 11.0 with family features.
    CU_TARGET_COMPUTE_100F = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_100F{{endif}}
    {{if 'CU_TARGET_COMPUTE_103F' in found_values}}

    #: Compute device class 12.0. with family features.
    CU_TARGET_COMPUTE_103F = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_103F{{endif}}
    {{if 'CU_TARGET_COMPUTE_110F' in found_values}}

    #: Compute device class 10.3. with family features.
    CU_TARGET_COMPUTE_110F = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_110F{{endif}}
    {{if 'CU_TARGET_COMPUTE_120F' in found_values}}

    #: Compute device class 12.1. with family features.
    CU_TARGET_COMPUTE_120F = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_120F{{endif}}
    {{if 'CU_TARGET_COMPUTE_121F' in found_values}}
    CU_TARGET_COMPUTE_121F = cydriver.CUjit_target_enum.CU_TARGET_COMPUTE_121F{{endif}}

_dict_CUjit_target = dict(((int(v), v) for k, v in CUjit_target.__members__.items()))
{{endif}}
{{if 'CUjit_fallback_enum' in found_types}}

class CUjit_fallback(IntEnum):
    """
    Cubin matching fallback strategies
    """
    {{if 'CU_PREFER_PTX' in found_values}}

    #: Prefer to compile ptx if exact binary match not found
    CU_PREFER_PTX = cydriver.CUjit_fallback_enum.CU_PREFER_PTX{{endif}}
    {{if 'CU_PREFER_BINARY' in found_values}}

    #: Prefer to fall back to compatible binary code if exact match not
    #: found
    CU_PREFER_BINARY = cydriver.CUjit_fallback_enum.CU_PREFER_BINARY{{endif}}

_dict_CUjit_fallback = dict(((int(v), v) for k, v in CUjit_fallback.__members__.items()))
{{endif}}
{{if 'CUjit_cacheMode_enum' in found_types}}

class CUjit_cacheMode(IntEnum):
    """
    Caching modes for dlcm
    """
    {{if 'CU_JIT_CACHE_OPTION_NONE' in found_values}}

    #: Compile with no -dlcm flag specified
    CU_JIT_CACHE_OPTION_NONE = cydriver.CUjit_cacheMode_enum.CU_JIT_CACHE_OPTION_NONE{{endif}}
    {{if 'CU_JIT_CACHE_OPTION_CG' in found_values}}

    #: Compile with L1 cache disabled
    CU_JIT_CACHE_OPTION_CG = cydriver.CUjit_cacheMode_enum.CU_JIT_CACHE_OPTION_CG{{endif}}
    {{if 'CU_JIT_CACHE_OPTION_CA' in found_values}}

    #: Compile with L1 cache enabled
    CU_JIT_CACHE_OPTION_CA = cydriver.CUjit_cacheMode_enum.CU_JIT_CACHE_OPTION_CA{{endif}}

_dict_CUjit_cacheMode = dict(((int(v), v) for k, v in CUjit_cacheMode.__members__.items()))
{{endif}}
{{if 'CUjitInputType_enum' in found_types}}

class CUjitInputType(IntEnum):
    """
    Device code formats
    """
    {{if 'CU_JIT_INPUT_CUBIN' in found_values}}

    #: Compiled device-class-specific device code
    #: Applicable options: none
    CU_JIT_INPUT_CUBIN = cydriver.CUjitInputType_enum.CU_JIT_INPUT_CUBIN{{endif}}
    {{if 'CU_JIT_INPUT_PTX' in found_values}}

    #: PTX source code
    #: Applicable options: PTX compiler options
    CU_JIT_INPUT_PTX = cydriver.CUjitInputType_enum.CU_JIT_INPUT_PTX{{endif}}
    {{if 'CU_JIT_INPUT_FATBINARY' in found_values}}

    #: Bundle of multiple cubins and/or PTX of some device code
    #: Applicable options: PTX compiler options,
    #: :py:obj:`~.CU_JIT_FALLBACK_STRATEGY`
    CU_JIT_INPUT_FATBINARY = cydriver.CUjitInputType_enum.CU_JIT_INPUT_FATBINARY{{endif}}
    {{if 'CU_JIT_INPUT_OBJECT' in found_values}}

    #: Host object with embedded device code
    #: Applicable options: PTX compiler options,
    #: :py:obj:`~.CU_JIT_FALLBACK_STRATEGY`
    CU_JIT_INPUT_OBJECT = cydriver.CUjitInputType_enum.CU_JIT_INPUT_OBJECT{{endif}}
    {{if 'CU_JIT_INPUT_LIBRARY' in found_values}}

    #: Archive of host objects with embedded device code
    #: Applicable options: PTX compiler options,
    #: :py:obj:`~.CU_JIT_FALLBACK_STRATEGY`
    CU_JIT_INPUT_LIBRARY = cydriver.CUjitInputType_enum.CU_JIT_INPUT_LIBRARY{{endif}}
    {{if 'CU_JIT_INPUT_NVVM' in found_values}}

    #: [Deprecated]
    #:
    #: Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0
    CU_JIT_INPUT_NVVM = cydriver.CUjitInputType_enum.CU_JIT_INPUT_NVVM{{endif}}
    {{if 'CU_JIT_NUM_INPUT_TYPES' in found_values}}
    CU_JIT_NUM_INPUT_TYPES = cydriver.CUjitInputType_enum.CU_JIT_NUM_INPUT_TYPES{{endif}}

_dict_CUjitInputType = dict(((int(v), v) for k, v in CUjitInputType.__members__.items()))
{{endif}}
{{if 'CUgraphicsRegisterFlags_enum' in found_types}}

class CUgraphicsRegisterFlags(IntEnum):
    """
    Flags to register a graphics resource
    """
    {{if 'CU_GRAPHICS_REGISTER_FLAGS_NONE' in found_values}}
    CU_GRAPHICS_REGISTER_FLAGS_NONE = cydriver.CUgraphicsRegisterFlags_enum.CU_GRAPHICS_REGISTER_FLAGS_NONE{{endif}}
    {{if 'CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY' in found_values}}
    CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY = cydriver.CUgraphicsRegisterFlags_enum.CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY{{endif}}
    {{if 'CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD' in found_values}}
    CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD = cydriver.CUgraphicsRegisterFlags_enum.CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD{{endif}}
    {{if 'CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST' in found_values}}
    CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST = cydriver.CUgraphicsRegisterFlags_enum.CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST{{endif}}
    {{if 'CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER' in found_values}}
    CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = cydriver.CUgraphicsRegisterFlags_enum.CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER{{endif}}

_dict_CUgraphicsRegisterFlags = dict(((int(v), v) for k, v in CUgraphicsRegisterFlags.__members__.items()))
{{endif}}
{{if 'CUgraphicsMapResourceFlags_enum' in found_types}}

class CUgraphicsMapResourceFlags(IntEnum):
    """
    Flags for mapping and unmapping interop resources
    """
    {{if 'CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE' in found_values}}
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE = cydriver.CUgraphicsMapResourceFlags_enum.CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE{{endif}}
    {{if 'CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY' in found_values}}
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY = cydriver.CUgraphicsMapResourceFlags_enum.CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY{{endif}}
    {{if 'CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD' in found_values}}
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD = cydriver.CUgraphicsMapResourceFlags_enum.CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD{{endif}}

_dict_CUgraphicsMapResourceFlags = dict(((int(v), v) for k, v in CUgraphicsMapResourceFlags.__members__.items()))
{{endif}}
{{if 'CUarray_cubemap_face_enum' in found_types}}

class CUarray_cubemap_face(IntEnum):
    """
    Array indices for cube faces
    """
    {{if 'CU_CUBEMAP_FACE_POSITIVE_X' in found_values}}

    #: Positive X face of cubemap
    CU_CUBEMAP_FACE_POSITIVE_X = cydriver.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_POSITIVE_X{{endif}}
    {{if 'CU_CUBEMAP_FACE_NEGATIVE_X' in found_values}}

    #: Negative X face of cubemap
    CU_CUBEMAP_FACE_NEGATIVE_X = cydriver.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_NEGATIVE_X{{endif}}
    {{if 'CU_CUBEMAP_FACE_POSITIVE_Y' in found_values}}

    #: Positive Y face of cubemap
    CU_CUBEMAP_FACE_POSITIVE_Y = cydriver.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_POSITIVE_Y{{endif}}
    {{if 'CU_CUBEMAP_FACE_NEGATIVE_Y' in found_values}}

    #: Negative Y face of cubemap
    CU_CUBEMAP_FACE_NEGATIVE_Y = cydriver.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_NEGATIVE_Y{{endif}}
    {{if 'CU_CUBEMAP_FACE_POSITIVE_Z' in found_values}}

    #: Positive Z face of cubemap
    CU_CUBEMAP_FACE_POSITIVE_Z = cydriver.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_POSITIVE_Z{{endif}}
    {{if 'CU_CUBEMAP_FACE_NEGATIVE_Z' in found_values}}

    #: Negative Z face of cubemap
    CU_CUBEMAP_FACE_NEGATIVE_Z = cydriver.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_NEGATIVE_Z{{endif}}

_dict_CUarray_cubemap_face = dict(((int(v), v) for k, v in CUarray_cubemap_face.__members__.items()))
{{endif}}
{{if 'CUlimit_enum' in found_types}}

class CUlimit(IntEnum):
    """
    Limits
    """
    {{if 'CU_LIMIT_STACK_SIZE' in found_values}}

    #: GPU thread stack size
    CU_LIMIT_STACK_SIZE = cydriver.CUlimit_enum.CU_LIMIT_STACK_SIZE{{endif}}
    {{if 'CU_LIMIT_PRINTF_FIFO_SIZE' in found_values}}

    #: GPU printf FIFO size
    CU_LIMIT_PRINTF_FIFO_SIZE = cydriver.CUlimit_enum.CU_LIMIT_PRINTF_FIFO_SIZE{{endif}}
    {{if 'CU_LIMIT_MALLOC_HEAP_SIZE' in found_values}}

    #: GPU malloc heap size
    CU_LIMIT_MALLOC_HEAP_SIZE = cydriver.CUlimit_enum.CU_LIMIT_MALLOC_HEAP_SIZE{{endif}}
    {{if 'CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH' in found_values}}

    #: GPU device runtime launch synchronize depth
    CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH = cydriver.CUlimit_enum.CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH{{endif}}
    {{if 'CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT' in found_values}}

    #: GPU device runtime pending launch count
    CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT = cydriver.CUlimit_enum.CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT{{endif}}
    {{if 'CU_LIMIT_MAX_L2_FETCH_GRANULARITY' in found_values}}

    #: A value between 0 and 128 that indicates the maximum fetch
    #: granularity of L2 (in Bytes). This is a hint
    CU_LIMIT_MAX_L2_FETCH_GRANULARITY = cydriver.CUlimit_enum.CU_LIMIT_MAX_L2_FETCH_GRANULARITY{{endif}}
    {{if 'CU_LIMIT_PERSISTING_L2_CACHE_SIZE' in found_values}}

    #: A size in bytes for L2 persisting lines cache size
    CU_LIMIT_PERSISTING_L2_CACHE_SIZE = cydriver.CUlimit_enum.CU_LIMIT_PERSISTING_L2_CACHE_SIZE{{endif}}
    {{if 'CU_LIMIT_SHMEM_SIZE' in found_values}}

    #: A maximum size in bytes of shared memory available to CUDA kernels
    #: on a CIG context. Can only be queried, cannot be set
    CU_LIMIT_SHMEM_SIZE = cydriver.CUlimit_enum.CU_LIMIT_SHMEM_SIZE{{endif}}
    {{if 'CU_LIMIT_CIG_ENABLED' in found_values}}

    #: A non-zero value indicates this CUDA context is a CIG-enabled
    #: context. Can only be queried, cannot be set
    CU_LIMIT_CIG_ENABLED = cydriver.CUlimit_enum.CU_LIMIT_CIG_ENABLED{{endif}}
    {{if 'CU_LIMIT_CIG_SHMEM_FALLBACK_ENABLED' in found_values}}

    #: When set to zero, CUDA will fail to launch a kernel on a CIG
    #: context, instead of using the fallback path, if the kernel uses more
    #: shared memory than available
    CU_LIMIT_CIG_SHMEM_FALLBACK_ENABLED = cydriver.CUlimit_enum.CU_LIMIT_CIG_SHMEM_FALLBACK_ENABLED{{endif}}
    {{if 'CU_LIMIT_MAX' in found_values}}
    CU_LIMIT_MAX = cydriver.CUlimit_enum.CU_LIMIT_MAX{{endif}}

_dict_CUlimit = dict(((int(v), v) for k, v in CUlimit.__members__.items()))
{{endif}}
{{if 'CUresourcetype_enum' in found_types}}

class CUresourcetype(IntEnum):
    """
    Resource types
    """
    {{if 'CU_RESOURCE_TYPE_ARRAY' in found_values}}

    #: Array resource
    CU_RESOURCE_TYPE_ARRAY = cydriver.CUresourcetype_enum.CU_RESOURCE_TYPE_ARRAY{{endif}}
    {{if 'CU_RESOURCE_TYPE_MIPMAPPED_ARRAY' in found_values}}

    #: Mipmapped array resource
    CU_RESOURCE_TYPE_MIPMAPPED_ARRAY = cydriver.CUresourcetype_enum.CU_RESOURCE_TYPE_MIPMAPPED_ARRAY{{endif}}
    {{if 'CU_RESOURCE_TYPE_LINEAR' in found_values}}

    #: Linear resource
    CU_RESOURCE_TYPE_LINEAR = cydriver.CUresourcetype_enum.CU_RESOURCE_TYPE_LINEAR{{endif}}
    {{if 'CU_RESOURCE_TYPE_PITCH2D' in found_values}}

    #: Pitch 2D resource
    CU_RESOURCE_TYPE_PITCH2D = cydriver.CUresourcetype_enum.CU_RESOURCE_TYPE_PITCH2D{{endif}}

_dict_CUresourcetype = dict(((int(v), v) for k, v in CUresourcetype.__members__.items()))
{{endif}}
{{if 'CUaccessProperty_enum' in found_types}}

class CUaccessProperty(IntEnum):
    """
    Specifies performance hint with :py:obj:`~.CUaccessPolicyWindow`
    for hitProp and missProp members.
    """
    {{if 'CU_ACCESS_PROPERTY_NORMAL' in found_values}}

    #: Normal cache persistence.
    CU_ACCESS_PROPERTY_NORMAL = cydriver.CUaccessProperty_enum.CU_ACCESS_PROPERTY_NORMAL{{endif}}
    {{if 'CU_ACCESS_PROPERTY_STREAMING' in found_values}}

    #: Streaming access is less likely to persit from cache.
    CU_ACCESS_PROPERTY_STREAMING = cydriver.CUaccessProperty_enum.CU_ACCESS_PROPERTY_STREAMING{{endif}}
    {{if 'CU_ACCESS_PROPERTY_PERSISTING' in found_values}}

    #: Persisting access is more likely to persist in cache.
    CU_ACCESS_PROPERTY_PERSISTING = cydriver.CUaccessProperty_enum.CU_ACCESS_PROPERTY_PERSISTING{{endif}}

_dict_CUaccessProperty = dict(((int(v), v) for k, v in CUaccessProperty.__members__.items()))
{{endif}}
{{if 'CUgraphConditionalNodeType_enum' in found_types}}

class CUgraphConditionalNodeType(IntEnum):
    """
    Conditional node types
    """
    {{if 'CU_GRAPH_COND_TYPE_IF' in found_values}}

    #: Conditional 'if/else' Node. Body[0] executed if condition is non-
    #: zero. If `size` == 2, an optional ELSE graph is created and this is
    #: executed if the condition is zero.
    CU_GRAPH_COND_TYPE_IF = cydriver.CUgraphConditionalNodeType_enum.CU_GRAPH_COND_TYPE_IF{{endif}}
    {{if 'CU_GRAPH_COND_TYPE_WHILE' in found_values}}

    #: Conditional 'while' Node. Body executed repeatedly while condition
    #: value is non-zero.
    CU_GRAPH_COND_TYPE_WHILE = cydriver.CUgraphConditionalNodeType_enum.CU_GRAPH_COND_TYPE_WHILE{{endif}}
    {{if 'CU_GRAPH_COND_TYPE_SWITCH' in found_values}}

    #: Conditional 'switch' Node. Body[n] is executed once, where 'n' is
    #: the value of the condition. If the condition does not match a body
    #: index, no body is launched.
    CU_GRAPH_COND_TYPE_SWITCH = cydriver.CUgraphConditionalNodeType_enum.CU_GRAPH_COND_TYPE_SWITCH{{endif}}

_dict_CUgraphConditionalNodeType = dict(((int(v), v) for k, v in CUgraphConditionalNodeType.__members__.items()))
{{endif}}
{{if 'CUgraphNodeType_enum' in found_types}}

class CUgraphNodeType(IntEnum):
    """
    Graph node types
    """
    {{if 'CU_GRAPH_NODE_TYPE_KERNEL' in found_values}}

    #: GPU kernel node
    CU_GRAPH_NODE_TYPE_KERNEL = cydriver.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_KERNEL{{endif}}
    {{if 'CU_GRAPH_NODE_TYPE_MEMCPY' in found_values}}

    #: Memcpy node
    CU_GRAPH_NODE_TYPE_MEMCPY = cydriver.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_MEMCPY{{endif}}
    {{if 'CU_GRAPH_NODE_TYPE_MEMSET' in found_values}}

    #: Memset node
    CU_GRAPH_NODE_TYPE_MEMSET = cydriver.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_MEMSET{{endif}}
    {{if 'CU_GRAPH_NODE_TYPE_HOST' in found_values}}

    #: Host (executable) node
    CU_GRAPH_NODE_TYPE_HOST = cydriver.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_HOST{{endif}}
    {{if 'CU_GRAPH_NODE_TYPE_GRAPH' in found_values}}

    #: Node which executes an embedded graph
    CU_GRAPH_NODE_TYPE_GRAPH = cydriver.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_GRAPH{{endif}}
    {{if 'CU_GRAPH_NODE_TYPE_EMPTY' in found_values}}

    #: Empty (no-op) node
    CU_GRAPH_NODE_TYPE_EMPTY = cydriver.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_EMPTY{{endif}}
    {{if 'CU_GRAPH_NODE_TYPE_WAIT_EVENT' in found_values}}

    #: External event wait node
    CU_GRAPH_NODE_TYPE_WAIT_EVENT = cydriver.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_WAIT_EVENT{{endif}}
    {{if 'CU_GRAPH_NODE_TYPE_EVENT_RECORD' in found_values}}

    #: External event record node
    CU_GRAPH_NODE_TYPE_EVENT_RECORD = cydriver.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_EVENT_RECORD{{endif}}
    {{if 'CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL' in found_values}}

    #: External semaphore signal node
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL = cydriver.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL{{endif}}
    {{if 'CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT' in found_values}}

    #: External semaphore wait node
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT = cydriver.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT{{endif}}
    {{if 'CU_GRAPH_NODE_TYPE_MEM_ALLOC' in found_values}}

    #: Memory Allocation Node
    CU_GRAPH_NODE_TYPE_MEM_ALLOC = cydriver.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_MEM_ALLOC{{endif}}
    {{if 'CU_GRAPH_NODE_TYPE_MEM_FREE' in found_values}}

    #: Memory Free Node
    CU_GRAPH_NODE_TYPE_MEM_FREE = cydriver.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_MEM_FREE{{endif}}
    {{if 'CU_GRAPH_NODE_TYPE_BATCH_MEM_OP' in found_values}}

    #: Batch MemOp Node See :py:obj:`~.cuStreamBatchMemOp` and
    #: :py:obj:`~.CUstreamBatchMemOpType` for what these nodes can do.
    CU_GRAPH_NODE_TYPE_BATCH_MEM_OP = cydriver.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_BATCH_MEM_OP{{endif}}
    {{if 'CU_GRAPH_NODE_TYPE_CONDITIONAL' in found_values}}

    #: Conditional Node                                         May be used
    #: to implement a conditional execution path or loop
    #:                                         inside of a graph. The
    #: graph(s) contained within the body of the conditional node
    #:                                         can be selectively executed
    #: or iterated upon based on the value of a conditional
    #:                                         variable.
    #:
    #:                                         Handles must be created in
    #: advance of creating the node
    #:                                         using
    #: :py:obj:`~.cuGraphConditionalHandleCreate`.
    #:
    #:                                         The following restrictions
    #: apply to graphs which contain conditional nodes:
    #:                                          The graph cannot be used in
    #: a child node.
    #:                                          Only one instantiation of
    #: the graph may exist at any point in time.
    #:                                          The graph cannot be cloned.
    #:
    #:                                         To set the control value,
    #: supply a default value when creating the handle and/or
    #:                                         call
    #: :py:obj:`~.cudaGraphSetConditional` from device code.
    CU_GRAPH_NODE_TYPE_CONDITIONAL = cydriver.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_CONDITIONAL{{endif}}

_dict_CUgraphNodeType = dict(((int(v), v) for k, v in CUgraphNodeType.__members__.items()))
{{endif}}
{{if 'CUgraphDependencyType_enum' in found_types}}

class CUgraphDependencyType(IntEnum):
    """
    Type annotations that can be applied to graph edges as part of
    :py:obj:`~.CUgraphEdgeData`.
    """
    {{if 'CU_GRAPH_DEPENDENCY_TYPE_DEFAULT' in found_values}}

    #: This is an ordinary dependency.
    CU_GRAPH_DEPENDENCY_TYPE_DEFAULT = cydriver.CUgraphDependencyType_enum.CU_GRAPH_DEPENDENCY_TYPE_DEFAULT{{endif}}
    {{if 'CU_GRAPH_DEPENDENCY_TYPE_PROGRAMMATIC' in found_values}}

    #: This dependency type allows the downstream node to use
    #: `cudaGridDependencySynchronize()`. It may only be used between
    #: kernel nodes, and must be used with either the
    #: :py:obj:`~.CU_GRAPH_KERNEL_NODE_PORT_PROGRAMMATIC` or
    #: :py:obj:`~.CU_GRAPH_KERNEL_NODE_PORT_LAUNCH_ORDER` outgoing port.
    CU_GRAPH_DEPENDENCY_TYPE_PROGRAMMATIC = cydriver.CUgraphDependencyType_enum.CU_GRAPH_DEPENDENCY_TYPE_PROGRAMMATIC{{endif}}

_dict_CUgraphDependencyType = dict(((int(v), v) for k, v in CUgraphDependencyType.__members__.items()))
{{endif}}
{{if 'CUgraphInstantiateResult_enum' in found_types}}

class CUgraphInstantiateResult(IntEnum):
    """
    Graph instantiation results
    """
    {{if 'CUDA_GRAPH_INSTANTIATE_SUCCESS' in found_values}}

    #: Instantiation succeeded
    CUDA_GRAPH_INSTANTIATE_SUCCESS = cydriver.CUgraphInstantiateResult_enum.CUDA_GRAPH_INSTANTIATE_SUCCESS{{endif}}
    {{if 'CUDA_GRAPH_INSTANTIATE_ERROR' in found_values}}

    #: Instantiation failed for an unexpected reason which is described in
    #: the return value of the function
    CUDA_GRAPH_INSTANTIATE_ERROR = cydriver.CUgraphInstantiateResult_enum.CUDA_GRAPH_INSTANTIATE_ERROR{{endif}}
    {{if 'CUDA_GRAPH_INSTANTIATE_INVALID_STRUCTURE' in found_values}}

    #: Instantiation failed due to invalid structure, such as cycles
    CUDA_GRAPH_INSTANTIATE_INVALID_STRUCTURE = cydriver.CUgraphInstantiateResult_enum.CUDA_GRAPH_INSTANTIATE_INVALID_STRUCTURE{{endif}}
    {{if 'CUDA_GRAPH_INSTANTIATE_NODE_OPERATION_NOT_SUPPORTED' in found_values}}

    #: Instantiation for device launch failed because the graph contained
    #: an unsupported operation
    CUDA_GRAPH_INSTANTIATE_NODE_OPERATION_NOT_SUPPORTED = cydriver.CUgraphInstantiateResult_enum.CUDA_GRAPH_INSTANTIATE_NODE_OPERATION_NOT_SUPPORTED{{endif}}
    {{if 'CUDA_GRAPH_INSTANTIATE_MULTIPLE_CTXS_NOT_SUPPORTED' in found_values}}

    #: Instantiation for device launch failed due to the nodes belonging to
    #: different contexts
    CUDA_GRAPH_INSTANTIATE_MULTIPLE_CTXS_NOT_SUPPORTED = cydriver.CUgraphInstantiateResult_enum.CUDA_GRAPH_INSTANTIATE_MULTIPLE_CTXS_NOT_SUPPORTED{{endif}}
    {{if 'CUDA_GRAPH_INSTANTIATE_CONDITIONAL_HANDLE_UNUSED' in found_values}}

    #: One or more conditional handles are not associated with conditional
    #: nodes
    CUDA_GRAPH_INSTANTIATE_CONDITIONAL_HANDLE_UNUSED = cydriver.CUgraphInstantiateResult_enum.CUDA_GRAPH_INSTANTIATE_CONDITIONAL_HANDLE_UNUSED{{endif}}

_dict_CUgraphInstantiateResult = dict(((int(v), v) for k, v in CUgraphInstantiateResult.__members__.items()))
{{endif}}
{{if 'CUsynchronizationPolicy_enum' in found_types}}

class CUsynchronizationPolicy(IntEnum):
    """

    """
    {{if 'CU_SYNC_POLICY_AUTO' in found_values}}
    CU_SYNC_POLICY_AUTO = cydriver.CUsynchronizationPolicy_enum.CU_SYNC_POLICY_AUTO{{endif}}
    {{if 'CU_SYNC_POLICY_SPIN' in found_values}}
    CU_SYNC_POLICY_SPIN = cydriver.CUsynchronizationPolicy_enum.CU_SYNC_POLICY_SPIN{{endif}}
    {{if 'CU_SYNC_POLICY_YIELD' in found_values}}
    CU_SYNC_POLICY_YIELD = cydriver.CUsynchronizationPolicy_enum.CU_SYNC_POLICY_YIELD{{endif}}
    {{if 'CU_SYNC_POLICY_BLOCKING_SYNC' in found_values}}
    CU_SYNC_POLICY_BLOCKING_SYNC = cydriver.CUsynchronizationPolicy_enum.CU_SYNC_POLICY_BLOCKING_SYNC{{endif}}

_dict_CUsynchronizationPolicy = dict(((int(v), v) for k, v in CUsynchronizationPolicy.__members__.items()))
{{endif}}
{{if 'CUclusterSchedulingPolicy_enum' in found_types}}

class CUclusterSchedulingPolicy(IntEnum):
    """
    Cluster scheduling policies. These may be passed to
    :py:obj:`~.cuFuncSetAttribute` or :py:obj:`~.cuKernelSetAttribute`
    """
    {{if 'CU_CLUSTER_SCHEDULING_POLICY_DEFAULT' in found_values}}

    #: the default policy
    CU_CLUSTER_SCHEDULING_POLICY_DEFAULT = cydriver.CUclusterSchedulingPolicy_enum.CU_CLUSTER_SCHEDULING_POLICY_DEFAULT{{endif}}
    {{if 'CU_CLUSTER_SCHEDULING_POLICY_SPREAD' in found_values}}

    #: spread the blocks within a cluster to the SMs
    CU_CLUSTER_SCHEDULING_POLICY_SPREAD = cydriver.CUclusterSchedulingPolicy_enum.CU_CLUSTER_SCHEDULING_POLICY_SPREAD{{endif}}
    {{if 'CU_CLUSTER_SCHEDULING_POLICY_LOAD_BALANCING' in found_values}}

    #: allow the hardware to load-balance the blocks in a cluster to the
    #: SMs
    CU_CLUSTER_SCHEDULING_POLICY_LOAD_BALANCING = cydriver.CUclusterSchedulingPolicy_enum.CU_CLUSTER_SCHEDULING_POLICY_LOAD_BALANCING{{endif}}

_dict_CUclusterSchedulingPolicy = dict(((int(v), v) for k, v in CUclusterSchedulingPolicy.__members__.items()))
{{endif}}
{{if 'CUlaunchMemSyncDomain_enum' in found_types}}

class CUlaunchMemSyncDomain(IntEnum):
    """
    Memory Synchronization Domain  A kernel can be launched in a
    specified memory synchronization domain that affects all memory
    operations issued by that kernel. A memory barrier issued in one
    domain will only order memory operations in that domain, thus
    eliminating latency increase from memory barriers ordering
    unrelated traffic.  By default, kernels are launched in domain 0.
    Kernel launched with :py:obj:`~.CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE`
    will have a different domain ID. User may also alter the domain ID
    with :py:obj:`~.CUlaunchMemSyncDomainMap` for a specific stream /
    graph node / kernel launch. See
    :py:obj:`~.CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN`,
    :py:obj:`~.cuStreamSetAttribute`, :py:obj:`~.cuLaunchKernelEx`,
    :py:obj:`~.cuGraphKernelNodeSetAttribute`.  Memory operations done
    in kernels launched in different domains are considered system-
    scope distanced. In other words, a GPU scoped memory
    synchronization is not sufficient for memory order to be observed
    by kernels in another memory synchronization domain even if they
    are on the same GPU.
    """
    {{if 'CU_LAUNCH_MEM_SYNC_DOMAIN_DEFAULT' in found_values}}

    #: Launch kernels in the default domain
    CU_LAUNCH_MEM_SYNC_DOMAIN_DEFAULT = cydriver.CUlaunchMemSyncDomain_enum.CU_LAUNCH_MEM_SYNC_DOMAIN_DEFAULT{{endif}}
    {{if 'CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE' in found_values}}

    #: Launch kernels in the remote domain
    CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE = cydriver.CUlaunchMemSyncDomain_enum.CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE{{endif}}

_dict_CUlaunchMemSyncDomain = dict(((int(v), v) for k, v in CUlaunchMemSyncDomain.__members__.items()))
{{endif}}
{{if 'CUlaunchAttributeID_enum' in found_types}}

class CUlaunchAttributeID(IntEnum):
    """
    Launch attributes enum; used as id field of
    :py:obj:`~.CUlaunchAttribute`
    """
    {{if 'CU_LAUNCH_ATTRIBUTE_IGNORE' in found_values}}

    #: Ignored entry, for convenient composition
    CU_LAUNCH_ATTRIBUTE_IGNORE = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_IGNORE{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW' in found_values}}

    #: Valid for streams, graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.accessPolicyWindow`.
    CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_COOPERATIVE' in found_values}}

    #: Valid for graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.cooperative`.
    CU_LAUNCH_ATTRIBUTE_COOPERATIVE = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_COOPERATIVE{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY' in found_values}}

    #: Valid for streams. See
    #: :py:obj:`~.CUlaunchAttributeValue.syncPolicy`.
    CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION' in found_values}}

    #: Valid for graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.clusterDim`.
    CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE' in found_values}}

    #: Valid for graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.clusterSchedulingPolicyPreference`.
    CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION' in found_values}}

    #: Valid for launches. Setting
    #: :py:obj:`~.CUlaunchAttributeValue.programmaticStreamSerializationAllowed`
    #: to non-0 signals that the kernel will use programmatic means to
    #: resolve its stream dependency, so that the CUDA runtime should
    #: opportunistically allow the grid's execution to overlap with the
    #: previous kernel in the stream, if that kernel requests the overlap.
    #: The dependent launches can choose to wait on the dependency using
    #: the programmatic sync (cudaGridDependencySynchronize() or equivalent
    #: PTX instructions).
    CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT' in found_values}}

    #: Valid for launches. Set
    #: :py:obj:`~.CUlaunchAttributeValue.programmaticEvent` to record the
    #: event. Event recorded through this launch attribute is guaranteed to
    #: only trigger after all block in the associated kernel trigger the
    #: event. A block can trigger the event through PTX launchdep.release
    #: or CUDA builtin function cudaTriggerProgrammaticLaunchCompletion().
    #: A trigger can also be inserted at the beginning of each block's
    #: execution if triggerAtBlockStart is set to non-0. The dependent
    #: launches can choose to wait on the dependency using the programmatic
    #: sync (cudaGridDependencySynchronize() or equivalent PTX
    #: instructions). Note that dependents (including the CPU thread
    #: calling :py:obj:`~.cuEventSynchronize()`) are not guaranteed to
    #: observe the release precisely when it is released. For example,
    #: :py:obj:`~.cuEventSynchronize()` may only observe the event trigger
    #: long after the associated kernel has completed. This recording type
    #: is primarily meant for establishing programmatic dependency between
    #: device tasks. Note also this type of dependency allows, but does not
    #: guarantee, concurrent execution of tasks.
    #:  The event supplied must not be an interprocess or interop event.
    #: The event must disable timing (i.e. must be created with the
    #: :py:obj:`~.CU_EVENT_DISABLE_TIMING` flag set).
    CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_PRIORITY' in found_values}}

    #: Valid for streams, graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.priority`.
    CU_LAUNCH_ATTRIBUTE_PRIORITY = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_PRIORITY{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP' in found_values}}

    #: Valid for streams, graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.memSyncDomainMap`.
    CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN' in found_values}}

    #: Valid for streams, graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.memSyncDomain`.
    CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION' in found_values}}

    #: Valid for graph nodes, launches. Set
    #: :py:obj:`~.CUlaunchAttributeValue.preferredClusterDim` to allow the
    #: kernel launch to specify a preferred substitute cluster dimension.
    #: Blocks may be grouped according to either the dimensions specified
    #: with this attribute (grouped into a "preferred substitute cluster"),
    #: or the one specified with
    #: :py:obj:`~.CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION` attribute (grouped
    #: into a "regular cluster"). The cluster dimensions of a "preferred
    #: substitute cluster" shall be an integer multiple greater than zero
    #: of the regular cluster dimensions. The device will attempt - on a
    #: best-effort basis - to group thread blocks into preferred clusters
    #: over grouping them into regular clusters. When it deems necessary
    #: (primarily when the device temporarily runs out of physical
    #: resources to launch the larger preferred clusters), the device may
    #: switch to launch the regular clusters instead to attempt to utilize
    #: as much of the physical device resources as possible.
    #:  Each type of cluster will have its enumeration / coordinate setup
    #: as if the grid consists solely of its type of cluster. For example,
    #: if the preferred substitute cluster dimensions double the regular
    #: cluster dimensions, there might be simultaneously a regular cluster
    #: indexed at (1,0,0), and a preferred cluster indexed at (1,0,0). In
    #: this example, the preferred substitute cluster (1,0,0) replaces
    #: regular clusters (2,0,0) and (3,0,0) and groups their blocks.
    #:  This attribute will only take effect when a regular cluster
    #: dimension has been specified. The preferred substitute cluster
    #: dimension must be an integer multiple greater than zero of the
    #: regular cluster dimension and must divide the grid. It must also be
    #: no more than `maxBlocksPerCluster`, if it is set in the kernel's
    #: `__launch_bounds__`. Otherwise it must be less than the maximum
    #: value the driver can support. Otherwise, setting this attribute to a
    #: value physically unable to fit on any particular device is
    #: permitted.
    CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT' in found_values}}

    #: Valid for launches. Set
    #: :py:obj:`~.CUlaunchAttributeValue.launchCompletionEvent` to record
    #: the event.
    #:  Nominally, the event is triggered once all blocks of the kernel
    #: have begun execution. Currently this is a best effort. If a kernel B
    #: has a launch completion dependency on a kernel A, B may wait until A
    #: is complete. Alternatively, blocks of B may begin before all blocks
    #: of A have begun, for example if B can claim execution resources
    #: unavailable to A (e.g. they run on different GPUs) or if B is a
    #: higher priority than A. Exercise caution if such an ordering
    #: inversion could lead to deadlock.
    #:  A launch completion event is nominally similar to a programmatic
    #: event with `triggerAtBlockStart` set except that it is not visible
    #: to `cudaGridDependencySynchronize()` and can be used with compute
    #: capability less than 9.0.
    #:  The event supplied must not be an interprocess or interop event.
    #: The event must disable timing (i.e. must be created with the
    #: :py:obj:`~.CU_EVENT_DISABLE_TIMING` flag set).
    CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE' in found_values}}

    #: Valid for graph nodes, launches. This attribute is graphs-only, and
    #: passing it to a launch in a non-capturing stream will result in an
    #: error.
    #: :py:obj:`~.CUlaunchAttributeValue`::deviceUpdatableKernelNode::deviceUpdatable
    #: can only be set to 0 or 1. Setting the field to 1 indicates that the
    #: corresponding kernel node should be device-updatable. On success, a
    #: handle will be returned via
    #: :py:obj:`~.CUlaunchAttributeValue`::deviceUpdatableKernelNode::devNode
    #: which can be passed to the various device-side update functions to
    #: update the node's kernel parameters from within another kernel. For
    #: more information on the types of device updates that can be made, as
    #: well as the relevant limitations thereof, see
    #: :py:obj:`~.cudaGraphKernelNodeUpdatesApply`.
    #:  Nodes which are device-updatable have additional restrictions
    #: compared to regular kernel nodes. Firstly, device-updatable nodes
    #: cannot be removed from their graph via
    #: :py:obj:`~.cuGraphDestroyNode`. Additionally, once opted-in to this
    #: functionality, a node cannot opt out, and any attempt to set the
    #: deviceUpdatable attribute to 0 will result in an error. Device-
    #: updatable kernel nodes also cannot have their attributes copied
    #: to/from another kernel node via
    #: :py:obj:`~.cuGraphKernelNodeCopyAttributes`. Graphs containing one
    #: or more device-updatable nodes also do not allow multiple
    #: instantiation, and neither the graph nor its instantiated version
    #: can be passed to :py:obj:`~.cuGraphExecUpdate`.
    #:  If a graph contains device-updatable nodes and updates those nodes
    #: from the device from within the graph, the graph must be uploaded
    #: with :py:obj:`~.cuGraphUpload` before it is launched. For such a
    #: graph, if host-side executable graph updates are made to the device-
    #: updatable nodes, the graph must be uploaded before it is launched
    #: again.
    CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT' in found_values}}

    #: Valid for launches. On devices where the L1 cache and shared memory
    #: use the same hardware resources, setting
    #: :py:obj:`~.CUlaunchAttributeValue.sharedMemCarveout` to a percentage
    #: between 0-100 signals the CUDA driver to set the shared memory
    #: carveout preference, in percent of the total shared memory for that
    #: kernel launch. This attribute takes precedence over
    #: :py:obj:`~.CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT`. This
    #: is only a hint, and the CUDA driver can choose a different
    #: configuration if required for the launch.
    CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_NVLINK_UTIL_CENTRIC_SCHEDULING' in found_values}}

    #: Valid for streams, graph nodes, launches. This attribute is a hint
    #: to the CUDA runtime that the launch should attempt to make the
    #: kernel maximize its NVLINK utilization.
    #:
    #:  When possible to honor this hint, CUDA will assume each block in
    #: the grid launch will carry out an even amount of NVLINK traffic, and
    #: make a best-effort attempt to adjust the kernel launch based on that
    #: assumption.
    #:  This attribute is a hint only. CUDA makes no functional or
    #: performance guarantee. Its applicability can be affected by many
    #: different factors, including driver version (i.e. CUDA doesn't
    #: guarantee the performance characteristics will be maintained between
    #: driver versions or a driver update could alter or regress previously
    #: observed perf characteristics.) It also doesn't guarantee a
    #: successful result, i.e. applying the attribute may not improve the
    #: performance of either the targeted kernel or the encapsulating
    #: application.
    #:  Valid values for
    #: :py:obj:`~.CUlaunchAttributeValue`::nvlinkUtilCentricScheduling are
    #: 0 (disabled) and 1 (enabled).
    CU_LAUNCH_ATTRIBUTE_NVLINK_UTIL_CENTRIC_SCHEDULING = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_NVLINK_UTIL_CENTRIC_SCHEDULING{{endif}}

_dict_CUlaunchAttributeID = dict(((int(v), v) for k, v in CUlaunchAttributeID.__members__.items()))
{{endif}}
{{if 'CUstreamCaptureStatus_enum' in found_types}}

class CUstreamCaptureStatus(IntEnum):
    """
    Possible stream capture statuses returned by
    :py:obj:`~.cuStreamIsCapturing`
    """
    {{if 'CU_STREAM_CAPTURE_STATUS_NONE' in found_values}}

    #: Stream is not capturing
    CU_STREAM_CAPTURE_STATUS_NONE = cydriver.CUstreamCaptureStatus_enum.CU_STREAM_CAPTURE_STATUS_NONE{{endif}}
    {{if 'CU_STREAM_CAPTURE_STATUS_ACTIVE' in found_values}}

    #: Stream is actively capturing
    CU_STREAM_CAPTURE_STATUS_ACTIVE = cydriver.CUstreamCaptureStatus_enum.CU_STREAM_CAPTURE_STATUS_ACTIVE{{endif}}
    {{if 'CU_STREAM_CAPTURE_STATUS_INVALIDATED' in found_values}}

    #: Stream is part of a capture sequence that has been invalidated, but
    #: not terminated
    CU_STREAM_CAPTURE_STATUS_INVALIDATED = cydriver.CUstreamCaptureStatus_enum.CU_STREAM_CAPTURE_STATUS_INVALIDATED{{endif}}

_dict_CUstreamCaptureStatus = dict(((int(v), v) for k, v in CUstreamCaptureStatus.__members__.items()))
{{endif}}
{{if 'CUstreamCaptureMode_enum' in found_types}}

class CUstreamCaptureMode(IntEnum):
    """
    Possible modes for stream capture thread interactions. For more
    details see :py:obj:`~.cuStreamBeginCapture` and
    :py:obj:`~.cuThreadExchangeStreamCaptureMode`
    """
    {{if 'CU_STREAM_CAPTURE_MODE_GLOBAL' in found_values}}
    CU_STREAM_CAPTURE_MODE_GLOBAL = cydriver.CUstreamCaptureMode_enum.CU_STREAM_CAPTURE_MODE_GLOBAL{{endif}}
    {{if 'CU_STREAM_CAPTURE_MODE_THREAD_LOCAL' in found_values}}
    CU_STREAM_CAPTURE_MODE_THREAD_LOCAL = cydriver.CUstreamCaptureMode_enum.CU_STREAM_CAPTURE_MODE_THREAD_LOCAL{{endif}}
    {{if 'CU_STREAM_CAPTURE_MODE_RELAXED' in found_values}}
    CU_STREAM_CAPTURE_MODE_RELAXED = cydriver.CUstreamCaptureMode_enum.CU_STREAM_CAPTURE_MODE_RELAXED{{endif}}

_dict_CUstreamCaptureMode = dict(((int(v), v) for k, v in CUstreamCaptureMode.__members__.items()))
{{endif}}
{{if 'CUdriverProcAddress_flags_enum' in found_types}}

class CUdriverProcAddress_flags(IntEnum):
    """
    Flags to specify search options. For more details see
    :py:obj:`~.cuGetProcAddress`
    """
    {{if 'CU_GET_PROC_ADDRESS_DEFAULT' in found_values}}

    #: Default search mode for driver symbols.
    CU_GET_PROC_ADDRESS_DEFAULT = cydriver.CUdriverProcAddress_flags_enum.CU_GET_PROC_ADDRESS_DEFAULT{{endif}}
    {{if 'CU_GET_PROC_ADDRESS_LEGACY_STREAM' in found_values}}

    #: Search for legacy versions of driver symbols.
    CU_GET_PROC_ADDRESS_LEGACY_STREAM = cydriver.CUdriverProcAddress_flags_enum.CU_GET_PROC_ADDRESS_LEGACY_STREAM{{endif}}
    {{if 'CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM' in found_values}}

    #: Search for per-thread versions of driver symbols.
    CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM = cydriver.CUdriverProcAddress_flags_enum.CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM{{endif}}

_dict_CUdriverProcAddress_flags = dict(((int(v), v) for k, v in CUdriverProcAddress_flags.__members__.items()))
{{endif}}
{{if 'CUdriverProcAddressQueryResult_enum' in found_types}}

class CUdriverProcAddressQueryResult(IntEnum):
    """
    Flags to indicate search status. For more details see
    :py:obj:`~.cuGetProcAddress`
    """
    {{if 'CU_GET_PROC_ADDRESS_SUCCESS' in found_values}}

    #: Symbol was succesfully found
    CU_GET_PROC_ADDRESS_SUCCESS = cydriver.CUdriverProcAddressQueryResult_enum.CU_GET_PROC_ADDRESS_SUCCESS{{endif}}
    {{if 'CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND' in found_values}}

    #: Symbol was not found in search
    CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND = cydriver.CUdriverProcAddressQueryResult_enum.CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND{{endif}}
    {{if 'CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT' in found_values}}

    #: Symbol was found but version supplied was not sufficient
    CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT = cydriver.CUdriverProcAddressQueryResult_enum.CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT{{endif}}

_dict_CUdriverProcAddressQueryResult = dict(((int(v), v) for k, v in CUdriverProcAddressQueryResult.__members__.items()))
{{endif}}
{{if 'CUexecAffinityType_enum' in found_types}}

class CUexecAffinityType(IntEnum):
    """
    Execution Affinity Types
    """
    {{if 'CU_EXEC_AFFINITY_TYPE_SM_COUNT' in found_values}}

    #: Create a context with limited SMs.
    CU_EXEC_AFFINITY_TYPE_SM_COUNT = cydriver.CUexecAffinityType_enum.CU_EXEC_AFFINITY_TYPE_SM_COUNT{{endif}}
    {{if 'CU_EXEC_AFFINITY_TYPE_MAX' in found_values}}
    CU_EXEC_AFFINITY_TYPE_MAX = cydriver.CUexecAffinityType_enum.CU_EXEC_AFFINITY_TYPE_MAX{{endif}}

_dict_CUexecAffinityType = dict(((int(v), v) for k, v in CUexecAffinityType.__members__.items()))
{{endif}}
{{if 'CUcigDataType_enum' in found_types}}

class CUcigDataType(IntEnum):
    """

    """
    {{if 'CIG_DATA_TYPE_D3D12_COMMAND_QUEUE' in found_values}}
    CIG_DATA_TYPE_D3D12_COMMAND_QUEUE = cydriver.CUcigDataType_enum.CIG_DATA_TYPE_D3D12_COMMAND_QUEUE{{endif}}
    {{if 'CIG_DATA_TYPE_NV_BLOB' in found_values}}

    #: D3D12 Command Queue Handle
    CIG_DATA_TYPE_NV_BLOB = cydriver.CUcigDataType_enum.CIG_DATA_TYPE_NV_BLOB{{endif}}

_dict_CUcigDataType = dict(((int(v), v) for k, v in CUcigDataType.__members__.items()))
{{endif}}
{{if 'CUlibraryOption_enum' in found_types}}

class CUlibraryOption(IntEnum):
    """
    Library options to be specified with
    :py:obj:`~.cuLibraryLoadData()` or
    :py:obj:`~.cuLibraryLoadFromFile()`
    """
    {{if 'CU_LIBRARY_HOST_UNIVERSAL_FUNCTION_AND_DATA_TABLE' in found_values}}
    CU_LIBRARY_HOST_UNIVERSAL_FUNCTION_AND_DATA_TABLE = cydriver.CUlibraryOption_enum.CU_LIBRARY_HOST_UNIVERSAL_FUNCTION_AND_DATA_TABLE{{endif}}
    {{if 'CU_LIBRARY_BINARY_IS_PRESERVED' in found_values}}

    #: Specifes that the argument `code` passed to
    #: :py:obj:`~.cuLibraryLoadData()` will be preserved. Specifying this
    #: option will let the driver know that `code` can be accessed at any
    #: point until :py:obj:`~.cuLibraryUnload()`. The default behavior is
    #: for the driver to allocate and maintain its own copy of `code`. Note
    #: that this is only a memory usage optimization hint and the driver
    #: can choose to ignore it if required. Specifying this option with
    #: :py:obj:`~.cuLibraryLoadFromFile()` is invalid and will return
    #: :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.
    CU_LIBRARY_BINARY_IS_PRESERVED = cydriver.CUlibraryOption_enum.CU_LIBRARY_BINARY_IS_PRESERVED{{endif}}
    {{if 'CU_LIBRARY_NUM_OPTIONS' in found_values}}
    CU_LIBRARY_NUM_OPTIONS = cydriver.CUlibraryOption_enum.CU_LIBRARY_NUM_OPTIONS{{endif}}

_dict_CUlibraryOption = dict(((int(v), v) for k, v in CUlibraryOption.__members__.items()))
{{endif}}
{{if 'cudaError_enum' in found_types}}

class CUresult(IntEnum):
    """
    Error codes
    """
    {{if 'CUDA_SUCCESS' in found_values}}

    #: The API call returned with no errors. In the case of query calls,
    #: this also means that the operation being queried is complete (see
    #: :py:obj:`~.cuEventQuery()` and :py:obj:`~.cuStreamQuery()`).
    CUDA_SUCCESS = cydriver.cudaError_enum.CUDA_SUCCESS{{endif}}
    {{if 'CUDA_ERROR_INVALID_VALUE' in found_values}}

    #: This indicates that one or more of the parameters passed to the API
    #: call is not within an acceptable range of values.
    CUDA_ERROR_INVALID_VALUE = cydriver.cudaError_enum.CUDA_ERROR_INVALID_VALUE{{endif}}
    {{if 'CUDA_ERROR_OUT_OF_MEMORY' in found_values}}

    #: The API call failed because it was unable to allocate enough memory
    #: or other resources to perform the requested operation.
    CUDA_ERROR_OUT_OF_MEMORY = cydriver.cudaError_enum.CUDA_ERROR_OUT_OF_MEMORY{{endif}}
    {{if 'CUDA_ERROR_NOT_INITIALIZED' in found_values}}

    #: This indicates that the CUDA driver has not been initialized with
    #: :py:obj:`~.cuInit()` or that initialization has failed.
    CUDA_ERROR_NOT_INITIALIZED = cydriver.cudaError_enum.CUDA_ERROR_NOT_INITIALIZED{{endif}}
    {{if 'CUDA_ERROR_DEINITIALIZED' in found_values}}

    #: This indicates that the CUDA driver is in the process of shutting
    #: down.
    CUDA_ERROR_DEINITIALIZED = cydriver.cudaError_enum.CUDA_ERROR_DEINITIALIZED{{endif}}
    {{if 'CUDA_ERROR_PROFILER_DISABLED' in found_values}}

    #: This indicates profiler is not initialized for this run. This can
    #: happen when the application is running with external profiling tools
    #: like visual profiler.
    CUDA_ERROR_PROFILER_DISABLED = cydriver.cudaError_enum.CUDA_ERROR_PROFILER_DISABLED{{endif}}
    {{if 'CUDA_ERROR_PROFILER_NOT_INITIALIZED' in found_values}}

    #: [Deprecated]
    CUDA_ERROR_PROFILER_NOT_INITIALIZED = cydriver.cudaError_enum.CUDA_ERROR_PROFILER_NOT_INITIALIZED{{endif}}
    {{if 'CUDA_ERROR_PROFILER_ALREADY_STARTED' in found_values}}

    #: [Deprecated]
    CUDA_ERROR_PROFILER_ALREADY_STARTED = cydriver.cudaError_enum.CUDA_ERROR_PROFILER_ALREADY_STARTED{{endif}}
    {{if 'CUDA_ERROR_PROFILER_ALREADY_STOPPED' in found_values}}

    #: [Deprecated]
    CUDA_ERROR_PROFILER_ALREADY_STOPPED = cydriver.cudaError_enum.CUDA_ERROR_PROFILER_ALREADY_STOPPED{{endif}}
    {{if 'CUDA_ERROR_STUB_LIBRARY' in found_values}}

    #: This indicates that the CUDA driver that the application has loaded
    #: is a stub library. Applications that run with the stub rather than a
    #: real driver loaded will result in CUDA API returning this error.
    CUDA_ERROR_STUB_LIBRARY = cydriver.cudaError_enum.CUDA_ERROR_STUB_LIBRARY{{endif}}
    {{if 'CUDA_ERROR_CALL_REQUIRES_NEWER_DRIVER' in found_values}}

    #: This indicates that the API call requires a newer CUDA driver than
    #: the one currently installed. Users should install an updated NVIDIA
    #: CUDA driver to allow the API call to succeed.
    CUDA_ERROR_CALL_REQUIRES_NEWER_DRIVER = cydriver.cudaError_enum.CUDA_ERROR_CALL_REQUIRES_NEWER_DRIVER{{endif}}
    {{if 'CUDA_ERROR_DEVICE_UNAVAILABLE' in found_values}}

    #: This indicates that requested CUDA device is unavailable at the
    #: current time. Devices are often unavailable due to use of
    #: :py:obj:`~.CU_COMPUTEMODE_EXCLUSIVE_PROCESS` or
    #: :py:obj:`~.CU_COMPUTEMODE_PROHIBITED`.
    CUDA_ERROR_DEVICE_UNAVAILABLE = cydriver.cudaError_enum.CUDA_ERROR_DEVICE_UNAVAILABLE{{endif}}
    {{if 'CUDA_ERROR_NO_DEVICE' in found_values}}

    #: This indicates that no CUDA-capable devices were detected by the
    #: installed CUDA driver.
    CUDA_ERROR_NO_DEVICE = cydriver.cudaError_enum.CUDA_ERROR_NO_DEVICE{{endif}}
    {{if 'CUDA_ERROR_INVALID_DEVICE' in found_values}}

    #: This indicates that the device ordinal supplied by the user does not
    #: correspond to a valid CUDA device or that the action requested is
    #: invalid for the specified device.
    CUDA_ERROR_INVALID_DEVICE = cydriver.cudaError_enum.CUDA_ERROR_INVALID_DEVICE{{endif}}
    {{if 'CUDA_ERROR_DEVICE_NOT_LICENSED' in found_values}}

    #: This error indicates that the Grid license is not applied.
    CUDA_ERROR_DEVICE_NOT_LICENSED = cydriver.cudaError_enum.CUDA_ERROR_DEVICE_NOT_LICENSED{{endif}}
    {{if 'CUDA_ERROR_INVALID_IMAGE' in found_values}}

    #: This indicates that the device kernel image is invalid. This can
    #: also indicate an invalid CUDA module.
    CUDA_ERROR_INVALID_IMAGE = cydriver.cudaError_enum.CUDA_ERROR_INVALID_IMAGE{{endif}}
    {{if 'CUDA_ERROR_INVALID_CONTEXT' in found_values}}

    #: This most frequently indicates that there is no context bound to the
    #: current thread. This can also be returned if the context passed to
    #: an API call is not a valid handle (such as a context that has had
    #: :py:obj:`~.cuCtxDestroy()` invoked on it). This can also be returned
    #: if a user mixes different API versions (i.e. 3010 context with 3020
    #: API calls). See :py:obj:`~.cuCtxGetApiVersion()` for more details.
    #: This can also be returned if the green context passed to an API call
    #: was not converted to a :py:obj:`~.CUcontext` using
    #: :py:obj:`~.cuCtxFromGreenCtx` API.
    CUDA_ERROR_INVALID_CONTEXT = cydriver.cudaError_enum.CUDA_ERROR_INVALID_CONTEXT{{endif}}
    {{if 'CUDA_ERROR_CONTEXT_ALREADY_CURRENT' in found_values}}

    #: This indicated that the context being supplied as a parameter to the
    #: API call was already the active context. [Deprecated]
    CUDA_ERROR_CONTEXT_ALREADY_CURRENT = cydriver.cudaError_enum.CUDA_ERROR_CONTEXT_ALREADY_CURRENT{{endif}}
    {{if 'CUDA_ERROR_MAP_FAILED' in found_values}}

    #: This indicates that a map or register operation has failed.
    CUDA_ERROR_MAP_FAILED = cydriver.cudaError_enum.CUDA_ERROR_MAP_FAILED{{endif}}
    {{if 'CUDA_ERROR_UNMAP_FAILED' in found_values}}

    #: This indicates that an unmap or unregister operation has failed.
    CUDA_ERROR_UNMAP_FAILED = cydriver.cudaError_enum.CUDA_ERROR_UNMAP_FAILED{{endif}}
    {{if 'CUDA_ERROR_ARRAY_IS_MAPPED' in found_values}}

    #: This indicates that the specified array is currently mapped and thus
    #: cannot be destroyed.
    CUDA_ERROR_ARRAY_IS_MAPPED = cydriver.cudaError_enum.CUDA_ERROR_ARRAY_IS_MAPPED{{endif}}
    {{if 'CUDA_ERROR_ALREADY_MAPPED' in found_values}}

    #: This indicates that the resource is already mapped.
    CUDA_ERROR_ALREADY_MAPPED = cydriver.cudaError_enum.CUDA_ERROR_ALREADY_MAPPED{{endif}}
    {{if 'CUDA_ERROR_NO_BINARY_FOR_GPU' in found_values}}

    #: This indicates that there is no kernel image available that is
    #: suitable for the device. This can occur when a user specifies code
    #: generation options for a particular CUDA source file that do not
    #: include the corresponding device configuration.
    CUDA_ERROR_NO_BINARY_FOR_GPU = cydriver.cudaError_enum.CUDA_ERROR_NO_BINARY_FOR_GPU{{endif}}
    {{if 'CUDA_ERROR_ALREADY_ACQUIRED' in found_values}}

    #: This indicates that a resource has already been acquired.
    CUDA_ERROR_ALREADY_ACQUIRED = cydriver.cudaError_enum.CUDA_ERROR_ALREADY_ACQUIRED{{endif}}
    {{if 'CUDA_ERROR_NOT_MAPPED' in found_values}}

    #: This indicates that a resource is not mapped.
    CUDA_ERROR_NOT_MAPPED = cydriver.cudaError_enum.CUDA_ERROR_NOT_MAPPED{{endif}}
    {{if 'CUDA_ERROR_NOT_MAPPED_AS_ARRAY' in found_values}}

    #: This indicates that a mapped resource is not available for access as
    #: an array.
    CUDA_ERROR_NOT_MAPPED_AS_ARRAY = cydriver.cudaError_enum.CUDA_ERROR_NOT_MAPPED_AS_ARRAY{{endif}}
    {{if 'CUDA_ERROR_NOT_MAPPED_AS_POINTER' in found_values}}

    #: This indicates that a mapped resource is not available for access as
    #: a pointer.
    CUDA_ERROR_NOT_MAPPED_AS_POINTER = cydriver.cudaError_enum.CUDA_ERROR_NOT_MAPPED_AS_POINTER{{endif}}
    {{if 'CUDA_ERROR_ECC_UNCORRECTABLE' in found_values}}

    #: This indicates that an uncorrectable ECC error was detected during
    #: execution.
    CUDA_ERROR_ECC_UNCORRECTABLE = cydriver.cudaError_enum.CUDA_ERROR_ECC_UNCORRECTABLE{{endif}}
    {{if 'CUDA_ERROR_UNSUPPORTED_LIMIT' in found_values}}

    #: This indicates that the :py:obj:`~.CUlimit` passed to the API call
    #: is not supported by the active device.
    CUDA_ERROR_UNSUPPORTED_LIMIT = cydriver.cudaError_enum.CUDA_ERROR_UNSUPPORTED_LIMIT{{endif}}
    {{if 'CUDA_ERROR_CONTEXT_ALREADY_IN_USE' in found_values}}

    #: This indicates that the :py:obj:`~.CUcontext` passed to the API call
    #: can only be bound to a single CPU thread at a time but is already
    #: bound to a CPU thread.
    CUDA_ERROR_CONTEXT_ALREADY_IN_USE = cydriver.cudaError_enum.CUDA_ERROR_CONTEXT_ALREADY_IN_USE{{endif}}
    {{if 'CUDA_ERROR_PEER_ACCESS_UNSUPPORTED' in found_values}}

    #: This indicates that peer access is not supported across the given
    #: devices.
    CUDA_ERROR_PEER_ACCESS_UNSUPPORTED = cydriver.cudaError_enum.CUDA_ERROR_PEER_ACCESS_UNSUPPORTED{{endif}}
    {{if 'CUDA_ERROR_INVALID_PTX' in found_values}}

    #: This indicates that a PTX JIT compilation failed.
    CUDA_ERROR_INVALID_PTX = cydriver.cudaError_enum.CUDA_ERROR_INVALID_PTX{{endif}}
    {{if 'CUDA_ERROR_INVALID_GRAPHICS_CONTEXT' in found_values}}

    #: This indicates an error with OpenGL or DirectX context.
    CUDA_ERROR_INVALID_GRAPHICS_CONTEXT = cydriver.cudaError_enum.CUDA_ERROR_INVALID_GRAPHICS_CONTEXT{{endif}}
    {{if 'CUDA_ERROR_NVLINK_UNCORRECTABLE' in found_values}}

    #: This indicates that an uncorrectable NVLink error was detected
    #: during the execution.
    CUDA_ERROR_NVLINK_UNCORRECTABLE = cydriver.cudaError_enum.CUDA_ERROR_NVLINK_UNCORRECTABLE{{endif}}
    {{if 'CUDA_ERROR_JIT_COMPILER_NOT_FOUND' in found_values}}

    #: This indicates that the PTX JIT compiler library was not found.
    CUDA_ERROR_JIT_COMPILER_NOT_FOUND = cydriver.cudaError_enum.CUDA_ERROR_JIT_COMPILER_NOT_FOUND{{endif}}
    {{if 'CUDA_ERROR_UNSUPPORTED_PTX_VERSION' in found_values}}

    #: This indicates that the provided PTX was compiled with an
    #: unsupported toolchain.
    CUDA_ERROR_UNSUPPORTED_PTX_VERSION = cydriver.cudaError_enum.CUDA_ERROR_UNSUPPORTED_PTX_VERSION{{endif}}
    {{if 'CUDA_ERROR_JIT_COMPILATION_DISABLED' in found_values}}

    #: This indicates that the PTX JIT compilation was disabled.
    CUDA_ERROR_JIT_COMPILATION_DISABLED = cydriver.cudaError_enum.CUDA_ERROR_JIT_COMPILATION_DISABLED{{endif}}
    {{if 'CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY' in found_values}}

    #: This indicates that the :py:obj:`~.CUexecAffinityType` passed to the
    #: API call is not supported by the active device.
    CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY = cydriver.cudaError_enum.CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY{{endif}}
    {{if 'CUDA_ERROR_UNSUPPORTED_DEVSIDE_SYNC' in found_values}}

    #: This indicates that the code to be compiled by the PTX JIT contains
    #: unsupported call to cudaDeviceSynchronize.
    CUDA_ERROR_UNSUPPORTED_DEVSIDE_SYNC = cydriver.cudaError_enum.CUDA_ERROR_UNSUPPORTED_DEVSIDE_SYNC{{endif}}
    {{if 'CUDA_ERROR_CONTAINED' in found_values}}

    #: This indicates that an exception occurred on the device that is now
    #: contained by the GPU's error containment capability. Common causes
    #: are - a. Certain types of invalid accesses of peer GPU memory over
    #: nvlink b. Certain classes of hardware errors This leaves the process
    #: in an inconsistent state and any further CUDA work will return the
    #: same error. To continue using CUDA, the process must be terminated
    #: and relaunched.
    CUDA_ERROR_CONTAINED = cydriver.cudaError_enum.CUDA_ERROR_CONTAINED{{endif}}
    {{if 'CUDA_ERROR_INVALID_SOURCE' in found_values}}

    #: This indicates that the device kernel source is invalid. This
    #: includes compilation/linker errors encountered in device code or
    #: user error.
    CUDA_ERROR_INVALID_SOURCE = cydriver.cudaError_enum.CUDA_ERROR_INVALID_SOURCE{{endif}}
    {{if 'CUDA_ERROR_FILE_NOT_FOUND' in found_values}}

    #: This indicates that the file specified was not found.
    CUDA_ERROR_FILE_NOT_FOUND = cydriver.cudaError_enum.CUDA_ERROR_FILE_NOT_FOUND{{endif}}
    {{if 'CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND' in found_values}}

    #: This indicates that a link to a shared object failed to resolve.
    CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND = cydriver.cudaError_enum.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND{{endif}}
    {{if 'CUDA_ERROR_SHARED_OBJECT_INIT_FAILED' in found_values}}

    #: This indicates that initialization of a shared object failed.
    CUDA_ERROR_SHARED_OBJECT_INIT_FAILED = cydriver.cudaError_enum.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED{{endif}}
    {{if 'CUDA_ERROR_OPERATING_SYSTEM' in found_values}}

    #: This indicates that an OS call failed.
    CUDA_ERROR_OPERATING_SYSTEM = cydriver.cudaError_enum.CUDA_ERROR_OPERATING_SYSTEM{{endif}}
    {{if 'CUDA_ERROR_INVALID_HANDLE' in found_values}}

    #: This indicates that a resource handle passed to the API call was not
    #: valid. Resource handles are opaque types like :py:obj:`~.CUstream`
    #: and :py:obj:`~.CUevent`.
    CUDA_ERROR_INVALID_HANDLE = cydriver.cudaError_enum.CUDA_ERROR_INVALID_HANDLE{{endif}}
    {{if 'CUDA_ERROR_ILLEGAL_STATE' in found_values}}

    #: This indicates that a resource required by the API call is not in a
    #: valid state to perform the requested operation.
    CUDA_ERROR_ILLEGAL_STATE = cydriver.cudaError_enum.CUDA_ERROR_ILLEGAL_STATE{{endif}}
    {{if 'CUDA_ERROR_LOSSY_QUERY' in found_values}}

    #: This indicates an attempt was made to introspect an object in a way
    #: that would discard semantically important information. This is
    #: either due to the object using funtionality newer than the API
    #: version used to introspect it or omission of optional return
    #: arguments.
    CUDA_ERROR_LOSSY_QUERY = cydriver.cudaError_enum.CUDA_ERROR_LOSSY_QUERY{{endif}}
    {{if 'CUDA_ERROR_NOT_FOUND' in found_values}}

    #: This indicates that a named symbol was not found. Examples of
    #: symbols are global/constant variable names, driver function names,
    #: texture names, and surface names.
    CUDA_ERROR_NOT_FOUND = cydriver.cudaError_enum.CUDA_ERROR_NOT_FOUND{{endif}}
    {{if 'CUDA_ERROR_NOT_READY' in found_values}}

    #: This indicates that asynchronous operations issued previously have
    #: not completed yet. This result is not actually an error, but must be
    #: indicated differently than :py:obj:`~.CUDA_SUCCESS` (which indicates
    #: completion). Calls that may return this value include
    #: :py:obj:`~.cuEventQuery()` and :py:obj:`~.cuStreamQuery()`.
    CUDA_ERROR_NOT_READY = cydriver.cudaError_enum.CUDA_ERROR_NOT_READY{{endif}}
    {{if 'CUDA_ERROR_ILLEGAL_ADDRESS' in found_values}}

    #: While executing a kernel, the device encountered a load or store
    #: instruction on an invalid memory address. This leaves the process in
    #: an inconsistent state and any further CUDA work will return the same
    #: error. To continue using CUDA, the process must be terminated and
    #: relaunched.
    CUDA_ERROR_ILLEGAL_ADDRESS = cydriver.cudaError_enum.CUDA_ERROR_ILLEGAL_ADDRESS{{endif}}
    {{if 'CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES' in found_values}}

    #: This indicates that a launch did not occur because it did not have
    #: appropriate resources. This error usually indicates that the user
    #: has attempted to pass too many arguments to the device kernel, or
    #: the kernel launch specifies too many threads for the kernel's
    #: register count. Passing arguments of the wrong size (i.e. a 64-bit
    #: pointer when a 32-bit int is expected) is equivalent to passing too
    #: many arguments and can also result in this error.
    CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES = cydriver.cudaError_enum.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES{{endif}}
    {{if 'CUDA_ERROR_LAUNCH_TIMEOUT' in found_values}}

    #: This indicates that the device kernel took too long to execute. This
    #: can only occur if timeouts are enabled - see the device attribute
    #: :py:obj:`~.CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT` for more
    #: information. This leaves the process in an inconsistent state and
    #: any further CUDA work will return the same error. To continue using
    #: CUDA, the process must be terminated and relaunched.
    CUDA_ERROR_LAUNCH_TIMEOUT = cydriver.cudaError_enum.CUDA_ERROR_LAUNCH_TIMEOUT{{endif}}
    {{if 'CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING' in found_values}}

    #: This error indicates a kernel launch that uses an incompatible
    #: texturing mode.
    CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING = cydriver.cudaError_enum.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING{{endif}}
    {{if 'CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED' in found_values}}

    #: This error indicates that a call to
    #: :py:obj:`~.cuCtxEnablePeerAccess()` is trying to re-enable peer
    #: access to a context which has already had peer access to it enabled.
    CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED = cydriver.cudaError_enum.CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED{{endif}}
    {{if 'CUDA_ERROR_PEER_ACCESS_NOT_ENABLED' in found_values}}

    #: This error indicates that :py:obj:`~.cuCtxDisablePeerAccess()` is
    #: trying to disable peer access which has not been enabled yet via
    #: :py:obj:`~.cuCtxEnablePeerAccess()`.
    CUDA_ERROR_PEER_ACCESS_NOT_ENABLED = cydriver.cudaError_enum.CUDA_ERROR_PEER_ACCESS_NOT_ENABLED{{endif}}
    {{if 'CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE' in found_values}}

    #: This error indicates that the primary context for the specified
    #: device has already been initialized.
    CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE = cydriver.cudaError_enum.CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE{{endif}}
    {{if 'CUDA_ERROR_CONTEXT_IS_DESTROYED' in found_values}}

    #: This error indicates that the context current to the calling thread
    #: has been destroyed using :py:obj:`~.cuCtxDestroy`, or is a primary
    #: context which has not yet been initialized.
    CUDA_ERROR_CONTEXT_IS_DESTROYED = cydriver.cudaError_enum.CUDA_ERROR_CONTEXT_IS_DESTROYED{{endif}}
    {{if 'CUDA_ERROR_ASSERT' in found_values}}

    #: A device-side assert triggered during kernel execution. The context
    #: cannot be used anymore, and must be destroyed. All existing device
    #: memory allocations from this context are invalid and must be
    #: reconstructed if the program is to continue using CUDA.
    CUDA_ERROR_ASSERT = cydriver.cudaError_enum.CUDA_ERROR_ASSERT{{endif}}
    {{if 'CUDA_ERROR_TOO_MANY_PEERS' in found_values}}

    #: This error indicates that the hardware resources required to enable
    #: peer access have been exhausted for one or more of the devices
    #: passed to :py:obj:`~.cuCtxEnablePeerAccess()`.
    CUDA_ERROR_TOO_MANY_PEERS = cydriver.cudaError_enum.CUDA_ERROR_TOO_MANY_PEERS{{endif}}
    {{if 'CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED' in found_values}}

    #: This error indicates that the memory range passed to
    #: :py:obj:`~.cuMemHostRegister()` has already been registered.
    CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED = cydriver.cudaError_enum.CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED{{endif}}
    {{if 'CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED' in found_values}}

    #: This error indicates that the pointer passed to
    #: :py:obj:`~.cuMemHostUnregister()` does not correspond to any
    #: currently registered memory region.
    CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED = cydriver.cudaError_enum.CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED{{endif}}
    {{if 'CUDA_ERROR_HARDWARE_STACK_ERROR' in found_values}}

    #: While executing a kernel, the device encountered a stack error. This
    #: can be due to stack corruption or exceeding the stack size limit.
    #: This leaves the process in an inconsistent state and any further
    #: CUDA work will return the same error. To continue using CUDA, the
    #: process must be terminated and relaunched.
    CUDA_ERROR_HARDWARE_STACK_ERROR = cydriver.cudaError_enum.CUDA_ERROR_HARDWARE_STACK_ERROR{{endif}}
    {{if 'CUDA_ERROR_ILLEGAL_INSTRUCTION' in found_values}}

    #: While executing a kernel, the device encountered an illegal
    #: instruction. This leaves the process in an inconsistent state and
    #: any further CUDA work will return the same error. To continue using
    #: CUDA, the process must be terminated and relaunched.
    CUDA_ERROR_ILLEGAL_INSTRUCTION = cydriver.cudaError_enum.CUDA_ERROR_ILLEGAL_INSTRUCTION{{endif}}
    {{if 'CUDA_ERROR_MISALIGNED_ADDRESS' in found_values}}

    #: While executing a kernel, the device encountered a load or store
    #: instruction on a memory address which is not aligned. This leaves
    #: the process in an inconsistent state and any further CUDA work will
    #: return the same error. To continue using CUDA, the process must be
    #: terminated and relaunched.
    CUDA_ERROR_MISALIGNED_ADDRESS = cydriver.cudaError_enum.CUDA_ERROR_MISALIGNED_ADDRESS{{endif}}
    {{if 'CUDA_ERROR_INVALID_ADDRESS_SPACE' in found_values}}

    #: While executing a kernel, the device encountered an instruction
    #: which can only operate on memory locations in certain address spaces
    #: (global, shared, or local), but was supplied a memory address not
    #: belonging to an allowed address space. This leaves the process in an
    #: inconsistent state and any further CUDA work will return the same
    #: error. To continue using CUDA, the process must be terminated and
    #: relaunched.
    CUDA_ERROR_INVALID_ADDRESS_SPACE = cydriver.cudaError_enum.CUDA_ERROR_INVALID_ADDRESS_SPACE{{endif}}
    {{if 'CUDA_ERROR_INVALID_PC' in found_values}}

    #: While executing a kernel, the device program counter wrapped its
    #: address space. This leaves the process in an inconsistent state and
    #: any further CUDA work will return the same error. To continue using
    #: CUDA, the process must be terminated and relaunched.
    CUDA_ERROR_INVALID_PC = cydriver.cudaError_enum.CUDA_ERROR_INVALID_PC{{endif}}
    {{if 'CUDA_ERROR_LAUNCH_FAILED' in found_values}}

    #: An exception occurred on the device while executing a kernel. Common
    #: causes include dereferencing an invalid device pointer and accessing
    #: out of bounds shared memory. Less common cases can be system
    #: specific - more information about these cases can be found in the
    #: system specific user guide. This leaves the process in an
    #: inconsistent state and any further CUDA work will return the same
    #: error. To continue using CUDA, the process must be terminated and
    #: relaunched.
    CUDA_ERROR_LAUNCH_FAILED = cydriver.cudaError_enum.CUDA_ERROR_LAUNCH_FAILED{{endif}}
    {{if 'CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE' in found_values}}

    #: This error indicates that the number of blocks launched per grid for
    #: a kernel that was launched via either
    #: :py:obj:`~.cuLaunchCooperativeKernel` or
    #: :py:obj:`~.cuLaunchCooperativeKernelMultiDevice` exceeds the maximum
    #: number of blocks as allowed by
    #: :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessor` or
    #: :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags`
    #: times the number of multiprocessors as specified by the device
    #: attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT`.
    CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE = cydriver.cudaError_enum.CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE{{endif}}
    {{if 'CUDA_ERROR_TENSOR_MEMORY_LEAK' in found_values}}

    #: An exception occurred on the device while exiting a kernel using
    #: tensor memory: the tensor memory was not completely deallocated.
    #: This leaves the process in an inconsistent state and any further
    #: CUDA work will return the same error. To continue using CUDA, the
    #: process must be terminated and relaunched.
    CUDA_ERROR_TENSOR_MEMORY_LEAK = cydriver.cudaError_enum.CUDA_ERROR_TENSOR_MEMORY_LEAK{{endif}}
    {{if 'CUDA_ERROR_NOT_PERMITTED' in found_values}}

    #: This error indicates that the attempted operation is not permitted.
    CUDA_ERROR_NOT_PERMITTED = cydriver.cudaError_enum.CUDA_ERROR_NOT_PERMITTED{{endif}}
    {{if 'CUDA_ERROR_NOT_SUPPORTED' in found_values}}

    #: This error indicates that the attempted operation is not supported
    #: on the current system or device.
    CUDA_ERROR_NOT_SUPPORTED = cydriver.cudaError_enum.CUDA_ERROR_NOT_SUPPORTED{{endif}}
    {{if 'CUDA_ERROR_SYSTEM_NOT_READY' in found_values}}

    #: This error indicates that the system is not yet ready to start any
    #: CUDA work. To continue using CUDA, verify the system configuration
    #: is in a valid state and all required driver daemons are actively
    #: running. More information about this error can be found in the
    #: system specific user guide.
    CUDA_ERROR_SYSTEM_NOT_READY = cydriver.cudaError_enum.CUDA_ERROR_SYSTEM_NOT_READY{{endif}}
    {{if 'CUDA_ERROR_SYSTEM_DRIVER_MISMATCH' in found_values}}

    #: This error indicates that there is a mismatch between the versions
    #: of the display driver and the CUDA driver. Refer to the
    #: compatibility documentation for supported versions.
    CUDA_ERROR_SYSTEM_DRIVER_MISMATCH = cydriver.cudaError_enum.CUDA_ERROR_SYSTEM_DRIVER_MISMATCH{{endif}}
    {{if 'CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE' in found_values}}

    #: This error indicates that the system was upgraded to run with
    #: forward compatibility but the visible hardware detected by CUDA does
    #: not support this configuration. Refer to the compatibility
    #: documentation for the supported hardware matrix or ensure that only
    #: supported hardware is visible during initialization via the
    #: CUDA_VISIBLE_DEVICES environment variable.
    CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE = cydriver.cudaError_enum.CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE{{endif}}
    {{if 'CUDA_ERROR_MPS_CONNECTION_FAILED' in found_values}}

    #: This error indicates that the MPS client failed to connect to the
    #: MPS control daemon or the MPS server.
    CUDA_ERROR_MPS_CONNECTION_FAILED = cydriver.cudaError_enum.CUDA_ERROR_MPS_CONNECTION_FAILED{{endif}}
    {{if 'CUDA_ERROR_MPS_RPC_FAILURE' in found_values}}

    #: This error indicates that the remote procedural call between the MPS
    #: server and the MPS client failed.
    CUDA_ERROR_MPS_RPC_FAILURE = cydriver.cudaError_enum.CUDA_ERROR_MPS_RPC_FAILURE{{endif}}
    {{if 'CUDA_ERROR_MPS_SERVER_NOT_READY' in found_values}}

    #: This error indicates that the MPS server is not ready to accept new
    #: MPS client requests. This error can be returned when the MPS server
    #: is in the process of recovering from a fatal failure.
    CUDA_ERROR_MPS_SERVER_NOT_READY = cydriver.cudaError_enum.CUDA_ERROR_MPS_SERVER_NOT_READY{{endif}}
    {{if 'CUDA_ERROR_MPS_MAX_CLIENTS_REACHED' in found_values}}

    #: This error indicates that the hardware resources required to create
    #: MPS client have been exhausted.
    CUDA_ERROR_MPS_MAX_CLIENTS_REACHED = cydriver.cudaError_enum.CUDA_ERROR_MPS_MAX_CLIENTS_REACHED{{endif}}
    {{if 'CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED' in found_values}}

    #: This error indicates the the hardware resources required to support
    #: device connections have been exhausted.
    CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED = cydriver.cudaError_enum.CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED{{endif}}
    {{if 'CUDA_ERROR_MPS_CLIENT_TERMINATED' in found_values}}

    #: This error indicates that the MPS client has been terminated by the
    #: server. To continue using CUDA, the process must be terminated and
    #: relaunched.
    CUDA_ERROR_MPS_CLIENT_TERMINATED = cydriver.cudaError_enum.CUDA_ERROR_MPS_CLIENT_TERMINATED{{endif}}
    {{if 'CUDA_ERROR_CDP_NOT_SUPPORTED' in found_values}}

    #: This error indicates that the module is using CUDA Dynamic
    #: Parallelism, but the current configuration, like MPS, does not
    #: support it.
    CUDA_ERROR_CDP_NOT_SUPPORTED = cydriver.cudaError_enum.CUDA_ERROR_CDP_NOT_SUPPORTED{{endif}}
    {{if 'CUDA_ERROR_CDP_VERSION_MISMATCH' in found_values}}

    #: This error indicates that a module contains an unsupported
    #: interaction between different versions of CUDA Dynamic Parallelism.
    CUDA_ERROR_CDP_VERSION_MISMATCH = cydriver.cudaError_enum.CUDA_ERROR_CDP_VERSION_MISMATCH{{endif}}
    {{if 'CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED' in found_values}}

    #: This error indicates that the operation is not permitted when the
    #: stream is capturing.
    CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED = cydriver.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED{{endif}}
    {{if 'CUDA_ERROR_STREAM_CAPTURE_INVALIDATED' in found_values}}

    #: This error indicates that the current capture sequence on the stream
    #: has been invalidated due to a previous error.
    CUDA_ERROR_STREAM_CAPTURE_INVALIDATED = cydriver.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_INVALIDATED{{endif}}
    {{if 'CUDA_ERROR_STREAM_CAPTURE_MERGE' in found_values}}

    #: This error indicates that the operation would have resulted in a
    #: merge of two independent capture sequences.
    CUDA_ERROR_STREAM_CAPTURE_MERGE = cydriver.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_MERGE{{endif}}
    {{if 'CUDA_ERROR_STREAM_CAPTURE_UNMATCHED' in found_values}}

    #: This error indicates that the capture was not initiated in this
    #: stream.
    CUDA_ERROR_STREAM_CAPTURE_UNMATCHED = cydriver.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_UNMATCHED{{endif}}
    {{if 'CUDA_ERROR_STREAM_CAPTURE_UNJOINED' in found_values}}

    #: This error indicates that the capture sequence contains a fork that
    #: was not joined to the primary stream.
    CUDA_ERROR_STREAM_CAPTURE_UNJOINED = cydriver.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_UNJOINED{{endif}}
    {{if 'CUDA_ERROR_STREAM_CAPTURE_ISOLATION' in found_values}}

    #: This error indicates that a dependency would have been created which
    #: crosses the capture sequence boundary. Only implicit in-stream
    #: ordering dependencies are allowed to cross the boundary.
    CUDA_ERROR_STREAM_CAPTURE_ISOLATION = cydriver.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_ISOLATION{{endif}}
    {{if 'CUDA_ERROR_STREAM_CAPTURE_IMPLICIT' in found_values}}

    #: This error indicates a disallowed implicit dependency on a current
    #: capture sequence from cudaStreamLegacy.
    CUDA_ERROR_STREAM_CAPTURE_IMPLICIT = cydriver.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT{{endif}}
    {{if 'CUDA_ERROR_CAPTURED_EVENT' in found_values}}

    #: This error indicates that the operation is not permitted on an event
    #: which was last recorded in a capturing stream.
    CUDA_ERROR_CAPTURED_EVENT = cydriver.cudaError_enum.CUDA_ERROR_CAPTURED_EVENT{{endif}}
    {{if 'CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD' in found_values}}

    #: A stream capture sequence not initiated with the
    #: :py:obj:`~.CU_STREAM_CAPTURE_MODE_RELAXED` argument to
    #: :py:obj:`~.cuStreamBeginCapture` was passed to
    #: :py:obj:`~.cuStreamEndCapture` in a different thread.
    CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD = cydriver.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD{{endif}}
    {{if 'CUDA_ERROR_TIMEOUT' in found_values}}

    #: This error indicates that the timeout specified for the wait
    #: operation has lapsed.
    CUDA_ERROR_TIMEOUT = cydriver.cudaError_enum.CUDA_ERROR_TIMEOUT{{endif}}
    {{if 'CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE' in found_values}}

    #: This error indicates that the graph update was not performed because
    #: it included changes which violated constraints specific to
    #: instantiated graph update.
    CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE = cydriver.cudaError_enum.CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE{{endif}}
    {{if 'CUDA_ERROR_EXTERNAL_DEVICE' in found_values}}

    #: This indicates that an async error has occurred in a device outside
    #: of CUDA. If CUDA was waiting for an external device's signal before
    #: consuming shared data, the external device signaled an error
    #: indicating that the data is not valid for consumption. This leaves
    #: the process in an inconsistent state and any further CUDA work will
    #: return the same error. To continue using CUDA, the process must be
    #: terminated and relaunched.
    CUDA_ERROR_EXTERNAL_DEVICE = cydriver.cudaError_enum.CUDA_ERROR_EXTERNAL_DEVICE{{endif}}
    {{if 'CUDA_ERROR_INVALID_CLUSTER_SIZE' in found_values}}

    #: Indicates a kernel launch error due to cluster misconfiguration.
    CUDA_ERROR_INVALID_CLUSTER_SIZE = cydriver.cudaError_enum.CUDA_ERROR_INVALID_CLUSTER_SIZE{{endif}}
    {{if 'CUDA_ERROR_FUNCTION_NOT_LOADED' in found_values}}

    #: Indiciates a function handle is not loaded when calling an API that
    #: requires a loaded function.
    CUDA_ERROR_FUNCTION_NOT_LOADED = cydriver.cudaError_enum.CUDA_ERROR_FUNCTION_NOT_LOADED{{endif}}
    {{if 'CUDA_ERROR_INVALID_RESOURCE_TYPE' in found_values}}

    #: This error indicates one or more resources passed in are not valid
    #: resource types for the operation.
    CUDA_ERROR_INVALID_RESOURCE_TYPE = cydriver.cudaError_enum.CUDA_ERROR_INVALID_RESOURCE_TYPE{{endif}}
    {{if 'CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION' in found_values}}

    #: This error indicates one or more resources are insufficient or non-
    #: applicable for the operation.
    CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION = cydriver.cudaError_enum.CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION{{endif}}
    {{if 'CUDA_ERROR_KEY_ROTATION' in found_values}}

    #: This error indicates that an error happened during the key rotation
    #: sequence.
    CUDA_ERROR_KEY_ROTATION = cydriver.cudaError_enum.CUDA_ERROR_KEY_ROTATION{{endif}}
    {{if 'CUDA_ERROR_UNKNOWN' in found_values}}

    #: This indicates that an unknown internal error has occurred.
    CUDA_ERROR_UNKNOWN = cydriver.cudaError_enum.CUDA_ERROR_UNKNOWN{{endif}}

_dict_CUresult = dict(((int(v), v) for k, v in CUresult.__members__.items()))
{{endif}}
{{if 'CUdevice_P2PAttribute_enum' in found_types}}

class CUdevice_P2PAttribute(IntEnum):
    """
    P2P Attributes
    """
    {{if 'CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK' in found_values}}

    #: A relative value indicating the performance of the link between two
    #: devices
    CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK = cydriver.CUdevice_P2PAttribute_enum.CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK{{endif}}
    {{if 'CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED' in found_values}}

    #: P2P Access is enable
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED = cydriver.CUdevice_P2PAttribute_enum.CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED' in found_values}}

    #: All CUDA-valid atomic operation over the link are supported
    CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED = cydriver.CUdevice_P2PAttribute_enum.CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED' in found_values}}

    #: [Deprecated]
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED = cydriver.CUdevice_P2PAttribute_enum.CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED' in found_values}}

    #: Accessing CUDA arrays over the link supported
    CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED = cydriver.CUdevice_P2PAttribute_enum.CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED{{endif}}
    {{if 'CU_DEVICE_P2P_ATTRIBUTE_ONLY_PARTIAL_NATIVE_ATOMIC_SUPPORTED' in found_values}}

    #: Only some CUDA-valid atomic operations over the link are supported.
    CU_DEVICE_P2P_ATTRIBUTE_ONLY_PARTIAL_NATIVE_ATOMIC_SUPPORTED = cydriver.CUdevice_P2PAttribute_enum.CU_DEVICE_P2P_ATTRIBUTE_ONLY_PARTIAL_NATIVE_ATOMIC_SUPPORTED{{endif}}

_dict_CUdevice_P2PAttribute = dict(((int(v), v) for k, v in CUdevice_P2PAttribute.__members__.items()))
{{endif}}
{{if 'CUatomicOperation_enum' in found_types}}

class CUatomicOperation(IntEnum):
    """
    CUDA-valid Atomic Operations
    """
    {{if 'CU_ATOMIC_OPERATION_INTEGER_ADD' in found_values}}
    CU_ATOMIC_OPERATION_INTEGER_ADD = cydriver.CUatomicOperation_enum.CU_ATOMIC_OPERATION_INTEGER_ADD{{endif}}
    {{if 'CU_ATOMIC_OPERATION_INTEGER_MIN' in found_values}}
    CU_ATOMIC_OPERATION_INTEGER_MIN = cydriver.CUatomicOperation_enum.CU_ATOMIC_OPERATION_INTEGER_MIN{{endif}}
    {{if 'CU_ATOMIC_OPERATION_INTEGER_MAX' in found_values}}
    CU_ATOMIC_OPERATION_INTEGER_MAX = cydriver.CUatomicOperation_enum.CU_ATOMIC_OPERATION_INTEGER_MAX{{endif}}
    {{if 'CU_ATOMIC_OPERATION_INTEGER_INCREMENT' in found_values}}
    CU_ATOMIC_OPERATION_INTEGER_INCREMENT = cydriver.CUatomicOperation_enum.CU_ATOMIC_OPERATION_INTEGER_INCREMENT{{endif}}
    {{if 'CU_ATOMIC_OPERATION_INTEGER_DECREMENT' in found_values}}
    CU_ATOMIC_OPERATION_INTEGER_DECREMENT = cydriver.CUatomicOperation_enum.CU_ATOMIC_OPERATION_INTEGER_DECREMENT{{endif}}
    {{if 'CU_ATOMIC_OPERATION_AND' in found_values}}
    CU_ATOMIC_OPERATION_AND = cydriver.CUatomicOperation_enum.CU_ATOMIC_OPERATION_AND{{endif}}
    {{if 'CU_ATOMIC_OPERATION_OR' in found_values}}
    CU_ATOMIC_OPERATION_OR = cydriver.CUatomicOperation_enum.CU_ATOMIC_OPERATION_OR{{endif}}
    {{if 'CU_ATOMIC_OPERATION_XOR' in found_values}}
    CU_ATOMIC_OPERATION_XOR = cydriver.CUatomicOperation_enum.CU_ATOMIC_OPERATION_XOR{{endif}}
    {{if 'CU_ATOMIC_OPERATION_EXCHANGE' in found_values}}
    CU_ATOMIC_OPERATION_EXCHANGE = cydriver.CUatomicOperation_enum.CU_ATOMIC_OPERATION_EXCHANGE{{endif}}
    {{if 'CU_ATOMIC_OPERATION_CAS' in found_values}}
    CU_ATOMIC_OPERATION_CAS = cydriver.CUatomicOperation_enum.CU_ATOMIC_OPERATION_CAS{{endif}}
    {{if 'CU_ATOMIC_OPERATION_FLOAT_ADD' in found_values}}
    CU_ATOMIC_OPERATION_FLOAT_ADD = cydriver.CUatomicOperation_enum.CU_ATOMIC_OPERATION_FLOAT_ADD{{endif}}
    {{if 'CU_ATOMIC_OPERATION_FLOAT_MIN' in found_values}}
    CU_ATOMIC_OPERATION_FLOAT_MIN = cydriver.CUatomicOperation_enum.CU_ATOMIC_OPERATION_FLOAT_MIN{{endif}}
    {{if 'CU_ATOMIC_OPERATION_FLOAT_MAX' in found_values}}
    CU_ATOMIC_OPERATION_FLOAT_MAX = cydriver.CUatomicOperation_enum.CU_ATOMIC_OPERATION_FLOAT_MAX{{endif}}
    {{if 'CU_ATOMIC_OPERATION_MAX' in found_values}}
    CU_ATOMIC_OPERATION_MAX = cydriver.CUatomicOperation_enum.CU_ATOMIC_OPERATION_MAX{{endif}}

_dict_CUatomicOperation = dict(((int(v), v) for k, v in CUatomicOperation.__members__.items()))
{{endif}}
{{if 'CUatomicOperationCapability_enum' in found_types}}

class CUatomicOperationCapability(IntEnum):
    """
    CUDA-valid Atomic Operation capabilities
    """
    {{if 'CU_ATOMIC_CAPABILITY_SIGNED' in found_values}}
    CU_ATOMIC_CAPABILITY_SIGNED = cydriver.CUatomicOperationCapability_enum.CU_ATOMIC_CAPABILITY_SIGNED{{endif}}
    {{if 'CU_ATOMIC_CAPABILITY_UNSIGNED' in found_values}}
    CU_ATOMIC_CAPABILITY_UNSIGNED = cydriver.CUatomicOperationCapability_enum.CU_ATOMIC_CAPABILITY_UNSIGNED{{endif}}
    {{if 'CU_ATOMIC_CAPABILITY_REDUCTION' in found_values}}
    CU_ATOMIC_CAPABILITY_REDUCTION = cydriver.CUatomicOperationCapability_enum.CU_ATOMIC_CAPABILITY_REDUCTION{{endif}}
    {{if 'CU_ATOMIC_CAPABILITY_SCALAR_32' in found_values}}
    CU_ATOMIC_CAPABILITY_SCALAR_32 = cydriver.CUatomicOperationCapability_enum.CU_ATOMIC_CAPABILITY_SCALAR_32{{endif}}
    {{if 'CU_ATOMIC_CAPABILITY_SCALAR_64' in found_values}}
    CU_ATOMIC_CAPABILITY_SCALAR_64 = cydriver.CUatomicOperationCapability_enum.CU_ATOMIC_CAPABILITY_SCALAR_64{{endif}}
    {{if 'CU_ATOMIC_CAPABILITY_SCALAR_128' in found_values}}
    CU_ATOMIC_CAPABILITY_SCALAR_128 = cydriver.CUatomicOperationCapability_enum.CU_ATOMIC_CAPABILITY_SCALAR_128{{endif}}
    {{if 'CU_ATOMIC_CAPABILITY_VECTOR_32x4' in found_values}}
    CU_ATOMIC_CAPABILITY_VECTOR_32x4 = cydriver.CUatomicOperationCapability_enum.CU_ATOMIC_CAPABILITY_VECTOR_32x4{{endif}}

_dict_CUatomicOperationCapability = dict(((int(v), v) for k, v in CUatomicOperationCapability.__members__.items()))
{{endif}}
{{if 'CUresourceViewFormat_enum' in found_types}}

class CUresourceViewFormat(IntEnum):
    """
    Resource view format
    """
    {{if 'CU_RES_VIEW_FORMAT_NONE' in found_values}}

    #: No resource view format (use underlying resource format)
    CU_RES_VIEW_FORMAT_NONE = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_NONE{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_UINT_1X8' in found_values}}

    #: 1 channel unsigned 8-bit integers
    CU_RES_VIEW_FORMAT_UINT_1X8 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_1X8{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_UINT_2X8' in found_values}}

    #: 2 channel unsigned 8-bit integers
    CU_RES_VIEW_FORMAT_UINT_2X8 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_2X8{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_UINT_4X8' in found_values}}

    #: 4 channel unsigned 8-bit integers
    CU_RES_VIEW_FORMAT_UINT_4X8 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_4X8{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_SINT_1X8' in found_values}}

    #: 1 channel signed 8-bit integers
    CU_RES_VIEW_FORMAT_SINT_1X8 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_1X8{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_SINT_2X8' in found_values}}

    #: 2 channel signed 8-bit integers
    CU_RES_VIEW_FORMAT_SINT_2X8 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_2X8{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_SINT_4X8' in found_values}}

    #: 4 channel signed 8-bit integers
    CU_RES_VIEW_FORMAT_SINT_4X8 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_4X8{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_UINT_1X16' in found_values}}

    #: 1 channel unsigned 16-bit integers
    CU_RES_VIEW_FORMAT_UINT_1X16 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_1X16{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_UINT_2X16' in found_values}}

    #: 2 channel unsigned 16-bit integers
    CU_RES_VIEW_FORMAT_UINT_2X16 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_2X16{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_UINT_4X16' in found_values}}

    #: 4 channel unsigned 16-bit integers
    CU_RES_VIEW_FORMAT_UINT_4X16 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_4X16{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_SINT_1X16' in found_values}}

    #: 1 channel signed 16-bit integers
    CU_RES_VIEW_FORMAT_SINT_1X16 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_1X16{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_SINT_2X16' in found_values}}

    #: 2 channel signed 16-bit integers
    CU_RES_VIEW_FORMAT_SINT_2X16 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_2X16{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_SINT_4X16' in found_values}}

    #: 4 channel signed 16-bit integers
    CU_RES_VIEW_FORMAT_SINT_4X16 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_4X16{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_UINT_1X32' in found_values}}

    #: 1 channel unsigned 32-bit integers
    CU_RES_VIEW_FORMAT_UINT_1X32 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_1X32{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_UINT_2X32' in found_values}}

    #: 2 channel unsigned 32-bit integers
    CU_RES_VIEW_FORMAT_UINT_2X32 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_2X32{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_UINT_4X32' in found_values}}

    #: 4 channel unsigned 32-bit integers
    CU_RES_VIEW_FORMAT_UINT_4X32 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_4X32{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_SINT_1X32' in found_values}}

    #: 1 channel signed 32-bit integers
    CU_RES_VIEW_FORMAT_SINT_1X32 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_1X32{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_SINT_2X32' in found_values}}

    #: 2 channel signed 32-bit integers
    CU_RES_VIEW_FORMAT_SINT_2X32 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_2X32{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_SINT_4X32' in found_values}}

    #: 4 channel signed 32-bit integers
    CU_RES_VIEW_FORMAT_SINT_4X32 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_4X32{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_FLOAT_1X16' in found_values}}

    #: 1 channel 16-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_1X16 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_1X16{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_FLOAT_2X16' in found_values}}

    #: 2 channel 16-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_2X16 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_2X16{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_FLOAT_4X16' in found_values}}

    #: 4 channel 16-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_4X16 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_4X16{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_FLOAT_1X32' in found_values}}

    #: 1 channel 32-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_1X32 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_1X32{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_FLOAT_2X32' in found_values}}

    #: 2 channel 32-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_2X32 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_2X32{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_FLOAT_4X32' in found_values}}

    #: 4 channel 32-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_4X32 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_4X32{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_UNSIGNED_BC1' in found_values}}

    #: Block compressed 1
    CU_RES_VIEW_FORMAT_UNSIGNED_BC1 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC1{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_UNSIGNED_BC2' in found_values}}

    #: Block compressed 2
    CU_RES_VIEW_FORMAT_UNSIGNED_BC2 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC2{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_UNSIGNED_BC3' in found_values}}

    #: Block compressed 3
    CU_RES_VIEW_FORMAT_UNSIGNED_BC3 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC3{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_UNSIGNED_BC4' in found_values}}

    #: Block compressed 4 unsigned
    CU_RES_VIEW_FORMAT_UNSIGNED_BC4 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC4{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_SIGNED_BC4' in found_values}}

    #: Block compressed 4 signed
    CU_RES_VIEW_FORMAT_SIGNED_BC4 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SIGNED_BC4{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_UNSIGNED_BC5' in found_values}}

    #: Block compressed 5 unsigned
    CU_RES_VIEW_FORMAT_UNSIGNED_BC5 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC5{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_SIGNED_BC5' in found_values}}

    #: Block compressed 5 signed
    CU_RES_VIEW_FORMAT_SIGNED_BC5 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SIGNED_BC5{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_UNSIGNED_BC6H' in found_values}}

    #: Block compressed 6 unsigned half-float
    CU_RES_VIEW_FORMAT_UNSIGNED_BC6H = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC6H{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_SIGNED_BC6H' in found_values}}

    #: Block compressed 6 signed half-float
    CU_RES_VIEW_FORMAT_SIGNED_BC6H = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SIGNED_BC6H{{endif}}
    {{if 'CU_RES_VIEW_FORMAT_UNSIGNED_BC7' in found_values}}

    #: Block compressed 7
    CU_RES_VIEW_FORMAT_UNSIGNED_BC7 = cydriver.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC7{{endif}}

_dict_CUresourceViewFormat = dict(((int(v), v) for k, v in CUresourceViewFormat.__members__.items()))
{{endif}}
{{if 'CUtensorMapDataType_enum' in found_types}}

class CUtensorMapDataType(IntEnum):
    """
    Tensor map data type
    """
    {{if 'CU_TENSOR_MAP_DATA_TYPE_UINT8' in found_values}}
    CU_TENSOR_MAP_DATA_TYPE_UINT8 = cydriver.CUtensorMapDataType_enum.CU_TENSOR_MAP_DATA_TYPE_UINT8{{endif}}
    {{if 'CU_TENSOR_MAP_DATA_TYPE_UINT16' in found_values}}
    CU_TENSOR_MAP_DATA_TYPE_UINT16 = cydriver.CUtensorMapDataType_enum.CU_TENSOR_MAP_DATA_TYPE_UINT16{{endif}}
    {{if 'CU_TENSOR_MAP_DATA_TYPE_UINT32' in found_values}}
    CU_TENSOR_MAP_DATA_TYPE_UINT32 = cydriver.CUtensorMapDataType_enum.CU_TENSOR_MAP_DATA_TYPE_UINT32{{endif}}
    {{if 'CU_TENSOR_MAP_DATA_TYPE_INT32' in found_values}}
    CU_TENSOR_MAP_DATA_TYPE_INT32 = cydriver.CUtensorMapDataType_enum.CU_TENSOR_MAP_DATA_TYPE_INT32{{endif}}
    {{if 'CU_TENSOR_MAP_DATA_TYPE_UINT64' in found_values}}
    CU_TENSOR_MAP_DATA_TYPE_UINT64 = cydriver.CUtensorMapDataType_enum.CU_TENSOR_MAP_DATA_TYPE_UINT64{{endif}}
    {{if 'CU_TENSOR_MAP_DATA_TYPE_INT64' in found_values}}
    CU_TENSOR_MAP_DATA_TYPE_INT64 = cydriver.CUtensorMapDataType_enum.CU_TENSOR_MAP_DATA_TYPE_INT64{{endif}}
    {{if 'CU_TENSOR_MAP_DATA_TYPE_FLOAT16' in found_values}}
    CU_TENSOR_MAP_DATA_TYPE_FLOAT16 = cydriver.CUtensorMapDataType_enum.CU_TENSOR_MAP_DATA_TYPE_FLOAT16{{endif}}
    {{if 'CU_TENSOR_MAP_DATA_TYPE_FLOAT32' in found_values}}
    CU_TENSOR_MAP_DATA_TYPE_FLOAT32 = cydriver.CUtensorMapDataType_enum.CU_TENSOR_MAP_DATA_TYPE_FLOAT32{{endif}}
    {{if 'CU_TENSOR_MAP_DATA_TYPE_FLOAT64' in found_values}}
    CU_TENSOR_MAP_DATA_TYPE_FLOAT64 = cydriver.CUtensorMapDataType_enum.CU_TENSOR_MAP_DATA_TYPE_FLOAT64{{endif}}
    {{if 'CU_TENSOR_MAP_DATA_TYPE_BFLOAT16' in found_values}}
    CU_TENSOR_MAP_DATA_TYPE_BFLOAT16 = cydriver.CUtensorMapDataType_enum.CU_TENSOR_MAP_DATA_TYPE_BFLOAT16{{endif}}
    {{if 'CU_TENSOR_MAP_DATA_TYPE_FLOAT32_FTZ' in found_values}}
    CU_TENSOR_MAP_DATA_TYPE_FLOAT32_FTZ = cydriver.CUtensorMapDataType_enum.CU_TENSOR_MAP_DATA_TYPE_FLOAT32_FTZ{{endif}}
    {{if 'CU_TENSOR_MAP_DATA_TYPE_TFLOAT32' in found_values}}
    CU_TENSOR_MAP_DATA_TYPE_TFLOAT32 = cydriver.CUtensorMapDataType_enum.CU_TENSOR_MAP_DATA_TYPE_TFLOAT32{{endif}}
    {{if 'CU_TENSOR_MAP_DATA_TYPE_TFLOAT32_FTZ' in found_values}}
    CU_TENSOR_MAP_DATA_TYPE_TFLOAT32_FTZ = cydriver.CUtensorMapDataType_enum.CU_TENSOR_MAP_DATA_TYPE_TFLOAT32_FTZ{{endif}}
    {{if 'CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B' in found_values}}
    CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B = cydriver.CUtensorMapDataType_enum.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B{{endif}}
    {{if 'CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B' in found_values}}
    CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B = cydriver.CUtensorMapDataType_enum.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B{{endif}}
    {{if 'CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B' in found_values}}
    CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B = cydriver.CUtensorMapDataType_enum.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B{{endif}}

_dict_CUtensorMapDataType = dict(((int(v), v) for k, v in CUtensorMapDataType.__members__.items()))
{{endif}}
{{if 'CUtensorMapInterleave_enum' in found_types}}

class CUtensorMapInterleave(IntEnum):
    """
    Tensor map interleave layout type
    """
    {{if 'CU_TENSOR_MAP_INTERLEAVE_NONE' in found_values}}
    CU_TENSOR_MAP_INTERLEAVE_NONE = cydriver.CUtensorMapInterleave_enum.CU_TENSOR_MAP_INTERLEAVE_NONE{{endif}}
    {{if 'CU_TENSOR_MAP_INTERLEAVE_16B' in found_values}}
    CU_TENSOR_MAP_INTERLEAVE_16B = cydriver.CUtensorMapInterleave_enum.CU_TENSOR_MAP_INTERLEAVE_16B{{endif}}
    {{if 'CU_TENSOR_MAP_INTERLEAVE_32B' in found_values}}
    CU_TENSOR_MAP_INTERLEAVE_32B = cydriver.CUtensorMapInterleave_enum.CU_TENSOR_MAP_INTERLEAVE_32B{{endif}}

_dict_CUtensorMapInterleave = dict(((int(v), v) for k, v in CUtensorMapInterleave.__members__.items()))
{{endif}}
{{if 'CUtensorMapSwizzle_enum' in found_types}}

class CUtensorMapSwizzle(IntEnum):
    """
    Tensor map swizzling mode of shared memory banks
    """
    {{if 'CU_TENSOR_MAP_SWIZZLE_NONE' in found_values}}
    CU_TENSOR_MAP_SWIZZLE_NONE = cydriver.CUtensorMapSwizzle_enum.CU_TENSOR_MAP_SWIZZLE_NONE{{endif}}
    {{if 'CU_TENSOR_MAP_SWIZZLE_32B' in found_values}}
    CU_TENSOR_MAP_SWIZZLE_32B = cydriver.CUtensorMapSwizzle_enum.CU_TENSOR_MAP_SWIZZLE_32B{{endif}}
    {{if 'CU_TENSOR_MAP_SWIZZLE_64B' in found_values}}
    CU_TENSOR_MAP_SWIZZLE_64B = cydriver.CUtensorMapSwizzle_enum.CU_TENSOR_MAP_SWIZZLE_64B{{endif}}
    {{if 'CU_TENSOR_MAP_SWIZZLE_128B' in found_values}}
    CU_TENSOR_MAP_SWIZZLE_128B = cydriver.CUtensorMapSwizzle_enum.CU_TENSOR_MAP_SWIZZLE_128B{{endif}}
    {{if 'CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B' in found_values}}
    CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B = cydriver.CUtensorMapSwizzle_enum.CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B{{endif}}
    {{if 'CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B_FLIP_8B' in found_values}}
    CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B_FLIP_8B = cydriver.CUtensorMapSwizzle_enum.CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B_FLIP_8B{{endif}}
    {{if 'CU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B' in found_values}}
    CU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B = cydriver.CUtensorMapSwizzle_enum.CU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B{{endif}}

_dict_CUtensorMapSwizzle = dict(((int(v), v) for k, v in CUtensorMapSwizzle.__members__.items()))
{{endif}}
{{if 'CUtensorMapL2promotion_enum' in found_types}}

class CUtensorMapL2promotion(IntEnum):
    """
    Tensor map L2 promotion type
    """
    {{if 'CU_TENSOR_MAP_L2_PROMOTION_NONE' in found_values}}
    CU_TENSOR_MAP_L2_PROMOTION_NONE = cydriver.CUtensorMapL2promotion_enum.CU_TENSOR_MAP_L2_PROMOTION_NONE{{endif}}
    {{if 'CU_TENSOR_MAP_L2_PROMOTION_L2_64B' in found_values}}
    CU_TENSOR_MAP_L2_PROMOTION_L2_64B = cydriver.CUtensorMapL2promotion_enum.CU_TENSOR_MAP_L2_PROMOTION_L2_64B{{endif}}
    {{if 'CU_TENSOR_MAP_L2_PROMOTION_L2_128B' in found_values}}
    CU_TENSOR_MAP_L2_PROMOTION_L2_128B = cydriver.CUtensorMapL2promotion_enum.CU_TENSOR_MAP_L2_PROMOTION_L2_128B{{endif}}
    {{if 'CU_TENSOR_MAP_L2_PROMOTION_L2_256B' in found_values}}
    CU_TENSOR_MAP_L2_PROMOTION_L2_256B = cydriver.CUtensorMapL2promotion_enum.CU_TENSOR_MAP_L2_PROMOTION_L2_256B{{endif}}

_dict_CUtensorMapL2promotion = dict(((int(v), v) for k, v in CUtensorMapL2promotion.__members__.items()))
{{endif}}
{{if 'CUtensorMapFloatOOBfill_enum' in found_types}}

class CUtensorMapFloatOOBfill(IntEnum):
    """
    Tensor map out-of-bounds fill type
    """
    {{if 'CU_TENSOR_MAP_FLOAT_OOB_FILL_NONE' in found_values}}
    CU_TENSOR_MAP_FLOAT_OOB_FILL_NONE = cydriver.CUtensorMapFloatOOBfill_enum.CU_TENSOR_MAP_FLOAT_OOB_FILL_NONE{{endif}}
    {{if 'CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA' in found_values}}
    CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA = cydriver.CUtensorMapFloatOOBfill_enum.CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA{{endif}}

_dict_CUtensorMapFloatOOBfill = dict(((int(v), v) for k, v in CUtensorMapFloatOOBfill.__members__.items()))
{{endif}}
{{if 'CUtensorMapIm2ColWideMode_enum' in found_types}}

class CUtensorMapIm2ColWideMode(IntEnum):
    """
    Tensor map Im2Col wide mode
    """
    {{if 'CU_TENSOR_MAP_IM2COL_WIDE_MODE_W' in found_values}}
    CU_TENSOR_MAP_IM2COL_WIDE_MODE_W = cydriver.CUtensorMapIm2ColWideMode_enum.CU_TENSOR_MAP_IM2COL_WIDE_MODE_W{{endif}}
    {{if 'CU_TENSOR_MAP_IM2COL_WIDE_MODE_W128' in found_values}}
    CU_TENSOR_MAP_IM2COL_WIDE_MODE_W128 = cydriver.CUtensorMapIm2ColWideMode_enum.CU_TENSOR_MAP_IM2COL_WIDE_MODE_W128{{endif}}

_dict_CUtensorMapIm2ColWideMode = dict(((int(v), v) for k, v in CUtensorMapIm2ColWideMode.__members__.items()))
{{endif}}
{{if 'CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum' in found_types}}

class CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS(IntEnum):
    """
    Access flags that specify the level of access the current context's
    device has on the memory referenced.
    """
    {{if 'CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE' in found_values}}

    #: No access, meaning the device cannot access this memory at all, thus
    #: must be staged through accessible memory in order to complete
    #: certain operations
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE = cydriver.CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum.CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ' in found_values}}

    #: Read-only access, meaning writes to this memory are considered
    #: invalid accesses and thus return error in that case.
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ = cydriver.CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum.CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ{{endif}}
    {{if 'CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE' in found_values}}

    #: Read-write access, the device has full read-write access to the
    #: memory
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE = cydriver.CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum.CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE{{endif}}

_dict_CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS = dict(((int(v), v) for k, v in CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS.__members__.items()))
{{endif}}
{{if 'CUexternalMemoryHandleType_enum' in found_types}}

class CUexternalMemoryHandleType(IntEnum):
    """
    External memory handle types
    """
    {{if 'CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD' in found_values}}

    #: Handle is an opaque file descriptor
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD = cydriver.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD{{endif}}
    {{if 'CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32' in found_values}}

    #: Handle is an opaque shared NT handle
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32 = cydriver.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32{{endif}}
    {{if 'CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT' in found_values}}

    #: Handle is an opaque, globally shared handle
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT = cydriver.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT{{endif}}
    {{if 'CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP' in found_values}}

    #: Handle is a D3D12 heap object
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP = cydriver.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP{{endif}}
    {{if 'CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE' in found_values}}

    #: Handle is a D3D12 committed resource
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE = cydriver.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE{{endif}}
    {{if 'CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE' in found_values}}

    #: Handle is a shared NT handle to a D3D11 resource
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE = cydriver.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE{{endif}}
    {{if 'CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT' in found_values}}

    #: Handle is a globally shared handle to a D3D11 resource
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT = cydriver.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT{{endif}}
    {{if 'CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF' in found_values}}

    #: Handle is an NvSciBuf object
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF = cydriver.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF{{endif}}
    {{if 'CU_EXTERNAL_MEMORY_HANDLE_TYPE_DMABUF_FD' in found_values}}

    #: Handle is a dma_buf file descriptor
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_DMABUF_FD = cydriver.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_DMABUF_FD{{endif}}

_dict_CUexternalMemoryHandleType = dict(((int(v), v) for k, v in CUexternalMemoryHandleType.__members__.items()))
{{endif}}
{{if 'CUexternalSemaphoreHandleType_enum' in found_types}}

class CUexternalSemaphoreHandleType(IntEnum):
    """
    External semaphore handle types
    """
    {{if 'CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD' in found_values}}

    #: Handle is an opaque file descriptor
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD = cydriver.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD{{endif}}
    {{if 'CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32' in found_values}}

    #: Handle is an opaque shared NT handle
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32 = cydriver.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32{{endif}}
    {{if 'CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT' in found_values}}

    #: Handle is an opaque, globally shared handle
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT = cydriver.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT{{endif}}
    {{if 'CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE' in found_values}}

    #: Handle is a shared NT handle referencing a D3D12 fence object
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE = cydriver.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE{{endif}}
    {{if 'CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE' in found_values}}

    #: Handle is a shared NT handle referencing a D3D11 fence object
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE = cydriver.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE{{endif}}
    {{if 'CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC' in found_values}}

    #: Opaque handle to NvSciSync Object
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC = cydriver.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC{{endif}}
    {{if 'CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX' in found_values}}

    #: Handle is a shared NT handle referencing a D3D11 keyed mutex object
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX = cydriver.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX{{endif}}
    {{if 'CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT' in found_values}}

    #: Handle is a globally shared handle referencing a D3D11 keyed mutex
    #: object
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT = cydriver.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT{{endif}}
    {{if 'CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD' in found_values}}

    #: Handle is an opaque file descriptor referencing a timeline semaphore
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD = cydriver.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD{{endif}}
    {{if 'CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32' in found_values}}

    #: Handle is an opaque shared NT handle referencing a timeline
    #: semaphore
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32 = cydriver.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32{{endif}}

_dict_CUexternalSemaphoreHandleType = dict(((int(v), v) for k, v in CUexternalSemaphoreHandleType.__members__.items()))
{{endif}}
{{if 'CUmemAllocationHandleType_enum' in found_types}}

class CUmemAllocationHandleType(IntEnum):
    """
    Flags for specifying particular handle types
    """
    {{if 'CU_MEM_HANDLE_TYPE_NONE' in found_values}}

    #: Does not allow any export mechanism. >
    CU_MEM_HANDLE_TYPE_NONE = cydriver.CUmemAllocationHandleType_enum.CU_MEM_HANDLE_TYPE_NONE{{endif}}
    {{if 'CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR' in found_values}}

    #: Allows a file descriptor to be used for exporting. Permitted only on
    #: POSIX systems. (int)
    CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR = cydriver.CUmemAllocationHandleType_enum.CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR{{endif}}
    {{if 'CU_MEM_HANDLE_TYPE_WIN32' in found_values}}

    #: Allows a Win32 NT handle to be used for exporting. (HANDLE)
    CU_MEM_HANDLE_TYPE_WIN32 = cydriver.CUmemAllocationHandleType_enum.CU_MEM_HANDLE_TYPE_WIN32{{endif}}
    {{if 'CU_MEM_HANDLE_TYPE_WIN32_KMT' in found_values}}

    #: Allows a Win32 KMT handle to be used for exporting. (D3DKMT_HANDLE)
    CU_MEM_HANDLE_TYPE_WIN32_KMT = cydriver.CUmemAllocationHandleType_enum.CU_MEM_HANDLE_TYPE_WIN32_KMT{{endif}}
    {{if 'CU_MEM_HANDLE_TYPE_FABRIC' in found_values}}

    #: Allows a fabric handle to be used for exporting. (CUmemFabricHandle)
    CU_MEM_HANDLE_TYPE_FABRIC = cydriver.CUmemAllocationHandleType_enum.CU_MEM_HANDLE_TYPE_FABRIC{{endif}}
    {{if 'CU_MEM_HANDLE_TYPE_MAX' in found_values}}
    CU_MEM_HANDLE_TYPE_MAX = cydriver.CUmemAllocationHandleType_enum.CU_MEM_HANDLE_TYPE_MAX{{endif}}

_dict_CUmemAllocationHandleType = dict(((int(v), v) for k, v in CUmemAllocationHandleType.__members__.items()))
{{endif}}
{{if 'CUmemAccess_flags_enum' in found_types}}

class CUmemAccess_flags(IntEnum):
    """
    Specifies the memory protection flags for mapping.
    """
    {{if 'CU_MEM_ACCESS_FLAGS_PROT_NONE' in found_values}}

    #: Default, make the address range not accessible
    CU_MEM_ACCESS_FLAGS_PROT_NONE = cydriver.CUmemAccess_flags_enum.CU_MEM_ACCESS_FLAGS_PROT_NONE{{endif}}
    {{if 'CU_MEM_ACCESS_FLAGS_PROT_READ' in found_values}}

    #: Make the address range read accessible
    CU_MEM_ACCESS_FLAGS_PROT_READ = cydriver.CUmemAccess_flags_enum.CU_MEM_ACCESS_FLAGS_PROT_READ{{endif}}
    {{if 'CU_MEM_ACCESS_FLAGS_PROT_READWRITE' in found_values}}

    #: Make the address range read-write accessible
    CU_MEM_ACCESS_FLAGS_PROT_READWRITE = cydriver.CUmemAccess_flags_enum.CU_MEM_ACCESS_FLAGS_PROT_READWRITE{{endif}}
    {{if 'CU_MEM_ACCESS_FLAGS_PROT_MAX' in found_values}}
    CU_MEM_ACCESS_FLAGS_PROT_MAX = cydriver.CUmemAccess_flags_enum.CU_MEM_ACCESS_FLAGS_PROT_MAX{{endif}}

_dict_CUmemAccess_flags = dict(((int(v), v) for k, v in CUmemAccess_flags.__members__.items()))
{{endif}}
{{if 'CUmemLocationType_enum' in found_types}}

class CUmemLocationType(IntEnum):
    """
    Specifies the type of location
    """
    {{if 'CU_MEM_LOCATION_TYPE_INVALID' in found_values}}
    CU_MEM_LOCATION_TYPE_INVALID = cydriver.CUmemLocationType_enum.CU_MEM_LOCATION_TYPE_INVALID{{endif}}
    {{if 'CU_MEM_LOCATION_TYPE_NONE' in found_values}}

    #: Location is unspecified. This is used when creating a managed memory
    #: pool to indicate no preferred location for the pool
    CU_MEM_LOCATION_TYPE_NONE = cydriver.CUmemLocationType_enum.CU_MEM_LOCATION_TYPE_NONE{{endif}}
    {{if 'CU_MEM_LOCATION_TYPE_DEVICE' in found_values}}

    #: Location is a device location, thus id is a device ordinal
    CU_MEM_LOCATION_TYPE_DEVICE = cydriver.CUmemLocationType_enum.CU_MEM_LOCATION_TYPE_DEVICE{{endif}}
    {{if 'CU_MEM_LOCATION_TYPE_HOST' in found_values}}

    #: Location is host, id is ignored
    CU_MEM_LOCATION_TYPE_HOST = cydriver.CUmemLocationType_enum.CU_MEM_LOCATION_TYPE_HOST{{endif}}
    {{if 'CU_MEM_LOCATION_TYPE_HOST_NUMA' in found_values}}

    #: Location is a host NUMA node, thus id is a host NUMA node id
    CU_MEM_LOCATION_TYPE_HOST_NUMA = cydriver.CUmemLocationType_enum.CU_MEM_LOCATION_TYPE_HOST_NUMA{{endif}}
    {{if 'CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT' in found_values}}

    #: Location is a host NUMA node of the current thread, id is ignored
    CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT = cydriver.CUmemLocationType_enum.CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT{{endif}}
    {{if 'CU_MEM_LOCATION_TYPE_MAX' in found_values}}
    CU_MEM_LOCATION_TYPE_MAX = cydriver.CUmemLocationType_enum.CU_MEM_LOCATION_TYPE_MAX{{endif}}

_dict_CUmemLocationType = dict(((int(v), v) for k, v in CUmemLocationType.__members__.items()))
{{endif}}
{{if 'CUmemAllocationType_enum' in found_types}}

class CUmemAllocationType(IntEnum):
    """
    Defines the allocation types available
    """
    {{if 'CU_MEM_ALLOCATION_TYPE_INVALID' in found_values}}
    CU_MEM_ALLOCATION_TYPE_INVALID = cydriver.CUmemAllocationType_enum.CU_MEM_ALLOCATION_TYPE_INVALID{{endif}}
    {{if 'CU_MEM_ALLOCATION_TYPE_PINNED' in found_values}}

    #: This allocation type is 'pinned', i.e. cannot migrate from its
    #: current location while the application is actively using it
    CU_MEM_ALLOCATION_TYPE_PINNED = cydriver.CUmemAllocationType_enum.CU_MEM_ALLOCATION_TYPE_PINNED{{endif}}
    {{if 'CU_MEM_ALLOCATION_TYPE_MANAGED' in found_values}}

    #: This allocation type is managed memory
    CU_MEM_ALLOCATION_TYPE_MANAGED = cydriver.CUmemAllocationType_enum.CU_MEM_ALLOCATION_TYPE_MANAGED{{endif}}
    {{if 'CU_MEM_ALLOCATION_TYPE_MAX' in found_values}}
    CU_MEM_ALLOCATION_TYPE_MAX = cydriver.CUmemAllocationType_enum.CU_MEM_ALLOCATION_TYPE_MAX{{endif}}

_dict_CUmemAllocationType = dict(((int(v), v) for k, v in CUmemAllocationType.__members__.items()))
{{endif}}
{{if 'CUmemAllocationGranularity_flags_enum' in found_types}}

class CUmemAllocationGranularity_flags(IntEnum):
    """
    Flag for requesting different optimal and required granularities
    for an allocation.
    """
    {{if 'CU_MEM_ALLOC_GRANULARITY_MINIMUM' in found_values}}

    #: Minimum required granularity for allocation
    CU_MEM_ALLOC_GRANULARITY_MINIMUM = cydriver.CUmemAllocationGranularity_flags_enum.CU_MEM_ALLOC_GRANULARITY_MINIMUM{{endif}}
    {{if 'CU_MEM_ALLOC_GRANULARITY_RECOMMENDED' in found_values}}

    #: Recommended granularity for allocation for best performance
    CU_MEM_ALLOC_GRANULARITY_RECOMMENDED = cydriver.CUmemAllocationGranularity_flags_enum.CU_MEM_ALLOC_GRANULARITY_RECOMMENDED{{endif}}

_dict_CUmemAllocationGranularity_flags = dict(((int(v), v) for k, v in CUmemAllocationGranularity_flags.__members__.items()))
{{endif}}
{{if 'CUmemRangeHandleType_enum' in found_types}}

class CUmemRangeHandleType(IntEnum):
    """
    Specifies the handle type for address range
    """
    {{if 'CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD' in found_values}}
    CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD = cydriver.CUmemRangeHandleType_enum.CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD{{endif}}
    {{if 'CU_MEM_RANGE_HANDLE_TYPE_MAX' in found_values}}
    CU_MEM_RANGE_HANDLE_TYPE_MAX = cydriver.CUmemRangeHandleType_enum.CU_MEM_RANGE_HANDLE_TYPE_MAX{{endif}}

_dict_CUmemRangeHandleType = dict(((int(v), v) for k, v in CUmemRangeHandleType.__members__.items()))
{{endif}}
{{if 'CUmemRangeFlags_enum' in found_types}}

class CUmemRangeFlags(IntEnum):
    """
    Flag for requesting handle type for address range.
    """
    {{if 'CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE' in found_values}}

    #: Indicates that DMA_BUF handle should be mapped via PCIe BAR1
    CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE = cydriver.CUmemRangeFlags_enum.CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE{{endif}}

_dict_CUmemRangeFlags = dict(((int(v), v) for k, v in CUmemRangeFlags.__members__.items()))
{{endif}}
{{if 'CUarraySparseSubresourceType_enum' in found_types}}

class CUarraySparseSubresourceType(IntEnum):
    """
    Sparse subresource types
    """
    {{if 'CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL' in found_values}}
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL = cydriver.CUarraySparseSubresourceType_enum.CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL{{endif}}
    {{if 'CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL' in found_values}}
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL = cydriver.CUarraySparseSubresourceType_enum.CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL{{endif}}

_dict_CUarraySparseSubresourceType = dict(((int(v), v) for k, v in CUarraySparseSubresourceType.__members__.items()))
{{endif}}
{{if 'CUmemOperationType_enum' in found_types}}

class CUmemOperationType(IntEnum):
    """
    Memory operation types
    """
    {{if 'CU_MEM_OPERATION_TYPE_MAP' in found_values}}
    CU_MEM_OPERATION_TYPE_MAP = cydriver.CUmemOperationType_enum.CU_MEM_OPERATION_TYPE_MAP{{endif}}
    {{if 'CU_MEM_OPERATION_TYPE_UNMAP' in found_values}}
    CU_MEM_OPERATION_TYPE_UNMAP = cydriver.CUmemOperationType_enum.CU_MEM_OPERATION_TYPE_UNMAP{{endif}}

_dict_CUmemOperationType = dict(((int(v), v) for k, v in CUmemOperationType.__members__.items()))
{{endif}}
{{if 'CUmemHandleType_enum' in found_types}}

class CUmemHandleType(IntEnum):
    """
    Memory handle types
    """
    {{if 'CU_MEM_HANDLE_TYPE_GENERIC' in found_values}}
    CU_MEM_HANDLE_TYPE_GENERIC = cydriver.CUmemHandleType_enum.CU_MEM_HANDLE_TYPE_GENERIC{{endif}}

_dict_CUmemHandleType = dict(((int(v), v) for k, v in CUmemHandleType.__members__.items()))
{{endif}}
{{if 'CUmemAllocationCompType_enum' in found_types}}

class CUmemAllocationCompType(IntEnum):
    """
    Specifies compression attribute for an allocation.
    """
    {{if 'CU_MEM_ALLOCATION_COMP_NONE' in found_values}}

    #: Allocating non-compressible memory
    CU_MEM_ALLOCATION_COMP_NONE = cydriver.CUmemAllocationCompType_enum.CU_MEM_ALLOCATION_COMP_NONE{{endif}}
    {{if 'CU_MEM_ALLOCATION_COMP_GENERIC' in found_values}}

    #: Allocating compressible memory
    CU_MEM_ALLOCATION_COMP_GENERIC = cydriver.CUmemAllocationCompType_enum.CU_MEM_ALLOCATION_COMP_GENERIC{{endif}}

_dict_CUmemAllocationCompType = dict(((int(v), v) for k, v in CUmemAllocationCompType.__members__.items()))
{{endif}}
{{if 'CUmulticastGranularity_flags_enum' in found_types}}

class CUmulticastGranularity_flags(IntEnum):
    """
    Flags for querying different granularities for a multicast object
    """
    {{if 'CU_MULTICAST_GRANULARITY_MINIMUM' in found_values}}

    #: Minimum required granularity
    CU_MULTICAST_GRANULARITY_MINIMUM = cydriver.CUmulticastGranularity_flags_enum.CU_MULTICAST_GRANULARITY_MINIMUM{{endif}}
    {{if 'CU_MULTICAST_GRANULARITY_RECOMMENDED' in found_values}}

    #: Recommended granularity for best performance
    CU_MULTICAST_GRANULARITY_RECOMMENDED = cydriver.CUmulticastGranularity_flags_enum.CU_MULTICAST_GRANULARITY_RECOMMENDED{{endif}}

_dict_CUmulticastGranularity_flags = dict(((int(v), v) for k, v in CUmulticastGranularity_flags.__members__.items()))
{{endif}}
{{if 'CUgraphExecUpdateResult_enum' in found_types}}

class CUgraphExecUpdateResult(IntEnum):
    """
    CUDA Graph Update error types
    """
    {{if 'CU_GRAPH_EXEC_UPDATE_SUCCESS' in found_values}}

    #: The update succeeded
    CU_GRAPH_EXEC_UPDATE_SUCCESS = cydriver.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_SUCCESS{{endif}}
    {{if 'CU_GRAPH_EXEC_UPDATE_ERROR' in found_values}}

    #: The update failed for an unexpected reason which is described in the
    #: return value of the function
    CU_GRAPH_EXEC_UPDATE_ERROR = cydriver.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR{{endif}}
    {{if 'CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED' in found_values}}

    #: The update failed because the topology changed
    CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED = cydriver.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED{{endif}}
    {{if 'CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED' in found_values}}

    #: The update failed because a node type changed
    CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED = cydriver.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED{{endif}}
    {{if 'CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED' in found_values}}

    #: The update failed because the function of a kernel node changed
    #: (CUDA driver < 11.2)
    CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED = cydriver.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED{{endif}}
    {{if 'CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED' in found_values}}

    #: The update failed because the parameters changed in a way that is
    #: not supported
    CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED = cydriver.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED{{endif}}
    {{if 'CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED' in found_values}}

    #: The update failed because something about the node is not supported
    CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED = cydriver.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED{{endif}}
    {{if 'CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE' in found_values}}

    #: The update failed because the function of a kernel node changed in
    #: an unsupported way
    CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE = cydriver.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE{{endif}}
    {{if 'CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED' in found_values}}

    #: The update failed because the node attributes changed in a way that
    #: is not supported
    CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED = cydriver.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED{{endif}}

_dict_CUgraphExecUpdateResult = dict(((int(v), v) for k, v in CUgraphExecUpdateResult.__members__.items()))
{{endif}}
{{if 'CUmemPool_attribute_enum' in found_types}}

class CUmemPool_attribute(IntEnum):
    """
    CUDA memory pool attributes
    """
    {{if 'CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES' in found_values}}

    #: (value type = int) Allow cuMemAllocAsync to use memory
    #: asynchronously freed in another streams as long as a stream ordering
    #: dependency of the allocating stream on the free action exists. Cuda
    #: events and null stream interactions can create the required stream
    #: ordered dependencies. (default enabled)
    CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES = cydriver.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES{{endif}}
    {{if 'CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC' in found_values}}

    #: (value type = int) Allow reuse of already completed frees when there
    #: is no dependency between the free and allocation. (default enabled)
    CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC = cydriver.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC{{endif}}
    {{if 'CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES' in found_values}}

    #: (value type = int) Allow cuMemAllocAsync to insert new stream
    #: dependencies in order to establish the stream ordering required to
    #: reuse a piece of memory released by cuFreeAsync (default enabled).
    CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES = cydriver.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES{{endif}}
    {{if 'CU_MEMPOOL_ATTR_RELEASE_THRESHOLD' in found_values}}

    #: (value type = cuuint64_t) Amount of reserved memory in bytes to hold
    #: onto before trying to release memory back to the OS. When more than
    #: the release threshold bytes of memory are held by the memory pool,
    #: the allocator will try to release memory back to the OS on the next
    #: call to stream, event or context synchronize. (default 0)
    CU_MEMPOOL_ATTR_RELEASE_THRESHOLD = cydriver.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_RELEASE_THRESHOLD{{endif}}
    {{if 'CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT' in found_values}}

    #: (value type = cuuint64_t) Amount of backing memory currently
    #: allocated for the mempool.
    CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT = cydriver.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT{{endif}}
    {{if 'CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH' in found_values}}

    #: (value type = cuuint64_t) High watermark of backing memory allocated
    #: for the mempool since the last time it was reset. High watermark can
    #: only be reset to zero.
    CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH = cydriver.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH{{endif}}
    {{if 'CU_MEMPOOL_ATTR_USED_MEM_CURRENT' in found_values}}

    #: (value type = cuuint64_t) Amount of memory from the pool that is
    #: currently in use by the application.
    CU_MEMPOOL_ATTR_USED_MEM_CURRENT = cydriver.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_USED_MEM_CURRENT{{endif}}
    {{if 'CU_MEMPOOL_ATTR_USED_MEM_HIGH' in found_values}}

    #: (value type = cuuint64_t) High watermark of the amount of memory
    #: from the pool that was in use by the application since the last time
    #: it was reset. High watermark can only be reset to zero.
    CU_MEMPOOL_ATTR_USED_MEM_HIGH = cydriver.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_USED_MEM_HIGH{{endif}}

_dict_CUmemPool_attribute = dict(((int(v), v) for k, v in CUmemPool_attribute.__members__.items()))
{{endif}}
{{if 'CUmemcpyFlags_enum' in found_types}}

class CUmemcpyFlags(IntEnum):
    """
    Flags to specify for copies within a batch. For more details see
    :py:obj:`~.cuMemcpyBatchAsync`.
    """
    {{if 'CU_MEMCPY_FLAG_DEFAULT' in found_values}}
    CU_MEMCPY_FLAG_DEFAULT = cydriver.CUmemcpyFlags_enum.CU_MEMCPY_FLAG_DEFAULT{{endif}}
    {{if 'CU_MEMCPY_FLAG_PREFER_OVERLAP_WITH_COMPUTE' in found_values}}

    #: Hint to the driver to try and overlap the copy with compute work on
    #: the SMs.
    CU_MEMCPY_FLAG_PREFER_OVERLAP_WITH_COMPUTE = cydriver.CUmemcpyFlags_enum.CU_MEMCPY_FLAG_PREFER_OVERLAP_WITH_COMPUTE{{endif}}

_dict_CUmemcpyFlags = dict(((int(v), v) for k, v in CUmemcpyFlags.__members__.items()))
{{endif}}
{{if 'CUmemcpySrcAccessOrder_enum' in found_types}}

class CUmemcpySrcAccessOrder(IntEnum):
    """
    These flags allow applications to convey the source access ordering
    CUDA must maintain. The destination will always be accessed in
    stream order.
    """
    {{if 'CU_MEMCPY_SRC_ACCESS_ORDER_INVALID' in found_values}}

    #: Default invalid.
    CU_MEMCPY_SRC_ACCESS_ORDER_INVALID = cydriver.CUmemcpySrcAccessOrder_enum.CU_MEMCPY_SRC_ACCESS_ORDER_INVALID{{endif}}
    {{if 'CU_MEMCPY_SRC_ACCESS_ORDER_STREAM' in found_values}}

    #: Indicates that access to the source pointer must be in stream order.
    CU_MEMCPY_SRC_ACCESS_ORDER_STREAM = cydriver.CUmemcpySrcAccessOrder_enum.CU_MEMCPY_SRC_ACCESS_ORDER_STREAM{{endif}}
    {{if 'CU_MEMCPY_SRC_ACCESS_ORDER_DURING_API_CALL' in found_values}}

    #: Indicates that access to the source pointer can be out of stream
    #: order and all accesses must be complete before the API call returns.
    #: This flag is suited for ephemeral sources (ex., stack variables)
    #: when it's known that no prior operations in the stream can be
    #: accessing the memory and also that the lifetime of the memory is
    #: limited to the scope that the source variable was declared in.
    #: Specifying this flag allows the driver to optimize the copy and
    #: removes the need for the user to synchronize the stream after the
    #: API call.
    CU_MEMCPY_SRC_ACCESS_ORDER_DURING_API_CALL = cydriver.CUmemcpySrcAccessOrder_enum.CU_MEMCPY_SRC_ACCESS_ORDER_DURING_API_CALL{{endif}}
    {{if 'CU_MEMCPY_SRC_ACCESS_ORDER_ANY' in found_values}}

    #: Indicates that access to the source pointer can be out of stream
    #: order and the accesses can happen even after the API call returns.
    #: This flag is suited for host pointers allocated outside CUDA (ex.,
    #: via malloc) when it's known that no prior operations in the stream
    #: can be accessing the memory. Specifying this flag allows the driver
    #: to optimize the copy on certain platforms.
    CU_MEMCPY_SRC_ACCESS_ORDER_ANY = cydriver.CUmemcpySrcAccessOrder_enum.CU_MEMCPY_SRC_ACCESS_ORDER_ANY{{endif}}
    {{if 'CU_MEMCPY_SRC_ACCESS_ORDER_MAX' in found_values}}
    CU_MEMCPY_SRC_ACCESS_ORDER_MAX = cydriver.CUmemcpySrcAccessOrder_enum.CU_MEMCPY_SRC_ACCESS_ORDER_MAX{{endif}}

_dict_CUmemcpySrcAccessOrder = dict(((int(v), v) for k, v in CUmemcpySrcAccessOrder.__members__.items()))
{{endif}}
{{if 'CUmemcpy3DOperandType_enum' in found_types}}

class CUmemcpy3DOperandType(IntEnum):
    """
    These flags allow applications to convey the operand type for
    individual copies specified in :py:obj:`~.cuMemcpy3DBatchAsync`.
    """
    {{if 'CU_MEMCPY_OPERAND_TYPE_POINTER' in found_values}}

    #: Memcpy operand is a valid pointer.
    CU_MEMCPY_OPERAND_TYPE_POINTER = cydriver.CUmemcpy3DOperandType_enum.CU_MEMCPY_OPERAND_TYPE_POINTER{{endif}}
    {{if 'CU_MEMCPY_OPERAND_TYPE_ARRAY' in found_values}}

    #: Memcpy operand is a CUarray.
    CU_MEMCPY_OPERAND_TYPE_ARRAY = cydriver.CUmemcpy3DOperandType_enum.CU_MEMCPY_OPERAND_TYPE_ARRAY{{endif}}
    {{if 'CU_MEMCPY_OPERAND_TYPE_MAX' in found_values}}
    CU_MEMCPY_OPERAND_TYPE_MAX = cydriver.CUmemcpy3DOperandType_enum.CU_MEMCPY_OPERAND_TYPE_MAX{{endif}}

_dict_CUmemcpy3DOperandType = dict(((int(v), v) for k, v in CUmemcpy3DOperandType.__members__.items()))
{{endif}}
{{if 'CUgraphMem_attribute_enum' in found_types}}

class CUgraphMem_attribute(IntEnum):
    """

    """
    {{if 'CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT' in found_values}}

    #: (value type = cuuint64_t) Amount of memory, in bytes, currently
    #: associated with graphs
    CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT = cydriver.CUgraphMem_attribute_enum.CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT{{endif}}
    {{if 'CU_GRAPH_MEM_ATTR_USED_MEM_HIGH' in found_values}}

    #: (value type = cuuint64_t) High watermark of memory, in bytes,
    #: associated with graphs since the last time it was reset. High
    #: watermark can only be reset to zero.
    CU_GRAPH_MEM_ATTR_USED_MEM_HIGH = cydriver.CUgraphMem_attribute_enum.CU_GRAPH_MEM_ATTR_USED_MEM_HIGH{{endif}}
    {{if 'CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT' in found_values}}

    #: (value type = cuuint64_t) Amount of memory, in bytes, currently
    #: allocated for use by the CUDA graphs asynchronous allocator.
    CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT = cydriver.CUgraphMem_attribute_enum.CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT{{endif}}
    {{if 'CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH' in found_values}}

    #: (value type = cuuint64_t) High watermark of memory, in bytes,
    #: currently allocated for use by the CUDA graphs asynchronous
    #: allocator.
    CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH = cydriver.CUgraphMem_attribute_enum.CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH{{endif}}

_dict_CUgraphMem_attribute = dict(((int(v), v) for k, v in CUgraphMem_attribute.__members__.items()))
{{endif}}
{{if 'CUgraphChildGraphNodeOwnership_enum' in found_types}}

class CUgraphChildGraphNodeOwnership(IntEnum):
    """
    Child graph node ownership
    """
    {{if 'CU_GRAPH_CHILD_GRAPH_OWNERSHIP_CLONE' in found_values}}

    #: Default behavior for a child graph node. Child graph is cloned into
    #: the parent and memory allocation/free nodes can't be present in the
    #: child graph.
    CU_GRAPH_CHILD_GRAPH_OWNERSHIP_CLONE = cydriver.CUgraphChildGraphNodeOwnership_enum.CU_GRAPH_CHILD_GRAPH_OWNERSHIP_CLONE{{endif}}
    {{if 'CU_GRAPH_CHILD_GRAPH_OWNERSHIP_MOVE' in found_values}}

    #: The child graph is moved to the parent. The handle to the child
    #: graph is owned by the parent and will be destroyed when the parent
    #: is destroyed.
    #:
    #: The following restrictions apply to child graphs after they have
    #: been moved: Cannot be independently instantiated or destroyed;
    #: Cannot be added as a child graph of a separate parent graph; Cannot
    #: be used as an argument to cuGraphExecUpdate; Cannot have additional
    #: memory allocation or free nodes added.
    CU_GRAPH_CHILD_GRAPH_OWNERSHIP_MOVE = cydriver.CUgraphChildGraphNodeOwnership_enum.CU_GRAPH_CHILD_GRAPH_OWNERSHIP_MOVE{{endif}}

_dict_CUgraphChildGraphNodeOwnership = dict(((int(v), v) for k, v in CUgraphChildGraphNodeOwnership.__members__.items()))
{{endif}}
{{if 'CUflushGPUDirectRDMAWritesOptions_enum' in found_types}}

class CUflushGPUDirectRDMAWritesOptions(IntEnum):
    """
    Bitmasks for
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS`
    """
    {{if 'CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST' in found_values}}

    #: :py:obj:`~.cuFlushGPUDirectRDMAWrites()` and its CUDA Runtime API
    #: counterpart are supported on the device.
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST = cydriver.CUflushGPUDirectRDMAWritesOptions_enum.CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST{{endif}}
    {{if 'CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS' in found_values}}

    #: The :py:obj:`~.CU_STREAM_WAIT_VALUE_FLUSH` flag and the
    #: :py:obj:`~.CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES` MemOp are supported
    #: on the device.
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS = cydriver.CUflushGPUDirectRDMAWritesOptions_enum.CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS{{endif}}

_dict_CUflushGPUDirectRDMAWritesOptions = dict(((int(v), v) for k, v in CUflushGPUDirectRDMAWritesOptions.__members__.items()))
{{endif}}
{{if 'CUGPUDirectRDMAWritesOrdering_enum' in found_types}}

class CUGPUDirectRDMAWritesOrdering(IntEnum):
    """
    Platform native ordering for GPUDirect RDMA writes
    """
    {{if 'CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE' in found_values}}

    #: The device does not natively support ordering of remote writes.
    #: :py:obj:`~.cuFlushGPUDirectRDMAWrites()` can be leveraged if
    #: supported.
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE = cydriver.CUGPUDirectRDMAWritesOrdering_enum.CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE{{endif}}
    {{if 'CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER' in found_values}}

    #: Natively, the device can consistently consume remote writes,
    #: although other CUDA devices may not.
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER = cydriver.CUGPUDirectRDMAWritesOrdering_enum.CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER{{endif}}
    {{if 'CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES' in found_values}}

    #: Any CUDA device in the system can consistently consume remote writes
    #: to this device.
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES = cydriver.CUGPUDirectRDMAWritesOrdering_enum.CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES{{endif}}

_dict_CUGPUDirectRDMAWritesOrdering = dict(((int(v), v) for k, v in CUGPUDirectRDMAWritesOrdering.__members__.items()))
{{endif}}
{{if 'CUflushGPUDirectRDMAWritesScope_enum' in found_types}}

class CUflushGPUDirectRDMAWritesScope(IntEnum):
    """
    The scopes for :py:obj:`~.cuFlushGPUDirectRDMAWrites`
    """
    {{if 'CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER' in found_values}}

    #: Blocks until remote writes are visible to the CUDA device context
    #: owning the data.
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER = cydriver.CUflushGPUDirectRDMAWritesScope_enum.CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER{{endif}}
    {{if 'CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES' in found_values}}

    #: Blocks until remote writes are visible to all CUDA device contexts.
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES = cydriver.CUflushGPUDirectRDMAWritesScope_enum.CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES{{endif}}

_dict_CUflushGPUDirectRDMAWritesScope = dict(((int(v), v) for k, v in CUflushGPUDirectRDMAWritesScope.__members__.items()))
{{endif}}
{{if 'CUflushGPUDirectRDMAWritesTarget_enum' in found_types}}

class CUflushGPUDirectRDMAWritesTarget(IntEnum):
    """
    The targets for :py:obj:`~.cuFlushGPUDirectRDMAWrites`
    """
    {{if 'CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX' in found_values}}

    #: Sets the target for :py:obj:`~.cuFlushGPUDirectRDMAWrites()` to the
    #: currently active CUDA device context.
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX = cydriver.CUflushGPUDirectRDMAWritesTarget_enum.CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX{{endif}}

_dict_CUflushGPUDirectRDMAWritesTarget = dict(((int(v), v) for k, v in CUflushGPUDirectRDMAWritesTarget.__members__.items()))
{{endif}}
{{if 'CUgraphDebugDot_flags_enum' in found_types}}

class CUgraphDebugDot_flags(IntEnum):
    """
    The additional write options for :py:obj:`~.cuGraphDebugDotPrint`
    """
    {{if 'CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE' in found_values}}

    #: Output all debug data as if every debug flag is enabled
    CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE = cydriver.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE{{endif}}
    {{if 'CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES' in found_values}}

    #: Use CUDA Runtime structures for output
    CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES = cydriver.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES{{endif}}
    {{if 'CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS' in found_values}}

    #: Adds CUDA_KERNEL_NODE_PARAMS values to output
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS = cydriver.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS{{endif}}
    {{if 'CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS' in found_values}}

    #: Adds CUDA_MEMCPY3D values to output
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS = cydriver.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS{{endif}}
    {{if 'CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS' in found_values}}

    #: Adds CUDA_MEMSET_NODE_PARAMS values to output
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS = cydriver.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS{{endif}}
    {{if 'CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS' in found_values}}

    #: Adds CUDA_HOST_NODE_PARAMS values to output
    CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS = cydriver.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS{{endif}}
    {{if 'CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS' in found_values}}

    #: Adds CUevent handle from record and wait nodes to output
    CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS = cydriver.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS{{endif}}
    {{if 'CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS' in found_values}}

    #: Adds CUDA_EXT_SEM_SIGNAL_NODE_PARAMS values to output
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS = cydriver.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS{{endif}}
    {{if 'CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS' in found_values}}

    #: Adds CUDA_EXT_SEM_WAIT_NODE_PARAMS values to output
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS = cydriver.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS{{endif}}
    {{if 'CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES' in found_values}}

    #: Adds CUkernelNodeAttrValue values to output
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES = cydriver.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES{{endif}}
    {{if 'CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES' in found_values}}

    #: Adds node handles and every kernel function handle to output
    CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES = cydriver.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES{{endif}}
    {{if 'CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS' in found_values}}

    #: Adds memory alloc node parameters to output
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS = cydriver.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS{{endif}}
    {{if 'CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS' in found_values}}

    #: Adds memory free node parameters to output
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS = cydriver.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS{{endif}}
    {{if 'CU_GRAPH_DEBUG_DOT_FLAGS_BATCH_MEM_OP_NODE_PARAMS' in found_values}}

    #: Adds batch mem op node parameters to output
    CU_GRAPH_DEBUG_DOT_FLAGS_BATCH_MEM_OP_NODE_PARAMS = cydriver.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_BATCH_MEM_OP_NODE_PARAMS{{endif}}
    {{if 'CU_GRAPH_DEBUG_DOT_FLAGS_EXTRA_TOPO_INFO' in found_values}}

    #: Adds edge numbering information
    CU_GRAPH_DEBUG_DOT_FLAGS_EXTRA_TOPO_INFO = cydriver.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_EXTRA_TOPO_INFO{{endif}}
    {{if 'CU_GRAPH_DEBUG_DOT_FLAGS_CONDITIONAL_NODE_PARAMS' in found_values}}

    #: Adds conditional node parameters to output
    CU_GRAPH_DEBUG_DOT_FLAGS_CONDITIONAL_NODE_PARAMS = cydriver.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_CONDITIONAL_NODE_PARAMS{{endif}}

_dict_CUgraphDebugDot_flags = dict(((int(v), v) for k, v in CUgraphDebugDot_flags.__members__.items()))
{{endif}}
{{if 'CUuserObject_flags_enum' in found_types}}

class CUuserObject_flags(IntEnum):
    """
    Flags for user objects for graphs
    """
    {{if 'CU_USER_OBJECT_NO_DESTRUCTOR_SYNC' in found_values}}

    #: Indicates the destructor execution is not synchronized by any CUDA
    #: handle.
    CU_USER_OBJECT_NO_DESTRUCTOR_SYNC = cydriver.CUuserObject_flags_enum.CU_USER_OBJECT_NO_DESTRUCTOR_SYNC{{endif}}

_dict_CUuserObject_flags = dict(((int(v), v) for k, v in CUuserObject_flags.__members__.items()))
{{endif}}
{{if 'CUuserObjectRetain_flags_enum' in found_types}}

class CUuserObjectRetain_flags(IntEnum):
    """
    Flags for retaining user object references for graphs
    """
    {{if 'CU_GRAPH_USER_OBJECT_MOVE' in found_values}}

    #: Transfer references from the caller rather than creating new
    #: references.
    CU_GRAPH_USER_OBJECT_MOVE = cydriver.CUuserObjectRetain_flags_enum.CU_GRAPH_USER_OBJECT_MOVE{{endif}}

_dict_CUuserObjectRetain_flags = dict(((int(v), v) for k, v in CUuserObjectRetain_flags.__members__.items()))
{{endif}}
{{if 'CUgraphInstantiate_flags_enum' in found_types}}

class CUgraphInstantiate_flags(IntEnum):
    """
    Flags for instantiating a graph
    """
    {{if 'CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH' in found_values}}

    #: Automatically free memory allocated in a graph before relaunching.
    CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH = cydriver.CUgraphInstantiate_flags_enum.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH{{endif}}
    {{if 'CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD' in found_values}}

    #: Automatically upload the graph after instantiation. Only supported
    #: by :py:obj:`~.cuGraphInstantiateWithParams`. The upload will be
    #: performed using the stream provided in `instantiateParams`.
    CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD = cydriver.CUgraphInstantiate_flags_enum.CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD{{endif}}
    {{if 'CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH' in found_values}}

    #: Instantiate the graph to be launchable from the device. This flag
    #: can only be used on platforms which support unified addressing. This
    #: flag cannot be used in conjunction with
    #: CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH.
    CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH = cydriver.CUgraphInstantiate_flags_enum.CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH{{endif}}
    {{if 'CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY' in found_values}}

    #: Run the graph using the per-node priority attributes rather than the
    #: priority of the stream it is launched into.
    CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY = cydriver.CUgraphInstantiate_flags_enum.CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY{{endif}}

_dict_CUgraphInstantiate_flags = dict(((int(v), v) for k, v in CUgraphInstantiate_flags.__members__.items()))
{{endif}}
{{if 'CUdeviceNumaConfig_enum' in found_types}}

class CUdeviceNumaConfig(IntEnum):
    """
    CUDA device NUMA configuration
    """
    {{if 'CU_DEVICE_NUMA_CONFIG_NONE' in found_values}}

    #: The GPU is not a NUMA node
    CU_DEVICE_NUMA_CONFIG_NONE = cydriver.CUdeviceNumaConfig_enum.CU_DEVICE_NUMA_CONFIG_NONE{{endif}}
    {{if 'CU_DEVICE_NUMA_CONFIG_NUMA_NODE' in found_values}}

    #: The GPU is a NUMA node, CU_DEVICE_ATTRIBUTE_NUMA_ID contains its
    #: NUMA ID
    CU_DEVICE_NUMA_CONFIG_NUMA_NODE = cydriver.CUdeviceNumaConfig_enum.CU_DEVICE_NUMA_CONFIG_NUMA_NODE{{endif}}

_dict_CUdeviceNumaConfig = dict(((int(v), v) for k, v in CUdeviceNumaConfig.__members__.items()))
{{endif}}
{{if 'CUprocessState_enum' in found_types}}

class CUprocessState(IntEnum):
    """
    CUDA Process States
    """
    {{if 'CU_PROCESS_STATE_RUNNING' in found_values}}

    #: Default process state
    CU_PROCESS_STATE_RUNNING = cydriver.CUprocessState_enum.CU_PROCESS_STATE_RUNNING{{endif}}
    {{if 'CU_PROCESS_STATE_LOCKED' in found_values}}

    #: CUDA API locks are taken so further CUDA API calls will block
    CU_PROCESS_STATE_LOCKED = cydriver.CUprocessState_enum.CU_PROCESS_STATE_LOCKED{{endif}}
    {{if 'CU_PROCESS_STATE_CHECKPOINTED' in found_values}}

    #: Application memory contents have been checkpointed and underlying
    #: allocations and device handles have been released
    CU_PROCESS_STATE_CHECKPOINTED = cydriver.CUprocessState_enum.CU_PROCESS_STATE_CHECKPOINTED{{endif}}
    {{if 'CU_PROCESS_STATE_FAILED' in found_values}}

    #: Application entered an uncorrectable error during the
    #: checkpoint/restore process
    CU_PROCESS_STATE_FAILED = cydriver.CUprocessState_enum.CU_PROCESS_STATE_FAILED{{endif}}

_dict_CUprocessState = dict(((int(v), v) for k, v in CUprocessState.__members__.items()))
{{endif}}
{{if 'CUmoduleLoadingMode_enum' in found_types}}

class CUmoduleLoadingMode(IntEnum):
    """
    CUDA Lazy Loading status
    """
    {{if 'CU_MODULE_EAGER_LOADING' in found_values}}

    #: Lazy Kernel Loading is not enabled
    CU_MODULE_EAGER_LOADING = cydriver.CUmoduleLoadingMode_enum.CU_MODULE_EAGER_LOADING{{endif}}
    {{if 'CU_MODULE_LAZY_LOADING' in found_values}}

    #: Lazy Kernel Loading is enabled
    CU_MODULE_LAZY_LOADING = cydriver.CUmoduleLoadingMode_enum.CU_MODULE_LAZY_LOADING{{endif}}

_dict_CUmoduleLoadingMode = dict(((int(v), v) for k, v in CUmoduleLoadingMode.__members__.items()))
{{endif}}
{{if 'CUmemDecompressAlgorithm_enum' in found_types}}

class CUmemDecompressAlgorithm(IntEnum):
    """
    Bitmasks for CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_ALGORITHM_MASK.
    """
    {{if 'CU_MEM_DECOMPRESS_UNSUPPORTED' in found_values}}

    #: Decompression is unsupported.
    CU_MEM_DECOMPRESS_UNSUPPORTED = cydriver.CUmemDecompressAlgorithm_enum.CU_MEM_DECOMPRESS_UNSUPPORTED{{endif}}
    {{if 'CU_MEM_DECOMPRESS_ALGORITHM_DEFLATE' in found_values}}

    #: Deflate is supported.
    CU_MEM_DECOMPRESS_ALGORITHM_DEFLATE = cydriver.CUmemDecompressAlgorithm_enum.CU_MEM_DECOMPRESS_ALGORITHM_DEFLATE{{endif}}
    {{if 'CU_MEM_DECOMPRESS_ALGORITHM_SNAPPY' in found_values}}

    #: Snappy is supported.
    CU_MEM_DECOMPRESS_ALGORITHM_SNAPPY = cydriver.CUmemDecompressAlgorithm_enum.CU_MEM_DECOMPRESS_ALGORITHM_SNAPPY{{endif}}
    {{if 'CU_MEM_DECOMPRESS_ALGORITHM_LZ4' in found_values}}

    #: LZ4 is supported.
    CU_MEM_DECOMPRESS_ALGORITHM_LZ4 = cydriver.CUmemDecompressAlgorithm_enum.CU_MEM_DECOMPRESS_ALGORITHM_LZ4{{endif}}

_dict_CUmemDecompressAlgorithm = dict(((int(v), v) for k, v in CUmemDecompressAlgorithm.__members__.items()))
{{endif}}
{{if 'CUfunctionLoadingState_enum' in found_types}}

class CUfunctionLoadingState(IntEnum):
    """

    """
    {{if 'CU_FUNCTION_LOADING_STATE_UNLOADED' in found_values}}
    CU_FUNCTION_LOADING_STATE_UNLOADED = cydriver.CUfunctionLoadingState_enum.CU_FUNCTION_LOADING_STATE_UNLOADED{{endif}}
    {{if 'CU_FUNCTION_LOADING_STATE_LOADED' in found_values}}
    CU_FUNCTION_LOADING_STATE_LOADED = cydriver.CUfunctionLoadingState_enum.CU_FUNCTION_LOADING_STATE_LOADED{{endif}}
    {{if 'CU_FUNCTION_LOADING_STATE_MAX' in found_values}}
    CU_FUNCTION_LOADING_STATE_MAX = cydriver.CUfunctionLoadingState_enum.CU_FUNCTION_LOADING_STATE_MAX{{endif}}

_dict_CUfunctionLoadingState = dict(((int(v), v) for k, v in CUfunctionLoadingState.__members__.items()))
{{endif}}
{{if 'CUcoredumpSettings_enum' in found_types}}

class CUcoredumpSettings(IntEnum):
    """
    Flags for choosing a coredump attribute to get/set
    """
    {{if 'CU_COREDUMP_ENABLE_ON_EXCEPTION' in found_values}}
    CU_COREDUMP_ENABLE_ON_EXCEPTION = cydriver.CUcoredumpSettings_enum.CU_COREDUMP_ENABLE_ON_EXCEPTION{{endif}}
    {{if 'CU_COREDUMP_TRIGGER_HOST' in found_values}}
    CU_COREDUMP_TRIGGER_HOST = cydriver.CUcoredumpSettings_enum.CU_COREDUMP_TRIGGER_HOST{{endif}}
    {{if 'CU_COREDUMP_LIGHTWEIGHT' in found_values}}
    CU_COREDUMP_LIGHTWEIGHT = cydriver.CUcoredumpSettings_enum.CU_COREDUMP_LIGHTWEIGHT{{endif}}
    {{if 'CU_COREDUMP_ENABLE_USER_TRIGGER' in found_values}}
    CU_COREDUMP_ENABLE_USER_TRIGGER = cydriver.CUcoredumpSettings_enum.CU_COREDUMP_ENABLE_USER_TRIGGER{{endif}}
    {{if 'CU_COREDUMP_FILE' in found_values}}
    CU_COREDUMP_FILE = cydriver.CUcoredumpSettings_enum.CU_COREDUMP_FILE{{endif}}
    {{if 'CU_COREDUMP_PIPE' in found_values}}
    CU_COREDUMP_PIPE = cydriver.CUcoredumpSettings_enum.CU_COREDUMP_PIPE{{endif}}
    {{if 'CU_COREDUMP_GENERATION_FLAGS' in found_values}}
    CU_COREDUMP_GENERATION_FLAGS = cydriver.CUcoredumpSettings_enum.CU_COREDUMP_GENERATION_FLAGS{{endif}}
    {{if 'CU_COREDUMP_MAX' in found_values}}
    CU_COREDUMP_MAX = cydriver.CUcoredumpSettings_enum.CU_COREDUMP_MAX{{endif}}

_dict_CUcoredumpSettings = dict(((int(v), v) for k, v in CUcoredumpSettings.__members__.items()))
{{endif}}
{{if 'CUCoredumpGenerationFlags' in found_types}}

class CUCoredumpGenerationFlags(IntEnum):
    """
    Flags for controlling coredump contents
    """
    {{if 'CU_COREDUMP_DEFAULT_FLAGS' in found_values}}
    CU_COREDUMP_DEFAULT_FLAGS = cydriver.CUCoredumpGenerationFlags.CU_COREDUMP_DEFAULT_FLAGS{{endif}}
    {{if 'CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES' in found_values}}
    CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES = cydriver.CUCoredumpGenerationFlags.CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES{{endif}}
    {{if 'CU_COREDUMP_SKIP_GLOBAL_MEMORY' in found_values}}
    CU_COREDUMP_SKIP_GLOBAL_MEMORY = cydriver.CUCoredumpGenerationFlags.CU_COREDUMP_SKIP_GLOBAL_MEMORY{{endif}}
    {{if 'CU_COREDUMP_SKIP_SHARED_MEMORY' in found_values}}
    CU_COREDUMP_SKIP_SHARED_MEMORY = cydriver.CUCoredumpGenerationFlags.CU_COREDUMP_SKIP_SHARED_MEMORY{{endif}}
    {{if 'CU_COREDUMP_SKIP_LOCAL_MEMORY' in found_values}}
    CU_COREDUMP_SKIP_LOCAL_MEMORY = cydriver.CUCoredumpGenerationFlags.CU_COREDUMP_SKIP_LOCAL_MEMORY{{endif}}
    {{if 'CU_COREDUMP_SKIP_ABORT' in found_values}}
    CU_COREDUMP_SKIP_ABORT = cydriver.CUCoredumpGenerationFlags.CU_COREDUMP_SKIP_ABORT{{endif}}
    {{if 'CU_COREDUMP_SKIP_CONSTBANK_MEMORY' in found_values}}
    CU_COREDUMP_SKIP_CONSTBANK_MEMORY = cydriver.CUCoredumpGenerationFlags.CU_COREDUMP_SKIP_CONSTBANK_MEMORY{{endif}}
    {{if 'CU_COREDUMP_LIGHTWEIGHT_FLAGS' in found_values}}
    CU_COREDUMP_LIGHTWEIGHT_FLAGS = cydriver.CUCoredumpGenerationFlags.CU_COREDUMP_LIGHTWEIGHT_FLAGS{{endif}}

_dict_CUCoredumpGenerationFlags = dict(((int(v), v) for k, v in CUCoredumpGenerationFlags.__members__.items()))
{{endif}}
{{if 'CUgreenCtxCreate_flags' in found_types}}

class CUgreenCtxCreate_flags(IntEnum):
    """

    """
    {{if 'CU_GREEN_CTX_DEFAULT_STREAM' in found_values}}

    #: Required. Creates a default stream to use inside the green context
    CU_GREEN_CTX_DEFAULT_STREAM = cydriver.CUgreenCtxCreate_flags.CU_GREEN_CTX_DEFAULT_STREAM{{endif}}

_dict_CUgreenCtxCreate_flags = dict(((int(v), v) for k, v in CUgreenCtxCreate_flags.__members__.items()))
{{endif}}
{{if 'CUdevSmResourceSplit_flags' in found_types}}

class CUdevSmResourceSplit_flags(IntEnum):
    """

    """
    {{if 'CU_DEV_SM_RESOURCE_SPLIT_IGNORE_SM_COSCHEDULING' in found_values}}
    CU_DEV_SM_RESOURCE_SPLIT_IGNORE_SM_COSCHEDULING = cydriver.CUdevSmResourceSplit_flags.CU_DEV_SM_RESOURCE_SPLIT_IGNORE_SM_COSCHEDULING{{endif}}
    {{if 'CU_DEV_SM_RESOURCE_SPLIT_MAX_POTENTIAL_CLUSTER_SIZE' in found_values}}
    CU_DEV_SM_RESOURCE_SPLIT_MAX_POTENTIAL_CLUSTER_SIZE = cydriver.CUdevSmResourceSplit_flags.CU_DEV_SM_RESOURCE_SPLIT_MAX_POTENTIAL_CLUSTER_SIZE{{endif}}

_dict_CUdevSmResourceSplit_flags = dict(((int(v), v) for k, v in CUdevSmResourceSplit_flags.__members__.items()))
{{endif}}
{{if 'CUdevResourceType' in found_types}}

class CUdevResourceType(IntEnum):
    """
    Type of resource
    """
    {{if 'CU_DEV_RESOURCE_TYPE_INVALID' in found_values}}
    CU_DEV_RESOURCE_TYPE_INVALID = cydriver.CUdevResourceType.CU_DEV_RESOURCE_TYPE_INVALID{{endif}}
    {{if 'CU_DEV_RESOURCE_TYPE_SM' in found_values}}

    #: Streaming multiprocessors related information
    CU_DEV_RESOURCE_TYPE_SM = cydriver.CUdevResourceType.CU_DEV_RESOURCE_TYPE_SM{{endif}}

_dict_CUdevResourceType = dict(((int(v), v) for k, v in CUdevResourceType.__members__.items()))
{{endif}}
{{if 'CUlogLevel_enum' in found_types}}

class CUlogLevel(IntEnum):
    """

    """
    {{if 'CU_LOG_LEVEL_ERROR' in found_values}}
    CU_LOG_LEVEL_ERROR = cydriver.CUlogLevel_enum.CU_LOG_LEVEL_ERROR{{endif}}
    {{if 'CU_LOG_LEVEL_WARNING' in found_values}}
    CU_LOG_LEVEL_WARNING = cydriver.CUlogLevel_enum.CU_LOG_LEVEL_WARNING{{endif}}

_dict_CUlogLevel = dict(((int(v), v) for k, v in CUlogLevel.__members__.items()))
{{endif}}
{{if 'CUoutput_mode_enum' in found_types}}

class CUoutput_mode(IntEnum):
    """
    Profiler Output Modes
    """
    {{if 'CU_OUT_KEY_VALUE_PAIR' in found_values}}

    #: Output mode Key-Value pair format.
    CU_OUT_KEY_VALUE_PAIR = cydriver.CUoutput_mode_enum.CU_OUT_KEY_VALUE_PAIR{{endif}}
    {{if 'CU_OUT_CSV' in found_values}}

    #: Output mode Comma separated values format.
    CU_OUT_CSV = cydriver.CUoutput_mode_enum.CU_OUT_CSV{{endif}}

_dict_CUoutput_mode = dict(((int(v), v) for k, v in CUoutput_mode.__members__.items()))
{{endif}}
{{if True}}

class CUeglFrameType(IntEnum):
    """
    CUDA EglFrame type - array or pointer
    """
    {{if True}}

    #: Frame type CUDA array
    CU_EGL_FRAME_TYPE_ARRAY = cydriver.CUeglFrameType_enum.CU_EGL_FRAME_TYPE_ARRAY{{endif}}
    {{if True}}

    #: Frame type pointer
    CU_EGL_FRAME_TYPE_PITCH = cydriver.CUeglFrameType_enum.CU_EGL_FRAME_TYPE_PITCH{{endif}}

_dict_CUeglFrameType = dict(((int(v), v) for k, v in CUeglFrameType.__members__.items()))
{{endif}}
{{if True}}

class CUeglResourceLocationFlags(IntEnum):
    """
    Resource location flags- sysmem or vidmem  For CUDA context on
    iGPU, since video and system memory are equivalent - these flags
    will not have an effect on the execution.  For CUDA context on
    dGPU, applications can use the flag
    :py:obj:`~.CUeglResourceLocationFlags` to give a hint about the
    desired location.  :py:obj:`~.CU_EGL_RESOURCE_LOCATION_SYSMEM` -
    the frame data is made resident on the system memory to be accessed
    by CUDA.  :py:obj:`~.CU_EGL_RESOURCE_LOCATION_VIDMEM` - the frame
    data is made resident on the dedicated video memory to be accessed
    by CUDA.  There may be an additional latency due to new allocation
    and data migration, if the frame is produced on a different memory.
    """
    {{if True}}

    #: Resource location sysmem
    CU_EGL_RESOURCE_LOCATION_SYSMEM = cydriver.CUeglResourceLocationFlags_enum.CU_EGL_RESOURCE_LOCATION_SYSMEM{{endif}}
    {{if True}}

    #: Resource location vidmem
    CU_EGL_RESOURCE_LOCATION_VIDMEM = cydriver.CUeglResourceLocationFlags_enum.CU_EGL_RESOURCE_LOCATION_VIDMEM{{endif}}

_dict_CUeglResourceLocationFlags = dict(((int(v), v) for k, v in CUeglResourceLocationFlags.__members__.items()))
{{endif}}
{{if True}}

class CUeglColorFormat(IntEnum):
    """
    CUDA EGL Color Format - The different planar and multiplanar
    formats currently supported for CUDA_EGL interops. Three channel
    formats are currently not supported for
    :py:obj:`~.CU_EGL_FRAME_TYPE_ARRAY`
    """
    {{if True}}

    #: Y, U, V in three surfaces, each in a separate surface, U/V width =
    #: 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YUV420_PLANAR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV420_PLANAR{{endif}}
    {{if True}}

    #: Y, UV in two surfaces (UV as one surface) with VU byte ordering,
    #: width, height ratio same as YUV420Planar.
    CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR{{endif}}
    {{if True}}

    #: Y, U, V each in a separate surface, U/V width = 1/2 Y width, U/V
    #: height = Y height.
    CU_EGL_COLOR_FORMAT_YUV422_PLANAR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV422_PLANAR{{endif}}
    {{if True}}

    #: Y, UV in two surfaces with VU byte ordering, width, height ratio
    #: same as YUV422Planar.
    CU_EGL_COLOR_FORMAT_YUV422_SEMIPLANAR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV422_SEMIPLANAR{{endif}}
    {{if True}}

    #: R/G/B three channels in one surface with BGR byte ordering. Only
    #: pitch linear format supported.
    CU_EGL_COLOR_FORMAT_RGB = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_RGB{{endif}}
    {{if True}}

    #: R/G/B three channels in one surface with RGB byte ordering. Only
    #: pitch linear format supported.
    CU_EGL_COLOR_FORMAT_BGR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BGR{{endif}}
    {{if True}}

    #: R/G/B/A four channels in one surface with BGRA byte ordering.
    CU_EGL_COLOR_FORMAT_ARGB = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_ARGB{{endif}}
    {{if True}}

    #: R/G/B/A four channels in one surface with ABGR byte ordering.
    CU_EGL_COLOR_FORMAT_RGBA = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_RGBA{{endif}}
    {{if True}}

    #: single luminance channel in one surface.
    CU_EGL_COLOR_FORMAT_L = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_L{{endif}}
    {{if True}}

    #: single color channel in one surface.
    CU_EGL_COLOR_FORMAT_R = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_R{{endif}}
    {{if True}}

    #: Y, U, V in three surfaces, each in a separate surface, U/V width = Y
    #: width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YUV444_PLANAR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV444_PLANAR{{endif}}
    {{if True}}

    #: Y, UV in two surfaces (UV as one surface) with VU byte ordering,
    #: width, height ratio same as YUV444Planar.
    CU_EGL_COLOR_FORMAT_YUV444_SEMIPLANAR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV444_SEMIPLANAR{{endif}}
    {{if True}}

    #: Y, U, V in one surface, interleaved as UYVY in one channel.
    CU_EGL_COLOR_FORMAT_YUYV_422 = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUYV_422{{endif}}
    {{if True}}

    #: Y, U, V in one surface, interleaved as YUYV in one channel.
    CU_EGL_COLOR_FORMAT_UYVY_422 = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_UYVY_422{{endif}}
    {{if True}}

    #: R/G/B/A four channels in one surface with RGBA byte ordering.
    CU_EGL_COLOR_FORMAT_ABGR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_ABGR{{endif}}
    {{if True}}

    #: R/G/B/A four channels in one surface with ARGB byte ordering.
    CU_EGL_COLOR_FORMAT_BGRA = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BGRA{{endif}}
    {{if True}}

    #: Alpha color format - one channel in one surface.
    CU_EGL_COLOR_FORMAT_A = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_A{{endif}}
    {{if True}}

    #: R/G color format - two channels in one surface with GR byte ordering
    CU_EGL_COLOR_FORMAT_RG = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_RG{{endif}}
    {{if True}}

    #: Y, U, V, A four channels in one surface, interleaved as VUYA.
    CU_EGL_COLOR_FORMAT_AYUV = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_AYUV{{endif}}
    {{if True}}

    #: Y, VU in two surfaces (VU as one surface) with UV byte ordering, U/V
    #: width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YVU444_SEMIPLANAR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU444_SEMIPLANAR{{endif}}
    {{if True}}

    #: Y, VU in two surfaces (VU as one surface) with UV byte ordering, U/V
    #: width = 1/2 Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YVU422_SEMIPLANAR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU422_SEMIPLANAR{{endif}}
    {{if True}}

    #: Y, VU in two surfaces (VU as one surface) with UV byte ordering, U/V
    #: width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR{{endif}}
    {{if True}}

    #: Y10, V10U10 in two surfaces (VU as one surface) with UV byte
    #: ordering, U/V width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR{{endif}}
    {{if True}}

    #: Y10, V10U10 in two surfaces (VU as one surface) with UV byte
    #: ordering, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR{{endif}}
    {{if True}}

    #: Y12, V12U12 in two surfaces (VU as one surface) with UV byte
    #: ordering, U/V width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR{{endif}}
    {{if True}}

    #: Y12, V12U12 in two surfaces (VU as one surface) with UV byte
    #: ordering, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR{{endif}}
    {{if True}}

    #: Extended Range Y, U, V in one surface, interleaved as YVYU in one
    #: channel.
    CU_EGL_COLOR_FORMAT_VYUY_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_VYUY_ER{{endif}}
    {{if True}}

    #: Extended Range Y, U, V in one surface, interleaved as YUYV in one
    #: channel.
    CU_EGL_COLOR_FORMAT_UYVY_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_UYVY_ER{{endif}}
    {{if True}}

    #: Extended Range Y, U, V in one surface, interleaved as UYVY in one
    #: channel.
    CU_EGL_COLOR_FORMAT_YUYV_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUYV_ER{{endif}}
    {{if True}}

    #: Extended Range Y, U, V in one surface, interleaved as VYUY in one
    #: channel.
    CU_EGL_COLOR_FORMAT_YVYU_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVYU_ER{{endif}}
    {{if True}}

    #: Extended Range Y, U, V three channels in one surface, interleaved as
    #: VUY. Only pitch linear format supported.
    CU_EGL_COLOR_FORMAT_YUV_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV_ER{{endif}}
    {{if True}}

    #: Extended Range Y, U, V, A four channels in one surface, interleaved
    #: as AVUY.
    CU_EGL_COLOR_FORMAT_YUVA_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUVA_ER{{endif}}
    {{if True}}

    #: Extended Range Y, U, V, A four channels in one surface, interleaved
    #: as VUYA.
    CU_EGL_COLOR_FORMAT_AYUV_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_AYUV_ER{{endif}}
    {{if True}}

    #: Extended Range Y, U, V in three surfaces, U/V width = Y width, U/V
    #: height = Y height.
    CU_EGL_COLOR_FORMAT_YUV444_PLANAR_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV444_PLANAR_ER{{endif}}
    {{if True}}

    #: Extended Range Y, U, V in three surfaces, U/V width = 1/2 Y width,
    #: U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YUV422_PLANAR_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV422_PLANAR_ER{{endif}}
    {{if True}}

    #: Extended Range Y, U, V in three surfaces, U/V width = 1/2 Y width,
    #: U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YUV420_PLANAR_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV420_PLANAR_ER{{endif}}
    {{if True}}

    #: Extended Range Y, UV in two surfaces (UV as one surface) with VU
    #: byte ordering, U/V width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YUV444_SEMIPLANAR_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV444_SEMIPLANAR_ER{{endif}}
    {{if True}}

    #: Extended Range Y, UV in two surfaces (UV as one surface) with VU
    #: byte ordering, U/V width = 1/2 Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YUV422_SEMIPLANAR_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV422_SEMIPLANAR_ER{{endif}}
    {{if True}}

    #: Extended Range Y, UV in two surfaces (UV as one surface) with VU
    #: byte ordering, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_ER{{endif}}
    {{if True}}

    #: Extended Range Y, V, U in three surfaces, U/V width = Y width, U/V
    #: height = Y height.
    CU_EGL_COLOR_FORMAT_YVU444_PLANAR_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU444_PLANAR_ER{{endif}}
    {{if True}}

    #: Extended Range Y, V, U in three surfaces, U/V width = 1/2 Y width,
    #: U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YVU422_PLANAR_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU422_PLANAR_ER{{endif}}
    {{if True}}

    #: Extended Range Y, V, U in three surfaces, U/V width = 1/2 Y width,
    #: U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YVU420_PLANAR_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU420_PLANAR_ER{{endif}}
    {{if True}}

    #: Extended Range Y, VU in two surfaces (VU as one surface) with UV
    #: byte ordering, U/V width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YVU444_SEMIPLANAR_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU444_SEMIPLANAR_ER{{endif}}
    {{if True}}

    #: Extended Range Y, VU in two surfaces (VU as one surface) with UV
    #: byte ordering, U/V width = 1/2 Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YVU422_SEMIPLANAR_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU422_SEMIPLANAR_ER{{endif}}
    {{if True}}

    #: Extended Range Y, VU in two surfaces (VU as one surface) with UV
    #: byte ordering, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_ER{{endif}}
    {{if True}}

    #: Bayer format - one channel in one surface with interleaved RGGB
    #: ordering.
    CU_EGL_COLOR_FORMAT_BAYER_RGGB = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_RGGB{{endif}}
    {{if True}}

    #: Bayer format - one channel in one surface with interleaved BGGR
    #: ordering.
    CU_EGL_COLOR_FORMAT_BAYER_BGGR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_BGGR{{endif}}
    {{if True}}

    #: Bayer format - one channel in one surface with interleaved GRBG
    #: ordering.
    CU_EGL_COLOR_FORMAT_BAYER_GRBG = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_GRBG{{endif}}
    {{if True}}

    #: Bayer format - one channel in one surface with interleaved GBRG
    #: ordering.
    CU_EGL_COLOR_FORMAT_BAYER_GBRG = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_GBRG{{endif}}
    {{if True}}

    #: Bayer10 format - one channel in one surface with interleaved RGGB
    #: ordering. Out of 16 bits, 10 bits used 6 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER10_RGGB = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER10_RGGB{{endif}}
    {{if True}}

    #: Bayer10 format - one channel in one surface with interleaved BGGR
    #: ordering. Out of 16 bits, 10 bits used 6 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER10_BGGR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER10_BGGR{{endif}}
    {{if True}}

    #: Bayer10 format - one channel in one surface with interleaved GRBG
    #: ordering. Out of 16 bits, 10 bits used 6 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER10_GRBG = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER10_GRBG{{endif}}
    {{if True}}

    #: Bayer10 format - one channel in one surface with interleaved GBRG
    #: ordering. Out of 16 bits, 10 bits used 6 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER10_GBRG = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER10_GBRG{{endif}}
    {{if True}}

    #: Bayer12 format - one channel in one surface with interleaved RGGB
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_RGGB = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_RGGB{{endif}}
    {{if True}}

    #: Bayer12 format - one channel in one surface with interleaved BGGR
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_BGGR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_BGGR{{endif}}
    {{if True}}

    #: Bayer12 format - one channel in one surface with interleaved GRBG
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_GRBG = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_GRBG{{endif}}
    {{if True}}

    #: Bayer12 format - one channel in one surface with interleaved GBRG
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_GBRG = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_GBRG{{endif}}
    {{if True}}

    #: Bayer14 format - one channel in one surface with interleaved RGGB
    #: ordering. Out of 16 bits, 14 bits used 2 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER14_RGGB = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER14_RGGB{{endif}}
    {{if True}}

    #: Bayer14 format - one channel in one surface with interleaved BGGR
    #: ordering. Out of 16 bits, 14 bits used 2 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER14_BGGR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER14_BGGR{{endif}}
    {{if True}}

    #: Bayer14 format - one channel in one surface with interleaved GRBG
    #: ordering. Out of 16 bits, 14 bits used 2 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER14_GRBG = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER14_GRBG{{endif}}
    {{if True}}

    #: Bayer14 format - one channel in one surface with interleaved GBRG
    #: ordering. Out of 16 bits, 14 bits used 2 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER14_GBRG = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER14_GBRG{{endif}}
    {{if True}}

    #: Bayer20 format - one channel in one surface with interleaved RGGB
    #: ordering. Out of 32 bits, 20 bits used 12 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER20_RGGB = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER20_RGGB{{endif}}
    {{if True}}

    #: Bayer20 format - one channel in one surface with interleaved BGGR
    #: ordering. Out of 32 bits, 20 bits used 12 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER20_BGGR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER20_BGGR{{endif}}
    {{if True}}

    #: Bayer20 format - one channel in one surface with interleaved GRBG
    #: ordering. Out of 32 bits, 20 bits used 12 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER20_GRBG = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER20_GRBG{{endif}}
    {{if True}}

    #: Bayer20 format - one channel in one surface with interleaved GBRG
    #: ordering. Out of 32 bits, 20 bits used 12 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER20_GBRG = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER20_GBRG{{endif}}
    {{if True}}

    #: Y, V, U in three surfaces, each in a separate surface, U/V width = Y
    #: width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YVU444_PLANAR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU444_PLANAR{{endif}}
    {{if True}}

    #: Y, V, U in three surfaces, each in a separate surface, U/V width =
    #: 1/2 Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YVU422_PLANAR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU422_PLANAR{{endif}}
    {{if True}}

    #: Y, V, U in three surfaces, each in a separate surface, U/V width =
    #: 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YVU420_PLANAR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU420_PLANAR{{endif}}
    {{if True}}

    #: Nvidia proprietary Bayer ISP format - one channel in one surface
    #: with interleaved RGGB ordering and mapped to opaque integer
    #: datatype.
    CU_EGL_COLOR_FORMAT_BAYER_ISP_RGGB = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_ISP_RGGB{{endif}}
    {{if True}}

    #: Nvidia proprietary Bayer ISP format - one channel in one surface
    #: with interleaved BGGR ordering and mapped to opaque integer
    #: datatype.
    CU_EGL_COLOR_FORMAT_BAYER_ISP_BGGR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_ISP_BGGR{{endif}}
    {{if True}}

    #: Nvidia proprietary Bayer ISP format - one channel in one surface
    #: with interleaved GRBG ordering and mapped to opaque integer
    #: datatype.
    CU_EGL_COLOR_FORMAT_BAYER_ISP_GRBG = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_ISP_GRBG{{endif}}
    {{if True}}

    #: Nvidia proprietary Bayer ISP format - one channel in one surface
    #: with interleaved GBRG ordering and mapped to opaque integer
    #: datatype.
    CU_EGL_COLOR_FORMAT_BAYER_ISP_GBRG = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_ISP_GBRG{{endif}}
    {{if True}}

    #: Bayer format - one channel in one surface with interleaved BCCR
    #: ordering.
    CU_EGL_COLOR_FORMAT_BAYER_BCCR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_BCCR{{endif}}
    {{if True}}

    #: Bayer format - one channel in one surface with interleaved RCCB
    #: ordering.
    CU_EGL_COLOR_FORMAT_BAYER_RCCB = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_RCCB{{endif}}
    {{if True}}

    #: Bayer format - one channel in one surface with interleaved CRBC
    #: ordering.
    CU_EGL_COLOR_FORMAT_BAYER_CRBC = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_CRBC{{endif}}
    {{if True}}

    #: Bayer format - one channel in one surface with interleaved CBRC
    #: ordering.
    CU_EGL_COLOR_FORMAT_BAYER_CBRC = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_CBRC{{endif}}
    {{if True}}

    #: Bayer10 format - one channel in one surface with interleaved CCCC
    #: ordering. Out of 16 bits, 10 bits used 6 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER10_CCCC = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER10_CCCC{{endif}}
    {{if True}}

    #: Bayer12 format - one channel in one surface with interleaved BCCR
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_BCCR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_BCCR{{endif}}
    {{if True}}

    #: Bayer12 format - one channel in one surface with interleaved RCCB
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_RCCB = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_RCCB{{endif}}
    {{if True}}

    #: Bayer12 format - one channel in one surface with interleaved CRBC
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_CRBC = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_CRBC{{endif}}
    {{if True}}

    #: Bayer12 format - one channel in one surface with interleaved CBRC
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_CBRC = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_CBRC{{endif}}
    {{if True}}

    #: Bayer12 format - one channel in one surface with interleaved CCCC
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_CCCC = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_CCCC{{endif}}
    {{if True}}

    #: Color format for single Y plane.
    CU_EGL_COLOR_FORMAT_Y = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y{{endif}}
    {{if True}}

    #: Y, UV in two surfaces (UV as one surface) U/V width = 1/2 Y width,
    #: U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_2020 = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_2020{{endif}}
    {{if True}}

    #: Y, VU in two surfaces (VU as one surface) U/V width = 1/2 Y width,
    #: U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_2020 = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_2020{{endif}}
    {{if True}}

    #: Y, U, V each in a separate surface, U/V width = 1/2 Y width, U/V
    #: height= 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YUV420_PLANAR_2020 = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV420_PLANAR_2020{{endif}}
    {{if True}}

    #: Y, V, U each in a separate surface, U/V width = 1/2 Y width, U/V
    #: height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YVU420_PLANAR_2020 = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU420_PLANAR_2020{{endif}}
    {{if True}}

    #: Y, UV in two surfaces (UV as one surface) U/V width = 1/2 Y width,
    #: U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_709 = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_709{{endif}}
    {{if True}}

    #: Y, VU in two surfaces (VU as one surface) U/V width = 1/2 Y width,
    #: U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_709 = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_709{{endif}}
    {{if True}}

    #: Y, U, V each in a separate surface, U/V width = 1/2 Y width, U/V
    #: height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YUV420_PLANAR_709 = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV420_PLANAR_709{{endif}}
    {{if True}}

    #: Y, V, U each in a separate surface, U/V width = 1/2 Y width, U/V
    #: height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YVU420_PLANAR_709 = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU420_PLANAR_709{{endif}}
    {{if True}}

    #: Y10, V10U10 in two surfaces (VU as one surface), U/V width = 1/2 Y
    #: width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_709 = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_709{{endif}}
    {{if True}}

    #: Y10, V10U10 in two surfaces (VU as one surface), U/V width = 1/2 Y
    #: width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_2020 = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_2020{{endif}}
    {{if True}}

    #: Y10, V10U10 in two surfaces(VU as one surface) U/V width = 1/2 Y
    #: width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR_2020 = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR_2020{{endif}}
    {{if True}}

    #: Y10, V10U10 in two surfaces(VU as one surface) U/V width = 1/2 Y
    #: width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR{{endif}}
    {{if True}}

    #: Y10, V10U10 in two surfaces(VU as one surface) U/V width = 1/2 Y
    #: width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR_709 = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR_709{{endif}}
    {{if True}}

    #: Extended Range Color format for single Y plane.
    CU_EGL_COLOR_FORMAT_Y_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y_ER{{endif}}
    {{if True}}

    #: Extended Range Color format for single Y plane.
    CU_EGL_COLOR_FORMAT_Y_709_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y_709_ER{{endif}}
    {{if True}}

    #: Extended Range Color format for single Y10 plane.
    CU_EGL_COLOR_FORMAT_Y10_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10_ER{{endif}}
    {{if True}}

    #: Extended Range Color format for single Y10 plane.
    CU_EGL_COLOR_FORMAT_Y10_709_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10_709_ER{{endif}}
    {{if True}}

    #: Extended Range Color format for single Y12 plane.
    CU_EGL_COLOR_FORMAT_Y12_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y12_ER{{endif}}
    {{if True}}

    #: Extended Range Color format for single Y12 plane.
    CU_EGL_COLOR_FORMAT_Y12_709_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y12_709_ER{{endif}}
    {{if True}}

    #: Y, U, V, A four channels in one surface, interleaved as AVUY.
    CU_EGL_COLOR_FORMAT_YUVA = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUVA{{endif}}
    {{if True}}

    #: Y, U, V three channels in one surface, interleaved as VUY. Only
    #: pitch linear format supported.
    CU_EGL_COLOR_FORMAT_YUV = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV{{endif}}
    {{if True}}

    #: Y, U, V in one surface, interleaved as YVYU in one channel.
    CU_EGL_COLOR_FORMAT_YVYU = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVYU{{endif}}
    {{if True}}

    #: Y, U, V in one surface, interleaved as VYUY in one channel.
    CU_EGL_COLOR_FORMAT_VYUY = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_VYUY{{endif}}
    {{if True}}

    #: Extended Range Y10, V10U10 in two surfaces(VU as one surface) U/V
    #: width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_ER{{endif}}
    {{if True}}

    #: Extended Range Y10, V10U10 in two surfaces(VU as one surface) U/V
    #: width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_709_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_709_ER{{endif}}
    {{if True}}

    #: Extended Range Y10, V10U10 in two surfaces (VU as one surface) U/V
    #: width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR_ER{{endif}}
    {{if True}}

    #: Extended Range Y10, V10U10 in two surfaces (VU as one surface) U/V
    #: width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR_709_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR_709_ER{{endif}}
    {{if True}}

    #: Extended Range Y12, V12U12 in two surfaces (VU as one surface) U/V
    #: width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR_ER{{endif}}
    {{if True}}

    #: Extended Range Y12, V12U12 in two surfaces (VU as one surface) U/V
    #: width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR_709_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR_709_ER{{endif}}
    {{if True}}

    #: Extended Range Y12, V12U12 in two surfaces (VU as one surface) U/V
    #: width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR_ER{{endif}}
    {{if True}}

    #: Extended Range Y12, V12U12 in two surfaces (VU as one surface) U/V
    #: width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR_709_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR_709_ER{{endif}}
    {{if True}}

    #: Y, U, V in one surface, interleaved as UYVY in one channel.
    CU_EGL_COLOR_FORMAT_UYVY_709 = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_UYVY_709{{endif}}
    {{if True}}

    #: Extended Range Y, U, V in one surface, interleaved as UYVY in one
    #: channel.
    CU_EGL_COLOR_FORMAT_UYVY_709_ER = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_UYVY_709_ER{{endif}}
    {{if True}}

    #: Y, U, V in one surface, interleaved as UYVY in one channel.
    CU_EGL_COLOR_FORMAT_UYVY_2020 = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_UYVY_2020{{endif}}
    {{if True}}
    CU_EGL_COLOR_FORMAT_MAX = cydriver.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_MAX{{endif}}

_dict_CUeglColorFormat = dict(((int(v), v) for k, v in CUeglColorFormat.__members__.items()))
{{endif}}
{{if True}}

class CUGLDeviceList(IntEnum):
    """
    CUDA devices corresponding to an OpenGL device
    """
    {{if True}}

    #: The CUDA devices for all GPUs used by the current OpenGL context
    CU_GL_DEVICE_LIST_ALL = cydriver.CUGLDeviceList_enum.CU_GL_DEVICE_LIST_ALL{{endif}}
    {{if True}}

    #: The CUDA devices for the GPUs used by the current OpenGL context in
    #: its currently rendering frame
    CU_GL_DEVICE_LIST_CURRENT_FRAME = cydriver.CUGLDeviceList_enum.CU_GL_DEVICE_LIST_CURRENT_FRAME{{endif}}
    {{if True}}

    #: The CUDA devices for the GPUs to be used by the current OpenGL
    #: context in the next frame
    CU_GL_DEVICE_LIST_NEXT_FRAME = cydriver.CUGLDeviceList_enum.CU_GL_DEVICE_LIST_NEXT_FRAME{{endif}}

_dict_CUGLDeviceList = dict(((int(v), v) for k, v in CUGLDeviceList.__members__.items()))
{{endif}}
{{if True}}

class CUGLmap_flags(IntEnum):
    """
    Flags to map or unmap a resource
    """
    {{if True}}
    CU_GL_MAP_RESOURCE_FLAGS_NONE = cydriver.CUGLmap_flags_enum.CU_GL_MAP_RESOURCE_FLAGS_NONE{{endif}}
    {{if True}}
    CU_GL_MAP_RESOURCE_FLAGS_READ_ONLY = cydriver.CUGLmap_flags_enum.CU_GL_MAP_RESOURCE_FLAGS_READ_ONLY{{endif}}
    {{if True}}
    CU_GL_MAP_RESOURCE_FLAGS_WRITE_DISCARD = cydriver.CUGLmap_flags_enum.CU_GL_MAP_RESOURCE_FLAGS_WRITE_DISCARD{{endif}}

_dict_CUGLmap_flags = dict(((int(v), v) for k, v in CUGLmap_flags.__members__.items()))
{{endif}}
{{if 'CUdeviceptr' in found_types}}

cdef class CUdeviceptr:
    """

    CUDA device pointer CUdeviceptr is defined as an unsigned integer type whose size matches the size of a pointer on the target platform.

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUdeviceptr *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUdeviceptr ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUdevice' in found_types}}

cdef class CUdevice:
    """

    CUDA device

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, int init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUdevice *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUdevice ' + str(self.__int__()) + '>'
    def __int__(self):
        return <int>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUtexObject' in found_types}}

cdef class CUtexObject:
    """

    An opaque value that represents a CUDA texture object

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUtexObject *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUtexObject ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUsurfObject' in found_types}}

cdef class CUsurfObject:
    """

    An opaque value that represents a CUDA surface object

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUsurfObject *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUsurfObject ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUgraphConditionalHandle' in found_types}}

cdef class CUgraphConditionalHandle:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, uint64_t init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUgraphConditionalHandle *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUgraphConditionalHandle ' + str(self.__int__()) + '>'
    def __int__(self):
        return <uint64_t>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUlaunchAttributeID_enum' in found_types}}

class CUkernelNodeAttrID(IntEnum):
    """
    Launch attributes enum; used as id field of
    :py:obj:`~.CUlaunchAttribute`
    """
    {{if 'CU_LAUNCH_ATTRIBUTE_IGNORE' in found_values}}

    #: Ignored entry, for convenient composition
    CU_LAUNCH_ATTRIBUTE_IGNORE = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_IGNORE{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW' in found_values}}

    #: Valid for streams, graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.accessPolicyWindow`.
    CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_COOPERATIVE' in found_values}}

    #: Valid for graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.cooperative`.
    CU_LAUNCH_ATTRIBUTE_COOPERATIVE = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_COOPERATIVE{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY' in found_values}}

    #: Valid for streams. See
    #: :py:obj:`~.CUlaunchAttributeValue.syncPolicy`.
    CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION' in found_values}}

    #: Valid for graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.clusterDim`.
    CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE' in found_values}}

    #: Valid for graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.clusterSchedulingPolicyPreference`.
    CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION' in found_values}}

    #: Valid for launches. Setting
    #: :py:obj:`~.CUlaunchAttributeValue.programmaticStreamSerializationAllowed`
    #: to non-0 signals that the kernel will use programmatic means to
    #: resolve its stream dependency, so that the CUDA runtime should
    #: opportunistically allow the grid's execution to overlap with the
    #: previous kernel in the stream, if that kernel requests the overlap.
    #: The dependent launches can choose to wait on the dependency using
    #: the programmatic sync (cudaGridDependencySynchronize() or equivalent
    #: PTX instructions).
    CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT' in found_values}}

    #: Valid for launches. Set
    #: :py:obj:`~.CUlaunchAttributeValue.programmaticEvent` to record the
    #: event. Event recorded through this launch attribute is guaranteed to
    #: only trigger after all block in the associated kernel trigger the
    #: event. A block can trigger the event through PTX launchdep.release
    #: or CUDA builtin function cudaTriggerProgrammaticLaunchCompletion().
    #: A trigger can also be inserted at the beginning of each block's
    #: execution if triggerAtBlockStart is set to non-0. The dependent
    #: launches can choose to wait on the dependency using the programmatic
    #: sync (cudaGridDependencySynchronize() or equivalent PTX
    #: instructions). Note that dependents (including the CPU thread
    #: calling :py:obj:`~.cuEventSynchronize()`) are not guaranteed to
    #: observe the release precisely when it is released. For example,
    #: :py:obj:`~.cuEventSynchronize()` may only observe the event trigger
    #: long after the associated kernel has completed. This recording type
    #: is primarily meant for establishing programmatic dependency between
    #: device tasks. Note also this type of dependency allows, but does not
    #: guarantee, concurrent execution of tasks.
    #:  The event supplied must not be an interprocess or interop event.
    #: The event must disable timing (i.e. must be created with the
    #: :py:obj:`~.CU_EVENT_DISABLE_TIMING` flag set).
    CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_PRIORITY' in found_values}}

    #: Valid for streams, graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.priority`.
    CU_LAUNCH_ATTRIBUTE_PRIORITY = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_PRIORITY{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP' in found_values}}

    #: Valid for streams, graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.memSyncDomainMap`.
    CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN' in found_values}}

    #: Valid for streams, graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.memSyncDomain`.
    CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION' in found_values}}

    #: Valid for graph nodes, launches. Set
    #: :py:obj:`~.CUlaunchAttributeValue.preferredClusterDim` to allow the
    #: kernel launch to specify a preferred substitute cluster dimension.
    #: Blocks may be grouped according to either the dimensions specified
    #: with this attribute (grouped into a "preferred substitute cluster"),
    #: or the one specified with
    #: :py:obj:`~.CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION` attribute (grouped
    #: into a "regular cluster"). The cluster dimensions of a "preferred
    #: substitute cluster" shall be an integer multiple greater than zero
    #: of the regular cluster dimensions. The device will attempt - on a
    #: best-effort basis - to group thread blocks into preferred clusters
    #: over grouping them into regular clusters. When it deems necessary
    #: (primarily when the device temporarily runs out of physical
    #: resources to launch the larger preferred clusters), the device may
    #: switch to launch the regular clusters instead to attempt to utilize
    #: as much of the physical device resources as possible.
    #:  Each type of cluster will have its enumeration / coordinate setup
    #: as if the grid consists solely of its type of cluster. For example,
    #: if the preferred substitute cluster dimensions double the regular
    #: cluster dimensions, there might be simultaneously a regular cluster
    #: indexed at (1,0,0), and a preferred cluster indexed at (1,0,0). In
    #: this example, the preferred substitute cluster (1,0,0) replaces
    #: regular clusters (2,0,0) and (3,0,0) and groups their blocks.
    #:  This attribute will only take effect when a regular cluster
    #: dimension has been specified. The preferred substitute cluster
    #: dimension must be an integer multiple greater than zero of the
    #: regular cluster dimension and must divide the grid. It must also be
    #: no more than `maxBlocksPerCluster`, if it is set in the kernel's
    #: `__launch_bounds__`. Otherwise it must be less than the maximum
    #: value the driver can support. Otherwise, setting this attribute to a
    #: value physically unable to fit on any particular device is
    #: permitted.
    CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT' in found_values}}

    #: Valid for launches. Set
    #: :py:obj:`~.CUlaunchAttributeValue.launchCompletionEvent` to record
    #: the event.
    #:  Nominally, the event is triggered once all blocks of the kernel
    #: have begun execution. Currently this is a best effort. If a kernel B
    #: has a launch completion dependency on a kernel A, B may wait until A
    #: is complete. Alternatively, blocks of B may begin before all blocks
    #: of A have begun, for example if B can claim execution resources
    #: unavailable to A (e.g. they run on different GPUs) or if B is a
    #: higher priority than A. Exercise caution if such an ordering
    #: inversion could lead to deadlock.
    #:  A launch completion event is nominally similar to a programmatic
    #: event with `triggerAtBlockStart` set except that it is not visible
    #: to `cudaGridDependencySynchronize()` and can be used with compute
    #: capability less than 9.0.
    #:  The event supplied must not be an interprocess or interop event.
    #: The event must disable timing (i.e. must be created with the
    #: :py:obj:`~.CU_EVENT_DISABLE_TIMING` flag set).
    CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE' in found_values}}

    #: Valid for graph nodes, launches. This attribute is graphs-only, and
    #: passing it to a launch in a non-capturing stream will result in an
    #: error.
    #: :py:obj:`~.CUlaunchAttributeValue`::deviceUpdatableKernelNode::deviceUpdatable
    #: can only be set to 0 or 1. Setting the field to 1 indicates that the
    #: corresponding kernel node should be device-updatable. On success, a
    #: handle will be returned via
    #: :py:obj:`~.CUlaunchAttributeValue`::deviceUpdatableKernelNode::devNode
    #: which can be passed to the various device-side update functions to
    #: update the node's kernel parameters from within another kernel. For
    #: more information on the types of device updates that can be made, as
    #: well as the relevant limitations thereof, see
    #: :py:obj:`~.cudaGraphKernelNodeUpdatesApply`.
    #:  Nodes which are device-updatable have additional restrictions
    #: compared to regular kernel nodes. Firstly, device-updatable nodes
    #: cannot be removed from their graph via
    #: :py:obj:`~.cuGraphDestroyNode`. Additionally, once opted-in to this
    #: functionality, a node cannot opt out, and any attempt to set the
    #: deviceUpdatable attribute to 0 will result in an error. Device-
    #: updatable kernel nodes also cannot have their attributes copied
    #: to/from another kernel node via
    #: :py:obj:`~.cuGraphKernelNodeCopyAttributes`. Graphs containing one
    #: or more device-updatable nodes also do not allow multiple
    #: instantiation, and neither the graph nor its instantiated version
    #: can be passed to :py:obj:`~.cuGraphExecUpdate`.
    #:  If a graph contains device-updatable nodes and updates those nodes
    #: from the device from within the graph, the graph must be uploaded
    #: with :py:obj:`~.cuGraphUpload` before it is launched. For such a
    #: graph, if host-side executable graph updates are made to the device-
    #: updatable nodes, the graph must be uploaded before it is launched
    #: again.
    CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT' in found_values}}

    #: Valid for launches. On devices where the L1 cache and shared memory
    #: use the same hardware resources, setting
    #: :py:obj:`~.CUlaunchAttributeValue.sharedMemCarveout` to a percentage
    #: between 0-100 signals the CUDA driver to set the shared memory
    #: carveout preference, in percent of the total shared memory for that
    #: kernel launch. This attribute takes precedence over
    #: :py:obj:`~.CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT`. This
    #: is only a hint, and the CUDA driver can choose a different
    #: configuration if required for the launch.
    CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_NVLINK_UTIL_CENTRIC_SCHEDULING' in found_values}}

    #: Valid for streams, graph nodes, launches. This attribute is a hint
    #: to the CUDA runtime that the launch should attempt to make the
    #: kernel maximize its NVLINK utilization.
    #:
    #:  When possible to honor this hint, CUDA will assume each block in
    #: the grid launch will carry out an even amount of NVLINK traffic, and
    #: make a best-effort attempt to adjust the kernel launch based on that
    #: assumption.
    #:  This attribute is a hint only. CUDA makes no functional or
    #: performance guarantee. Its applicability can be affected by many
    #: different factors, including driver version (i.e. CUDA doesn't
    #: guarantee the performance characteristics will be maintained between
    #: driver versions or a driver update could alter or regress previously
    #: observed perf characteristics.) It also doesn't guarantee a
    #: successful result, i.e. applying the attribute may not improve the
    #: performance of either the targeted kernel or the encapsulating
    #: application.
    #:  Valid values for
    #: :py:obj:`~.CUlaunchAttributeValue`::nvlinkUtilCentricScheduling are
    #: 0 (disabled) and 1 (enabled).
    CU_LAUNCH_ATTRIBUTE_NVLINK_UTIL_CENTRIC_SCHEDULING = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_NVLINK_UTIL_CENTRIC_SCHEDULING{{endif}}

_dict_CUlaunchAttributeID = dict(((int(v), v) for k, v in CUlaunchAttributeID.__members__.items()))
{{endif}}
{{if 'CUlaunchAttributeID_enum' in found_types}}

class CUstreamAttrID(IntEnum):
    """
    Launch attributes enum; used as id field of
    :py:obj:`~.CUlaunchAttribute`
    """
    {{if 'CU_LAUNCH_ATTRIBUTE_IGNORE' in found_values}}

    #: Ignored entry, for convenient composition
    CU_LAUNCH_ATTRIBUTE_IGNORE = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_IGNORE{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW' in found_values}}

    #: Valid for streams, graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.accessPolicyWindow`.
    CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_COOPERATIVE' in found_values}}

    #: Valid for graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.cooperative`.
    CU_LAUNCH_ATTRIBUTE_COOPERATIVE = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_COOPERATIVE{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY' in found_values}}

    #: Valid for streams. See
    #: :py:obj:`~.CUlaunchAttributeValue.syncPolicy`.
    CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION' in found_values}}

    #: Valid for graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.clusterDim`.
    CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE' in found_values}}

    #: Valid for graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.clusterSchedulingPolicyPreference`.
    CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION' in found_values}}

    #: Valid for launches. Setting
    #: :py:obj:`~.CUlaunchAttributeValue.programmaticStreamSerializationAllowed`
    #: to non-0 signals that the kernel will use programmatic means to
    #: resolve its stream dependency, so that the CUDA runtime should
    #: opportunistically allow the grid's execution to overlap with the
    #: previous kernel in the stream, if that kernel requests the overlap.
    #: The dependent launches can choose to wait on the dependency using
    #: the programmatic sync (cudaGridDependencySynchronize() or equivalent
    #: PTX instructions).
    CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT' in found_values}}

    #: Valid for launches. Set
    #: :py:obj:`~.CUlaunchAttributeValue.programmaticEvent` to record the
    #: event. Event recorded through this launch attribute is guaranteed to
    #: only trigger after all block in the associated kernel trigger the
    #: event. A block can trigger the event through PTX launchdep.release
    #: or CUDA builtin function cudaTriggerProgrammaticLaunchCompletion().
    #: A trigger can also be inserted at the beginning of each block's
    #: execution if triggerAtBlockStart is set to non-0. The dependent
    #: launches can choose to wait on the dependency using the programmatic
    #: sync (cudaGridDependencySynchronize() or equivalent PTX
    #: instructions). Note that dependents (including the CPU thread
    #: calling :py:obj:`~.cuEventSynchronize()`) are not guaranteed to
    #: observe the release precisely when it is released. For example,
    #: :py:obj:`~.cuEventSynchronize()` may only observe the event trigger
    #: long after the associated kernel has completed. This recording type
    #: is primarily meant for establishing programmatic dependency between
    #: device tasks. Note also this type of dependency allows, but does not
    #: guarantee, concurrent execution of tasks.
    #:  The event supplied must not be an interprocess or interop event.
    #: The event must disable timing (i.e. must be created with the
    #: :py:obj:`~.CU_EVENT_DISABLE_TIMING` flag set).
    CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_PRIORITY' in found_values}}

    #: Valid for streams, graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.priority`.
    CU_LAUNCH_ATTRIBUTE_PRIORITY = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_PRIORITY{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP' in found_values}}

    #: Valid for streams, graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.memSyncDomainMap`.
    CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN' in found_values}}

    #: Valid for streams, graph nodes, launches. See
    #: :py:obj:`~.CUlaunchAttributeValue.memSyncDomain`.
    CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION' in found_values}}

    #: Valid for graph nodes, launches. Set
    #: :py:obj:`~.CUlaunchAttributeValue.preferredClusterDim` to allow the
    #: kernel launch to specify a preferred substitute cluster dimension.
    #: Blocks may be grouped according to either the dimensions specified
    #: with this attribute (grouped into a "preferred substitute cluster"),
    #: or the one specified with
    #: :py:obj:`~.CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION` attribute (grouped
    #: into a "regular cluster"). The cluster dimensions of a "preferred
    #: substitute cluster" shall be an integer multiple greater than zero
    #: of the regular cluster dimensions. The device will attempt - on a
    #: best-effort basis - to group thread blocks into preferred clusters
    #: over grouping them into regular clusters. When it deems necessary
    #: (primarily when the device temporarily runs out of physical
    #: resources to launch the larger preferred clusters), the device may
    #: switch to launch the regular clusters instead to attempt to utilize
    #: as much of the physical device resources as possible.
    #:  Each type of cluster will have its enumeration / coordinate setup
    #: as if the grid consists solely of its type of cluster. For example,
    #: if the preferred substitute cluster dimensions double the regular
    #: cluster dimensions, there might be simultaneously a regular cluster
    #: indexed at (1,0,0), and a preferred cluster indexed at (1,0,0). In
    #: this example, the preferred substitute cluster (1,0,0) replaces
    #: regular clusters (2,0,0) and (3,0,0) and groups their blocks.
    #:  This attribute will only take effect when a regular cluster
    #: dimension has been specified. The preferred substitute cluster
    #: dimension must be an integer multiple greater than zero of the
    #: regular cluster dimension and must divide the grid. It must also be
    #: no more than `maxBlocksPerCluster`, if it is set in the kernel's
    #: `__launch_bounds__`. Otherwise it must be less than the maximum
    #: value the driver can support. Otherwise, setting this attribute to a
    #: value physically unable to fit on any particular device is
    #: permitted.
    CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT' in found_values}}

    #: Valid for launches. Set
    #: :py:obj:`~.CUlaunchAttributeValue.launchCompletionEvent` to record
    #: the event.
    #:  Nominally, the event is triggered once all blocks of the kernel
    #: have begun execution. Currently this is a best effort. If a kernel B
    #: has a launch completion dependency on a kernel A, B may wait until A
    #: is complete. Alternatively, blocks of B may begin before all blocks
    #: of A have begun, for example if B can claim execution resources
    #: unavailable to A (e.g. they run on different GPUs) or if B is a
    #: higher priority than A. Exercise caution if such an ordering
    #: inversion could lead to deadlock.
    #:  A launch completion event is nominally similar to a programmatic
    #: event with `triggerAtBlockStart` set except that it is not visible
    #: to `cudaGridDependencySynchronize()` and can be used with compute
    #: capability less than 9.0.
    #:  The event supplied must not be an interprocess or interop event.
    #: The event must disable timing (i.e. must be created with the
    #: :py:obj:`~.CU_EVENT_DISABLE_TIMING` flag set).
    CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE' in found_values}}

    #: Valid for graph nodes, launches. This attribute is graphs-only, and
    #: passing it to a launch in a non-capturing stream will result in an
    #: error.
    #: :py:obj:`~.CUlaunchAttributeValue`::deviceUpdatableKernelNode::deviceUpdatable
    #: can only be set to 0 or 1. Setting the field to 1 indicates that the
    #: corresponding kernel node should be device-updatable. On success, a
    #: handle will be returned via
    #: :py:obj:`~.CUlaunchAttributeValue`::deviceUpdatableKernelNode::devNode
    #: which can be passed to the various device-side update functions to
    #: update the node's kernel parameters from within another kernel. For
    #: more information on the types of device updates that can be made, as
    #: well as the relevant limitations thereof, see
    #: :py:obj:`~.cudaGraphKernelNodeUpdatesApply`.
    #:  Nodes which are device-updatable have additional restrictions
    #: compared to regular kernel nodes. Firstly, device-updatable nodes
    #: cannot be removed from their graph via
    #: :py:obj:`~.cuGraphDestroyNode`. Additionally, once opted-in to this
    #: functionality, a node cannot opt out, and any attempt to set the
    #: deviceUpdatable attribute to 0 will result in an error. Device-
    #: updatable kernel nodes also cannot have their attributes copied
    #: to/from another kernel node via
    #: :py:obj:`~.cuGraphKernelNodeCopyAttributes`. Graphs containing one
    #: or more device-updatable nodes also do not allow multiple
    #: instantiation, and neither the graph nor its instantiated version
    #: can be passed to :py:obj:`~.cuGraphExecUpdate`.
    #:  If a graph contains device-updatable nodes and updates those nodes
    #: from the device from within the graph, the graph must be uploaded
    #: with :py:obj:`~.cuGraphUpload` before it is launched. For such a
    #: graph, if host-side executable graph updates are made to the device-
    #: updatable nodes, the graph must be uploaded before it is launched
    #: again.
    CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT' in found_values}}

    #: Valid for launches. On devices where the L1 cache and shared memory
    #: use the same hardware resources, setting
    #: :py:obj:`~.CUlaunchAttributeValue.sharedMemCarveout` to a percentage
    #: between 0-100 signals the CUDA driver to set the shared memory
    #: carveout preference, in percent of the total shared memory for that
    #: kernel launch. This attribute takes precedence over
    #: :py:obj:`~.CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT`. This
    #: is only a hint, and the CUDA driver can choose a different
    #: configuration if required for the launch.
    CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT{{endif}}
    {{if 'CU_LAUNCH_ATTRIBUTE_NVLINK_UTIL_CENTRIC_SCHEDULING' in found_values}}

    #: Valid for streams, graph nodes, launches. This attribute is a hint
    #: to the CUDA runtime that the launch should attempt to make the
    #: kernel maximize its NVLINK utilization.
    #:
    #:  When possible to honor this hint, CUDA will assume each block in
    #: the grid launch will carry out an even amount of NVLINK traffic, and
    #: make a best-effort attempt to adjust the kernel launch based on that
    #: assumption.
    #:  This attribute is a hint only. CUDA makes no functional or
    #: performance guarantee. Its applicability can be affected by many
    #: different factors, including driver version (i.e. CUDA doesn't
    #: guarantee the performance characteristics will be maintained between
    #: driver versions or a driver update could alter or regress previously
    #: observed perf characteristics.) It also doesn't guarantee a
    #: successful result, i.e. applying the attribute may not improve the
    #: performance of either the targeted kernel or the encapsulating
    #: application.
    #:  Valid values for
    #: :py:obj:`~.CUlaunchAttributeValue`::nvlinkUtilCentricScheduling are
    #: 0 (disabled) and 1 (enabled).
    CU_LAUNCH_ATTRIBUTE_NVLINK_UTIL_CENTRIC_SCHEDULING = cydriver.CUlaunchAttributeID_enum.CU_LAUNCH_ATTRIBUTE_NVLINK_UTIL_CENTRIC_SCHEDULING{{endif}}

_dict_CUlaunchAttributeID = dict(((int(v), v) for k, v in CUlaunchAttributeID.__members__.items()))
{{endif}}
{{if 'CUmemGenericAllocationHandle' in found_types}}

cdef class CUmemGenericAllocationHandle:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUmemGenericAllocationHandle *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUmemGenericAllocationHandle ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUcontext' in found_types}}

cdef class CUcontext:
    """

    A regular context handle

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUcontext>init_value
        else:
            self._pvt_ptr = <cydriver.CUcontext *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUcontext ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUcontext):
            return False
        return self._pvt_ptr[0] == (<CUcontext>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUmodule' in found_types}}

cdef class CUmodule:
    """

    CUDA module

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUmodule>init_value
        else:
            self._pvt_ptr = <cydriver.CUmodule *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUmodule ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUmodule):
            return False
        return self._pvt_ptr[0] == (<CUmodule>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUfunction' in found_types}}

cdef class CUfunction:
    """

    CUDA function

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUfunction>init_value
        else:
            self._pvt_ptr = <cydriver.CUfunction *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUfunction ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUfunction):
            return False
        return self._pvt_ptr[0] == (<CUfunction>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUlibrary' in found_types}}

cdef class CUlibrary:
    """

    CUDA library

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUlibrary>init_value
        else:
            self._pvt_ptr = <cydriver.CUlibrary *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUlibrary ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUlibrary):
            return False
        return self._pvt_ptr[0] == (<CUlibrary>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUkernel' in found_types}}

cdef class CUkernel:
    """

    CUDA kernel

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUkernel>init_value
        else:
            self._pvt_ptr = <cydriver.CUkernel *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUkernel ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUkernel):
            return False
        return self._pvt_ptr[0] == (<CUkernel>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUarray' in found_types}}

cdef class CUarray:
    """

    CUDA array

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUarray>init_value
        else:
            self._pvt_ptr = <cydriver.CUarray *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUarray ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUarray):
            return False
        return self._pvt_ptr[0] == (<CUarray>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUmipmappedArray' in found_types}}

cdef class CUmipmappedArray:
    """

    CUDA mipmapped array

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUmipmappedArray>init_value
        else:
            self._pvt_ptr = <cydriver.CUmipmappedArray *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUmipmappedArray ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUmipmappedArray):
            return False
        return self._pvt_ptr[0] == (<CUmipmappedArray>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUtexref' in found_types}}

cdef class CUtexref:
    """

    CUDA texture reference

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUtexref>init_value
        else:
            self._pvt_ptr = <cydriver.CUtexref *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUtexref ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUtexref):
            return False
        return self._pvt_ptr[0] == (<CUtexref>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUsurfref' in found_types}}

cdef class CUsurfref:
    """

    CUDA surface reference

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUsurfref>init_value
        else:
            self._pvt_ptr = <cydriver.CUsurfref *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUsurfref ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUsurfref):
            return False
        return self._pvt_ptr[0] == (<CUsurfref>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUevent' in found_types}}

cdef class CUevent:
    """

    CUDA event

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUevent>init_value
        else:
            self._pvt_ptr = <cydriver.CUevent *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUevent ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUevent):
            return False
        return self._pvt_ptr[0] == (<CUevent>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUstream' in found_types}}

cdef class CUstream:
    """

    CUDA stream

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUstream>init_value
        else:
            self._pvt_ptr = <cydriver.CUstream *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUstream ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUstream):
            return False
        return self._pvt_ptr[0] == (<CUstream>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUgraphicsResource' in found_types}}

cdef class CUgraphicsResource:
    """

    CUDA graphics interop resource

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUgraphicsResource>init_value
        else:
            self._pvt_ptr = <cydriver.CUgraphicsResource *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUgraphicsResource ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUgraphicsResource):
            return False
        return self._pvt_ptr[0] == (<CUgraphicsResource>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUexternalMemory' in found_types}}

cdef class CUexternalMemory:
    """

    CUDA external memory

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUexternalMemory>init_value
        else:
            self._pvt_ptr = <cydriver.CUexternalMemory *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUexternalMemory ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUexternalMemory):
            return False
        return self._pvt_ptr[0] == (<CUexternalMemory>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUexternalSemaphore' in found_types}}

cdef class CUexternalSemaphore:
    """

    CUDA external semaphore

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUexternalSemaphore>init_value
        else:
            self._pvt_ptr = <cydriver.CUexternalSemaphore *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUexternalSemaphore ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUexternalSemaphore):
            return False
        return self._pvt_ptr[0] == (<CUexternalSemaphore>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUgraph' in found_types}}

cdef class CUgraph:
    """

    CUDA graph

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUgraph>init_value
        else:
            self._pvt_ptr = <cydriver.CUgraph *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUgraph ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUgraph):
            return False
        return self._pvt_ptr[0] == (<CUgraph>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUgraphNode' in found_types}}

cdef class CUgraphNode:
    """

    CUDA graph node

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUgraphNode>init_value
        else:
            self._pvt_ptr = <cydriver.CUgraphNode *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUgraphNode ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUgraphNode):
            return False
        return self._pvt_ptr[0] == (<CUgraphNode>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUgraphExec' in found_types}}

cdef class CUgraphExec:
    """

    CUDA executable graph

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUgraphExec>init_value
        else:
            self._pvt_ptr = <cydriver.CUgraphExec *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUgraphExec ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUgraphExec):
            return False
        return self._pvt_ptr[0] == (<CUgraphExec>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUmemoryPool' in found_types}}

cdef class CUmemoryPool:
    """

    CUDA memory pool

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUmemoryPool>init_value
        else:
            self._pvt_ptr = <cydriver.CUmemoryPool *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUmemoryPool ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUmemoryPool):
            return False
        return self._pvt_ptr[0] == (<CUmemoryPool>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUuserObject' in found_types}}

cdef class CUuserObject:
    """

    CUDA user object for graphs

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUuserObject>init_value
        else:
            self._pvt_ptr = <cydriver.CUuserObject *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUuserObject ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUuserObject):
            return False
        return self._pvt_ptr[0] == (<CUuserObject>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUgraphDeviceNode' in found_types}}

cdef class CUgraphDeviceNode:
    """

    CUDA graph device node handle

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUgraphDeviceNode>init_value
        else:
            self._pvt_ptr = <cydriver.CUgraphDeviceNode *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUgraphDeviceNode ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUgraphDeviceNode):
            return False
        return self._pvt_ptr[0] == (<CUgraphDeviceNode>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUasyncCallbackHandle' in found_types}}

cdef class CUasyncCallbackHandle:
    """

    CUDA async notification callback handle

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUasyncCallbackHandle>init_value
        else:
            self._pvt_ptr = <cydriver.CUasyncCallbackHandle *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUasyncCallbackHandle ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUasyncCallbackHandle):
            return False
        return self._pvt_ptr[0] == (<CUasyncCallbackHandle>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUgreenCtx' in found_types}}

cdef class CUgreenCtx:
    """

    A green context handle. This handle can be used safely from only one CPU thread at a time. Created via cuGreenCtxCreate

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUgreenCtx>init_value
        else:
            self._pvt_ptr = <cydriver.CUgreenCtx *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUgreenCtx ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUgreenCtx):
            return False
        return self._pvt_ptr[0] == (<CUgreenCtx>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUlinkState' in found_types}}

cdef class CUlinkState:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUlinkState>init_value
        else:
            self._pvt_ptr = <cydriver.CUlinkState *>_ptr
    def __init__(self, *args, **kwargs):
        self._keepalive = []
    def __repr__(self):
        return '<CUlinkState ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUlinkState):
            return False
        return self._pvt_ptr[0] == (<CUlinkState>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUdevResourceDesc' in found_types}}

cdef class CUdevResourceDesc:
    """

    An opaque descriptor handle. The descriptor encapsulates multiple created and configured resources. Created via cuDevResourceGenerateDesc

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUdevResourceDesc>init_value
        else:
            self._pvt_ptr = <cydriver.CUdevResourceDesc *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUdevResourceDesc ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUdevResourceDesc):
            return False
        return self._pvt_ptr[0] == (<CUdevResourceDesc>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUlogsCallbackHandle' in found_types}}

cdef class CUlogsCallbackHandle:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUlogsCallbackHandle>init_value
        else:
            self._pvt_ptr = <cydriver.CUlogsCallbackHandle *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUlogsCallbackHandle ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUlogsCallbackHandle):
            return False
        return self._pvt_ptr[0] == (<CUlogsCallbackHandle>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class CUeglStreamConnection:
    """

    CUDA EGLSream Connection

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUeglStreamConnection>init_value
        else:
            self._pvt_ptr = <cydriver.CUeglStreamConnection *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUeglStreamConnection ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, CUeglStreamConnection):
            return False
        return self._pvt_ptr[0] == (<CUeglStreamConnection>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class EGLImageKHR:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.EGLImageKHR>init_value
        else:
            self._pvt_ptr = <cydriver.EGLImageKHR *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<EGLImageKHR ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, EGLImageKHR):
            return False
        return self._pvt_ptr[0] == (<EGLImageKHR>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class EGLStreamKHR:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.EGLStreamKHR>init_value
        else:
            self._pvt_ptr = <cydriver.EGLStreamKHR *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<EGLStreamKHR ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, EGLStreamKHR):
            return False
        return self._pvt_ptr[0] == (<EGLStreamKHR>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class EGLSyncKHR:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.EGLSyncKHR>init_value
        else:
            self._pvt_ptr = <cydriver.EGLSyncKHR *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<EGLSyncKHR ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, EGLSyncKHR):
            return False
        return self._pvt_ptr[0] == (<EGLSyncKHR>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUasyncCallback' in found_types}}

cdef class CUasyncCallback:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUasyncCallback>init_value
        else:
            self._pvt_ptr = <cydriver.CUasyncCallback *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUasyncCallback ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUhostFn' in found_types}}

cdef class CUhostFn:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUhostFn>init_value
        else:
            self._pvt_ptr = <cydriver.CUhostFn *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUhostFn ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUstreamCallback' in found_types}}

cdef class CUstreamCallback:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUstreamCallback>init_value
        else:
            self._pvt_ptr = <cydriver.CUstreamCallback *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUstreamCallback ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUoccupancyB2DSize' in found_types}}

cdef class CUoccupancyB2DSize:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUoccupancyB2DSize>init_value
        else:
            self._pvt_ptr = <cydriver.CUoccupancyB2DSize *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUoccupancyB2DSize ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUlogsCallback' in found_types}}

cdef class CUlogsCallback:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cydriver.CUlogsCallback>init_value
        else:
            self._pvt_ptr = <cydriver.CUlogsCallback *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUlogsCallback ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUuuid_st' in found_struct}}

cdef class CUuuid_st:
    """
    Attributes
    ----------
    {{if 'CUuuid_st.bytes' in found_struct}}
    bytes : bytes
        < CUDA definition of UUID
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUuuid_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUuuid_st.bytes' in found_struct}}
            try:
                str_list += ['bytes : ' + str(self.bytes.hex())]
            except ValueError:
                str_list += ['bytes : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUuuid_st.bytes' in found_struct}}
    @property
    def bytes(self):
        return PyBytes_FromStringAndSize(self._pvt_ptr[0].bytes, 16)
    {{endif}}
{{endif}}
{{if 'CUmemFabricHandle_st' in found_struct}}

cdef class CUmemFabricHandle_st:
    """
    Fabric handle - An opaque handle representing a memory allocation
    that can be exported to processes in same or different nodes. For
    IPC between processes on different nodes they must be connected via
    the NVSwitch fabric.

    Attributes
    ----------
    {{if 'CUmemFabricHandle_st.data' in found_struct}}
    data : bytes

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUmemFabricHandle_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUmemFabricHandle_st.data' in found_struct}}
            try:
                str_list += ['data : ' + str(self.data)]
            except ValueError:
                str_list += ['data : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUmemFabricHandle_st.data' in found_struct}}
    @property
    def data(self):
        return PyBytes_FromStringAndSize(<char*>self._pvt_ptr[0].data, 64)
    @data.setter
    def data(self, data):
        if len(data) != 64:
            raise ValueError("data length must be 64, is " + str(len(data)))
        for i, b in enumerate(data):
            self._pvt_ptr[0].data[i] = b
    {{endif}}
{{endif}}
{{if 'CUipcEventHandle_st' in found_struct}}

cdef class CUipcEventHandle_st:
    """
    CUDA IPC event handle

    Attributes
    ----------
    {{if 'CUipcEventHandle_st.reserved' in found_struct}}
    reserved : bytes

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUipcEventHandle_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUipcEventHandle_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUipcEventHandle_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(self._pvt_ptr[0].reserved, 64)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 64:
            raise ValueError("reserved length must be 64, is " + str(len(reserved)))
        if CHAR_MIN == 0:
            for i, b in enumerate(reserved):
                if b < 0 and b > -129:
                    b = b + 256
                self._pvt_ptr[0].reserved[i] = b
        else:
            for i, b in enumerate(reserved):
                if b > 127 and b < 256:
                    b = b - 256
                self._pvt_ptr[0].reserved[i] = b
    {{endif}}
{{endif}}
{{if 'CUipcMemHandle_st' in found_struct}}

cdef class CUipcMemHandle_st:
    """
    CUDA IPC mem handle

    Attributes
    ----------
    {{if 'CUipcMemHandle_st.reserved' in found_struct}}
    reserved : bytes

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUipcMemHandle_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUipcMemHandle_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUipcMemHandle_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(self._pvt_ptr[0].reserved, 64)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 64:
            raise ValueError("reserved length must be 64, is " + str(len(reserved)))
        if CHAR_MIN == 0:
            for i, b in enumerate(reserved):
                if b < 0 and b > -129:
                    b = b + 256
                self._pvt_ptr[0].reserved[i] = b
        else:
            for i, b in enumerate(reserved):
                if b > 127 and b < 256:
                    b = b - 256
                self._pvt_ptr[0].reserved[i] = b
    {{endif}}
{{endif}}
{{if 'CUstreamBatchMemOpParams_union.waitValue' in found_struct}}

cdef class CUstreamMemOpWaitValueParams_st:
    """
    Attributes
    ----------
    {{if 'CUstreamBatchMemOpParams_union.waitValue.operation' in found_struct}}
    operation : CUstreamBatchMemOpType

    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.waitValue.address' in found_struct}}
    address : CUdeviceptr

    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.waitValue.value' in found_struct}}
    value : cuuint32_t

    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.waitValue.value64' in found_struct}}
    value64 : cuuint64_t

    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.waitValue.flags' in found_struct}}
    flags : unsigned int
        See CUstreamWaitValue_flags.
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.waitValue.alias' in found_struct}}
    alias : CUdeviceptr
        For driver internal use. Initial value is unimportant.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUstreamBatchMemOpParams_union *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUstreamBatchMemOpParams_union.waitValue.address' in found_struct}}
        self._address = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].waitValue.address)
        {{endif}}
        {{if 'CUstreamBatchMemOpParams_union.waitValue.value' in found_struct}}
        self._value = cuuint32_t(_ptr=<void_ptr>&self._pvt_ptr[0].waitValue.value)
        {{endif}}
        {{if 'CUstreamBatchMemOpParams_union.waitValue.value64' in found_struct}}
        self._value64 = cuuint64_t(_ptr=<void_ptr>&self._pvt_ptr[0].waitValue.value64)
        {{endif}}
        {{if 'CUstreamBatchMemOpParams_union.waitValue.alias' in found_struct}}
        self._alias = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].waitValue.alias)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].waitValue
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUstreamBatchMemOpParams_union.waitValue.operation' in found_struct}}
            try:
                str_list += ['operation : ' + str(self.operation)]
            except ValueError:
                str_list += ['operation : <ValueError>']
            {{endif}}
            {{if 'CUstreamBatchMemOpParams_union.waitValue.address' in found_struct}}
            try:
                str_list += ['address : ' + str(self.address)]
            except ValueError:
                str_list += ['address : <ValueError>']
            {{endif}}
            {{if 'CUstreamBatchMemOpParams_union.waitValue.value' in found_struct}}
            try:
                str_list += ['value : ' + str(self.value)]
            except ValueError:
                str_list += ['value : <ValueError>']
            {{endif}}
            {{if 'CUstreamBatchMemOpParams_union.waitValue.value64' in found_struct}}
            try:
                str_list += ['value64 : ' + str(self.value64)]
            except ValueError:
                str_list += ['value64 : <ValueError>']
            {{endif}}
            {{if 'CUstreamBatchMemOpParams_union.waitValue.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'CUstreamBatchMemOpParams_union.waitValue.alias' in found_struct}}
            try:
                str_list += ['alias : ' + str(self.alias)]
            except ValueError:
                str_list += ['alias : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUstreamBatchMemOpParams_union.waitValue.operation' in found_struct}}
    @property
    def operation(self):
        if self._pvt_ptr[0].waitValue.operation not in _dict_CUstreamBatchMemOpType:
            return None
        return _dict_CUstreamBatchMemOpType[self._pvt_ptr[0].waitValue.operation]
    @operation.setter
    def operation(self, operation not None : CUstreamBatchMemOpType):
        self._pvt_ptr[0].waitValue.operation = operation.value
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.waitValue.address' in found_struct}}
    @property
    def address(self):
        return self._address
    @address.setter
    def address(self, address):
        cdef cydriver.CUdeviceptr cyaddress
        if address is None:
            cyaddress = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(address, (CUdeviceptr)):
            paddress = int(address)
            cyaddress = <cydriver.CUdeviceptr><void_ptr>paddress
        else:
            paddress = int(CUdeviceptr(address))
            cyaddress = <cydriver.CUdeviceptr><void_ptr>paddress
        self._address._pvt_ptr[0] = cyaddress

    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.waitValue.value' in found_struct}}
    @property
    def value(self):
        return self._value
    @value.setter
    def value(self, value):
        cdef cydriver.cuuint32_t cyvalue
        if value is None:
            cyvalue = <cydriver.cuuint32_t><void_ptr>0
        elif isinstance(value, (cuuint32_t)):
            pvalue = int(value)
            cyvalue = <cydriver.cuuint32_t><void_ptr>pvalue
        else:
            pvalue = int(cuuint32_t(value))
            cyvalue = <cydriver.cuuint32_t><void_ptr>pvalue
        self._value._pvt_ptr[0] = cyvalue

    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.waitValue.value64' in found_struct}}
    @property
    def value64(self):
        return self._value64
    @value64.setter
    def value64(self, value64):
        cdef cydriver.cuuint64_t cyvalue64
        if value64 is None:
            cyvalue64 = <cydriver.cuuint64_t><void_ptr>0
        elif isinstance(value64, (cuuint64_t)):
            pvalue64 = int(value64)
            cyvalue64 = <cydriver.cuuint64_t><void_ptr>pvalue64
        else:
            pvalue64 = int(cuuint64_t(value64))
            cyvalue64 = <cydriver.cuuint64_t><void_ptr>pvalue64
        self._value64._pvt_ptr[0] = cyvalue64

    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.waitValue.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].waitValue.flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].waitValue.flags = flags
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.waitValue.alias' in found_struct}}
    @property
    def alias(self):
        return self._alias
    @alias.setter
    def alias(self, alias):
        cdef cydriver.CUdeviceptr cyalias
        if alias is None:
            cyalias = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(alias, (CUdeviceptr)):
            palias = int(alias)
            cyalias = <cydriver.CUdeviceptr><void_ptr>palias
        else:
            palias = int(CUdeviceptr(alias))
            cyalias = <cydriver.CUdeviceptr><void_ptr>palias
        self._alias._pvt_ptr[0] = cyalias

    {{endif}}
{{endif}}
{{if 'CUstreamBatchMemOpParams_union.writeValue' in found_struct}}

cdef class CUstreamMemOpWriteValueParams_st:
    """
    Attributes
    ----------
    {{if 'CUstreamBatchMemOpParams_union.writeValue.operation' in found_struct}}
    operation : CUstreamBatchMemOpType

    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.writeValue.address' in found_struct}}
    address : CUdeviceptr

    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.writeValue.value' in found_struct}}
    value : cuuint32_t

    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.writeValue.value64' in found_struct}}
    value64 : cuuint64_t

    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.writeValue.flags' in found_struct}}
    flags : unsigned int
        See CUstreamWriteValue_flags.
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.writeValue.alias' in found_struct}}
    alias : CUdeviceptr
        For driver internal use. Initial value is unimportant.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUstreamBatchMemOpParams_union *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUstreamBatchMemOpParams_union.writeValue.address' in found_struct}}
        self._address = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].writeValue.address)
        {{endif}}
        {{if 'CUstreamBatchMemOpParams_union.writeValue.value' in found_struct}}
        self._value = cuuint32_t(_ptr=<void_ptr>&self._pvt_ptr[0].writeValue.value)
        {{endif}}
        {{if 'CUstreamBatchMemOpParams_union.writeValue.value64' in found_struct}}
        self._value64 = cuuint64_t(_ptr=<void_ptr>&self._pvt_ptr[0].writeValue.value64)
        {{endif}}
        {{if 'CUstreamBatchMemOpParams_union.writeValue.alias' in found_struct}}
        self._alias = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].writeValue.alias)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].writeValue
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUstreamBatchMemOpParams_union.writeValue.operation' in found_struct}}
            try:
                str_list += ['operation : ' + str(self.operation)]
            except ValueError:
                str_list += ['operation : <ValueError>']
            {{endif}}
            {{if 'CUstreamBatchMemOpParams_union.writeValue.address' in found_struct}}
            try:
                str_list += ['address : ' + str(self.address)]
            except ValueError:
                str_list += ['address : <ValueError>']
            {{endif}}
            {{if 'CUstreamBatchMemOpParams_union.writeValue.value' in found_struct}}
            try:
                str_list += ['value : ' + str(self.value)]
            except ValueError:
                str_list += ['value : <ValueError>']
            {{endif}}
            {{if 'CUstreamBatchMemOpParams_union.writeValue.value64' in found_struct}}
            try:
                str_list += ['value64 : ' + str(self.value64)]
            except ValueError:
                str_list += ['value64 : <ValueError>']
            {{endif}}
            {{if 'CUstreamBatchMemOpParams_union.writeValue.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'CUstreamBatchMemOpParams_union.writeValue.alias' in found_struct}}
            try:
                str_list += ['alias : ' + str(self.alias)]
            except ValueError:
                str_list += ['alias : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUstreamBatchMemOpParams_union.writeValue.operation' in found_struct}}
    @property
    def operation(self):
        if self._pvt_ptr[0].writeValue.operation not in _dict_CUstreamBatchMemOpType:
            return None
        return _dict_CUstreamBatchMemOpType[self._pvt_ptr[0].writeValue.operation]
    @operation.setter
    def operation(self, operation not None : CUstreamBatchMemOpType):
        self._pvt_ptr[0].writeValue.operation = operation.value
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.writeValue.address' in found_struct}}
    @property
    def address(self):
        return self._address
    @address.setter
    def address(self, address):
        cdef cydriver.CUdeviceptr cyaddress
        if address is None:
            cyaddress = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(address, (CUdeviceptr)):
            paddress = int(address)
            cyaddress = <cydriver.CUdeviceptr><void_ptr>paddress
        else:
            paddress = int(CUdeviceptr(address))
            cyaddress = <cydriver.CUdeviceptr><void_ptr>paddress
        self._address._pvt_ptr[0] = cyaddress

    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.writeValue.value' in found_struct}}
    @property
    def value(self):
        return self._value
    @value.setter
    def value(self, value):
        cdef cydriver.cuuint32_t cyvalue
        if value is None:
            cyvalue = <cydriver.cuuint32_t><void_ptr>0
        elif isinstance(value, (cuuint32_t)):
            pvalue = int(value)
            cyvalue = <cydriver.cuuint32_t><void_ptr>pvalue
        else:
            pvalue = int(cuuint32_t(value))
            cyvalue = <cydriver.cuuint32_t><void_ptr>pvalue
        self._value._pvt_ptr[0] = cyvalue

    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.writeValue.value64' in found_struct}}
    @property
    def value64(self):
        return self._value64
    @value64.setter
    def value64(self, value64):
        cdef cydriver.cuuint64_t cyvalue64
        if value64 is None:
            cyvalue64 = <cydriver.cuuint64_t><void_ptr>0
        elif isinstance(value64, (cuuint64_t)):
            pvalue64 = int(value64)
            cyvalue64 = <cydriver.cuuint64_t><void_ptr>pvalue64
        else:
            pvalue64 = int(cuuint64_t(value64))
            cyvalue64 = <cydriver.cuuint64_t><void_ptr>pvalue64
        self._value64._pvt_ptr[0] = cyvalue64

    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.writeValue.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].writeValue.flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].writeValue.flags = flags
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.writeValue.alias' in found_struct}}
    @property
    def alias(self):
        return self._alias
    @alias.setter
    def alias(self, alias):
        cdef cydriver.CUdeviceptr cyalias
        if alias is None:
            cyalias = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(alias, (CUdeviceptr)):
            palias = int(alias)
            cyalias = <cydriver.CUdeviceptr><void_ptr>palias
        else:
            palias = int(CUdeviceptr(alias))
            cyalias = <cydriver.CUdeviceptr><void_ptr>palias
        self._alias._pvt_ptr[0] = cyalias

    {{endif}}
{{endif}}
{{if 'CUstreamBatchMemOpParams_union.flushRemoteWrites' in found_struct}}

cdef class CUstreamMemOpFlushRemoteWritesParams_st:
    """
    Attributes
    ----------
    {{if 'CUstreamBatchMemOpParams_union.flushRemoteWrites.operation' in found_struct}}
    operation : CUstreamBatchMemOpType

    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.flushRemoteWrites.flags' in found_struct}}
    flags : unsigned int
        Must be 0.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUstreamBatchMemOpParams_union *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].flushRemoteWrites
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUstreamBatchMemOpParams_union.flushRemoteWrites.operation' in found_struct}}
            try:
                str_list += ['operation : ' + str(self.operation)]
            except ValueError:
                str_list += ['operation : <ValueError>']
            {{endif}}
            {{if 'CUstreamBatchMemOpParams_union.flushRemoteWrites.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUstreamBatchMemOpParams_union.flushRemoteWrites.operation' in found_struct}}
    @property
    def operation(self):
        if self._pvt_ptr[0].flushRemoteWrites.operation not in _dict_CUstreamBatchMemOpType:
            return None
        return _dict_CUstreamBatchMemOpType[self._pvt_ptr[0].flushRemoteWrites.operation]
    @operation.setter
    def operation(self, operation not None : CUstreamBatchMemOpType):
        self._pvt_ptr[0].flushRemoteWrites.operation = operation.value
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.flushRemoteWrites.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flushRemoteWrites.flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flushRemoteWrites.flags = flags
    {{endif}}
{{endif}}
{{if 'CUstreamBatchMemOpParams_union.memoryBarrier' in found_struct}}

cdef class CUstreamMemOpMemoryBarrierParams_st:
    """
    Attributes
    ----------
    {{if 'CUstreamBatchMemOpParams_union.memoryBarrier.operation' in found_struct}}
    operation : CUstreamBatchMemOpType
        < Only supported in the _v2 API
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.memoryBarrier.flags' in found_struct}}
    flags : unsigned int
        See CUstreamMemoryBarrier_flags
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUstreamBatchMemOpParams_union *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].memoryBarrier
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUstreamBatchMemOpParams_union.memoryBarrier.operation' in found_struct}}
            try:
                str_list += ['operation : ' + str(self.operation)]
            except ValueError:
                str_list += ['operation : <ValueError>']
            {{endif}}
            {{if 'CUstreamBatchMemOpParams_union.memoryBarrier.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUstreamBatchMemOpParams_union.memoryBarrier.operation' in found_struct}}
    @property
    def operation(self):
        if self._pvt_ptr[0].memoryBarrier.operation not in _dict_CUstreamBatchMemOpType:
            return None
        return _dict_CUstreamBatchMemOpType[self._pvt_ptr[0].memoryBarrier.operation]
    @operation.setter
    def operation(self, operation not None : CUstreamBatchMemOpType):
        self._pvt_ptr[0].memoryBarrier.operation = operation.value
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.memoryBarrier.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].memoryBarrier.flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].memoryBarrier.flags = flags
    {{endif}}
{{endif}}
{{if 'CUstreamBatchMemOpParams_union' in found_struct}}

cdef class CUstreamBatchMemOpParams_union:
    """
    Per-operation parameters for cuStreamBatchMemOp

    Attributes
    ----------
    {{if 'CUstreamBatchMemOpParams_union.operation' in found_struct}}
    operation : CUstreamBatchMemOpType
        Operation. This is the first field of all the union elemets and
        acts as a TAG to determine which union member is valid.
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.waitValue' in found_struct}}
    waitValue : CUstreamMemOpWaitValueParams_st
        Params for CU_STREAM_MEM_OP_WAIT_VALUE_32 and
        CU_STREAM_MEM_OP_WAIT_VALUE_64 operations.
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.writeValue' in found_struct}}
    writeValue : CUstreamMemOpWriteValueParams_st
        Params for CU_STREAM_MEM_OP_WRITE_VALUE_32 and
        CU_STREAM_MEM_OP_WRITE_VALUE_64 operations.
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.flushRemoteWrites' in found_struct}}
    flushRemoteWrites : CUstreamMemOpFlushRemoteWritesParams_st
        Params for CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES operations.
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.memoryBarrier' in found_struct}}
    memoryBarrier : CUstreamMemOpMemoryBarrierParams_st
        Params for CU_STREAM_MEM_OP_BARRIER operations.
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.pad' in found_struct}}
    pad : list[cuuint64_t]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUstreamBatchMemOpParams_union *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUstreamBatchMemOpParams_union.waitValue' in found_struct}}
        self._waitValue = CUstreamMemOpWaitValueParams_st(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUstreamBatchMemOpParams_union.writeValue' in found_struct}}
        self._writeValue = CUstreamMemOpWriteValueParams_st(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUstreamBatchMemOpParams_union.flushRemoteWrites' in found_struct}}
        self._flushRemoteWrites = CUstreamMemOpFlushRemoteWritesParams_st(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUstreamBatchMemOpParams_union.memoryBarrier' in found_struct}}
        self._memoryBarrier = CUstreamMemOpMemoryBarrierParams_st(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUstreamBatchMemOpParams_union.operation' in found_struct}}
            try:
                str_list += ['operation : ' + str(self.operation)]
            except ValueError:
                str_list += ['operation : <ValueError>']
            {{endif}}
            {{if 'CUstreamBatchMemOpParams_union.waitValue' in found_struct}}
            try:
                str_list += ['waitValue :\n' + '\n'.join(['    ' + line for line in str(self.waitValue).splitlines()])]
            except ValueError:
                str_list += ['waitValue : <ValueError>']
            {{endif}}
            {{if 'CUstreamBatchMemOpParams_union.writeValue' in found_struct}}
            try:
                str_list += ['writeValue :\n' + '\n'.join(['    ' + line for line in str(self.writeValue).splitlines()])]
            except ValueError:
                str_list += ['writeValue : <ValueError>']
            {{endif}}
            {{if 'CUstreamBatchMemOpParams_union.flushRemoteWrites' in found_struct}}
            try:
                str_list += ['flushRemoteWrites :\n' + '\n'.join(['    ' + line for line in str(self.flushRemoteWrites).splitlines()])]
            except ValueError:
                str_list += ['flushRemoteWrites : <ValueError>']
            {{endif}}
            {{if 'CUstreamBatchMemOpParams_union.memoryBarrier' in found_struct}}
            try:
                str_list += ['memoryBarrier :\n' + '\n'.join(['    ' + line for line in str(self.memoryBarrier).splitlines()])]
            except ValueError:
                str_list += ['memoryBarrier : <ValueError>']
            {{endif}}
            {{if 'CUstreamBatchMemOpParams_union.pad' in found_struct}}
            try:
                str_list += ['pad : ' + str(self.pad)]
            except ValueError:
                str_list += ['pad : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUstreamBatchMemOpParams_union.operation' in found_struct}}
    @property
    def operation(self):
        if self._pvt_ptr[0].operation not in _dict_CUstreamBatchMemOpType:
            return None
        return _dict_CUstreamBatchMemOpType[self._pvt_ptr[0].operation]
    @operation.setter
    def operation(self, operation not None : CUstreamBatchMemOpType):
        self._pvt_ptr[0].operation = operation.value
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.waitValue' in found_struct}}
    @property
    def waitValue(self):
        return self._waitValue
    @waitValue.setter
    def waitValue(self, waitValue not None : CUstreamMemOpWaitValueParams_st):
        string.memcpy(&self._pvt_ptr[0].waitValue, <cydriver.CUstreamMemOpWaitValueParams_st*><void_ptr>waitValue.getPtr(), sizeof(self._pvt_ptr[0].waitValue))
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.writeValue' in found_struct}}
    @property
    def writeValue(self):
        return self._writeValue
    @writeValue.setter
    def writeValue(self, writeValue not None : CUstreamMemOpWriteValueParams_st):
        string.memcpy(&self._pvt_ptr[0].writeValue, <cydriver.CUstreamMemOpWriteValueParams_st*><void_ptr>writeValue.getPtr(), sizeof(self._pvt_ptr[0].writeValue))
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.flushRemoteWrites' in found_struct}}
    @property
    def flushRemoteWrites(self):
        return self._flushRemoteWrites
    @flushRemoteWrites.setter
    def flushRemoteWrites(self, flushRemoteWrites not None : CUstreamMemOpFlushRemoteWritesParams_st):
        string.memcpy(&self._pvt_ptr[0].flushRemoteWrites, <cydriver.CUstreamMemOpFlushRemoteWritesParams_st*><void_ptr>flushRemoteWrites.getPtr(), sizeof(self._pvt_ptr[0].flushRemoteWrites))
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.memoryBarrier' in found_struct}}
    @property
    def memoryBarrier(self):
        return self._memoryBarrier
    @memoryBarrier.setter
    def memoryBarrier(self, memoryBarrier not None : CUstreamMemOpMemoryBarrierParams_st):
        string.memcpy(&self._pvt_ptr[0].memoryBarrier, <cydriver.CUstreamMemOpMemoryBarrierParams_st*><void_ptr>memoryBarrier.getPtr(), sizeof(self._pvt_ptr[0].memoryBarrier))
    {{endif}}
    {{if 'CUstreamBatchMemOpParams_union.pad' in found_struct}}
    @property
    def pad(self):
        return [cuuint64_t(init_value=_pad) for _pad in self._pvt_ptr[0].pad]
    @pad.setter
    def pad(self, pad):
        self._pvt_ptr[0].pad = pad

    {{endif}}
{{endif}}
{{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st' in found_struct}}

cdef class CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st:
    """
    Batch memory operation node parameters  Used in the legacy
    cuGraphAddBatchMemOpNode api. New code should use cuGraphAddNode()

    Attributes
    ----------
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st.ctx' in found_struct}}
    ctx : CUcontext

    {{endif}}
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st.count' in found_struct}}
    count : unsigned int

    {{endif}}
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st.paramArray' in found_struct}}
    paramArray : CUstreamBatchMemOpParams

    {{endif}}
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st.flags' in found_struct}}
    flags : unsigned int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st.ctx' in found_struct}}
        self._ctx = CUcontext(_ptr=<void_ptr>&self._pvt_ptr[0].ctx)
        {{endif}}
    def __dealloc__(self):
        pass
        {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st.paramArray' in found_struct}}
        if self._paramArray is not NULL:
            free(self._paramArray)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st.ctx' in found_struct}}
            try:
                str_list += ['ctx : ' + str(self.ctx)]
            except ValueError:
                str_list += ['ctx : <ValueError>']
            {{endif}}
            {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st.count' in found_struct}}
            try:
                str_list += ['count : ' + str(self.count)]
            except ValueError:
                str_list += ['count : <ValueError>']
            {{endif}}
            {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st.paramArray' in found_struct}}
            try:
                str_list += ['paramArray : ' + str(self.paramArray)]
            except ValueError:
                str_list += ['paramArray : <ValueError>']
            {{endif}}
            {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st.ctx' in found_struct}}
    @property
    def ctx(self):
        return self._ctx
    @ctx.setter
    def ctx(self, ctx):
        cdef cydriver.CUcontext cyctx
        if ctx is None:
            cyctx = <cydriver.CUcontext><void_ptr>0
        elif isinstance(ctx, (CUcontext,)):
            pctx = int(ctx)
            cyctx = <cydriver.CUcontext><void_ptr>pctx
        else:
            pctx = int(CUcontext(ctx))
            cyctx = <cydriver.CUcontext><void_ptr>pctx
        self._ctx._pvt_ptr[0] = cyctx
    {{endif}}
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st.count' in found_struct}}
    @property
    def count(self):
        return self._pvt_ptr[0].count
    @count.setter
    def count(self, unsigned int count):
        self._pvt_ptr[0].count = count
    {{endif}}
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st.paramArray' in found_struct}}
    @property
    def paramArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].paramArray + x*sizeof(cydriver.CUstreamBatchMemOpParams) for x in range(self._paramArray_length)]
        return [CUstreamBatchMemOpParams(_ptr=arr) for arr in arrs]
    @paramArray.setter
    def paramArray(self, val):
        if len(val) == 0:
            free(self._paramArray)
            self._paramArray_length = 0
            self._pvt_ptr[0].paramArray = NULL
        else:
            if self._paramArray_length != <size_t>len(val):
                free(self._paramArray)
                self._paramArray = <cydriver.CUstreamBatchMemOpParams*> calloc(len(val), sizeof(cydriver.CUstreamBatchMemOpParams))
                if self._paramArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cydriver.CUstreamBatchMemOpParams)))
                self._paramArray_length = <size_t>len(val)
                self._pvt_ptr[0].paramArray = self._paramArray
            for idx in range(len(val)):
                string.memcpy(&self._paramArray[idx], (<CUstreamBatchMemOpParams>val[idx])._pvt_ptr, sizeof(cydriver.CUstreamBatchMemOpParams))

    {{endif}}
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
{{endif}}
{{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st' in found_struct}}

cdef class CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st:
    """
    Batch memory operation node parameters

    Attributes
    ----------
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st.ctx' in found_struct}}
    ctx : CUcontext
        Context to use for the operations.
    {{endif}}
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st.count' in found_struct}}
    count : unsigned int
        Number of operations in paramArray.
    {{endif}}
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st.paramArray' in found_struct}}
    paramArray : CUstreamBatchMemOpParams
        Array of batch memory operations.
    {{endif}}
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st.flags' in found_struct}}
    flags : unsigned int
        Flags to control the node.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st.ctx' in found_struct}}
        self._ctx = CUcontext(_ptr=<void_ptr>&self._pvt_ptr[0].ctx)
        {{endif}}
    def __dealloc__(self):
        pass
        {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st.paramArray' in found_struct}}
        if self._paramArray is not NULL:
            free(self._paramArray)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st.ctx' in found_struct}}
            try:
                str_list += ['ctx : ' + str(self.ctx)]
            except ValueError:
                str_list += ['ctx : <ValueError>']
            {{endif}}
            {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st.count' in found_struct}}
            try:
                str_list += ['count : ' + str(self.count)]
            except ValueError:
                str_list += ['count : <ValueError>']
            {{endif}}
            {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st.paramArray' in found_struct}}
            try:
                str_list += ['paramArray : ' + str(self.paramArray)]
            except ValueError:
                str_list += ['paramArray : <ValueError>']
            {{endif}}
            {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st.ctx' in found_struct}}
    @property
    def ctx(self):
        return self._ctx
    @ctx.setter
    def ctx(self, ctx):
        cdef cydriver.CUcontext cyctx
        if ctx is None:
            cyctx = <cydriver.CUcontext><void_ptr>0
        elif isinstance(ctx, (CUcontext,)):
            pctx = int(ctx)
            cyctx = <cydriver.CUcontext><void_ptr>pctx
        else:
            pctx = int(CUcontext(ctx))
            cyctx = <cydriver.CUcontext><void_ptr>pctx
        self._ctx._pvt_ptr[0] = cyctx
    {{endif}}
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st.count' in found_struct}}
    @property
    def count(self):
        return self._pvt_ptr[0].count
    @count.setter
    def count(self, unsigned int count):
        self._pvt_ptr[0].count = count
    {{endif}}
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st.paramArray' in found_struct}}
    @property
    def paramArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].paramArray + x*sizeof(cydriver.CUstreamBatchMemOpParams) for x in range(self._paramArray_length)]
        return [CUstreamBatchMemOpParams(_ptr=arr) for arr in arrs]
    @paramArray.setter
    def paramArray(self, val):
        if len(val) == 0:
            free(self._paramArray)
            self._paramArray_length = 0
            self._pvt_ptr[0].paramArray = NULL
        else:
            if self._paramArray_length != <size_t>len(val):
                free(self._paramArray)
                self._paramArray = <cydriver.CUstreamBatchMemOpParams*> calloc(len(val), sizeof(cydriver.CUstreamBatchMemOpParams))
                if self._paramArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cydriver.CUstreamBatchMemOpParams)))
                self._paramArray_length = <size_t>len(val)
                self._pvt_ptr[0].paramArray = self._paramArray
            for idx in range(len(val)):
                string.memcpy(&self._paramArray[idx], (<CUstreamBatchMemOpParams>val[idx])._pvt_ptr, sizeof(cydriver.CUstreamBatchMemOpParams))

    {{endif}}
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
{{endif}}
{{if 'CUasyncNotificationInfo_st.info.overBudget' in found_struct}}

cdef class anon_struct0:
    """
    Attributes
    ----------
    {{if 'CUasyncNotificationInfo_st.info.overBudget.bytesOverBudget' in found_struct}}
    bytesOverBudget : unsigned long long

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUasyncNotificationInfo_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].info.overBudget
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUasyncNotificationInfo_st.info.overBudget.bytesOverBudget' in found_struct}}
            try:
                str_list += ['bytesOverBudget : ' + str(self.bytesOverBudget)]
            except ValueError:
                str_list += ['bytesOverBudget : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUasyncNotificationInfo_st.info.overBudget.bytesOverBudget' in found_struct}}
    @property
    def bytesOverBudget(self):
        return self._pvt_ptr[0].info.overBudget.bytesOverBudget
    @bytesOverBudget.setter
    def bytesOverBudget(self, unsigned long long bytesOverBudget):
        self._pvt_ptr[0].info.overBudget.bytesOverBudget = bytesOverBudget
    {{endif}}
{{endif}}
{{if 'CUasyncNotificationInfo_st.info' in found_struct}}

cdef class anon_union2:
    """
    Attributes
    ----------
    {{if 'CUasyncNotificationInfo_st.info.overBudget' in found_struct}}
    overBudget : anon_struct0

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUasyncNotificationInfo_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUasyncNotificationInfo_st.info.overBudget' in found_struct}}
        self._overBudget = anon_struct0(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].info
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUasyncNotificationInfo_st.info.overBudget' in found_struct}}
            try:
                str_list += ['overBudget :\n' + '\n'.join(['    ' + line for line in str(self.overBudget).splitlines()])]
            except ValueError:
                str_list += ['overBudget : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUasyncNotificationInfo_st.info.overBudget' in found_struct}}
    @property
    def overBudget(self):
        return self._overBudget
    @overBudget.setter
    def overBudget(self, overBudget not None : anon_struct0):
        string.memcpy(&self._pvt_ptr[0].info.overBudget, <cydriver.anon_struct0*><void_ptr>overBudget.getPtr(), sizeof(self._pvt_ptr[0].info.overBudget))
    {{endif}}
{{endif}}
{{if 'CUasyncNotificationInfo_st' in found_struct}}

cdef class CUasyncNotificationInfo_st:
    """
    Information passed to the user via the async notification callback

    Attributes
    ----------
    {{if 'CUasyncNotificationInfo_st.type' in found_struct}}
    type : CUasyncNotificationType
        The type of notification being sent
    {{endif}}
    {{if 'CUasyncNotificationInfo_st.info' in found_struct}}
    info : anon_union2
        Information about the notification. `typename` must be checked in
        order to interpret this field.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cydriver.CUasyncNotificationInfo_st *>calloc(1, sizeof(cydriver.CUasyncNotificationInfo_st))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cydriver.CUasyncNotificationInfo_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUasyncNotificationInfo_st.info' in found_struct}}
        self._info = anon_union2(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUasyncNotificationInfo_st.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'CUasyncNotificationInfo_st.info' in found_struct}}
            try:
                str_list += ['info :\n' + '\n'.join(['    ' + line for line in str(self.info).splitlines()])]
            except ValueError:
                str_list += ['info : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUasyncNotificationInfo_st.type' in found_struct}}
    @property
    def type(self):
        if self._pvt_ptr[0].type not in _dict_CUasyncNotificationType:
            return None
        return _dict_CUasyncNotificationType[self._pvt_ptr[0].type]
    @type.setter
    def type(self, type not None : CUasyncNotificationType):
        self._pvt_ptr[0].type = type.value
    {{endif}}
    {{if 'CUasyncNotificationInfo_st.info' in found_struct}}
    @property
    def info(self):
        return self._info
    @info.setter
    def info(self, info not None : anon_union2):
        string.memcpy(&self._pvt_ptr[0].info, <cydriver.anon_union2*><void_ptr>info.getPtr(), sizeof(self._pvt_ptr[0].info))
    {{endif}}
{{endif}}
{{if 'CUdevprop_st' in found_struct}}

cdef class CUdevprop_st:
    """
    Legacy device properties

    Attributes
    ----------
    {{if 'CUdevprop_st.maxThreadsPerBlock' in found_struct}}
    maxThreadsPerBlock : int
        Maximum number of threads per block
    {{endif}}
    {{if 'CUdevprop_st.maxThreadsDim' in found_struct}}
    maxThreadsDim : list[int]
        Maximum size of each dimension of a block
    {{endif}}
    {{if 'CUdevprop_st.maxGridSize' in found_struct}}
    maxGridSize : list[int]
        Maximum size of each dimension of a grid
    {{endif}}
    {{if 'CUdevprop_st.sharedMemPerBlock' in found_struct}}
    sharedMemPerBlock : int
        Shared memory available per block in bytes
    {{endif}}
    {{if 'CUdevprop_st.totalConstantMemory' in found_struct}}
    totalConstantMemory : int
        Constant memory available on device in bytes
    {{endif}}
    {{if 'CUdevprop_st.SIMDWidth' in found_struct}}
    SIMDWidth : int
        Warp size in threads
    {{endif}}
    {{if 'CUdevprop_st.memPitch' in found_struct}}
    memPitch : int
        Maximum pitch in bytes allowed by memory copies
    {{endif}}
    {{if 'CUdevprop_st.regsPerBlock' in found_struct}}
    regsPerBlock : int
        32-bit registers available per block
    {{endif}}
    {{if 'CUdevprop_st.clockRate' in found_struct}}
    clockRate : int
        Clock frequency in kilohertz
    {{endif}}
    {{if 'CUdevprop_st.textureAlign' in found_struct}}
    textureAlign : int
        Alignment requirement for textures
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUdevprop_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUdevprop_st.maxThreadsPerBlock' in found_struct}}
            try:
                str_list += ['maxThreadsPerBlock : ' + str(self.maxThreadsPerBlock)]
            except ValueError:
                str_list += ['maxThreadsPerBlock : <ValueError>']
            {{endif}}
            {{if 'CUdevprop_st.maxThreadsDim' in found_struct}}
            try:
                str_list += ['maxThreadsDim : ' + str(self.maxThreadsDim)]
            except ValueError:
                str_list += ['maxThreadsDim : <ValueError>']
            {{endif}}
            {{if 'CUdevprop_st.maxGridSize' in found_struct}}
            try:
                str_list += ['maxGridSize : ' + str(self.maxGridSize)]
            except ValueError:
                str_list += ['maxGridSize : <ValueError>']
            {{endif}}
            {{if 'CUdevprop_st.sharedMemPerBlock' in found_struct}}
            try:
                str_list += ['sharedMemPerBlock : ' + str(self.sharedMemPerBlock)]
            except ValueError:
                str_list += ['sharedMemPerBlock : <ValueError>']
            {{endif}}
            {{if 'CUdevprop_st.totalConstantMemory' in found_struct}}
            try:
                str_list += ['totalConstantMemory : ' + str(self.totalConstantMemory)]
            except ValueError:
                str_list += ['totalConstantMemory : <ValueError>']
            {{endif}}
            {{if 'CUdevprop_st.SIMDWidth' in found_struct}}
            try:
                str_list += ['SIMDWidth : ' + str(self.SIMDWidth)]
            except ValueError:
                str_list += ['SIMDWidth : <ValueError>']
            {{endif}}
            {{if 'CUdevprop_st.memPitch' in found_struct}}
            try:
                str_list += ['memPitch : ' + str(self.memPitch)]
            except ValueError:
                str_list += ['memPitch : <ValueError>']
            {{endif}}
            {{if 'CUdevprop_st.regsPerBlock' in found_struct}}
            try:
                str_list += ['regsPerBlock : ' + str(self.regsPerBlock)]
            except ValueError:
                str_list += ['regsPerBlock : <ValueError>']
            {{endif}}
            {{if 'CUdevprop_st.clockRate' in found_struct}}
            try:
                str_list += ['clockRate : ' + str(self.clockRate)]
            except ValueError:
                str_list += ['clockRate : <ValueError>']
            {{endif}}
            {{if 'CUdevprop_st.textureAlign' in found_struct}}
            try:
                str_list += ['textureAlign : ' + str(self.textureAlign)]
            except ValueError:
                str_list += ['textureAlign : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUdevprop_st.maxThreadsPerBlock' in found_struct}}
    @property
    def maxThreadsPerBlock(self):
        return self._pvt_ptr[0].maxThreadsPerBlock
    @maxThreadsPerBlock.setter
    def maxThreadsPerBlock(self, int maxThreadsPerBlock):
        self._pvt_ptr[0].maxThreadsPerBlock = maxThreadsPerBlock
    {{endif}}
    {{if 'CUdevprop_st.maxThreadsDim' in found_struct}}
    @property
    def maxThreadsDim(self):
        return self._pvt_ptr[0].maxThreadsDim
    @maxThreadsDim.setter
    def maxThreadsDim(self, maxThreadsDim):
        self._pvt_ptr[0].maxThreadsDim = maxThreadsDim
    {{endif}}
    {{if 'CUdevprop_st.maxGridSize' in found_struct}}
    @property
    def maxGridSize(self):
        return self._pvt_ptr[0].maxGridSize
    @maxGridSize.setter
    def maxGridSize(self, maxGridSize):
        self._pvt_ptr[0].maxGridSize = maxGridSize
    {{endif}}
    {{if 'CUdevprop_st.sharedMemPerBlock' in found_struct}}
    @property
    def sharedMemPerBlock(self):
        return self._pvt_ptr[0].sharedMemPerBlock
    @sharedMemPerBlock.setter
    def sharedMemPerBlock(self, int sharedMemPerBlock):
        self._pvt_ptr[0].sharedMemPerBlock = sharedMemPerBlock
    {{endif}}
    {{if 'CUdevprop_st.totalConstantMemory' in found_struct}}
    @property
    def totalConstantMemory(self):
        return self._pvt_ptr[0].totalConstantMemory
    @totalConstantMemory.setter
    def totalConstantMemory(self, int totalConstantMemory):
        self._pvt_ptr[0].totalConstantMemory = totalConstantMemory
    {{endif}}
    {{if 'CUdevprop_st.SIMDWidth' in found_struct}}
    @property
    def SIMDWidth(self):
        return self._pvt_ptr[0].SIMDWidth
    @SIMDWidth.setter
    def SIMDWidth(self, int SIMDWidth):
        self._pvt_ptr[0].SIMDWidth = SIMDWidth
    {{endif}}
    {{if 'CUdevprop_st.memPitch' in found_struct}}
    @property
    def memPitch(self):
        return self._pvt_ptr[0].memPitch
    @memPitch.setter
    def memPitch(self, int memPitch):
        self._pvt_ptr[0].memPitch = memPitch
    {{endif}}
    {{if 'CUdevprop_st.regsPerBlock' in found_struct}}
    @property
    def regsPerBlock(self):
        return self._pvt_ptr[0].regsPerBlock
    @regsPerBlock.setter
    def regsPerBlock(self, int regsPerBlock):
        self._pvt_ptr[0].regsPerBlock = regsPerBlock
    {{endif}}
    {{if 'CUdevprop_st.clockRate' in found_struct}}
    @property
    def clockRate(self):
        return self._pvt_ptr[0].clockRate
    @clockRate.setter
    def clockRate(self, int clockRate):
        self._pvt_ptr[0].clockRate = clockRate
    {{endif}}
    {{if 'CUdevprop_st.textureAlign' in found_struct}}
    @property
    def textureAlign(self):
        return self._pvt_ptr[0].textureAlign
    @textureAlign.setter
    def textureAlign(self, int textureAlign):
        self._pvt_ptr[0].textureAlign = textureAlign
    {{endif}}
{{endif}}
{{if 'CUaccessPolicyWindow_st' in found_struct}}

cdef class CUaccessPolicyWindow_st:
    """
    Specifies an access policy for a window, a contiguous extent of
    memory beginning at base_ptr and ending at base_ptr + num_bytes.
    num_bytes is limited by
    CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE. Partition into
    many segments and assign segments such that: sum of "hit segments"
    / window == approx. ratio. sum of "miss segments" / window ==
    approx 1-ratio. Segments and ratio specifications are fitted to the
    capabilities of the architecture. Accesses in a hit segment apply
    the hitProp access policy. Accesses in a miss segment apply the
    missProp access policy.

    Attributes
    ----------
    {{if 'CUaccessPolicyWindow_st.base_ptr' in found_struct}}
    base_ptr : Any
        Starting address of the access policy window. CUDA driver may align
        it.
    {{endif}}
    {{if 'CUaccessPolicyWindow_st.num_bytes' in found_struct}}
    num_bytes : size_t
        Size in bytes of the window policy. CUDA driver may restrict the
        maximum size and alignment.
    {{endif}}
    {{if 'CUaccessPolicyWindow_st.hitRatio' in found_struct}}
    hitRatio : float
        hitRatio specifies percentage of lines assigned hitProp, rest are
        assigned missProp.
    {{endif}}
    {{if 'CUaccessPolicyWindow_st.hitProp' in found_struct}}
    hitProp : CUaccessProperty
        CUaccessProperty set for hit.
    {{endif}}
    {{if 'CUaccessPolicyWindow_st.missProp' in found_struct}}
    missProp : CUaccessProperty
        CUaccessProperty set for miss. Must be either NORMAL or STREAMING
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUaccessPolicyWindow_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUaccessPolicyWindow_st.base_ptr' in found_struct}}
            try:
                str_list += ['base_ptr : ' + hex(self.base_ptr)]
            except ValueError:
                str_list += ['base_ptr : <ValueError>']
            {{endif}}
            {{if 'CUaccessPolicyWindow_st.num_bytes' in found_struct}}
            try:
                str_list += ['num_bytes : ' + str(self.num_bytes)]
            except ValueError:
                str_list += ['num_bytes : <ValueError>']
            {{endif}}
            {{if 'CUaccessPolicyWindow_st.hitRatio' in found_struct}}
            try:
                str_list += ['hitRatio : ' + str(self.hitRatio)]
            except ValueError:
                str_list += ['hitRatio : <ValueError>']
            {{endif}}
            {{if 'CUaccessPolicyWindow_st.hitProp' in found_struct}}
            try:
                str_list += ['hitProp : ' + str(self.hitProp)]
            except ValueError:
                str_list += ['hitProp : <ValueError>']
            {{endif}}
            {{if 'CUaccessPolicyWindow_st.missProp' in found_struct}}
            try:
                str_list += ['missProp : ' + str(self.missProp)]
            except ValueError:
                str_list += ['missProp : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUaccessPolicyWindow_st.base_ptr' in found_struct}}
    @property
    def base_ptr(self):
        return <void_ptr>self._pvt_ptr[0].base_ptr
    @base_ptr.setter
    def base_ptr(self, base_ptr):
        _cbase_ptr = _HelperInputVoidPtr(base_ptr)
        self._pvt_ptr[0].base_ptr = <void*><void_ptr>_cbase_ptr.cptr
    {{endif}}
    {{if 'CUaccessPolicyWindow_st.num_bytes' in found_struct}}
    @property
    def num_bytes(self):
        return self._pvt_ptr[0].num_bytes
    @num_bytes.setter
    def num_bytes(self, size_t num_bytes):
        self._pvt_ptr[0].num_bytes = num_bytes
    {{endif}}
    {{if 'CUaccessPolicyWindow_st.hitRatio' in found_struct}}
    @property
    def hitRatio(self):
        return self._pvt_ptr[0].hitRatio
    @hitRatio.setter
    def hitRatio(self, float hitRatio):
        self._pvt_ptr[0].hitRatio = hitRatio
    {{endif}}
    {{if 'CUaccessPolicyWindow_st.hitProp' in found_struct}}
    @property
    def hitProp(self):
        if self._pvt_ptr[0].hitProp not in _dict_CUaccessProperty:
            return None
        return _dict_CUaccessProperty[self._pvt_ptr[0].hitProp]
    @hitProp.setter
    def hitProp(self, hitProp not None : CUaccessProperty):
        self._pvt_ptr[0].hitProp = hitProp.value
    {{endif}}
    {{if 'CUaccessPolicyWindow_st.missProp' in found_struct}}
    @property
    def missProp(self):
        if self._pvt_ptr[0].missProp not in _dict_CUaccessProperty:
            return None
        return _dict_CUaccessProperty[self._pvt_ptr[0].missProp]
    @missProp.setter
    def missProp(self, missProp not None : CUaccessProperty):
        self._pvt_ptr[0].missProp = missProp.value
    {{endif}}
{{endif}}
{{if 'CUDA_KERNEL_NODE_PARAMS_st' in found_struct}}

cdef class CUDA_KERNEL_NODE_PARAMS_st:
    """
    GPU kernel node parameters

    Attributes
    ----------
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.func' in found_struct}}
    func : CUfunction
        Kernel to launch
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.gridDimX' in found_struct}}
    gridDimX : unsigned int
        Width of grid in blocks
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.gridDimY' in found_struct}}
    gridDimY : unsigned int
        Height of grid in blocks
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.gridDimZ' in found_struct}}
    gridDimZ : unsigned int
        Depth of grid in blocks
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.blockDimX' in found_struct}}
    blockDimX : unsigned int
        X dimension of each thread block
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.blockDimY' in found_struct}}
    blockDimY : unsigned int
        Y dimension of each thread block
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.blockDimZ' in found_struct}}
    blockDimZ : unsigned int
        Z dimension of each thread block
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.sharedMemBytes' in found_struct}}
    sharedMemBytes : unsigned int
        Dynamic shared-memory size per thread block in bytes
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.kernelParams' in found_struct}}
    kernelParams : Any
        Array of pointers to kernel parameters
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.extra' in found_struct}}
    extra : Any
        Extra options
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_KERNEL_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_KERNEL_NODE_PARAMS_st.func' in found_struct}}
        self._func = CUfunction(_ptr=<void_ptr>&self._pvt_ptr[0].func)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_KERNEL_NODE_PARAMS_st.func' in found_struct}}
            try:
                str_list += ['func : ' + str(self.func)]
            except ValueError:
                str_list += ['func : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_st.gridDimX' in found_struct}}
            try:
                str_list += ['gridDimX : ' + str(self.gridDimX)]
            except ValueError:
                str_list += ['gridDimX : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_st.gridDimY' in found_struct}}
            try:
                str_list += ['gridDimY : ' + str(self.gridDimY)]
            except ValueError:
                str_list += ['gridDimY : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_st.gridDimZ' in found_struct}}
            try:
                str_list += ['gridDimZ : ' + str(self.gridDimZ)]
            except ValueError:
                str_list += ['gridDimZ : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_st.blockDimX' in found_struct}}
            try:
                str_list += ['blockDimX : ' + str(self.blockDimX)]
            except ValueError:
                str_list += ['blockDimX : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_st.blockDimY' in found_struct}}
            try:
                str_list += ['blockDimY : ' + str(self.blockDimY)]
            except ValueError:
                str_list += ['blockDimY : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_st.blockDimZ' in found_struct}}
            try:
                str_list += ['blockDimZ : ' + str(self.blockDimZ)]
            except ValueError:
                str_list += ['blockDimZ : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_st.sharedMemBytes' in found_struct}}
            try:
                str_list += ['sharedMemBytes : ' + str(self.sharedMemBytes)]
            except ValueError:
                str_list += ['sharedMemBytes : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_st.kernelParams' in found_struct}}
            try:
                str_list += ['kernelParams : ' + str(self.kernelParams)]
            except ValueError:
                str_list += ['kernelParams : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_st.extra' in found_struct}}
            try:
                str_list += ['extra : ' + str(self.extra)]
            except ValueError:
                str_list += ['extra : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.func' in found_struct}}
    @property
    def func(self):
        return self._func
    @func.setter
    def func(self, func):
        cdef cydriver.CUfunction cyfunc
        if func is None:
            cyfunc = <cydriver.CUfunction><void_ptr>0
        elif isinstance(func, (CUfunction,)):
            pfunc = int(func)
            cyfunc = <cydriver.CUfunction><void_ptr>pfunc
        else:
            pfunc = int(CUfunction(func))
            cyfunc = <cydriver.CUfunction><void_ptr>pfunc
        self._func._pvt_ptr[0] = cyfunc
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.gridDimX' in found_struct}}
    @property
    def gridDimX(self):
        return self._pvt_ptr[0].gridDimX
    @gridDimX.setter
    def gridDimX(self, unsigned int gridDimX):
        self._pvt_ptr[0].gridDimX = gridDimX
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.gridDimY' in found_struct}}
    @property
    def gridDimY(self):
        return self._pvt_ptr[0].gridDimY
    @gridDimY.setter
    def gridDimY(self, unsigned int gridDimY):
        self._pvt_ptr[0].gridDimY = gridDimY
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.gridDimZ' in found_struct}}
    @property
    def gridDimZ(self):
        return self._pvt_ptr[0].gridDimZ
    @gridDimZ.setter
    def gridDimZ(self, unsigned int gridDimZ):
        self._pvt_ptr[0].gridDimZ = gridDimZ
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.blockDimX' in found_struct}}
    @property
    def blockDimX(self):
        return self._pvt_ptr[0].blockDimX
    @blockDimX.setter
    def blockDimX(self, unsigned int blockDimX):
        self._pvt_ptr[0].blockDimX = blockDimX
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.blockDimY' in found_struct}}
    @property
    def blockDimY(self):
        return self._pvt_ptr[0].blockDimY
    @blockDimY.setter
    def blockDimY(self, unsigned int blockDimY):
        self._pvt_ptr[0].blockDimY = blockDimY
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.blockDimZ' in found_struct}}
    @property
    def blockDimZ(self):
        return self._pvt_ptr[0].blockDimZ
    @blockDimZ.setter
    def blockDimZ(self, unsigned int blockDimZ):
        self._pvt_ptr[0].blockDimZ = blockDimZ
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.sharedMemBytes' in found_struct}}
    @property
    def sharedMemBytes(self):
        return self._pvt_ptr[0].sharedMemBytes
    @sharedMemBytes.setter
    def sharedMemBytes(self, unsigned int sharedMemBytes):
        self._pvt_ptr[0].sharedMemBytes = sharedMemBytes
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.kernelParams' in found_struct}}
    @property
    def kernelParams(self):
        return <void_ptr>self._pvt_ptr[0].kernelParams
    @kernelParams.setter
    def kernelParams(self, kernelParams):
        self._cykernelParams = _HelperKernelParams(kernelParams)
        self._pvt_ptr[0].kernelParams = <void**><void_ptr>self._cykernelParams.ckernelParams
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st.extra' in found_struct}}
    @property
    def extra(self):
        return <void_ptr>self._pvt_ptr[0].extra
    @extra.setter
    def extra(self, void_ptr extra):
        self._pvt_ptr[0].extra = <void**>extra
    {{endif}}
{{endif}}
{{if 'CUDA_KERNEL_NODE_PARAMS_v2_st' in found_struct}}

cdef class CUDA_KERNEL_NODE_PARAMS_v2_st:
    """
    GPU kernel node parameters

    Attributes
    ----------
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.func' in found_struct}}
    func : CUfunction
        Kernel to launch
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.gridDimX' in found_struct}}
    gridDimX : unsigned int
        Width of grid in blocks
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.gridDimY' in found_struct}}
    gridDimY : unsigned int
        Height of grid in blocks
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.gridDimZ' in found_struct}}
    gridDimZ : unsigned int
        Depth of grid in blocks
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.blockDimX' in found_struct}}
    blockDimX : unsigned int
        X dimension of each thread block
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.blockDimY' in found_struct}}
    blockDimY : unsigned int
        Y dimension of each thread block
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.blockDimZ' in found_struct}}
    blockDimZ : unsigned int
        Z dimension of each thread block
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.sharedMemBytes' in found_struct}}
    sharedMemBytes : unsigned int
        Dynamic shared-memory size per thread block in bytes
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.kernelParams' in found_struct}}
    kernelParams : Any
        Array of pointers to kernel parameters
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.extra' in found_struct}}
    extra : Any
        Extra options
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.kern' in found_struct}}
    kern : CUkernel
        Kernel to launch, will only be referenced if func is NULL
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.ctx' in found_struct}}
    ctx : CUcontext
        Context for the kernel task to run in. The value NULL will indicate
        the current context should be used by the api. This field is
        ignored if func is set.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_KERNEL_NODE_PARAMS_v2_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.func' in found_struct}}
        self._func = CUfunction(_ptr=<void_ptr>&self._pvt_ptr[0].func)
        {{endif}}
        {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.kern' in found_struct}}
        self._kern = CUkernel(_ptr=<void_ptr>&self._pvt_ptr[0].kern)
        {{endif}}
        {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.ctx' in found_struct}}
        self._ctx = CUcontext(_ptr=<void_ptr>&self._pvt_ptr[0].ctx)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.func' in found_struct}}
            try:
                str_list += ['func : ' + str(self.func)]
            except ValueError:
                str_list += ['func : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.gridDimX' in found_struct}}
            try:
                str_list += ['gridDimX : ' + str(self.gridDimX)]
            except ValueError:
                str_list += ['gridDimX : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.gridDimY' in found_struct}}
            try:
                str_list += ['gridDimY : ' + str(self.gridDimY)]
            except ValueError:
                str_list += ['gridDimY : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.gridDimZ' in found_struct}}
            try:
                str_list += ['gridDimZ : ' + str(self.gridDimZ)]
            except ValueError:
                str_list += ['gridDimZ : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.blockDimX' in found_struct}}
            try:
                str_list += ['blockDimX : ' + str(self.blockDimX)]
            except ValueError:
                str_list += ['blockDimX : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.blockDimY' in found_struct}}
            try:
                str_list += ['blockDimY : ' + str(self.blockDimY)]
            except ValueError:
                str_list += ['blockDimY : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.blockDimZ' in found_struct}}
            try:
                str_list += ['blockDimZ : ' + str(self.blockDimZ)]
            except ValueError:
                str_list += ['blockDimZ : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.sharedMemBytes' in found_struct}}
            try:
                str_list += ['sharedMemBytes : ' + str(self.sharedMemBytes)]
            except ValueError:
                str_list += ['sharedMemBytes : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.kernelParams' in found_struct}}
            try:
                str_list += ['kernelParams : ' + str(self.kernelParams)]
            except ValueError:
                str_list += ['kernelParams : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.extra' in found_struct}}
            try:
                str_list += ['extra : ' + str(self.extra)]
            except ValueError:
                str_list += ['extra : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.kern' in found_struct}}
            try:
                str_list += ['kern : ' + str(self.kern)]
            except ValueError:
                str_list += ['kern : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.ctx' in found_struct}}
            try:
                str_list += ['ctx : ' + str(self.ctx)]
            except ValueError:
                str_list += ['ctx : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.func' in found_struct}}
    @property
    def func(self):
        return self._func
    @func.setter
    def func(self, func):
        cdef cydriver.CUfunction cyfunc
        if func is None:
            cyfunc = <cydriver.CUfunction><void_ptr>0
        elif isinstance(func, (CUfunction,)):
            pfunc = int(func)
            cyfunc = <cydriver.CUfunction><void_ptr>pfunc
        else:
            pfunc = int(CUfunction(func))
            cyfunc = <cydriver.CUfunction><void_ptr>pfunc
        self._func._pvt_ptr[0] = cyfunc
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.gridDimX' in found_struct}}
    @property
    def gridDimX(self):
        return self._pvt_ptr[0].gridDimX
    @gridDimX.setter
    def gridDimX(self, unsigned int gridDimX):
        self._pvt_ptr[0].gridDimX = gridDimX
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.gridDimY' in found_struct}}
    @property
    def gridDimY(self):
        return self._pvt_ptr[0].gridDimY
    @gridDimY.setter
    def gridDimY(self, unsigned int gridDimY):
        self._pvt_ptr[0].gridDimY = gridDimY
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.gridDimZ' in found_struct}}
    @property
    def gridDimZ(self):
        return self._pvt_ptr[0].gridDimZ
    @gridDimZ.setter
    def gridDimZ(self, unsigned int gridDimZ):
        self._pvt_ptr[0].gridDimZ = gridDimZ
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.blockDimX' in found_struct}}
    @property
    def blockDimX(self):
        return self._pvt_ptr[0].blockDimX
    @blockDimX.setter
    def blockDimX(self, unsigned int blockDimX):
        self._pvt_ptr[0].blockDimX = blockDimX
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.blockDimY' in found_struct}}
    @property
    def blockDimY(self):
        return self._pvt_ptr[0].blockDimY
    @blockDimY.setter
    def blockDimY(self, unsigned int blockDimY):
        self._pvt_ptr[0].blockDimY = blockDimY
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.blockDimZ' in found_struct}}
    @property
    def blockDimZ(self):
        return self._pvt_ptr[0].blockDimZ
    @blockDimZ.setter
    def blockDimZ(self, unsigned int blockDimZ):
        self._pvt_ptr[0].blockDimZ = blockDimZ
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.sharedMemBytes' in found_struct}}
    @property
    def sharedMemBytes(self):
        return self._pvt_ptr[0].sharedMemBytes
    @sharedMemBytes.setter
    def sharedMemBytes(self, unsigned int sharedMemBytes):
        self._pvt_ptr[0].sharedMemBytes = sharedMemBytes
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.kernelParams' in found_struct}}
    @property
    def kernelParams(self):
        return <void_ptr>self._pvt_ptr[0].kernelParams
    @kernelParams.setter
    def kernelParams(self, kernelParams):
        self._cykernelParams = _HelperKernelParams(kernelParams)
        self._pvt_ptr[0].kernelParams = <void**><void_ptr>self._cykernelParams.ckernelParams
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.extra' in found_struct}}
    @property
    def extra(self):
        return <void_ptr>self._pvt_ptr[0].extra
    @extra.setter
    def extra(self, void_ptr extra):
        self._pvt_ptr[0].extra = <void**>extra
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.kern' in found_struct}}
    @property
    def kern(self):
        return self._kern
    @kern.setter
    def kern(self, kern):
        cdef cydriver.CUkernel cykern
        if kern is None:
            cykern = <cydriver.CUkernel><void_ptr>0
        elif isinstance(kern, (CUkernel,)):
            pkern = int(kern)
            cykern = <cydriver.CUkernel><void_ptr>pkern
        else:
            pkern = int(CUkernel(kern))
            cykern = <cydriver.CUkernel><void_ptr>pkern
        self._kern._pvt_ptr[0] = cykern
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st.ctx' in found_struct}}
    @property
    def ctx(self):
        return self._ctx
    @ctx.setter
    def ctx(self, ctx):
        cdef cydriver.CUcontext cyctx
        if ctx is None:
            cyctx = <cydriver.CUcontext><void_ptr>0
        elif isinstance(ctx, (CUcontext,)):
            pctx = int(ctx)
            cyctx = <cydriver.CUcontext><void_ptr>pctx
        else:
            pctx = int(CUcontext(ctx))
            cyctx = <cydriver.CUcontext><void_ptr>pctx
        self._ctx._pvt_ptr[0] = cyctx
    {{endif}}
{{endif}}
{{if 'CUDA_KERNEL_NODE_PARAMS_v3_st' in found_struct}}

cdef class CUDA_KERNEL_NODE_PARAMS_v3_st:
    """
    GPU kernel node parameters

    Attributes
    ----------
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.func' in found_struct}}
    func : CUfunction
        Kernel to launch
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.gridDimX' in found_struct}}
    gridDimX : unsigned int
        Width of grid in blocks
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.gridDimY' in found_struct}}
    gridDimY : unsigned int
        Height of grid in blocks
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.gridDimZ' in found_struct}}
    gridDimZ : unsigned int
        Depth of grid in blocks
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.blockDimX' in found_struct}}
    blockDimX : unsigned int
        X dimension of each thread block
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.blockDimY' in found_struct}}
    blockDimY : unsigned int
        Y dimension of each thread block
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.blockDimZ' in found_struct}}
    blockDimZ : unsigned int
        Z dimension of each thread block
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.sharedMemBytes' in found_struct}}
    sharedMemBytes : unsigned int
        Dynamic shared-memory size per thread block in bytes
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.kernelParams' in found_struct}}
    kernelParams : Any
        Array of pointers to kernel parameters
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.extra' in found_struct}}
    extra : Any
        Extra options
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.kern' in found_struct}}
    kern : CUkernel
        Kernel to launch, will only be referenced if func is NULL
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.ctx' in found_struct}}
    ctx : CUcontext
        Context for the kernel task to run in. The value NULL will indicate
        the current context should be used by the api. This field is
        ignored if func is set.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_KERNEL_NODE_PARAMS_v3_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.func' in found_struct}}
        self._func = CUfunction(_ptr=<void_ptr>&self._pvt_ptr[0].func)
        {{endif}}
        {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.kern' in found_struct}}
        self._kern = CUkernel(_ptr=<void_ptr>&self._pvt_ptr[0].kern)
        {{endif}}
        {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.ctx' in found_struct}}
        self._ctx = CUcontext(_ptr=<void_ptr>&self._pvt_ptr[0].ctx)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.func' in found_struct}}
            try:
                str_list += ['func : ' + str(self.func)]
            except ValueError:
                str_list += ['func : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.gridDimX' in found_struct}}
            try:
                str_list += ['gridDimX : ' + str(self.gridDimX)]
            except ValueError:
                str_list += ['gridDimX : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.gridDimY' in found_struct}}
            try:
                str_list += ['gridDimY : ' + str(self.gridDimY)]
            except ValueError:
                str_list += ['gridDimY : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.gridDimZ' in found_struct}}
            try:
                str_list += ['gridDimZ : ' + str(self.gridDimZ)]
            except ValueError:
                str_list += ['gridDimZ : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.blockDimX' in found_struct}}
            try:
                str_list += ['blockDimX : ' + str(self.blockDimX)]
            except ValueError:
                str_list += ['blockDimX : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.blockDimY' in found_struct}}
            try:
                str_list += ['blockDimY : ' + str(self.blockDimY)]
            except ValueError:
                str_list += ['blockDimY : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.blockDimZ' in found_struct}}
            try:
                str_list += ['blockDimZ : ' + str(self.blockDimZ)]
            except ValueError:
                str_list += ['blockDimZ : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.sharedMemBytes' in found_struct}}
            try:
                str_list += ['sharedMemBytes : ' + str(self.sharedMemBytes)]
            except ValueError:
                str_list += ['sharedMemBytes : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.kernelParams' in found_struct}}
            try:
                str_list += ['kernelParams : ' + str(self.kernelParams)]
            except ValueError:
                str_list += ['kernelParams : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.extra' in found_struct}}
            try:
                str_list += ['extra : ' + str(self.extra)]
            except ValueError:
                str_list += ['extra : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.kern' in found_struct}}
            try:
                str_list += ['kern : ' + str(self.kern)]
            except ValueError:
                str_list += ['kern : <ValueError>']
            {{endif}}
            {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.ctx' in found_struct}}
            try:
                str_list += ['ctx : ' + str(self.ctx)]
            except ValueError:
                str_list += ['ctx : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.func' in found_struct}}
    @property
    def func(self):
        return self._func
    @func.setter
    def func(self, func):
        cdef cydriver.CUfunction cyfunc
        if func is None:
            cyfunc = <cydriver.CUfunction><void_ptr>0
        elif isinstance(func, (CUfunction,)):
            pfunc = int(func)
            cyfunc = <cydriver.CUfunction><void_ptr>pfunc
        else:
            pfunc = int(CUfunction(func))
            cyfunc = <cydriver.CUfunction><void_ptr>pfunc
        self._func._pvt_ptr[0] = cyfunc
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.gridDimX' in found_struct}}
    @property
    def gridDimX(self):
        return self._pvt_ptr[0].gridDimX
    @gridDimX.setter
    def gridDimX(self, unsigned int gridDimX):
        self._pvt_ptr[0].gridDimX = gridDimX
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.gridDimY' in found_struct}}
    @property
    def gridDimY(self):
        return self._pvt_ptr[0].gridDimY
    @gridDimY.setter
    def gridDimY(self, unsigned int gridDimY):
        self._pvt_ptr[0].gridDimY = gridDimY
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.gridDimZ' in found_struct}}
    @property
    def gridDimZ(self):
        return self._pvt_ptr[0].gridDimZ
    @gridDimZ.setter
    def gridDimZ(self, unsigned int gridDimZ):
        self._pvt_ptr[0].gridDimZ = gridDimZ
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.blockDimX' in found_struct}}
    @property
    def blockDimX(self):
        return self._pvt_ptr[0].blockDimX
    @blockDimX.setter
    def blockDimX(self, unsigned int blockDimX):
        self._pvt_ptr[0].blockDimX = blockDimX
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.blockDimY' in found_struct}}
    @property
    def blockDimY(self):
        return self._pvt_ptr[0].blockDimY
    @blockDimY.setter
    def blockDimY(self, unsigned int blockDimY):
        self._pvt_ptr[0].blockDimY = blockDimY
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.blockDimZ' in found_struct}}
    @property
    def blockDimZ(self):
        return self._pvt_ptr[0].blockDimZ
    @blockDimZ.setter
    def blockDimZ(self, unsigned int blockDimZ):
        self._pvt_ptr[0].blockDimZ = blockDimZ
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.sharedMemBytes' in found_struct}}
    @property
    def sharedMemBytes(self):
        return self._pvt_ptr[0].sharedMemBytes
    @sharedMemBytes.setter
    def sharedMemBytes(self, unsigned int sharedMemBytes):
        self._pvt_ptr[0].sharedMemBytes = sharedMemBytes
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.kernelParams' in found_struct}}
    @property
    def kernelParams(self):
        return <void_ptr>self._pvt_ptr[0].kernelParams
    @kernelParams.setter
    def kernelParams(self, kernelParams):
        self._cykernelParams = _HelperKernelParams(kernelParams)
        self._pvt_ptr[0].kernelParams = <void**><void_ptr>self._cykernelParams.ckernelParams
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.extra' in found_struct}}
    @property
    def extra(self):
        return <void_ptr>self._pvt_ptr[0].extra
    @extra.setter
    def extra(self, void_ptr extra):
        self._pvt_ptr[0].extra = <void**>extra
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.kern' in found_struct}}
    @property
    def kern(self):
        return self._kern
    @kern.setter
    def kern(self, kern):
        cdef cydriver.CUkernel cykern
        if kern is None:
            cykern = <cydriver.CUkernel><void_ptr>0
        elif isinstance(kern, (CUkernel,)):
            pkern = int(kern)
            cykern = <cydriver.CUkernel><void_ptr>pkern
        else:
            pkern = int(CUkernel(kern))
            cykern = <cydriver.CUkernel><void_ptr>pkern
        self._kern._pvt_ptr[0] = cykern
    {{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st.ctx' in found_struct}}
    @property
    def ctx(self):
        return self._ctx
    @ctx.setter
    def ctx(self, ctx):
        cdef cydriver.CUcontext cyctx
        if ctx is None:
            cyctx = <cydriver.CUcontext><void_ptr>0
        elif isinstance(ctx, (CUcontext,)):
            pctx = int(ctx)
            cyctx = <cydriver.CUcontext><void_ptr>pctx
        else:
            pctx = int(CUcontext(ctx))
            cyctx = <cydriver.CUcontext><void_ptr>pctx
        self._ctx._pvt_ptr[0] = cyctx
    {{endif}}
{{endif}}
{{if 'CUDA_MEMSET_NODE_PARAMS_st' in found_struct}}

cdef class CUDA_MEMSET_NODE_PARAMS_st:
    """
    Memset node parameters

    Attributes
    ----------
    {{if 'CUDA_MEMSET_NODE_PARAMS_st.dst' in found_struct}}
    dst : CUdeviceptr
        Destination device pointer
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_st.pitch' in found_struct}}
    pitch : size_t
        Pitch of destination device pointer. Unused if height is 1
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_st.value' in found_struct}}
    value : unsigned int
        Value to be set
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_st.elementSize' in found_struct}}
    elementSize : unsigned int
        Size of each element in bytes. Must be 1, 2, or 4.
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_st.width' in found_struct}}
    width : size_t
        Width of the row in elements
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_st.height' in found_struct}}
    height : size_t
        Number of rows
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_MEMSET_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_MEMSET_NODE_PARAMS_st.dst' in found_struct}}
        self._dst = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].dst)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_MEMSET_NODE_PARAMS_st.dst' in found_struct}}
            try:
                str_list += ['dst : ' + str(self.dst)]
            except ValueError:
                str_list += ['dst : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMSET_NODE_PARAMS_st.pitch' in found_struct}}
            try:
                str_list += ['pitch : ' + str(self.pitch)]
            except ValueError:
                str_list += ['pitch : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMSET_NODE_PARAMS_st.value' in found_struct}}
            try:
                str_list += ['value : ' + str(self.value)]
            except ValueError:
                str_list += ['value : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMSET_NODE_PARAMS_st.elementSize' in found_struct}}
            try:
                str_list += ['elementSize : ' + str(self.elementSize)]
            except ValueError:
                str_list += ['elementSize : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMSET_NODE_PARAMS_st.width' in found_struct}}
            try:
                str_list += ['width : ' + str(self.width)]
            except ValueError:
                str_list += ['width : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMSET_NODE_PARAMS_st.height' in found_struct}}
            try:
                str_list += ['height : ' + str(self.height)]
            except ValueError:
                str_list += ['height : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_MEMSET_NODE_PARAMS_st.dst' in found_struct}}
    @property
    def dst(self):
        return self._dst
    @dst.setter
    def dst(self, dst):
        cdef cydriver.CUdeviceptr cydst
        if dst is None:
            cydst = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(dst, (CUdeviceptr)):
            pdst = int(dst)
            cydst = <cydriver.CUdeviceptr><void_ptr>pdst
        else:
            pdst = int(CUdeviceptr(dst))
            cydst = <cydriver.CUdeviceptr><void_ptr>pdst
        self._dst._pvt_ptr[0] = cydst

    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_st.pitch' in found_struct}}
    @property
    def pitch(self):
        return self._pvt_ptr[0].pitch
    @pitch.setter
    def pitch(self, size_t pitch):
        self._pvt_ptr[0].pitch = pitch
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_st.value' in found_struct}}
    @property
    def value(self):
        return self._pvt_ptr[0].value
    @value.setter
    def value(self, unsigned int value):
        self._pvt_ptr[0].value = value
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_st.elementSize' in found_struct}}
    @property
    def elementSize(self):
        return self._pvt_ptr[0].elementSize
    @elementSize.setter
    def elementSize(self, unsigned int elementSize):
        self._pvt_ptr[0].elementSize = elementSize
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_st.width' in found_struct}}
    @property
    def width(self):
        return self._pvt_ptr[0].width
    @width.setter
    def width(self, size_t width):
        self._pvt_ptr[0].width = width
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_st.height' in found_struct}}
    @property
    def height(self):
        return self._pvt_ptr[0].height
    @height.setter
    def height(self, size_t height):
        self._pvt_ptr[0].height = height
    {{endif}}
{{endif}}
{{if 'CUDA_MEMSET_NODE_PARAMS_v2_st' in found_struct}}

cdef class CUDA_MEMSET_NODE_PARAMS_v2_st:
    """
    Memset node parameters

    Attributes
    ----------
    {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.dst' in found_struct}}
    dst : CUdeviceptr
        Destination device pointer
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.pitch' in found_struct}}
    pitch : size_t
        Pitch of destination device pointer. Unused if height is 1
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.value' in found_struct}}
    value : unsigned int
        Value to be set
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.elementSize' in found_struct}}
    elementSize : unsigned int
        Size of each element in bytes. Must be 1, 2, or 4.
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.width' in found_struct}}
    width : size_t
        Width of the row in elements
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.height' in found_struct}}
    height : size_t
        Number of rows
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.ctx' in found_struct}}
    ctx : CUcontext
        Context on which to run the node
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_MEMSET_NODE_PARAMS_v2_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.dst' in found_struct}}
        self._dst = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].dst)
        {{endif}}
        {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.ctx' in found_struct}}
        self._ctx = CUcontext(_ptr=<void_ptr>&self._pvt_ptr[0].ctx)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.dst' in found_struct}}
            try:
                str_list += ['dst : ' + str(self.dst)]
            except ValueError:
                str_list += ['dst : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.pitch' in found_struct}}
            try:
                str_list += ['pitch : ' + str(self.pitch)]
            except ValueError:
                str_list += ['pitch : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.value' in found_struct}}
            try:
                str_list += ['value : ' + str(self.value)]
            except ValueError:
                str_list += ['value : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.elementSize' in found_struct}}
            try:
                str_list += ['elementSize : ' + str(self.elementSize)]
            except ValueError:
                str_list += ['elementSize : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.width' in found_struct}}
            try:
                str_list += ['width : ' + str(self.width)]
            except ValueError:
                str_list += ['width : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.height' in found_struct}}
            try:
                str_list += ['height : ' + str(self.height)]
            except ValueError:
                str_list += ['height : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.ctx' in found_struct}}
            try:
                str_list += ['ctx : ' + str(self.ctx)]
            except ValueError:
                str_list += ['ctx : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.dst' in found_struct}}
    @property
    def dst(self):
        return self._dst
    @dst.setter
    def dst(self, dst):
        cdef cydriver.CUdeviceptr cydst
        if dst is None:
            cydst = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(dst, (CUdeviceptr)):
            pdst = int(dst)
            cydst = <cydriver.CUdeviceptr><void_ptr>pdst
        else:
            pdst = int(CUdeviceptr(dst))
            cydst = <cydriver.CUdeviceptr><void_ptr>pdst
        self._dst._pvt_ptr[0] = cydst

    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.pitch' in found_struct}}
    @property
    def pitch(self):
        return self._pvt_ptr[0].pitch
    @pitch.setter
    def pitch(self, size_t pitch):
        self._pvt_ptr[0].pitch = pitch
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.value' in found_struct}}
    @property
    def value(self):
        return self._pvt_ptr[0].value
    @value.setter
    def value(self, unsigned int value):
        self._pvt_ptr[0].value = value
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.elementSize' in found_struct}}
    @property
    def elementSize(self):
        return self._pvt_ptr[0].elementSize
    @elementSize.setter
    def elementSize(self, unsigned int elementSize):
        self._pvt_ptr[0].elementSize = elementSize
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.width' in found_struct}}
    @property
    def width(self):
        return self._pvt_ptr[0].width
    @width.setter
    def width(self, size_t width):
        self._pvt_ptr[0].width = width
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.height' in found_struct}}
    @property
    def height(self):
        return self._pvt_ptr[0].height
    @height.setter
    def height(self, size_t height):
        self._pvt_ptr[0].height = height
    {{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st.ctx' in found_struct}}
    @property
    def ctx(self):
        return self._ctx
    @ctx.setter
    def ctx(self, ctx):
        cdef cydriver.CUcontext cyctx
        if ctx is None:
            cyctx = <cydriver.CUcontext><void_ptr>0
        elif isinstance(ctx, (CUcontext,)):
            pctx = int(ctx)
            cyctx = <cydriver.CUcontext><void_ptr>pctx
        else:
            pctx = int(CUcontext(ctx))
            cyctx = <cydriver.CUcontext><void_ptr>pctx
        self._ctx._pvt_ptr[0] = cyctx
    {{endif}}
{{endif}}
{{if 'CUDA_HOST_NODE_PARAMS_st' in found_struct}}

cdef class CUDA_HOST_NODE_PARAMS_st:
    """
    Host node parameters

    Attributes
    ----------
    {{if 'CUDA_HOST_NODE_PARAMS_st.fn' in found_struct}}
    fn : CUhostFn
        The function to call when the node executes
    {{endif}}
    {{if 'CUDA_HOST_NODE_PARAMS_st.userData' in found_struct}}
    userData : Any
        Argument to pass to the function
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_HOST_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_HOST_NODE_PARAMS_st.fn' in found_struct}}
        self._fn = CUhostFn(_ptr=<void_ptr>&self._pvt_ptr[0].fn)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_HOST_NODE_PARAMS_st.fn' in found_struct}}
            try:
                str_list += ['fn : ' + str(self.fn)]
            except ValueError:
                str_list += ['fn : <ValueError>']
            {{endif}}
            {{if 'CUDA_HOST_NODE_PARAMS_st.userData' in found_struct}}
            try:
                str_list += ['userData : ' + hex(self.userData)]
            except ValueError:
                str_list += ['userData : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_HOST_NODE_PARAMS_st.fn' in found_struct}}
    @property
    def fn(self):
        return self._fn
    @fn.setter
    def fn(self, fn):
        cdef cydriver.CUhostFn cyfn
        if fn is None:
            cyfn = <cydriver.CUhostFn><void_ptr>0
        elif isinstance(fn, (CUhostFn)):
            pfn = int(fn)
            cyfn = <cydriver.CUhostFn><void_ptr>pfn
        else:
            pfn = int(CUhostFn(fn))
            cyfn = <cydriver.CUhostFn><void_ptr>pfn
        self._fn._pvt_ptr[0] = cyfn
    {{endif}}
    {{if 'CUDA_HOST_NODE_PARAMS_st.userData' in found_struct}}
    @property
    def userData(self):
        return <void_ptr>self._pvt_ptr[0].userData
    @userData.setter
    def userData(self, userData):
        _cuserData = _HelperInputVoidPtr(userData)
        self._pvt_ptr[0].userData = <void*><void_ptr>_cuserData.cptr
    {{endif}}
{{endif}}
{{if 'CUDA_HOST_NODE_PARAMS_v2_st' in found_struct}}

cdef class CUDA_HOST_NODE_PARAMS_v2_st:
    """
    Host node parameters

    Attributes
    ----------
    {{if 'CUDA_HOST_NODE_PARAMS_v2_st.fn' in found_struct}}
    fn : CUhostFn
        The function to call when the node executes
    {{endif}}
    {{if 'CUDA_HOST_NODE_PARAMS_v2_st.userData' in found_struct}}
    userData : Any
        Argument to pass to the function
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_HOST_NODE_PARAMS_v2_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_HOST_NODE_PARAMS_v2_st.fn' in found_struct}}
        self._fn = CUhostFn(_ptr=<void_ptr>&self._pvt_ptr[0].fn)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_HOST_NODE_PARAMS_v2_st.fn' in found_struct}}
            try:
                str_list += ['fn : ' + str(self.fn)]
            except ValueError:
                str_list += ['fn : <ValueError>']
            {{endif}}
            {{if 'CUDA_HOST_NODE_PARAMS_v2_st.userData' in found_struct}}
            try:
                str_list += ['userData : ' + hex(self.userData)]
            except ValueError:
                str_list += ['userData : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_HOST_NODE_PARAMS_v2_st.fn' in found_struct}}
    @property
    def fn(self):
        return self._fn
    @fn.setter
    def fn(self, fn):
        cdef cydriver.CUhostFn cyfn
        if fn is None:
            cyfn = <cydriver.CUhostFn><void_ptr>0
        elif isinstance(fn, (CUhostFn)):
            pfn = int(fn)
            cyfn = <cydriver.CUhostFn><void_ptr>pfn
        else:
            pfn = int(CUhostFn(fn))
            cyfn = <cydriver.CUhostFn><void_ptr>pfn
        self._fn._pvt_ptr[0] = cyfn
    {{endif}}
    {{if 'CUDA_HOST_NODE_PARAMS_v2_st.userData' in found_struct}}
    @property
    def userData(self):
        return <void_ptr>self._pvt_ptr[0].userData
    @userData.setter
    def userData(self, userData):
        _cuserData = _HelperInputVoidPtr(userData)
        self._pvt_ptr[0].userData = <void*><void_ptr>_cuserData.cptr
    {{endif}}
{{endif}}
{{if 'CUDA_CONDITIONAL_NODE_PARAMS' in found_struct}}

cdef class CUDA_CONDITIONAL_NODE_PARAMS:
    """
    Conditional node parameters

    Attributes
    ----------
    {{if 'CUDA_CONDITIONAL_NODE_PARAMS.handle' in found_struct}}
    handle : CUgraphConditionalHandle
        Conditional node handle. Handles must be created in advance of
        creating the node using cuGraphConditionalHandleCreate.
    {{endif}}
    {{if 'CUDA_CONDITIONAL_NODE_PARAMS.type' in found_struct}}
    type : CUgraphConditionalNodeType
        Type of conditional node.
    {{endif}}
    {{if 'CUDA_CONDITIONAL_NODE_PARAMS.size' in found_struct}}
    size : unsigned int
        Size of graph output array. Allowed values are 1 for
        CU_GRAPH_COND_TYPE_WHILE, 1 or 2 for CU_GRAPH_COND_TYPE_IF, or any
        value greater than zero for CU_GRAPH_COND_TYPE_SWITCH.
    {{endif}}
    {{if 'CUDA_CONDITIONAL_NODE_PARAMS.phGraph_out' in found_struct}}
    phGraph_out : CUgraph
        CUDA-owned array populated with conditional node child graphs
        during creation of the node. Valid for the lifetime of the
        conditional node. The contents of the graph(s) are subject to the
        following constraints:   - Allowed node types are kernel nodes,
        empty nodes, child graphs, memsets, memcopies, and conditionals.
        This applies recursively to child graphs and conditional bodies.
        - All kernels, including kernels in nested conditionals or child
        graphs at any level, must belong to the same CUDA context.
        These graphs may be populated using graph node creation APIs or
        cuStreamBeginCaptureToGraph.  CU_GRAPH_COND_TYPE_IF: phGraph_out[0]
        is executed when the condition is non-zero. If `size` == 2,
        phGraph_out[1] will be executed when the condition is zero.
        CU_GRAPH_COND_TYPE_WHILE: phGraph_out[0] is executed as long as the
        condition is non-zero. CU_GRAPH_COND_TYPE_SWITCH: phGraph_out[n] is
        executed when the condition is equal to n. If the condition >=
        `size`, no body graph is executed.
    {{endif}}
    {{if 'CUDA_CONDITIONAL_NODE_PARAMS.ctx' in found_struct}}
    ctx : CUcontext
        Context on which to run the node. Must match context used to create
        the handle and all body nodes.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_CONDITIONAL_NODE_PARAMS *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_CONDITIONAL_NODE_PARAMS.handle' in found_struct}}
        self._handle = CUgraphConditionalHandle(_ptr=<void_ptr>&self._pvt_ptr[0].handle)
        {{endif}}
        {{if 'CUDA_CONDITIONAL_NODE_PARAMS.ctx' in found_struct}}
        self._ctx = CUcontext(_ptr=<void_ptr>&self._pvt_ptr[0].ctx)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_CONDITIONAL_NODE_PARAMS.handle' in found_struct}}
            try:
                str_list += ['handle : ' + str(self.handle)]
            except ValueError:
                str_list += ['handle : <ValueError>']
            {{endif}}
            {{if 'CUDA_CONDITIONAL_NODE_PARAMS.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'CUDA_CONDITIONAL_NODE_PARAMS.size' in found_struct}}
            try:
                str_list += ['size : ' + str(self.size)]
            except ValueError:
                str_list += ['size : <ValueError>']
            {{endif}}
            {{if 'CUDA_CONDITIONAL_NODE_PARAMS.phGraph_out' in found_struct}}
            try:
                str_list += ['phGraph_out : ' + str(self.phGraph_out)]
            except ValueError:
                str_list += ['phGraph_out : <ValueError>']
            {{endif}}
            {{if 'CUDA_CONDITIONAL_NODE_PARAMS.ctx' in found_struct}}
            try:
                str_list += ['ctx : ' + str(self.ctx)]
            except ValueError:
                str_list += ['ctx : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_CONDITIONAL_NODE_PARAMS.handle' in found_struct}}
    @property
    def handle(self):
        return self._handle
    @handle.setter
    def handle(self, handle):
        cdef cydriver.CUgraphConditionalHandle cyhandle
        if handle is None:
            cyhandle = <cydriver.CUgraphConditionalHandle><void_ptr>0
        elif isinstance(handle, (CUgraphConditionalHandle)):
            phandle = int(handle)
            cyhandle = <cydriver.CUgraphConditionalHandle><void_ptr>phandle
        else:
            phandle = int(CUgraphConditionalHandle(handle))
            cyhandle = <cydriver.CUgraphConditionalHandle><void_ptr>phandle
        self._handle._pvt_ptr[0] = cyhandle

    {{endif}}
    {{if 'CUDA_CONDITIONAL_NODE_PARAMS.type' in found_struct}}
    @property
    def type(self):
        if self._pvt_ptr[0].type not in _dict_CUgraphConditionalNodeType:
            return None
        return _dict_CUgraphConditionalNodeType[self._pvt_ptr[0].type]
    @type.setter
    def type(self, type not None : CUgraphConditionalNodeType):
        self._pvt_ptr[0].type = type.value
    {{endif}}
    {{if 'CUDA_CONDITIONAL_NODE_PARAMS.size' in found_struct}}
    @property
    def size(self):
        return self._pvt_ptr[0].size
    @size.setter
    def size(self, unsigned int size):
        self._pvt_ptr[0].size = size
    {{endif}}
    {{if 'CUDA_CONDITIONAL_NODE_PARAMS.phGraph_out' in found_struct}}
    @property
    def phGraph_out(self):
        arrs = [<void_ptr>self._pvt_ptr[0].phGraph_out + x*sizeof(cydriver.CUgraph) for x in range(self.size)]
        return [CUgraph(_ptr=arr) for arr in arrs]
    {{endif}}
    {{if 'CUDA_CONDITIONAL_NODE_PARAMS.ctx' in found_struct}}
    @property
    def ctx(self):
        return self._ctx
    @ctx.setter
    def ctx(self, ctx):
        cdef cydriver.CUcontext cyctx
        if ctx is None:
            cyctx = <cydriver.CUcontext><void_ptr>0
        elif isinstance(ctx, (CUcontext,)):
            pctx = int(ctx)
            cyctx = <cydriver.CUcontext><void_ptr>pctx
        else:
            pctx = int(CUcontext(ctx))
            cyctx = <cydriver.CUcontext><void_ptr>pctx
        self._ctx._pvt_ptr[0] = cyctx
    {{endif}}
{{endif}}
{{if 'CUgraphEdgeData_st' in found_struct}}

cdef class CUgraphEdgeData_st:
    """
    Optional annotation for edges in a CUDA graph. Note, all edges
    implicitly have annotations and default to a zero-initialized value
    if not specified. A zero-initialized struct indicates a standard
    full serialization of two nodes with memory visibility.

    Attributes
    ----------
    {{if 'CUgraphEdgeData_st.from_port' in found_struct}}
    from_port : bytes
        This indicates when the dependency is triggered from the upstream
        node on the edge. The meaning is specfic to the node type. A value
        of 0 in all cases means full completion of the upstream node, with
        memory visibility to the downstream node or portion thereof
        (indicated by `to_port`).   Only kernel nodes define non-zero
        ports. A kernel node can use the following output port types:
        CU_GRAPH_KERNEL_NODE_PORT_DEFAULT,
        CU_GRAPH_KERNEL_NODE_PORT_PROGRAMMATIC, or
        CU_GRAPH_KERNEL_NODE_PORT_LAUNCH_ORDER.
    {{endif}}
    {{if 'CUgraphEdgeData_st.to_port' in found_struct}}
    to_port : bytes
        This indicates what portion of the downstream node is dependent on
        the upstream node or portion thereof (indicated by `from_port`).
        The meaning is specific to the node type. A value of 0 in all cases
        means the entirety of the downstream node is dependent on the
        upstream work.   Currently no node types define non-zero ports.
        Accordingly, this field must be set to zero.
    {{endif}}
    {{if 'CUgraphEdgeData_st.type' in found_struct}}
    type : bytes
        This should be populated with a value from CUgraphDependencyType.
        (It is typed as char due to compiler-specific layout of bitfields.)
        See CUgraphDependencyType.
    {{endif}}
    {{if 'CUgraphEdgeData_st.reserved' in found_struct}}
    reserved : bytes
        These bytes are unused and must be zeroed. This ensures
        compatibility if additional fields are added in the future.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUgraphEdgeData_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUgraphEdgeData_st.from_port' in found_struct}}
            try:
                str_list += ['from_port : ' + str(self.from_port)]
            except ValueError:
                str_list += ['from_port : <ValueError>']
            {{endif}}
            {{if 'CUgraphEdgeData_st.to_port' in found_struct}}
            try:
                str_list += ['to_port : ' + str(self.to_port)]
            except ValueError:
                str_list += ['to_port : <ValueError>']
            {{endif}}
            {{if 'CUgraphEdgeData_st.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'CUgraphEdgeData_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUgraphEdgeData_st.from_port' in found_struct}}
    @property
    def from_port(self):
        return self._pvt_ptr[0].from_port
    @from_port.setter
    def from_port(self, unsigned char from_port):
        self._pvt_ptr[0].from_port = from_port
    {{endif}}
    {{if 'CUgraphEdgeData_st.to_port' in found_struct}}
    @property
    def to_port(self):
        return self._pvt_ptr[0].to_port
    @to_port.setter
    def to_port(self, unsigned char to_port):
        self._pvt_ptr[0].to_port = to_port
    {{endif}}
    {{if 'CUgraphEdgeData_st.type' in found_struct}}
    @property
    def type(self):
        return self._pvt_ptr[0].type
    @type.setter
    def type(self, unsigned char type):
        self._pvt_ptr[0].type = type
    {{endif}}
    {{if 'CUgraphEdgeData_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(<char*>self._pvt_ptr[0].reserved, 5)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 5:
            raise ValueError("reserved length must be 5, is " + str(len(reserved)))
        for i, b in enumerate(reserved):
            self._pvt_ptr[0].reserved[i] = b
    {{endif}}
{{endif}}
{{if 'CUDA_GRAPH_INSTANTIATE_PARAMS_st' in found_struct}}

cdef class CUDA_GRAPH_INSTANTIATE_PARAMS_st:
    """
    Graph instantiation parameters

    Attributes
    ----------
    {{if 'CUDA_GRAPH_INSTANTIATE_PARAMS_st.flags' in found_struct}}
    flags : cuuint64_t
        Instantiation flags
    {{endif}}
    {{if 'CUDA_GRAPH_INSTANTIATE_PARAMS_st.hUploadStream' in found_struct}}
    hUploadStream : CUstream
        Upload stream
    {{endif}}
    {{if 'CUDA_GRAPH_INSTANTIATE_PARAMS_st.hErrNode_out' in found_struct}}
    hErrNode_out : CUgraphNode
        The node which caused instantiation to fail, if any
    {{endif}}
    {{if 'CUDA_GRAPH_INSTANTIATE_PARAMS_st.result_out' in found_struct}}
    result_out : CUgraphInstantiateResult
        Whether instantiation was successful. If it failed, the reason why
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_GRAPH_INSTANTIATE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_GRAPH_INSTANTIATE_PARAMS_st.flags' in found_struct}}
        self._flags = cuuint64_t(_ptr=<void_ptr>&self._pvt_ptr[0].flags)
        {{endif}}
        {{if 'CUDA_GRAPH_INSTANTIATE_PARAMS_st.hUploadStream' in found_struct}}
        self._hUploadStream = CUstream(_ptr=<void_ptr>&self._pvt_ptr[0].hUploadStream)
        {{endif}}
        {{if 'CUDA_GRAPH_INSTANTIATE_PARAMS_st.hErrNode_out' in found_struct}}
        self._hErrNode_out = CUgraphNode(_ptr=<void_ptr>&self._pvt_ptr[0].hErrNode_out)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_GRAPH_INSTANTIATE_PARAMS_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'CUDA_GRAPH_INSTANTIATE_PARAMS_st.hUploadStream' in found_struct}}
            try:
                str_list += ['hUploadStream : ' + str(self.hUploadStream)]
            except ValueError:
                str_list += ['hUploadStream : <ValueError>']
            {{endif}}
            {{if 'CUDA_GRAPH_INSTANTIATE_PARAMS_st.hErrNode_out' in found_struct}}
            try:
                str_list += ['hErrNode_out : ' + str(self.hErrNode_out)]
            except ValueError:
                str_list += ['hErrNode_out : <ValueError>']
            {{endif}}
            {{if 'CUDA_GRAPH_INSTANTIATE_PARAMS_st.result_out' in found_struct}}
            try:
                str_list += ['result_out : ' + str(self.result_out)]
            except ValueError:
                str_list += ['result_out : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_GRAPH_INSTANTIATE_PARAMS_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._flags
    @flags.setter
    def flags(self, flags):
        cdef cydriver.cuuint64_t cyflags
        if flags is None:
            cyflags = <cydriver.cuuint64_t><void_ptr>0
        elif isinstance(flags, (cuuint64_t)):
            pflags = int(flags)
            cyflags = <cydriver.cuuint64_t><void_ptr>pflags
        else:
            pflags = int(cuuint64_t(flags))
            cyflags = <cydriver.cuuint64_t><void_ptr>pflags
        self._flags._pvt_ptr[0] = cyflags

    {{endif}}
    {{if 'CUDA_GRAPH_INSTANTIATE_PARAMS_st.hUploadStream' in found_struct}}
    @property
    def hUploadStream(self):
        return self._hUploadStream
    @hUploadStream.setter
    def hUploadStream(self, hUploadStream):
        cdef cydriver.CUstream cyhUploadStream
        if hUploadStream is None:
            cyhUploadStream = <cydriver.CUstream><void_ptr>0
        elif isinstance(hUploadStream, (CUstream,)):
            phUploadStream = int(hUploadStream)
            cyhUploadStream = <cydriver.CUstream><void_ptr>phUploadStream
        else:
            phUploadStream = int(CUstream(hUploadStream))
            cyhUploadStream = <cydriver.CUstream><void_ptr>phUploadStream
        self._hUploadStream._pvt_ptr[0] = cyhUploadStream
    {{endif}}
    {{if 'CUDA_GRAPH_INSTANTIATE_PARAMS_st.hErrNode_out' in found_struct}}
    @property
    def hErrNode_out(self):
        return self._hErrNode_out
    @hErrNode_out.setter
    def hErrNode_out(self, hErrNode_out):
        cdef cydriver.CUgraphNode cyhErrNode_out
        if hErrNode_out is None:
            cyhErrNode_out = <cydriver.CUgraphNode><void_ptr>0
        elif isinstance(hErrNode_out, (CUgraphNode,)):
            phErrNode_out = int(hErrNode_out)
            cyhErrNode_out = <cydriver.CUgraphNode><void_ptr>phErrNode_out
        else:
            phErrNode_out = int(CUgraphNode(hErrNode_out))
            cyhErrNode_out = <cydriver.CUgraphNode><void_ptr>phErrNode_out
        self._hErrNode_out._pvt_ptr[0] = cyhErrNode_out
    {{endif}}
    {{if 'CUDA_GRAPH_INSTANTIATE_PARAMS_st.result_out' in found_struct}}
    @property
    def result_out(self):
        if self._pvt_ptr[0].result_out not in _dict_CUgraphInstantiateResult:
            return None
        return _dict_CUgraphInstantiateResult[self._pvt_ptr[0].result_out]
    @result_out.setter
    def result_out(self, result_out not None : CUgraphInstantiateResult):
        self._pvt_ptr[0].result_out = result_out.value
    {{endif}}
{{endif}}
{{if 'CUlaunchMemSyncDomainMap_st' in found_struct}}

cdef class CUlaunchMemSyncDomainMap_st:
    """
    Memory Synchronization Domain map  See ::cudaLaunchMemSyncDomain.
    By default, kernels are launched in domain 0. Kernel launched with
    CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE will have a different domain ID.
    User may also alter the domain ID with CUlaunchMemSyncDomainMap for
    a specific stream / graph node / kernel launch. See
    CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP.  Domain ID range is
    available through CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT.

    Attributes
    ----------
    {{if 'CUlaunchMemSyncDomainMap_st.default_' in found_struct}}
    default_ : bytes
        The default domain ID to use for designated kernels
    {{endif}}
    {{if 'CUlaunchMemSyncDomainMap_st.remote' in found_struct}}
    remote : bytes
        The remote domain ID to use for designated kernels
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUlaunchMemSyncDomainMap_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUlaunchMemSyncDomainMap_st.default_' in found_struct}}
            try:
                str_list += ['default_ : ' + str(self.default_)]
            except ValueError:
                str_list += ['default_ : <ValueError>']
            {{endif}}
            {{if 'CUlaunchMemSyncDomainMap_st.remote' in found_struct}}
            try:
                str_list += ['remote : ' + str(self.remote)]
            except ValueError:
                str_list += ['remote : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUlaunchMemSyncDomainMap_st.default_' in found_struct}}
    @property
    def default_(self):
        return self._pvt_ptr[0].default_
    @default_.setter
    def default_(self, unsigned char default_):
        self._pvt_ptr[0].default_ = default_
    {{endif}}
    {{if 'CUlaunchMemSyncDomainMap_st.remote' in found_struct}}
    @property
    def remote(self):
        return self._pvt_ptr[0].remote
    @remote.setter
    def remote(self, unsigned char remote):
        self._pvt_ptr[0].remote = remote
    {{endif}}
{{endif}}
{{if 'CUlaunchAttributeValue_union.clusterDim' in found_struct}}

cdef class anon_struct1:
    """
    Attributes
    ----------
    {{if 'CUlaunchAttributeValue_union.clusterDim.x' in found_struct}}
    x : unsigned int

    {{endif}}
    {{if 'CUlaunchAttributeValue_union.clusterDim.y' in found_struct}}
    y : unsigned int

    {{endif}}
    {{if 'CUlaunchAttributeValue_union.clusterDim.z' in found_struct}}
    z : unsigned int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUlaunchAttributeValue_union *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].clusterDim
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUlaunchAttributeValue_union.clusterDim.x' in found_struct}}
            try:
                str_list += ['x : ' + str(self.x)]
            except ValueError:
                str_list += ['x : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.clusterDim.y' in found_struct}}
            try:
                str_list += ['y : ' + str(self.y)]
            except ValueError:
                str_list += ['y : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.clusterDim.z' in found_struct}}
            try:
                str_list += ['z : ' + str(self.z)]
            except ValueError:
                str_list += ['z : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUlaunchAttributeValue_union.clusterDim.x' in found_struct}}
    @property
    def x(self):
        return self._pvt_ptr[0].clusterDim.x
    @x.setter
    def x(self, unsigned int x):
        self._pvt_ptr[0].clusterDim.x = x
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.clusterDim.y' in found_struct}}
    @property
    def y(self):
        return self._pvt_ptr[0].clusterDim.y
    @y.setter
    def y(self, unsigned int y):
        self._pvt_ptr[0].clusterDim.y = y
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.clusterDim.z' in found_struct}}
    @property
    def z(self):
        return self._pvt_ptr[0].clusterDim.z
    @z.setter
    def z(self, unsigned int z):
        self._pvt_ptr[0].clusterDim.z = z
    {{endif}}
{{endif}}
{{if 'CUlaunchAttributeValue_union.programmaticEvent' in found_struct}}

cdef class anon_struct2:
    """
    Attributes
    ----------
    {{if 'CUlaunchAttributeValue_union.programmaticEvent.event' in found_struct}}
    event : CUevent

    {{endif}}
    {{if 'CUlaunchAttributeValue_union.programmaticEvent.flags' in found_struct}}
    flags : int

    {{endif}}
    {{if 'CUlaunchAttributeValue_union.programmaticEvent.triggerAtBlockStart' in found_struct}}
    triggerAtBlockStart : int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUlaunchAttributeValue_union *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUlaunchAttributeValue_union.programmaticEvent.event' in found_struct}}
        self._event = CUevent(_ptr=<void_ptr>&self._pvt_ptr[0].programmaticEvent.event)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].programmaticEvent
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUlaunchAttributeValue_union.programmaticEvent.event' in found_struct}}
            try:
                str_list += ['event : ' + str(self.event)]
            except ValueError:
                str_list += ['event : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.programmaticEvent.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.programmaticEvent.triggerAtBlockStart' in found_struct}}
            try:
                str_list += ['triggerAtBlockStart : ' + str(self.triggerAtBlockStart)]
            except ValueError:
                str_list += ['triggerAtBlockStart : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUlaunchAttributeValue_union.programmaticEvent.event' in found_struct}}
    @property
    def event(self):
        return self._event
    @event.setter
    def event(self, event):
        cdef cydriver.CUevent cyevent
        if event is None:
            cyevent = <cydriver.CUevent><void_ptr>0
        elif isinstance(event, (CUevent,)):
            pevent = int(event)
            cyevent = <cydriver.CUevent><void_ptr>pevent
        else:
            pevent = int(CUevent(event))
            cyevent = <cydriver.CUevent><void_ptr>pevent
        self._event._pvt_ptr[0] = cyevent
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.programmaticEvent.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].programmaticEvent.flags
    @flags.setter
    def flags(self, int flags):
        self._pvt_ptr[0].programmaticEvent.flags = flags
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.programmaticEvent.triggerAtBlockStart' in found_struct}}
    @property
    def triggerAtBlockStart(self):
        return self._pvt_ptr[0].programmaticEvent.triggerAtBlockStart
    @triggerAtBlockStart.setter
    def triggerAtBlockStart(self, int triggerAtBlockStart):
        self._pvt_ptr[0].programmaticEvent.triggerAtBlockStart = triggerAtBlockStart
    {{endif}}
{{endif}}
{{if 'CUlaunchAttributeValue_union.launchCompletionEvent' in found_struct}}

cdef class anon_struct3:
    """
    Attributes
    ----------
    {{if 'CUlaunchAttributeValue_union.launchCompletionEvent.event' in found_struct}}
    event : CUevent

    {{endif}}
    {{if 'CUlaunchAttributeValue_union.launchCompletionEvent.flags' in found_struct}}
    flags : int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUlaunchAttributeValue_union *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUlaunchAttributeValue_union.launchCompletionEvent.event' in found_struct}}
        self._event = CUevent(_ptr=<void_ptr>&self._pvt_ptr[0].launchCompletionEvent.event)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].launchCompletionEvent
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUlaunchAttributeValue_union.launchCompletionEvent.event' in found_struct}}
            try:
                str_list += ['event : ' + str(self.event)]
            except ValueError:
                str_list += ['event : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.launchCompletionEvent.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUlaunchAttributeValue_union.launchCompletionEvent.event' in found_struct}}
    @property
    def event(self):
        return self._event
    @event.setter
    def event(self, event):
        cdef cydriver.CUevent cyevent
        if event is None:
            cyevent = <cydriver.CUevent><void_ptr>0
        elif isinstance(event, (CUevent,)):
            pevent = int(event)
            cyevent = <cydriver.CUevent><void_ptr>pevent
        else:
            pevent = int(CUevent(event))
            cyevent = <cydriver.CUevent><void_ptr>pevent
        self._event._pvt_ptr[0] = cyevent
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.launchCompletionEvent.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].launchCompletionEvent.flags
    @flags.setter
    def flags(self, int flags):
        self._pvt_ptr[0].launchCompletionEvent.flags = flags
    {{endif}}
{{endif}}
{{if 'CUlaunchAttributeValue_union.preferredClusterDim' in found_struct}}

cdef class anon_struct4:
    """
    Attributes
    ----------
    {{if 'CUlaunchAttributeValue_union.preferredClusterDim.x' in found_struct}}
    x : unsigned int

    {{endif}}
    {{if 'CUlaunchAttributeValue_union.preferredClusterDim.y' in found_struct}}
    y : unsigned int

    {{endif}}
    {{if 'CUlaunchAttributeValue_union.preferredClusterDim.z' in found_struct}}
    z : unsigned int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUlaunchAttributeValue_union *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].preferredClusterDim
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUlaunchAttributeValue_union.preferredClusterDim.x' in found_struct}}
            try:
                str_list += ['x : ' + str(self.x)]
            except ValueError:
                str_list += ['x : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.preferredClusterDim.y' in found_struct}}
            try:
                str_list += ['y : ' + str(self.y)]
            except ValueError:
                str_list += ['y : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.preferredClusterDim.z' in found_struct}}
            try:
                str_list += ['z : ' + str(self.z)]
            except ValueError:
                str_list += ['z : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUlaunchAttributeValue_union.preferredClusterDim.x' in found_struct}}
    @property
    def x(self):
        return self._pvt_ptr[0].preferredClusterDim.x
    @x.setter
    def x(self, unsigned int x):
        self._pvt_ptr[0].preferredClusterDim.x = x
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.preferredClusterDim.y' in found_struct}}
    @property
    def y(self):
        return self._pvt_ptr[0].preferredClusterDim.y
    @y.setter
    def y(self, unsigned int y):
        self._pvt_ptr[0].preferredClusterDim.y = y
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.preferredClusterDim.z' in found_struct}}
    @property
    def z(self):
        return self._pvt_ptr[0].preferredClusterDim.z
    @z.setter
    def z(self, unsigned int z):
        self._pvt_ptr[0].preferredClusterDim.z = z
    {{endif}}
{{endif}}
{{if 'CUlaunchAttributeValue_union.deviceUpdatableKernelNode' in found_struct}}

cdef class anon_struct5:
    """
    Attributes
    ----------
    {{if 'CUlaunchAttributeValue_union.deviceUpdatableKernelNode.deviceUpdatable' in found_struct}}
    deviceUpdatable : int

    {{endif}}
    {{if 'CUlaunchAttributeValue_union.deviceUpdatableKernelNode.devNode' in found_struct}}
    devNode : CUgraphDeviceNode

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUlaunchAttributeValue_union *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUlaunchAttributeValue_union.deviceUpdatableKernelNode.devNode' in found_struct}}
        self._devNode = CUgraphDeviceNode(_ptr=<void_ptr>&self._pvt_ptr[0].deviceUpdatableKernelNode.devNode)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].deviceUpdatableKernelNode
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUlaunchAttributeValue_union.deviceUpdatableKernelNode.deviceUpdatable' in found_struct}}
            try:
                str_list += ['deviceUpdatable : ' + str(self.deviceUpdatable)]
            except ValueError:
                str_list += ['deviceUpdatable : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.deviceUpdatableKernelNode.devNode' in found_struct}}
            try:
                str_list += ['devNode : ' + str(self.devNode)]
            except ValueError:
                str_list += ['devNode : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUlaunchAttributeValue_union.deviceUpdatableKernelNode.deviceUpdatable' in found_struct}}
    @property
    def deviceUpdatable(self):
        return self._pvt_ptr[0].deviceUpdatableKernelNode.deviceUpdatable
    @deviceUpdatable.setter
    def deviceUpdatable(self, int deviceUpdatable):
        self._pvt_ptr[0].deviceUpdatableKernelNode.deviceUpdatable = deviceUpdatable
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.deviceUpdatableKernelNode.devNode' in found_struct}}
    @property
    def devNode(self):
        return self._devNode
    @devNode.setter
    def devNode(self, devNode):
        cdef cydriver.CUgraphDeviceNode cydevNode
        if devNode is None:
            cydevNode = <cydriver.CUgraphDeviceNode><void_ptr>0
        elif isinstance(devNode, (CUgraphDeviceNode,)):
            pdevNode = int(devNode)
            cydevNode = <cydriver.CUgraphDeviceNode><void_ptr>pdevNode
        else:
            pdevNode = int(CUgraphDeviceNode(devNode))
            cydevNode = <cydriver.CUgraphDeviceNode><void_ptr>pdevNode
        self._devNode._pvt_ptr[0] = cydevNode
    {{endif}}
{{endif}}
{{if 'CUlaunchAttributeValue_union' in found_struct}}

cdef class CUlaunchAttributeValue_union:
    """
    Launch attributes union; used as value field of CUlaunchAttribute

    Attributes
    ----------
    {{if 'CUlaunchAttributeValue_union.pad' in found_struct}}
    pad : bytes

    {{endif}}
    {{if 'CUlaunchAttributeValue_union.accessPolicyWindow' in found_struct}}
    accessPolicyWindow : CUaccessPolicyWindow
        Value of launch attribute CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW.
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.cooperative' in found_struct}}
    cooperative : int
        Value of launch attribute CU_LAUNCH_ATTRIBUTE_COOPERATIVE. Nonzero
        indicates a cooperative kernel (see cuLaunchCooperativeKernel).
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.syncPolicy' in found_struct}}
    syncPolicy : CUsynchronizationPolicy
        Value of launch attribute
        CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY.
        ::CUsynchronizationPolicy for work queued up in this stream
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.clusterDim' in found_struct}}
    clusterDim : anon_struct1
        Value of launch attribute CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION
        that represents the desired cluster dimensions for the kernel.
        Opaque type with the following fields: - `x` - The X dimension of
        the cluster, in blocks. Must be a divisor of the grid X dimension.
        - `y` - The Y dimension of the cluster, in blocks. Must be a
        divisor of the grid Y dimension.    - `z` - The Z dimension of the
        cluster, in blocks. Must be a divisor of the grid Z dimension.
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.clusterSchedulingPolicyPreference' in found_struct}}
    clusterSchedulingPolicyPreference : CUclusterSchedulingPolicy
        Value of launch attribute
        CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE. Cluster
        scheduling policy preference for the kernel.
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.programmaticStreamSerializationAllowed' in found_struct}}
    programmaticStreamSerializationAllowed : int
        Value of launch attribute
        CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION.
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.programmaticEvent' in found_struct}}
    programmaticEvent : anon_struct2
        Value of launch attribute CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT
        with the following fields: - `CUevent` event - Event to fire when
        all blocks trigger it.    - `Event` record flags, see
        cuEventRecordWithFlags. Does not accept :CU_EVENT_RECORD_EXTERNAL.
        - `triggerAtBlockStart` - If this is set to non-0, each block
        launch will automatically trigger the event.
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.launchCompletionEvent' in found_struct}}
    launchCompletionEvent : anon_struct3
        Value of launch attribute
        CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT with the following
        fields: - `CUevent` event - Event to fire when the last block
        launches    - `int` flags; - Event record flags, see
        cuEventRecordWithFlags. Does not accept CU_EVENT_RECORD_EXTERNAL.
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.priority' in found_struct}}
    priority : int
        Value of launch attribute CU_LAUNCH_ATTRIBUTE_PRIORITY. Execution
        priority of the kernel.
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.memSyncDomainMap' in found_struct}}
    memSyncDomainMap : CUlaunchMemSyncDomainMap
        Value of launch attribute CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP.
        See CUlaunchMemSyncDomainMap.
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.memSyncDomain' in found_struct}}
    memSyncDomain : CUlaunchMemSyncDomain
        Value of launch attribute CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN.
        See::CUlaunchMemSyncDomain
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.preferredClusterDim' in found_struct}}
    preferredClusterDim : anon_struct4
        Value of launch attribute
        CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION that represents the
        desired preferred cluster dimensions for the kernel. Opaque type
        with the following fields: - `x` - The X dimension of the preferred
        cluster, in blocks. Must be a divisor of the grid X dimension, and
        must be a multiple of the `x` field of
        CUlaunchAttributeValue::clusterDim.    - `y` - The Y dimension of
        the preferred cluster, in blocks. Must be a divisor of the grid Y
        dimension, and must be a multiple of the `y` field of
        CUlaunchAttributeValue::clusterDim.    - `z` - The Z dimension of
        the preferred cluster, in blocks. Must be equal to the `z` field of
        CUlaunchAttributeValue::clusterDim.
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.deviceUpdatableKernelNode' in found_struct}}
    deviceUpdatableKernelNode : anon_struct5
        Value of launch attribute
        CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE. with the
        following fields: - `int` deviceUpdatable - Whether or not the
        resulting kernel node should be device-updatable.    -
        `CUgraphDeviceNode` devNode - Returns a handle to pass to the
        various device-side update functions.
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.sharedMemCarveout' in found_struct}}
    sharedMemCarveout : unsigned int
        Value of launch attribute
        CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT.
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.nvlinkUtilCentricScheduling' in found_struct}}
    nvlinkUtilCentricScheduling : unsigned int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUlaunchAttributeValue_union *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUlaunchAttributeValue_union.accessPolicyWindow' in found_struct}}
        self._accessPolicyWindow = CUaccessPolicyWindow(_ptr=<void_ptr>&self._pvt_ptr[0].accessPolicyWindow)
        {{endif}}
        {{if 'CUlaunchAttributeValue_union.clusterDim' in found_struct}}
        self._clusterDim = anon_struct1(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUlaunchAttributeValue_union.programmaticEvent' in found_struct}}
        self._programmaticEvent = anon_struct2(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUlaunchAttributeValue_union.launchCompletionEvent' in found_struct}}
        self._launchCompletionEvent = anon_struct3(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUlaunchAttributeValue_union.memSyncDomainMap' in found_struct}}
        self._memSyncDomainMap = CUlaunchMemSyncDomainMap(_ptr=<void_ptr>&self._pvt_ptr[0].memSyncDomainMap)
        {{endif}}
        {{if 'CUlaunchAttributeValue_union.preferredClusterDim' in found_struct}}
        self._preferredClusterDim = anon_struct4(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUlaunchAttributeValue_union.deviceUpdatableKernelNode' in found_struct}}
        self._deviceUpdatableKernelNode = anon_struct5(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUlaunchAttributeValue_union.pad' in found_struct}}
            try:
                str_list += ['pad : ' + str(self.pad)]
            except ValueError:
                str_list += ['pad : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.accessPolicyWindow' in found_struct}}
            try:
                str_list += ['accessPolicyWindow :\n' + '\n'.join(['    ' + line for line in str(self.accessPolicyWindow).splitlines()])]
            except ValueError:
                str_list += ['accessPolicyWindow : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.cooperative' in found_struct}}
            try:
                str_list += ['cooperative : ' + str(self.cooperative)]
            except ValueError:
                str_list += ['cooperative : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.syncPolicy' in found_struct}}
            try:
                str_list += ['syncPolicy : ' + str(self.syncPolicy)]
            except ValueError:
                str_list += ['syncPolicy : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.clusterDim' in found_struct}}
            try:
                str_list += ['clusterDim :\n' + '\n'.join(['    ' + line for line in str(self.clusterDim).splitlines()])]
            except ValueError:
                str_list += ['clusterDim : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.clusterSchedulingPolicyPreference' in found_struct}}
            try:
                str_list += ['clusterSchedulingPolicyPreference : ' + str(self.clusterSchedulingPolicyPreference)]
            except ValueError:
                str_list += ['clusterSchedulingPolicyPreference : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.programmaticStreamSerializationAllowed' in found_struct}}
            try:
                str_list += ['programmaticStreamSerializationAllowed : ' + str(self.programmaticStreamSerializationAllowed)]
            except ValueError:
                str_list += ['programmaticStreamSerializationAllowed : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.programmaticEvent' in found_struct}}
            try:
                str_list += ['programmaticEvent :\n' + '\n'.join(['    ' + line for line in str(self.programmaticEvent).splitlines()])]
            except ValueError:
                str_list += ['programmaticEvent : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.launchCompletionEvent' in found_struct}}
            try:
                str_list += ['launchCompletionEvent :\n' + '\n'.join(['    ' + line for line in str(self.launchCompletionEvent).splitlines()])]
            except ValueError:
                str_list += ['launchCompletionEvent : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.priority' in found_struct}}
            try:
                str_list += ['priority : ' + str(self.priority)]
            except ValueError:
                str_list += ['priority : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.memSyncDomainMap' in found_struct}}
            try:
                str_list += ['memSyncDomainMap :\n' + '\n'.join(['    ' + line for line in str(self.memSyncDomainMap).splitlines()])]
            except ValueError:
                str_list += ['memSyncDomainMap : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.memSyncDomain' in found_struct}}
            try:
                str_list += ['memSyncDomain : ' + str(self.memSyncDomain)]
            except ValueError:
                str_list += ['memSyncDomain : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.preferredClusterDim' in found_struct}}
            try:
                str_list += ['preferredClusterDim :\n' + '\n'.join(['    ' + line for line in str(self.preferredClusterDim).splitlines()])]
            except ValueError:
                str_list += ['preferredClusterDim : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.deviceUpdatableKernelNode' in found_struct}}
            try:
                str_list += ['deviceUpdatableKernelNode :\n' + '\n'.join(['    ' + line for line in str(self.deviceUpdatableKernelNode).splitlines()])]
            except ValueError:
                str_list += ['deviceUpdatableKernelNode : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.sharedMemCarveout' in found_struct}}
            try:
                str_list += ['sharedMemCarveout : ' + str(self.sharedMemCarveout)]
            except ValueError:
                str_list += ['sharedMemCarveout : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttributeValue_union.nvlinkUtilCentricScheduling' in found_struct}}
            try:
                str_list += ['nvlinkUtilCentricScheduling : ' + str(self.nvlinkUtilCentricScheduling)]
            except ValueError:
                str_list += ['nvlinkUtilCentricScheduling : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUlaunchAttributeValue_union.pad' in found_struct}}
    @property
    def pad(self):
        return PyBytes_FromStringAndSize(self._pvt_ptr[0].pad, 64)
    @pad.setter
    def pad(self, pad):
        if len(pad) != 64:
            raise ValueError("pad length must be 64, is " + str(len(pad)))
        if CHAR_MIN == 0:
            for i, b in enumerate(pad):
                if b < 0 and b > -129:
                    b = b + 256
                self._pvt_ptr[0].pad[i] = b
        else:
            for i, b in enumerate(pad):
                if b > 127 and b < 256:
                    b = b - 256
                self._pvt_ptr[0].pad[i] = b
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.accessPolicyWindow' in found_struct}}
    @property
    def accessPolicyWindow(self):
        return self._accessPolicyWindow
    @accessPolicyWindow.setter
    def accessPolicyWindow(self, accessPolicyWindow not None : CUaccessPolicyWindow):
        string.memcpy(&self._pvt_ptr[0].accessPolicyWindow, <cydriver.CUaccessPolicyWindow*><void_ptr>accessPolicyWindow.getPtr(), sizeof(self._pvt_ptr[0].accessPolicyWindow))
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.cooperative' in found_struct}}
    @property
    def cooperative(self):
        return self._pvt_ptr[0].cooperative
    @cooperative.setter
    def cooperative(self, int cooperative):
        self._pvt_ptr[0].cooperative = cooperative
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.syncPolicy' in found_struct}}
    @property
    def syncPolicy(self):
        if self._pvt_ptr[0].syncPolicy not in _dict_CUsynchronizationPolicy:
            return None
        return _dict_CUsynchronizationPolicy[self._pvt_ptr[0].syncPolicy]
    @syncPolicy.setter
    def syncPolicy(self, syncPolicy not None : CUsynchronizationPolicy):
        self._pvt_ptr[0].syncPolicy = syncPolicy.value
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.clusterDim' in found_struct}}
    @property
    def clusterDim(self):
        return self._clusterDim
    @clusterDim.setter
    def clusterDim(self, clusterDim not None : anon_struct1):
        string.memcpy(&self._pvt_ptr[0].clusterDim, <cydriver.anon_struct1*><void_ptr>clusterDim.getPtr(), sizeof(self._pvt_ptr[0].clusterDim))
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.clusterSchedulingPolicyPreference' in found_struct}}
    @property
    def clusterSchedulingPolicyPreference(self):
        if self._pvt_ptr[0].clusterSchedulingPolicyPreference not in _dict_CUclusterSchedulingPolicy:
            return None
        return _dict_CUclusterSchedulingPolicy[self._pvt_ptr[0].clusterSchedulingPolicyPreference]
    @clusterSchedulingPolicyPreference.setter
    def clusterSchedulingPolicyPreference(self, clusterSchedulingPolicyPreference not None : CUclusterSchedulingPolicy):
        self._pvt_ptr[0].clusterSchedulingPolicyPreference = clusterSchedulingPolicyPreference.value
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.programmaticStreamSerializationAllowed' in found_struct}}
    @property
    def programmaticStreamSerializationAllowed(self):
        return self._pvt_ptr[0].programmaticStreamSerializationAllowed
    @programmaticStreamSerializationAllowed.setter
    def programmaticStreamSerializationAllowed(self, int programmaticStreamSerializationAllowed):
        self._pvt_ptr[0].programmaticStreamSerializationAllowed = programmaticStreamSerializationAllowed
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.programmaticEvent' in found_struct}}
    @property
    def programmaticEvent(self):
        return self._programmaticEvent
    @programmaticEvent.setter
    def programmaticEvent(self, programmaticEvent not None : anon_struct2):
        string.memcpy(&self._pvt_ptr[0].programmaticEvent, <cydriver.anon_struct2*><void_ptr>programmaticEvent.getPtr(), sizeof(self._pvt_ptr[0].programmaticEvent))
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.launchCompletionEvent' in found_struct}}
    @property
    def launchCompletionEvent(self):
        return self._launchCompletionEvent
    @launchCompletionEvent.setter
    def launchCompletionEvent(self, launchCompletionEvent not None : anon_struct3):
        string.memcpy(&self._pvt_ptr[0].launchCompletionEvent, <cydriver.anon_struct3*><void_ptr>launchCompletionEvent.getPtr(), sizeof(self._pvt_ptr[0].launchCompletionEvent))
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.priority' in found_struct}}
    @property
    def priority(self):
        return self._pvt_ptr[0].priority
    @priority.setter
    def priority(self, int priority):
        self._pvt_ptr[0].priority = priority
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.memSyncDomainMap' in found_struct}}
    @property
    def memSyncDomainMap(self):
        return self._memSyncDomainMap
    @memSyncDomainMap.setter
    def memSyncDomainMap(self, memSyncDomainMap not None : CUlaunchMemSyncDomainMap):
        string.memcpy(&self._pvt_ptr[0].memSyncDomainMap, <cydriver.CUlaunchMemSyncDomainMap*><void_ptr>memSyncDomainMap.getPtr(), sizeof(self._pvt_ptr[0].memSyncDomainMap))
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.memSyncDomain' in found_struct}}
    @property
    def memSyncDomain(self):
        if self._pvt_ptr[0].memSyncDomain not in _dict_CUlaunchMemSyncDomain:
            return None
        return _dict_CUlaunchMemSyncDomain[self._pvt_ptr[0].memSyncDomain]
    @memSyncDomain.setter
    def memSyncDomain(self, memSyncDomain not None : CUlaunchMemSyncDomain):
        self._pvt_ptr[0].memSyncDomain = memSyncDomain.value
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.preferredClusterDim' in found_struct}}
    @property
    def preferredClusterDim(self):
        return self._preferredClusterDim
    @preferredClusterDim.setter
    def preferredClusterDim(self, preferredClusterDim not None : anon_struct4):
        string.memcpy(&self._pvt_ptr[0].preferredClusterDim, <cydriver.anon_struct4*><void_ptr>preferredClusterDim.getPtr(), sizeof(self._pvt_ptr[0].preferredClusterDim))
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.deviceUpdatableKernelNode' in found_struct}}
    @property
    def deviceUpdatableKernelNode(self):
        return self._deviceUpdatableKernelNode
    @deviceUpdatableKernelNode.setter
    def deviceUpdatableKernelNode(self, deviceUpdatableKernelNode not None : anon_struct5):
        string.memcpy(&self._pvt_ptr[0].deviceUpdatableKernelNode, <cydriver.anon_struct5*><void_ptr>deviceUpdatableKernelNode.getPtr(), sizeof(self._pvt_ptr[0].deviceUpdatableKernelNode))
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.sharedMemCarveout' in found_struct}}
    @property
    def sharedMemCarveout(self):
        return self._pvt_ptr[0].sharedMemCarveout
    @sharedMemCarveout.setter
    def sharedMemCarveout(self, unsigned int sharedMemCarveout):
        self._pvt_ptr[0].sharedMemCarveout = sharedMemCarveout
    {{endif}}
    {{if 'CUlaunchAttributeValue_union.nvlinkUtilCentricScheduling' in found_struct}}
    @property
    def nvlinkUtilCentricScheduling(self):
        return self._pvt_ptr[0].nvlinkUtilCentricScheduling
    @nvlinkUtilCentricScheduling.setter
    def nvlinkUtilCentricScheduling(self, unsigned int nvlinkUtilCentricScheduling):
        self._pvt_ptr[0].nvlinkUtilCentricScheduling = nvlinkUtilCentricScheduling
    {{endif}}
{{endif}}
{{if 'CUlaunchAttribute_st' in found_struct}}

cdef class CUlaunchAttribute_st:
    """
    Launch attribute

    Attributes
    ----------
    {{if 'CUlaunchAttribute_st.id' in found_struct}}
    id : CUlaunchAttributeID
        Attribute to set
    {{endif}}
    {{if 'CUlaunchAttribute_st.value' in found_struct}}
    value : CUlaunchAttributeValue
        Value of the attribute
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUlaunchAttribute_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUlaunchAttribute_st.value' in found_struct}}
        self._value = CUlaunchAttributeValue(_ptr=<void_ptr>&self._pvt_ptr[0].value)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUlaunchAttribute_st.id' in found_struct}}
            try:
                str_list += ['id : ' + str(self.id)]
            except ValueError:
                str_list += ['id : <ValueError>']
            {{endif}}
            {{if 'CUlaunchAttribute_st.value' in found_struct}}
            try:
                str_list += ['value :\n' + '\n'.join(['    ' + line for line in str(self.value).splitlines()])]
            except ValueError:
                str_list += ['value : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUlaunchAttribute_st.id' in found_struct}}
    @property
    def id(self):
        if self._pvt_ptr[0].id not in _dict_CUlaunchAttributeID:
            return None
        return _dict_CUlaunchAttributeID[self._pvt_ptr[0].id]
    @id.setter
    def id(self, id not None : CUlaunchAttributeID):
        self._pvt_ptr[0].id = id.value
    {{endif}}
    {{if 'CUlaunchAttribute_st.value' in found_struct}}
    @property
    def value(self):
        return self._value
    @value.setter
    def value(self, value not None : CUlaunchAttributeValue):
        string.memcpy(&self._pvt_ptr[0].value, <cydriver.CUlaunchAttributeValue*><void_ptr>value.getPtr(), sizeof(self._pvt_ptr[0].value))
    {{endif}}
{{endif}}
{{if 'CUlaunchConfig_st' in found_struct}}

cdef class CUlaunchConfig_st:
    """
    CUDA extensible launch configuration

    Attributes
    ----------
    {{if 'CUlaunchConfig_st.gridDimX' in found_struct}}
    gridDimX : unsigned int
        Width of grid in blocks
    {{endif}}
    {{if 'CUlaunchConfig_st.gridDimY' in found_struct}}
    gridDimY : unsigned int
        Height of grid in blocks
    {{endif}}
    {{if 'CUlaunchConfig_st.gridDimZ' in found_struct}}
    gridDimZ : unsigned int
        Depth of grid in blocks
    {{endif}}
    {{if 'CUlaunchConfig_st.blockDimX' in found_struct}}
    blockDimX : unsigned int
        X dimension of each thread block
    {{endif}}
    {{if 'CUlaunchConfig_st.blockDimY' in found_struct}}
    blockDimY : unsigned int
        Y dimension of each thread block
    {{endif}}
    {{if 'CUlaunchConfig_st.blockDimZ' in found_struct}}
    blockDimZ : unsigned int
        Z dimension of each thread block
    {{endif}}
    {{if 'CUlaunchConfig_st.sharedMemBytes' in found_struct}}
    sharedMemBytes : unsigned int
        Dynamic shared-memory size per thread block in bytes
    {{endif}}
    {{if 'CUlaunchConfig_st.hStream' in found_struct}}
    hStream : CUstream
        Stream identifier
    {{endif}}
    {{if 'CUlaunchConfig_st.attrs' in found_struct}}
    attrs : CUlaunchAttribute
        List of attributes; nullable if CUlaunchConfig::numAttrs == 0
    {{endif}}
    {{if 'CUlaunchConfig_st.numAttrs' in found_struct}}
    numAttrs : unsigned int
        Number of attributes populated in CUlaunchConfig::attrs
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUlaunchConfig_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUlaunchConfig_st.hStream' in found_struct}}
        self._hStream = CUstream(_ptr=<void_ptr>&self._pvt_ptr[0].hStream)
        {{endif}}
    def __dealloc__(self):
        pass
        {{if 'CUlaunchConfig_st.attrs' in found_struct}}
        if self._attrs is not NULL:
            free(self._attrs)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUlaunchConfig_st.gridDimX' in found_struct}}
            try:
                str_list += ['gridDimX : ' + str(self.gridDimX)]
            except ValueError:
                str_list += ['gridDimX : <ValueError>']
            {{endif}}
            {{if 'CUlaunchConfig_st.gridDimY' in found_struct}}
            try:
                str_list += ['gridDimY : ' + str(self.gridDimY)]
            except ValueError:
                str_list += ['gridDimY : <ValueError>']
            {{endif}}
            {{if 'CUlaunchConfig_st.gridDimZ' in found_struct}}
            try:
                str_list += ['gridDimZ : ' + str(self.gridDimZ)]
            except ValueError:
                str_list += ['gridDimZ : <ValueError>']
            {{endif}}
            {{if 'CUlaunchConfig_st.blockDimX' in found_struct}}
            try:
                str_list += ['blockDimX : ' + str(self.blockDimX)]
            except ValueError:
                str_list += ['blockDimX : <ValueError>']
            {{endif}}
            {{if 'CUlaunchConfig_st.blockDimY' in found_struct}}
            try:
                str_list += ['blockDimY : ' + str(self.blockDimY)]
            except ValueError:
                str_list += ['blockDimY : <ValueError>']
            {{endif}}
            {{if 'CUlaunchConfig_st.blockDimZ' in found_struct}}
            try:
                str_list += ['blockDimZ : ' + str(self.blockDimZ)]
            except ValueError:
                str_list += ['blockDimZ : <ValueError>']
            {{endif}}
            {{if 'CUlaunchConfig_st.sharedMemBytes' in found_struct}}
            try:
                str_list += ['sharedMemBytes : ' + str(self.sharedMemBytes)]
            except ValueError:
                str_list += ['sharedMemBytes : <ValueError>']
            {{endif}}
            {{if 'CUlaunchConfig_st.hStream' in found_struct}}
            try:
                str_list += ['hStream : ' + str(self.hStream)]
            except ValueError:
                str_list += ['hStream : <ValueError>']
            {{endif}}
            {{if 'CUlaunchConfig_st.attrs' in found_struct}}
            try:
                str_list += ['attrs : ' + str(self.attrs)]
            except ValueError:
                str_list += ['attrs : <ValueError>']
            {{endif}}
            {{if 'CUlaunchConfig_st.numAttrs' in found_struct}}
            try:
                str_list += ['numAttrs : ' + str(self.numAttrs)]
            except ValueError:
                str_list += ['numAttrs : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUlaunchConfig_st.gridDimX' in found_struct}}
    @property
    def gridDimX(self):
        return self._pvt_ptr[0].gridDimX
    @gridDimX.setter
    def gridDimX(self, unsigned int gridDimX):
        self._pvt_ptr[0].gridDimX = gridDimX
    {{endif}}
    {{if 'CUlaunchConfig_st.gridDimY' in found_struct}}
    @property
    def gridDimY(self):
        return self._pvt_ptr[0].gridDimY
    @gridDimY.setter
    def gridDimY(self, unsigned int gridDimY):
        self._pvt_ptr[0].gridDimY = gridDimY
    {{endif}}
    {{if 'CUlaunchConfig_st.gridDimZ' in found_struct}}
    @property
    def gridDimZ(self):
        return self._pvt_ptr[0].gridDimZ
    @gridDimZ.setter
    def gridDimZ(self, unsigned int gridDimZ):
        self._pvt_ptr[0].gridDimZ = gridDimZ
    {{endif}}
    {{if 'CUlaunchConfig_st.blockDimX' in found_struct}}
    @property
    def blockDimX(self):
        return self._pvt_ptr[0].blockDimX
    @blockDimX.setter
    def blockDimX(self, unsigned int blockDimX):
        self._pvt_ptr[0].blockDimX = blockDimX
    {{endif}}
    {{if 'CUlaunchConfig_st.blockDimY' in found_struct}}
    @property
    def blockDimY(self):
        return self._pvt_ptr[0].blockDimY
    @blockDimY.setter
    def blockDimY(self, unsigned int blockDimY):
        self._pvt_ptr[0].blockDimY = blockDimY
    {{endif}}
    {{if 'CUlaunchConfig_st.blockDimZ' in found_struct}}
    @property
    def blockDimZ(self):
        return self._pvt_ptr[0].blockDimZ
    @blockDimZ.setter
    def blockDimZ(self, unsigned int blockDimZ):
        self._pvt_ptr[0].blockDimZ = blockDimZ
    {{endif}}
    {{if 'CUlaunchConfig_st.sharedMemBytes' in found_struct}}
    @property
    def sharedMemBytes(self):
        return self._pvt_ptr[0].sharedMemBytes
    @sharedMemBytes.setter
    def sharedMemBytes(self, unsigned int sharedMemBytes):
        self._pvt_ptr[0].sharedMemBytes = sharedMemBytes
    {{endif}}
    {{if 'CUlaunchConfig_st.hStream' in found_struct}}
    @property
    def hStream(self):
        return self._hStream
    @hStream.setter
    def hStream(self, hStream):
        cdef cydriver.CUstream cyhStream
        if hStream is None:
            cyhStream = <cydriver.CUstream><void_ptr>0
        elif isinstance(hStream, (CUstream,)):
            phStream = int(hStream)
            cyhStream = <cydriver.CUstream><void_ptr>phStream
        else:
            phStream = int(CUstream(hStream))
            cyhStream = <cydriver.CUstream><void_ptr>phStream
        self._hStream._pvt_ptr[0] = cyhStream
    {{endif}}
    {{if 'CUlaunchConfig_st.attrs' in found_struct}}
    @property
    def attrs(self):
        arrs = [<void_ptr>self._pvt_ptr[0].attrs + x*sizeof(cydriver.CUlaunchAttribute) for x in range(self._attrs_length)]
        return [CUlaunchAttribute(_ptr=arr) for arr in arrs]
    @attrs.setter
    def attrs(self, val):
        if len(val) == 0:
            free(self._attrs)
            self._attrs_length = 0
            self._pvt_ptr[0].attrs = NULL
        else:
            if self._attrs_length != <size_t>len(val):
                free(self._attrs)
                self._attrs = <cydriver.CUlaunchAttribute*> calloc(len(val), sizeof(cydriver.CUlaunchAttribute))
                if self._attrs is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cydriver.CUlaunchAttribute)))
                self._attrs_length = <size_t>len(val)
                self._pvt_ptr[0].attrs = self._attrs
            for idx in range(len(val)):
                string.memcpy(&self._attrs[idx], (<CUlaunchAttribute>val[idx])._pvt_ptr, sizeof(cydriver.CUlaunchAttribute))

    {{endif}}
    {{if 'CUlaunchConfig_st.numAttrs' in found_struct}}
    @property
    def numAttrs(self):
        return self._pvt_ptr[0].numAttrs
    @numAttrs.setter
    def numAttrs(self, unsigned int numAttrs):
        self._pvt_ptr[0].numAttrs = numAttrs
    {{endif}}
{{endif}}
{{if 'CUexecAffinitySmCount_st' in found_struct}}

cdef class CUexecAffinitySmCount_st:
    """
    Value for CU_EXEC_AFFINITY_TYPE_SM_COUNT

    Attributes
    ----------
    {{if 'CUexecAffinitySmCount_st.val' in found_struct}}
    val : unsigned int
        The number of SMs the context is limited to use.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUexecAffinitySmCount_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUexecAffinitySmCount_st.val' in found_struct}}
            try:
                str_list += ['val : ' + str(self.val)]
            except ValueError:
                str_list += ['val : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUexecAffinitySmCount_st.val' in found_struct}}
    @property
    def val(self):
        return self._pvt_ptr[0].val
    @val.setter
    def val(self, unsigned int val):
        self._pvt_ptr[0].val = val
    {{endif}}
{{endif}}
{{if 'CUexecAffinityParam_st.param' in found_struct}}

cdef class anon_union3:
    """
    Attributes
    ----------
    {{if 'CUexecAffinityParam_st.param.smCount' in found_struct}}
    smCount : CUexecAffinitySmCount

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUexecAffinityParam_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUexecAffinityParam_st.param.smCount' in found_struct}}
        self._smCount = CUexecAffinitySmCount(_ptr=<void_ptr>&self._pvt_ptr[0].param.smCount)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].param
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUexecAffinityParam_st.param.smCount' in found_struct}}
            try:
                str_list += ['smCount :\n' + '\n'.join(['    ' + line for line in str(self.smCount).splitlines()])]
            except ValueError:
                str_list += ['smCount : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUexecAffinityParam_st.param.smCount' in found_struct}}
    @property
    def smCount(self):
        return self._smCount
    @smCount.setter
    def smCount(self, smCount not None : CUexecAffinitySmCount):
        string.memcpy(&self._pvt_ptr[0].param.smCount, <cydriver.CUexecAffinitySmCount*><void_ptr>smCount.getPtr(), sizeof(self._pvt_ptr[0].param.smCount))
    {{endif}}
{{endif}}
{{if 'CUexecAffinityParam_st' in found_struct}}

cdef class CUexecAffinityParam_st:
    """
    Execution Affinity Parameters

    Attributes
    ----------
    {{if 'CUexecAffinityParam_st.type' in found_struct}}
    type : CUexecAffinityType

    {{endif}}
    {{if 'CUexecAffinityParam_st.param' in found_struct}}
    param : anon_union3

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cydriver.CUexecAffinityParam_st *>calloc(1, sizeof(cydriver.CUexecAffinityParam_st))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cydriver.CUexecAffinityParam_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUexecAffinityParam_st.param' in found_struct}}
        self._param = anon_union3(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUexecAffinityParam_st.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'CUexecAffinityParam_st.param' in found_struct}}
            try:
                str_list += ['param :\n' + '\n'.join(['    ' + line for line in str(self.param).splitlines()])]
            except ValueError:
                str_list += ['param : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUexecAffinityParam_st.type' in found_struct}}
    @property
    def type(self):
        if self._pvt_ptr[0].type not in _dict_CUexecAffinityType:
            return None
        return _dict_CUexecAffinityType[self._pvt_ptr[0].type]
    @type.setter
    def type(self, type not None : CUexecAffinityType):
        self._pvt_ptr[0].type = type.value
    {{endif}}
    {{if 'CUexecAffinityParam_st.param' in found_struct}}
    @property
    def param(self):
        return self._param
    @param.setter
    def param(self, param not None : anon_union3):
        string.memcpy(&self._pvt_ptr[0].param, <cydriver.anon_union3*><void_ptr>param.getPtr(), sizeof(self._pvt_ptr[0].param))
    {{endif}}
{{endif}}
{{if 'CUctxCigParam_st' in found_struct}}

cdef class CUctxCigParam_st:
    """
    CIG Context Create Params

    Attributes
    ----------
    {{if 'CUctxCigParam_st.sharedDataType' in found_struct}}
    sharedDataType : CUcigDataType

    {{endif}}
    {{if 'CUctxCigParam_st.sharedData' in found_struct}}
    sharedData : Any

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUctxCigParam_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUctxCigParam_st.sharedDataType' in found_struct}}
            try:
                str_list += ['sharedDataType : ' + str(self.sharedDataType)]
            except ValueError:
                str_list += ['sharedDataType : <ValueError>']
            {{endif}}
            {{if 'CUctxCigParam_st.sharedData' in found_struct}}
            try:
                str_list += ['sharedData : ' + hex(self.sharedData)]
            except ValueError:
                str_list += ['sharedData : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUctxCigParam_st.sharedDataType' in found_struct}}
    @property
    def sharedDataType(self):
        if self._pvt_ptr[0].sharedDataType not in _dict_CUcigDataType:
            return None
        return _dict_CUcigDataType[self._pvt_ptr[0].sharedDataType]
    @sharedDataType.setter
    def sharedDataType(self, sharedDataType not None : CUcigDataType):
        self._pvt_ptr[0].sharedDataType = sharedDataType.value
    {{endif}}
    {{if 'CUctxCigParam_st.sharedData' in found_struct}}
    @property
    def sharedData(self):
        return <void_ptr>self._pvt_ptr[0].sharedData
    @sharedData.setter
    def sharedData(self, sharedData):
        _csharedData = _HelperInputVoidPtr(sharedData)
        self._pvt_ptr[0].sharedData = <void*><void_ptr>_csharedData.cptr
    {{endif}}
{{endif}}
{{if 'CUctxCreateParams_st' in found_struct}}

cdef class CUctxCreateParams_st:
    """
    Params for creating CUDA context Exactly one of execAffinityParams
    and cigParams must be non-NULL.

    Attributes
    ----------
    {{if 'CUctxCreateParams_st.execAffinityParams' in found_struct}}
    execAffinityParams : CUexecAffinityParam

    {{endif}}
    {{if 'CUctxCreateParams_st.numExecAffinityParams' in found_struct}}
    numExecAffinityParams : int

    {{endif}}
    {{if 'CUctxCreateParams_st.cigParams' in found_struct}}
    cigParams : CUctxCigParam

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUctxCreateParams_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
        {{if 'CUctxCreateParams_st.execAffinityParams' in found_struct}}
        if self._execAffinityParams is not NULL:
            free(self._execAffinityParams)
        {{endif}}
        {{if 'CUctxCreateParams_st.cigParams' in found_struct}}
        if self._cigParams is not NULL:
            free(self._cigParams)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUctxCreateParams_st.execAffinityParams' in found_struct}}
            try:
                str_list += ['execAffinityParams : ' + str(self.execAffinityParams)]
            except ValueError:
                str_list += ['execAffinityParams : <ValueError>']
            {{endif}}
            {{if 'CUctxCreateParams_st.numExecAffinityParams' in found_struct}}
            try:
                str_list += ['numExecAffinityParams : ' + str(self.numExecAffinityParams)]
            except ValueError:
                str_list += ['numExecAffinityParams : <ValueError>']
            {{endif}}
            {{if 'CUctxCreateParams_st.cigParams' in found_struct}}
            try:
                str_list += ['cigParams : ' + str(self.cigParams)]
            except ValueError:
                str_list += ['cigParams : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUctxCreateParams_st.execAffinityParams' in found_struct}}
    @property
    def execAffinityParams(self):
        arrs = [<void_ptr>self._pvt_ptr[0].execAffinityParams + x*sizeof(cydriver.CUexecAffinityParam) for x in range(self._execAffinityParams_length)]
        return [CUexecAffinityParam(_ptr=arr) for arr in arrs]
    @execAffinityParams.setter
    def execAffinityParams(self, val):
        if len(val) == 0:
            free(self._execAffinityParams)
            self._execAffinityParams_length = 0
            self._pvt_ptr[0].execAffinityParams = NULL
        else:
            if self._execAffinityParams_length != <size_t>len(val):
                free(self._execAffinityParams)
                self._execAffinityParams = <cydriver.CUexecAffinityParam*> calloc(len(val), sizeof(cydriver.CUexecAffinityParam))
                if self._execAffinityParams is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cydriver.CUexecAffinityParam)))
                self._execAffinityParams_length = <size_t>len(val)
                self._pvt_ptr[0].execAffinityParams = self._execAffinityParams
            for idx in range(len(val)):
                string.memcpy(&self._execAffinityParams[idx], (<CUexecAffinityParam>val[idx])._pvt_ptr, sizeof(cydriver.CUexecAffinityParam))

    {{endif}}
    {{if 'CUctxCreateParams_st.numExecAffinityParams' in found_struct}}
    @property
    def numExecAffinityParams(self):
        return self._pvt_ptr[0].numExecAffinityParams
    @numExecAffinityParams.setter
    def numExecAffinityParams(self, int numExecAffinityParams):
        self._pvt_ptr[0].numExecAffinityParams = numExecAffinityParams
    {{endif}}
    {{if 'CUctxCreateParams_st.cigParams' in found_struct}}
    @property
    def cigParams(self):
        arrs = [<void_ptr>self._pvt_ptr[0].cigParams + x*sizeof(cydriver.CUctxCigParam) for x in range(self._cigParams_length)]
        return [CUctxCigParam(_ptr=arr) for arr in arrs]
    @cigParams.setter
    def cigParams(self, val):
        if len(val) == 0:
            free(self._cigParams)
            self._cigParams_length = 0
            self._pvt_ptr[0].cigParams = NULL
        else:
            if self._cigParams_length != <size_t>len(val):
                free(self._cigParams)
                self._cigParams = <cydriver.CUctxCigParam*> calloc(len(val), sizeof(cydriver.CUctxCigParam))
                if self._cigParams is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cydriver.CUctxCigParam)))
                self._cigParams_length = <size_t>len(val)
                self._pvt_ptr[0].cigParams = self._cigParams
            for idx in range(len(val)):
                string.memcpy(&self._cigParams[idx], (<CUctxCigParam>val[idx])._pvt_ptr, sizeof(cydriver.CUctxCigParam))

    {{endif}}
{{endif}}
{{if 'CUlibraryHostUniversalFunctionAndDataTable_st' in found_struct}}

cdef class CUlibraryHostUniversalFunctionAndDataTable_st:
    """
    Attributes
    ----------
    {{if 'CUlibraryHostUniversalFunctionAndDataTable_st.functionTable' in found_struct}}
    functionTable : Any

    {{endif}}
    {{if 'CUlibraryHostUniversalFunctionAndDataTable_st.functionWindowSize' in found_struct}}
    functionWindowSize : size_t

    {{endif}}
    {{if 'CUlibraryHostUniversalFunctionAndDataTable_st.dataTable' in found_struct}}
    dataTable : Any

    {{endif}}
    {{if 'CUlibraryHostUniversalFunctionAndDataTable_st.dataWindowSize' in found_struct}}
    dataWindowSize : size_t

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUlibraryHostUniversalFunctionAndDataTable_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUlibraryHostUniversalFunctionAndDataTable_st.functionTable' in found_struct}}
            try:
                str_list += ['functionTable : ' + hex(self.functionTable)]
            except ValueError:
                str_list += ['functionTable : <ValueError>']
            {{endif}}
            {{if 'CUlibraryHostUniversalFunctionAndDataTable_st.functionWindowSize' in found_struct}}
            try:
                str_list += ['functionWindowSize : ' + str(self.functionWindowSize)]
            except ValueError:
                str_list += ['functionWindowSize : <ValueError>']
            {{endif}}
            {{if 'CUlibraryHostUniversalFunctionAndDataTable_st.dataTable' in found_struct}}
            try:
                str_list += ['dataTable : ' + hex(self.dataTable)]
            except ValueError:
                str_list += ['dataTable : <ValueError>']
            {{endif}}
            {{if 'CUlibraryHostUniversalFunctionAndDataTable_st.dataWindowSize' in found_struct}}
            try:
                str_list += ['dataWindowSize : ' + str(self.dataWindowSize)]
            except ValueError:
                str_list += ['dataWindowSize : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUlibraryHostUniversalFunctionAndDataTable_st.functionTable' in found_struct}}
    @property
    def functionTable(self):
        return <void_ptr>self._pvt_ptr[0].functionTable
    @functionTable.setter
    def functionTable(self, functionTable):
        _cfunctionTable = _HelperInputVoidPtr(functionTable)
        self._pvt_ptr[0].functionTable = <void*><void_ptr>_cfunctionTable.cptr
    {{endif}}
    {{if 'CUlibraryHostUniversalFunctionAndDataTable_st.functionWindowSize' in found_struct}}
    @property
    def functionWindowSize(self):
        return self._pvt_ptr[0].functionWindowSize
    @functionWindowSize.setter
    def functionWindowSize(self, size_t functionWindowSize):
        self._pvt_ptr[0].functionWindowSize = functionWindowSize
    {{endif}}
    {{if 'CUlibraryHostUniversalFunctionAndDataTable_st.dataTable' in found_struct}}
    @property
    def dataTable(self):
        return <void_ptr>self._pvt_ptr[0].dataTable
    @dataTable.setter
    def dataTable(self, dataTable):
        _cdataTable = _HelperInputVoidPtr(dataTable)
        self._pvt_ptr[0].dataTable = <void*><void_ptr>_cdataTable.cptr
    {{endif}}
    {{if 'CUlibraryHostUniversalFunctionAndDataTable_st.dataWindowSize' in found_struct}}
    @property
    def dataWindowSize(self):
        return self._pvt_ptr[0].dataWindowSize
    @dataWindowSize.setter
    def dataWindowSize(self, size_t dataWindowSize):
        self._pvt_ptr[0].dataWindowSize = dataWindowSize
    {{endif}}
{{endif}}
{{if 'CUDA_MEMCPY2D_st' in found_struct}}

cdef class CUDA_MEMCPY2D_st:
    """
    2D memory copy parameters

    Attributes
    ----------
    {{if 'CUDA_MEMCPY2D_st.srcXInBytes' in found_struct}}
    srcXInBytes : size_t
        Source X in bytes
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.srcY' in found_struct}}
    srcY : size_t
        Source Y
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.srcMemoryType' in found_struct}}
    srcMemoryType : CUmemorytype
        Source memory type (host, device, array)
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.srcHost' in found_struct}}
    srcHost : Any
        Source host pointer
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.srcDevice' in found_struct}}
    srcDevice : CUdeviceptr
        Source device pointer
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.srcArray' in found_struct}}
    srcArray : CUarray
        Source array reference
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.srcPitch' in found_struct}}
    srcPitch : size_t
        Source pitch (ignored when src is array)
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.dstXInBytes' in found_struct}}
    dstXInBytes : size_t
        Destination X in bytes
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.dstY' in found_struct}}
    dstY : size_t
        Destination Y
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.dstMemoryType' in found_struct}}
    dstMemoryType : CUmemorytype
        Destination memory type (host, device, array)
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.dstHost' in found_struct}}
    dstHost : Any
        Destination host pointer
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.dstDevice' in found_struct}}
    dstDevice : CUdeviceptr
        Destination device pointer
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.dstArray' in found_struct}}
    dstArray : CUarray
        Destination array reference
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.dstPitch' in found_struct}}
    dstPitch : size_t
        Destination pitch (ignored when dst is array)
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.WidthInBytes' in found_struct}}
    WidthInBytes : size_t
        Width of 2D memory copy in bytes
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.Height' in found_struct}}
    Height : size_t
        Height of 2D memory copy
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_MEMCPY2D_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_MEMCPY2D_st.srcDevice' in found_struct}}
        self._srcDevice = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].srcDevice)
        {{endif}}
        {{if 'CUDA_MEMCPY2D_st.srcArray' in found_struct}}
        self._srcArray = CUarray(_ptr=<void_ptr>&self._pvt_ptr[0].srcArray)
        {{endif}}
        {{if 'CUDA_MEMCPY2D_st.dstDevice' in found_struct}}
        self._dstDevice = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].dstDevice)
        {{endif}}
        {{if 'CUDA_MEMCPY2D_st.dstArray' in found_struct}}
        self._dstArray = CUarray(_ptr=<void_ptr>&self._pvt_ptr[0].dstArray)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_MEMCPY2D_st.srcXInBytes' in found_struct}}
            try:
                str_list += ['srcXInBytes : ' + str(self.srcXInBytes)]
            except ValueError:
                str_list += ['srcXInBytes : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY2D_st.srcY' in found_struct}}
            try:
                str_list += ['srcY : ' + str(self.srcY)]
            except ValueError:
                str_list += ['srcY : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY2D_st.srcMemoryType' in found_struct}}
            try:
                str_list += ['srcMemoryType : ' + str(self.srcMemoryType)]
            except ValueError:
                str_list += ['srcMemoryType : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY2D_st.srcHost' in found_struct}}
            try:
                str_list += ['srcHost : ' + hex(self.srcHost)]
            except ValueError:
                str_list += ['srcHost : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY2D_st.srcDevice' in found_struct}}
            try:
                str_list += ['srcDevice : ' + str(self.srcDevice)]
            except ValueError:
                str_list += ['srcDevice : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY2D_st.srcArray' in found_struct}}
            try:
                str_list += ['srcArray : ' + str(self.srcArray)]
            except ValueError:
                str_list += ['srcArray : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY2D_st.srcPitch' in found_struct}}
            try:
                str_list += ['srcPitch : ' + str(self.srcPitch)]
            except ValueError:
                str_list += ['srcPitch : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY2D_st.dstXInBytes' in found_struct}}
            try:
                str_list += ['dstXInBytes : ' + str(self.dstXInBytes)]
            except ValueError:
                str_list += ['dstXInBytes : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY2D_st.dstY' in found_struct}}
            try:
                str_list += ['dstY : ' + str(self.dstY)]
            except ValueError:
                str_list += ['dstY : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY2D_st.dstMemoryType' in found_struct}}
            try:
                str_list += ['dstMemoryType : ' + str(self.dstMemoryType)]
            except ValueError:
                str_list += ['dstMemoryType : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY2D_st.dstHost' in found_struct}}
            try:
                str_list += ['dstHost : ' + hex(self.dstHost)]
            except ValueError:
                str_list += ['dstHost : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY2D_st.dstDevice' in found_struct}}
            try:
                str_list += ['dstDevice : ' + str(self.dstDevice)]
            except ValueError:
                str_list += ['dstDevice : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY2D_st.dstArray' in found_struct}}
            try:
                str_list += ['dstArray : ' + str(self.dstArray)]
            except ValueError:
                str_list += ['dstArray : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY2D_st.dstPitch' in found_struct}}
            try:
                str_list += ['dstPitch : ' + str(self.dstPitch)]
            except ValueError:
                str_list += ['dstPitch : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY2D_st.WidthInBytes' in found_struct}}
            try:
                str_list += ['WidthInBytes : ' + str(self.WidthInBytes)]
            except ValueError:
                str_list += ['WidthInBytes : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY2D_st.Height' in found_struct}}
            try:
                str_list += ['Height : ' + str(self.Height)]
            except ValueError:
                str_list += ['Height : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_MEMCPY2D_st.srcXInBytes' in found_struct}}
    @property
    def srcXInBytes(self):
        return self._pvt_ptr[0].srcXInBytes
    @srcXInBytes.setter
    def srcXInBytes(self, size_t srcXInBytes):
        self._pvt_ptr[0].srcXInBytes = srcXInBytes
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.srcY' in found_struct}}
    @property
    def srcY(self):
        return self._pvt_ptr[0].srcY
    @srcY.setter
    def srcY(self, size_t srcY):
        self._pvt_ptr[0].srcY = srcY
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.srcMemoryType' in found_struct}}
    @property
    def srcMemoryType(self):
        if self._pvt_ptr[0].srcMemoryType not in _dict_CUmemorytype:
            return None
        return _dict_CUmemorytype[self._pvt_ptr[0].srcMemoryType]
    @srcMemoryType.setter
    def srcMemoryType(self, srcMemoryType not None : CUmemorytype):
        self._pvt_ptr[0].srcMemoryType = srcMemoryType.value
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.srcHost' in found_struct}}
    @property
    def srcHost(self):
        return <void_ptr>self._pvt_ptr[0].srcHost
    @srcHost.setter
    def srcHost(self, srcHost):
        _csrcHost = _HelperInputVoidPtr(srcHost)
        self._pvt_ptr[0].srcHost = <void*><void_ptr>_csrcHost.cptr
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.srcDevice' in found_struct}}
    @property
    def srcDevice(self):
        return self._srcDevice
    @srcDevice.setter
    def srcDevice(self, srcDevice):
        cdef cydriver.CUdeviceptr cysrcDevice
        if srcDevice is None:
            cysrcDevice = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(srcDevice, (CUdeviceptr)):
            psrcDevice = int(srcDevice)
            cysrcDevice = <cydriver.CUdeviceptr><void_ptr>psrcDevice
        else:
            psrcDevice = int(CUdeviceptr(srcDevice))
            cysrcDevice = <cydriver.CUdeviceptr><void_ptr>psrcDevice
        self._srcDevice._pvt_ptr[0] = cysrcDevice

    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.srcArray' in found_struct}}
    @property
    def srcArray(self):
        return self._srcArray
    @srcArray.setter
    def srcArray(self, srcArray):
        cdef cydriver.CUarray cysrcArray
        if srcArray is None:
            cysrcArray = <cydriver.CUarray><void_ptr>0
        elif isinstance(srcArray, (CUarray,)):
            psrcArray = int(srcArray)
            cysrcArray = <cydriver.CUarray><void_ptr>psrcArray
        else:
            psrcArray = int(CUarray(srcArray))
            cysrcArray = <cydriver.CUarray><void_ptr>psrcArray
        self._srcArray._pvt_ptr[0] = cysrcArray
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.srcPitch' in found_struct}}
    @property
    def srcPitch(self):
        return self._pvt_ptr[0].srcPitch
    @srcPitch.setter
    def srcPitch(self, size_t srcPitch):
        self._pvt_ptr[0].srcPitch = srcPitch
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.dstXInBytes' in found_struct}}
    @property
    def dstXInBytes(self):
        return self._pvt_ptr[0].dstXInBytes
    @dstXInBytes.setter
    def dstXInBytes(self, size_t dstXInBytes):
        self._pvt_ptr[0].dstXInBytes = dstXInBytes
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.dstY' in found_struct}}
    @property
    def dstY(self):
        return self._pvt_ptr[0].dstY
    @dstY.setter
    def dstY(self, size_t dstY):
        self._pvt_ptr[0].dstY = dstY
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.dstMemoryType' in found_struct}}
    @property
    def dstMemoryType(self):
        if self._pvt_ptr[0].dstMemoryType not in _dict_CUmemorytype:
            return None
        return _dict_CUmemorytype[self._pvt_ptr[0].dstMemoryType]
    @dstMemoryType.setter
    def dstMemoryType(self, dstMemoryType not None : CUmemorytype):
        self._pvt_ptr[0].dstMemoryType = dstMemoryType.value
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.dstHost' in found_struct}}
    @property
    def dstHost(self):
        return <void_ptr>self._pvt_ptr[0].dstHost
    @dstHost.setter
    def dstHost(self, dstHost):
        _cdstHost = _HelperInputVoidPtr(dstHost)
        self._pvt_ptr[0].dstHost = <void*><void_ptr>_cdstHost.cptr
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.dstDevice' in found_struct}}
    @property
    def dstDevice(self):
        return self._dstDevice
    @dstDevice.setter
    def dstDevice(self, dstDevice):
        cdef cydriver.CUdeviceptr cydstDevice
        if dstDevice is None:
            cydstDevice = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(dstDevice, (CUdeviceptr)):
            pdstDevice = int(dstDevice)
            cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
        else:
            pdstDevice = int(CUdeviceptr(dstDevice))
            cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
        self._dstDevice._pvt_ptr[0] = cydstDevice

    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.dstArray' in found_struct}}
    @property
    def dstArray(self):
        return self._dstArray
    @dstArray.setter
    def dstArray(self, dstArray):
        cdef cydriver.CUarray cydstArray
        if dstArray is None:
            cydstArray = <cydriver.CUarray><void_ptr>0
        elif isinstance(dstArray, (CUarray,)):
            pdstArray = int(dstArray)
            cydstArray = <cydriver.CUarray><void_ptr>pdstArray
        else:
            pdstArray = int(CUarray(dstArray))
            cydstArray = <cydriver.CUarray><void_ptr>pdstArray
        self._dstArray._pvt_ptr[0] = cydstArray
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.dstPitch' in found_struct}}
    @property
    def dstPitch(self):
        return self._pvt_ptr[0].dstPitch
    @dstPitch.setter
    def dstPitch(self, size_t dstPitch):
        self._pvt_ptr[0].dstPitch = dstPitch
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.WidthInBytes' in found_struct}}
    @property
    def WidthInBytes(self):
        return self._pvt_ptr[0].WidthInBytes
    @WidthInBytes.setter
    def WidthInBytes(self, size_t WidthInBytes):
        self._pvt_ptr[0].WidthInBytes = WidthInBytes
    {{endif}}
    {{if 'CUDA_MEMCPY2D_st.Height' in found_struct}}
    @property
    def Height(self):
        return self._pvt_ptr[0].Height
    @Height.setter
    def Height(self, size_t Height):
        self._pvt_ptr[0].Height = Height
    {{endif}}
{{endif}}
{{if 'CUDA_MEMCPY3D_st' in found_struct}}

cdef class CUDA_MEMCPY3D_st:
    """
    3D memory copy parameters

    Attributes
    ----------
    {{if 'CUDA_MEMCPY3D_st.srcXInBytes' in found_struct}}
    srcXInBytes : size_t
        Source X in bytes
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcY' in found_struct}}
    srcY : size_t
        Source Y
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcZ' in found_struct}}
    srcZ : size_t
        Source Z
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcLOD' in found_struct}}
    srcLOD : size_t
        Source LOD
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcMemoryType' in found_struct}}
    srcMemoryType : CUmemorytype
        Source memory type (host, device, array)
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcHost' in found_struct}}
    srcHost : Any
        Source host pointer
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcDevice' in found_struct}}
    srcDevice : CUdeviceptr
        Source device pointer
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcArray' in found_struct}}
    srcArray : CUarray
        Source array reference
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.reserved0' in found_struct}}
    reserved0 : Any
        Must be NULL
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcPitch' in found_struct}}
    srcPitch : size_t
        Source pitch (ignored when src is array)
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcHeight' in found_struct}}
    srcHeight : size_t
        Source height (ignored when src is array; may be 0 if Depth==1)
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstXInBytes' in found_struct}}
    dstXInBytes : size_t
        Destination X in bytes
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstY' in found_struct}}
    dstY : size_t
        Destination Y
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstZ' in found_struct}}
    dstZ : size_t
        Destination Z
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstLOD' in found_struct}}
    dstLOD : size_t
        Destination LOD
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstMemoryType' in found_struct}}
    dstMemoryType : CUmemorytype
        Destination memory type (host, device, array)
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstHost' in found_struct}}
    dstHost : Any
        Destination host pointer
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstDevice' in found_struct}}
    dstDevice : CUdeviceptr
        Destination device pointer
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstArray' in found_struct}}
    dstArray : CUarray
        Destination array reference
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.reserved1' in found_struct}}
    reserved1 : Any
        Must be NULL
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstPitch' in found_struct}}
    dstPitch : size_t
        Destination pitch (ignored when dst is array)
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstHeight' in found_struct}}
    dstHeight : size_t
        Destination height (ignored when dst is array; may be 0 if
        Depth==1)
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.WidthInBytes' in found_struct}}
    WidthInBytes : size_t
        Width of 3D memory copy in bytes
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.Height' in found_struct}}
    Height : size_t
        Height of 3D memory copy
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.Depth' in found_struct}}
    Depth : size_t
        Depth of 3D memory copy
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_MEMCPY3D_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_MEMCPY3D_st.srcDevice' in found_struct}}
        self._srcDevice = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].srcDevice)
        {{endif}}
        {{if 'CUDA_MEMCPY3D_st.srcArray' in found_struct}}
        self._srcArray = CUarray(_ptr=<void_ptr>&self._pvt_ptr[0].srcArray)
        {{endif}}
        {{if 'CUDA_MEMCPY3D_st.dstDevice' in found_struct}}
        self._dstDevice = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].dstDevice)
        {{endif}}
        {{if 'CUDA_MEMCPY3D_st.dstArray' in found_struct}}
        self._dstArray = CUarray(_ptr=<void_ptr>&self._pvt_ptr[0].dstArray)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_MEMCPY3D_st.srcXInBytes' in found_struct}}
            try:
                str_list += ['srcXInBytes : ' + str(self.srcXInBytes)]
            except ValueError:
                str_list += ['srcXInBytes : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.srcY' in found_struct}}
            try:
                str_list += ['srcY : ' + str(self.srcY)]
            except ValueError:
                str_list += ['srcY : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.srcZ' in found_struct}}
            try:
                str_list += ['srcZ : ' + str(self.srcZ)]
            except ValueError:
                str_list += ['srcZ : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.srcLOD' in found_struct}}
            try:
                str_list += ['srcLOD : ' + str(self.srcLOD)]
            except ValueError:
                str_list += ['srcLOD : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.srcMemoryType' in found_struct}}
            try:
                str_list += ['srcMemoryType : ' + str(self.srcMemoryType)]
            except ValueError:
                str_list += ['srcMemoryType : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.srcHost' in found_struct}}
            try:
                str_list += ['srcHost : ' + hex(self.srcHost)]
            except ValueError:
                str_list += ['srcHost : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.srcDevice' in found_struct}}
            try:
                str_list += ['srcDevice : ' + str(self.srcDevice)]
            except ValueError:
                str_list += ['srcDevice : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.srcArray' in found_struct}}
            try:
                str_list += ['srcArray : ' + str(self.srcArray)]
            except ValueError:
                str_list += ['srcArray : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.reserved0' in found_struct}}
            try:
                str_list += ['reserved0 : ' + hex(self.reserved0)]
            except ValueError:
                str_list += ['reserved0 : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.srcPitch' in found_struct}}
            try:
                str_list += ['srcPitch : ' + str(self.srcPitch)]
            except ValueError:
                str_list += ['srcPitch : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.srcHeight' in found_struct}}
            try:
                str_list += ['srcHeight : ' + str(self.srcHeight)]
            except ValueError:
                str_list += ['srcHeight : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.dstXInBytes' in found_struct}}
            try:
                str_list += ['dstXInBytes : ' + str(self.dstXInBytes)]
            except ValueError:
                str_list += ['dstXInBytes : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.dstY' in found_struct}}
            try:
                str_list += ['dstY : ' + str(self.dstY)]
            except ValueError:
                str_list += ['dstY : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.dstZ' in found_struct}}
            try:
                str_list += ['dstZ : ' + str(self.dstZ)]
            except ValueError:
                str_list += ['dstZ : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.dstLOD' in found_struct}}
            try:
                str_list += ['dstLOD : ' + str(self.dstLOD)]
            except ValueError:
                str_list += ['dstLOD : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.dstMemoryType' in found_struct}}
            try:
                str_list += ['dstMemoryType : ' + str(self.dstMemoryType)]
            except ValueError:
                str_list += ['dstMemoryType : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.dstHost' in found_struct}}
            try:
                str_list += ['dstHost : ' + hex(self.dstHost)]
            except ValueError:
                str_list += ['dstHost : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.dstDevice' in found_struct}}
            try:
                str_list += ['dstDevice : ' + str(self.dstDevice)]
            except ValueError:
                str_list += ['dstDevice : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.dstArray' in found_struct}}
            try:
                str_list += ['dstArray : ' + str(self.dstArray)]
            except ValueError:
                str_list += ['dstArray : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.reserved1' in found_struct}}
            try:
                str_list += ['reserved1 : ' + hex(self.reserved1)]
            except ValueError:
                str_list += ['reserved1 : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.dstPitch' in found_struct}}
            try:
                str_list += ['dstPitch : ' + str(self.dstPitch)]
            except ValueError:
                str_list += ['dstPitch : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.dstHeight' in found_struct}}
            try:
                str_list += ['dstHeight : ' + str(self.dstHeight)]
            except ValueError:
                str_list += ['dstHeight : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.WidthInBytes' in found_struct}}
            try:
                str_list += ['WidthInBytes : ' + str(self.WidthInBytes)]
            except ValueError:
                str_list += ['WidthInBytes : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.Height' in found_struct}}
            try:
                str_list += ['Height : ' + str(self.Height)]
            except ValueError:
                str_list += ['Height : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_st.Depth' in found_struct}}
            try:
                str_list += ['Depth : ' + str(self.Depth)]
            except ValueError:
                str_list += ['Depth : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_MEMCPY3D_st.srcXInBytes' in found_struct}}
    @property
    def srcXInBytes(self):
        return self._pvt_ptr[0].srcXInBytes
    @srcXInBytes.setter
    def srcXInBytes(self, size_t srcXInBytes):
        self._pvt_ptr[0].srcXInBytes = srcXInBytes
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcY' in found_struct}}
    @property
    def srcY(self):
        return self._pvt_ptr[0].srcY
    @srcY.setter
    def srcY(self, size_t srcY):
        self._pvt_ptr[0].srcY = srcY
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcZ' in found_struct}}
    @property
    def srcZ(self):
        return self._pvt_ptr[0].srcZ
    @srcZ.setter
    def srcZ(self, size_t srcZ):
        self._pvt_ptr[0].srcZ = srcZ
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcLOD' in found_struct}}
    @property
    def srcLOD(self):
        return self._pvt_ptr[0].srcLOD
    @srcLOD.setter
    def srcLOD(self, size_t srcLOD):
        self._pvt_ptr[0].srcLOD = srcLOD
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcMemoryType' in found_struct}}
    @property
    def srcMemoryType(self):
        if self._pvt_ptr[0].srcMemoryType not in _dict_CUmemorytype:
            return None
        return _dict_CUmemorytype[self._pvt_ptr[0].srcMemoryType]
    @srcMemoryType.setter
    def srcMemoryType(self, srcMemoryType not None : CUmemorytype):
        self._pvt_ptr[0].srcMemoryType = srcMemoryType.value
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcHost' in found_struct}}
    @property
    def srcHost(self):
        return <void_ptr>self._pvt_ptr[0].srcHost
    @srcHost.setter
    def srcHost(self, srcHost):
        _csrcHost = _HelperInputVoidPtr(srcHost)
        self._pvt_ptr[0].srcHost = <void*><void_ptr>_csrcHost.cptr
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcDevice' in found_struct}}
    @property
    def srcDevice(self):
        return self._srcDevice
    @srcDevice.setter
    def srcDevice(self, srcDevice):
        cdef cydriver.CUdeviceptr cysrcDevice
        if srcDevice is None:
            cysrcDevice = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(srcDevice, (CUdeviceptr)):
            psrcDevice = int(srcDevice)
            cysrcDevice = <cydriver.CUdeviceptr><void_ptr>psrcDevice
        else:
            psrcDevice = int(CUdeviceptr(srcDevice))
            cysrcDevice = <cydriver.CUdeviceptr><void_ptr>psrcDevice
        self._srcDevice._pvt_ptr[0] = cysrcDevice

    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcArray' in found_struct}}
    @property
    def srcArray(self):
        return self._srcArray
    @srcArray.setter
    def srcArray(self, srcArray):
        cdef cydriver.CUarray cysrcArray
        if srcArray is None:
            cysrcArray = <cydriver.CUarray><void_ptr>0
        elif isinstance(srcArray, (CUarray,)):
            psrcArray = int(srcArray)
            cysrcArray = <cydriver.CUarray><void_ptr>psrcArray
        else:
            psrcArray = int(CUarray(srcArray))
            cysrcArray = <cydriver.CUarray><void_ptr>psrcArray
        self._srcArray._pvt_ptr[0] = cysrcArray
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.reserved0' in found_struct}}
    @property
    def reserved0(self):
        return <void_ptr>self._pvt_ptr[0].reserved0
    @reserved0.setter
    def reserved0(self, reserved0):
        _creserved0 = _HelperInputVoidPtr(reserved0)
        self._pvt_ptr[0].reserved0 = <void*><void_ptr>_creserved0.cptr
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcPitch' in found_struct}}
    @property
    def srcPitch(self):
        return self._pvt_ptr[0].srcPitch
    @srcPitch.setter
    def srcPitch(self, size_t srcPitch):
        self._pvt_ptr[0].srcPitch = srcPitch
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.srcHeight' in found_struct}}
    @property
    def srcHeight(self):
        return self._pvt_ptr[0].srcHeight
    @srcHeight.setter
    def srcHeight(self, size_t srcHeight):
        self._pvt_ptr[0].srcHeight = srcHeight
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstXInBytes' in found_struct}}
    @property
    def dstXInBytes(self):
        return self._pvt_ptr[0].dstXInBytes
    @dstXInBytes.setter
    def dstXInBytes(self, size_t dstXInBytes):
        self._pvt_ptr[0].dstXInBytes = dstXInBytes
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstY' in found_struct}}
    @property
    def dstY(self):
        return self._pvt_ptr[0].dstY
    @dstY.setter
    def dstY(self, size_t dstY):
        self._pvt_ptr[0].dstY = dstY
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstZ' in found_struct}}
    @property
    def dstZ(self):
        return self._pvt_ptr[0].dstZ
    @dstZ.setter
    def dstZ(self, size_t dstZ):
        self._pvt_ptr[0].dstZ = dstZ
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstLOD' in found_struct}}
    @property
    def dstLOD(self):
        return self._pvt_ptr[0].dstLOD
    @dstLOD.setter
    def dstLOD(self, size_t dstLOD):
        self._pvt_ptr[0].dstLOD = dstLOD
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstMemoryType' in found_struct}}
    @property
    def dstMemoryType(self):
        if self._pvt_ptr[0].dstMemoryType not in _dict_CUmemorytype:
            return None
        return _dict_CUmemorytype[self._pvt_ptr[0].dstMemoryType]
    @dstMemoryType.setter
    def dstMemoryType(self, dstMemoryType not None : CUmemorytype):
        self._pvt_ptr[0].dstMemoryType = dstMemoryType.value
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstHost' in found_struct}}
    @property
    def dstHost(self):
        return <void_ptr>self._pvt_ptr[0].dstHost
    @dstHost.setter
    def dstHost(self, dstHost):
        _cdstHost = _HelperInputVoidPtr(dstHost)
        self._pvt_ptr[0].dstHost = <void*><void_ptr>_cdstHost.cptr
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstDevice' in found_struct}}
    @property
    def dstDevice(self):
        return self._dstDevice
    @dstDevice.setter
    def dstDevice(self, dstDevice):
        cdef cydriver.CUdeviceptr cydstDevice
        if dstDevice is None:
            cydstDevice = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(dstDevice, (CUdeviceptr)):
            pdstDevice = int(dstDevice)
            cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
        else:
            pdstDevice = int(CUdeviceptr(dstDevice))
            cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
        self._dstDevice._pvt_ptr[0] = cydstDevice

    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstArray' in found_struct}}
    @property
    def dstArray(self):
        return self._dstArray
    @dstArray.setter
    def dstArray(self, dstArray):
        cdef cydriver.CUarray cydstArray
        if dstArray is None:
            cydstArray = <cydriver.CUarray><void_ptr>0
        elif isinstance(dstArray, (CUarray,)):
            pdstArray = int(dstArray)
            cydstArray = <cydriver.CUarray><void_ptr>pdstArray
        else:
            pdstArray = int(CUarray(dstArray))
            cydstArray = <cydriver.CUarray><void_ptr>pdstArray
        self._dstArray._pvt_ptr[0] = cydstArray
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.reserved1' in found_struct}}
    @property
    def reserved1(self):
        return <void_ptr>self._pvt_ptr[0].reserved1
    @reserved1.setter
    def reserved1(self, reserved1):
        _creserved1 = _HelperInputVoidPtr(reserved1)
        self._pvt_ptr[0].reserved1 = <void*><void_ptr>_creserved1.cptr
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstPitch' in found_struct}}
    @property
    def dstPitch(self):
        return self._pvt_ptr[0].dstPitch
    @dstPitch.setter
    def dstPitch(self, size_t dstPitch):
        self._pvt_ptr[0].dstPitch = dstPitch
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.dstHeight' in found_struct}}
    @property
    def dstHeight(self):
        return self._pvt_ptr[0].dstHeight
    @dstHeight.setter
    def dstHeight(self, size_t dstHeight):
        self._pvt_ptr[0].dstHeight = dstHeight
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.WidthInBytes' in found_struct}}
    @property
    def WidthInBytes(self):
        return self._pvt_ptr[0].WidthInBytes
    @WidthInBytes.setter
    def WidthInBytes(self, size_t WidthInBytes):
        self._pvt_ptr[0].WidthInBytes = WidthInBytes
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.Height' in found_struct}}
    @property
    def Height(self):
        return self._pvt_ptr[0].Height
    @Height.setter
    def Height(self, size_t Height):
        self._pvt_ptr[0].Height = Height
    {{endif}}
    {{if 'CUDA_MEMCPY3D_st.Depth' in found_struct}}
    @property
    def Depth(self):
        return self._pvt_ptr[0].Depth
    @Depth.setter
    def Depth(self, size_t Depth):
        self._pvt_ptr[0].Depth = Depth
    {{endif}}
{{endif}}
{{if 'CUDA_MEMCPY3D_PEER_st' in found_struct}}

cdef class CUDA_MEMCPY3D_PEER_st:
    """
    3D memory cross-context copy parameters

    Attributes
    ----------
    {{if 'CUDA_MEMCPY3D_PEER_st.srcXInBytes' in found_struct}}
    srcXInBytes : size_t
        Source X in bytes
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcY' in found_struct}}
    srcY : size_t
        Source Y
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcZ' in found_struct}}
    srcZ : size_t
        Source Z
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcLOD' in found_struct}}
    srcLOD : size_t
        Source LOD
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcMemoryType' in found_struct}}
    srcMemoryType : CUmemorytype
        Source memory type (host, device, array)
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcHost' in found_struct}}
    srcHost : Any
        Source host pointer
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcDevice' in found_struct}}
    srcDevice : CUdeviceptr
        Source device pointer
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcArray' in found_struct}}
    srcArray : CUarray
        Source array reference
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcContext' in found_struct}}
    srcContext : CUcontext
        Source context (ignored with srcMemoryType is CU_MEMORYTYPE_ARRAY)
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcPitch' in found_struct}}
    srcPitch : size_t
        Source pitch (ignored when src is array)
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcHeight' in found_struct}}
    srcHeight : size_t
        Source height (ignored when src is array; may be 0 if Depth==1)
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstXInBytes' in found_struct}}
    dstXInBytes : size_t
        Destination X in bytes
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstY' in found_struct}}
    dstY : size_t
        Destination Y
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstZ' in found_struct}}
    dstZ : size_t
        Destination Z
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstLOD' in found_struct}}
    dstLOD : size_t
        Destination LOD
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstMemoryType' in found_struct}}
    dstMemoryType : CUmemorytype
        Destination memory type (host, device, array)
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstHost' in found_struct}}
    dstHost : Any
        Destination host pointer
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstDevice' in found_struct}}
    dstDevice : CUdeviceptr
        Destination device pointer
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstArray' in found_struct}}
    dstArray : CUarray
        Destination array reference
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstContext' in found_struct}}
    dstContext : CUcontext
        Destination context (ignored with dstMemoryType is
        CU_MEMORYTYPE_ARRAY)
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstPitch' in found_struct}}
    dstPitch : size_t
        Destination pitch (ignored when dst is array)
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstHeight' in found_struct}}
    dstHeight : size_t
        Destination height (ignored when dst is array; may be 0 if
        Depth==1)
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.WidthInBytes' in found_struct}}
    WidthInBytes : size_t
        Width of 3D memory copy in bytes
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.Height' in found_struct}}
    Height : size_t
        Height of 3D memory copy
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.Depth' in found_struct}}
    Depth : size_t
        Depth of 3D memory copy
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_MEMCPY3D_PEER_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_MEMCPY3D_PEER_st.srcDevice' in found_struct}}
        self._srcDevice = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].srcDevice)
        {{endif}}
        {{if 'CUDA_MEMCPY3D_PEER_st.srcArray' in found_struct}}
        self._srcArray = CUarray(_ptr=<void_ptr>&self._pvt_ptr[0].srcArray)
        {{endif}}
        {{if 'CUDA_MEMCPY3D_PEER_st.srcContext' in found_struct}}
        self._srcContext = CUcontext(_ptr=<void_ptr>&self._pvt_ptr[0].srcContext)
        {{endif}}
        {{if 'CUDA_MEMCPY3D_PEER_st.dstDevice' in found_struct}}
        self._dstDevice = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].dstDevice)
        {{endif}}
        {{if 'CUDA_MEMCPY3D_PEER_st.dstArray' in found_struct}}
        self._dstArray = CUarray(_ptr=<void_ptr>&self._pvt_ptr[0].dstArray)
        {{endif}}
        {{if 'CUDA_MEMCPY3D_PEER_st.dstContext' in found_struct}}
        self._dstContext = CUcontext(_ptr=<void_ptr>&self._pvt_ptr[0].dstContext)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_MEMCPY3D_PEER_st.srcXInBytes' in found_struct}}
            try:
                str_list += ['srcXInBytes : ' + str(self.srcXInBytes)]
            except ValueError:
                str_list += ['srcXInBytes : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.srcY' in found_struct}}
            try:
                str_list += ['srcY : ' + str(self.srcY)]
            except ValueError:
                str_list += ['srcY : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.srcZ' in found_struct}}
            try:
                str_list += ['srcZ : ' + str(self.srcZ)]
            except ValueError:
                str_list += ['srcZ : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.srcLOD' in found_struct}}
            try:
                str_list += ['srcLOD : ' + str(self.srcLOD)]
            except ValueError:
                str_list += ['srcLOD : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.srcMemoryType' in found_struct}}
            try:
                str_list += ['srcMemoryType : ' + str(self.srcMemoryType)]
            except ValueError:
                str_list += ['srcMemoryType : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.srcHost' in found_struct}}
            try:
                str_list += ['srcHost : ' + hex(self.srcHost)]
            except ValueError:
                str_list += ['srcHost : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.srcDevice' in found_struct}}
            try:
                str_list += ['srcDevice : ' + str(self.srcDevice)]
            except ValueError:
                str_list += ['srcDevice : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.srcArray' in found_struct}}
            try:
                str_list += ['srcArray : ' + str(self.srcArray)]
            except ValueError:
                str_list += ['srcArray : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.srcContext' in found_struct}}
            try:
                str_list += ['srcContext : ' + str(self.srcContext)]
            except ValueError:
                str_list += ['srcContext : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.srcPitch' in found_struct}}
            try:
                str_list += ['srcPitch : ' + str(self.srcPitch)]
            except ValueError:
                str_list += ['srcPitch : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.srcHeight' in found_struct}}
            try:
                str_list += ['srcHeight : ' + str(self.srcHeight)]
            except ValueError:
                str_list += ['srcHeight : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.dstXInBytes' in found_struct}}
            try:
                str_list += ['dstXInBytes : ' + str(self.dstXInBytes)]
            except ValueError:
                str_list += ['dstXInBytes : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.dstY' in found_struct}}
            try:
                str_list += ['dstY : ' + str(self.dstY)]
            except ValueError:
                str_list += ['dstY : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.dstZ' in found_struct}}
            try:
                str_list += ['dstZ : ' + str(self.dstZ)]
            except ValueError:
                str_list += ['dstZ : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.dstLOD' in found_struct}}
            try:
                str_list += ['dstLOD : ' + str(self.dstLOD)]
            except ValueError:
                str_list += ['dstLOD : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.dstMemoryType' in found_struct}}
            try:
                str_list += ['dstMemoryType : ' + str(self.dstMemoryType)]
            except ValueError:
                str_list += ['dstMemoryType : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.dstHost' in found_struct}}
            try:
                str_list += ['dstHost : ' + hex(self.dstHost)]
            except ValueError:
                str_list += ['dstHost : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.dstDevice' in found_struct}}
            try:
                str_list += ['dstDevice : ' + str(self.dstDevice)]
            except ValueError:
                str_list += ['dstDevice : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.dstArray' in found_struct}}
            try:
                str_list += ['dstArray : ' + str(self.dstArray)]
            except ValueError:
                str_list += ['dstArray : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.dstContext' in found_struct}}
            try:
                str_list += ['dstContext : ' + str(self.dstContext)]
            except ValueError:
                str_list += ['dstContext : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.dstPitch' in found_struct}}
            try:
                str_list += ['dstPitch : ' + str(self.dstPitch)]
            except ValueError:
                str_list += ['dstPitch : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.dstHeight' in found_struct}}
            try:
                str_list += ['dstHeight : ' + str(self.dstHeight)]
            except ValueError:
                str_list += ['dstHeight : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.WidthInBytes' in found_struct}}
            try:
                str_list += ['WidthInBytes : ' + str(self.WidthInBytes)]
            except ValueError:
                str_list += ['WidthInBytes : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.Height' in found_struct}}
            try:
                str_list += ['Height : ' + str(self.Height)]
            except ValueError:
                str_list += ['Height : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_PEER_st.Depth' in found_struct}}
            try:
                str_list += ['Depth : ' + str(self.Depth)]
            except ValueError:
                str_list += ['Depth : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_MEMCPY3D_PEER_st.srcXInBytes' in found_struct}}
    @property
    def srcXInBytes(self):
        return self._pvt_ptr[0].srcXInBytes
    @srcXInBytes.setter
    def srcXInBytes(self, size_t srcXInBytes):
        self._pvt_ptr[0].srcXInBytes = srcXInBytes
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcY' in found_struct}}
    @property
    def srcY(self):
        return self._pvt_ptr[0].srcY
    @srcY.setter
    def srcY(self, size_t srcY):
        self._pvt_ptr[0].srcY = srcY
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcZ' in found_struct}}
    @property
    def srcZ(self):
        return self._pvt_ptr[0].srcZ
    @srcZ.setter
    def srcZ(self, size_t srcZ):
        self._pvt_ptr[0].srcZ = srcZ
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcLOD' in found_struct}}
    @property
    def srcLOD(self):
        return self._pvt_ptr[0].srcLOD
    @srcLOD.setter
    def srcLOD(self, size_t srcLOD):
        self._pvt_ptr[0].srcLOD = srcLOD
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcMemoryType' in found_struct}}
    @property
    def srcMemoryType(self):
        if self._pvt_ptr[0].srcMemoryType not in _dict_CUmemorytype:
            return None
        return _dict_CUmemorytype[self._pvt_ptr[0].srcMemoryType]
    @srcMemoryType.setter
    def srcMemoryType(self, srcMemoryType not None : CUmemorytype):
        self._pvt_ptr[0].srcMemoryType = srcMemoryType.value
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcHost' in found_struct}}
    @property
    def srcHost(self):
        return <void_ptr>self._pvt_ptr[0].srcHost
    @srcHost.setter
    def srcHost(self, srcHost):
        _csrcHost = _HelperInputVoidPtr(srcHost)
        self._pvt_ptr[0].srcHost = <void*><void_ptr>_csrcHost.cptr
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcDevice' in found_struct}}
    @property
    def srcDevice(self):
        return self._srcDevice
    @srcDevice.setter
    def srcDevice(self, srcDevice):
        cdef cydriver.CUdeviceptr cysrcDevice
        if srcDevice is None:
            cysrcDevice = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(srcDevice, (CUdeviceptr)):
            psrcDevice = int(srcDevice)
            cysrcDevice = <cydriver.CUdeviceptr><void_ptr>psrcDevice
        else:
            psrcDevice = int(CUdeviceptr(srcDevice))
            cysrcDevice = <cydriver.CUdeviceptr><void_ptr>psrcDevice
        self._srcDevice._pvt_ptr[0] = cysrcDevice

    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcArray' in found_struct}}
    @property
    def srcArray(self):
        return self._srcArray
    @srcArray.setter
    def srcArray(self, srcArray):
        cdef cydriver.CUarray cysrcArray
        if srcArray is None:
            cysrcArray = <cydriver.CUarray><void_ptr>0
        elif isinstance(srcArray, (CUarray,)):
            psrcArray = int(srcArray)
            cysrcArray = <cydriver.CUarray><void_ptr>psrcArray
        else:
            psrcArray = int(CUarray(srcArray))
            cysrcArray = <cydriver.CUarray><void_ptr>psrcArray
        self._srcArray._pvt_ptr[0] = cysrcArray
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcContext' in found_struct}}
    @property
    def srcContext(self):
        return self._srcContext
    @srcContext.setter
    def srcContext(self, srcContext):
        cdef cydriver.CUcontext cysrcContext
        if srcContext is None:
            cysrcContext = <cydriver.CUcontext><void_ptr>0
        elif isinstance(srcContext, (CUcontext,)):
            psrcContext = int(srcContext)
            cysrcContext = <cydriver.CUcontext><void_ptr>psrcContext
        else:
            psrcContext = int(CUcontext(srcContext))
            cysrcContext = <cydriver.CUcontext><void_ptr>psrcContext
        self._srcContext._pvt_ptr[0] = cysrcContext
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcPitch' in found_struct}}
    @property
    def srcPitch(self):
        return self._pvt_ptr[0].srcPitch
    @srcPitch.setter
    def srcPitch(self, size_t srcPitch):
        self._pvt_ptr[0].srcPitch = srcPitch
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.srcHeight' in found_struct}}
    @property
    def srcHeight(self):
        return self._pvt_ptr[0].srcHeight
    @srcHeight.setter
    def srcHeight(self, size_t srcHeight):
        self._pvt_ptr[0].srcHeight = srcHeight
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstXInBytes' in found_struct}}
    @property
    def dstXInBytes(self):
        return self._pvt_ptr[0].dstXInBytes
    @dstXInBytes.setter
    def dstXInBytes(self, size_t dstXInBytes):
        self._pvt_ptr[0].dstXInBytes = dstXInBytes
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstY' in found_struct}}
    @property
    def dstY(self):
        return self._pvt_ptr[0].dstY
    @dstY.setter
    def dstY(self, size_t dstY):
        self._pvt_ptr[0].dstY = dstY
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstZ' in found_struct}}
    @property
    def dstZ(self):
        return self._pvt_ptr[0].dstZ
    @dstZ.setter
    def dstZ(self, size_t dstZ):
        self._pvt_ptr[0].dstZ = dstZ
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstLOD' in found_struct}}
    @property
    def dstLOD(self):
        return self._pvt_ptr[0].dstLOD
    @dstLOD.setter
    def dstLOD(self, size_t dstLOD):
        self._pvt_ptr[0].dstLOD = dstLOD
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstMemoryType' in found_struct}}
    @property
    def dstMemoryType(self):
        if self._pvt_ptr[0].dstMemoryType not in _dict_CUmemorytype:
            return None
        return _dict_CUmemorytype[self._pvt_ptr[0].dstMemoryType]
    @dstMemoryType.setter
    def dstMemoryType(self, dstMemoryType not None : CUmemorytype):
        self._pvt_ptr[0].dstMemoryType = dstMemoryType.value
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstHost' in found_struct}}
    @property
    def dstHost(self):
        return <void_ptr>self._pvt_ptr[0].dstHost
    @dstHost.setter
    def dstHost(self, dstHost):
        _cdstHost = _HelperInputVoidPtr(dstHost)
        self._pvt_ptr[0].dstHost = <void*><void_ptr>_cdstHost.cptr
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstDevice' in found_struct}}
    @property
    def dstDevice(self):
        return self._dstDevice
    @dstDevice.setter
    def dstDevice(self, dstDevice):
        cdef cydriver.CUdeviceptr cydstDevice
        if dstDevice is None:
            cydstDevice = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(dstDevice, (CUdeviceptr)):
            pdstDevice = int(dstDevice)
            cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
        else:
            pdstDevice = int(CUdeviceptr(dstDevice))
            cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
        self._dstDevice._pvt_ptr[0] = cydstDevice

    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstArray' in found_struct}}
    @property
    def dstArray(self):
        return self._dstArray
    @dstArray.setter
    def dstArray(self, dstArray):
        cdef cydriver.CUarray cydstArray
        if dstArray is None:
            cydstArray = <cydriver.CUarray><void_ptr>0
        elif isinstance(dstArray, (CUarray,)):
            pdstArray = int(dstArray)
            cydstArray = <cydriver.CUarray><void_ptr>pdstArray
        else:
            pdstArray = int(CUarray(dstArray))
            cydstArray = <cydriver.CUarray><void_ptr>pdstArray
        self._dstArray._pvt_ptr[0] = cydstArray
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstContext' in found_struct}}
    @property
    def dstContext(self):
        return self._dstContext
    @dstContext.setter
    def dstContext(self, dstContext):
        cdef cydriver.CUcontext cydstContext
        if dstContext is None:
            cydstContext = <cydriver.CUcontext><void_ptr>0
        elif isinstance(dstContext, (CUcontext,)):
            pdstContext = int(dstContext)
            cydstContext = <cydriver.CUcontext><void_ptr>pdstContext
        else:
            pdstContext = int(CUcontext(dstContext))
            cydstContext = <cydriver.CUcontext><void_ptr>pdstContext
        self._dstContext._pvt_ptr[0] = cydstContext
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstPitch' in found_struct}}
    @property
    def dstPitch(self):
        return self._pvt_ptr[0].dstPitch
    @dstPitch.setter
    def dstPitch(self, size_t dstPitch):
        self._pvt_ptr[0].dstPitch = dstPitch
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.dstHeight' in found_struct}}
    @property
    def dstHeight(self):
        return self._pvt_ptr[0].dstHeight
    @dstHeight.setter
    def dstHeight(self, size_t dstHeight):
        self._pvt_ptr[0].dstHeight = dstHeight
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.WidthInBytes' in found_struct}}
    @property
    def WidthInBytes(self):
        return self._pvt_ptr[0].WidthInBytes
    @WidthInBytes.setter
    def WidthInBytes(self, size_t WidthInBytes):
        self._pvt_ptr[0].WidthInBytes = WidthInBytes
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.Height' in found_struct}}
    @property
    def Height(self):
        return self._pvt_ptr[0].Height
    @Height.setter
    def Height(self, size_t Height):
        self._pvt_ptr[0].Height = Height
    {{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st.Depth' in found_struct}}
    @property
    def Depth(self):
        return self._pvt_ptr[0].Depth
    @Depth.setter
    def Depth(self, size_t Depth):
        self._pvt_ptr[0].Depth = Depth
    {{endif}}
{{endif}}
{{if 'CUDA_MEMCPY_NODE_PARAMS_st' in found_struct}}

cdef class CUDA_MEMCPY_NODE_PARAMS_st:
    """
    Memcpy node parameters

    Attributes
    ----------
    {{if 'CUDA_MEMCPY_NODE_PARAMS_st.flags' in found_struct}}
    flags : int
        Must be zero
    {{endif}}
    {{if 'CUDA_MEMCPY_NODE_PARAMS_st.reserved' in found_struct}}
    reserved : int
        Must be zero
    {{endif}}
    {{if 'CUDA_MEMCPY_NODE_PARAMS_st.copyCtx' in found_struct}}
    copyCtx : CUcontext
        Context on which to run the node
    {{endif}}
    {{if 'CUDA_MEMCPY_NODE_PARAMS_st.copyParams' in found_struct}}
    copyParams : CUDA_MEMCPY3D
        Parameters for the memory copy
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_MEMCPY_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_MEMCPY_NODE_PARAMS_st.copyCtx' in found_struct}}
        self._copyCtx = CUcontext(_ptr=<void_ptr>&self._pvt_ptr[0].copyCtx)
        {{endif}}
        {{if 'CUDA_MEMCPY_NODE_PARAMS_st.copyParams' in found_struct}}
        self._copyParams = CUDA_MEMCPY3D(_ptr=<void_ptr>&self._pvt_ptr[0].copyParams)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_MEMCPY_NODE_PARAMS_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY_NODE_PARAMS_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY_NODE_PARAMS_st.copyCtx' in found_struct}}
            try:
                str_list += ['copyCtx : ' + str(self.copyCtx)]
            except ValueError:
                str_list += ['copyCtx : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY_NODE_PARAMS_st.copyParams' in found_struct}}
            try:
                str_list += ['copyParams :\n' + '\n'.join(['    ' + line for line in str(self.copyParams).splitlines()])]
            except ValueError:
                str_list += ['copyParams : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_MEMCPY_NODE_PARAMS_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'CUDA_MEMCPY_NODE_PARAMS_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, int reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
    {{if 'CUDA_MEMCPY_NODE_PARAMS_st.copyCtx' in found_struct}}
    @property
    def copyCtx(self):
        return self._copyCtx
    @copyCtx.setter
    def copyCtx(self, copyCtx):
        cdef cydriver.CUcontext cycopyCtx
        if copyCtx is None:
            cycopyCtx = <cydriver.CUcontext><void_ptr>0
        elif isinstance(copyCtx, (CUcontext,)):
            pcopyCtx = int(copyCtx)
            cycopyCtx = <cydriver.CUcontext><void_ptr>pcopyCtx
        else:
            pcopyCtx = int(CUcontext(copyCtx))
            cycopyCtx = <cydriver.CUcontext><void_ptr>pcopyCtx
        self._copyCtx._pvt_ptr[0] = cycopyCtx
    {{endif}}
    {{if 'CUDA_MEMCPY_NODE_PARAMS_st.copyParams' in found_struct}}
    @property
    def copyParams(self):
        return self._copyParams
    @copyParams.setter
    def copyParams(self, copyParams not None : CUDA_MEMCPY3D):
        string.memcpy(&self._pvt_ptr[0].copyParams, <cydriver.CUDA_MEMCPY3D*><void_ptr>copyParams.getPtr(), sizeof(self._pvt_ptr[0].copyParams))
    {{endif}}
{{endif}}
{{if 'CUDA_ARRAY_DESCRIPTOR_st' in found_struct}}

cdef class CUDA_ARRAY_DESCRIPTOR_st:
    """
    Array descriptor

    Attributes
    ----------
    {{if 'CUDA_ARRAY_DESCRIPTOR_st.Width' in found_struct}}
    Width : size_t
        Width of array
    {{endif}}
    {{if 'CUDA_ARRAY_DESCRIPTOR_st.Height' in found_struct}}
    Height : size_t
        Height of array
    {{endif}}
    {{if 'CUDA_ARRAY_DESCRIPTOR_st.Format' in found_struct}}
    Format : CUarray_format
        Array format
    {{endif}}
    {{if 'CUDA_ARRAY_DESCRIPTOR_st.NumChannels' in found_struct}}
    NumChannels : unsigned int
        Channels per array element
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_ARRAY_DESCRIPTOR_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_ARRAY_DESCRIPTOR_st.Width' in found_struct}}
            try:
                str_list += ['Width : ' + str(self.Width)]
            except ValueError:
                str_list += ['Width : <ValueError>']
            {{endif}}
            {{if 'CUDA_ARRAY_DESCRIPTOR_st.Height' in found_struct}}
            try:
                str_list += ['Height : ' + str(self.Height)]
            except ValueError:
                str_list += ['Height : <ValueError>']
            {{endif}}
            {{if 'CUDA_ARRAY_DESCRIPTOR_st.Format' in found_struct}}
            try:
                str_list += ['Format : ' + str(self.Format)]
            except ValueError:
                str_list += ['Format : <ValueError>']
            {{endif}}
            {{if 'CUDA_ARRAY_DESCRIPTOR_st.NumChannels' in found_struct}}
            try:
                str_list += ['NumChannels : ' + str(self.NumChannels)]
            except ValueError:
                str_list += ['NumChannels : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_ARRAY_DESCRIPTOR_st.Width' in found_struct}}
    @property
    def Width(self):
        return self._pvt_ptr[0].Width
    @Width.setter
    def Width(self, size_t Width):
        self._pvt_ptr[0].Width = Width
    {{endif}}
    {{if 'CUDA_ARRAY_DESCRIPTOR_st.Height' in found_struct}}
    @property
    def Height(self):
        return self._pvt_ptr[0].Height
    @Height.setter
    def Height(self, size_t Height):
        self._pvt_ptr[0].Height = Height
    {{endif}}
    {{if 'CUDA_ARRAY_DESCRIPTOR_st.Format' in found_struct}}
    @property
    def Format(self):
        if self._pvt_ptr[0].Format not in _dict_CUarray_format:
            return None
        return _dict_CUarray_format[self._pvt_ptr[0].Format]
    @Format.setter
    def Format(self, Format not None : CUarray_format):
        self._pvt_ptr[0].Format = Format.value
    {{endif}}
    {{if 'CUDA_ARRAY_DESCRIPTOR_st.NumChannels' in found_struct}}
    @property
    def NumChannels(self):
        return self._pvt_ptr[0].NumChannels
    @NumChannels.setter
    def NumChannels(self, unsigned int NumChannels):
        self._pvt_ptr[0].NumChannels = NumChannels
    {{endif}}
{{endif}}
{{if 'CUDA_ARRAY3D_DESCRIPTOR_st' in found_struct}}

cdef class CUDA_ARRAY3D_DESCRIPTOR_st:
    """
    3D array descriptor

    Attributes
    ----------
    {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.Width' in found_struct}}
    Width : size_t
        Width of 3D array
    {{endif}}
    {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.Height' in found_struct}}
    Height : size_t
        Height of 3D array
    {{endif}}
    {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.Depth' in found_struct}}
    Depth : size_t
        Depth of 3D array
    {{endif}}
    {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.Format' in found_struct}}
    Format : CUarray_format
        Array format
    {{endif}}
    {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.NumChannels' in found_struct}}
    NumChannels : unsigned int
        Channels per array element
    {{endif}}
    {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.Flags' in found_struct}}
    Flags : unsigned int
        Flags
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_ARRAY3D_DESCRIPTOR_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.Width' in found_struct}}
            try:
                str_list += ['Width : ' + str(self.Width)]
            except ValueError:
                str_list += ['Width : <ValueError>']
            {{endif}}
            {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.Height' in found_struct}}
            try:
                str_list += ['Height : ' + str(self.Height)]
            except ValueError:
                str_list += ['Height : <ValueError>']
            {{endif}}
            {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.Depth' in found_struct}}
            try:
                str_list += ['Depth : ' + str(self.Depth)]
            except ValueError:
                str_list += ['Depth : <ValueError>']
            {{endif}}
            {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.Format' in found_struct}}
            try:
                str_list += ['Format : ' + str(self.Format)]
            except ValueError:
                str_list += ['Format : <ValueError>']
            {{endif}}
            {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.NumChannels' in found_struct}}
            try:
                str_list += ['NumChannels : ' + str(self.NumChannels)]
            except ValueError:
                str_list += ['NumChannels : <ValueError>']
            {{endif}}
            {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.Flags' in found_struct}}
            try:
                str_list += ['Flags : ' + str(self.Flags)]
            except ValueError:
                str_list += ['Flags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.Width' in found_struct}}
    @property
    def Width(self):
        return self._pvt_ptr[0].Width
    @Width.setter
    def Width(self, size_t Width):
        self._pvt_ptr[0].Width = Width
    {{endif}}
    {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.Height' in found_struct}}
    @property
    def Height(self):
        return self._pvt_ptr[0].Height
    @Height.setter
    def Height(self, size_t Height):
        self._pvt_ptr[0].Height = Height
    {{endif}}
    {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.Depth' in found_struct}}
    @property
    def Depth(self):
        return self._pvt_ptr[0].Depth
    @Depth.setter
    def Depth(self, size_t Depth):
        self._pvt_ptr[0].Depth = Depth
    {{endif}}
    {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.Format' in found_struct}}
    @property
    def Format(self):
        if self._pvt_ptr[0].Format not in _dict_CUarray_format:
            return None
        return _dict_CUarray_format[self._pvt_ptr[0].Format]
    @Format.setter
    def Format(self, Format not None : CUarray_format):
        self._pvt_ptr[0].Format = Format.value
    {{endif}}
    {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.NumChannels' in found_struct}}
    @property
    def NumChannels(self):
        return self._pvt_ptr[0].NumChannels
    @NumChannels.setter
    def NumChannels(self, unsigned int NumChannels):
        self._pvt_ptr[0].NumChannels = NumChannels
    {{endif}}
    {{if 'CUDA_ARRAY3D_DESCRIPTOR_st.Flags' in found_struct}}
    @property
    def Flags(self):
        return self._pvt_ptr[0].Flags
    @Flags.setter
    def Flags(self, unsigned int Flags):
        self._pvt_ptr[0].Flags = Flags
    {{endif}}
{{endif}}
{{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.tileExtent' in found_struct}}

cdef class anon_struct6:
    """
    Attributes
    ----------
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.tileExtent.width' in found_struct}}
    width : unsigned int

    {{endif}}
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.tileExtent.height' in found_struct}}
    height : unsigned int

    {{endif}}
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.tileExtent.depth' in found_struct}}
    depth : unsigned int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_ARRAY_SPARSE_PROPERTIES_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].tileExtent
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.tileExtent.width' in found_struct}}
            try:
                str_list += ['width : ' + str(self.width)]
            except ValueError:
                str_list += ['width : <ValueError>']
            {{endif}}
            {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.tileExtent.height' in found_struct}}
            try:
                str_list += ['height : ' + str(self.height)]
            except ValueError:
                str_list += ['height : <ValueError>']
            {{endif}}
            {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.tileExtent.depth' in found_struct}}
            try:
                str_list += ['depth : ' + str(self.depth)]
            except ValueError:
                str_list += ['depth : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.tileExtent.width' in found_struct}}
    @property
    def width(self):
        return self._pvt_ptr[0].tileExtent.width
    @width.setter
    def width(self, unsigned int width):
        self._pvt_ptr[0].tileExtent.width = width
    {{endif}}
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.tileExtent.height' in found_struct}}
    @property
    def height(self):
        return self._pvt_ptr[0].tileExtent.height
    @height.setter
    def height(self, unsigned int height):
        self._pvt_ptr[0].tileExtent.height = height
    {{endif}}
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.tileExtent.depth' in found_struct}}
    @property
    def depth(self):
        return self._pvt_ptr[0].tileExtent.depth
    @depth.setter
    def depth(self, unsigned int depth):
        self._pvt_ptr[0].tileExtent.depth = depth
    {{endif}}
{{endif}}
{{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st' in found_struct}}

cdef class CUDA_ARRAY_SPARSE_PROPERTIES_st:
    """
    CUDA array sparse properties

    Attributes
    ----------
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.tileExtent' in found_struct}}
    tileExtent : anon_struct6

    {{endif}}
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.miptailFirstLevel' in found_struct}}
    miptailFirstLevel : unsigned int
        First mip level at which the mip tail begins.
    {{endif}}
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.miptailSize' in found_struct}}
    miptailSize : unsigned long long
        Total size of the mip tail.
    {{endif}}
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.flags' in found_struct}}
    flags : unsigned int
        Flags will either be zero or
        CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL
    {{endif}}
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.reserved' in found_struct}}
    reserved : list[unsigned int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_ARRAY_SPARSE_PROPERTIES_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.tileExtent' in found_struct}}
        self._tileExtent = anon_struct6(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.tileExtent' in found_struct}}
            try:
                str_list += ['tileExtent :\n' + '\n'.join(['    ' + line for line in str(self.tileExtent).splitlines()])]
            except ValueError:
                str_list += ['tileExtent : <ValueError>']
            {{endif}}
            {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.miptailFirstLevel' in found_struct}}
            try:
                str_list += ['miptailFirstLevel : ' + str(self.miptailFirstLevel)]
            except ValueError:
                str_list += ['miptailFirstLevel : <ValueError>']
            {{endif}}
            {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.miptailSize' in found_struct}}
            try:
                str_list += ['miptailSize : ' + str(self.miptailSize)]
            except ValueError:
                str_list += ['miptailSize : <ValueError>']
            {{endif}}
            {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.tileExtent' in found_struct}}
    @property
    def tileExtent(self):
        return self._tileExtent
    @tileExtent.setter
    def tileExtent(self, tileExtent not None : anon_struct6):
        string.memcpy(&self._pvt_ptr[0].tileExtent, <cydriver.anon_struct6*><void_ptr>tileExtent.getPtr(), sizeof(self._pvt_ptr[0].tileExtent))
    {{endif}}
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.miptailFirstLevel' in found_struct}}
    @property
    def miptailFirstLevel(self):
        return self._pvt_ptr[0].miptailFirstLevel
    @miptailFirstLevel.setter
    def miptailFirstLevel(self, unsigned int miptailFirstLevel):
        self._pvt_ptr[0].miptailFirstLevel = miptailFirstLevel
    {{endif}}
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.miptailSize' in found_struct}}
    @property
    def miptailSize(self):
        return self._pvt_ptr[0].miptailSize
    @miptailSize.setter
    def miptailSize(self, unsigned long long miptailSize):
        self._pvt_ptr[0].miptailSize = miptailSize
    {{endif}}
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'CUDA_ARRAY_MEMORY_REQUIREMENTS_st' in found_struct}}

cdef class CUDA_ARRAY_MEMORY_REQUIREMENTS_st:
    """
    CUDA array memory requirements

    Attributes
    ----------
    {{if 'CUDA_ARRAY_MEMORY_REQUIREMENTS_st.size' in found_struct}}
    size : size_t
        Total required memory size
    {{endif}}
    {{if 'CUDA_ARRAY_MEMORY_REQUIREMENTS_st.alignment' in found_struct}}
    alignment : size_t
        alignment requirement
    {{endif}}
    {{if 'CUDA_ARRAY_MEMORY_REQUIREMENTS_st.reserved' in found_struct}}
    reserved : list[unsigned int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_ARRAY_MEMORY_REQUIREMENTS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_ARRAY_MEMORY_REQUIREMENTS_st.size' in found_struct}}
            try:
                str_list += ['size : ' + str(self.size)]
            except ValueError:
                str_list += ['size : <ValueError>']
            {{endif}}
            {{if 'CUDA_ARRAY_MEMORY_REQUIREMENTS_st.alignment' in found_struct}}
            try:
                str_list += ['alignment : ' + str(self.alignment)]
            except ValueError:
                str_list += ['alignment : <ValueError>']
            {{endif}}
            {{if 'CUDA_ARRAY_MEMORY_REQUIREMENTS_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_ARRAY_MEMORY_REQUIREMENTS_st.size' in found_struct}}
    @property
    def size(self):
        return self._pvt_ptr[0].size
    @size.setter
    def size(self, size_t size):
        self._pvt_ptr[0].size = size
    {{endif}}
    {{if 'CUDA_ARRAY_MEMORY_REQUIREMENTS_st.alignment' in found_struct}}
    @property
    def alignment(self):
        return self._pvt_ptr[0].alignment
    @alignment.setter
    def alignment(self, size_t alignment):
        self._pvt_ptr[0].alignment = alignment
    {{endif}}
    {{if 'CUDA_ARRAY_MEMORY_REQUIREMENTS_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'CUDA_RESOURCE_DESC_st.res.array' in found_struct}}

cdef class anon_struct7:
    """
    Attributes
    ----------
    {{if 'CUDA_RESOURCE_DESC_st.res.array.hArray' in found_struct}}
    hArray : CUarray

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_RESOURCE_DESC_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUDA_RESOURCE_DESC_st.res.array.hArray' in found_struct}}
        self._hArray = CUarray(_ptr=<void_ptr>&self._pvt_ptr[0].res.array.hArray)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].res.array
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_RESOURCE_DESC_st.res.array.hArray' in found_struct}}
            try:
                str_list += ['hArray : ' + str(self.hArray)]
            except ValueError:
                str_list += ['hArray : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_RESOURCE_DESC_st.res.array.hArray' in found_struct}}
    @property
    def hArray(self):
        return self._hArray
    @hArray.setter
    def hArray(self, hArray):
        cdef cydriver.CUarray cyhArray
        if hArray is None:
            cyhArray = <cydriver.CUarray><void_ptr>0
        elif isinstance(hArray, (CUarray,)):
            phArray = int(hArray)
            cyhArray = <cydriver.CUarray><void_ptr>phArray
        else:
            phArray = int(CUarray(hArray))
            cyhArray = <cydriver.CUarray><void_ptr>phArray
        self._hArray._pvt_ptr[0] = cyhArray
    {{endif}}
{{endif}}
{{if 'CUDA_RESOURCE_DESC_st.res.mipmap' in found_struct}}

cdef class anon_struct8:
    """
    Attributes
    ----------
    {{if 'CUDA_RESOURCE_DESC_st.res.mipmap.hMipmappedArray' in found_struct}}
    hMipmappedArray : CUmipmappedArray

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_RESOURCE_DESC_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUDA_RESOURCE_DESC_st.res.mipmap.hMipmappedArray' in found_struct}}
        self._hMipmappedArray = CUmipmappedArray(_ptr=<void_ptr>&self._pvt_ptr[0].res.mipmap.hMipmappedArray)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].res.mipmap
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_RESOURCE_DESC_st.res.mipmap.hMipmappedArray' in found_struct}}
            try:
                str_list += ['hMipmappedArray : ' + str(self.hMipmappedArray)]
            except ValueError:
                str_list += ['hMipmappedArray : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_RESOURCE_DESC_st.res.mipmap.hMipmappedArray' in found_struct}}
    @property
    def hMipmappedArray(self):
        return self._hMipmappedArray
    @hMipmappedArray.setter
    def hMipmappedArray(self, hMipmappedArray):
        cdef cydriver.CUmipmappedArray cyhMipmappedArray
        if hMipmappedArray is None:
            cyhMipmappedArray = <cydriver.CUmipmappedArray><void_ptr>0
        elif isinstance(hMipmappedArray, (CUmipmappedArray,)):
            phMipmappedArray = int(hMipmappedArray)
            cyhMipmappedArray = <cydriver.CUmipmappedArray><void_ptr>phMipmappedArray
        else:
            phMipmappedArray = int(CUmipmappedArray(hMipmappedArray))
            cyhMipmappedArray = <cydriver.CUmipmappedArray><void_ptr>phMipmappedArray
        self._hMipmappedArray._pvt_ptr[0] = cyhMipmappedArray
    {{endif}}
{{endif}}
{{if 'CUDA_RESOURCE_DESC_st.res.linear' in found_struct}}

cdef class anon_struct9:
    """
    Attributes
    ----------
    {{if 'CUDA_RESOURCE_DESC_st.res.linear.devPtr' in found_struct}}
    devPtr : CUdeviceptr

    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.linear.format' in found_struct}}
    format : CUarray_format

    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.linear.numChannels' in found_struct}}
    numChannels : unsigned int

    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.linear.sizeInBytes' in found_struct}}
    sizeInBytes : size_t

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_RESOURCE_DESC_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUDA_RESOURCE_DESC_st.res.linear.devPtr' in found_struct}}
        self._devPtr = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].res.linear.devPtr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].res.linear
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_RESOURCE_DESC_st.res.linear.devPtr' in found_struct}}
            try:
                str_list += ['devPtr : ' + str(self.devPtr)]
            except ValueError:
                str_list += ['devPtr : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_DESC_st.res.linear.format' in found_struct}}
            try:
                str_list += ['format : ' + str(self.format)]
            except ValueError:
                str_list += ['format : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_DESC_st.res.linear.numChannels' in found_struct}}
            try:
                str_list += ['numChannels : ' + str(self.numChannels)]
            except ValueError:
                str_list += ['numChannels : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_DESC_st.res.linear.sizeInBytes' in found_struct}}
            try:
                str_list += ['sizeInBytes : ' + str(self.sizeInBytes)]
            except ValueError:
                str_list += ['sizeInBytes : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_RESOURCE_DESC_st.res.linear.devPtr' in found_struct}}
    @property
    def devPtr(self):
        return self._devPtr
    @devPtr.setter
    def devPtr(self, devPtr):
        cdef cydriver.CUdeviceptr cydevPtr
        if devPtr is None:
            cydevPtr = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(devPtr, (CUdeviceptr)):
            pdevPtr = int(devPtr)
            cydevPtr = <cydriver.CUdeviceptr><void_ptr>pdevPtr
        else:
            pdevPtr = int(CUdeviceptr(devPtr))
            cydevPtr = <cydriver.CUdeviceptr><void_ptr>pdevPtr
        self._devPtr._pvt_ptr[0] = cydevPtr

    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.linear.format' in found_struct}}
    @property
    def format(self):
        if self._pvt_ptr[0].res.linear.format not in _dict_CUarray_format:
            return None
        return _dict_CUarray_format[self._pvt_ptr[0].res.linear.format]
    @format.setter
    def format(self, format not None : CUarray_format):
        self._pvt_ptr[0].res.linear.format = format.value
    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.linear.numChannels' in found_struct}}
    @property
    def numChannels(self):
        return self._pvt_ptr[0].res.linear.numChannels
    @numChannels.setter
    def numChannels(self, unsigned int numChannels):
        self._pvt_ptr[0].res.linear.numChannels = numChannels
    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.linear.sizeInBytes' in found_struct}}
    @property
    def sizeInBytes(self):
        return self._pvt_ptr[0].res.linear.sizeInBytes
    @sizeInBytes.setter
    def sizeInBytes(self, size_t sizeInBytes):
        self._pvt_ptr[0].res.linear.sizeInBytes = sizeInBytes
    {{endif}}
{{endif}}
{{if 'CUDA_RESOURCE_DESC_st.res.pitch2D' in found_struct}}

cdef class anon_struct10:
    """
    Attributes
    ----------
    {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.devPtr' in found_struct}}
    devPtr : CUdeviceptr

    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.format' in found_struct}}
    format : CUarray_format

    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.numChannels' in found_struct}}
    numChannels : unsigned int

    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.width' in found_struct}}
    width : size_t

    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.height' in found_struct}}
    height : size_t

    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.pitchInBytes' in found_struct}}
    pitchInBytes : size_t

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_RESOURCE_DESC_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.devPtr' in found_struct}}
        self._devPtr = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].res.pitch2D.devPtr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].res.pitch2D
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.devPtr' in found_struct}}
            try:
                str_list += ['devPtr : ' + str(self.devPtr)]
            except ValueError:
                str_list += ['devPtr : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.format' in found_struct}}
            try:
                str_list += ['format : ' + str(self.format)]
            except ValueError:
                str_list += ['format : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.numChannels' in found_struct}}
            try:
                str_list += ['numChannels : ' + str(self.numChannels)]
            except ValueError:
                str_list += ['numChannels : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.width' in found_struct}}
            try:
                str_list += ['width : ' + str(self.width)]
            except ValueError:
                str_list += ['width : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.height' in found_struct}}
            try:
                str_list += ['height : ' + str(self.height)]
            except ValueError:
                str_list += ['height : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.pitchInBytes' in found_struct}}
            try:
                str_list += ['pitchInBytes : ' + str(self.pitchInBytes)]
            except ValueError:
                str_list += ['pitchInBytes : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.devPtr' in found_struct}}
    @property
    def devPtr(self):
        return self._devPtr
    @devPtr.setter
    def devPtr(self, devPtr):
        cdef cydriver.CUdeviceptr cydevPtr
        if devPtr is None:
            cydevPtr = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(devPtr, (CUdeviceptr)):
            pdevPtr = int(devPtr)
            cydevPtr = <cydriver.CUdeviceptr><void_ptr>pdevPtr
        else:
            pdevPtr = int(CUdeviceptr(devPtr))
            cydevPtr = <cydriver.CUdeviceptr><void_ptr>pdevPtr
        self._devPtr._pvt_ptr[0] = cydevPtr

    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.format' in found_struct}}
    @property
    def format(self):
        if self._pvt_ptr[0].res.pitch2D.format not in _dict_CUarray_format:
            return None
        return _dict_CUarray_format[self._pvt_ptr[0].res.pitch2D.format]
    @format.setter
    def format(self, format not None : CUarray_format):
        self._pvt_ptr[0].res.pitch2D.format = format.value
    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.numChannels' in found_struct}}
    @property
    def numChannels(self):
        return self._pvt_ptr[0].res.pitch2D.numChannels
    @numChannels.setter
    def numChannels(self, unsigned int numChannels):
        self._pvt_ptr[0].res.pitch2D.numChannels = numChannels
    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.width' in found_struct}}
    @property
    def width(self):
        return self._pvt_ptr[0].res.pitch2D.width
    @width.setter
    def width(self, size_t width):
        self._pvt_ptr[0].res.pitch2D.width = width
    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.height' in found_struct}}
    @property
    def height(self):
        return self._pvt_ptr[0].res.pitch2D.height
    @height.setter
    def height(self, size_t height):
        self._pvt_ptr[0].res.pitch2D.height = height
    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D.pitchInBytes' in found_struct}}
    @property
    def pitchInBytes(self):
        return self._pvt_ptr[0].res.pitch2D.pitchInBytes
    @pitchInBytes.setter
    def pitchInBytes(self, size_t pitchInBytes):
        self._pvt_ptr[0].res.pitch2D.pitchInBytes = pitchInBytes
    {{endif}}
{{endif}}
{{if 'CUDA_RESOURCE_DESC_st.res.reserved' in found_struct}}

cdef class anon_struct11:
    """
    Attributes
    ----------
    {{if 'CUDA_RESOURCE_DESC_st.res.reserved.reserved' in found_struct}}
    reserved : list[int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_RESOURCE_DESC_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].res.reserved
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_RESOURCE_DESC_st.res.reserved.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_RESOURCE_DESC_st.res.reserved.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].res.reserved.reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].res.reserved.reserved = reserved
    {{endif}}
{{endif}}
{{if 'CUDA_RESOURCE_DESC_st.res' in found_struct}}

cdef class anon_union4:
    """
    Attributes
    ----------
    {{if 'CUDA_RESOURCE_DESC_st.res.array' in found_struct}}
    array : anon_struct7

    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.mipmap' in found_struct}}
    mipmap : anon_struct8

    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.linear' in found_struct}}
    linear : anon_struct9

    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D' in found_struct}}
    pitch2D : anon_struct10

    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.reserved' in found_struct}}
    reserved : anon_struct11

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_RESOURCE_DESC_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUDA_RESOURCE_DESC_st.res.array' in found_struct}}
        self._array = anon_struct7(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUDA_RESOURCE_DESC_st.res.mipmap' in found_struct}}
        self._mipmap = anon_struct8(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUDA_RESOURCE_DESC_st.res.linear' in found_struct}}
        self._linear = anon_struct9(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D' in found_struct}}
        self._pitch2D = anon_struct10(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUDA_RESOURCE_DESC_st.res.reserved' in found_struct}}
        self._reserved = anon_struct11(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].res
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_RESOURCE_DESC_st.res.array' in found_struct}}
            try:
                str_list += ['array :\n' + '\n'.join(['    ' + line for line in str(self.array).splitlines()])]
            except ValueError:
                str_list += ['array : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_DESC_st.res.mipmap' in found_struct}}
            try:
                str_list += ['mipmap :\n' + '\n'.join(['    ' + line for line in str(self.mipmap).splitlines()])]
            except ValueError:
                str_list += ['mipmap : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_DESC_st.res.linear' in found_struct}}
            try:
                str_list += ['linear :\n' + '\n'.join(['    ' + line for line in str(self.linear).splitlines()])]
            except ValueError:
                str_list += ['linear : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D' in found_struct}}
            try:
                str_list += ['pitch2D :\n' + '\n'.join(['    ' + line for line in str(self.pitch2D).splitlines()])]
            except ValueError:
                str_list += ['pitch2D : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_DESC_st.res.reserved' in found_struct}}
            try:
                str_list += ['reserved :\n' + '\n'.join(['    ' + line for line in str(self.reserved).splitlines()])]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_RESOURCE_DESC_st.res.array' in found_struct}}
    @property
    def array(self):
        return self._array
    @array.setter
    def array(self, array not None : anon_struct7):
        string.memcpy(&self._pvt_ptr[0].res.array, <cydriver.anon_struct7*><void_ptr>array.getPtr(), sizeof(self._pvt_ptr[0].res.array))
    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.mipmap' in found_struct}}
    @property
    def mipmap(self):
        return self._mipmap
    @mipmap.setter
    def mipmap(self, mipmap not None : anon_struct8):
        string.memcpy(&self._pvt_ptr[0].res.mipmap, <cydriver.anon_struct8*><void_ptr>mipmap.getPtr(), sizeof(self._pvt_ptr[0].res.mipmap))
    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.linear' in found_struct}}
    @property
    def linear(self):
        return self._linear
    @linear.setter
    def linear(self, linear not None : anon_struct9):
        string.memcpy(&self._pvt_ptr[0].res.linear, <cydriver.anon_struct9*><void_ptr>linear.getPtr(), sizeof(self._pvt_ptr[0].res.linear))
    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.pitch2D' in found_struct}}
    @property
    def pitch2D(self):
        return self._pitch2D
    @pitch2D.setter
    def pitch2D(self, pitch2D not None : anon_struct10):
        string.memcpy(&self._pvt_ptr[0].res.pitch2D, <cydriver.anon_struct10*><void_ptr>pitch2D.getPtr(), sizeof(self._pvt_ptr[0].res.pitch2D))
    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._reserved
    @reserved.setter
    def reserved(self, reserved not None : anon_struct11):
        string.memcpy(&self._pvt_ptr[0].res.reserved, <cydriver.anon_struct11*><void_ptr>reserved.getPtr(), sizeof(self._pvt_ptr[0].res.reserved))
    {{endif}}
{{endif}}
{{if 'CUDA_RESOURCE_DESC_st' in found_struct}}

cdef class CUDA_RESOURCE_DESC_st:
    """
    CUDA Resource descriptor

    Attributes
    ----------
    {{if 'CUDA_RESOURCE_DESC_st.resType' in found_struct}}
    resType : CUresourcetype
        Resource type
    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res' in found_struct}}
    res : anon_union4

    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.flags' in found_struct}}
    flags : unsigned int
        Flags (must be zero)
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cydriver.CUDA_RESOURCE_DESC_st *>calloc(1, sizeof(cydriver.CUDA_RESOURCE_DESC_st))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cydriver.CUDA_RESOURCE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_RESOURCE_DESC_st.res' in found_struct}}
        self._res = anon_union4(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_RESOURCE_DESC_st.resType' in found_struct}}
            try:
                str_list += ['resType : ' + str(self.resType)]
            except ValueError:
                str_list += ['resType : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_DESC_st.res' in found_struct}}
            try:
                str_list += ['res :\n' + '\n'.join(['    ' + line for line in str(self.res).splitlines()])]
            except ValueError:
                str_list += ['res : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_DESC_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_RESOURCE_DESC_st.resType' in found_struct}}
    @property
    def resType(self):
        if self._pvt_ptr[0].resType not in _dict_CUresourcetype:
            return None
        return _dict_CUresourcetype[self._pvt_ptr[0].resType]
    @resType.setter
    def resType(self, resType not None : CUresourcetype):
        self._pvt_ptr[0].resType = resType.value
    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.res' in found_struct}}
    @property
    def res(self):
        return self._res
    @res.setter
    def res(self, res not None : anon_union4):
        string.memcpy(&self._pvt_ptr[0].res, <cydriver.anon_union4*><void_ptr>res.getPtr(), sizeof(self._pvt_ptr[0].res))
    {{endif}}
    {{if 'CUDA_RESOURCE_DESC_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
{{endif}}
{{if 'CUDA_TEXTURE_DESC_st' in found_struct}}

cdef class CUDA_TEXTURE_DESC_st:
    """
    Texture descriptor

    Attributes
    ----------
    {{if 'CUDA_TEXTURE_DESC_st.addressMode' in found_struct}}
    addressMode : list[CUaddress_mode]
        Address modes
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.filterMode' in found_struct}}
    filterMode : CUfilter_mode
        Filter mode
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.flags' in found_struct}}
    flags : unsigned int
        Flags
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.maxAnisotropy' in found_struct}}
    maxAnisotropy : unsigned int
        Maximum anisotropy ratio
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.mipmapFilterMode' in found_struct}}
    mipmapFilterMode : CUfilter_mode
        Mipmap filter mode
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.mipmapLevelBias' in found_struct}}
    mipmapLevelBias : float
        Mipmap level bias
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.minMipmapLevelClamp' in found_struct}}
    minMipmapLevelClamp : float
        Mipmap minimum level clamp
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.maxMipmapLevelClamp' in found_struct}}
    maxMipmapLevelClamp : float
        Mipmap maximum level clamp
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.borderColor' in found_struct}}
    borderColor : list[float]
        Border Color
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.reserved' in found_struct}}
    reserved : list[int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_TEXTURE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_TEXTURE_DESC_st.addressMode' in found_struct}}
            try:
                str_list += ['addressMode : ' + str(self.addressMode)]
            except ValueError:
                str_list += ['addressMode : <ValueError>']
            {{endif}}
            {{if 'CUDA_TEXTURE_DESC_st.filterMode' in found_struct}}
            try:
                str_list += ['filterMode : ' + str(self.filterMode)]
            except ValueError:
                str_list += ['filterMode : <ValueError>']
            {{endif}}
            {{if 'CUDA_TEXTURE_DESC_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'CUDA_TEXTURE_DESC_st.maxAnisotropy' in found_struct}}
            try:
                str_list += ['maxAnisotropy : ' + str(self.maxAnisotropy)]
            except ValueError:
                str_list += ['maxAnisotropy : <ValueError>']
            {{endif}}
            {{if 'CUDA_TEXTURE_DESC_st.mipmapFilterMode' in found_struct}}
            try:
                str_list += ['mipmapFilterMode : ' + str(self.mipmapFilterMode)]
            except ValueError:
                str_list += ['mipmapFilterMode : <ValueError>']
            {{endif}}
            {{if 'CUDA_TEXTURE_DESC_st.mipmapLevelBias' in found_struct}}
            try:
                str_list += ['mipmapLevelBias : ' + str(self.mipmapLevelBias)]
            except ValueError:
                str_list += ['mipmapLevelBias : <ValueError>']
            {{endif}}
            {{if 'CUDA_TEXTURE_DESC_st.minMipmapLevelClamp' in found_struct}}
            try:
                str_list += ['minMipmapLevelClamp : ' + str(self.minMipmapLevelClamp)]
            except ValueError:
                str_list += ['minMipmapLevelClamp : <ValueError>']
            {{endif}}
            {{if 'CUDA_TEXTURE_DESC_st.maxMipmapLevelClamp' in found_struct}}
            try:
                str_list += ['maxMipmapLevelClamp : ' + str(self.maxMipmapLevelClamp)]
            except ValueError:
                str_list += ['maxMipmapLevelClamp : <ValueError>']
            {{endif}}
            {{if 'CUDA_TEXTURE_DESC_st.borderColor' in found_struct}}
            try:
                str_list += ['borderColor : ' + str(self.borderColor)]
            except ValueError:
                str_list += ['borderColor : <ValueError>']
            {{endif}}
            {{if 'CUDA_TEXTURE_DESC_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_TEXTURE_DESC_st.addressMode' in found_struct}}
    @property
    def addressMode(self):
        return [_dict_CUaddress_mode[_x] if _x in _dict_CUaddress_mode else None for _x in list(self._pvt_ptr[0].addressMode)]
    @addressMode.setter
    def addressMode(self, addressMode):
        self._pvt_ptr[0].addressMode = [_x.value for _x in addressMode]
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.filterMode' in found_struct}}
    @property
    def filterMode(self):
        if self._pvt_ptr[0].filterMode not in _dict_CUfilter_mode:
            return None
        return _dict_CUfilter_mode[self._pvt_ptr[0].filterMode]
    @filterMode.setter
    def filterMode(self, filterMode not None : CUfilter_mode):
        self._pvt_ptr[0].filterMode = filterMode.value
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.maxAnisotropy' in found_struct}}
    @property
    def maxAnisotropy(self):
        return self._pvt_ptr[0].maxAnisotropy
    @maxAnisotropy.setter
    def maxAnisotropy(self, unsigned int maxAnisotropy):
        self._pvt_ptr[0].maxAnisotropy = maxAnisotropy
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.mipmapFilterMode' in found_struct}}
    @property
    def mipmapFilterMode(self):
        if self._pvt_ptr[0].mipmapFilterMode not in _dict_CUfilter_mode:
            return None
        return _dict_CUfilter_mode[self._pvt_ptr[0].mipmapFilterMode]
    @mipmapFilterMode.setter
    def mipmapFilterMode(self, mipmapFilterMode not None : CUfilter_mode):
        self._pvt_ptr[0].mipmapFilterMode = mipmapFilterMode.value
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.mipmapLevelBias' in found_struct}}
    @property
    def mipmapLevelBias(self):
        return self._pvt_ptr[0].mipmapLevelBias
    @mipmapLevelBias.setter
    def mipmapLevelBias(self, float mipmapLevelBias):
        self._pvt_ptr[0].mipmapLevelBias = mipmapLevelBias
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.minMipmapLevelClamp' in found_struct}}
    @property
    def minMipmapLevelClamp(self):
        return self._pvt_ptr[0].minMipmapLevelClamp
    @minMipmapLevelClamp.setter
    def minMipmapLevelClamp(self, float minMipmapLevelClamp):
        self._pvt_ptr[0].minMipmapLevelClamp = minMipmapLevelClamp
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.maxMipmapLevelClamp' in found_struct}}
    @property
    def maxMipmapLevelClamp(self):
        return self._pvt_ptr[0].maxMipmapLevelClamp
    @maxMipmapLevelClamp.setter
    def maxMipmapLevelClamp(self, float maxMipmapLevelClamp):
        self._pvt_ptr[0].maxMipmapLevelClamp = maxMipmapLevelClamp
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.borderColor' in found_struct}}
    @property
    def borderColor(self):
        return self._pvt_ptr[0].borderColor
    @borderColor.setter
    def borderColor(self, borderColor):
        self._pvt_ptr[0].borderColor = borderColor
    {{endif}}
    {{if 'CUDA_TEXTURE_DESC_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'CUDA_RESOURCE_VIEW_DESC_st' in found_struct}}

cdef class CUDA_RESOURCE_VIEW_DESC_st:
    """
    Resource view descriptor

    Attributes
    ----------
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.format' in found_struct}}
    format : CUresourceViewFormat
        Resource view format
    {{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.width' in found_struct}}
    width : size_t
        Width of the resource view
    {{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.height' in found_struct}}
    height : size_t
        Height of the resource view
    {{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.depth' in found_struct}}
    depth : size_t
        Depth of the resource view
    {{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.firstMipmapLevel' in found_struct}}
    firstMipmapLevel : unsigned int
        First defined mipmap level
    {{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.lastMipmapLevel' in found_struct}}
    lastMipmapLevel : unsigned int
        Last defined mipmap level
    {{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.firstLayer' in found_struct}}
    firstLayer : unsigned int
        First layer index
    {{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.lastLayer' in found_struct}}
    lastLayer : unsigned int
        Last layer index
    {{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.reserved' in found_struct}}
    reserved : list[unsigned int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_RESOURCE_VIEW_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_RESOURCE_VIEW_DESC_st.format' in found_struct}}
            try:
                str_list += ['format : ' + str(self.format)]
            except ValueError:
                str_list += ['format : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_VIEW_DESC_st.width' in found_struct}}
            try:
                str_list += ['width : ' + str(self.width)]
            except ValueError:
                str_list += ['width : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_VIEW_DESC_st.height' in found_struct}}
            try:
                str_list += ['height : ' + str(self.height)]
            except ValueError:
                str_list += ['height : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_VIEW_DESC_st.depth' in found_struct}}
            try:
                str_list += ['depth : ' + str(self.depth)]
            except ValueError:
                str_list += ['depth : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_VIEW_DESC_st.firstMipmapLevel' in found_struct}}
            try:
                str_list += ['firstMipmapLevel : ' + str(self.firstMipmapLevel)]
            except ValueError:
                str_list += ['firstMipmapLevel : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_VIEW_DESC_st.lastMipmapLevel' in found_struct}}
            try:
                str_list += ['lastMipmapLevel : ' + str(self.lastMipmapLevel)]
            except ValueError:
                str_list += ['lastMipmapLevel : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_VIEW_DESC_st.firstLayer' in found_struct}}
            try:
                str_list += ['firstLayer : ' + str(self.firstLayer)]
            except ValueError:
                str_list += ['firstLayer : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_VIEW_DESC_st.lastLayer' in found_struct}}
            try:
                str_list += ['lastLayer : ' + str(self.lastLayer)]
            except ValueError:
                str_list += ['lastLayer : <ValueError>']
            {{endif}}
            {{if 'CUDA_RESOURCE_VIEW_DESC_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.format' in found_struct}}
    @property
    def format(self):
        if self._pvt_ptr[0].format not in _dict_CUresourceViewFormat:
            return None
        return _dict_CUresourceViewFormat[self._pvt_ptr[0].format]
    @format.setter
    def format(self, format not None : CUresourceViewFormat):
        self._pvt_ptr[0].format = format.value
    {{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.width' in found_struct}}
    @property
    def width(self):
        return self._pvt_ptr[0].width
    @width.setter
    def width(self, size_t width):
        self._pvt_ptr[0].width = width
    {{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.height' in found_struct}}
    @property
    def height(self):
        return self._pvt_ptr[0].height
    @height.setter
    def height(self, size_t height):
        self._pvt_ptr[0].height = height
    {{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.depth' in found_struct}}
    @property
    def depth(self):
        return self._pvt_ptr[0].depth
    @depth.setter
    def depth(self, size_t depth):
        self._pvt_ptr[0].depth = depth
    {{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.firstMipmapLevel' in found_struct}}
    @property
    def firstMipmapLevel(self):
        return self._pvt_ptr[0].firstMipmapLevel
    @firstMipmapLevel.setter
    def firstMipmapLevel(self, unsigned int firstMipmapLevel):
        self._pvt_ptr[0].firstMipmapLevel = firstMipmapLevel
    {{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.lastMipmapLevel' in found_struct}}
    @property
    def lastMipmapLevel(self):
        return self._pvt_ptr[0].lastMipmapLevel
    @lastMipmapLevel.setter
    def lastMipmapLevel(self, unsigned int lastMipmapLevel):
        self._pvt_ptr[0].lastMipmapLevel = lastMipmapLevel
    {{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.firstLayer' in found_struct}}
    @property
    def firstLayer(self):
        return self._pvt_ptr[0].firstLayer
    @firstLayer.setter
    def firstLayer(self, unsigned int firstLayer):
        self._pvt_ptr[0].firstLayer = firstLayer
    {{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.lastLayer' in found_struct}}
    @property
    def lastLayer(self):
        return self._pvt_ptr[0].lastLayer
    @lastLayer.setter
    def lastLayer(self, unsigned int lastLayer):
        self._pvt_ptr[0].lastLayer = lastLayer
    {{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'CUtensorMap_st' in found_struct}}

cdef class CUtensorMap_st:
    """
    Tensor map descriptor. Requires compiler support for aligning to
    128 bytes.

    Attributes
    ----------
    {{if 'CUtensorMap_st.opaque' in found_struct}}
    opaque : list[cuuint64_t]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUtensorMap_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUtensorMap_st.opaque' in found_struct}}
            try:
                str_list += ['opaque : ' + str(self.opaque)]
            except ValueError:
                str_list += ['opaque : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUtensorMap_st.opaque' in found_struct}}
    @property
    def opaque(self):
        return [cuuint64_t(init_value=_opaque) for _opaque in self._pvt_ptr[0].opaque]
    @opaque.setter
    def opaque(self, opaque):
        self._pvt_ptr[0].opaque = opaque

    {{endif}}
{{endif}}
{{if 'CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st' in found_struct}}

cdef class CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st:
    """
    GPU Direct v3 tokens

    Attributes
    ----------
    {{if 'CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st.p2pToken' in found_struct}}
    p2pToken : unsigned long long

    {{endif}}
    {{if 'CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st.vaSpaceToken' in found_struct}}
    vaSpaceToken : unsigned int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st.p2pToken' in found_struct}}
            try:
                str_list += ['p2pToken : ' + str(self.p2pToken)]
            except ValueError:
                str_list += ['p2pToken : <ValueError>']
            {{endif}}
            {{if 'CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st.vaSpaceToken' in found_struct}}
            try:
                str_list += ['vaSpaceToken : ' + str(self.vaSpaceToken)]
            except ValueError:
                str_list += ['vaSpaceToken : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st.p2pToken' in found_struct}}
    @property
    def p2pToken(self):
        return self._pvt_ptr[0].p2pToken
    @p2pToken.setter
    def p2pToken(self, unsigned long long p2pToken):
        self._pvt_ptr[0].p2pToken = p2pToken
    {{endif}}
    {{if 'CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st.vaSpaceToken' in found_struct}}
    @property
    def vaSpaceToken(self):
        return self._pvt_ptr[0].vaSpaceToken
    @vaSpaceToken.setter
    def vaSpaceToken(self, unsigned int vaSpaceToken):
        self._pvt_ptr[0].vaSpaceToken = vaSpaceToken
    {{endif}}
{{endif}}
{{if 'CUDA_LAUNCH_PARAMS_st' in found_struct}}

cdef class CUDA_LAUNCH_PARAMS_st:
    """
    Kernel launch parameters

    Attributes
    ----------
    {{if 'CUDA_LAUNCH_PARAMS_st.function' in found_struct}}
    function : CUfunction
        Kernel to launch
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.gridDimX' in found_struct}}
    gridDimX : unsigned int
        Width of grid in blocks
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.gridDimY' in found_struct}}
    gridDimY : unsigned int
        Height of grid in blocks
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.gridDimZ' in found_struct}}
    gridDimZ : unsigned int
        Depth of grid in blocks
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.blockDimX' in found_struct}}
    blockDimX : unsigned int
        X dimension of each thread block
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.blockDimY' in found_struct}}
    blockDimY : unsigned int
        Y dimension of each thread block
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.blockDimZ' in found_struct}}
    blockDimZ : unsigned int
        Z dimension of each thread block
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.sharedMemBytes' in found_struct}}
    sharedMemBytes : unsigned int
        Dynamic shared-memory size per thread block in bytes
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.hStream' in found_struct}}
    hStream : CUstream
        Stream identifier
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.kernelParams' in found_struct}}
    kernelParams : Any
        Array of pointers to kernel parameters
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_LAUNCH_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_LAUNCH_PARAMS_st.function' in found_struct}}
        self._function = CUfunction(_ptr=<void_ptr>&self._pvt_ptr[0].function)
        {{endif}}
        {{if 'CUDA_LAUNCH_PARAMS_st.hStream' in found_struct}}
        self._hStream = CUstream(_ptr=<void_ptr>&self._pvt_ptr[0].hStream)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_LAUNCH_PARAMS_st.function' in found_struct}}
            try:
                str_list += ['function : ' + str(self.function)]
            except ValueError:
                str_list += ['function : <ValueError>']
            {{endif}}
            {{if 'CUDA_LAUNCH_PARAMS_st.gridDimX' in found_struct}}
            try:
                str_list += ['gridDimX : ' + str(self.gridDimX)]
            except ValueError:
                str_list += ['gridDimX : <ValueError>']
            {{endif}}
            {{if 'CUDA_LAUNCH_PARAMS_st.gridDimY' in found_struct}}
            try:
                str_list += ['gridDimY : ' + str(self.gridDimY)]
            except ValueError:
                str_list += ['gridDimY : <ValueError>']
            {{endif}}
            {{if 'CUDA_LAUNCH_PARAMS_st.gridDimZ' in found_struct}}
            try:
                str_list += ['gridDimZ : ' + str(self.gridDimZ)]
            except ValueError:
                str_list += ['gridDimZ : <ValueError>']
            {{endif}}
            {{if 'CUDA_LAUNCH_PARAMS_st.blockDimX' in found_struct}}
            try:
                str_list += ['blockDimX : ' + str(self.blockDimX)]
            except ValueError:
                str_list += ['blockDimX : <ValueError>']
            {{endif}}
            {{if 'CUDA_LAUNCH_PARAMS_st.blockDimY' in found_struct}}
            try:
                str_list += ['blockDimY : ' + str(self.blockDimY)]
            except ValueError:
                str_list += ['blockDimY : <ValueError>']
            {{endif}}
            {{if 'CUDA_LAUNCH_PARAMS_st.blockDimZ' in found_struct}}
            try:
                str_list += ['blockDimZ : ' + str(self.blockDimZ)]
            except ValueError:
                str_list += ['blockDimZ : <ValueError>']
            {{endif}}
            {{if 'CUDA_LAUNCH_PARAMS_st.sharedMemBytes' in found_struct}}
            try:
                str_list += ['sharedMemBytes : ' + str(self.sharedMemBytes)]
            except ValueError:
                str_list += ['sharedMemBytes : <ValueError>']
            {{endif}}
            {{if 'CUDA_LAUNCH_PARAMS_st.hStream' in found_struct}}
            try:
                str_list += ['hStream : ' + str(self.hStream)]
            except ValueError:
                str_list += ['hStream : <ValueError>']
            {{endif}}
            {{if 'CUDA_LAUNCH_PARAMS_st.kernelParams' in found_struct}}
            try:
                str_list += ['kernelParams : ' + str(self.kernelParams)]
            except ValueError:
                str_list += ['kernelParams : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_LAUNCH_PARAMS_st.function' in found_struct}}
    @property
    def function(self):
        return self._function
    @function.setter
    def function(self, function):
        cdef cydriver.CUfunction cyfunction
        if function is None:
            cyfunction = <cydriver.CUfunction><void_ptr>0
        elif isinstance(function, (CUfunction,)):
            pfunction = int(function)
            cyfunction = <cydriver.CUfunction><void_ptr>pfunction
        else:
            pfunction = int(CUfunction(function))
            cyfunction = <cydriver.CUfunction><void_ptr>pfunction
        self._function._pvt_ptr[0] = cyfunction
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.gridDimX' in found_struct}}
    @property
    def gridDimX(self):
        return self._pvt_ptr[0].gridDimX
    @gridDimX.setter
    def gridDimX(self, unsigned int gridDimX):
        self._pvt_ptr[0].gridDimX = gridDimX
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.gridDimY' in found_struct}}
    @property
    def gridDimY(self):
        return self._pvt_ptr[0].gridDimY
    @gridDimY.setter
    def gridDimY(self, unsigned int gridDimY):
        self._pvt_ptr[0].gridDimY = gridDimY
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.gridDimZ' in found_struct}}
    @property
    def gridDimZ(self):
        return self._pvt_ptr[0].gridDimZ
    @gridDimZ.setter
    def gridDimZ(self, unsigned int gridDimZ):
        self._pvt_ptr[0].gridDimZ = gridDimZ
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.blockDimX' in found_struct}}
    @property
    def blockDimX(self):
        return self._pvt_ptr[0].blockDimX
    @blockDimX.setter
    def blockDimX(self, unsigned int blockDimX):
        self._pvt_ptr[0].blockDimX = blockDimX
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.blockDimY' in found_struct}}
    @property
    def blockDimY(self):
        return self._pvt_ptr[0].blockDimY
    @blockDimY.setter
    def blockDimY(self, unsigned int blockDimY):
        self._pvt_ptr[0].blockDimY = blockDimY
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.blockDimZ' in found_struct}}
    @property
    def blockDimZ(self):
        return self._pvt_ptr[0].blockDimZ
    @blockDimZ.setter
    def blockDimZ(self, unsigned int blockDimZ):
        self._pvt_ptr[0].blockDimZ = blockDimZ
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.sharedMemBytes' in found_struct}}
    @property
    def sharedMemBytes(self):
        return self._pvt_ptr[0].sharedMemBytes
    @sharedMemBytes.setter
    def sharedMemBytes(self, unsigned int sharedMemBytes):
        self._pvt_ptr[0].sharedMemBytes = sharedMemBytes
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.hStream' in found_struct}}
    @property
    def hStream(self):
        return self._hStream
    @hStream.setter
    def hStream(self, hStream):
        cdef cydriver.CUstream cyhStream
        if hStream is None:
            cyhStream = <cydriver.CUstream><void_ptr>0
        elif isinstance(hStream, (CUstream,)):
            phStream = int(hStream)
            cyhStream = <cydriver.CUstream><void_ptr>phStream
        else:
            phStream = int(CUstream(hStream))
            cyhStream = <cydriver.CUstream><void_ptr>phStream
        self._hStream._pvt_ptr[0] = cyhStream
    {{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st.kernelParams' in found_struct}}
    @property
    def kernelParams(self):
        return <void_ptr>self._pvt_ptr[0].kernelParams
    @kernelParams.setter
    def kernelParams(self, kernelParams):
        self._cykernelParams = _HelperKernelParams(kernelParams)
        self._pvt_ptr[0].kernelParams = <void**><void_ptr>self._cykernelParams.ckernelParams
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle.win32' in found_struct}}

cdef class anon_struct12:
    """
    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle.win32.handle' in found_struct}}
    handle : Any

    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle.win32.name' in found_struct}}
    name : Any

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].handle.win32
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle.win32.handle' in found_struct}}
            try:
                str_list += ['handle : ' + hex(self.handle)]
            except ValueError:
                str_list += ['handle : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle.win32.name' in found_struct}}
            try:
                str_list += ['name : ' + hex(self.name)]
            except ValueError:
                str_list += ['name : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle.win32.handle' in found_struct}}
    @property
    def handle(self):
        return <void_ptr>self._pvt_ptr[0].handle.win32.handle
    @handle.setter
    def handle(self, handle):
        _chandle = _HelperInputVoidPtr(handle)
        self._pvt_ptr[0].handle.win32.handle = <void*><void_ptr>_chandle.cptr
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle.win32.name' in found_struct}}
    @property
    def name(self):
        return <void_ptr>self._pvt_ptr[0].handle.win32.name
    @name.setter
    def name(self, name):
        _cname = _HelperInputVoidPtr(name)
        self._pvt_ptr[0].handle.win32.name = <void*><void_ptr>_cname.cptr
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle' in found_struct}}

cdef class anon_union5:
    """
    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle.fd' in found_struct}}
    fd : int

    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle.win32' in found_struct}}
    win32 : anon_struct12

    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle.nvSciBufObject' in found_struct}}
    nvSciBufObject : Any

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle.win32' in found_struct}}
        self._win32 = anon_struct12(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].handle
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle.fd' in found_struct}}
            try:
                str_list += ['fd : ' + str(self.fd)]
            except ValueError:
                str_list += ['fd : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle.win32' in found_struct}}
            try:
                str_list += ['win32 :\n' + '\n'.join(['    ' + line for line in str(self.win32).splitlines()])]
            except ValueError:
                str_list += ['win32 : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle.nvSciBufObject' in found_struct}}
            try:
                str_list += ['nvSciBufObject : ' + hex(self.nvSciBufObject)]
            except ValueError:
                str_list += ['nvSciBufObject : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle.fd' in found_struct}}
    @property
    def fd(self):
        return self._pvt_ptr[0].handle.fd
    @fd.setter
    def fd(self, int fd):
        self._pvt_ptr[0].handle.fd = fd
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle.win32' in found_struct}}
    @property
    def win32(self):
        return self._win32
    @win32.setter
    def win32(self, win32 not None : anon_struct12):
        string.memcpy(&self._pvt_ptr[0].handle.win32, <cydriver.anon_struct12*><void_ptr>win32.getPtr(), sizeof(self._pvt_ptr[0].handle.win32))
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle.nvSciBufObject' in found_struct}}
    @property
    def nvSciBufObject(self):
        return <void_ptr>self._pvt_ptr[0].handle.nvSciBufObject
    @nvSciBufObject.setter
    def nvSciBufObject(self, nvSciBufObject):
        _cnvSciBufObject = _HelperInputVoidPtr(nvSciBufObject)
        self._pvt_ptr[0].handle.nvSciBufObject = <void*><void_ptr>_cnvSciBufObject.cptr
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st' in found_struct}}

cdef class CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st:
    """
    External memory handle descriptor

    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.type' in found_struct}}
    type : CUexternalMemoryHandleType
        Type of the handle
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle' in found_struct}}
    handle : anon_union5

    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.size' in found_struct}}
    size : unsigned long long
        Size of the memory allocation
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.flags' in found_struct}}
    flags : unsigned int
        Flags must either be zero or CUDA_EXTERNAL_MEMORY_DEDICATED
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.reserved' in found_struct}}
    reserved : list[unsigned int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cydriver.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st *>calloc(1, sizeof(cydriver.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cydriver.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle' in found_struct}}
        self._handle = anon_union5(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle' in found_struct}}
            try:
                str_list += ['handle :\n' + '\n'.join(['    ' + line for line in str(self.handle).splitlines()])]
            except ValueError:
                str_list += ['handle : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.size' in found_struct}}
            try:
                str_list += ['size : ' + str(self.size)]
            except ValueError:
                str_list += ['size : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.type' in found_struct}}
    @property
    def type(self):
        if self._pvt_ptr[0].type not in _dict_CUexternalMemoryHandleType:
            return None
        return _dict_CUexternalMemoryHandleType[self._pvt_ptr[0].type]
    @type.setter
    def type(self, type not None : CUexternalMemoryHandleType):
        self._pvt_ptr[0].type = type.value
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.handle' in found_struct}}
    @property
    def handle(self):
        return self._handle
    @handle.setter
    def handle(self, handle not None : anon_union5):
        string.memcpy(&self._pvt_ptr[0].handle, <cydriver.anon_union5*><void_ptr>handle.getPtr(), sizeof(self._pvt_ptr[0].handle))
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.size' in found_struct}}
    @property
    def size(self):
        return self._pvt_ptr[0].size
    @size.setter
    def size(self, unsigned long long size):
        self._pvt_ptr[0].size = size
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st' in found_struct}}

cdef class CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st:
    """
    External memory buffer descriptor

    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st.offset' in found_struct}}
    offset : unsigned long long
        Offset into the memory object where the buffer's base is
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st.size' in found_struct}}
    size : unsigned long long
        Size of the buffer
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st.flags' in found_struct}}
    flags : unsigned int
        Flags reserved for future use. Must be zero.
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st.reserved' in found_struct}}
    reserved : list[unsigned int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st.offset' in found_struct}}
            try:
                str_list += ['offset : ' + str(self.offset)]
            except ValueError:
                str_list += ['offset : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st.size' in found_struct}}
            try:
                str_list += ['size : ' + str(self.size)]
            except ValueError:
                str_list += ['size : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st.offset' in found_struct}}
    @property
    def offset(self):
        return self._pvt_ptr[0].offset
    @offset.setter
    def offset(self, unsigned long long offset):
        self._pvt_ptr[0].offset = offset
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st.size' in found_struct}}
    @property
    def size(self):
        return self._pvt_ptr[0].size
    @size.setter
    def size(self, unsigned long long size):
        self._pvt_ptr[0].size = size
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st' in found_struct}}

cdef class CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st:
    """
    External memory mipmap descriptor

    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st.offset' in found_struct}}
    offset : unsigned long long
        Offset into the memory object where the base level of the mipmap
        chain is.
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st.arrayDesc' in found_struct}}
    arrayDesc : CUDA_ARRAY3D_DESCRIPTOR
        Format, dimension and type of base level of the mipmap chain
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st.numLevels' in found_struct}}
    numLevels : unsigned int
        Total number of levels in the mipmap chain
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st.reserved' in found_struct}}
    reserved : list[unsigned int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st.arrayDesc' in found_struct}}
        self._arrayDesc = CUDA_ARRAY3D_DESCRIPTOR(_ptr=<void_ptr>&self._pvt_ptr[0].arrayDesc)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st.offset' in found_struct}}
            try:
                str_list += ['offset : ' + str(self.offset)]
            except ValueError:
                str_list += ['offset : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st.arrayDesc' in found_struct}}
            try:
                str_list += ['arrayDesc :\n' + '\n'.join(['    ' + line for line in str(self.arrayDesc).splitlines()])]
            except ValueError:
                str_list += ['arrayDesc : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st.numLevels' in found_struct}}
            try:
                str_list += ['numLevels : ' + str(self.numLevels)]
            except ValueError:
                str_list += ['numLevels : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st.offset' in found_struct}}
    @property
    def offset(self):
        return self._pvt_ptr[0].offset
    @offset.setter
    def offset(self, unsigned long long offset):
        self._pvt_ptr[0].offset = offset
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st.arrayDesc' in found_struct}}
    @property
    def arrayDesc(self):
        return self._arrayDesc
    @arrayDesc.setter
    def arrayDesc(self, arrayDesc not None : CUDA_ARRAY3D_DESCRIPTOR):
        string.memcpy(&self._pvt_ptr[0].arrayDesc, <cydriver.CUDA_ARRAY3D_DESCRIPTOR*><void_ptr>arrayDesc.getPtr(), sizeof(self._pvt_ptr[0].arrayDesc))
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st.numLevels' in found_struct}}
    @property
    def numLevels(self):
        return self._pvt_ptr[0].numLevels
    @numLevels.setter
    def numLevels(self, unsigned int numLevels):
        self._pvt_ptr[0].numLevels = numLevels
    {{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle.win32' in found_struct}}

cdef class anon_struct13:
    """
    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle.win32.handle' in found_struct}}
    handle : Any

    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle.win32.name' in found_struct}}
    name : Any

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].handle.win32
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle.win32.handle' in found_struct}}
            try:
                str_list += ['handle : ' + hex(self.handle)]
            except ValueError:
                str_list += ['handle : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle.win32.name' in found_struct}}
            try:
                str_list += ['name : ' + hex(self.name)]
            except ValueError:
                str_list += ['name : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle.win32.handle' in found_struct}}
    @property
    def handle(self):
        return <void_ptr>self._pvt_ptr[0].handle.win32.handle
    @handle.setter
    def handle(self, handle):
        _chandle = _HelperInputVoidPtr(handle)
        self._pvt_ptr[0].handle.win32.handle = <void*><void_ptr>_chandle.cptr
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle.win32.name' in found_struct}}
    @property
    def name(self):
        return <void_ptr>self._pvt_ptr[0].handle.win32.name
    @name.setter
    def name(self, name):
        _cname = _HelperInputVoidPtr(name)
        self._pvt_ptr[0].handle.win32.name = <void*><void_ptr>_cname.cptr
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle' in found_struct}}

cdef class anon_union6:
    """
    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle.fd' in found_struct}}
    fd : int

    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle.win32' in found_struct}}
    win32 : anon_struct13

    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle.nvSciSyncObj' in found_struct}}
    nvSciSyncObj : Any

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle.win32' in found_struct}}
        self._win32 = anon_struct13(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].handle
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle.fd' in found_struct}}
            try:
                str_list += ['fd : ' + str(self.fd)]
            except ValueError:
                str_list += ['fd : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle.win32' in found_struct}}
            try:
                str_list += ['win32 :\n' + '\n'.join(['    ' + line for line in str(self.win32).splitlines()])]
            except ValueError:
                str_list += ['win32 : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle.nvSciSyncObj' in found_struct}}
            try:
                str_list += ['nvSciSyncObj : ' + hex(self.nvSciSyncObj)]
            except ValueError:
                str_list += ['nvSciSyncObj : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle.fd' in found_struct}}
    @property
    def fd(self):
        return self._pvt_ptr[0].handle.fd
    @fd.setter
    def fd(self, int fd):
        self._pvt_ptr[0].handle.fd = fd
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle.win32' in found_struct}}
    @property
    def win32(self):
        return self._win32
    @win32.setter
    def win32(self, win32 not None : anon_struct13):
        string.memcpy(&self._pvt_ptr[0].handle.win32, <cydriver.anon_struct13*><void_ptr>win32.getPtr(), sizeof(self._pvt_ptr[0].handle.win32))
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle.nvSciSyncObj' in found_struct}}
    @property
    def nvSciSyncObj(self):
        return <void_ptr>self._pvt_ptr[0].handle.nvSciSyncObj
    @nvSciSyncObj.setter
    def nvSciSyncObj(self, nvSciSyncObj):
        _cnvSciSyncObj = _HelperInputVoidPtr(nvSciSyncObj)
        self._pvt_ptr[0].handle.nvSciSyncObj = <void*><void_ptr>_cnvSciSyncObj.cptr
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st' in found_struct}}

cdef class CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st:
    """
    External semaphore handle descriptor

    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.type' in found_struct}}
    type : CUexternalSemaphoreHandleType
        Type of the handle
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle' in found_struct}}
    handle : anon_union6

    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.flags' in found_struct}}
    flags : unsigned int
        Flags reserved for the future. Must be zero.
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.reserved' in found_struct}}
    reserved : list[unsigned int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cydriver.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st *>calloc(1, sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cydriver.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle' in found_struct}}
        self._handle = anon_union6(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle' in found_struct}}
            try:
                str_list += ['handle :\n' + '\n'.join(['    ' + line for line in str(self.handle).splitlines()])]
            except ValueError:
                str_list += ['handle : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.type' in found_struct}}
    @property
    def type(self):
        if self._pvt_ptr[0].type not in _dict_CUexternalSemaphoreHandleType:
            return None
        return _dict_CUexternalSemaphoreHandleType[self._pvt_ptr[0].type]
    @type.setter
    def type(self, type not None : CUexternalSemaphoreHandleType):
        self._pvt_ptr[0].type = type.value
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.handle' in found_struct}}
    @property
    def handle(self):
        return self._handle
    @handle.setter
    def handle(self, handle not None : anon_union6):
        string.memcpy(&self._pvt_ptr[0].handle, <cydriver.anon_union6*><void_ptr>handle.getPtr(), sizeof(self._pvt_ptr[0].handle))
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.fence' in found_struct}}

cdef class anon_struct14:
    """
    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.fence.value' in found_struct}}
    value : unsigned long long

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].params.fence
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.fence.value' in found_struct}}
            try:
                str_list += ['value : ' + str(self.value)]
            except ValueError:
                str_list += ['value : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.fence.value' in found_struct}}
    @property
    def value(self):
        return self._pvt_ptr[0].params.fence.value
    @value.setter
    def value(self, unsigned long long value):
        self._pvt_ptr[0].params.fence.value = value
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.nvSciSync' in found_struct}}

cdef class anon_union7:
    """
    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.nvSciSync.fence' in found_struct}}
    fence : Any

    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.nvSciSync.reserved' in found_struct}}
    reserved : unsigned long long

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].params.nvSciSync
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.nvSciSync.fence' in found_struct}}
            try:
                str_list += ['fence : ' + hex(self.fence)]
            except ValueError:
                str_list += ['fence : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.nvSciSync.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.nvSciSync.fence' in found_struct}}
    @property
    def fence(self):
        return <void_ptr>self._pvt_ptr[0].params.nvSciSync.fence
    @fence.setter
    def fence(self, fence):
        _cfence = _HelperInputVoidPtr(fence)
        self._pvt_ptr[0].params.nvSciSync.fence = <void*><void_ptr>_cfence.cptr
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.nvSciSync.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].params.nvSciSync.reserved
    @reserved.setter
    def reserved(self, unsigned long long reserved):
        self._pvt_ptr[0].params.nvSciSync.reserved = reserved
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.keyedMutex' in found_struct}}

cdef class anon_struct15:
    """
    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.keyedMutex.key' in found_struct}}
    key : unsigned long long

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].params.keyedMutex
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.keyedMutex.key' in found_struct}}
            try:
                str_list += ['key : ' + str(self.key)]
            except ValueError:
                str_list += ['key : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.keyedMutex.key' in found_struct}}
    @property
    def key(self):
        return self._pvt_ptr[0].params.keyedMutex.key
    @key.setter
    def key(self, unsigned long long key):
        self._pvt_ptr[0].params.keyedMutex.key = key
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params' in found_struct}}

cdef class anon_struct16:
    """
    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.fence' in found_struct}}
    fence : anon_struct14

    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.nvSciSync' in found_struct}}
    nvSciSync : anon_union7

    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.keyedMutex' in found_struct}}
    keyedMutex : anon_struct15

    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.reserved' in found_struct}}
    reserved : list[unsigned int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.fence' in found_struct}}
        self._fence = anon_struct14(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.nvSciSync' in found_struct}}
        self._nvSciSync = anon_union7(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.keyedMutex' in found_struct}}
        self._keyedMutex = anon_struct15(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].params
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.fence' in found_struct}}
            try:
                str_list += ['fence :\n' + '\n'.join(['    ' + line for line in str(self.fence).splitlines()])]
            except ValueError:
                str_list += ['fence : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.nvSciSync' in found_struct}}
            try:
                str_list += ['nvSciSync :\n' + '\n'.join(['    ' + line for line in str(self.nvSciSync).splitlines()])]
            except ValueError:
                str_list += ['nvSciSync : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.keyedMutex' in found_struct}}
            try:
                str_list += ['keyedMutex :\n' + '\n'.join(['    ' + line for line in str(self.keyedMutex).splitlines()])]
            except ValueError:
                str_list += ['keyedMutex : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.fence' in found_struct}}
    @property
    def fence(self):
        return self._fence
    @fence.setter
    def fence(self, fence not None : anon_struct14):
        string.memcpy(&self._pvt_ptr[0].params.fence, <cydriver.anon_struct14*><void_ptr>fence.getPtr(), sizeof(self._pvt_ptr[0].params.fence))
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.nvSciSync' in found_struct}}
    @property
    def nvSciSync(self):
        return self._nvSciSync
    @nvSciSync.setter
    def nvSciSync(self, nvSciSync not None : anon_union7):
        string.memcpy(&self._pvt_ptr[0].params.nvSciSync, <cydriver.anon_union7*><void_ptr>nvSciSync.getPtr(), sizeof(self._pvt_ptr[0].params.nvSciSync))
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.keyedMutex' in found_struct}}
    @property
    def keyedMutex(self):
        return self._keyedMutex
    @keyedMutex.setter
    def keyedMutex(self, keyedMutex not None : anon_struct15):
        string.memcpy(&self._pvt_ptr[0].params.keyedMutex, <cydriver.anon_struct15*><void_ptr>keyedMutex.getPtr(), sizeof(self._pvt_ptr[0].params.keyedMutex))
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].params.reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].params.reserved = reserved
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st' in found_struct}}

cdef class CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st:
    """
    External semaphore signal parameters

    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params' in found_struct}}
    params : anon_struct16

    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.flags' in found_struct}}
    flags : unsigned int
        Only when ::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS is used to signal
        a CUexternalSemaphore of type
        CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC, the valid flag is
        CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC which
        indicates that while signaling the CUexternalSemaphore, no memory
        synchronization operations should be performed for any external
        memory object imported as CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF.
        For all other types of CUexternalSemaphore, flags must be zero.
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.reserved' in found_struct}}
    reserved : list[unsigned int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params' in found_struct}}
        self._params = anon_struct16(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params' in found_struct}}
            try:
                str_list += ['params :\n' + '\n'.join(['    ' + line for line in str(self.params).splitlines()])]
            except ValueError:
                str_list += ['params : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.params' in found_struct}}
    @property
    def params(self):
        return self._params
    @params.setter
    def params(self, params not None : anon_struct16):
        string.memcpy(&self._pvt_ptr[0].params, <cydriver.anon_struct16*><void_ptr>params.getPtr(), sizeof(self._pvt_ptr[0].params))
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.fence' in found_struct}}

cdef class anon_struct17:
    """
    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.fence.value' in found_struct}}
    value : unsigned long long

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].params.fence
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.fence.value' in found_struct}}
            try:
                str_list += ['value : ' + str(self.value)]
            except ValueError:
                str_list += ['value : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.fence.value' in found_struct}}
    @property
    def value(self):
        return self._pvt_ptr[0].params.fence.value
    @value.setter
    def value(self, unsigned long long value):
        self._pvt_ptr[0].params.fence.value = value
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.nvSciSync' in found_struct}}

cdef class anon_union8:
    """
    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.nvSciSync.fence' in found_struct}}
    fence : Any

    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.nvSciSync.reserved' in found_struct}}
    reserved : unsigned long long

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].params.nvSciSync
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.nvSciSync.fence' in found_struct}}
            try:
                str_list += ['fence : ' + hex(self.fence)]
            except ValueError:
                str_list += ['fence : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.nvSciSync.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.nvSciSync.fence' in found_struct}}
    @property
    def fence(self):
        return <void_ptr>self._pvt_ptr[0].params.nvSciSync.fence
    @fence.setter
    def fence(self, fence):
        _cfence = _HelperInputVoidPtr(fence)
        self._pvt_ptr[0].params.nvSciSync.fence = <void*><void_ptr>_cfence.cptr
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.nvSciSync.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].params.nvSciSync.reserved
    @reserved.setter
    def reserved(self, unsigned long long reserved):
        self._pvt_ptr[0].params.nvSciSync.reserved = reserved
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.keyedMutex' in found_struct}}

cdef class anon_struct18:
    """
    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.keyedMutex.key' in found_struct}}
    key : unsigned long long

    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.keyedMutex.timeoutMs' in found_struct}}
    timeoutMs : unsigned int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].params.keyedMutex
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.keyedMutex.key' in found_struct}}
            try:
                str_list += ['key : ' + str(self.key)]
            except ValueError:
                str_list += ['key : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.keyedMutex.timeoutMs' in found_struct}}
            try:
                str_list += ['timeoutMs : ' + str(self.timeoutMs)]
            except ValueError:
                str_list += ['timeoutMs : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.keyedMutex.key' in found_struct}}
    @property
    def key(self):
        return self._pvt_ptr[0].params.keyedMutex.key
    @key.setter
    def key(self, unsigned long long key):
        self._pvt_ptr[0].params.keyedMutex.key = key
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.keyedMutex.timeoutMs' in found_struct}}
    @property
    def timeoutMs(self):
        return self._pvt_ptr[0].params.keyedMutex.timeoutMs
    @timeoutMs.setter
    def timeoutMs(self, unsigned int timeoutMs):
        self._pvt_ptr[0].params.keyedMutex.timeoutMs = timeoutMs
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params' in found_struct}}

cdef class anon_struct19:
    """
    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.fence' in found_struct}}
    fence : anon_struct17

    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.nvSciSync' in found_struct}}
    nvSciSync : anon_union8

    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.keyedMutex' in found_struct}}
    keyedMutex : anon_struct18

    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.reserved' in found_struct}}
    reserved : list[unsigned int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.fence' in found_struct}}
        self._fence = anon_struct17(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.nvSciSync' in found_struct}}
        self._nvSciSync = anon_union8(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.keyedMutex' in found_struct}}
        self._keyedMutex = anon_struct18(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].params
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.fence' in found_struct}}
            try:
                str_list += ['fence :\n' + '\n'.join(['    ' + line for line in str(self.fence).splitlines()])]
            except ValueError:
                str_list += ['fence : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.nvSciSync' in found_struct}}
            try:
                str_list += ['nvSciSync :\n' + '\n'.join(['    ' + line for line in str(self.nvSciSync).splitlines()])]
            except ValueError:
                str_list += ['nvSciSync : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.keyedMutex' in found_struct}}
            try:
                str_list += ['keyedMutex :\n' + '\n'.join(['    ' + line for line in str(self.keyedMutex).splitlines()])]
            except ValueError:
                str_list += ['keyedMutex : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.fence' in found_struct}}
    @property
    def fence(self):
        return self._fence
    @fence.setter
    def fence(self, fence not None : anon_struct17):
        string.memcpy(&self._pvt_ptr[0].params.fence, <cydriver.anon_struct17*><void_ptr>fence.getPtr(), sizeof(self._pvt_ptr[0].params.fence))
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.nvSciSync' in found_struct}}
    @property
    def nvSciSync(self):
        return self._nvSciSync
    @nvSciSync.setter
    def nvSciSync(self, nvSciSync not None : anon_union8):
        string.memcpy(&self._pvt_ptr[0].params.nvSciSync, <cydriver.anon_union8*><void_ptr>nvSciSync.getPtr(), sizeof(self._pvt_ptr[0].params.nvSciSync))
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.keyedMutex' in found_struct}}
    @property
    def keyedMutex(self):
        return self._keyedMutex
    @keyedMutex.setter
    def keyedMutex(self, keyedMutex not None : anon_struct18):
        string.memcpy(&self._pvt_ptr[0].params.keyedMutex, <cydriver.anon_struct18*><void_ptr>keyedMutex.getPtr(), sizeof(self._pvt_ptr[0].params.keyedMutex))
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].params.reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].params.reserved = reserved
    {{endif}}
{{endif}}
{{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st' in found_struct}}

cdef class CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st:
    """
    External semaphore wait parameters

    Attributes
    ----------
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params' in found_struct}}
    params : anon_struct19

    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.flags' in found_struct}}
    flags : unsigned int
        Only when ::CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS is used to wait on
        a CUexternalSemaphore of type
        CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC, the valid flag is
        CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC which indicates
        that while waiting for the CUexternalSemaphore, no memory
        synchronization operations should be performed for any external
        memory object imported as CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF.
        For all other types of CUexternalSemaphore, flags must be zero.
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.reserved' in found_struct}}
    reserved : list[unsigned int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params' in found_struct}}
        self._params = anon_struct19(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params' in found_struct}}
            try:
                str_list += ['params :\n' + '\n'.join(['    ' + line for line in str(self.params).splitlines()])]
            except ValueError:
                str_list += ['params : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.params' in found_struct}}
    @property
    def params(self):
        return self._params
    @params.setter
    def params(self, params not None : anon_struct19):
        string.memcpy(&self._pvt_ptr[0].params, <cydriver.anon_struct19*><void_ptr>params.getPtr(), sizeof(self._pvt_ptr[0].params))
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st' in found_struct}}

cdef class CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st:
    """
    Semaphore signal node parameters

    Attributes
    ----------
    {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st.extSemArray' in found_struct}}
    extSemArray : CUexternalSemaphore
        Array of external semaphore handles.
    {{endif}}
    {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st.paramsArray' in found_struct}}
    paramsArray : CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS
        Array of external semaphore signal parameters.
    {{endif}}
    {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st.numExtSems' in found_struct}}
    numExtSems : unsigned int
        Number of handles and parameters supplied in extSemArray and
        paramsArray.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
        {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st.extSemArray' in found_struct}}
        if self._extSemArray is not NULL:
            free(self._extSemArray)
        {{endif}}
        {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st.paramsArray' in found_struct}}
        if self._paramsArray is not NULL:
            free(self._paramsArray)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st.extSemArray' in found_struct}}
            try:
                str_list += ['extSemArray : ' + str(self.extSemArray)]
            except ValueError:
                str_list += ['extSemArray : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st.paramsArray' in found_struct}}
            try:
                str_list += ['paramsArray : ' + str(self.paramsArray)]
            except ValueError:
                str_list += ['paramsArray : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st.numExtSems' in found_struct}}
            try:
                str_list += ['numExtSems : ' + str(self.numExtSems)]
            except ValueError:
                str_list += ['numExtSems : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st.extSemArray' in found_struct}}
    @property
    def extSemArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].extSemArray + x*sizeof(cydriver.CUexternalSemaphore) for x in range(self._extSemArray_length)]
        return [CUexternalSemaphore(_ptr=arr) for arr in arrs]
    @extSemArray.setter
    def extSemArray(self, val):
        if len(val) == 0:
            free(self._extSemArray)
            self._extSemArray_length = 0
            self._pvt_ptr[0].extSemArray = NULL
        else:
            if self._extSemArray_length != <size_t>len(val):
                free(self._extSemArray)
                self._extSemArray = <cydriver.CUexternalSemaphore*> calloc(len(val), sizeof(cydriver.CUexternalSemaphore))
                if self._extSemArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cydriver.CUexternalSemaphore)))
                self._extSemArray_length = <size_t>len(val)
                self._pvt_ptr[0].extSemArray = self._extSemArray
            for idx in range(len(val)):
                self._extSemArray[idx] = (<CUexternalSemaphore>val[idx])._pvt_ptr[0]

    {{endif}}
    {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st.paramsArray' in found_struct}}
    @property
    def paramsArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].paramsArray + x*sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS) for x in range(self._paramsArray_length)]
        return [CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS(_ptr=arr) for arr in arrs]
    @paramsArray.setter
    def paramsArray(self, val):
        if len(val) == 0:
            free(self._paramsArray)
            self._paramsArray_length = 0
            self._pvt_ptr[0].paramsArray = NULL
        else:
            if self._paramsArray_length != <size_t>len(val):
                free(self._paramsArray)
                self._paramsArray = <cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS*> calloc(len(val), sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS))
                if self._paramsArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS)))
                self._paramsArray_length = <size_t>len(val)
                self._pvt_ptr[0].paramsArray = self._paramsArray
            for idx in range(len(val)):
                string.memcpy(&self._paramsArray[idx], (<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS>val[idx])._pvt_ptr, sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS))

    {{endif}}
    {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st.numExtSems' in found_struct}}
    @property
    def numExtSems(self):
        return self._pvt_ptr[0].numExtSems
    @numExtSems.setter
    def numExtSems(self, unsigned int numExtSems):
        self._pvt_ptr[0].numExtSems = numExtSems
    {{endif}}
{{endif}}
{{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st' in found_struct}}

cdef class CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st:
    """
    Semaphore signal node parameters

    Attributes
    ----------
    {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st.extSemArray' in found_struct}}
    extSemArray : CUexternalSemaphore
        Array of external semaphore handles.
    {{endif}}
    {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st.paramsArray' in found_struct}}
    paramsArray : CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS
        Array of external semaphore signal parameters.
    {{endif}}
    {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st.numExtSems' in found_struct}}
    numExtSems : unsigned int
        Number of handles and parameters supplied in extSemArray and
        paramsArray.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
        {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st.extSemArray' in found_struct}}
        if self._extSemArray is not NULL:
            free(self._extSemArray)
        {{endif}}
        {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st.paramsArray' in found_struct}}
        if self._paramsArray is not NULL:
            free(self._paramsArray)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st.extSemArray' in found_struct}}
            try:
                str_list += ['extSemArray : ' + str(self.extSemArray)]
            except ValueError:
                str_list += ['extSemArray : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st.paramsArray' in found_struct}}
            try:
                str_list += ['paramsArray : ' + str(self.paramsArray)]
            except ValueError:
                str_list += ['paramsArray : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st.numExtSems' in found_struct}}
            try:
                str_list += ['numExtSems : ' + str(self.numExtSems)]
            except ValueError:
                str_list += ['numExtSems : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st.extSemArray' in found_struct}}
    @property
    def extSemArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].extSemArray + x*sizeof(cydriver.CUexternalSemaphore) for x in range(self._extSemArray_length)]
        return [CUexternalSemaphore(_ptr=arr) for arr in arrs]
    @extSemArray.setter
    def extSemArray(self, val):
        if len(val) == 0:
            free(self._extSemArray)
            self._extSemArray_length = 0
            self._pvt_ptr[0].extSemArray = NULL
        else:
            if self._extSemArray_length != <size_t>len(val):
                free(self._extSemArray)
                self._extSemArray = <cydriver.CUexternalSemaphore*> calloc(len(val), sizeof(cydriver.CUexternalSemaphore))
                if self._extSemArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cydriver.CUexternalSemaphore)))
                self._extSemArray_length = <size_t>len(val)
                self._pvt_ptr[0].extSemArray = self._extSemArray
            for idx in range(len(val)):
                self._extSemArray[idx] = (<CUexternalSemaphore>val[idx])._pvt_ptr[0]

    {{endif}}
    {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st.paramsArray' in found_struct}}
    @property
    def paramsArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].paramsArray + x*sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS) for x in range(self._paramsArray_length)]
        return [CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS(_ptr=arr) for arr in arrs]
    @paramsArray.setter
    def paramsArray(self, val):
        if len(val) == 0:
            free(self._paramsArray)
            self._paramsArray_length = 0
            self._pvt_ptr[0].paramsArray = NULL
        else:
            if self._paramsArray_length != <size_t>len(val):
                free(self._paramsArray)
                self._paramsArray = <cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS*> calloc(len(val), sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS))
                if self._paramsArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS)))
                self._paramsArray_length = <size_t>len(val)
                self._pvt_ptr[0].paramsArray = self._paramsArray
            for idx in range(len(val)):
                string.memcpy(&self._paramsArray[idx], (<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS>val[idx])._pvt_ptr, sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS))

    {{endif}}
    {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st.numExtSems' in found_struct}}
    @property
    def numExtSems(self):
        return self._pvt_ptr[0].numExtSems
    @numExtSems.setter
    def numExtSems(self, unsigned int numExtSems):
        self._pvt_ptr[0].numExtSems = numExtSems
    {{endif}}
{{endif}}
{{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_st' in found_struct}}

cdef class CUDA_EXT_SEM_WAIT_NODE_PARAMS_st:
    """
    Semaphore wait node parameters

    Attributes
    ----------
    {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_st.extSemArray' in found_struct}}
    extSemArray : CUexternalSemaphore
        Array of external semaphore handles.
    {{endif}}
    {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_st.paramsArray' in found_struct}}
    paramsArray : CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS
        Array of external semaphore wait parameters.
    {{endif}}
    {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_st.numExtSems' in found_struct}}
    numExtSems : unsigned int
        Number of handles and parameters supplied in extSemArray and
        paramsArray.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_EXT_SEM_WAIT_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
        {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_st.extSemArray' in found_struct}}
        if self._extSemArray is not NULL:
            free(self._extSemArray)
        {{endif}}
        {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_st.paramsArray' in found_struct}}
        if self._paramsArray is not NULL:
            free(self._paramsArray)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_st.extSemArray' in found_struct}}
            try:
                str_list += ['extSemArray : ' + str(self.extSemArray)]
            except ValueError:
                str_list += ['extSemArray : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_st.paramsArray' in found_struct}}
            try:
                str_list += ['paramsArray : ' + str(self.paramsArray)]
            except ValueError:
                str_list += ['paramsArray : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_st.numExtSems' in found_struct}}
            try:
                str_list += ['numExtSems : ' + str(self.numExtSems)]
            except ValueError:
                str_list += ['numExtSems : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_st.extSemArray' in found_struct}}
    @property
    def extSemArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].extSemArray + x*sizeof(cydriver.CUexternalSemaphore) for x in range(self._extSemArray_length)]
        return [CUexternalSemaphore(_ptr=arr) for arr in arrs]
    @extSemArray.setter
    def extSemArray(self, val):
        if len(val) == 0:
            free(self._extSemArray)
            self._extSemArray_length = 0
            self._pvt_ptr[0].extSemArray = NULL
        else:
            if self._extSemArray_length != <size_t>len(val):
                free(self._extSemArray)
                self._extSemArray = <cydriver.CUexternalSemaphore*> calloc(len(val), sizeof(cydriver.CUexternalSemaphore))
                if self._extSemArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cydriver.CUexternalSemaphore)))
                self._extSemArray_length = <size_t>len(val)
                self._pvt_ptr[0].extSemArray = self._extSemArray
            for idx in range(len(val)):
                self._extSemArray[idx] = (<CUexternalSemaphore>val[idx])._pvt_ptr[0]

    {{endif}}
    {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_st.paramsArray' in found_struct}}
    @property
    def paramsArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].paramsArray + x*sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS) for x in range(self._paramsArray_length)]
        return [CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS(_ptr=arr) for arr in arrs]
    @paramsArray.setter
    def paramsArray(self, val):
        if len(val) == 0:
            free(self._paramsArray)
            self._paramsArray_length = 0
            self._pvt_ptr[0].paramsArray = NULL
        else:
            if self._paramsArray_length != <size_t>len(val):
                free(self._paramsArray)
                self._paramsArray = <cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS*> calloc(len(val), sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS))
                if self._paramsArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS)))
                self._paramsArray_length = <size_t>len(val)
                self._pvt_ptr[0].paramsArray = self._paramsArray
            for idx in range(len(val)):
                string.memcpy(&self._paramsArray[idx], (<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS>val[idx])._pvt_ptr, sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS))

    {{endif}}
    {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_st.numExtSems' in found_struct}}
    @property
    def numExtSems(self):
        return self._pvt_ptr[0].numExtSems
    @numExtSems.setter
    def numExtSems(self, unsigned int numExtSems):
        self._pvt_ptr[0].numExtSems = numExtSems
    {{endif}}
{{endif}}
{{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st' in found_struct}}

cdef class CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st:
    """
    Semaphore wait node parameters

    Attributes
    ----------
    {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st.extSemArray' in found_struct}}
    extSemArray : CUexternalSemaphore
        Array of external semaphore handles.
    {{endif}}
    {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st.paramsArray' in found_struct}}
    paramsArray : CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS
        Array of external semaphore wait parameters.
    {{endif}}
    {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st.numExtSems' in found_struct}}
    numExtSems : unsigned int
        Number of handles and parameters supplied in extSemArray and
        paramsArray.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
        {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st.extSemArray' in found_struct}}
        if self._extSemArray is not NULL:
            free(self._extSemArray)
        {{endif}}
        {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st.paramsArray' in found_struct}}
        if self._paramsArray is not NULL:
            free(self._paramsArray)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st.extSemArray' in found_struct}}
            try:
                str_list += ['extSemArray : ' + str(self.extSemArray)]
            except ValueError:
                str_list += ['extSemArray : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st.paramsArray' in found_struct}}
            try:
                str_list += ['paramsArray : ' + str(self.paramsArray)]
            except ValueError:
                str_list += ['paramsArray : <ValueError>']
            {{endif}}
            {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st.numExtSems' in found_struct}}
            try:
                str_list += ['numExtSems : ' + str(self.numExtSems)]
            except ValueError:
                str_list += ['numExtSems : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st.extSemArray' in found_struct}}
    @property
    def extSemArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].extSemArray + x*sizeof(cydriver.CUexternalSemaphore) for x in range(self._extSemArray_length)]
        return [CUexternalSemaphore(_ptr=arr) for arr in arrs]
    @extSemArray.setter
    def extSemArray(self, val):
        if len(val) == 0:
            free(self._extSemArray)
            self._extSemArray_length = 0
            self._pvt_ptr[0].extSemArray = NULL
        else:
            if self._extSemArray_length != <size_t>len(val):
                free(self._extSemArray)
                self._extSemArray = <cydriver.CUexternalSemaphore*> calloc(len(val), sizeof(cydriver.CUexternalSemaphore))
                if self._extSemArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cydriver.CUexternalSemaphore)))
                self._extSemArray_length = <size_t>len(val)
                self._pvt_ptr[0].extSemArray = self._extSemArray
            for idx in range(len(val)):
                self._extSemArray[idx] = (<CUexternalSemaphore>val[idx])._pvt_ptr[0]

    {{endif}}
    {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st.paramsArray' in found_struct}}
    @property
    def paramsArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].paramsArray + x*sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS) for x in range(self._paramsArray_length)]
        return [CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS(_ptr=arr) for arr in arrs]
    @paramsArray.setter
    def paramsArray(self, val):
        if len(val) == 0:
            free(self._paramsArray)
            self._paramsArray_length = 0
            self._pvt_ptr[0].paramsArray = NULL
        else:
            if self._paramsArray_length != <size_t>len(val):
                free(self._paramsArray)
                self._paramsArray = <cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS*> calloc(len(val), sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS))
                if self._paramsArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS)))
                self._paramsArray_length = <size_t>len(val)
                self._pvt_ptr[0].paramsArray = self._paramsArray
            for idx in range(len(val)):
                string.memcpy(&self._paramsArray[idx], (<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS>val[idx])._pvt_ptr, sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS))

    {{endif}}
    {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st.numExtSems' in found_struct}}
    @property
    def numExtSems(self):
        return self._pvt_ptr[0].numExtSems
    @numExtSems.setter
    def numExtSems(self, unsigned int numExtSems):
        self._pvt_ptr[0].numExtSems = numExtSems
    {{endif}}
{{endif}}
{{if 'CUarrayMapInfo_st.resource' in found_struct}}

cdef class anon_union9:
    """
    Attributes
    ----------
    {{if 'CUarrayMapInfo_st.resource.mipmap' in found_struct}}
    mipmap : CUmipmappedArray

    {{endif}}
    {{if 'CUarrayMapInfo_st.resource.array' in found_struct}}
    array : CUarray

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUarrayMapInfo_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUarrayMapInfo_st.resource.mipmap' in found_struct}}
        self._mipmap = CUmipmappedArray(_ptr=<void_ptr>&self._pvt_ptr[0].resource.mipmap)
        {{endif}}
        {{if 'CUarrayMapInfo_st.resource.array' in found_struct}}
        self._array = CUarray(_ptr=<void_ptr>&self._pvt_ptr[0].resource.array)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].resource
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUarrayMapInfo_st.resource.mipmap' in found_struct}}
            try:
                str_list += ['mipmap : ' + str(self.mipmap)]
            except ValueError:
                str_list += ['mipmap : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.resource.array' in found_struct}}
            try:
                str_list += ['array : ' + str(self.array)]
            except ValueError:
                str_list += ['array : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUarrayMapInfo_st.resource.mipmap' in found_struct}}
    @property
    def mipmap(self):
        return self._mipmap
    @mipmap.setter
    def mipmap(self, mipmap):
        cdef cydriver.CUmipmappedArray cymipmap
        if mipmap is None:
            cymipmap = <cydriver.CUmipmappedArray><void_ptr>0
        elif isinstance(mipmap, (CUmipmappedArray,)):
            pmipmap = int(mipmap)
            cymipmap = <cydriver.CUmipmappedArray><void_ptr>pmipmap
        else:
            pmipmap = int(CUmipmappedArray(mipmap))
            cymipmap = <cydriver.CUmipmappedArray><void_ptr>pmipmap
        self._mipmap._pvt_ptr[0] = cymipmap
    {{endif}}
    {{if 'CUarrayMapInfo_st.resource.array' in found_struct}}
    @property
    def array(self):
        return self._array
    @array.setter
    def array(self, array):
        cdef cydriver.CUarray cyarray
        if array is None:
            cyarray = <cydriver.CUarray><void_ptr>0
        elif isinstance(array, (CUarray,)):
            parray = int(array)
            cyarray = <cydriver.CUarray><void_ptr>parray
        else:
            parray = int(CUarray(array))
            cyarray = <cydriver.CUarray><void_ptr>parray
        self._array._pvt_ptr[0] = cyarray
    {{endif}}
{{endif}}
{{if 'CUarrayMapInfo_st.subresource.sparseLevel' in found_struct}}

cdef class anon_struct20:
    """
    Attributes
    ----------
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel.level' in found_struct}}
    level : unsigned int

    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel.layer' in found_struct}}
    layer : unsigned int

    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel.offsetX' in found_struct}}
    offsetX : unsigned int

    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel.offsetY' in found_struct}}
    offsetY : unsigned int

    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel.offsetZ' in found_struct}}
    offsetZ : unsigned int

    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel.extentWidth' in found_struct}}
    extentWidth : unsigned int

    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel.extentHeight' in found_struct}}
    extentHeight : unsigned int

    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel.extentDepth' in found_struct}}
    extentDepth : unsigned int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUarrayMapInfo_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].subresource.sparseLevel
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUarrayMapInfo_st.subresource.sparseLevel.level' in found_struct}}
            try:
                str_list += ['level : ' + str(self.level)]
            except ValueError:
                str_list += ['level : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.subresource.sparseLevel.layer' in found_struct}}
            try:
                str_list += ['layer : ' + str(self.layer)]
            except ValueError:
                str_list += ['layer : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.subresource.sparseLevel.offsetX' in found_struct}}
            try:
                str_list += ['offsetX : ' + str(self.offsetX)]
            except ValueError:
                str_list += ['offsetX : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.subresource.sparseLevel.offsetY' in found_struct}}
            try:
                str_list += ['offsetY : ' + str(self.offsetY)]
            except ValueError:
                str_list += ['offsetY : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.subresource.sparseLevel.offsetZ' in found_struct}}
            try:
                str_list += ['offsetZ : ' + str(self.offsetZ)]
            except ValueError:
                str_list += ['offsetZ : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.subresource.sparseLevel.extentWidth' in found_struct}}
            try:
                str_list += ['extentWidth : ' + str(self.extentWidth)]
            except ValueError:
                str_list += ['extentWidth : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.subresource.sparseLevel.extentHeight' in found_struct}}
            try:
                str_list += ['extentHeight : ' + str(self.extentHeight)]
            except ValueError:
                str_list += ['extentHeight : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.subresource.sparseLevel.extentDepth' in found_struct}}
            try:
                str_list += ['extentDepth : ' + str(self.extentDepth)]
            except ValueError:
                str_list += ['extentDepth : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel.level' in found_struct}}
    @property
    def level(self):
        return self._pvt_ptr[0].subresource.sparseLevel.level
    @level.setter
    def level(self, unsigned int level):
        self._pvt_ptr[0].subresource.sparseLevel.level = level
    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel.layer' in found_struct}}
    @property
    def layer(self):
        return self._pvt_ptr[0].subresource.sparseLevel.layer
    @layer.setter
    def layer(self, unsigned int layer):
        self._pvt_ptr[0].subresource.sparseLevel.layer = layer
    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel.offsetX' in found_struct}}
    @property
    def offsetX(self):
        return self._pvt_ptr[0].subresource.sparseLevel.offsetX
    @offsetX.setter
    def offsetX(self, unsigned int offsetX):
        self._pvt_ptr[0].subresource.sparseLevel.offsetX = offsetX
    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel.offsetY' in found_struct}}
    @property
    def offsetY(self):
        return self._pvt_ptr[0].subresource.sparseLevel.offsetY
    @offsetY.setter
    def offsetY(self, unsigned int offsetY):
        self._pvt_ptr[0].subresource.sparseLevel.offsetY = offsetY
    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel.offsetZ' in found_struct}}
    @property
    def offsetZ(self):
        return self._pvt_ptr[0].subresource.sparseLevel.offsetZ
    @offsetZ.setter
    def offsetZ(self, unsigned int offsetZ):
        self._pvt_ptr[0].subresource.sparseLevel.offsetZ = offsetZ
    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel.extentWidth' in found_struct}}
    @property
    def extentWidth(self):
        return self._pvt_ptr[0].subresource.sparseLevel.extentWidth
    @extentWidth.setter
    def extentWidth(self, unsigned int extentWidth):
        self._pvt_ptr[0].subresource.sparseLevel.extentWidth = extentWidth
    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel.extentHeight' in found_struct}}
    @property
    def extentHeight(self):
        return self._pvt_ptr[0].subresource.sparseLevel.extentHeight
    @extentHeight.setter
    def extentHeight(self, unsigned int extentHeight):
        self._pvt_ptr[0].subresource.sparseLevel.extentHeight = extentHeight
    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel.extentDepth' in found_struct}}
    @property
    def extentDepth(self):
        return self._pvt_ptr[0].subresource.sparseLevel.extentDepth
    @extentDepth.setter
    def extentDepth(self, unsigned int extentDepth):
        self._pvt_ptr[0].subresource.sparseLevel.extentDepth = extentDepth
    {{endif}}
{{endif}}
{{if 'CUarrayMapInfo_st.subresource.miptail' in found_struct}}

cdef class anon_struct21:
    """
    Attributes
    ----------
    {{if 'CUarrayMapInfo_st.subresource.miptail.layer' in found_struct}}
    layer : unsigned int

    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.miptail.offset' in found_struct}}
    offset : unsigned long long

    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.miptail.size' in found_struct}}
    size : unsigned long long

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUarrayMapInfo_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].subresource.miptail
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUarrayMapInfo_st.subresource.miptail.layer' in found_struct}}
            try:
                str_list += ['layer : ' + str(self.layer)]
            except ValueError:
                str_list += ['layer : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.subresource.miptail.offset' in found_struct}}
            try:
                str_list += ['offset : ' + str(self.offset)]
            except ValueError:
                str_list += ['offset : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.subresource.miptail.size' in found_struct}}
            try:
                str_list += ['size : ' + str(self.size)]
            except ValueError:
                str_list += ['size : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUarrayMapInfo_st.subresource.miptail.layer' in found_struct}}
    @property
    def layer(self):
        return self._pvt_ptr[0].subresource.miptail.layer
    @layer.setter
    def layer(self, unsigned int layer):
        self._pvt_ptr[0].subresource.miptail.layer = layer
    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.miptail.offset' in found_struct}}
    @property
    def offset(self):
        return self._pvt_ptr[0].subresource.miptail.offset
    @offset.setter
    def offset(self, unsigned long long offset):
        self._pvt_ptr[0].subresource.miptail.offset = offset
    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.miptail.size' in found_struct}}
    @property
    def size(self):
        return self._pvt_ptr[0].subresource.miptail.size
    @size.setter
    def size(self, unsigned long long size):
        self._pvt_ptr[0].subresource.miptail.size = size
    {{endif}}
{{endif}}
{{if 'CUarrayMapInfo_st.subresource' in found_struct}}

cdef class anon_union10:
    """
    Attributes
    ----------
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel' in found_struct}}
    sparseLevel : anon_struct20

    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.miptail' in found_struct}}
    miptail : anon_struct21

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUarrayMapInfo_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUarrayMapInfo_st.subresource.sparseLevel' in found_struct}}
        self._sparseLevel = anon_struct20(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUarrayMapInfo_st.subresource.miptail' in found_struct}}
        self._miptail = anon_struct21(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].subresource
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUarrayMapInfo_st.subresource.sparseLevel' in found_struct}}
            try:
                str_list += ['sparseLevel :\n' + '\n'.join(['    ' + line for line in str(self.sparseLevel).splitlines()])]
            except ValueError:
                str_list += ['sparseLevel : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.subresource.miptail' in found_struct}}
            try:
                str_list += ['miptail :\n' + '\n'.join(['    ' + line for line in str(self.miptail).splitlines()])]
            except ValueError:
                str_list += ['miptail : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUarrayMapInfo_st.subresource.sparseLevel' in found_struct}}
    @property
    def sparseLevel(self):
        return self._sparseLevel
    @sparseLevel.setter
    def sparseLevel(self, sparseLevel not None : anon_struct20):
        string.memcpy(&self._pvt_ptr[0].subresource.sparseLevel, <cydriver.anon_struct20*><void_ptr>sparseLevel.getPtr(), sizeof(self._pvt_ptr[0].subresource.sparseLevel))
    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource.miptail' in found_struct}}
    @property
    def miptail(self):
        return self._miptail
    @miptail.setter
    def miptail(self, miptail not None : anon_struct21):
        string.memcpy(&self._pvt_ptr[0].subresource.miptail, <cydriver.anon_struct21*><void_ptr>miptail.getPtr(), sizeof(self._pvt_ptr[0].subresource.miptail))
    {{endif}}
{{endif}}
{{if 'CUarrayMapInfo_st.memHandle' in found_struct}}

cdef class anon_union11:
    """
    Attributes
    ----------
    {{if 'CUarrayMapInfo_st.memHandle.memHandle' in found_struct}}
    memHandle : CUmemGenericAllocationHandle

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUarrayMapInfo_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUarrayMapInfo_st.memHandle.memHandle' in found_struct}}
        self._memHandle = CUmemGenericAllocationHandle(_ptr=<void_ptr>&self._pvt_ptr[0].memHandle.memHandle)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].memHandle
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUarrayMapInfo_st.memHandle.memHandle' in found_struct}}
            try:
                str_list += ['memHandle : ' + str(self.memHandle)]
            except ValueError:
                str_list += ['memHandle : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUarrayMapInfo_st.memHandle.memHandle' in found_struct}}
    @property
    def memHandle(self):
        return self._memHandle
    @memHandle.setter
    def memHandle(self, memHandle):
        cdef cydriver.CUmemGenericAllocationHandle cymemHandle
        if memHandle is None:
            cymemHandle = <cydriver.CUmemGenericAllocationHandle><void_ptr>0
        elif isinstance(memHandle, (CUmemGenericAllocationHandle)):
            pmemHandle = int(memHandle)
            cymemHandle = <cydriver.CUmemGenericAllocationHandle><void_ptr>pmemHandle
        else:
            pmemHandle = int(CUmemGenericAllocationHandle(memHandle))
            cymemHandle = <cydriver.CUmemGenericAllocationHandle><void_ptr>pmemHandle
        self._memHandle._pvt_ptr[0] = cymemHandle

    {{endif}}
{{endif}}
{{if 'CUarrayMapInfo_st' in found_struct}}

cdef class CUarrayMapInfo_st:
    """
    Specifies the CUDA array or CUDA mipmapped array memory mapping
    information

    Attributes
    ----------
    {{if 'CUarrayMapInfo_st.resourceType' in found_struct}}
    resourceType : CUresourcetype
        Resource type
    {{endif}}
    {{if 'CUarrayMapInfo_st.resource' in found_struct}}
    resource : anon_union9

    {{endif}}
    {{if 'CUarrayMapInfo_st.subresourceType' in found_struct}}
    subresourceType : CUarraySparseSubresourceType
        Sparse subresource type
    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource' in found_struct}}
    subresource : anon_union10

    {{endif}}
    {{if 'CUarrayMapInfo_st.memOperationType' in found_struct}}
    memOperationType : CUmemOperationType
        Memory operation type
    {{endif}}
    {{if 'CUarrayMapInfo_st.memHandleType' in found_struct}}
    memHandleType : CUmemHandleType
        Memory handle type
    {{endif}}
    {{if 'CUarrayMapInfo_st.memHandle' in found_struct}}
    memHandle : anon_union11

    {{endif}}
    {{if 'CUarrayMapInfo_st.offset' in found_struct}}
    offset : unsigned long long
        Offset within mip tail  Offset within the memory
    {{endif}}
    {{if 'CUarrayMapInfo_st.deviceBitMask' in found_struct}}
    deviceBitMask : unsigned int
        Device ordinal bit mask
    {{endif}}
    {{if 'CUarrayMapInfo_st.flags' in found_struct}}
    flags : unsigned int
        flags for future use, must be zero now.
    {{endif}}
    {{if 'CUarrayMapInfo_st.reserved' in found_struct}}
    reserved : list[unsigned int]
        Reserved for future use, must be zero now.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cydriver.CUarrayMapInfo_st *>calloc(1, sizeof(cydriver.CUarrayMapInfo_st))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cydriver.CUarrayMapInfo_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUarrayMapInfo_st.resource' in found_struct}}
        self._resource = anon_union9(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUarrayMapInfo_st.subresource' in found_struct}}
        self._subresource = anon_union10(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUarrayMapInfo_st.memHandle' in found_struct}}
        self._memHandle = anon_union11(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUarrayMapInfo_st.resourceType' in found_struct}}
            try:
                str_list += ['resourceType : ' + str(self.resourceType)]
            except ValueError:
                str_list += ['resourceType : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.resource' in found_struct}}
            try:
                str_list += ['resource :\n' + '\n'.join(['    ' + line for line in str(self.resource).splitlines()])]
            except ValueError:
                str_list += ['resource : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.subresourceType' in found_struct}}
            try:
                str_list += ['subresourceType : ' + str(self.subresourceType)]
            except ValueError:
                str_list += ['subresourceType : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.subresource' in found_struct}}
            try:
                str_list += ['subresource :\n' + '\n'.join(['    ' + line for line in str(self.subresource).splitlines()])]
            except ValueError:
                str_list += ['subresource : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.memOperationType' in found_struct}}
            try:
                str_list += ['memOperationType : ' + str(self.memOperationType)]
            except ValueError:
                str_list += ['memOperationType : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.memHandleType' in found_struct}}
            try:
                str_list += ['memHandleType : ' + str(self.memHandleType)]
            except ValueError:
                str_list += ['memHandleType : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.memHandle' in found_struct}}
            try:
                str_list += ['memHandle :\n' + '\n'.join(['    ' + line for line in str(self.memHandle).splitlines()])]
            except ValueError:
                str_list += ['memHandle : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.offset' in found_struct}}
            try:
                str_list += ['offset : ' + str(self.offset)]
            except ValueError:
                str_list += ['offset : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.deviceBitMask' in found_struct}}
            try:
                str_list += ['deviceBitMask : ' + str(self.deviceBitMask)]
            except ValueError:
                str_list += ['deviceBitMask : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'CUarrayMapInfo_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUarrayMapInfo_st.resourceType' in found_struct}}
    @property
    def resourceType(self):
        if self._pvt_ptr[0].resourceType not in _dict_CUresourcetype:
            return None
        return _dict_CUresourcetype[self._pvt_ptr[0].resourceType]
    @resourceType.setter
    def resourceType(self, resourceType not None : CUresourcetype):
        self._pvt_ptr[0].resourceType = resourceType.value
    {{endif}}
    {{if 'CUarrayMapInfo_st.resource' in found_struct}}
    @property
    def resource(self):
        return self._resource
    @resource.setter
    def resource(self, resource not None : anon_union9):
        string.memcpy(&self._pvt_ptr[0].resource, <cydriver.anon_union9*><void_ptr>resource.getPtr(), sizeof(self._pvt_ptr[0].resource))
    {{endif}}
    {{if 'CUarrayMapInfo_st.subresourceType' in found_struct}}
    @property
    def subresourceType(self):
        if self._pvt_ptr[0].subresourceType not in _dict_CUarraySparseSubresourceType:
            return None
        return _dict_CUarraySparseSubresourceType[self._pvt_ptr[0].subresourceType]
    @subresourceType.setter
    def subresourceType(self, subresourceType not None : CUarraySparseSubresourceType):
        self._pvt_ptr[0].subresourceType = subresourceType.value
    {{endif}}
    {{if 'CUarrayMapInfo_st.subresource' in found_struct}}
    @property
    def subresource(self):
        return self._subresource
    @subresource.setter
    def subresource(self, subresource not None : anon_union10):
        string.memcpy(&self._pvt_ptr[0].subresource, <cydriver.anon_union10*><void_ptr>subresource.getPtr(), sizeof(self._pvt_ptr[0].subresource))
    {{endif}}
    {{if 'CUarrayMapInfo_st.memOperationType' in found_struct}}
    @property
    def memOperationType(self):
        if self._pvt_ptr[0].memOperationType not in _dict_CUmemOperationType:
            return None
        return _dict_CUmemOperationType[self._pvt_ptr[0].memOperationType]
    @memOperationType.setter
    def memOperationType(self, memOperationType not None : CUmemOperationType):
        self._pvt_ptr[0].memOperationType = memOperationType.value
    {{endif}}
    {{if 'CUarrayMapInfo_st.memHandleType' in found_struct}}
    @property
    def memHandleType(self):
        if self._pvt_ptr[0].memHandleType not in _dict_CUmemHandleType:
            return None
        return _dict_CUmemHandleType[self._pvt_ptr[0].memHandleType]
    @memHandleType.setter
    def memHandleType(self, memHandleType not None : CUmemHandleType):
        self._pvt_ptr[0].memHandleType = memHandleType.value
    {{endif}}
    {{if 'CUarrayMapInfo_st.memHandle' in found_struct}}
    @property
    def memHandle(self):
        return self._memHandle
    @memHandle.setter
    def memHandle(self, memHandle not None : anon_union11):
        string.memcpy(&self._pvt_ptr[0].memHandle, <cydriver.anon_union11*><void_ptr>memHandle.getPtr(), sizeof(self._pvt_ptr[0].memHandle))
    {{endif}}
    {{if 'CUarrayMapInfo_st.offset' in found_struct}}
    @property
    def offset(self):
        return self._pvt_ptr[0].offset
    @offset.setter
    def offset(self, unsigned long long offset):
        self._pvt_ptr[0].offset = offset
    {{endif}}
    {{if 'CUarrayMapInfo_st.deviceBitMask' in found_struct}}
    @property
    def deviceBitMask(self):
        return self._pvt_ptr[0].deviceBitMask
    @deviceBitMask.setter
    def deviceBitMask(self, unsigned int deviceBitMask):
        self._pvt_ptr[0].deviceBitMask = deviceBitMask
    {{endif}}
    {{if 'CUarrayMapInfo_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'CUarrayMapInfo_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'CUmemLocation_st' in found_struct}}

cdef class CUmemLocation_st:
    """
    Specifies a memory location.

    Attributes
    ----------
    {{if 'CUmemLocation_st.type' in found_struct}}
    type : CUmemLocationType
        Specifies the location type, which modifies the meaning of id.
    {{endif}}
    {{if 'CUmemLocation_st.id' in found_struct}}
    id : int
        identifier for a given this location's CUmemLocationType.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUmemLocation_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUmemLocation_st.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'CUmemLocation_st.id' in found_struct}}
            try:
                str_list += ['id : ' + str(self.id)]
            except ValueError:
                str_list += ['id : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUmemLocation_st.type' in found_struct}}
    @property
    def type(self):
        if self._pvt_ptr[0].type not in _dict_CUmemLocationType:
            return None
        return _dict_CUmemLocationType[self._pvt_ptr[0].type]
    @type.setter
    def type(self, type not None : CUmemLocationType):
        self._pvt_ptr[0].type = type.value
    {{endif}}
    {{if 'CUmemLocation_st.id' in found_struct}}
    @property
    def id(self):
        return self._pvt_ptr[0].id
    @id.setter
    def id(self, int id):
        self._pvt_ptr[0].id = id
    {{endif}}
{{endif}}
{{if 'CUmemAllocationProp_st.allocFlags' in found_struct}}

cdef class anon_struct22:
    """
    Attributes
    ----------
    {{if 'CUmemAllocationProp_st.allocFlags.compressionType' in found_struct}}
    compressionType : bytes

    {{endif}}
    {{if 'CUmemAllocationProp_st.allocFlags.gpuDirectRDMACapable' in found_struct}}
    gpuDirectRDMACapable : bytes

    {{endif}}
    {{if 'CUmemAllocationProp_st.allocFlags.usage' in found_struct}}
    usage : unsigned short

    {{endif}}
    {{if 'CUmemAllocationProp_st.allocFlags.reserved' in found_struct}}
    reserved : bytes

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUmemAllocationProp_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].allocFlags
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUmemAllocationProp_st.allocFlags.compressionType' in found_struct}}
            try:
                str_list += ['compressionType : ' + str(self.compressionType)]
            except ValueError:
                str_list += ['compressionType : <ValueError>']
            {{endif}}
            {{if 'CUmemAllocationProp_st.allocFlags.gpuDirectRDMACapable' in found_struct}}
            try:
                str_list += ['gpuDirectRDMACapable : ' + str(self.gpuDirectRDMACapable)]
            except ValueError:
                str_list += ['gpuDirectRDMACapable : <ValueError>']
            {{endif}}
            {{if 'CUmemAllocationProp_st.allocFlags.usage' in found_struct}}
            try:
                str_list += ['usage : ' + str(self.usage)]
            except ValueError:
                str_list += ['usage : <ValueError>']
            {{endif}}
            {{if 'CUmemAllocationProp_st.allocFlags.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUmemAllocationProp_st.allocFlags.compressionType' in found_struct}}
    @property
    def compressionType(self):
        return self._pvt_ptr[0].allocFlags.compressionType
    @compressionType.setter
    def compressionType(self, unsigned char compressionType):
        self._pvt_ptr[0].allocFlags.compressionType = compressionType
    {{endif}}
    {{if 'CUmemAllocationProp_st.allocFlags.gpuDirectRDMACapable' in found_struct}}
    @property
    def gpuDirectRDMACapable(self):
        return self._pvt_ptr[0].allocFlags.gpuDirectRDMACapable
    @gpuDirectRDMACapable.setter
    def gpuDirectRDMACapable(self, unsigned char gpuDirectRDMACapable):
        self._pvt_ptr[0].allocFlags.gpuDirectRDMACapable = gpuDirectRDMACapable
    {{endif}}
    {{if 'CUmemAllocationProp_st.allocFlags.usage' in found_struct}}
    @property
    def usage(self):
        return self._pvt_ptr[0].allocFlags.usage
    @usage.setter
    def usage(self, unsigned short usage):
        self._pvt_ptr[0].allocFlags.usage = usage
    {{endif}}
    {{if 'CUmemAllocationProp_st.allocFlags.reserved' in found_struct}}
    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(<char*>self._pvt_ptr[0].allocFlags.reserved, 4)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 4:
            raise ValueError("reserved length must be 4, is " + str(len(reserved)))
        for i, b in enumerate(reserved):
            self._pvt_ptr[0].allocFlags.reserved[i] = b
    {{endif}}
{{endif}}
{{if 'CUmemAllocationProp_st' in found_struct}}

cdef class CUmemAllocationProp_st:
    """
    Specifies the allocation properties for a allocation.

    Attributes
    ----------
    {{if 'CUmemAllocationProp_st.type' in found_struct}}
    type : CUmemAllocationType
        Allocation type
    {{endif}}
    {{if 'CUmemAllocationProp_st.requestedHandleTypes' in found_struct}}
    requestedHandleTypes : CUmemAllocationHandleType
        requested CUmemAllocationHandleType
    {{endif}}
    {{if 'CUmemAllocationProp_st.location' in found_struct}}
    location : CUmemLocation
        Location of allocation
    {{endif}}
    {{if 'CUmemAllocationProp_st.win32HandleMetaData' in found_struct}}
    win32HandleMetaData : Any
        Windows-specific POBJECT_ATTRIBUTES required when
        CU_MEM_HANDLE_TYPE_WIN32 is specified. This object attributes
        structure includes security attributes that define the scope of
        which exported allocations may be transferred to other processes.
        In all other cases, this field is required to be zero.
    {{endif}}
    {{if 'CUmemAllocationProp_st.allocFlags' in found_struct}}
    allocFlags : anon_struct22

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUmemAllocationProp_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUmemAllocationProp_st.location' in found_struct}}
        self._location = CUmemLocation(_ptr=<void_ptr>&self._pvt_ptr[0].location)
        {{endif}}
        {{if 'CUmemAllocationProp_st.allocFlags' in found_struct}}
        self._allocFlags = anon_struct22(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUmemAllocationProp_st.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'CUmemAllocationProp_st.requestedHandleTypes' in found_struct}}
            try:
                str_list += ['requestedHandleTypes : ' + str(self.requestedHandleTypes)]
            except ValueError:
                str_list += ['requestedHandleTypes : <ValueError>']
            {{endif}}
            {{if 'CUmemAllocationProp_st.location' in found_struct}}
            try:
                str_list += ['location :\n' + '\n'.join(['    ' + line for line in str(self.location).splitlines()])]
            except ValueError:
                str_list += ['location : <ValueError>']
            {{endif}}
            {{if 'CUmemAllocationProp_st.win32HandleMetaData' in found_struct}}
            try:
                str_list += ['win32HandleMetaData : ' + hex(self.win32HandleMetaData)]
            except ValueError:
                str_list += ['win32HandleMetaData : <ValueError>']
            {{endif}}
            {{if 'CUmemAllocationProp_st.allocFlags' in found_struct}}
            try:
                str_list += ['allocFlags :\n' + '\n'.join(['    ' + line for line in str(self.allocFlags).splitlines()])]
            except ValueError:
                str_list += ['allocFlags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUmemAllocationProp_st.type' in found_struct}}
    @property
    def type(self):
        if self._pvt_ptr[0].type not in _dict_CUmemAllocationType:
            return None
        return _dict_CUmemAllocationType[self._pvt_ptr[0].type]
    @type.setter
    def type(self, type not None : CUmemAllocationType):
        self._pvt_ptr[0].type = type.value
    {{endif}}
    {{if 'CUmemAllocationProp_st.requestedHandleTypes' in found_struct}}
    @property
    def requestedHandleTypes(self):
        if self._pvt_ptr[0].requestedHandleTypes not in _dict_CUmemAllocationHandleType:
            return None
        return _dict_CUmemAllocationHandleType[self._pvt_ptr[0].requestedHandleTypes]
    @requestedHandleTypes.setter
    def requestedHandleTypes(self, requestedHandleTypes not None : CUmemAllocationHandleType):
        self._pvt_ptr[0].requestedHandleTypes = requestedHandleTypes.value
    {{endif}}
    {{if 'CUmemAllocationProp_st.location' in found_struct}}
    @property
    def location(self):
        return self._location
    @location.setter
    def location(self, location not None : CUmemLocation):
        string.memcpy(&self._pvt_ptr[0].location, <cydriver.CUmemLocation*><void_ptr>location.getPtr(), sizeof(self._pvt_ptr[0].location))
    {{endif}}
    {{if 'CUmemAllocationProp_st.win32HandleMetaData' in found_struct}}
    @property
    def win32HandleMetaData(self):
        return <void_ptr>self._pvt_ptr[0].win32HandleMetaData
    @win32HandleMetaData.setter
    def win32HandleMetaData(self, win32HandleMetaData):
        _cwin32HandleMetaData = _HelperInputVoidPtr(win32HandleMetaData)
        self._pvt_ptr[0].win32HandleMetaData = <void*><void_ptr>_cwin32HandleMetaData.cptr
    {{endif}}
    {{if 'CUmemAllocationProp_st.allocFlags' in found_struct}}
    @property
    def allocFlags(self):
        return self._allocFlags
    @allocFlags.setter
    def allocFlags(self, allocFlags not None : anon_struct22):
        string.memcpy(&self._pvt_ptr[0].allocFlags, <cydriver.anon_struct22*><void_ptr>allocFlags.getPtr(), sizeof(self._pvt_ptr[0].allocFlags))
    {{endif}}
{{endif}}
{{if 'CUmulticastObjectProp_st' in found_struct}}

cdef class CUmulticastObjectProp_st:
    """
    Specifies the properties for a multicast object.

    Attributes
    ----------
    {{if 'CUmulticastObjectProp_st.numDevices' in found_struct}}
    numDevices : unsigned int
        The number of devices in the multicast team that will bind memory
        to this object
    {{endif}}
    {{if 'CUmulticastObjectProp_st.size' in found_struct}}
    size : size_t
        The maximum amount of memory that can be bound to this multicast
        object per device
    {{endif}}
    {{if 'CUmulticastObjectProp_st.handleTypes' in found_struct}}
    handleTypes : unsigned long long
        Bitmask of exportable handle types (see CUmemAllocationHandleType)
        for this object
    {{endif}}
    {{if 'CUmulticastObjectProp_st.flags' in found_struct}}
    flags : unsigned long long
        Flags for future use, must be zero now
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUmulticastObjectProp_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUmulticastObjectProp_st.numDevices' in found_struct}}
            try:
                str_list += ['numDevices : ' + str(self.numDevices)]
            except ValueError:
                str_list += ['numDevices : <ValueError>']
            {{endif}}
            {{if 'CUmulticastObjectProp_st.size' in found_struct}}
            try:
                str_list += ['size : ' + str(self.size)]
            except ValueError:
                str_list += ['size : <ValueError>']
            {{endif}}
            {{if 'CUmulticastObjectProp_st.handleTypes' in found_struct}}
            try:
                str_list += ['handleTypes : ' + str(self.handleTypes)]
            except ValueError:
                str_list += ['handleTypes : <ValueError>']
            {{endif}}
            {{if 'CUmulticastObjectProp_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUmulticastObjectProp_st.numDevices' in found_struct}}
    @property
    def numDevices(self):
        return self._pvt_ptr[0].numDevices
    @numDevices.setter
    def numDevices(self, unsigned int numDevices):
        self._pvt_ptr[0].numDevices = numDevices
    {{endif}}
    {{if 'CUmulticastObjectProp_st.size' in found_struct}}
    @property
    def size(self):
        return self._pvt_ptr[0].size
    @size.setter
    def size(self, size_t size):
        self._pvt_ptr[0].size = size
    {{endif}}
    {{if 'CUmulticastObjectProp_st.handleTypes' in found_struct}}
    @property
    def handleTypes(self):
        return self._pvt_ptr[0].handleTypes
    @handleTypes.setter
    def handleTypes(self, unsigned long long handleTypes):
        self._pvt_ptr[0].handleTypes = handleTypes
    {{endif}}
    {{if 'CUmulticastObjectProp_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned long long flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
{{endif}}
{{if 'CUmemAccessDesc_st' in found_struct}}

cdef class CUmemAccessDesc_st:
    """
    Memory access descriptor

    Attributes
    ----------
    {{if 'CUmemAccessDesc_st.location' in found_struct}}
    location : CUmemLocation
        Location on which the request is to change it's accessibility
    {{endif}}
    {{if 'CUmemAccessDesc_st.flags' in found_struct}}
    flags : CUmemAccess_flags
        ::CUmemProt accessibility flags to set on the request
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUmemAccessDesc_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUmemAccessDesc_st.location' in found_struct}}
        self._location = CUmemLocation(_ptr=<void_ptr>&self._pvt_ptr[0].location)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUmemAccessDesc_st.location' in found_struct}}
            try:
                str_list += ['location :\n' + '\n'.join(['    ' + line for line in str(self.location).splitlines()])]
            except ValueError:
                str_list += ['location : <ValueError>']
            {{endif}}
            {{if 'CUmemAccessDesc_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUmemAccessDesc_st.location' in found_struct}}
    @property
    def location(self):
        return self._location
    @location.setter
    def location(self, location not None : CUmemLocation):
        string.memcpy(&self._pvt_ptr[0].location, <cydriver.CUmemLocation*><void_ptr>location.getPtr(), sizeof(self._pvt_ptr[0].location))
    {{endif}}
    {{if 'CUmemAccessDesc_st.flags' in found_struct}}
    @property
    def flags(self):
        if self._pvt_ptr[0].flags not in _dict_CUmemAccess_flags:
            return None
        return _dict_CUmemAccess_flags[self._pvt_ptr[0].flags]
    @flags.setter
    def flags(self, flags not None : CUmemAccess_flags):
        self._pvt_ptr[0].flags = flags.value
    {{endif}}
{{endif}}
{{if 'CUgraphExecUpdateResultInfo_st' in found_struct}}

cdef class CUgraphExecUpdateResultInfo_st:
    """
    Result information returned by cuGraphExecUpdate

    Attributes
    ----------
    {{if 'CUgraphExecUpdateResultInfo_st.result' in found_struct}}
    result : CUgraphExecUpdateResult
        Gives more specific detail when a cuda graph update fails.
    {{endif}}
    {{if 'CUgraphExecUpdateResultInfo_st.errorNode' in found_struct}}
    errorNode : CUgraphNode
        The "to node" of the error edge when the topologies do not match.
        The error node when the error is associated with a specific node.
        NULL when the error is generic.
    {{endif}}
    {{if 'CUgraphExecUpdateResultInfo_st.errorFromNode' in found_struct}}
    errorFromNode : CUgraphNode
        The from node of error edge when the topologies do not match.
        Otherwise NULL.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUgraphExecUpdateResultInfo_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUgraphExecUpdateResultInfo_st.errorNode' in found_struct}}
        self._errorNode = CUgraphNode(_ptr=<void_ptr>&self._pvt_ptr[0].errorNode)
        {{endif}}
        {{if 'CUgraphExecUpdateResultInfo_st.errorFromNode' in found_struct}}
        self._errorFromNode = CUgraphNode(_ptr=<void_ptr>&self._pvt_ptr[0].errorFromNode)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUgraphExecUpdateResultInfo_st.result' in found_struct}}
            try:
                str_list += ['result : ' + str(self.result)]
            except ValueError:
                str_list += ['result : <ValueError>']
            {{endif}}
            {{if 'CUgraphExecUpdateResultInfo_st.errorNode' in found_struct}}
            try:
                str_list += ['errorNode : ' + str(self.errorNode)]
            except ValueError:
                str_list += ['errorNode : <ValueError>']
            {{endif}}
            {{if 'CUgraphExecUpdateResultInfo_st.errorFromNode' in found_struct}}
            try:
                str_list += ['errorFromNode : ' + str(self.errorFromNode)]
            except ValueError:
                str_list += ['errorFromNode : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUgraphExecUpdateResultInfo_st.result' in found_struct}}
    @property
    def result(self):
        if self._pvt_ptr[0].result not in _dict_CUgraphExecUpdateResult:
            return None
        return _dict_CUgraphExecUpdateResult[self._pvt_ptr[0].result]
    @result.setter
    def result(self, result not None : CUgraphExecUpdateResult):
        self._pvt_ptr[0].result = result.value
    {{endif}}
    {{if 'CUgraphExecUpdateResultInfo_st.errorNode' in found_struct}}
    @property
    def errorNode(self):
        return self._errorNode
    @errorNode.setter
    def errorNode(self, errorNode):
        cdef cydriver.CUgraphNode cyerrorNode
        if errorNode is None:
            cyerrorNode = <cydriver.CUgraphNode><void_ptr>0
        elif isinstance(errorNode, (CUgraphNode,)):
            perrorNode = int(errorNode)
            cyerrorNode = <cydriver.CUgraphNode><void_ptr>perrorNode
        else:
            perrorNode = int(CUgraphNode(errorNode))
            cyerrorNode = <cydriver.CUgraphNode><void_ptr>perrorNode
        self._errorNode._pvt_ptr[0] = cyerrorNode
    {{endif}}
    {{if 'CUgraphExecUpdateResultInfo_st.errorFromNode' in found_struct}}
    @property
    def errorFromNode(self):
        return self._errorFromNode
    @errorFromNode.setter
    def errorFromNode(self, errorFromNode):
        cdef cydriver.CUgraphNode cyerrorFromNode
        if errorFromNode is None:
            cyerrorFromNode = <cydriver.CUgraphNode><void_ptr>0
        elif isinstance(errorFromNode, (CUgraphNode,)):
            perrorFromNode = int(errorFromNode)
            cyerrorFromNode = <cydriver.CUgraphNode><void_ptr>perrorFromNode
        else:
            perrorFromNode = int(CUgraphNode(errorFromNode))
            cyerrorFromNode = <cydriver.CUgraphNode><void_ptr>perrorFromNode
        self._errorFromNode._pvt_ptr[0] = cyerrorFromNode
    {{endif}}
{{endif}}
{{if 'CUmemPoolProps_st' in found_struct}}

cdef class CUmemPoolProps_st:
    """
    Specifies the properties of allocations made from the pool.

    Attributes
    ----------
    {{if 'CUmemPoolProps_st.allocType' in found_struct}}
    allocType : CUmemAllocationType
        Allocation type. Currently must be specified as
        CU_MEM_ALLOCATION_TYPE_PINNED
    {{endif}}
    {{if 'CUmemPoolProps_st.handleTypes' in found_struct}}
    handleTypes : CUmemAllocationHandleType
        Handle types that will be supported by allocations from the pool.
    {{endif}}
    {{if 'CUmemPoolProps_st.location' in found_struct}}
    location : CUmemLocation
        Location where allocations should reside.
    {{endif}}
    {{if 'CUmemPoolProps_st.win32SecurityAttributes' in found_struct}}
    win32SecurityAttributes : Any
        Windows-specific LPSECURITYATTRIBUTES required when
        CU_MEM_HANDLE_TYPE_WIN32 is specified. This security attribute
        defines the scope of which exported allocations may be transferred
        to other processes. In all other cases, this field is required to
        be zero.
    {{endif}}
    {{if 'CUmemPoolProps_st.maxSize' in found_struct}}
    maxSize : size_t
        Maximum pool size. When set to 0, defaults to a system dependent
        value.
    {{endif}}
    {{if 'CUmemPoolProps_st.usage' in found_struct}}
    usage : unsigned short
        Bitmask indicating intended usage for the pool.
    {{endif}}
    {{if 'CUmemPoolProps_st.reserved' in found_struct}}
    reserved : bytes
        reserved for future use, must be 0
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUmemPoolProps_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUmemPoolProps_st.location' in found_struct}}
        self._location = CUmemLocation(_ptr=<void_ptr>&self._pvt_ptr[0].location)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUmemPoolProps_st.allocType' in found_struct}}
            try:
                str_list += ['allocType : ' + str(self.allocType)]
            except ValueError:
                str_list += ['allocType : <ValueError>']
            {{endif}}
            {{if 'CUmemPoolProps_st.handleTypes' in found_struct}}
            try:
                str_list += ['handleTypes : ' + str(self.handleTypes)]
            except ValueError:
                str_list += ['handleTypes : <ValueError>']
            {{endif}}
            {{if 'CUmemPoolProps_st.location' in found_struct}}
            try:
                str_list += ['location :\n' + '\n'.join(['    ' + line for line in str(self.location).splitlines()])]
            except ValueError:
                str_list += ['location : <ValueError>']
            {{endif}}
            {{if 'CUmemPoolProps_st.win32SecurityAttributes' in found_struct}}
            try:
                str_list += ['win32SecurityAttributes : ' + hex(self.win32SecurityAttributes)]
            except ValueError:
                str_list += ['win32SecurityAttributes : <ValueError>']
            {{endif}}
            {{if 'CUmemPoolProps_st.maxSize' in found_struct}}
            try:
                str_list += ['maxSize : ' + str(self.maxSize)]
            except ValueError:
                str_list += ['maxSize : <ValueError>']
            {{endif}}
            {{if 'CUmemPoolProps_st.usage' in found_struct}}
            try:
                str_list += ['usage : ' + str(self.usage)]
            except ValueError:
                str_list += ['usage : <ValueError>']
            {{endif}}
            {{if 'CUmemPoolProps_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUmemPoolProps_st.allocType' in found_struct}}
    @property
    def allocType(self):
        if self._pvt_ptr[0].allocType not in _dict_CUmemAllocationType:
            return None
        return _dict_CUmemAllocationType[self._pvt_ptr[0].allocType]
    @allocType.setter
    def allocType(self, allocType not None : CUmemAllocationType):
        self._pvt_ptr[0].allocType = allocType.value
    {{endif}}
    {{if 'CUmemPoolProps_st.handleTypes' in found_struct}}
    @property
    def handleTypes(self):
        if self._pvt_ptr[0].handleTypes not in _dict_CUmemAllocationHandleType:
            return None
        return _dict_CUmemAllocationHandleType[self._pvt_ptr[0].handleTypes]
    @handleTypes.setter
    def handleTypes(self, handleTypes not None : CUmemAllocationHandleType):
        self._pvt_ptr[0].handleTypes = handleTypes.value
    {{endif}}
    {{if 'CUmemPoolProps_st.location' in found_struct}}
    @property
    def location(self):
        return self._location
    @location.setter
    def location(self, location not None : CUmemLocation):
        string.memcpy(&self._pvt_ptr[0].location, <cydriver.CUmemLocation*><void_ptr>location.getPtr(), sizeof(self._pvt_ptr[0].location))
    {{endif}}
    {{if 'CUmemPoolProps_st.win32SecurityAttributes' in found_struct}}
    @property
    def win32SecurityAttributes(self):
        return <void_ptr>self._pvt_ptr[0].win32SecurityAttributes
    @win32SecurityAttributes.setter
    def win32SecurityAttributes(self, win32SecurityAttributes):
        _cwin32SecurityAttributes = _HelperInputVoidPtr(win32SecurityAttributes)
        self._pvt_ptr[0].win32SecurityAttributes = <void*><void_ptr>_cwin32SecurityAttributes.cptr
    {{endif}}
    {{if 'CUmemPoolProps_st.maxSize' in found_struct}}
    @property
    def maxSize(self):
        return self._pvt_ptr[0].maxSize
    @maxSize.setter
    def maxSize(self, size_t maxSize):
        self._pvt_ptr[0].maxSize = maxSize
    {{endif}}
    {{if 'CUmemPoolProps_st.usage' in found_struct}}
    @property
    def usage(self):
        return self._pvt_ptr[0].usage
    @usage.setter
    def usage(self, unsigned short usage):
        self._pvt_ptr[0].usage = usage
    {{endif}}
    {{if 'CUmemPoolProps_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(<char*>self._pvt_ptr[0].reserved, 54)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 54:
            raise ValueError("reserved length must be 54, is " + str(len(reserved)))
        for i, b in enumerate(reserved):
            self._pvt_ptr[0].reserved[i] = b
    {{endif}}
{{endif}}
{{if 'CUmemPoolPtrExportData_st' in found_struct}}

cdef class CUmemPoolPtrExportData_st:
    """
    Opaque data for exporting a pool allocation

    Attributes
    ----------
    {{if 'CUmemPoolPtrExportData_st.reserved' in found_struct}}
    reserved : bytes

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUmemPoolPtrExportData_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUmemPoolPtrExportData_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUmemPoolPtrExportData_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(<char*>self._pvt_ptr[0].reserved, 64)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 64:
            raise ValueError("reserved length must be 64, is " + str(len(reserved)))
        for i, b in enumerate(reserved):
            self._pvt_ptr[0].reserved[i] = b
    {{endif}}
{{endif}}
{{if 'CUmemcpyAttributes_st' in found_struct}}

cdef class CUmemcpyAttributes_st:
    """
    Attributes specific to copies within a batch. For more details on
    usage see cuMemcpyBatchAsync.

    Attributes
    ----------
    {{if 'CUmemcpyAttributes_st.srcAccessOrder' in found_struct}}
    srcAccessOrder : CUmemcpySrcAccessOrder
        Source access ordering to be observed for copies with this
        attribute.
    {{endif}}
    {{if 'CUmemcpyAttributes_st.srcLocHint' in found_struct}}
    srcLocHint : CUmemLocation
        Hint location for the source operand. Ignored when the pointers are
        not managed memory or memory allocated outside CUDA.
    {{endif}}
    {{if 'CUmemcpyAttributes_st.dstLocHint' in found_struct}}
    dstLocHint : CUmemLocation
        Hint location for the destination operand. Ignored when the
        pointers are not managed memory or memory allocated outside CUDA.
    {{endif}}
    {{if 'CUmemcpyAttributes_st.flags' in found_struct}}
    flags : unsigned int
        Additional flags for copies with this attribute. See CUmemcpyFlags
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUmemcpyAttributes_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUmemcpyAttributes_st.srcLocHint' in found_struct}}
        self._srcLocHint = CUmemLocation(_ptr=<void_ptr>&self._pvt_ptr[0].srcLocHint)
        {{endif}}
        {{if 'CUmemcpyAttributes_st.dstLocHint' in found_struct}}
        self._dstLocHint = CUmemLocation(_ptr=<void_ptr>&self._pvt_ptr[0].dstLocHint)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUmemcpyAttributes_st.srcAccessOrder' in found_struct}}
            try:
                str_list += ['srcAccessOrder : ' + str(self.srcAccessOrder)]
            except ValueError:
                str_list += ['srcAccessOrder : <ValueError>']
            {{endif}}
            {{if 'CUmemcpyAttributes_st.srcLocHint' in found_struct}}
            try:
                str_list += ['srcLocHint :\n' + '\n'.join(['    ' + line for line in str(self.srcLocHint).splitlines()])]
            except ValueError:
                str_list += ['srcLocHint : <ValueError>']
            {{endif}}
            {{if 'CUmemcpyAttributes_st.dstLocHint' in found_struct}}
            try:
                str_list += ['dstLocHint :\n' + '\n'.join(['    ' + line for line in str(self.dstLocHint).splitlines()])]
            except ValueError:
                str_list += ['dstLocHint : <ValueError>']
            {{endif}}
            {{if 'CUmemcpyAttributes_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUmemcpyAttributes_st.srcAccessOrder' in found_struct}}
    @property
    def srcAccessOrder(self):
        if self._pvt_ptr[0].srcAccessOrder not in _dict_CUmemcpySrcAccessOrder:
            return None
        return _dict_CUmemcpySrcAccessOrder[self._pvt_ptr[0].srcAccessOrder]
    @srcAccessOrder.setter
    def srcAccessOrder(self, srcAccessOrder not None : CUmemcpySrcAccessOrder):
        self._pvt_ptr[0].srcAccessOrder = srcAccessOrder.value
    {{endif}}
    {{if 'CUmemcpyAttributes_st.srcLocHint' in found_struct}}
    @property
    def srcLocHint(self):
        return self._srcLocHint
    @srcLocHint.setter
    def srcLocHint(self, srcLocHint not None : CUmemLocation):
        string.memcpy(&self._pvt_ptr[0].srcLocHint, <cydriver.CUmemLocation*><void_ptr>srcLocHint.getPtr(), sizeof(self._pvt_ptr[0].srcLocHint))
    {{endif}}
    {{if 'CUmemcpyAttributes_st.dstLocHint' in found_struct}}
    @property
    def dstLocHint(self):
        return self._dstLocHint
    @dstLocHint.setter
    def dstLocHint(self, dstLocHint not None : CUmemLocation):
        string.memcpy(&self._pvt_ptr[0].dstLocHint, <cydriver.CUmemLocation*><void_ptr>dstLocHint.getPtr(), sizeof(self._pvt_ptr[0].dstLocHint))
    {{endif}}
    {{if 'CUmemcpyAttributes_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
{{endif}}
{{if 'CUoffset3D_st' in found_struct}}

cdef class CUoffset3D_st:
    """
    Struct representing offset into a CUarray in elements

    Attributes
    ----------
    {{if 'CUoffset3D_st.x' in found_struct}}
    x : size_t

    {{endif}}
    {{if 'CUoffset3D_st.y' in found_struct}}
    y : size_t

    {{endif}}
    {{if 'CUoffset3D_st.z' in found_struct}}
    z : size_t

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUoffset3D_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUoffset3D_st.x' in found_struct}}
            try:
                str_list += ['x : ' + str(self.x)]
            except ValueError:
                str_list += ['x : <ValueError>']
            {{endif}}
            {{if 'CUoffset3D_st.y' in found_struct}}
            try:
                str_list += ['y : ' + str(self.y)]
            except ValueError:
                str_list += ['y : <ValueError>']
            {{endif}}
            {{if 'CUoffset3D_st.z' in found_struct}}
            try:
                str_list += ['z : ' + str(self.z)]
            except ValueError:
                str_list += ['z : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUoffset3D_st.x' in found_struct}}
    @property
    def x(self):
        return self._pvt_ptr[0].x
    @x.setter
    def x(self, size_t x):
        self._pvt_ptr[0].x = x
    {{endif}}
    {{if 'CUoffset3D_st.y' in found_struct}}
    @property
    def y(self):
        return self._pvt_ptr[0].y
    @y.setter
    def y(self, size_t y):
        self._pvt_ptr[0].y = y
    {{endif}}
    {{if 'CUoffset3D_st.z' in found_struct}}
    @property
    def z(self):
        return self._pvt_ptr[0].z
    @z.setter
    def z(self, size_t z):
        self._pvt_ptr[0].z = z
    {{endif}}
{{endif}}
{{if 'CUextent3D_st' in found_struct}}

cdef class CUextent3D_st:
    """
    Struct representing width/height/depth of a CUarray in elements

    Attributes
    ----------
    {{if 'CUextent3D_st.width' in found_struct}}
    width : size_t

    {{endif}}
    {{if 'CUextent3D_st.height' in found_struct}}
    height : size_t

    {{endif}}
    {{if 'CUextent3D_st.depth' in found_struct}}
    depth : size_t

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUextent3D_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUextent3D_st.width' in found_struct}}
            try:
                str_list += ['width : ' + str(self.width)]
            except ValueError:
                str_list += ['width : <ValueError>']
            {{endif}}
            {{if 'CUextent3D_st.height' in found_struct}}
            try:
                str_list += ['height : ' + str(self.height)]
            except ValueError:
                str_list += ['height : <ValueError>']
            {{endif}}
            {{if 'CUextent3D_st.depth' in found_struct}}
            try:
                str_list += ['depth : ' + str(self.depth)]
            except ValueError:
                str_list += ['depth : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUextent3D_st.width' in found_struct}}
    @property
    def width(self):
        return self._pvt_ptr[0].width
    @width.setter
    def width(self, size_t width):
        self._pvt_ptr[0].width = width
    {{endif}}
    {{if 'CUextent3D_st.height' in found_struct}}
    @property
    def height(self):
        return self._pvt_ptr[0].height
    @height.setter
    def height(self, size_t height):
        self._pvt_ptr[0].height = height
    {{endif}}
    {{if 'CUextent3D_st.depth' in found_struct}}
    @property
    def depth(self):
        return self._pvt_ptr[0].depth
    @depth.setter
    def depth(self, size_t depth):
        self._pvt_ptr[0].depth = depth
    {{endif}}
{{endif}}
{{if 'CUmemcpy3DOperand_st.op.ptr' in found_struct}}

cdef class anon_struct23:
    """
    Attributes
    ----------
    {{if 'CUmemcpy3DOperand_st.op.ptr.ptr' in found_struct}}
    ptr : CUdeviceptr

    {{endif}}
    {{if 'CUmemcpy3DOperand_st.op.ptr.rowLength' in found_struct}}
    rowLength : size_t

    {{endif}}
    {{if 'CUmemcpy3DOperand_st.op.ptr.layerHeight' in found_struct}}
    layerHeight : size_t

    {{endif}}
    {{if 'CUmemcpy3DOperand_st.op.ptr.locHint' in found_struct}}
    locHint : CUmemLocation

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUmemcpy3DOperand_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUmemcpy3DOperand_st.op.ptr.ptr' in found_struct}}
        self._ptr = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].op.ptr.ptr)
        {{endif}}
        {{if 'CUmemcpy3DOperand_st.op.ptr.locHint' in found_struct}}
        self._locHint = CUmemLocation(_ptr=<void_ptr>&self._pvt_ptr[0].op.ptr.locHint)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].op.ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUmemcpy3DOperand_st.op.ptr.ptr' in found_struct}}
            try:
                str_list += ['ptr : ' + str(self.ptr)]
            except ValueError:
                str_list += ['ptr : <ValueError>']
            {{endif}}
            {{if 'CUmemcpy3DOperand_st.op.ptr.rowLength' in found_struct}}
            try:
                str_list += ['rowLength : ' + str(self.rowLength)]
            except ValueError:
                str_list += ['rowLength : <ValueError>']
            {{endif}}
            {{if 'CUmemcpy3DOperand_st.op.ptr.layerHeight' in found_struct}}
            try:
                str_list += ['layerHeight : ' + str(self.layerHeight)]
            except ValueError:
                str_list += ['layerHeight : <ValueError>']
            {{endif}}
            {{if 'CUmemcpy3DOperand_st.op.ptr.locHint' in found_struct}}
            try:
                str_list += ['locHint :\n' + '\n'.join(['    ' + line for line in str(self.locHint).splitlines()])]
            except ValueError:
                str_list += ['locHint : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUmemcpy3DOperand_st.op.ptr.ptr' in found_struct}}
    @property
    def ptr(self):
        return self._ptr
    @ptr.setter
    def ptr(self, ptr):
        cdef cydriver.CUdeviceptr cyptr
        if ptr is None:
            cyptr = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(ptr, (CUdeviceptr)):
            pptr = int(ptr)
            cyptr = <cydriver.CUdeviceptr><void_ptr>pptr
        else:
            pptr = int(CUdeviceptr(ptr))
            cyptr = <cydriver.CUdeviceptr><void_ptr>pptr
        self._ptr._pvt_ptr[0] = cyptr

    {{endif}}
    {{if 'CUmemcpy3DOperand_st.op.ptr.rowLength' in found_struct}}
    @property
    def rowLength(self):
        return self._pvt_ptr[0].op.ptr.rowLength
    @rowLength.setter
    def rowLength(self, size_t rowLength):
        self._pvt_ptr[0].op.ptr.rowLength = rowLength
    {{endif}}
    {{if 'CUmemcpy3DOperand_st.op.ptr.layerHeight' in found_struct}}
    @property
    def layerHeight(self):
        return self._pvt_ptr[0].op.ptr.layerHeight
    @layerHeight.setter
    def layerHeight(self, size_t layerHeight):
        self._pvt_ptr[0].op.ptr.layerHeight = layerHeight
    {{endif}}
    {{if 'CUmemcpy3DOperand_st.op.ptr.locHint' in found_struct}}
    @property
    def locHint(self):
        return self._locHint
    @locHint.setter
    def locHint(self, locHint not None : CUmemLocation):
        string.memcpy(&self._pvt_ptr[0].op.ptr.locHint, <cydriver.CUmemLocation*><void_ptr>locHint.getPtr(), sizeof(self._pvt_ptr[0].op.ptr.locHint))
    {{endif}}
{{endif}}
{{if 'CUmemcpy3DOperand_st.op.array' in found_struct}}

cdef class anon_struct24:
    """
    Attributes
    ----------
    {{if 'CUmemcpy3DOperand_st.op.array.array' in found_struct}}
    array : CUarray

    {{endif}}
    {{if 'CUmemcpy3DOperand_st.op.array.offset' in found_struct}}
    offset : CUoffset3D

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUmemcpy3DOperand_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUmemcpy3DOperand_st.op.array.array' in found_struct}}
        self._array = CUarray(_ptr=<void_ptr>&self._pvt_ptr[0].op.array.array)
        {{endif}}
        {{if 'CUmemcpy3DOperand_st.op.array.offset' in found_struct}}
        self._offset = CUoffset3D(_ptr=<void_ptr>&self._pvt_ptr[0].op.array.offset)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].op.array
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUmemcpy3DOperand_st.op.array.array' in found_struct}}
            try:
                str_list += ['array : ' + str(self.array)]
            except ValueError:
                str_list += ['array : <ValueError>']
            {{endif}}
            {{if 'CUmemcpy3DOperand_st.op.array.offset' in found_struct}}
            try:
                str_list += ['offset :\n' + '\n'.join(['    ' + line for line in str(self.offset).splitlines()])]
            except ValueError:
                str_list += ['offset : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUmemcpy3DOperand_st.op.array.array' in found_struct}}
    @property
    def array(self):
        return self._array
    @array.setter
    def array(self, array):
        cdef cydriver.CUarray cyarray
        if array is None:
            cyarray = <cydriver.CUarray><void_ptr>0
        elif isinstance(array, (CUarray,)):
            parray = int(array)
            cyarray = <cydriver.CUarray><void_ptr>parray
        else:
            parray = int(CUarray(array))
            cyarray = <cydriver.CUarray><void_ptr>parray
        self._array._pvt_ptr[0] = cyarray
    {{endif}}
    {{if 'CUmemcpy3DOperand_st.op.array.offset' in found_struct}}
    @property
    def offset(self):
        return self._offset
    @offset.setter
    def offset(self, offset not None : CUoffset3D):
        string.memcpy(&self._pvt_ptr[0].op.array.offset, <cydriver.CUoffset3D*><void_ptr>offset.getPtr(), sizeof(self._pvt_ptr[0].op.array.offset))
    {{endif}}
{{endif}}
{{if 'CUmemcpy3DOperand_st.op' in found_struct}}

cdef class anon_union12:
    """
    Attributes
    ----------
    {{if 'CUmemcpy3DOperand_st.op.ptr' in found_struct}}
    ptr : anon_struct23

    {{endif}}
    {{if 'CUmemcpy3DOperand_st.op.array' in found_struct}}
    array : anon_struct24

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUmemcpy3DOperand_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'CUmemcpy3DOperand_st.op.ptr' in found_struct}}
        self._ptr = anon_struct23(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'CUmemcpy3DOperand_st.op.array' in found_struct}}
        self._array = anon_struct24(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].op
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUmemcpy3DOperand_st.op.ptr' in found_struct}}
            try:
                str_list += ['ptr :\n' + '\n'.join(['    ' + line for line in str(self.ptr).splitlines()])]
            except ValueError:
                str_list += ['ptr : <ValueError>']
            {{endif}}
            {{if 'CUmemcpy3DOperand_st.op.array' in found_struct}}
            try:
                str_list += ['array :\n' + '\n'.join(['    ' + line for line in str(self.array).splitlines()])]
            except ValueError:
                str_list += ['array : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUmemcpy3DOperand_st.op.ptr' in found_struct}}
    @property
    def ptr(self):
        return self._ptr
    @ptr.setter
    def ptr(self, ptr not None : anon_struct23):
        string.memcpy(&self._pvt_ptr[0].op.ptr, <cydriver.anon_struct23*><void_ptr>ptr.getPtr(), sizeof(self._pvt_ptr[0].op.ptr))
    {{endif}}
    {{if 'CUmemcpy3DOperand_st.op.array' in found_struct}}
    @property
    def array(self):
        return self._array
    @array.setter
    def array(self, array not None : anon_struct24):
        string.memcpy(&self._pvt_ptr[0].op.array, <cydriver.anon_struct24*><void_ptr>array.getPtr(), sizeof(self._pvt_ptr[0].op.array))
    {{endif}}
{{endif}}
{{if 'CUmemcpy3DOperand_st' in found_struct}}

cdef class CUmemcpy3DOperand_st:
    """
    Struct representing an operand for copy with cuMemcpy3DBatchAsync

    Attributes
    ----------
    {{if 'CUmemcpy3DOperand_st.type' in found_struct}}
    type : CUmemcpy3DOperandType

    {{endif}}
    {{if 'CUmemcpy3DOperand_st.op' in found_struct}}
    op : anon_union12

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cydriver.CUmemcpy3DOperand_st *>calloc(1, sizeof(cydriver.CUmemcpy3DOperand_st))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cydriver.CUmemcpy3DOperand_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUmemcpy3DOperand_st.op' in found_struct}}
        self._op = anon_union12(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUmemcpy3DOperand_st.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'CUmemcpy3DOperand_st.op' in found_struct}}
            try:
                str_list += ['op :\n' + '\n'.join(['    ' + line for line in str(self.op).splitlines()])]
            except ValueError:
                str_list += ['op : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUmemcpy3DOperand_st.type' in found_struct}}
    @property
    def type(self):
        if self._pvt_ptr[0].type not in _dict_CUmemcpy3DOperandType:
            return None
        return _dict_CUmemcpy3DOperandType[self._pvt_ptr[0].type]
    @type.setter
    def type(self, type not None : CUmemcpy3DOperandType):
        self._pvt_ptr[0].type = type.value
    {{endif}}
    {{if 'CUmemcpy3DOperand_st.op' in found_struct}}
    @property
    def op(self):
        return self._op
    @op.setter
    def op(self, op not None : anon_union12):
        string.memcpy(&self._pvt_ptr[0].op, <cydriver.anon_union12*><void_ptr>op.getPtr(), sizeof(self._pvt_ptr[0].op))
    {{endif}}
{{endif}}
{{if 'CUDA_MEMCPY3D_BATCH_OP_st' in found_struct}}

cdef class CUDA_MEMCPY3D_BATCH_OP_st:
    """
    Attributes
    ----------
    {{if 'CUDA_MEMCPY3D_BATCH_OP_st.src' in found_struct}}
    src : CUmemcpy3DOperand
        Source memcpy operand.
    {{endif}}
    {{if 'CUDA_MEMCPY3D_BATCH_OP_st.dst' in found_struct}}
    dst : CUmemcpy3DOperand
        Destination memcpy operand.
    {{endif}}
    {{if 'CUDA_MEMCPY3D_BATCH_OP_st.extent' in found_struct}}
    extent : CUextent3D
        Extents of the memcpy between src and dst. The width, height and
        depth components must not be 0.
    {{endif}}
    {{if 'CUDA_MEMCPY3D_BATCH_OP_st.srcAccessOrder' in found_struct}}
    srcAccessOrder : CUmemcpySrcAccessOrder
        Source access ordering to be observed for copy from src to dst.
    {{endif}}
    {{if 'CUDA_MEMCPY3D_BATCH_OP_st.flags' in found_struct}}
    flags : unsigned int
        Additional flags for copies with this attribute. See CUmemcpyFlags
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_MEMCPY3D_BATCH_OP_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_MEMCPY3D_BATCH_OP_st.src' in found_struct}}
        self._src = CUmemcpy3DOperand(_ptr=<void_ptr>&self._pvt_ptr[0].src)
        {{endif}}
        {{if 'CUDA_MEMCPY3D_BATCH_OP_st.dst' in found_struct}}
        self._dst = CUmemcpy3DOperand(_ptr=<void_ptr>&self._pvt_ptr[0].dst)
        {{endif}}
        {{if 'CUDA_MEMCPY3D_BATCH_OP_st.extent' in found_struct}}
        self._extent = CUextent3D(_ptr=<void_ptr>&self._pvt_ptr[0].extent)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_MEMCPY3D_BATCH_OP_st.src' in found_struct}}
            try:
                str_list += ['src :\n' + '\n'.join(['    ' + line for line in str(self.src).splitlines()])]
            except ValueError:
                str_list += ['src : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_BATCH_OP_st.dst' in found_struct}}
            try:
                str_list += ['dst :\n' + '\n'.join(['    ' + line for line in str(self.dst).splitlines()])]
            except ValueError:
                str_list += ['dst : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_BATCH_OP_st.extent' in found_struct}}
            try:
                str_list += ['extent :\n' + '\n'.join(['    ' + line for line in str(self.extent).splitlines()])]
            except ValueError:
                str_list += ['extent : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_BATCH_OP_st.srcAccessOrder' in found_struct}}
            try:
                str_list += ['srcAccessOrder : ' + str(self.srcAccessOrder)]
            except ValueError:
                str_list += ['srcAccessOrder : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEMCPY3D_BATCH_OP_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_MEMCPY3D_BATCH_OP_st.src' in found_struct}}
    @property
    def src(self):
        return self._src
    @src.setter
    def src(self, src not None : CUmemcpy3DOperand):
        string.memcpy(&self._pvt_ptr[0].src, <cydriver.CUmemcpy3DOperand*><void_ptr>src.getPtr(), sizeof(self._pvt_ptr[0].src))
    {{endif}}
    {{if 'CUDA_MEMCPY3D_BATCH_OP_st.dst' in found_struct}}
    @property
    def dst(self):
        return self._dst
    @dst.setter
    def dst(self, dst not None : CUmemcpy3DOperand):
        string.memcpy(&self._pvt_ptr[0].dst, <cydriver.CUmemcpy3DOperand*><void_ptr>dst.getPtr(), sizeof(self._pvt_ptr[0].dst))
    {{endif}}
    {{if 'CUDA_MEMCPY3D_BATCH_OP_st.extent' in found_struct}}
    @property
    def extent(self):
        return self._extent
    @extent.setter
    def extent(self, extent not None : CUextent3D):
        string.memcpy(&self._pvt_ptr[0].extent, <cydriver.CUextent3D*><void_ptr>extent.getPtr(), sizeof(self._pvt_ptr[0].extent))
    {{endif}}
    {{if 'CUDA_MEMCPY3D_BATCH_OP_st.srcAccessOrder' in found_struct}}
    @property
    def srcAccessOrder(self):
        if self._pvt_ptr[0].srcAccessOrder not in _dict_CUmemcpySrcAccessOrder:
            return None
        return _dict_CUmemcpySrcAccessOrder[self._pvt_ptr[0].srcAccessOrder]
    @srcAccessOrder.setter
    def srcAccessOrder(self, srcAccessOrder not None : CUmemcpySrcAccessOrder):
        self._pvt_ptr[0].srcAccessOrder = srcAccessOrder.value
    {{endif}}
    {{if 'CUDA_MEMCPY3D_BATCH_OP_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
{{endif}}
{{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st' in found_struct}}

cdef class CUDA_MEM_ALLOC_NODE_PARAMS_v1_st:
    """
    Memory allocation node parameters

    Attributes
    ----------
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.poolProps' in found_struct}}
    poolProps : CUmemPoolProps
        in: location where the allocation should reside (specified in
        ::location). ::handleTypes must be CU_MEM_HANDLE_TYPE_NONE. IPC is
        not supported.
    {{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.accessDescs' in found_struct}}
    accessDescs : CUmemAccessDesc
        in: array of memory access descriptors. Used to describe peer GPU
        access
    {{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.accessDescCount' in found_struct}}
    accessDescCount : size_t
        in: number of memory access descriptors. Must not exceed the number
        of GPUs.
    {{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.bytesize' in found_struct}}
    bytesize : size_t
        in: size in bytes of the requested allocation
    {{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.dptr' in found_struct}}
    dptr : CUdeviceptr
        out: address of the allocation returned by CUDA
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_MEM_ALLOC_NODE_PARAMS_v1_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.poolProps' in found_struct}}
        self._poolProps = CUmemPoolProps(_ptr=<void_ptr>&self._pvt_ptr[0].poolProps)
        {{endif}}
        {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.dptr' in found_struct}}
        self._dptr = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].dptr)
        {{endif}}
    def __dealloc__(self):
        pass
        {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.accessDescs' in found_struct}}
        if self._accessDescs is not NULL:
            free(self._accessDescs)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.poolProps' in found_struct}}
            try:
                str_list += ['poolProps :\n' + '\n'.join(['    ' + line for line in str(self.poolProps).splitlines()])]
            except ValueError:
                str_list += ['poolProps : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.accessDescs' in found_struct}}
            try:
                str_list += ['accessDescs : ' + str(self.accessDescs)]
            except ValueError:
                str_list += ['accessDescs : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.accessDescCount' in found_struct}}
            try:
                str_list += ['accessDescCount : ' + str(self.accessDescCount)]
            except ValueError:
                str_list += ['accessDescCount : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.bytesize' in found_struct}}
            try:
                str_list += ['bytesize : ' + str(self.bytesize)]
            except ValueError:
                str_list += ['bytesize : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.dptr' in found_struct}}
            try:
                str_list += ['dptr : ' + str(self.dptr)]
            except ValueError:
                str_list += ['dptr : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.poolProps' in found_struct}}
    @property
    def poolProps(self):
        return self._poolProps
    @poolProps.setter
    def poolProps(self, poolProps not None : CUmemPoolProps):
        string.memcpy(&self._pvt_ptr[0].poolProps, <cydriver.CUmemPoolProps*><void_ptr>poolProps.getPtr(), sizeof(self._pvt_ptr[0].poolProps))
    {{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.accessDescs' in found_struct}}
    @property
    def accessDescs(self):
        arrs = [<void_ptr>self._pvt_ptr[0].accessDescs + x*sizeof(cydriver.CUmemAccessDesc) for x in range(self._accessDescs_length)]
        return [CUmemAccessDesc(_ptr=arr) for arr in arrs]
    @accessDescs.setter
    def accessDescs(self, val):
        if len(val) == 0:
            free(self._accessDescs)
            self._accessDescs_length = 0
            self._pvt_ptr[0].accessDescs = NULL
        else:
            if self._accessDescs_length != <size_t>len(val):
                free(self._accessDescs)
                self._accessDescs = <cydriver.CUmemAccessDesc*> calloc(len(val), sizeof(cydriver.CUmemAccessDesc))
                if self._accessDescs is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cydriver.CUmemAccessDesc)))
                self._accessDescs_length = <size_t>len(val)
                self._pvt_ptr[0].accessDescs = self._accessDescs
            for idx in range(len(val)):
                string.memcpy(&self._accessDescs[idx], (<CUmemAccessDesc>val[idx])._pvt_ptr, sizeof(cydriver.CUmemAccessDesc))

    {{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.accessDescCount' in found_struct}}
    @property
    def accessDescCount(self):
        return self._pvt_ptr[0].accessDescCount
    @accessDescCount.setter
    def accessDescCount(self, size_t accessDescCount):
        self._pvt_ptr[0].accessDescCount = accessDescCount
    {{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.bytesize' in found_struct}}
    @property
    def bytesize(self):
        return self._pvt_ptr[0].bytesize
    @bytesize.setter
    def bytesize(self, size_t bytesize):
        self._pvt_ptr[0].bytesize = bytesize
    {{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st.dptr' in found_struct}}
    @property
    def dptr(self):
        return self._dptr
    @dptr.setter
    def dptr(self, dptr):
        cdef cydriver.CUdeviceptr cydptr
        if dptr is None:
            cydptr = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(dptr, (CUdeviceptr)):
            pdptr = int(dptr)
            cydptr = <cydriver.CUdeviceptr><void_ptr>pdptr
        else:
            pdptr = int(CUdeviceptr(dptr))
            cydptr = <cydriver.CUdeviceptr><void_ptr>pdptr
        self._dptr._pvt_ptr[0] = cydptr

    {{endif}}
{{endif}}
{{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st' in found_struct}}

cdef class CUDA_MEM_ALLOC_NODE_PARAMS_v2_st:
    """
    Memory allocation node parameters

    Attributes
    ----------
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.poolProps' in found_struct}}
    poolProps : CUmemPoolProps
        in: location where the allocation should reside (specified in
        ::location). ::handleTypes must be CU_MEM_HANDLE_TYPE_NONE. IPC is
        not supported.
    {{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.accessDescs' in found_struct}}
    accessDescs : CUmemAccessDesc
        in: array of memory access descriptors. Used to describe peer GPU
        access
    {{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.accessDescCount' in found_struct}}
    accessDescCount : size_t
        in: number of memory access descriptors. Must not exceed the number
        of GPUs.
    {{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.bytesize' in found_struct}}
    bytesize : size_t
        in: size in bytes of the requested allocation
    {{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.dptr' in found_struct}}
    dptr : CUdeviceptr
        out: address of the allocation returned by CUDA
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_MEM_ALLOC_NODE_PARAMS_v2_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.poolProps' in found_struct}}
        self._poolProps = CUmemPoolProps(_ptr=<void_ptr>&self._pvt_ptr[0].poolProps)
        {{endif}}
        {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.dptr' in found_struct}}
        self._dptr = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].dptr)
        {{endif}}
    def __dealloc__(self):
        pass
        {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.accessDescs' in found_struct}}
        if self._accessDescs is not NULL:
            free(self._accessDescs)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.poolProps' in found_struct}}
            try:
                str_list += ['poolProps :\n' + '\n'.join(['    ' + line for line in str(self.poolProps).splitlines()])]
            except ValueError:
                str_list += ['poolProps : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.accessDescs' in found_struct}}
            try:
                str_list += ['accessDescs : ' + str(self.accessDescs)]
            except ValueError:
                str_list += ['accessDescs : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.accessDescCount' in found_struct}}
            try:
                str_list += ['accessDescCount : ' + str(self.accessDescCount)]
            except ValueError:
                str_list += ['accessDescCount : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.bytesize' in found_struct}}
            try:
                str_list += ['bytesize : ' + str(self.bytesize)]
            except ValueError:
                str_list += ['bytesize : <ValueError>']
            {{endif}}
            {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.dptr' in found_struct}}
            try:
                str_list += ['dptr : ' + str(self.dptr)]
            except ValueError:
                str_list += ['dptr : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.poolProps' in found_struct}}
    @property
    def poolProps(self):
        return self._poolProps
    @poolProps.setter
    def poolProps(self, poolProps not None : CUmemPoolProps):
        string.memcpy(&self._pvt_ptr[0].poolProps, <cydriver.CUmemPoolProps*><void_ptr>poolProps.getPtr(), sizeof(self._pvt_ptr[0].poolProps))
    {{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.accessDescs' in found_struct}}
    @property
    def accessDescs(self):
        arrs = [<void_ptr>self._pvt_ptr[0].accessDescs + x*sizeof(cydriver.CUmemAccessDesc) for x in range(self._accessDescs_length)]
        return [CUmemAccessDesc(_ptr=arr) for arr in arrs]
    @accessDescs.setter
    def accessDescs(self, val):
        if len(val) == 0:
            free(self._accessDescs)
            self._accessDescs_length = 0
            self._pvt_ptr[0].accessDescs = NULL
        else:
            if self._accessDescs_length != <size_t>len(val):
                free(self._accessDescs)
                self._accessDescs = <cydriver.CUmemAccessDesc*> calloc(len(val), sizeof(cydriver.CUmemAccessDesc))
                if self._accessDescs is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cydriver.CUmemAccessDesc)))
                self._accessDescs_length = <size_t>len(val)
                self._pvt_ptr[0].accessDescs = self._accessDescs
            for idx in range(len(val)):
                string.memcpy(&self._accessDescs[idx], (<CUmemAccessDesc>val[idx])._pvt_ptr, sizeof(cydriver.CUmemAccessDesc))

    {{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.accessDescCount' in found_struct}}
    @property
    def accessDescCount(self):
        return self._pvt_ptr[0].accessDescCount
    @accessDescCount.setter
    def accessDescCount(self, size_t accessDescCount):
        self._pvt_ptr[0].accessDescCount = accessDescCount
    {{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.bytesize' in found_struct}}
    @property
    def bytesize(self):
        return self._pvt_ptr[0].bytesize
    @bytesize.setter
    def bytesize(self, size_t bytesize):
        self._pvt_ptr[0].bytesize = bytesize
    {{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st.dptr' in found_struct}}
    @property
    def dptr(self):
        return self._dptr
    @dptr.setter
    def dptr(self, dptr):
        cdef cydriver.CUdeviceptr cydptr
        if dptr is None:
            cydptr = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(dptr, (CUdeviceptr)):
            pdptr = int(dptr)
            cydptr = <cydriver.CUdeviceptr><void_ptr>pdptr
        else:
            pdptr = int(CUdeviceptr(dptr))
            cydptr = <cydriver.CUdeviceptr><void_ptr>pdptr
        self._dptr._pvt_ptr[0] = cydptr

    {{endif}}
{{endif}}
{{if 'CUDA_MEM_FREE_NODE_PARAMS_st' in found_struct}}

cdef class CUDA_MEM_FREE_NODE_PARAMS_st:
    """
    Memory free node parameters

    Attributes
    ----------
    {{if 'CUDA_MEM_FREE_NODE_PARAMS_st.dptr' in found_struct}}
    dptr : CUdeviceptr
        in: the pointer to free
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_MEM_FREE_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_MEM_FREE_NODE_PARAMS_st.dptr' in found_struct}}
        self._dptr = CUdeviceptr(_ptr=<void_ptr>&self._pvt_ptr[0].dptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_MEM_FREE_NODE_PARAMS_st.dptr' in found_struct}}
            try:
                str_list += ['dptr : ' + str(self.dptr)]
            except ValueError:
                str_list += ['dptr : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_MEM_FREE_NODE_PARAMS_st.dptr' in found_struct}}
    @property
    def dptr(self):
        return self._dptr
    @dptr.setter
    def dptr(self, dptr):
        cdef cydriver.CUdeviceptr cydptr
        if dptr is None:
            cydptr = <cydriver.CUdeviceptr><void_ptr>0
        elif isinstance(dptr, (CUdeviceptr)):
            pdptr = int(dptr)
            cydptr = <cydriver.CUdeviceptr><void_ptr>pdptr
        else:
            pdptr = int(CUdeviceptr(dptr))
            cydptr = <cydriver.CUdeviceptr><void_ptr>pdptr
        self._dptr._pvt_ptr[0] = cydptr

    {{endif}}
{{endif}}
{{if 'CUDA_CHILD_GRAPH_NODE_PARAMS_st' in found_struct}}

cdef class CUDA_CHILD_GRAPH_NODE_PARAMS_st:
    """
    Child graph node parameters

    Attributes
    ----------
    {{if 'CUDA_CHILD_GRAPH_NODE_PARAMS_st.graph' in found_struct}}
    graph : CUgraph
        The child graph to clone into the node for node creation, or a
        handle to the graph owned by the node for node query. The graph
        must not contain conditional nodes. Graphs containing memory
        allocation or memory free nodes must set the ownership to be moved
        to the parent.
    {{endif}}
    {{if 'CUDA_CHILD_GRAPH_NODE_PARAMS_st.ownership' in found_struct}}
    ownership : CUgraphChildGraphNodeOwnership
        The ownership relationship of the child graph node.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_CHILD_GRAPH_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_CHILD_GRAPH_NODE_PARAMS_st.graph' in found_struct}}
        self._graph = CUgraph(_ptr=<void_ptr>&self._pvt_ptr[0].graph)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_CHILD_GRAPH_NODE_PARAMS_st.graph' in found_struct}}
            try:
                str_list += ['graph : ' + str(self.graph)]
            except ValueError:
                str_list += ['graph : <ValueError>']
            {{endif}}
            {{if 'CUDA_CHILD_GRAPH_NODE_PARAMS_st.ownership' in found_struct}}
            try:
                str_list += ['ownership : ' + str(self.ownership)]
            except ValueError:
                str_list += ['ownership : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_CHILD_GRAPH_NODE_PARAMS_st.graph' in found_struct}}
    @property
    def graph(self):
        return self._graph
    @graph.setter
    def graph(self, graph):
        cdef cydriver.CUgraph cygraph
        if graph is None:
            cygraph = <cydriver.CUgraph><void_ptr>0
        elif isinstance(graph, (CUgraph,)):
            pgraph = int(graph)
            cygraph = <cydriver.CUgraph><void_ptr>pgraph
        else:
            pgraph = int(CUgraph(graph))
            cygraph = <cydriver.CUgraph><void_ptr>pgraph
        self._graph._pvt_ptr[0] = cygraph
    {{endif}}
    {{if 'CUDA_CHILD_GRAPH_NODE_PARAMS_st.ownership' in found_struct}}
    @property
    def ownership(self):
        if self._pvt_ptr[0].ownership not in _dict_CUgraphChildGraphNodeOwnership:
            return None
        return _dict_CUgraphChildGraphNodeOwnership[self._pvt_ptr[0].ownership]
    @ownership.setter
    def ownership(self, ownership not None : CUgraphChildGraphNodeOwnership):
        self._pvt_ptr[0].ownership = ownership.value
    {{endif}}
{{endif}}
{{if 'CUDA_EVENT_RECORD_NODE_PARAMS_st' in found_struct}}

cdef class CUDA_EVENT_RECORD_NODE_PARAMS_st:
    """
    Event record node parameters

    Attributes
    ----------
    {{if 'CUDA_EVENT_RECORD_NODE_PARAMS_st.event' in found_struct}}
    event : CUevent
        The event to record when the node executes
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_EVENT_RECORD_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_EVENT_RECORD_NODE_PARAMS_st.event' in found_struct}}
        self._event = CUevent(_ptr=<void_ptr>&self._pvt_ptr[0].event)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EVENT_RECORD_NODE_PARAMS_st.event' in found_struct}}
            try:
                str_list += ['event : ' + str(self.event)]
            except ValueError:
                str_list += ['event : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EVENT_RECORD_NODE_PARAMS_st.event' in found_struct}}
    @property
    def event(self):
        return self._event
    @event.setter
    def event(self, event):
        cdef cydriver.CUevent cyevent
        if event is None:
            cyevent = <cydriver.CUevent><void_ptr>0
        elif isinstance(event, (CUevent,)):
            pevent = int(event)
            cyevent = <cydriver.CUevent><void_ptr>pevent
        else:
            pevent = int(CUevent(event))
            cyevent = <cydriver.CUevent><void_ptr>pevent
        self._event._pvt_ptr[0] = cyevent
    {{endif}}
{{endif}}
{{if 'CUDA_EVENT_WAIT_NODE_PARAMS_st' in found_struct}}

cdef class CUDA_EVENT_WAIT_NODE_PARAMS_st:
    """
    Event wait node parameters

    Attributes
    ----------
    {{if 'CUDA_EVENT_WAIT_NODE_PARAMS_st.event' in found_struct}}
    event : CUevent
        The event to wait on from the node
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUDA_EVENT_WAIT_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUDA_EVENT_WAIT_NODE_PARAMS_st.event' in found_struct}}
        self._event = CUevent(_ptr=<void_ptr>&self._pvt_ptr[0].event)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUDA_EVENT_WAIT_NODE_PARAMS_st.event' in found_struct}}
            try:
                str_list += ['event : ' + str(self.event)]
            except ValueError:
                str_list += ['event : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUDA_EVENT_WAIT_NODE_PARAMS_st.event' in found_struct}}
    @property
    def event(self):
        return self._event
    @event.setter
    def event(self, event):
        cdef cydriver.CUevent cyevent
        if event is None:
            cyevent = <cydriver.CUevent><void_ptr>0
        elif isinstance(event, (CUevent,)):
            pevent = int(event)
            cyevent = <cydriver.CUevent><void_ptr>pevent
        else:
            pevent = int(CUevent(event))
            cyevent = <cydriver.CUevent><void_ptr>pevent
        self._event._pvt_ptr[0] = cyevent
    {{endif}}
{{endif}}
{{if 'CUgraphNodeParams_st' in found_struct}}

cdef class CUgraphNodeParams_st:
    """
    Graph node parameters. See cuGraphAddNode.

    Attributes
    ----------
    {{if 'CUgraphNodeParams_st.type' in found_struct}}
    type : CUgraphNodeType
        Type of the node
    {{endif}}
    {{if 'CUgraphNodeParams_st.reserved0' in found_struct}}
    reserved0 : list[int]
        Reserved. Must be zero.
    {{endif}}
    {{if 'CUgraphNodeParams_st.reserved1' in found_struct}}
    reserved1 : list[long long]
        Padding. Unused bytes must be zero.
    {{endif}}
    {{if 'CUgraphNodeParams_st.kernel' in found_struct}}
    kernel : CUDA_KERNEL_NODE_PARAMS_v3
        Kernel node parameters.
    {{endif}}
    {{if 'CUgraphNodeParams_st.memcpy' in found_struct}}
    memcpy : CUDA_MEMCPY_NODE_PARAMS
        Memcpy node parameters.
    {{endif}}
    {{if 'CUgraphNodeParams_st.memset' in found_struct}}
    memset : CUDA_MEMSET_NODE_PARAMS_v2
        Memset node parameters.
    {{endif}}
    {{if 'CUgraphNodeParams_st.host' in found_struct}}
    host : CUDA_HOST_NODE_PARAMS_v2
        Host node parameters.
    {{endif}}
    {{if 'CUgraphNodeParams_st.graph' in found_struct}}
    graph : CUDA_CHILD_GRAPH_NODE_PARAMS
        Child graph node parameters.
    {{endif}}
    {{if 'CUgraphNodeParams_st.eventWait' in found_struct}}
    eventWait : CUDA_EVENT_WAIT_NODE_PARAMS
        Event wait node parameters.
    {{endif}}
    {{if 'CUgraphNodeParams_st.eventRecord' in found_struct}}
    eventRecord : CUDA_EVENT_RECORD_NODE_PARAMS
        Event record node parameters.
    {{endif}}
    {{if 'CUgraphNodeParams_st.extSemSignal' in found_struct}}
    extSemSignal : CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2
        External semaphore signal node parameters.
    {{endif}}
    {{if 'CUgraphNodeParams_st.extSemWait' in found_struct}}
    extSemWait : CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2
        External semaphore wait node parameters.
    {{endif}}
    {{if 'CUgraphNodeParams_st.alloc' in found_struct}}
    alloc : CUDA_MEM_ALLOC_NODE_PARAMS_v2
        Memory allocation node parameters.
    {{endif}}
    {{if 'CUgraphNodeParams_st.free' in found_struct}}
    free : CUDA_MEM_FREE_NODE_PARAMS
        Memory free node parameters.
    {{endif}}
    {{if 'CUgraphNodeParams_st.memOp' in found_struct}}
    memOp : CUDA_BATCH_MEM_OP_NODE_PARAMS_v2
        MemOp node parameters.
    {{endif}}
    {{if 'CUgraphNodeParams_st.conditional' in found_struct}}
    conditional : CUDA_CONDITIONAL_NODE_PARAMS
        Conditional node parameters.
    {{endif}}
    {{if 'CUgraphNodeParams_st.reserved2' in found_struct}}
    reserved2 : long long
        Reserved bytes. Must be zero.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cydriver.CUgraphNodeParams_st *>calloc(1, sizeof(cydriver.CUgraphNodeParams_st))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cydriver.CUgraphNodeParams_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUgraphNodeParams_st.kernel' in found_struct}}
        self._kernel = CUDA_KERNEL_NODE_PARAMS_v3(_ptr=<void_ptr>&self._pvt_ptr[0].kernel)
        {{endif}}
        {{if 'CUgraphNodeParams_st.memcpy' in found_struct}}
        self._memcpy = CUDA_MEMCPY_NODE_PARAMS(_ptr=<void_ptr>&self._pvt_ptr[0].memcpy)
        {{endif}}
        {{if 'CUgraphNodeParams_st.memset' in found_struct}}
        self._memset = CUDA_MEMSET_NODE_PARAMS_v2(_ptr=<void_ptr>&self._pvt_ptr[0].memset)
        {{endif}}
        {{if 'CUgraphNodeParams_st.host' in found_struct}}
        self._host = CUDA_HOST_NODE_PARAMS_v2(_ptr=<void_ptr>&self._pvt_ptr[0].host)
        {{endif}}
        {{if 'CUgraphNodeParams_st.graph' in found_struct}}
        self._graph = CUDA_CHILD_GRAPH_NODE_PARAMS(_ptr=<void_ptr>&self._pvt_ptr[0].graph)
        {{endif}}
        {{if 'CUgraphNodeParams_st.eventWait' in found_struct}}
        self._eventWait = CUDA_EVENT_WAIT_NODE_PARAMS(_ptr=<void_ptr>&self._pvt_ptr[0].eventWait)
        {{endif}}
        {{if 'CUgraphNodeParams_st.eventRecord' in found_struct}}
        self._eventRecord = CUDA_EVENT_RECORD_NODE_PARAMS(_ptr=<void_ptr>&self._pvt_ptr[0].eventRecord)
        {{endif}}
        {{if 'CUgraphNodeParams_st.extSemSignal' in found_struct}}
        self._extSemSignal = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2(_ptr=<void_ptr>&self._pvt_ptr[0].extSemSignal)
        {{endif}}
        {{if 'CUgraphNodeParams_st.extSemWait' in found_struct}}
        self._extSemWait = CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2(_ptr=<void_ptr>&self._pvt_ptr[0].extSemWait)
        {{endif}}
        {{if 'CUgraphNodeParams_st.alloc' in found_struct}}
        self._alloc = CUDA_MEM_ALLOC_NODE_PARAMS_v2(_ptr=<void_ptr>&self._pvt_ptr[0].alloc)
        {{endif}}
        {{if 'CUgraphNodeParams_st.free' in found_struct}}
        self._free = CUDA_MEM_FREE_NODE_PARAMS(_ptr=<void_ptr>&self._pvt_ptr[0].free)
        {{endif}}
        {{if 'CUgraphNodeParams_st.memOp' in found_struct}}
        self._memOp = CUDA_BATCH_MEM_OP_NODE_PARAMS_v2(_ptr=<void_ptr>&self._pvt_ptr[0].memOp)
        {{endif}}
        {{if 'CUgraphNodeParams_st.conditional' in found_struct}}
        self._conditional = CUDA_CONDITIONAL_NODE_PARAMS(_ptr=<void_ptr>&self._pvt_ptr[0].conditional)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUgraphNodeParams_st.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'CUgraphNodeParams_st.reserved0' in found_struct}}
            try:
                str_list += ['reserved0 : ' + str(self.reserved0)]
            except ValueError:
                str_list += ['reserved0 : <ValueError>']
            {{endif}}
            {{if 'CUgraphNodeParams_st.reserved1' in found_struct}}
            try:
                str_list += ['reserved1 : ' + str(self.reserved1)]
            except ValueError:
                str_list += ['reserved1 : <ValueError>']
            {{endif}}
            {{if 'CUgraphNodeParams_st.kernel' in found_struct}}
            try:
                str_list += ['kernel :\n' + '\n'.join(['    ' + line for line in str(self.kernel).splitlines()])]
            except ValueError:
                str_list += ['kernel : <ValueError>']
            {{endif}}
            {{if 'CUgraphNodeParams_st.memcpy' in found_struct}}
            try:
                str_list += ['memcpy :\n' + '\n'.join(['    ' + line for line in str(self.memcpy).splitlines()])]
            except ValueError:
                str_list += ['memcpy : <ValueError>']
            {{endif}}
            {{if 'CUgraphNodeParams_st.memset' in found_struct}}
            try:
                str_list += ['memset :\n' + '\n'.join(['    ' + line for line in str(self.memset).splitlines()])]
            except ValueError:
                str_list += ['memset : <ValueError>']
            {{endif}}
            {{if 'CUgraphNodeParams_st.host' in found_struct}}
            try:
                str_list += ['host :\n' + '\n'.join(['    ' + line for line in str(self.host).splitlines()])]
            except ValueError:
                str_list += ['host : <ValueError>']
            {{endif}}
            {{if 'CUgraphNodeParams_st.graph' in found_struct}}
            try:
                str_list += ['graph :\n' + '\n'.join(['    ' + line for line in str(self.graph).splitlines()])]
            except ValueError:
                str_list += ['graph : <ValueError>']
            {{endif}}
            {{if 'CUgraphNodeParams_st.eventWait' in found_struct}}
            try:
                str_list += ['eventWait :\n' + '\n'.join(['    ' + line for line in str(self.eventWait).splitlines()])]
            except ValueError:
                str_list += ['eventWait : <ValueError>']
            {{endif}}
            {{if 'CUgraphNodeParams_st.eventRecord' in found_struct}}
            try:
                str_list += ['eventRecord :\n' + '\n'.join(['    ' + line for line in str(self.eventRecord).splitlines()])]
            except ValueError:
                str_list += ['eventRecord : <ValueError>']
            {{endif}}
            {{if 'CUgraphNodeParams_st.extSemSignal' in found_struct}}
            try:
                str_list += ['extSemSignal :\n' + '\n'.join(['    ' + line for line in str(self.extSemSignal).splitlines()])]
            except ValueError:
                str_list += ['extSemSignal : <ValueError>']
            {{endif}}
            {{if 'CUgraphNodeParams_st.extSemWait' in found_struct}}
            try:
                str_list += ['extSemWait :\n' + '\n'.join(['    ' + line for line in str(self.extSemWait).splitlines()])]
            except ValueError:
                str_list += ['extSemWait : <ValueError>']
            {{endif}}
            {{if 'CUgraphNodeParams_st.alloc' in found_struct}}
            try:
                str_list += ['alloc :\n' + '\n'.join(['    ' + line for line in str(self.alloc).splitlines()])]
            except ValueError:
                str_list += ['alloc : <ValueError>']
            {{endif}}
            {{if 'CUgraphNodeParams_st.free' in found_struct}}
            try:
                str_list += ['free :\n' + '\n'.join(['    ' + line for line in str(self.free).splitlines()])]
            except ValueError:
                str_list += ['free : <ValueError>']
            {{endif}}
            {{if 'CUgraphNodeParams_st.memOp' in found_struct}}
            try:
                str_list += ['memOp :\n' + '\n'.join(['    ' + line for line in str(self.memOp).splitlines()])]
            except ValueError:
                str_list += ['memOp : <ValueError>']
            {{endif}}
            {{if 'CUgraphNodeParams_st.conditional' in found_struct}}
            try:
                str_list += ['conditional :\n' + '\n'.join(['    ' + line for line in str(self.conditional).splitlines()])]
            except ValueError:
                str_list += ['conditional : <ValueError>']
            {{endif}}
            {{if 'CUgraphNodeParams_st.reserved2' in found_struct}}
            try:
                str_list += ['reserved2 : ' + str(self.reserved2)]
            except ValueError:
                str_list += ['reserved2 : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUgraphNodeParams_st.type' in found_struct}}
    @property
    def type(self):
        if self._pvt_ptr[0].type not in _dict_CUgraphNodeType:
            return None
        return _dict_CUgraphNodeType[self._pvt_ptr[0].type]
    @type.setter
    def type(self, type not None : CUgraphNodeType):
        self._pvt_ptr[0].type = type.value
    {{endif}}
    {{if 'CUgraphNodeParams_st.reserved0' in found_struct}}
    @property
    def reserved0(self):
        return self._pvt_ptr[0].reserved0
    @reserved0.setter
    def reserved0(self, reserved0):
        self._pvt_ptr[0].reserved0 = reserved0
    {{endif}}
    {{if 'CUgraphNodeParams_st.reserved1' in found_struct}}
    @property
    def reserved1(self):
        return self._pvt_ptr[0].reserved1
    @reserved1.setter
    def reserved1(self, reserved1):
        self._pvt_ptr[0].reserved1 = reserved1
    {{endif}}
    {{if 'CUgraphNodeParams_st.kernel' in found_struct}}
    @property
    def kernel(self):
        return self._kernel
    @kernel.setter
    def kernel(self, kernel not None : CUDA_KERNEL_NODE_PARAMS_v3):
        string.memcpy(&self._pvt_ptr[0].kernel, <cydriver.CUDA_KERNEL_NODE_PARAMS_v3*><void_ptr>kernel.getPtr(), sizeof(self._pvt_ptr[0].kernel))
    {{endif}}
    {{if 'CUgraphNodeParams_st.memcpy' in found_struct}}
    @property
    def memcpy(self):
        return self._memcpy
    @memcpy.setter
    def memcpy(self, memcpy not None : CUDA_MEMCPY_NODE_PARAMS):
        string.memcpy(&self._pvt_ptr[0].memcpy, <cydriver.CUDA_MEMCPY_NODE_PARAMS*><void_ptr>memcpy.getPtr(), sizeof(self._pvt_ptr[0].memcpy))
    {{endif}}
    {{if 'CUgraphNodeParams_st.memset' in found_struct}}
    @property
    def memset(self):
        return self._memset
    @memset.setter
    def memset(self, memset not None : CUDA_MEMSET_NODE_PARAMS_v2):
        string.memcpy(&self._pvt_ptr[0].memset, <cydriver.CUDA_MEMSET_NODE_PARAMS_v2*><void_ptr>memset.getPtr(), sizeof(self._pvt_ptr[0].memset))
    {{endif}}
    {{if 'CUgraphNodeParams_st.host' in found_struct}}
    @property
    def host(self):
        return self._host
    @host.setter
    def host(self, host not None : CUDA_HOST_NODE_PARAMS_v2):
        string.memcpy(&self._pvt_ptr[0].host, <cydriver.CUDA_HOST_NODE_PARAMS_v2*><void_ptr>host.getPtr(), sizeof(self._pvt_ptr[0].host))
    {{endif}}
    {{if 'CUgraphNodeParams_st.graph' in found_struct}}
    @property
    def graph(self):
        return self._graph
    @graph.setter
    def graph(self, graph not None : CUDA_CHILD_GRAPH_NODE_PARAMS):
        string.memcpy(&self._pvt_ptr[0].graph, <cydriver.CUDA_CHILD_GRAPH_NODE_PARAMS*><void_ptr>graph.getPtr(), sizeof(self._pvt_ptr[0].graph))
    {{endif}}
    {{if 'CUgraphNodeParams_st.eventWait' in found_struct}}
    @property
    def eventWait(self):
        return self._eventWait
    @eventWait.setter
    def eventWait(self, eventWait not None : CUDA_EVENT_WAIT_NODE_PARAMS):
        string.memcpy(&self._pvt_ptr[0].eventWait, <cydriver.CUDA_EVENT_WAIT_NODE_PARAMS*><void_ptr>eventWait.getPtr(), sizeof(self._pvt_ptr[0].eventWait))
    {{endif}}
    {{if 'CUgraphNodeParams_st.eventRecord' in found_struct}}
    @property
    def eventRecord(self):
        return self._eventRecord
    @eventRecord.setter
    def eventRecord(self, eventRecord not None : CUDA_EVENT_RECORD_NODE_PARAMS):
        string.memcpy(&self._pvt_ptr[0].eventRecord, <cydriver.CUDA_EVENT_RECORD_NODE_PARAMS*><void_ptr>eventRecord.getPtr(), sizeof(self._pvt_ptr[0].eventRecord))
    {{endif}}
    {{if 'CUgraphNodeParams_st.extSemSignal' in found_struct}}
    @property
    def extSemSignal(self):
        return self._extSemSignal
    @extSemSignal.setter
    def extSemSignal(self, extSemSignal not None : CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2):
        string.memcpy(&self._pvt_ptr[0].extSemSignal, <cydriver.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2*><void_ptr>extSemSignal.getPtr(), sizeof(self._pvt_ptr[0].extSemSignal))
    {{endif}}
    {{if 'CUgraphNodeParams_st.extSemWait' in found_struct}}
    @property
    def extSemWait(self):
        return self._extSemWait
    @extSemWait.setter
    def extSemWait(self, extSemWait not None : CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2):
        string.memcpy(&self._pvt_ptr[0].extSemWait, <cydriver.CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2*><void_ptr>extSemWait.getPtr(), sizeof(self._pvt_ptr[0].extSemWait))
    {{endif}}
    {{if 'CUgraphNodeParams_st.alloc' in found_struct}}
    @property
    def alloc(self):
        return self._alloc
    @alloc.setter
    def alloc(self, alloc not None : CUDA_MEM_ALLOC_NODE_PARAMS_v2):
        string.memcpy(&self._pvt_ptr[0].alloc, <cydriver.CUDA_MEM_ALLOC_NODE_PARAMS_v2*><void_ptr>alloc.getPtr(), sizeof(self._pvt_ptr[0].alloc))
    {{endif}}
    {{if 'CUgraphNodeParams_st.free' in found_struct}}
    @property
    def free(self):
        return self._free
    @free.setter
    def free(self, free not None : CUDA_MEM_FREE_NODE_PARAMS):
        string.memcpy(&self._pvt_ptr[0].free, <cydriver.CUDA_MEM_FREE_NODE_PARAMS*><void_ptr>free.getPtr(), sizeof(self._pvt_ptr[0].free))
    {{endif}}
    {{if 'CUgraphNodeParams_st.memOp' in found_struct}}
    @property
    def memOp(self):
        return self._memOp
    @memOp.setter
    def memOp(self, memOp not None : CUDA_BATCH_MEM_OP_NODE_PARAMS_v2):
        string.memcpy(&self._pvt_ptr[0].memOp, <cydriver.CUDA_BATCH_MEM_OP_NODE_PARAMS_v2*><void_ptr>memOp.getPtr(), sizeof(self._pvt_ptr[0].memOp))
    {{endif}}
    {{if 'CUgraphNodeParams_st.conditional' in found_struct}}
    @property
    def conditional(self):
        return self._conditional
    @conditional.setter
    def conditional(self, conditional not None : CUDA_CONDITIONAL_NODE_PARAMS):
        string.memcpy(&self._pvt_ptr[0].conditional, <cydriver.CUDA_CONDITIONAL_NODE_PARAMS*><void_ptr>conditional.getPtr(), sizeof(self._pvt_ptr[0].conditional))
    {{endif}}
    {{if 'CUgraphNodeParams_st.reserved2' in found_struct}}
    @property
    def reserved2(self):
        return self._pvt_ptr[0].reserved2
    @reserved2.setter
    def reserved2(self, long long reserved2):
        self._pvt_ptr[0].reserved2 = reserved2
    {{endif}}
{{endif}}
{{if 'CUcheckpointLockArgs_st' in found_struct}}

cdef class CUcheckpointLockArgs_st:
    """
    CUDA checkpoint optional lock arguments

    Attributes
    ----------
    {{if 'CUcheckpointLockArgs_st.timeoutMs' in found_struct}}
    timeoutMs : unsigned int
        Timeout in milliseconds to attempt to lock the process, 0 indicates
        no timeout
    {{endif}}
    {{if 'CUcheckpointLockArgs_st.reserved0' in found_struct}}
    reserved0 : unsigned int
        Reserved for future use, must be zero
    {{endif}}
    {{if 'CUcheckpointLockArgs_st.reserved1' in found_struct}}
    reserved1 : list[cuuint64_t]
        Reserved for future use, must be zeroed
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUcheckpointLockArgs_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUcheckpointLockArgs_st.timeoutMs' in found_struct}}
            try:
                str_list += ['timeoutMs : ' + str(self.timeoutMs)]
            except ValueError:
                str_list += ['timeoutMs : <ValueError>']
            {{endif}}
            {{if 'CUcheckpointLockArgs_st.reserved0' in found_struct}}
            try:
                str_list += ['reserved0 : ' + str(self.reserved0)]
            except ValueError:
                str_list += ['reserved0 : <ValueError>']
            {{endif}}
            {{if 'CUcheckpointLockArgs_st.reserved1' in found_struct}}
            try:
                str_list += ['reserved1 : ' + str(self.reserved1)]
            except ValueError:
                str_list += ['reserved1 : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUcheckpointLockArgs_st.timeoutMs' in found_struct}}
    @property
    def timeoutMs(self):
        return self._pvt_ptr[0].timeoutMs
    @timeoutMs.setter
    def timeoutMs(self, unsigned int timeoutMs):
        self._pvt_ptr[0].timeoutMs = timeoutMs
    {{endif}}
    {{if 'CUcheckpointLockArgs_st.reserved0' in found_struct}}
    @property
    def reserved0(self):
        return self._pvt_ptr[0].reserved0
    @reserved0.setter
    def reserved0(self, unsigned int reserved0):
        self._pvt_ptr[0].reserved0 = reserved0
    {{endif}}
    {{if 'CUcheckpointLockArgs_st.reserved1' in found_struct}}
    @property
    def reserved1(self):
        return [cuuint64_t(init_value=_reserved1) for _reserved1 in self._pvt_ptr[0].reserved1]
    @reserved1.setter
    def reserved1(self, reserved1):
        self._pvt_ptr[0].reserved1 = reserved1

    {{endif}}
{{endif}}
{{if 'CUcheckpointCheckpointArgs_st' in found_struct}}

cdef class CUcheckpointCheckpointArgs_st:
    """
    CUDA checkpoint optional checkpoint arguments

    Attributes
    ----------
    {{if 'CUcheckpointCheckpointArgs_st.reserved' in found_struct}}
    reserved : list[cuuint64_t]
        Reserved for future use, must be zeroed
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUcheckpointCheckpointArgs_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUcheckpointCheckpointArgs_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUcheckpointCheckpointArgs_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return [cuuint64_t(init_value=_reserved) for _reserved in self._pvt_ptr[0].reserved]
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved

    {{endif}}
{{endif}}
{{if 'CUcheckpointGpuPair_st' in found_struct}}

cdef class CUcheckpointGpuPair_st:
    """
    CUDA checkpoint GPU UUID pairs for device remapping during restore

    Attributes
    ----------
    {{if 'CUcheckpointGpuPair_st.oldUuid' in found_struct}}
    oldUuid : CUuuid
        UUID of the GPU that was checkpointed
    {{endif}}
    {{if 'CUcheckpointGpuPair_st.newUuid' in found_struct}}
    newUuid : CUuuid
        UUID of the GPU to restore onto
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUcheckpointGpuPair_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUcheckpointGpuPair_st.oldUuid' in found_struct}}
        self._oldUuid = CUuuid(_ptr=<void_ptr>&self._pvt_ptr[0].oldUuid)
        {{endif}}
        {{if 'CUcheckpointGpuPair_st.newUuid' in found_struct}}
        self._newUuid = CUuuid(_ptr=<void_ptr>&self._pvt_ptr[0].newUuid)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUcheckpointGpuPair_st.oldUuid' in found_struct}}
            try:
                str_list += ['oldUuid :\n' + '\n'.join(['    ' + line for line in str(self.oldUuid).splitlines()])]
            except ValueError:
                str_list += ['oldUuid : <ValueError>']
            {{endif}}
            {{if 'CUcheckpointGpuPair_st.newUuid' in found_struct}}
            try:
                str_list += ['newUuid :\n' + '\n'.join(['    ' + line for line in str(self.newUuid).splitlines()])]
            except ValueError:
                str_list += ['newUuid : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUcheckpointGpuPair_st.oldUuid' in found_struct}}
    @property
    def oldUuid(self):
        return self._oldUuid
    @oldUuid.setter
    def oldUuid(self, oldUuid not None : CUuuid):
        string.memcpy(&self._pvt_ptr[0].oldUuid, <cydriver.CUuuid*><void_ptr>oldUuid.getPtr(), sizeof(self._pvt_ptr[0].oldUuid))
    {{endif}}
    {{if 'CUcheckpointGpuPair_st.newUuid' in found_struct}}
    @property
    def newUuid(self):
        return self._newUuid
    @newUuid.setter
    def newUuid(self, newUuid not None : CUuuid):
        string.memcpy(&self._pvt_ptr[0].newUuid, <cydriver.CUuuid*><void_ptr>newUuid.getPtr(), sizeof(self._pvt_ptr[0].newUuid))
    {{endif}}
{{endif}}
{{if 'CUcheckpointRestoreArgs_st' in found_struct}}

cdef class CUcheckpointRestoreArgs_st:
    """
    CUDA checkpoint optional restore arguments

    Attributes
    ----------
    {{if 'CUcheckpointRestoreArgs_st.gpuPairs' in found_struct}}
    gpuPairs : CUcheckpointGpuPair
        Pointer to array of gpu pairs that indicate how to remap GPUs
        during restore
    {{endif}}
    {{if 'CUcheckpointRestoreArgs_st.gpuPairsCount' in found_struct}}
    gpuPairsCount : unsigned int
        Number of gpu pairs to remap
    {{endif}}
    {{if 'CUcheckpointRestoreArgs_st.reserved' in found_struct}}
    reserved : bytes
        Reserved for future use, must be zeroed
    {{endif}}
    {{if 'CUcheckpointRestoreArgs_st.reserved1' in found_struct}}
    reserved1 : cuuint64_t
        Reserved for future use, must be zeroed
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUcheckpointRestoreArgs_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUcheckpointRestoreArgs_st.reserved1' in found_struct}}
        self._reserved1 = cuuint64_t(_ptr=<void_ptr>&self._pvt_ptr[0].reserved1)
        {{endif}}
    def __dealloc__(self):
        pass
        {{if 'CUcheckpointRestoreArgs_st.gpuPairs' in found_struct}}
        if self._gpuPairs is not NULL:
            free(self._gpuPairs)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUcheckpointRestoreArgs_st.gpuPairs' in found_struct}}
            try:
                str_list += ['gpuPairs : ' + str(self.gpuPairs)]
            except ValueError:
                str_list += ['gpuPairs : <ValueError>']
            {{endif}}
            {{if 'CUcheckpointRestoreArgs_st.gpuPairsCount' in found_struct}}
            try:
                str_list += ['gpuPairsCount : ' + str(self.gpuPairsCount)]
            except ValueError:
                str_list += ['gpuPairsCount : <ValueError>']
            {{endif}}
            {{if 'CUcheckpointRestoreArgs_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            {{if 'CUcheckpointRestoreArgs_st.reserved1' in found_struct}}
            try:
                str_list += ['reserved1 : ' + str(self.reserved1)]
            except ValueError:
                str_list += ['reserved1 : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUcheckpointRestoreArgs_st.gpuPairs' in found_struct}}
    @property
    def gpuPairs(self):
        arrs = [<void_ptr>self._pvt_ptr[0].gpuPairs + x*sizeof(cydriver.CUcheckpointGpuPair) for x in range(self._gpuPairs_length)]
        return [CUcheckpointGpuPair(_ptr=arr) for arr in arrs]
    @gpuPairs.setter
    def gpuPairs(self, val):
        if len(val) == 0:
            free(self._gpuPairs)
            self._gpuPairs_length = 0
            self._pvt_ptr[0].gpuPairs = NULL
        else:
            if self._gpuPairs_length != <size_t>len(val):
                free(self._gpuPairs)
                self._gpuPairs = <cydriver.CUcheckpointGpuPair*> calloc(len(val), sizeof(cydriver.CUcheckpointGpuPair))
                if self._gpuPairs is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cydriver.CUcheckpointGpuPair)))
                self._gpuPairs_length = <size_t>len(val)
                self._pvt_ptr[0].gpuPairs = self._gpuPairs
            for idx in range(len(val)):
                string.memcpy(&self._gpuPairs[idx], (<CUcheckpointGpuPair>val[idx])._pvt_ptr, sizeof(cydriver.CUcheckpointGpuPair))

    {{endif}}
    {{if 'CUcheckpointRestoreArgs_st.gpuPairsCount' in found_struct}}
    @property
    def gpuPairsCount(self):
        return self._pvt_ptr[0].gpuPairsCount
    @gpuPairsCount.setter
    def gpuPairsCount(self, unsigned int gpuPairsCount):
        self._pvt_ptr[0].gpuPairsCount = gpuPairsCount
    {{endif}}
    {{if 'CUcheckpointRestoreArgs_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(self._pvt_ptr[0].reserved, 44)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 44:
            raise ValueError("reserved length must be 44, is " + str(len(reserved)))
        if CHAR_MIN == 0:
            for i, b in enumerate(reserved):
                if b < 0 and b > -129:
                    b = b + 256
                self._pvt_ptr[0].reserved[i] = b
        else:
            for i, b in enumerate(reserved):
                if b > 127 and b < 256:
                    b = b - 256
                self._pvt_ptr[0].reserved[i] = b
    {{endif}}
    {{if 'CUcheckpointRestoreArgs_st.reserved1' in found_struct}}
    @property
    def reserved1(self):
        return self._reserved1
    @reserved1.setter
    def reserved1(self, reserved1):
        cdef cydriver.cuuint64_t cyreserved1
        if reserved1 is None:
            cyreserved1 = <cydriver.cuuint64_t><void_ptr>0
        elif isinstance(reserved1, (cuuint64_t)):
            preserved1 = int(reserved1)
            cyreserved1 = <cydriver.cuuint64_t><void_ptr>preserved1
        else:
            preserved1 = int(cuuint64_t(reserved1))
            cyreserved1 = <cydriver.cuuint64_t><void_ptr>preserved1
        self._reserved1._pvt_ptr[0] = cyreserved1

    {{endif}}
{{endif}}
{{if 'CUcheckpointUnlockArgs_st' in found_struct}}

cdef class CUcheckpointUnlockArgs_st:
    """
    CUDA checkpoint optional unlock arguments

    Attributes
    ----------
    {{if 'CUcheckpointUnlockArgs_st.reserved' in found_struct}}
    reserved : list[cuuint64_t]
        Reserved for future use, must be zeroed
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUcheckpointUnlockArgs_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUcheckpointUnlockArgs_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUcheckpointUnlockArgs_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return [cuuint64_t(init_value=_reserved) for _reserved in self._pvt_ptr[0].reserved]
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved

    {{endif}}
{{endif}}
{{if 'CUmemDecompressParams_st' in found_struct}}

cdef class CUmemDecompressParams_st:
    """
    Structure describing the parameters that compose a single
    decompression operation.

    Attributes
    ----------
    {{if 'CUmemDecompressParams_st.srcNumBytes' in found_struct}}
    srcNumBytes : size_t
        The number of bytes to be read and decompressed from
        CUmemDecompressParams_st.src.
    {{endif}}
    {{if 'CUmemDecompressParams_st.dstNumBytes' in found_struct}}
    dstNumBytes : size_t
        The number of bytes that the decompression operation will be
        expected to write to CUmemDecompressParams_st.dst. This value is
        optional; if present, it may be used by the CUDA driver as a
        heuristic for scheduling the individual decompression operations.
    {{endif}}
    {{if 'CUmemDecompressParams_st.dstActBytes' in found_struct}}
    dstActBytes : cuuint32_t
        After the decompression operation has completed, the actual number
        of bytes written to CUmemDecompressParams.dst will be recorded as a
        32-bit unsigned integer in the memory at this address.
    {{endif}}
    {{if 'CUmemDecompressParams_st.src' in found_struct}}
    src : Any
        Pointer to a buffer of at least
        CUmemDecompressParams_st.srcNumBytes compressed bytes.
    {{endif}}
    {{if 'CUmemDecompressParams_st.dst' in found_struct}}
    dst : Any
        Pointer to a buffer where the decompressed data will be written.
        The number of bytes written to this location will be recorded in
        the memory pointed to by CUmemDecompressParams_st.dstActBytes
    {{endif}}
    {{if 'CUmemDecompressParams_st.algo' in found_struct}}
    algo : CUmemDecompressAlgorithm
        The decompression algorithm to use.
    {{endif}}
    {{if 'CUmemDecompressParams_st.padding' in found_struct}}
    padding : bytes

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUmemDecompressParams_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUmemDecompressParams_st.srcNumBytes' in found_struct}}
            try:
                str_list += ['srcNumBytes : ' + str(self.srcNumBytes)]
            except ValueError:
                str_list += ['srcNumBytes : <ValueError>']
            {{endif}}
            {{if 'CUmemDecompressParams_st.dstNumBytes' in found_struct}}
            try:
                str_list += ['dstNumBytes : ' + str(self.dstNumBytes)]
            except ValueError:
                str_list += ['dstNumBytes : <ValueError>']
            {{endif}}
            {{if 'CUmemDecompressParams_st.dstActBytes' in found_struct}}
            try:
                str_list += ['dstActBytes : ' + str(self.dstActBytes)]
            except ValueError:
                str_list += ['dstActBytes : <ValueError>']
            {{endif}}
            {{if 'CUmemDecompressParams_st.src' in found_struct}}
            try:
                str_list += ['src : ' + hex(self.src)]
            except ValueError:
                str_list += ['src : <ValueError>']
            {{endif}}
            {{if 'CUmemDecompressParams_st.dst' in found_struct}}
            try:
                str_list += ['dst : ' + hex(self.dst)]
            except ValueError:
                str_list += ['dst : <ValueError>']
            {{endif}}
            {{if 'CUmemDecompressParams_st.algo' in found_struct}}
            try:
                str_list += ['algo : ' + str(self.algo)]
            except ValueError:
                str_list += ['algo : <ValueError>']
            {{endif}}
            {{if 'CUmemDecompressParams_st.padding' in found_struct}}
            try:
                str_list += ['padding : ' + str(self.padding)]
            except ValueError:
                str_list += ['padding : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUmemDecompressParams_st.srcNumBytes' in found_struct}}
    @property
    def srcNumBytes(self):
        return self._pvt_ptr[0].srcNumBytes
    @srcNumBytes.setter
    def srcNumBytes(self, size_t srcNumBytes):
        self._pvt_ptr[0].srcNumBytes = srcNumBytes
    {{endif}}
    {{if 'CUmemDecompressParams_st.dstNumBytes' in found_struct}}
    @property
    def dstNumBytes(self):
        return self._pvt_ptr[0].dstNumBytes
    @dstNumBytes.setter
    def dstNumBytes(self, size_t dstNumBytes):
        self._pvt_ptr[0].dstNumBytes = dstNumBytes
    {{endif}}
    {{if 'CUmemDecompressParams_st.dstActBytes' in found_struct}}
    @property
    def dstActBytes(self):
        return cuuint32_t(_ptr=<void_ptr>self._pvt_ptr[0].dstActBytes)
    {{endif}}
    {{if 'CUmemDecompressParams_st.src' in found_struct}}
    @property
    def src(self):
        return <void_ptr>self._pvt_ptr[0].src
    @src.setter
    def src(self, src):
        _csrc = _HelperInputVoidPtr(src)
        self._pvt_ptr[0].src = <void*><void_ptr>_csrc.cptr
    {{endif}}
    {{if 'CUmemDecompressParams_st.dst' in found_struct}}
    @property
    def dst(self):
        return <void_ptr>self._pvt_ptr[0].dst
    @dst.setter
    def dst(self, dst):
        _cdst = _HelperInputVoidPtr(dst)
        self._pvt_ptr[0].dst = <void*><void_ptr>_cdst.cptr
    {{endif}}
    {{if 'CUmemDecompressParams_st.algo' in found_struct}}
    @property
    def algo(self):
        if self._pvt_ptr[0].algo not in _dict_CUmemDecompressAlgorithm:
            return None
        return _dict_CUmemDecompressAlgorithm[self._pvt_ptr[0].algo]
    @algo.setter
    def algo(self, algo not None : CUmemDecompressAlgorithm):
        self._pvt_ptr[0].algo = algo.value
    {{endif}}
    {{if 'CUmemDecompressParams_st.padding' in found_struct}}
    @property
    def padding(self):
        return PyBytes_FromStringAndSize(<char*>self._pvt_ptr[0].padding, 20)
    @padding.setter
    def padding(self, padding):
        if len(padding) != 20:
            raise ValueError("padding length must be 20, is " + str(len(padding)))
        for i, b in enumerate(padding):
            self._pvt_ptr[0].padding[i] = b
    {{endif}}
{{endif}}
{{if 'CUdevSmResource_st' in found_struct}}

cdef class CUdevSmResource_st:
    """
    Attributes
    ----------
    {{if 'CUdevSmResource_st.smCount' in found_struct}}
    smCount : unsigned int
        The amount of streaming multiprocessors available in this resource.
        This is an output parameter only, do not write to this field.
    {{endif}}
    {{if 'CUdevSmResource_st.minSmPartitionSize' in found_struct}}
    minSmPartitionSize : unsigned int
        The minimum number of streaming multiprocessors required to
        partition this resource. This is an output parameter only, do not
        write to this field.
    {{endif}}
    {{if 'CUdevSmResource_st.smCoscheduledAlignment' in found_struct}}
    smCoscheduledAlignment : unsigned int
        The number of streaming multiprocessors in this resource that are
        guaranteed to be co-scheduled on the same GPU processing cluster.
        smCount is a multiple of this value. This is an output parameter
        only, do not write to this field.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUdevSmResource_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUdevSmResource_st.smCount' in found_struct}}
            try:
                str_list += ['smCount : ' + str(self.smCount)]
            except ValueError:
                str_list += ['smCount : <ValueError>']
            {{endif}}
            {{if 'CUdevSmResource_st.minSmPartitionSize' in found_struct}}
            try:
                str_list += ['minSmPartitionSize : ' + str(self.minSmPartitionSize)]
            except ValueError:
                str_list += ['minSmPartitionSize : <ValueError>']
            {{endif}}
            {{if 'CUdevSmResource_st.smCoscheduledAlignment' in found_struct}}
            try:
                str_list += ['smCoscheduledAlignment : ' + str(self.smCoscheduledAlignment)]
            except ValueError:
                str_list += ['smCoscheduledAlignment : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUdevSmResource_st.smCount' in found_struct}}
    @property
    def smCount(self):
        return self._pvt_ptr[0].smCount
    @smCount.setter
    def smCount(self, unsigned int smCount):
        self._pvt_ptr[0].smCount = smCount
    {{endif}}
    {{if 'CUdevSmResource_st.minSmPartitionSize' in found_struct}}
    @property
    def minSmPartitionSize(self):
        return self._pvt_ptr[0].minSmPartitionSize
    @minSmPartitionSize.setter
    def minSmPartitionSize(self, unsigned int minSmPartitionSize):
        self._pvt_ptr[0].minSmPartitionSize = minSmPartitionSize
    {{endif}}
    {{if 'CUdevSmResource_st.smCoscheduledAlignment' in found_struct}}
    @property
    def smCoscheduledAlignment(self):
        return self._pvt_ptr[0].smCoscheduledAlignment
    @smCoscheduledAlignment.setter
    def smCoscheduledAlignment(self, unsigned int smCoscheduledAlignment):
        self._pvt_ptr[0].smCoscheduledAlignment = smCoscheduledAlignment
    {{endif}}
{{endif}}
{{if 'CUdevResource_st' in found_struct}}

cdef class CUdevResource_st:
    """
    Attributes
    ----------
    {{if 'CUdevResource_st.type' in found_struct}}
    type : CUdevResourceType
        Type of resource, dictates which union field was last set
    {{endif}}
    {{if 'CUdevResource_st._internal_padding' in found_struct}}
    _internal_padding : bytes

    {{endif}}
    {{if 'CUdevResource_st.sm' in found_struct}}
    sm : CUdevSmResource
        Resource corresponding to CU_DEV_RESOURCE_TYPE_SM `typename`.
    {{endif}}
    {{if 'CUdevResource_st._oversize' in found_struct}}
    _oversize : bytes

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cydriver.CUdevResource_st *>calloc(1, sizeof(cydriver.CUdevResource_st))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cydriver.CUdevResource_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'CUdevResource_st.sm' in found_struct}}
        self._sm = CUdevSmResource(_ptr=<void_ptr>&self._pvt_ptr[0].sm)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUdevResource_st.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'CUdevResource_st._internal_padding' in found_struct}}
            try:
                str_list += ['_internal_padding : ' + str(self._internal_padding)]
            except ValueError:
                str_list += ['_internal_padding : <ValueError>']
            {{endif}}
            {{if 'CUdevResource_st.sm' in found_struct}}
            try:
                str_list += ['sm :\n' + '\n'.join(['    ' + line for line in str(self.sm).splitlines()])]
            except ValueError:
                str_list += ['sm : <ValueError>']
            {{endif}}
            {{if 'CUdevResource_st._oversize' in found_struct}}
            try:
                str_list += ['_oversize : ' + str(self._oversize)]
            except ValueError:
                str_list += ['_oversize : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUdevResource_st.type' in found_struct}}
    @property
    def type(self):
        if self._pvt_ptr[0].type not in _dict_CUdevResourceType:
            return None
        return _dict_CUdevResourceType[self._pvt_ptr[0].type]
    @type.setter
    def type(self, type not None : CUdevResourceType):
        self._pvt_ptr[0].type = type.value
    {{endif}}
    {{if 'CUdevResource_st._internal_padding' in found_struct}}
    @property
    def _internal_padding(self):
        return PyBytes_FromStringAndSize(<char*>self._pvt_ptr[0]._internal_padding, 92)
    @_internal_padding.setter
    def _internal_padding(self, _internal_padding):
        if len(_internal_padding) != 92:
            raise ValueError("_internal_padding length must be 92, is " + str(len(_internal_padding)))
        for i, b in enumerate(_internal_padding):
            self._pvt_ptr[0]._internal_padding[i] = b
    {{endif}}
    {{if 'CUdevResource_st.sm' in found_struct}}
    @property
    def sm(self):
        return self._sm
    @sm.setter
    def sm(self, sm not None : CUdevSmResource):
        string.memcpy(&self._pvt_ptr[0].sm, <cydriver.CUdevSmResource*><void_ptr>sm.getPtr(), sizeof(self._pvt_ptr[0].sm))
    {{endif}}
    {{if 'CUdevResource_st._oversize' in found_struct}}
    @property
    def _oversize(self):
        return PyBytes_FromStringAndSize(<char*>self._pvt_ptr[0]._oversize, 48)
    @_oversize.setter
    def _oversize(self, _oversize):
        if len(_oversize) != 48:
            raise ValueError("_oversize length must be 48, is " + str(len(_oversize)))
        for i, b in enumerate(_oversize):
            self._pvt_ptr[0]._oversize[i] = b
    {{endif}}
{{endif}}
{{if True}}

cdef class anon_union15:
    """
    Attributes
    ----------
    {{if True}}
    pArray : list[CUarray]

    {{endif}}
    {{if True}}
    pPitch : list[Any]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cydriver.CUeglFrame_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].frame
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if True}}
            try:
                str_list += ['pArray : ' + str(self.pArray)]
            except ValueError:
                str_list += ['pArray : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['pPitch : ' + hex(self.pPitch)]
            except ValueError:
                str_list += ['pPitch : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if True}}
    @property
    def pArray(self):
        return [CUarray(init_value=<void_ptr>_pArray) for _pArray in self._pvt_ptr[0].frame.pArray]
    @pArray.setter
    def pArray(self, pArray : list[CUarray]):
        if len(pArray) != 3:
            raise IndexError('not enough values found during array assignment, expected 3, got', len(pArray))
        pArray = [int(_pArray) for _pArray in pArray]
        for _idx, _pArray in enumerate(pArray):
            self._pvt_ptr[0].frame.pArray[_idx] = <cydriver.CUarray><void_ptr>_pArray

    {{endif}}
    {{if True}}
    @property
    def pPitch(self):
        return [<void_ptr>_pPitch for _pPitch in self._pvt_ptr[0].frame.pPitch]
    @pPitch.setter
    def pPitch(self, pPitch : list[int]):
        if len(pPitch) != 3:
            raise IndexError('not enough values found during array assignment, expected 3, got', len(pPitch))
        pPitch = [<void_ptr>_pPitch for _pPitch in pPitch]
        for _idx, _pPitch in enumerate(pPitch):
            self._pvt_ptr[0].frame.pPitch[_idx] = <void*><void_ptr>_pPitch
    {{endif}}
{{endif}}
{{if True}}

cdef class CUeglFrame_st:
    """
    CUDA EGLFrame structure Descriptor - structure defining one frame
    of EGL.  Each frame may contain one or more planes depending on
    whether the surface * is Multiplanar or not.

    Attributes
    ----------
    {{if True}}
    frame : anon_union15

    {{endif}}
    {{if True}}
    width : unsigned int
        Width of first plane
    {{endif}}
    {{if True}}
    height : unsigned int
        Height of first plane
    {{endif}}
    {{if True}}
    depth : unsigned int
        Depth of first plane
    {{endif}}
    {{if True}}
    pitch : unsigned int
        Pitch of first plane
    {{endif}}
    {{if True}}
    planeCount : unsigned int
        Number of planes
    {{endif}}
    {{if True}}
    numChannels : unsigned int
        Number of channels for the plane
    {{endif}}
    {{if True}}
    frameType : CUeglFrameType
        Array or Pitch
    {{endif}}
    {{if True}}
    eglColorFormat : CUeglColorFormat
        CUDA EGL Color Format
    {{endif}}
    {{if True}}
    cuFormat : CUarray_format
        CUDA Array Format
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cydriver.CUeglFrame_st *>calloc(1, sizeof(cydriver.CUeglFrame_st))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cydriver.CUeglFrame_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if True}}
        self._frame = anon_union15(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if True}}
            try:
                str_list += ['frame :\n' + '\n'.join(['    ' + line for line in str(self.frame).splitlines()])]
            except ValueError:
                str_list += ['frame : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['width : ' + str(self.width)]
            except ValueError:
                str_list += ['width : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['height : ' + str(self.height)]
            except ValueError:
                str_list += ['height : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['depth : ' + str(self.depth)]
            except ValueError:
                str_list += ['depth : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['pitch : ' + str(self.pitch)]
            except ValueError:
                str_list += ['pitch : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['planeCount : ' + str(self.planeCount)]
            except ValueError:
                str_list += ['planeCount : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['numChannels : ' + str(self.numChannels)]
            except ValueError:
                str_list += ['numChannels : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['frameType : ' + str(self.frameType)]
            except ValueError:
                str_list += ['frameType : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['eglColorFormat : ' + str(self.eglColorFormat)]
            except ValueError:
                str_list += ['eglColorFormat : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['cuFormat : ' + str(self.cuFormat)]
            except ValueError:
                str_list += ['cuFormat : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if True}}
    @property
    def frame(self):
        return self._frame
    @frame.setter
    def frame(self, frame not None : anon_union15):
        string.memcpy(&self._pvt_ptr[0].frame, <cydriver.anon_union15*><void_ptr>frame.getPtr(), sizeof(self._pvt_ptr[0].frame))
    {{endif}}
    {{if True}}
    @property
    def width(self):
        return self._pvt_ptr[0].width
    @width.setter
    def width(self, unsigned int width):
        self._pvt_ptr[0].width = width
    {{endif}}
    {{if True}}
    @property
    def height(self):
        return self._pvt_ptr[0].height
    @height.setter
    def height(self, unsigned int height):
        self._pvt_ptr[0].height = height
    {{endif}}
    {{if True}}
    @property
    def depth(self):
        return self._pvt_ptr[0].depth
    @depth.setter
    def depth(self, unsigned int depth):
        self._pvt_ptr[0].depth = depth
    {{endif}}
    {{if True}}
    @property
    def pitch(self):
        return self._pvt_ptr[0].pitch
    @pitch.setter
    def pitch(self, unsigned int pitch):
        self._pvt_ptr[0].pitch = pitch
    {{endif}}
    {{if True}}
    @property
    def planeCount(self):
        return self._pvt_ptr[0].planeCount
    @planeCount.setter
    def planeCount(self, unsigned int planeCount):
        self._pvt_ptr[0].planeCount = planeCount
    {{endif}}
    {{if True}}
    @property
    def numChannels(self):
        return self._pvt_ptr[0].numChannels
    @numChannels.setter
    def numChannels(self, unsigned int numChannels):
        self._pvt_ptr[0].numChannels = numChannels
    {{endif}}
    {{if True}}
    @property
    def frameType(self):
        if self._pvt_ptr[0].frameType not in _dict_CUeglFrameType:
            return None
        return _dict_CUeglFrameType[self._pvt_ptr[0].frameType]
    @frameType.setter
    def frameType(self, frameType not None : CUeglFrameType):
        self._pvt_ptr[0].frameType = frameType.value
    {{endif}}
    {{if True}}
    @property
    def eglColorFormat(self):
        if self._pvt_ptr[0].eglColorFormat not in _dict_CUeglColorFormat:
            return None
        return _dict_CUeglColorFormat[self._pvt_ptr[0].eglColorFormat]
    @eglColorFormat.setter
    def eglColorFormat(self, eglColorFormat not None : CUeglColorFormat):
        self._pvt_ptr[0].eglColorFormat = eglColorFormat.value
    {{endif}}
    {{if True}}
    @property
    def cuFormat(self):
        if self._pvt_ptr[0].cuFormat not in _dict_CUarray_format:
            return None
        return _dict_CUarray_format[self._pvt_ptr[0].cuFormat]
    @cuFormat.setter
    def cuFormat(self, cuFormat not None : CUarray_format):
        self._pvt_ptr[0].cuFormat = cuFormat.value
    {{endif}}
{{endif}}
{{if 'cuuint32_t' in found_types}}

cdef class cuuint32_t:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, uint32_t init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.cuuint32_t *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<cuuint32_t ' + str(self.__int__()) + '>'
    def __int__(self):
        return <uint32_t>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cuuint64_t' in found_types}}

cdef class cuuint64_t:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, uint64_t init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.cuuint64_t *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<cuuint64_t ' + str(self.__int__()) + '>'
    def __int__(self):
        return <uint64_t>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUdeviceptr_v2' in found_types}}

cdef class CUdeviceptr_v2:
    """

    CUDA device pointer CUdeviceptr is defined as an unsigned integer type whose size matches the size of a pointer on the target platform.

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUdeviceptr_v2 *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUdeviceptr_v2 ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUdevice_v1' in found_types}}

cdef class CUdevice_v1:
    """

    CUDA device

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, int init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUdevice_v1 *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUdevice_v1 ' + str(self.__int__()) + '>'
    def __int__(self):
        return <int>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUtexObject_v1' in found_types}}

cdef class CUtexObject_v1:
    """

    An opaque value that represents a CUDA texture object

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUtexObject_v1 *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUtexObject_v1 ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUsurfObject_v1' in found_types}}

cdef class CUsurfObject_v1:
    """

    An opaque value that represents a CUDA surface object

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUsurfObject_v1 *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUsurfObject_v1 ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUmemGenericAllocationHandle_v1' in found_types}}

cdef class CUmemGenericAllocationHandle_v1:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUmemGenericAllocationHandle_v1 *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUmemGenericAllocationHandle_v1 ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'CUlogIterator' in found_types}}

cdef class CUlogIterator:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned int init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.CUlogIterator *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUlogIterator ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned int>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class GLenum:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned int init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.GLenum *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<GLenum ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned int>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class GLuint:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned int init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.GLuint *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<GLuint ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned int>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class EGLint:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned int init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.EGLint *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<EGLint ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned int>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class VdpDevice:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, uint32_t init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.VdpDevice *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<VdpDevice ' + str(self.__int__()) + '>'
    def __int__(self):
        return <uint32_t>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class VdpGetProcAddress:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.VdpGetProcAddress *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<VdpGetProcAddress ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class VdpVideoSurface:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, uint32_t init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.VdpVideoSurface *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<VdpVideoSurface ' + str(self.__int__()) + '>'
    def __int__(self):
        return <uint32_t>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class VdpOutputSurface:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, uint32_t init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cydriver.VdpOutputSurface *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<VdpOutputSurface ' + str(self.__int__()) + '>'
    def __int__(self):
        return <uint32_t>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cuGetErrorString' in found_functions}}

@cython.embedsignature(True)
def cuGetErrorString(error not None : CUresult):
    """ Gets the string description of an error code.

    Sets `*pStr` to the address of a NULL-terminated string description of
    the error code `error`. If the error code is not recognized,
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned and `*pStr` will
    be set to the NULL address.

    Parameters
    ----------
    error : :py:obj:`~.CUresult`
        Error code to convert to string

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pStr : bytes
        Address of the string pointer.

    See Also
    --------
    :py:obj:`~.CUresult`, :py:obj:`~.cudaGetErrorString`
    """
    cdef cydriver.CUresult cyerror = error.value
    cdef const char* pStr = NULL
    with nogil:
        err = cydriver.cuGetErrorString(cyerror, &pStr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], <bytes>pStr if pStr != NULL else None)
{{endif}}

{{if 'cuGetErrorName' in found_functions}}

@cython.embedsignature(True)
def cuGetErrorName(error not None : CUresult):
    """ Gets the string representation of an error code enum name.

    Sets `*pStr` to the address of a NULL-terminated string representation
    of the name of the enum error code `error`. If the error code is not
    recognized, :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned and
    `*pStr` will be set to the NULL address.

    Parameters
    ----------
    error : :py:obj:`~.CUresult`
        Error code to convert to string

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pStr : bytes
        Address of the string pointer.

    See Also
    --------
    :py:obj:`~.CUresult`, :py:obj:`~.cudaGetErrorName`
    """
    cdef cydriver.CUresult cyerror = error.value
    cdef const char* pStr = NULL
    with nogil:
        err = cydriver.cuGetErrorName(cyerror, &pStr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], <bytes>pStr if pStr != NULL else None)
{{endif}}

{{if 'cuInit' in found_functions}}

@cython.embedsignature(True)
def cuInit(unsigned int Flags):
    """ Initialize the CUDA driver API Initializes the driver API and must be called before any other function from the driver API in the current process. Currently, the `Flags` parameter must be 0. If :py:obj:`~.cuInit()` has not been called, any function from the driver API will return :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`.

    Note: cuInit preloads various libraries needed for JIT compilation. To
    opt-out of this behavior, set the environment variable
    CUDA_FORCE_PRELOAD_LIBRARIES=0. CUDA will lazily load JIT libraries as
    needed. To disable JIT entirely, set the environment variable
    CUDA_DISABLE_JIT=1.

    Parameters
    ----------
    Flags : unsigned int
        Initialization flag for CUDA.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_SYSTEM_DRIVER_MISMATCH`, :py:obj:`~.CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE`
    """
    with nogil:
        err = cydriver.cuInit(Flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuDriverGetVersion' in found_functions}}

@cython.embedsignature(True)
def cuDriverGetVersion():
    """ Returns the latest CUDA version supported by driver.

    Returns in `*driverVersion` the version of CUDA supported by the
    driver. The version is returned as (1000 * major + 10 * minor). For
    example, CUDA 9.2 would be represented by 9020.

    This function automatically returns
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if `driverVersion` is NULL.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    driverVersion : int
        Returns the CUDA driver version

    See Also
    --------
    :py:obj:`~.cudaDriverGetVersion`, :py:obj:`~.cudaRuntimeGetVersion`
    """
    cdef int driverVersion = 0
    with nogil:
        err = cydriver.cuDriverGetVersion(&driverVersion)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], driverVersion)
{{endif}}

{{if 'cuDeviceGet' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGet(int ordinal):
    """ Returns a handle to a compute device.

    Returns in `*device` a device handle given an ordinal in the range [0,
    :py:obj:`~.cuDeviceGetCount()`-1].

    Parameters
    ----------
    ordinal : int
        Device number to get handle for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    device : :py:obj:`~.CUdevice`
        Returned device handle

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGetLuid`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cuDeviceGetExecAffinitySupport`
    """
    cdef CUdevice device = CUdevice()
    with nogil:
        err = cydriver.cuDeviceGet(<cydriver.CUdevice*>device._pvt_ptr, ordinal)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], device)
{{endif}}

{{if 'cuDeviceGetCount' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetCount():
    """ Returns the number of compute-capable devices.

    Returns in `*count` the number of devices with compute capability
    greater than or equal to 2.0 that are available for execution. If there
    is no such device, :py:obj:`~.cuDeviceGetCount()` returns 0.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    count : int
        Returned number of compute-capable devices

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGetLuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cuDeviceGetExecAffinitySupport`, :py:obj:`~.cudaGetDeviceCount`
    """
    cdef int count = 0
    with nogil:
        err = cydriver.cuDeviceGetCount(&count)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], count)
{{endif}}

{{if 'cuDeviceGetName' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetName(int length, dev):
    """ Returns an identifier string for the device.

    Returns an ASCII string identifying the device `dev` in the NULL-
    terminated string pointed to by `name`. `length` specifies the maximum
    length of the string that may be returned. `name` is shortened to the
    specified `length`, if `length` is less than the device name

    Parameters
    ----------
    length : int
        Maximum length of string to store in `name`
    dev : :py:obj:`~.CUdevice`
        Device to get identifier string for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    name : bytes
        Returned identifier string for the device

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGetLuid`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cuDeviceGetExecAffinitySupport`, :py:obj:`~.cudaGetDeviceProperties`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    pyname = b" " * length
    cdef char* name = pyname
    with nogil:
        err = cydriver.cuDeviceGetName(name, length, cydev)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pyname)
{{endif}}

{{if 'cuDeviceGetUuid_v2' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetUuid(dev):
    """ Return an UUID for the device.

    Returns 16-octets identifying the device `dev` in the structure pointed
    by the `uuid`. If the device is in MIG mode, returns its MIG UUID which
    uniquely identifies the subscribed MIG compute instance.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device to get identifier string for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    uuid : :py:obj:`~.CUuuid`
        Returned UUID

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetLuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cudaGetDeviceProperties`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef CUuuid uuid = CUuuid()
    with nogil:
        err = cydriver.cuDeviceGetUuid(<cydriver.CUuuid*>uuid._pvt_ptr, cydev)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], uuid)
{{endif}}

{{if 'cuDeviceGetLuid' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetLuid(dev):
    """ Return an LUID and device node mask for the device.

    Return identifying information (`luid` and `deviceNodeMask`) to allow
    matching device with graphics APIs.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device to get identifier string for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    luid : bytes
        Returned LUID
    deviceNodeMask : unsigned int
        Returned device node mask

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cuDeviceGetExecAffinitySupport`, :py:obj:`~.cudaGetDeviceProperties`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef char luid[8]
    cdef unsigned int deviceNodeMask = 0
    with nogil:
        err = cydriver.cuDeviceGetLuid(luid, &deviceNodeMask, cydev)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], <bytes>luid, deviceNodeMask)
{{endif}}

{{if 'cuDeviceTotalMem_v2' in found_functions}}

@cython.embedsignature(True)
def cuDeviceTotalMem(dev):
    """ Returns the total amount of memory on the device.

    Returns in `*bytes` the total amount of memory available on the device
    `dev` in bytes.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device handle

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    numbytes : int
        Returned memory available on device in bytes

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceGetExecAffinitySupport`, :py:obj:`~.cudaMemGetInfo`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef size_t numbytes = 0
    with nogil:
        err = cydriver.cuDeviceTotalMem(&numbytes, cydev)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], numbytes)
{{endif}}

{{if 'cuDeviceGetTexture1DLinearMaxWidth' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetTexture1DLinearMaxWidth(pformat not None : CUarray_format, unsigned numChannels, dev):
    """ Returns the maximum number of elements allocatable in a 1D linear texture for a given texture element size.

    Returns in `maxWidthInElements` the maximum number of texture elements
    allocatable in a 1D linear texture for given `pformat` and
    `numChannels`.

    Parameters
    ----------
    pformat : :py:obj:`~.CUarray_format`
        Texture format.
    numChannels : unsigned
        Number of channels per texture element.
    dev : :py:obj:`~.CUdevice`
        Device handle.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    maxWidthInElements : int
        Returned maximum number of texture elements allocatable for given
        `pformat` and `numChannels`.

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cudaMemGetInfo`, :py:obj:`~.cuDeviceTotalMem`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef size_t maxWidthInElements = 0
    cdef cydriver.CUarray_format cypformat = pformat.value
    with nogil:
        err = cydriver.cuDeviceGetTexture1DLinearMaxWidth(&maxWidthInElements, cypformat, numChannels, cydev)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], maxWidthInElements)
{{endif}}

{{if 'cuDeviceGetAttribute' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetAttribute(attrib not None : CUdevice_attribute, dev):
    """ Returns information about the device.

    Returns in `*pi` the integer value of the attribute `attrib` on device
    `dev`.

    Parameters
    ----------
    attrib : :py:obj:`~.CUdevice_attribute`
        Device attribute to query
    dev : :py:obj:`~.CUdevice`
        Device handle

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    pi : int
        Returned device attribute value

    See Also
    --------
    :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cuDeviceGetExecAffinitySupport`, :py:obj:`~.cudaDeviceGetAttribute`, :py:obj:`~.cudaGetDeviceProperties`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef int pi = 0
    cdef cydriver.CUdevice_attribute cyattrib = attrib.value
    with nogil:
        err = cydriver.cuDeviceGetAttribute(&pi, cyattrib, cydev)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pi)
{{endif}}

{{if 'cuDeviceGetHostAtomicCapabilities' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetHostAtomicCapabilities(operations : Optional[tuple[CUatomicOperation] | list[CUatomicOperation]], unsigned int count, dev):
    """ Queries details about atomic operations supported between the device and host.

    Returns in `*capabilities` the details about requested atomic
    `*operations` over the the link between `dev` and the host. The
    allocated size of `*operations` and `*capabilities` must be `count`.

    For each :py:obj:`~.CUatomicOperation` in `*operations`, the
    corresponding result in `*capabilities` will be a bitmask indicating
    which of :py:obj:`~.CUatomicOperationCapability` the link supports
    natively.

    Returns :py:obj:`~.CUDA_ERROR_INVALID_DEVICE` if `dev` is not valid.

    Returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if `*capabilities` or
    `*operations` is NULL, if `count` is 0, or if any of `*operations` is
    not valid.

    Parameters
    ----------
    operations : list[:py:obj:`~.CUatomicOperation`]
        Requested operations
    count : unsigned int
        Count of requested operations and size of capabilities
    dev : :py:obj:`~.CUdevice`
        Device handle

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    capabilities : list[unsigned int]
        Returned capability details of each requested operation

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetP2PAtomicCapabilities`, :py:obj:`~.cudaDeviceGeHostAtomicCapabilities`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    operations = [] if operations is None else operations
    if not all(isinstance(_x, (CUatomicOperation)) for _x in operations):
        raise TypeError("Argument 'operations' is not instance of type (expected tuple[cydriver.CUatomicOperation] or list[cydriver.CUatomicOperation]")
    cdef unsigned int* cycapabilities = NULL
    pycapabilities = []
    if count != 0:
        cycapabilities = <unsigned int*>calloc(count, sizeof(unsigned int))
        if cycapabilities is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(count) + 'x' + str(sizeof(unsigned int)))
    cdef vector[cydriver.CUatomicOperation] cyoperations = [pyoperations.value for pyoperations in (operations)]
    if count > len(operations): raise RuntimeError("List is too small: " + str(len(operations)) + " < " + str(count))
    with nogil:
        err = cydriver.cuDeviceGetHostAtomicCapabilities(cycapabilities, cyoperations.data(), count, cydev)
    if CUresult(err) == CUresult(0):
        pycapabilities = [<unsigned int>cycapabilities[idx] for idx in range(count)]
    if cycapabilities is not NULL:
        free(cycapabilities)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pycapabilities)
{{endif}}

{{if 'cuDeviceGetNvSciSyncAttributes' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetNvSciSyncAttributes(nvSciSyncAttrList, dev, int flags):
    """ Return NvSciSync attributes that this device can support.

    Returns in `nvSciSyncAttrList`, the properties of NvSciSync that this
    CUDA device, `dev` can support. The returned `nvSciSyncAttrList` can be
    used to create an NvSciSync object that matches this device's
    capabilities.

    If NvSciSyncAttrKey_RequiredPerm field in `nvSciSyncAttrList` is
    already set this API will return :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

    The applications should set `nvSciSyncAttrList` to a valid
    NvSciSyncAttrList failing which this API will return
    :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`.

    The `flags` controls how applications intends to use the NvSciSync
    created from the `nvSciSyncAttrList`. The valid flags are:

    - :py:obj:`~.CUDA_NVSCISYNC_ATTR_SIGNAL`, specifies that the
      applications intends to signal an NvSciSync on this CUDA device.

    - :py:obj:`~.CUDA_NVSCISYNC_ATTR_WAIT`, specifies that the applications
      intends to wait on an NvSciSync on this CUDA device.

    At least one of these flags must be set, failing which the API returns
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE`. Both the flags are orthogonal to
    one another: a developer may set both these flags that allows to set
    both wait and signal specific attributes in the same
    `nvSciSyncAttrList`.

    Note that this API updates the input `nvSciSyncAttrList` with values
    equivalent to the following public attribute key-values:
    NvSciSyncAttrKey_RequiredPerm is set to

    - NvSciSyncAccessPerm_SignalOnly if
      :py:obj:`~.CUDA_NVSCISYNC_ATTR_SIGNAL` is set in `flags`.

    - NvSciSyncAccessPerm_WaitOnly if :py:obj:`~.CUDA_NVSCISYNC_ATTR_WAIT`
      is set in `flags`.

    - NvSciSyncAccessPerm_WaitSignal if both
      :py:obj:`~.CUDA_NVSCISYNC_ATTR_WAIT` and
      :py:obj:`~.CUDA_NVSCISYNC_ATTR_SIGNAL` are set in `flags`.
      NvSciSyncAttrKey_PrimitiveInfo is set to

    - NvSciSyncAttrValPrimitiveType_SysmemSemaphore on any valid `device`.

    - NvSciSyncAttrValPrimitiveType_Syncpoint if `device` is a Tegra
      device.

    - NvSciSyncAttrValPrimitiveType_SysmemSemaphorePayload64b if `device`
      is GA10X+. NvSciSyncAttrKey_GpuId is set to the same UUID that is
      returned for this `device` from :py:obj:`~.cuDeviceGetUuid`.

    :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`,
    :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`,
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`,
    :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`,
    :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`,
    :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

    Parameters
    ----------
    nvSciSyncAttrList : Any
        Return NvSciSync attributes supported.
    dev : :py:obj:`~.CUdevice`
        Valid Cuda Device to get NvSciSync attributes for.
    flags : int
        flags describing NvSciSync usage.

    Returns
    -------
    CUresult


    See Also
    --------
    :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuDestroyExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cynvSciSyncAttrList = _HelperInputVoidPtr(nvSciSyncAttrList)
    cdef void* cynvSciSyncAttrList_ptr = <void*><void_ptr>cynvSciSyncAttrList.cptr
    with nogil:
        err = cydriver.cuDeviceGetNvSciSyncAttributes(cynvSciSyncAttrList_ptr, cydev, flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuDeviceSetMemPool' in found_functions}}

@cython.embedsignature(True)
def cuDeviceSetMemPool(dev, pool):
    """ Sets the current memory pool of a device.

    The memory pool must be local to the specified device.
    :py:obj:`~.cuMemAllocAsync` allocates from the current mempool of the
    provided stream's device. By default, a device's current memory pool is
    its default memory pool.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        None
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        None

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuMemPoolDestroy`, :py:obj:`~.cuMemAllocFromPoolAsync`

    Notes
    -----
    Use :py:obj:`~.cuMemAllocFromPoolAsync` to specify asynchronous allocations from a device different than the one the stream runs on.
    """
    cdef cydriver.CUmemoryPool cypool
    if pool is None:
        ppool = 0
    elif isinstance(pool, (CUmemoryPool,)):
        ppool = int(pool)
    else:
        ppool = int(CUmemoryPool(pool))
    cypool = <cydriver.CUmemoryPool><void_ptr>ppool
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    with nogil:
        err = cydriver.cuDeviceSetMemPool(cydev, cypool)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuDeviceGetMemPool' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetMemPool(dev):
    """ Gets the current mempool for a device.

    Returns the last pool provided to :py:obj:`~.cuDeviceSetMemPool` for
    this device or the device's default memory pool if
    :py:obj:`~.cuDeviceSetMemPool` has never been called. By default the
    current mempool is the default mempool for a device. Otherwise the
    returned pool must have been set with :py:obj:`~.cuDeviceSetMemPool`.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        None

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pool : :py:obj:`~.CUmemoryPool`
        None

    See Also
    --------
    :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuDeviceSetMemPool`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef CUmemoryPool pool = CUmemoryPool()
    with nogil:
        err = cydriver.cuDeviceGetMemPool(<cydriver.CUmemoryPool*>pool._pvt_ptr, cydev)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pool)
{{endif}}

{{if 'cuDeviceGetDefaultMemPool' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetDefaultMemPool(dev):
    """ Returns the default mempool of a device.

    The default mempool of a device contains device memory from that
    device.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        None

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    pool_out : :py:obj:`~.CUmemoryPool`
        None

    See Also
    --------
    :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemPoolTrimTo`, :py:obj:`~.cuMemPoolGetAttribute`, :py:obj:`~.cuMemPoolSetAttribute`, :py:obj:`~.cuMemPoolSetAccess`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef CUmemoryPool pool_out = CUmemoryPool()
    with nogil:
        err = cydriver.cuDeviceGetDefaultMemPool(<cydriver.CUmemoryPool*>pool_out._pvt_ptr, cydev)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pool_out)
{{endif}}

{{if 'cuDeviceGetExecAffinitySupport' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetExecAffinitySupport(typename not None : CUexecAffinityType, dev):
    """ Returns information about the execution affinity support of the device.

    Returns in `*pi` whether execution affinity type `typename` is
    supported by device `dev`. The supported types are:

    - :py:obj:`~.CU_EXEC_AFFINITY_TYPE_SM_COUNT`: 1 if context with limited
      SMs is supported by the device, or 0 if not;

    Parameters
    ----------
    typename : :py:obj:`~.CUexecAffinityType`
        Execution affinity type to query
    dev : :py:obj:`~.CUdevice`
        Device handle

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    pi : int
        1 if the execution affinity type `typename` is supported by the
        device, or 0 if not

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef int pi = 0
    cdef cydriver.CUexecAffinityType cytypename = typename.value
    with nogil:
        err = cydriver.cuDeviceGetExecAffinitySupport(&pi, cytypename, cydev)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pi)
{{endif}}

{{if 'cuFlushGPUDirectRDMAWrites' in found_functions}}

@cython.embedsignature(True)
def cuFlushGPUDirectRDMAWrites(target not None : CUflushGPUDirectRDMAWritesTarget, scope not None : CUflushGPUDirectRDMAWritesScope):
    """ Blocks until remote writes are visible to the specified scope.

    Blocks until GPUDirect RDMA writes to the target context via mappings
    created through APIs like nvidia_p2p_get_pages (see
    https://docs.nvidia.com/cuda/gpudirect-rdma for more information), are
    visible to the specified scope.

    If the scope equals or lies within the scope indicated by
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING`, the
    call will be a no-op and can be safely omitted for performance. This
    can be determined by comparing the numerical values between the two
    enums, with smaller scopes having smaller values.

    On platforms that support GPUDirect RDMA writes via more than one path
    in hardware (see
    :py:obj:`~.CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE`), the user
    should consider those paths as belonging to separate ordering domains.
    Note that in such cases CUDA driver will report both RDMA writes
    ordering and RDMA write scope as ALL_DEVICES and a call to
    cuFlushGPUDirectRDMA will be a no-op, but when these multiple paths are
    used simultaneously, it is the user's responsibility to ensure ordering
    by using mechanisms outside the scope of CUDA.

    Users may query support for this API via
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_FLUSH_FLUSH_GPU_DIRECT_RDMA_OPTIONS`.

    Parameters
    ----------
    target : :py:obj:`~.CUflushGPUDirectRDMAWritesTarget`
        The target of the operation, see
        :py:obj:`~.CUflushGPUDirectRDMAWritesTarget`
    scope : :py:obj:`~.CUflushGPUDirectRDMAWritesScope`
        The scope of the operation, see
        :py:obj:`~.CUflushGPUDirectRDMAWritesScope`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    """
    cdef cydriver.CUflushGPUDirectRDMAWritesTarget cytarget = target.value
    cdef cydriver.CUflushGPUDirectRDMAWritesScope cyscope = scope.value
    with nogil:
        err = cydriver.cuFlushGPUDirectRDMAWrites(cytarget, cyscope)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuDeviceGetProperties' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetProperties(dev):
    """ Returns properties for a selected device.

    [Deprecated]

    This function was deprecated as of CUDA 5.0 and replaced by
    :py:obj:`~.cuDeviceGetAttribute()`.

    Returns in `*prop` the properties of device `dev`. The
    :py:obj:`~.CUdevprop` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.maxThreadsPerBlock` is the maximum number of threads per
      block;

    - :py:obj:`~.maxThreadsDim`[3] is the maximum sizes of each dimension
      of a block;

    - :py:obj:`~.maxGridSize`[3] is the maximum sizes of each dimension of
      a grid;

    - :py:obj:`~.sharedMemPerBlock` is the total amount of shared memory
      available per block in bytes;

    - :py:obj:`~.totalConstantMemory` is the total amount of constant
      memory available on the device in bytes;

    - :py:obj:`~.SIMDWidth` is the warp size;

    - :py:obj:`~.memPitch` is the maximum pitch allowed by the memory copy
      functions that involve memory regions allocated through
      :py:obj:`~.cuMemAllocPitch()`;

    - :py:obj:`~.regsPerBlock` is the total number of registers available
      per block;

    - :py:obj:`~.clockRate` is the clock frequency in kilohertz;

    - :py:obj:`~.textureAlign` is the alignment requirement; texture base
      addresses that are aligned to :py:obj:`~.textureAlign` bytes do not
      need an offset applied to texture fetches.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device to get properties for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    prop : :py:obj:`~.CUdevprop`
        Returned properties of device

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef CUdevprop prop = CUdevprop()
    with nogil:
        err = cydriver.cuDeviceGetProperties(<cydriver.CUdevprop*>prop._pvt_ptr, cydev)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], prop)
{{endif}}

{{if 'cuDeviceComputeCapability' in found_functions}}

@cython.embedsignature(True)
def cuDeviceComputeCapability(dev):
    """ Returns the compute capability of the device.

    [Deprecated]

    This function was deprecated as of CUDA 5.0 and its functionality
    superseded by :py:obj:`~.cuDeviceGetAttribute()`.

    Returns in `*major` and `*minor` the major and minor revision numbers
    that define the compute capability of the device `dev`.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device handle

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    major : int
        Major revision number
    minor : int
        Minor revision number

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef int major = 0
    cdef int minor = 0
    with nogil:
        err = cydriver.cuDeviceComputeCapability(&major, &minor, cydev)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], major, minor)
{{endif}}

{{if 'cuDevicePrimaryCtxRetain' in found_functions}}

@cython.embedsignature(True)
def cuDevicePrimaryCtxRetain(dev):
    """ Retain the primary context on the GPU.

    Retains the primary context on the device. Once the user successfully
    retains the primary context, the primary context will be active and
    available to the user until the user releases it with
    :py:obj:`~.cuDevicePrimaryCtxRelease()` or resets it with
    :py:obj:`~.cuDevicePrimaryCtxReset()`. Unlike :py:obj:`~.cuCtxCreate()`
    the newly retained context is not pushed onto the stack.

    Retaining the primary context for the first time will fail with
    :py:obj:`~.CUDA_ERROR_UNKNOWN` if the compute mode of the device is
    :py:obj:`~.CU_COMPUTEMODE_PROHIBITED`. The function
    :py:obj:`~.cuDeviceGetAttribute()` can be used with
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_COMPUTE_MODE` to determine the compute
    mode of the device. The `nvidia-smi` tool can be used to set the
    compute mode for devices. Documentation for `nvidia-smi` can be
    obtained by passing a -h option to it.

    Please note that the primary context always supports pinned
    allocations. Other flags can be specified by
    :py:obj:`~.cuDevicePrimaryCtxSetFlags()`.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device for which primary context is requested

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    pctx : :py:obj:`~.CUcontext`
        Returned context handle of the new context

    See Also
    --------
    :py:obj:`~.cuDevicePrimaryCtxRelease`, :py:obj:`~.cuDevicePrimaryCtxSetFlags`, :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef CUcontext pctx = CUcontext()
    with nogil:
        err = cydriver.cuDevicePrimaryCtxRetain(<cydriver.CUcontext*>pctx._pvt_ptr, cydev)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pctx)
{{endif}}

{{if 'cuDevicePrimaryCtxRelease_v2' in found_functions}}

@cython.embedsignature(True)
def cuDevicePrimaryCtxRelease(dev):
    """ Release the primary context on the GPU.

    Releases the primary context interop on the device. A retained context
    should always be released once the user is done using it. The context
    is automatically reset once the last reference to it is released. This
    behavior is different when the primary context was retained by the CUDA
    runtime from CUDA 4.0 and earlier. In this case, the primary context
    remains always active.

    Releasing a primary context that has not been previously retained will
    fail with :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`.

    Please note that unlike :py:obj:`~.cuCtxDestroy()` this method does not
    pop the context from stack in any circumstances.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device which primary context is released

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuDevicePrimaryCtxRetain`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    with nogil:
        err = cydriver.cuDevicePrimaryCtxRelease(cydev)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuDevicePrimaryCtxSetFlags_v2' in found_functions}}

@cython.embedsignature(True)
def cuDevicePrimaryCtxSetFlags(dev, unsigned int flags):
    """ Set flags for the primary context.

    Sets the flags for the primary context on the device overwriting
    perviously set ones.

    The three LSBs of the `flags` parameter can be used to control how the
    OS thread, which owns the CUDA context at the time of an API call,
    interacts with the OS scheduler when waiting for results from the GPU.
    Only one of the scheduling flags can be set when creating a context.

    - :py:obj:`~.CU_CTX_SCHED_SPIN`: Instruct CUDA to actively spin when
      waiting for results from the GPU. This can decrease latency when
      waiting for the GPU, but may lower the performance of CPU threads if
      they are performing work in parallel with the CUDA thread.

    - :py:obj:`~.CU_CTX_SCHED_YIELD`: Instruct CUDA to yield its thread
      when waiting for results from the GPU. This can increase latency when
      waiting for the GPU, but can increase the performance of CPU threads
      performing work in parallel with the GPU.

    - :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`: Instruct CUDA to block the
      CPU thread on a synchronization primitive when waiting for the GPU to
      finish work.

    - :py:obj:`~.CU_CTX_BLOCKING_SYNC`: Instruct CUDA to block the CPU
      thread on a synchronization primitive when waiting for the GPU to
      finish work.   Deprecated: This flag was deprecated as of CUDA 4.0
      and was replaced with :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`.

    - :py:obj:`~.CU_CTX_SCHED_AUTO`: The default value if the `flags`
      parameter is zero, uses a heuristic based on the number of active
      CUDA contexts in the process `C` and the number of logical processors
      in the system `P`. If `C` > `P`, then CUDA will yield to other OS
      threads when waiting for the GPU (:py:obj:`~.CU_CTX_SCHED_YIELD`),
      otherwise CUDA will not yield while waiting for results and actively
      spin on the processor (:py:obj:`~.CU_CTX_SCHED_SPIN`). Additionally,
      on Tegra devices, :py:obj:`~.CU_CTX_SCHED_AUTO` uses a heuristic
      based on the power profile of the platform and may choose
      :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC` for low-powered devices.

    - :py:obj:`~.CU_CTX_LMEM_RESIZE_TO_MAX`: Instruct CUDA to not reduce
      local memory after resizing local memory for a kernel. This can
      prevent thrashing by local memory allocations when launching many
      kernels with high local memory usage at the cost of potentially
      increased memory usage.   Deprecated: This flag is deprecated and the
      behavior enabled by this flag is now the default and cannot be
      disabled.

    - :py:obj:`~.CU_CTX_COREDUMP_ENABLE`: If GPU coredumps have not been
      enabled globally with :py:obj:`~.cuCoredumpSetAttributeGlobal` or
      environment variables, this flag can be set during context creation
      to instruct CUDA to create a coredump if this context raises an
      exception during execution. These environment variables are described
      in the CUDA-GDB user guide under the "GPU core dump support" section.
      The initial settings will be taken from the global settings at the
      time of context creation. The other settings that control coredump
      output can be modified by calling :py:obj:`~.cuCoredumpSetAttribute`
      from the created context after it becomes current.

    - :py:obj:`~.CU_CTX_USER_COREDUMP_ENABLE`: If user-triggered GPU
      coredumps have not been enabled globally with
      :py:obj:`~.cuCoredumpSetAttributeGlobal` or environment variables,
      this flag can be set during context creation to instruct CUDA to
      create a coredump if data is written to a certain pipe that is
      present in the OS space. These environment variables are described in
      the CUDA-GDB user guide under the "GPU core dump support" section. It
      is important to note that the pipe name `must` be set with
      :py:obj:`~.cuCoredumpSetAttributeGlobal` before creating the context
      if this flag is used. Setting this flag implies that
      :py:obj:`~.CU_CTX_COREDUMP_ENABLE` is set. The initial settings will
      be taken from the global settings at the time of context creation.
      The other settings that control coredump output can be modified by
      calling :py:obj:`~.cuCoredumpSetAttribute` from the created context
      after it becomes current.

    - :py:obj:`~.CU_CTX_SYNC_MEMOPS`: Ensures that synchronous memory
      operations initiated on this context will always synchronize. See
      further documentation in the section titled "API Synchronization
      behavior" to learn more about cases when synchronous memory
      operations can exhibit asynchronous behavior.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device for which the primary context flags are set
    flags : unsigned int
        New flags for the device

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuDevicePrimaryCtxRetain`, :py:obj:`~.cuDevicePrimaryCtxGetState`, :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxSetFlags`, :py:obj:`~.cudaSetDeviceFlags`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    with nogil:
        err = cydriver.cuDevicePrimaryCtxSetFlags(cydev, flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuDevicePrimaryCtxGetState' in found_functions}}

@cython.embedsignature(True)
def cuDevicePrimaryCtxGetState(dev):
    """ Get the state of the primary context.

    Returns in `*flags` the flags for the primary context of `dev`, and in
    `*active` whether it is active. See
    :py:obj:`~.cuDevicePrimaryCtxSetFlags` for flag values.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device to get primary context flags for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    flags : unsigned int
        Pointer to store flags
    active : int
        Pointer to store context state; 0 = inactive, 1 = active

    See Also
    --------
    :py:obj:`~.cuDevicePrimaryCtxSetFlags`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxSetFlags`, :py:obj:`~.cudaGetDeviceFlags`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef unsigned int flags = 0
    cdef int active = 0
    with nogil:
        err = cydriver.cuDevicePrimaryCtxGetState(cydev, &flags, &active)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], flags, active)
{{endif}}

{{if 'cuDevicePrimaryCtxReset_v2' in found_functions}}

@cython.embedsignature(True)
def cuDevicePrimaryCtxReset(dev):
    """ Destroy all allocations and reset all state on the primary context.

    Explicitly destroys and cleans up all resources associated with the
    current device in the current process.

    Note that it is responsibility of the calling function to ensure that
    no other module in the process is using the device any more. For that
    reason it is recommended to use :py:obj:`~.cuDevicePrimaryCtxRelease()`
    in most cases. However it is safe for other modules to call
    :py:obj:`~.cuDevicePrimaryCtxRelease()` even after resetting the
    device. Resetting the primary context does not release it, an
    application that has retained the primary context should explicitly
    release its usage.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device for which primary context is destroyed

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE`

    See Also
    --------
    :py:obj:`~.cuDevicePrimaryCtxRetain`, :py:obj:`~.cuDevicePrimaryCtxRelease`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cudaDeviceReset`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    with nogil:
        err = cydriver.cuDevicePrimaryCtxReset(cydev)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCtxCreate_v4' in found_functions}}

@cython.embedsignature(True)
def cuCtxCreate(ctxCreateParams : Optional[CUctxCreateParams], unsigned int flags, dev):
    """ Create a CUDA context.

    Creates a new CUDA context and associates it with the calling thread.
    The `flags` parameter is described below. The context is created with a
    usage count of 1 and the caller of :py:obj:`~.cuCtxCreate()` must call
    :py:obj:`~.cuCtxDestroy()` when done using the context. If a context is
    already current to the thread, it is supplanted by the newly created
    context and may be restored by a subsequent call to
    :py:obj:`~.cuCtxPopCurrent()`.

    CUDA context can be created with execution affinity. The type and the
    amount of execution resource the context can use is limited by
    `paramsArray` and `numExecAffinityParams` in `execAffinity`. The
    `paramsArray` is an array of `CUexecAffinityParam` and the
    `numExecAffinityParams` describes the size of the paramsArray. If two
    `CUexecAffinityParam` in the array have the same type, the latter
    execution affinity parameter overrides the former execution affinity
    parameter. The supported execution affinity types are:

    - :py:obj:`~.CU_EXEC_AFFINITY_TYPE_SM_COUNT` limits the portion of SMs
      that the context can use. The portion of SMs is specified as the
      number of SMs via `CUexecAffinitySmCount`. This limit will be
      internally rounded up to the next hardware-supported amount. Hence,
      it is imperative to query the actual execution affinity of the
      context via `cuCtxGetExecAffinity` after context creation. Currently,
      this attribute is only supported under Volta+ MPS.

    CUDA context can be created in CIG(CUDA in Graphics) mode by setting
    `cigParams`. Data from graphics client is shared with CUDA via the
    `sharedData` in `cigParams`. Support for D3D12 graphics client can be
    determined using :py:obj:`~.cuDeviceGetAttribute()` with
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_D3D12_CIG_SUPPORTED`. `sharedData` is a
    ID3D12CommandQueue handle. Support for Vulkan graphics client can be
    determined using :py:obj:`~.cuDeviceGetAttribute()` with
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_VULKAN_CIG_SUPPORTED`. `sharedData` is a
    Nvidia specific data blob populated by calling
    vkGetExternalComputeQueueDataNV(). Either `execAffinityParams` or
    `cigParams` can be set to a non-null value. Setting both to a non-null
    value will result in an undefined behavior.

    The three LSBs of the `flags` parameter can be used to control how the
    OS thread, which owns the CUDA context at the time of an API call,
    interacts with the OS scheduler when waiting for results from the GPU.
    Only one of the scheduling flags can be set when creating a context.

    - :py:obj:`~.CU_CTX_SCHED_SPIN`: Instruct CUDA to actively spin when
      waiting for results from the GPU. This can decrease latency when
      waiting for the GPU, but may lower the performance of CPU threads if
      they are performing work in parallel with the CUDA thread.

    - :py:obj:`~.CU_CTX_SCHED_YIELD`: Instruct CUDA to yield its thread
      when waiting for results from the GPU. This can increase latency when
      waiting for the GPU, but can increase the performance of CPU threads
      performing work in parallel with the GPU.

    - :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`: Instruct CUDA to block the
      CPU thread on a synchronization primitive when waiting for the GPU to
      finish work.

    - :py:obj:`~.CU_CTX_BLOCKING_SYNC`: Instruct CUDA to block the CPU
      thread on a synchronization primitive when waiting for the GPU to
      finish work.   Deprecated: This flag was deprecated as of CUDA 4.0
      and was replaced with :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`.

    - :py:obj:`~.CU_CTX_SCHED_AUTO`: The default value if the `flags`
      parameter is zero, uses a heuristic based on the number of active
      CUDA contexts in the process `C` and the number of logical processors
      in the system `P`. If `C` > `P`, then CUDA will yield to other OS
      threads when waiting for the GPU (:py:obj:`~.CU_CTX_SCHED_YIELD`),
      otherwise CUDA will not yield while waiting for results and actively
      spin on the processor (:py:obj:`~.CU_CTX_SCHED_SPIN`). Additionally,
      on Tegra devices, :py:obj:`~.CU_CTX_SCHED_AUTO` uses a heuristic
      based on the power profile of the platform and may choose
      :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC` for low-powered devices.

    - :py:obj:`~.CU_CTX_MAP_HOST`: Instruct CUDA to support mapped pinned
      allocations. This flag must be set in order to allocate pinned host
      memory that is accessible to the GPU.

    - :py:obj:`~.CU_CTX_LMEM_RESIZE_TO_MAX`: Instruct CUDA to not reduce
      local memory after resizing local memory for a kernel. This can
      prevent thrashing by local memory allocations when launching many
      kernels with high local memory usage at the cost of potentially
      increased memory usage.   Deprecated: This flag is deprecated and the
      behavior enabled by this flag is now the default and cannot be
      disabled. Instead, the per-thread stack size can be controlled with
      :py:obj:`~.cuCtxSetLimit()`.

    - :py:obj:`~.CU_CTX_COREDUMP_ENABLE`: If GPU coredumps have not been
      enabled globally with :py:obj:`~.cuCoredumpSetAttributeGlobal` or
      environment variables, this flag can be set during context creation
      to instruct CUDA to create a coredump if this context raises an
      exception during execution. These environment variables are described
      in the CUDA-GDB user guide under the "GPU core dump support" section.
      The initial attributes will be taken from the global attributes at
      the time of context creation. The other attributes that control
      coredump output can be modified by calling
      :py:obj:`~.cuCoredumpSetAttribute` from the created context after it
      becomes current. This flag is not supported when CUDA context is
      created in CIG(CUDA in Graphics) mode.

    - :py:obj:`~.CU_CTX_USER_COREDUMP_ENABLE`: If user-triggered GPU
      coredumps have not been enabled globally with
      :py:obj:`~.cuCoredumpSetAttributeGlobal` or environment variables,
      this flag can be set during context creation to instruct CUDA to
      create a coredump if data is written to a certain pipe that is
      present in the OS space. These environment variables are described in
      the CUDA-GDB user guide under the "GPU core dump support" section. It
      is important to note that the pipe name `must` be set with
      :py:obj:`~.cuCoredumpSetAttributeGlobal` before creating the context
      if this flag is used. Setting this flag implies that
      :py:obj:`~.CU_CTX_COREDUMP_ENABLE` is set. The initial attributes
      will be taken from the global attributes at the time of context
      creation. The other attributes that control coredump output can be
      modified by calling :py:obj:`~.cuCoredumpSetAttribute` from the
      created context after it becomes current. Setting this flag on any
      context creation is equivalent to setting the
      :py:obj:`~.CU_COREDUMP_ENABLE_USER_TRIGGER` attribute to `true`
      globally. This flag is not supported when CUDA context is created in
      CIG(CUDA in Graphics) mode.

    - :py:obj:`~.CU_CTX_SYNC_MEMOPS`: Ensures that synchronous memory
      operations initiated on this context will always synchronize. See
      further documentation in the section titled "API Synchronization
      behavior" to learn more about cases when synchronous memory
      operations can exhibit asynchronous behavior.

    Context creation will fail with :py:obj:`~.CUDA_ERROR_UNKNOWN` if the
    compute mode of the device is :py:obj:`~.CU_COMPUTEMODE_PROHIBITED`.
    The function :py:obj:`~.cuDeviceGetAttribute()` can be used with
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_COMPUTE_MODE` to determine the compute
    mode of the device. The `nvidia-smi` tool can be used to set the
    compute mode for * devices. Documentation for `nvidia-smi` can be
    obtained by passing a -h option to it.

    Context creation will fail with :: CUDA_ERROR_INVALID_VALUE if invalid
    parameter was passed by client to create the CUDA context.

    Context creation in CIG mode will fail with
    :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED` if CIG is not supported by the
    device or the driver.

    Parameters
    ----------
    ctxCreateParams : :py:obj:`~.CUctxCreateParams`
        Context creation parameters
    flags : unsigned int
        Context creation flags
    dev : :py:obj:`~.CUdevice`
        Device to create context on

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    pctx : :py:obj:`~.CUcontext`
        Returned context handle of the new context

    See Also
    --------
    :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCoredumpSetAttributeGlobal`, :py:obj:`~.cuCoredumpSetAttribute`, :py:obj:`~.cuCtxSynchronize`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef CUcontext pctx = CUcontext()
    cdef cydriver.CUctxCreateParams* cyctxCreateParams_ptr = ctxCreateParams._pvt_ptr if ctxCreateParams is not None else NULL
    with nogil:
        err = cydriver.cuCtxCreate(<cydriver.CUcontext*>pctx._pvt_ptr, cyctxCreateParams_ptr, flags, cydev)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pctx)
{{endif}}

{{if 'cuCtxDestroy_v2' in found_functions}}

@cython.embedsignature(True)
def cuCtxDestroy(ctx):
    """ Destroy a CUDA context.

    Destroys the CUDA context specified by `ctx`. The context `ctx` will be
    destroyed regardless of how many threads it is current to. It is the
    responsibility of the calling function to ensure that no API call
    issues using `ctx` while :py:obj:`~.cuCtxDestroy()` is executing.

    Destroys and cleans up all resources associated with the context. It is
    the caller's responsibility to ensure that the context or its resources
    are not accessed or passed in subsequent API calls and doing so will
    result in undefined behavior. These resources include CUDA types
    :py:obj:`~.CUmodule`, :py:obj:`~.CUfunction`, :py:obj:`~.CUstream`,
    :py:obj:`~.CUevent`, :py:obj:`~.CUarray`, :py:obj:`~.CUmipmappedArray`,
    :py:obj:`~.CUtexObject`, :py:obj:`~.CUsurfObject`,
    :py:obj:`~.CUtexref`, :py:obj:`~.CUsurfref`,
    :py:obj:`~.CUgraphicsResource`, :py:obj:`~.CUlinkState`,
    :py:obj:`~.CUexternalMemory` and :py:obj:`~.CUexternalSemaphore`. These
    resources also include memory allocations by :py:obj:`~.cuMemAlloc()`,
    :py:obj:`~.cuMemAllocHost()`, :py:obj:`~.cuMemAllocManaged()` and
    :py:obj:`~.cuMemAllocPitch()`.

    If `ctx` is current to the calling thread then `ctx` will also be
    popped from the current thread's context stack (as though
    :py:obj:`~.cuCtxPopCurrent()` were called). If `ctx` is current to
    other threads, then `ctx` will remain current to those threads, and
    attempting to access `ctx` from those threads will result in the error
    :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`.

    Parameters
    ----------
    ctx : :py:obj:`~.CUcontext`
        Context to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`

    Notes
    -----
    :py:obj:`~.cuCtxDestroy()` will not destroy memory allocations by :py:obj:`~.cuMemCreate()`, :py:obj:`~.cuMemAllocAsync()` and :py:obj:`~.cuMemAllocFromPoolAsync()`. These memory allocations are not associated with any CUDA context and need to be destroyed explicitly.
    """
    cdef cydriver.CUcontext cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (CUcontext,)):
        pctx = int(ctx)
    else:
        pctx = int(CUcontext(ctx))
    cyctx = <cydriver.CUcontext><void_ptr>pctx
    with nogil:
        err = cydriver.cuCtxDestroy(cyctx)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCtxPushCurrent_v2' in found_functions}}

@cython.embedsignature(True)
def cuCtxPushCurrent(ctx):
    """ Pushes a context on the current CPU thread.

    Pushes the given context `ctx` onto the CPU thread's stack of current
    contexts. The specified context becomes the CPU thread's current
    context, so all CUDA functions that operate on the current context are
    affected.

    The previous current context may be made current again by calling
    :py:obj:`~.cuCtxDestroy()` or :py:obj:`~.cuCtxPopCurrent()`.

    Parameters
    ----------
    ctx : :py:obj:`~.CUcontext`
        Context to push

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """
    cdef cydriver.CUcontext cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (CUcontext,)):
        pctx = int(ctx)
    else:
        pctx = int(CUcontext(ctx))
    cyctx = <cydriver.CUcontext><void_ptr>pctx
    with nogil:
        err = cydriver.cuCtxPushCurrent(cyctx)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCtxPopCurrent_v2' in found_functions}}

@cython.embedsignature(True)
def cuCtxPopCurrent():
    """ Pops the current CUDA context from the current CPU thread.

    Pops the current CUDA context from the CPU thread and passes back the
    old context handle in `*pctx`. That context may then be made current to
    a different CPU thread by calling :py:obj:`~.cuCtxPushCurrent()`.

    If a context was current to the CPU thread before
    :py:obj:`~.cuCtxCreate()` or :py:obj:`~.cuCtxPushCurrent()` was called,
    this function makes that context current to the CPU thread again.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`
    pctx : :py:obj:`~.CUcontext`
        Returned popped context handle

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """
    cdef CUcontext pctx = CUcontext()
    with nogil:
        err = cydriver.cuCtxPopCurrent(<cydriver.CUcontext*>pctx._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pctx)
{{endif}}

{{if 'cuCtxSetCurrent' in found_functions}}

@cython.embedsignature(True)
def cuCtxSetCurrent(ctx):
    """ Binds the specified CUDA context to the calling CPU thread.

    Binds the specified CUDA context to the calling CPU thread. If `ctx` is
    NULL then the CUDA context previously bound to the calling CPU thread
    is unbound and :py:obj:`~.CUDA_SUCCESS` is returned.

    If there exists a CUDA context stack on the calling CPU thread, this
    will replace the top of that stack with `ctx`. If `ctx` is NULL then
    this will be equivalent to popping the top of the calling CPU thread's
    CUDA context stack (or a no-op if the calling CPU thread's CUDA context
    stack is empty).

    Parameters
    ----------
    ctx : :py:obj:`~.CUcontext`
        Context to bind to the calling CPU thread

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuCtxGetCurrent`, :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cudaSetDevice`
    """
    cdef cydriver.CUcontext cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (CUcontext,)):
        pctx = int(ctx)
    else:
        pctx = int(CUcontext(ctx))
    cyctx = <cydriver.CUcontext><void_ptr>pctx
    with nogil:
        err = cydriver.cuCtxSetCurrent(cyctx)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCtxGetCurrent' in found_functions}}

@cython.embedsignature(True)
def cuCtxGetCurrent():
    """ Returns the CUDA context bound to the calling CPU thread.

    Returns in `*pctx` the CUDA context bound to the calling CPU thread. If
    no context is bound to the calling CPU thread then `*pctx` is set to
    NULL and :py:obj:`~.CUDA_SUCCESS` is returned.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`,
    pctx : :py:obj:`~.CUcontext`
        Returned context handle

    See Also
    --------
    :py:obj:`~.cuCtxSetCurrent`, :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cudaGetDevice`
    """
    cdef CUcontext pctx = CUcontext()
    with nogil:
        err = cydriver.cuCtxGetCurrent(<cydriver.CUcontext*>pctx._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pctx)
{{endif}}

{{if 'cuCtxGetDevice' in found_functions}}

@cython.embedsignature(True)
def cuCtxGetDevice():
    """ Returns the device handle for the current context.

    Returns in `*device` the handle of the current context's device.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    device : :py:obj:`~.CUdevice`
        Returned device handle for the current context

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cudaGetDevice`
    """
    cdef CUdevice device = CUdevice()
    with nogil:
        err = cydriver.cuCtxGetDevice(<cydriver.CUdevice*>device._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], device)
{{endif}}

{{if 'cuCtxGetDevice_v2' in found_functions}}

@cython.embedsignature(True)
def cuCtxGetDevice_v2(ctx):
    """ Returns the device handle for the specified context.

    Returns in `*device` the handle of the specified context's device. If
    the specified context is NULL, the API will return the current
    context's device.

    Parameters
    ----------
    ctx : :py:obj:`~.CUcontext`
        Context for which to obtain the device

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    device : :py:obj:`~.CUdevice`
        Returned device handle for the specified context

    See Also
    --------
    :py:obj:`~.cuCtxGetCurrent`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`
    """
    cdef cydriver.CUcontext cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (CUcontext,)):
        pctx = int(ctx)
    else:
        pctx = int(CUcontext(ctx))
    cyctx = <cydriver.CUcontext><void_ptr>pctx
    cdef CUdevice device = CUdevice()
    with nogil:
        err = cydriver.cuCtxGetDevice_v2(<cydriver.CUdevice*>device._pvt_ptr, cyctx)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], device)
{{endif}}

{{if 'cuCtxGetFlags' in found_functions}}

@cython.embedsignature(True)
def cuCtxGetFlags():
    """ Returns the flags for the current context.

    Returns in `*flags` the flags of the current context. See
    :py:obj:`~.cuCtxCreate` for flag values.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    flags : unsigned int
        Pointer to store flags of current context

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetCurrent`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxGetSharedMemConfig`, :py:obj:`~.cuCtxGetStreamPriorityRange`, :py:obj:`~.cuCtxSetFlags`, :py:obj:`~.cudaGetDeviceFlags`
    """
    cdef unsigned int flags = 0
    with nogil:
        err = cydriver.cuCtxGetFlags(&flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], flags)
{{endif}}

{{if 'cuCtxSetFlags' in found_functions}}

@cython.embedsignature(True)
def cuCtxSetFlags(unsigned int flags):
    """ Sets the flags for the current context.

    Sets the flags for the current context overwriting previously set ones.
    See :py:obj:`~.cuDevicePrimaryCtxSetFlags` for flag values.

    Parameters
    ----------
    flags : unsigned int
        Flags to set on the current context

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetCurrent`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxGetSharedMemConfig`, :py:obj:`~.cuCtxGetStreamPriorityRange`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cudaGetDeviceFlags`, :py:obj:`~.cuDevicePrimaryCtxSetFlags`,
    """
    with nogil:
        err = cydriver.cuCtxSetFlags(flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCtxGetId' in found_functions}}

@cython.embedsignature(True)
def cuCtxGetId(ctx):
    """ Returns the unique Id associated with the context supplied.

    Returns in `ctxId` the unique Id which is associated with a given
    context. The Id is unique for the life of the program for this instance
    of CUDA. If context is supplied as NULL and there is one current, the
    Id of the current context is returned.

    Parameters
    ----------
    ctx : :py:obj:`~.CUcontext`
        Context for which to obtain the Id

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    ctxId : unsigned long long
        Pointer to store the Id of the context

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPushCurrent`
    """
    cdef cydriver.CUcontext cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (CUcontext,)):
        pctx = int(ctx)
    else:
        pctx = int(CUcontext(ctx))
    cyctx = <cydriver.CUcontext><void_ptr>pctx
    cdef unsigned long long ctxId = 0
    with nogil:
        err = cydriver.cuCtxGetId(cyctx, &ctxId)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], ctxId)
{{endif}}

{{if 'cuCtxSynchronize' in found_functions}}

@cython.embedsignature(True)
def cuCtxSynchronize():
    """ Block for the current context's tasks to complete.

    Blocks until the current context has completed all preceding requested
    tasks. If the current context is the primary context, green contexts
    that have been created will also be synchronized.
    :py:obj:`~.cuCtxSynchronize()` returns an error if one of the preceding
    tasks failed. If the context was created with the
    :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC` flag, the CPU thread will block
    until the GPU context has finished its work.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cudaDeviceSynchronize`
    """
    with nogil:
        err = cydriver.cuCtxSynchronize()
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCtxSynchronize_v2' in found_functions}}

@cython.embedsignature(True)
def cuCtxSynchronize_v2(ctx):
    """ Block for the specified context's tasks to complete.

    Blocks until the specified context has completed all preceding
    requested tasks. If the specified context is the primary context, green
    contexts that have been created will also be synchronized. The API
    returns an error if one of the preceding tasks failed.

    If the context was created with the
    :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC` flag, the CPU thread will block
    until the GPU context has finished its work.

    If the specified context is NULL, the API will operate on the current
    context.

    Parameters
    ----------
    ctx : :py:obj:`~.CUcontext`
        Context to synchronize

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuCtxGetCurrent`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuGreenCtxCreate`, :py:obj:`~.cuCtxFromGreenCtx`, :py:obj:`~.cudaDeviceSynchronize`
    """
    cdef cydriver.CUcontext cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (CUcontext,)):
        pctx = int(ctx)
    else:
        pctx = int(CUcontext(ctx))
    cyctx = <cydriver.CUcontext><void_ptr>pctx
    with nogil:
        err = cydriver.cuCtxSynchronize_v2(cyctx)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCtxSetLimit' in found_functions}}

@cython.embedsignature(True)
def cuCtxSetLimit(limit not None : CUlimit, size_t value):
    """ Set resource limits.

    Setting `limit` to `value` is a request by the application to update
    the current limit maintained by the context. The driver is free to
    modify the requested value to meet h/w requirements (this could be
    clamping to minimum or maximum values, rounding up to nearest element
    size, etc). The application can use :py:obj:`~.cuCtxGetLimit()` to find
    out exactly what the limit has been set to.

    Setting each :py:obj:`~.CUlimit` has its own specific restrictions, so
    each is discussed here.

    - :py:obj:`~.CU_LIMIT_STACK_SIZE` controls the stack size in bytes of
      each GPU thread. The driver automatically increases the per-thread
      stack size for each kernel launch as needed. This size isn't reset
      back to the original value after each launch. Setting this value will
      take effect immediately, and if necessary, the device will block
      until all preceding requested tasks are complete.

    - :py:obj:`~.CU_LIMIT_PRINTF_FIFO_SIZE` controls the size in bytes of
      the FIFO used by the :py:obj:`~.printf()` device system call. Setting
      :py:obj:`~.CU_LIMIT_PRINTF_FIFO_SIZE` must be performed before
      launching any kernel that uses the :py:obj:`~.printf()` device system
      call, otherwise :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be
      returned.

    - :py:obj:`~.CU_LIMIT_MALLOC_HEAP_SIZE` controls the size in bytes of
      the heap used by the :py:obj:`~.malloc()` and :py:obj:`~.free()`
      device system calls. Setting :py:obj:`~.CU_LIMIT_MALLOC_HEAP_SIZE`
      must be performed before launching any kernel that uses the
      :py:obj:`~.malloc()` or :py:obj:`~.free()` device system calls,
      otherwise :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned.

    - :py:obj:`~.CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH` controls the maximum
      nesting depth of a grid at which a thread can safely call
      :py:obj:`~.cudaDeviceSynchronize()`. Setting this limit must be
      performed before any launch of a kernel that uses the device runtime
      and calls :py:obj:`~.cudaDeviceSynchronize()` above the default sync
      depth, two levels of grids. Calls to
      :py:obj:`~.cudaDeviceSynchronize()` will fail with error code
      :py:obj:`~.cudaErrorSyncDepthExceeded` if the limitation is violated.
      This limit can be set smaller than the default or up the maximum
      launch depth of 24. When setting this limit, keep in mind that
      additional levels of sync depth require the driver to reserve large
      amounts of device memory which can no longer be used for user
      allocations. If these reservations of device memory fail,
      :py:obj:`~.cuCtxSetLimit()` will return
      :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, and the limit can be reset to a
      lower value. This limit is only applicable to devices of compute
      capability < 9.0. Attempting to set this limit on devices of other
      compute capability versions will result in the error
      :py:obj:`~.CUDA_ERROR_UNSUPPORTED_LIMIT` being returned.

    - :py:obj:`~.CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT` controls the
      maximum number of outstanding device runtime launches that can be
      made from the current context. A grid is outstanding from the point
      of launch up until the grid is known to have been completed. Device
      runtime launches which violate this limitation fail and return
      :py:obj:`~.cudaErrorLaunchPendingCountExceeded` when
      :py:obj:`~.cudaGetLastError()` is called after launch. If more
      pending launches than the default (2048 launches) are needed for a
      module using the device runtime, this limit can be increased. Keep in
      mind that being able to sustain additional pending launches will
      require the driver to reserve larger amounts of device memory upfront
      which can no longer be used for allocations. If these reservations
      fail, :py:obj:`~.cuCtxSetLimit()` will return
      :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, and the limit can be reset to a
      lower value. This limit is only applicable to devices of compute
      capability 3.5 and higher. Attempting to set this limit on devices of
      compute capability less than 3.5 will result in the error
      :py:obj:`~.CUDA_ERROR_UNSUPPORTED_LIMIT` being returned.

    - :py:obj:`~.CU_LIMIT_MAX_L2_FETCH_GRANULARITY` controls the L2 cache
      fetch granularity. Values can range from 0B to 128B. This is purely a
      performance hint and it can be ignored or clamped depending on the
      platform.

    - :py:obj:`~.CU_LIMIT_PERSISTING_L2_CACHE_SIZE` controls size in bytes
      available for persisting L2 cache. This is purely a performance hint
      and it can be ignored or clamped depending on the platform.

    Parameters
    ----------
    limit : :py:obj:`~.CUlimit`
        Limit to set
    value : size_t
        Size of limit

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_LIMIT`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cudaDeviceSetLimit`
    """
    cdef cydriver.CUlimit cylimit = limit.value
    with nogil:
        err = cydriver.cuCtxSetLimit(cylimit, value)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCtxGetLimit' in found_functions}}

@cython.embedsignature(True)
def cuCtxGetLimit(limit not None : CUlimit):
    """ Returns resource limits.

    Returns in `*pvalue` the current size of `limit`. The supported
    :py:obj:`~.CUlimit` values are:

    - :py:obj:`~.CU_LIMIT_STACK_SIZE`: stack size in bytes of each GPU
      thread.

    - :py:obj:`~.CU_LIMIT_PRINTF_FIFO_SIZE`: size in bytes of the FIFO used
      by the :py:obj:`~.printf()` device system call.

    - :py:obj:`~.CU_LIMIT_MALLOC_HEAP_SIZE`: size in bytes of the heap used
      by the :py:obj:`~.malloc()` and :py:obj:`~.free()` device system
      calls.

    - :py:obj:`~.CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH`: maximum grid depth at
      which a thread can issue the device runtime call
      :py:obj:`~.cudaDeviceSynchronize()` to wait on child grid launches to
      complete.

    - :py:obj:`~.CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT`: maximum number
      of outstanding device runtime launches that can be made from this
      context.

    - :py:obj:`~.CU_LIMIT_MAX_L2_FETCH_GRANULARITY`: L2 cache fetch
      granularity.

    - :py:obj:`~.CU_LIMIT_PERSISTING_L2_CACHE_SIZE`: Persisting L2 cache
      size in bytes

    Parameters
    ----------
    limit : :py:obj:`~.CUlimit`
        Limit to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_LIMIT`
    pvalue : int
        Returned size of limit

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cudaDeviceGetLimit`
    """
    cdef size_t pvalue = 0
    cdef cydriver.CUlimit cylimit = limit.value
    with nogil:
        err = cydriver.cuCtxGetLimit(&pvalue, cylimit)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pvalue)
{{endif}}

{{if 'cuCtxGetCacheConfig' in found_functions}}

@cython.embedsignature(True)
def cuCtxGetCacheConfig():
    """ Returns the preferred cache configuration for the current context.

    On devices where the L1 cache and shared memory use the same hardware
    resources, this function returns through `pconfig` the preferred cache
    configuration for the current context. This is only a preference. The
    driver will use the requested configuration if possible, but it is free
    to choose a different configuration if required to execute functions.

    This will return a `pconfig` of :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE`
    on devices where the size of the L1 cache and shared memory are fixed.

    The supported cache configurations are:

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE`: no preference for shared
      memory or L1 (default)

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_SHARED`: prefer larger shared memory
      and smaller L1 cache

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_L1`: prefer larger L1 cache and
      smaller shared memory

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_EQUAL`: prefer equal sized L1 cache
      and shared memory

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pconfig : :py:obj:`~.CUfunc_cache`
        Returned cache configuration

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cudaDeviceGetCacheConfig`
    """
    cdef cydriver.CUfunc_cache pconfig
    with nogil:
        err = cydriver.cuCtxGetCacheConfig(&pconfig)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], CUfunc_cache(pconfig))
{{endif}}

{{if 'cuCtxSetCacheConfig' in found_functions}}

@cython.embedsignature(True)
def cuCtxSetCacheConfig(config not None : CUfunc_cache):
    """ Sets the preferred cache configuration for the current context.

    On devices where the L1 cache and shared memory use the same hardware
    resources, this sets through `config` the preferred cache configuration
    for the current context. This is only a preference. The driver will use
    the requested configuration if possible, but it is free to choose a
    different configuration if required to execute the function. Any
    function preference set via :py:obj:`~.cuFuncSetCacheConfig()` or
    :py:obj:`~.cuKernelSetCacheConfig()` will be preferred over this
    context-wide setting. Setting the context-wide cache configuration to
    :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE` will cause subsequent kernel
    launches to prefer to not change the cache configuration unless
    required to launch the kernel.

    This setting does nothing on devices where the size of the L1 cache and
    shared memory are fixed.

    Launching a kernel with a different preference than the most recent
    preference setting may insert a device-side synchronization point.

    The supported cache configurations are:

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE`: no preference for shared
      memory or L1 (default)

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_SHARED`: prefer larger shared memory
      and smaller L1 cache

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_L1`: prefer larger L1 cache and
      smaller shared memory

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_EQUAL`: prefer equal sized L1 cache
      and shared memory

    Parameters
    ----------
    config : :py:obj:`~.CUfunc_cache`
        Requested cache configuration

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cudaDeviceSetCacheConfig`, :py:obj:`~.cuKernelSetCacheConfig`
    """
    cdef cydriver.CUfunc_cache cyconfig = config.value
    with nogil:
        err = cydriver.cuCtxSetCacheConfig(cyconfig)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCtxGetApiVersion' in found_functions}}

@cython.embedsignature(True)
def cuCtxGetApiVersion(ctx):
    """ Gets the context's API version.

    Returns a version number in `version` corresponding to the capabilities
    of the context (e.g. 3010 or 3020), which library developers can use to
    direct callers to a specific API version. If `ctx` is NULL, returns the
    API version used to create the currently bound context.

    Note that new API versions are only introduced when context
    capabilities are changed that break binary compatibility, so the API
    version and driver version may be different. For example, it is valid
    for the API version to be 3020 while the driver version is 4020.

    Parameters
    ----------
    ctx : :py:obj:`~.CUcontext`
        Context to check

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    version : unsigned int
        Pointer to version

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """
    cdef cydriver.CUcontext cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (CUcontext,)):
        pctx = int(ctx)
    else:
        pctx = int(CUcontext(ctx))
    cyctx = <cydriver.CUcontext><void_ptr>pctx
    cdef unsigned int version = 0
    with nogil:
        err = cydriver.cuCtxGetApiVersion(cyctx, &version)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], version)
{{endif}}

{{if 'cuCtxGetStreamPriorityRange' in found_functions}}

@cython.embedsignature(True)
def cuCtxGetStreamPriorityRange():
    """ Returns numerical values that correspond to the least and greatest stream priorities.

    Returns in `*leastPriority` and `*greatestPriority` the numerical
    values that correspond to the least and greatest stream priorities
    respectively. Stream priorities follow a convention where lower numbers
    imply greater priorities. The range of meaningful stream priorities is
    given by [`*greatestPriority`, `*leastPriority`]. If the user attempts
    to create a stream with a priority value that is outside the meaningful
    range as specified by this API, the priority is automatically clamped
    down or up to either `*leastPriority` or `*greatestPriority`
    respectively. See :py:obj:`~.cuStreamCreateWithPriority` for details on
    creating a priority stream. A NULL may be passed in for
    `*leastPriority` or `*greatestPriority` if the value is not desired.

    This function will return '0' in both `*leastPriority` and
    `*greatestPriority` if the current context's device does not support
    stream priorities (see :py:obj:`~.cuDeviceGetAttribute`).

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    leastPriority : int
        Pointer to an int in which the numerical value for least stream
        priority is returned
    greatestPriority : int
        Pointer to an int in which the numerical value for greatest stream
        priority is returned

    See Also
    --------
    :py:obj:`~.cuStreamCreateWithPriority`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cudaDeviceGetStreamPriorityRange`
    """
    cdef int leastPriority = 0
    cdef int greatestPriority = 0
    with nogil:
        err = cydriver.cuCtxGetStreamPriorityRange(&leastPriority, &greatestPriority)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], leastPriority, greatestPriority)
{{endif}}

{{if 'cuCtxResetPersistingL2Cache' in found_functions}}

@cython.embedsignature(True)
def cuCtxResetPersistingL2Cache():
    """ Resets all persisting lines in cache to normal status.

    :py:obj:`~.cuCtxResetPersistingL2Cache` Resets all persisting lines in
    cache to normal status. Takes effect on function return.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.CUaccessPolicyWindow`
    """
    with nogil:
        err = cydriver.cuCtxResetPersistingL2Cache()
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCtxGetExecAffinity' in found_functions}}

@cython.embedsignature(True)
def cuCtxGetExecAffinity(typename not None : CUexecAffinityType):
    """ Returns the execution affinity setting for the current context.

    Returns in `*pExecAffinity` the current value of `typename`. The
    supported :py:obj:`~.CUexecAffinityType` values are:

    - :py:obj:`~.CU_EXEC_AFFINITY_TYPE_SM_COUNT`: number of SMs the context
      is limited to use.

    Parameters
    ----------
    typename : :py:obj:`~.CUexecAffinityType`
        Execution affinity type to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY`
    pExecAffinity : :py:obj:`~.CUexecAffinityParam`
        Returned execution affinity

    See Also
    --------
    :py:obj:`~.CUexecAffinityParam`
    """
    cdef CUexecAffinityParam pExecAffinity = CUexecAffinityParam()
    cdef cydriver.CUexecAffinityType cytypename = typename.value
    with nogil:
        err = cydriver.cuCtxGetExecAffinity(<cydriver.CUexecAffinityParam*>pExecAffinity._pvt_ptr, cytypename)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pExecAffinity)
{{endif}}

{{if 'cuCtxRecordEvent' in found_functions}}

@cython.embedsignature(True)
def cuCtxRecordEvent(hCtx, hEvent):
    """ Records an event.

    Captures in `hEvent` all the activities of the context `hCtx` at the
    time of this call. `hEvent` and `hCtx` must be from the same CUDA
    context, otherwise :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` will be
    returned. Calls such as :py:obj:`~.cuEventQuery()` or
    :py:obj:`~.cuCtxWaitEvent()` will then examine or wait for completion
    of the work that was captured. Uses of `hCtx` after this call do not
    modify `hEvent`. If the context passed to `hCtx` is the primary
    context, `hEvent` will capture all the activities of the primary
    context and its green contexts. If the context passed to `hCtx` is a
    context converted from green context via
    :py:obj:`~.cuCtxFromGreenCtx()`, `hEvent` will capture only the
    activities of the green context.

    Parameters
    ----------
    hCtx : :py:obj:`~.CUcontext`
        Context to record event for
    hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to record

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED`

    See Also
    --------
    :py:obj:`~.cuCtxWaitEvent`, :py:obj:`~.cuGreenCtxRecordEvent`, :py:obj:`~.cuGreenCtxWaitEvent`, :py:obj:`~.cuEventRecord`

    Notes
    -----
    The API will return :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED` if the specified context `hCtx` has a stream in the capture mode. In such a case, the call will invalidate all the conflicting captures.
    """
    cdef cydriver.CUevent cyhEvent
    if hEvent is None:
        phEvent = 0
    elif isinstance(hEvent, (CUevent,)):
        phEvent = int(hEvent)
    else:
        phEvent = int(CUevent(hEvent))
    cyhEvent = <cydriver.CUevent><void_ptr>phEvent
    cdef cydriver.CUcontext cyhCtx
    if hCtx is None:
        phCtx = 0
    elif isinstance(hCtx, (CUcontext,)):
        phCtx = int(hCtx)
    else:
        phCtx = int(CUcontext(hCtx))
    cyhCtx = <cydriver.CUcontext><void_ptr>phCtx
    with nogil:
        err = cydriver.cuCtxRecordEvent(cyhCtx, cyhEvent)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCtxWaitEvent' in found_functions}}

@cython.embedsignature(True)
def cuCtxWaitEvent(hCtx, hEvent):
    """ Make a context wait on an event.

    Makes all future work submitted to context `hCtx` wait for all work
    captured in `hEvent`. The synchronization will be performed on the
    device and will not block the calling CPU thread. See
    :py:obj:`~.cuCtxRecordEvent()` for details on what is captured by an
    event. If the context passed to `hCtx` is the primary context, the
    primary context and its green contexts will wait for `hEvent`. If the
    context passed to `hCtx` is a context converted from green context via
    :py:obj:`~.cuCtxFromGreenCtx()`, the green context will wait for
    `hEvent`.

    Parameters
    ----------
    hCtx : :py:obj:`~.CUcontext`
        Context to wait
    hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to wait on

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED`

    See Also
    --------
    :py:obj:`~.cuCtxRecordEvent`, :py:obj:`~.cuGreenCtxRecordEvent`, :py:obj:`~.cuGreenCtxWaitEvent`, :py:obj:`~.cuStreamWaitEvent`

    Notes
    -----
    `hEvent` may be from a different context or device than `hCtx`.

    The API will return :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED` and invalidate the capture if the specified event `hEvent` is part of an ongoing capture sequence or if the specified context `hCtx` has a stream in the capture mode.
    """
    cdef cydriver.CUevent cyhEvent
    if hEvent is None:
        phEvent = 0
    elif isinstance(hEvent, (CUevent,)):
        phEvent = int(hEvent)
    else:
        phEvent = int(CUevent(hEvent))
    cyhEvent = <cydriver.CUevent><void_ptr>phEvent
    cdef cydriver.CUcontext cyhCtx
    if hCtx is None:
        phCtx = 0
    elif isinstance(hCtx, (CUcontext,)):
        phCtx = int(hCtx)
    else:
        phCtx = int(CUcontext(hCtx))
    cyhCtx = <cydriver.CUcontext><void_ptr>phCtx
    with nogil:
        err = cydriver.cuCtxWaitEvent(cyhCtx, cyhEvent)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCtxAttach' in found_functions}}

@cython.embedsignature(True)
def cuCtxAttach(unsigned int flags):
    """ Increment a context's usage-count.

    [Deprecated]

    Note that this function is deprecated and should not be used.

    Increments the usage count of the context and passes back a context
    handle in `*pctx` that must be passed to :py:obj:`~.cuCtxDetach()` when
    the application is done with the context. :py:obj:`~.cuCtxAttach()`
    fails if there is no context current to the thread.

    Currently, the `flags` parameter must be 0.

    Parameters
    ----------
    flags : unsigned int
        Context attach flags (must be 0)

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pctx : :py:obj:`~.CUcontext`
        Returned context handle of the current context

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxDetach`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """
    cdef CUcontext pctx = CUcontext()
    with nogil:
        err = cydriver.cuCtxAttach(<cydriver.CUcontext*>pctx._pvt_ptr, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pctx)
{{endif}}

{{if 'cuCtxDetach' in found_functions}}

@cython.embedsignature(True)
def cuCtxDetach(ctx):
    """ Decrement a context's usage-count.

    [Deprecated]

    Note that this function is deprecated and should not be used.

    Decrements the usage count of the context `ctx`, and destroys the
    context if the usage count goes to 0. The context must be a handle that
    was passed back by :py:obj:`~.cuCtxCreate()` or
    :py:obj:`~.cuCtxAttach()`, and must be current to the calling thread.

    Parameters
    ----------
    ctx : :py:obj:`~.CUcontext`
        Context to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """
    cdef cydriver.CUcontext cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (CUcontext,)):
        pctx = int(ctx)
    else:
        pctx = int(CUcontext(ctx))
    cyctx = <cydriver.CUcontext><void_ptr>pctx
    with nogil:
        err = cydriver.cuCtxDetach(cyctx)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCtxGetSharedMemConfig' in found_functions}}

@cython.embedsignature(True)
def cuCtxGetSharedMemConfig():
    """ Returns the current shared memory configuration for the current context.

    [Deprecated]

    This function will return in `pConfig` the current size of shared
    memory banks in the current context. On devices with configurable
    shared memory banks, :py:obj:`~.cuCtxSetSharedMemConfig` can be used to
    change this setting, so that all subsequent kernel launches will by
    default use the new bank size. When :py:obj:`~.cuCtxGetSharedMemConfig`
    is called on devices without configurable shared memory, it will return
    the fixed bank size of the hardware.

    The returned bank configurations can be either:

    - :py:obj:`~.CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE`: shared memory
      bank width is four bytes.

    - :py:obj:`~.CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE`: shared memory
      bank width will eight bytes.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pConfig : :py:obj:`~.CUsharedconfig`
        returned shared memory configuration

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cuCtxGetSharedMemConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cudaDeviceGetSharedMemConfig`
    """
    cdef cydriver.CUsharedconfig pConfig
    with nogil:
        err = cydriver.cuCtxGetSharedMemConfig(&pConfig)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], CUsharedconfig(pConfig))
{{endif}}

{{if 'cuCtxSetSharedMemConfig' in found_functions}}

@cython.embedsignature(True)
def cuCtxSetSharedMemConfig(config not None : CUsharedconfig):
    """ Sets the shared memory configuration for the current context.

    [Deprecated]

    On devices with configurable shared memory banks, this function will
    set the context's shared memory bank size which is used for subsequent
    kernel launches.

    Changed the shared memory configuration between launches may insert a
    device side synchronization point between those launches.

    Changing the shared memory bank size will not increase shared memory
    usage or affect occupancy of kernels, but may have major effects on
    performance. Larger bank sizes will allow for greater potential
    bandwidth to shared memory, but will change what kinds of accesses to
    shared memory will result in bank conflicts.

    This function will do nothing on devices with fixed shared memory bank
    size.

    The supported bank configurations are:

    - :py:obj:`~.CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE`: set bank width to
      the default initial setting (currently, four bytes).

    - :py:obj:`~.CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE`: set shared
      memory bank width to be natively four bytes.

    - :py:obj:`~.CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE`: set shared
      memory bank width to be natively eight bytes.

    Parameters
    ----------
    config : :py:obj:`~.CUsharedconfig`
        requested shared memory configuration

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cuCtxGetSharedMemConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cudaDeviceSetSharedMemConfig`
    """
    cdef cydriver.CUsharedconfig cyconfig = config.value
    with nogil:
        err = cydriver.cuCtxSetSharedMemConfig(cyconfig)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuModuleLoad' in found_functions}}

@cython.embedsignature(True)
def cuModuleLoad(char* fname):
    """ Loads a compute module.

    Takes a filename `fname` and loads the corresponding module `module`
    into the current context. The CUDA driver API does not attempt to
    lazily allocate the resources needed by a module; if the memory for
    functions and data (constant and global) needed by the module cannot be
    allocated, :py:obj:`~.cuModuleLoad()` fails. The file should be a
    `cubin` file as output by nvcc, or a `PTX` file either as output by
    nvcc or handwritten, or a `fatbin` file as output by nvcc from
    toolchain 4.0 or later.

    Parameters
    ----------
    fname : bytes
        Filename of module to load

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_FILE_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`
    module : :py:obj:`~.CUmodule`
        Returned module

    See Also
    --------
    :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`
    """
    cdef CUmodule module = CUmodule()
    with nogil:
        err = cydriver.cuModuleLoad(<cydriver.CUmodule*>module._pvt_ptr, fname)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], module)
{{endif}}

{{if 'cuModuleLoadData' in found_functions}}

@cython.embedsignature(True)
def cuModuleLoadData(image):
    """ Load a module's data.

    Takes a pointer `image` and loads the corresponding module `module`
    into the current context. The `image` may be a `cubin` or `fatbin` as
    output by nvcc, or a NULL-terminated `PTX`, either as output by nvcc or
    hand-written.

    Parameters
    ----------
    image : Any
        Module data to load

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`
    module : :py:obj:`~.CUmodule`
        Returned module

    See Also
    --------
    :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`
    """
    cdef CUmodule module = CUmodule()
    cyimage = _HelperInputVoidPtr(image)
    cdef void* cyimage_ptr = <void*><void_ptr>cyimage.cptr
    with nogil:
        err = cydriver.cuModuleLoadData(<cydriver.CUmodule*>module._pvt_ptr, cyimage_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], module)
{{endif}}

{{if 'cuModuleLoadDataEx' in found_functions}}

@cython.embedsignature(True)
def cuModuleLoadDataEx(image, unsigned int numOptions, options : Optional[tuple[CUjit_option] | list[CUjit_option]], optionValues : Optional[tuple[Any] | list[Any]]):
    """ Load a module's data with options.

    Takes a pointer `image` and loads the corresponding module `module`
    into the current context. The `image` may be a `cubin` or `fatbin` as
    output by nvcc, or a NULL-terminated `PTX`, either as output by nvcc or
    hand-written.

    Parameters
    ----------
    image : Any
        Module data to load
    numOptions : unsigned int
        Number of options
    options : list[:py:obj:`~.CUjit_option`]
        Options for JIT
    optionValues : list[Any]
        Option values for JIT

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`
    module : :py:obj:`~.CUmodule`
        Returned module

    See Also
    --------
    :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`
    """
    optionValues = [] if optionValues is None else optionValues
    options = [] if options is None else options
    if not all(isinstance(_x, (CUjit_option)) for _x in options):
        raise TypeError("Argument 'options' is not instance of type (expected tuple[cydriver.CUjit_option] or list[cydriver.CUjit_option]")
    cdef CUmodule module = CUmodule()
    cyimage = _HelperInputVoidPtr(image)
    cdef void* cyimage_ptr = <void*><void_ptr>cyimage.cptr
    if numOptions > len(options): raise RuntimeError("List is too small: " + str(len(options)) + " < " + str(numOptions))
    if numOptions > len(optionValues): raise RuntimeError("List is too small: " + str(len(optionValues)) + " < " + str(numOptions))
    cdef vector[cydriver.CUjit_option] cyoptions = [pyoptions.value for pyoptions in (options)]
    pylist = [_HelperCUjit_option(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(options, optionValues)]
    cdef _InputVoidPtrPtrHelper voidStarHelperoptionValues = _InputVoidPtrPtrHelper(pylist)
    cdef void** cyoptionValues_ptr = <void**><void_ptr>voidStarHelperoptionValues.cptr
    with nogil:
        err = cydriver.cuModuleLoadDataEx(<cydriver.CUmodule*>module._pvt_ptr, cyimage_ptr, numOptions, cyoptions.data(), cyoptionValues_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], module)
{{endif}}

{{if 'cuModuleLoadFatBinary' in found_functions}}

@cython.embedsignature(True)
def cuModuleLoadFatBinary(fatCubin):
    """ Load a module's data.

    Takes a pointer `fatCubin` and loads the corresponding module `module`
    into the current context. The pointer represents a `fat binary` object,
    which is a collection of different `cubin` and/or `PTX` files, all
    representing the same device code, but compiled and optimized for
    different architectures.

    Prior to CUDA 4.0, there was no documented API for constructing and
    using fat binary objects by programmers. Starting with CUDA 4.0, fat
    binary objects can be constructed by providing the `-fatbin option` to
    nvcc. More information can be found in the nvcc document.

    Parameters
    ----------
    fatCubin : Any
        Fat binary to load

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`
    module : :py:obj:`~.CUmodule`
        Returned module

    See Also
    --------
    :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleUnload`
    """
    cdef CUmodule module = CUmodule()
    cyfatCubin = _HelperInputVoidPtr(fatCubin)
    cdef void* cyfatCubin_ptr = <void*><void_ptr>cyfatCubin.cptr
    with nogil:
        err = cydriver.cuModuleLoadFatBinary(<cydriver.CUmodule*>module._pvt_ptr, cyfatCubin_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], module)
{{endif}}

{{if 'cuModuleUnload' in found_functions}}

@cython.embedsignature(True)
def cuModuleUnload(hmod):
    """ Unloads a module.

    Unloads a module `hmod` from the current context. Attempting to unload
    a module which was obtained from the Library Management API such as
    :py:obj:`~.cuLibraryGetModule` will return
    :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`.

    Parameters
    ----------
    hmod : :py:obj:`~.CUmodule`
        Module to unload

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`

    See Also
    --------
    :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`
    """
    cdef cydriver.CUmodule cyhmod
    if hmod is None:
        phmod = 0
    elif isinstance(hmod, (CUmodule,)):
        phmod = int(hmod)
    else:
        phmod = int(CUmodule(hmod))
    cyhmod = <cydriver.CUmodule><void_ptr>phmod
    with nogil:
        err = cydriver.cuModuleUnload(cyhmod)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuModuleGetLoadingMode' in found_functions}}

@cython.embedsignature(True)
def cuModuleGetLoadingMode():
    """ Query lazy loading mode.

    Returns lazy loading mode Module loading mode is controlled by
    CUDA_MODULE_LOADING env variable

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    mode : :py:obj:`~.CUmoduleLoadingMode`
        Returns the lazy loading mode

    See Also
    --------
    :py:obj:`~.cuModuleLoad`,
    """
    cdef cydriver.CUmoduleLoadingMode mode
    with nogil:
        err = cydriver.cuModuleGetLoadingMode(&mode)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], CUmoduleLoadingMode(mode))
{{endif}}

{{if 'cuModuleGetFunction' in found_functions}}

@cython.embedsignature(True)
def cuModuleGetFunction(hmod, char* name):
    """ Returns a function handle.

    Returns in `*hfunc` the handle of the function of name `name` located
    in module `hmod`. If no function of that name exists,
    :py:obj:`~.cuModuleGetFunction()` returns
    :py:obj:`~.CUDA_ERROR_NOT_FOUND`.

    Parameters
    ----------
    hmod : :py:obj:`~.CUmodule`
        Module to retrieve function from
    name : bytes
        Name of function to retrieve

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
    hfunc : :py:obj:`~.CUfunction`
        Returned function handle

    See Also
    --------
    :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`
    """
    cdef cydriver.CUmodule cyhmod
    if hmod is None:
        phmod = 0
    elif isinstance(hmod, (CUmodule,)):
        phmod = int(hmod)
    else:
        phmod = int(CUmodule(hmod))
    cyhmod = <cydriver.CUmodule><void_ptr>phmod
    cdef CUfunction hfunc = CUfunction()
    with nogil:
        err = cydriver.cuModuleGetFunction(<cydriver.CUfunction*>hfunc._pvt_ptr, cyhmod, name)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], hfunc)
{{endif}}

{{if 'cuModuleGetFunctionCount' in found_functions}}

@cython.embedsignature(True)
def cuModuleGetFunctionCount(mod):
    """ Returns the number of functions within a module.

    Returns in `count` the number of functions in `mod`.

    Parameters
    ----------
    mod : :py:obj:`~.CUmodule`
        Module to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    count : unsigned int
        Number of functions found within the module
    """
    cdef cydriver.CUmodule cymod
    if mod is None:
        pmod = 0
    elif isinstance(mod, (CUmodule,)):
        pmod = int(mod)
    else:
        pmod = int(CUmodule(mod))
    cymod = <cydriver.CUmodule><void_ptr>pmod
    cdef unsigned int count = 0
    with nogil:
        err = cydriver.cuModuleGetFunctionCount(&count, cymod)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], count)
{{endif}}

{{if 'cuModuleEnumerateFunctions' in found_functions}}

@cython.embedsignature(True)
def cuModuleEnumerateFunctions(unsigned int numFunctions, mod):
    """ Returns the function handles within a module.

    Returns in `functions` a maximum number of `numFunctions` function
    handles within `mod`. When function loading mode is set to LAZY the
    function retrieved may be partially loaded. The loading state of a
    function can be queried using :py:obj:`~.cuFunctionIsLoaded`. CUDA APIs
    may load the function automatically when called with partially loaded
    function handle which may incur additional latency. Alternatively,
    :py:obj:`~.cuFunctionLoad` can be used to explicitly load a function.
    The returned function handles become invalid when the module is
    unloaded.

    Parameters
    ----------
    numFunctions : unsigned int
        Maximum number of function handles may be returned to the buffer
    mod : :py:obj:`~.CUmodule`
        Module to query from

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    functions : list[:py:obj:`~.CUfunction`]
        Buffer where the function handles are returned to

    See Also
    --------
    :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetFunctionCount`, :py:obj:`~.cuFuncIsLoaded`, :py:obj:`~.cuFuncLoad`
    """
    cdef cydriver.CUmodule cymod
    if mod is None:
        pmod = 0
    elif isinstance(mod, (CUmodule,)):
        pmod = int(mod)
    else:
        pmod = int(CUmodule(mod))
    cymod = <cydriver.CUmodule><void_ptr>pmod
    cdef cydriver.CUfunction* cyfunctions = NULL
    pyfunctions = []
    if numFunctions != 0:
        cyfunctions = <cydriver.CUfunction*>calloc(numFunctions, sizeof(cydriver.CUfunction))
        if cyfunctions is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(numFunctions) + 'x' + str(sizeof(cydriver.CUfunction)))
    with nogil:
        err = cydriver.cuModuleEnumerateFunctions(cyfunctions, numFunctions, cymod)
    if CUresult(err) == CUresult(0):
        pyfunctions = [CUfunction(init_value=<void_ptr>cyfunctions[idx]) for idx in range(numFunctions)]
    if cyfunctions is not NULL:
        free(cyfunctions)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pyfunctions)
{{endif}}

{{if 'cuModuleGetGlobal_v2' in found_functions}}

@cython.embedsignature(True)
def cuModuleGetGlobal(hmod, char* name):
    """ Returns a global pointer from a module.

    Returns in `*dptr` and `*bytes` the base pointer and size of the global
    of name `name` located in module `hmod`. If no variable of that name
    exists, :py:obj:`~.cuModuleGetGlobal()` returns
    :py:obj:`~.CUDA_ERROR_NOT_FOUND`. One of the parameters `dptr` or
    `numbytes` (not both) can be NULL in which case it is ignored.

    Parameters
    ----------
    hmod : :py:obj:`~.CUmodule`
        Module to retrieve global from
    name : bytes
        Name of global to retrieve

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
    dptr : :py:obj:`~.CUdeviceptr`
        Returned global device pointer
    numbytes : int
        Returned global size in bytes

    See Also
    --------
    :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`, :py:obj:`~.cudaGetSymbolAddress`, :py:obj:`~.cudaGetSymbolSize`
    """
    cdef cydriver.CUmodule cyhmod
    if hmod is None:
        phmod = 0
    elif isinstance(hmod, (CUmodule,)):
        phmod = int(hmod)
    else:
        phmod = int(CUmodule(hmod))
    cyhmod = <cydriver.CUmodule><void_ptr>phmod
    cdef CUdeviceptr dptr = CUdeviceptr()
    cdef size_t numbytes = 0
    with nogil:
        err = cydriver.cuModuleGetGlobal(<cydriver.CUdeviceptr*>dptr._pvt_ptr, &numbytes, cyhmod, name)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], dptr, numbytes)
{{endif}}

{{if 'cuLinkCreate_v2' in found_functions}}

@cython.embedsignature(True)
def cuLinkCreate(unsigned int numOptions, options : Optional[tuple[CUjit_option] | list[CUjit_option]], optionValues : Optional[tuple[Any] | list[Any]]):
    """ Creates a pending JIT linker invocation.

    If the call is successful, the caller owns the returned CUlinkState,
    which should eventually be destroyed with :py:obj:`~.cuLinkDestroy`.
    The device code machine size (32 or 64 bit) will match the calling
    application.

    Both linker and compiler options may be specified. Compiler options
    will be applied to inputs to this linker action which must be compiled
    from PTX. The options :py:obj:`~.CU_JIT_WALL_TIME`,
    :py:obj:`~.CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES`, and
    :py:obj:`~.CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES` will accumulate data
    until the CUlinkState is destroyed.

    The data passed in via :py:obj:`~.cuLinkAddData` and
    :py:obj:`~.cuLinkAddFile` will be treated as relocatable (-rdc=true to
    nvcc) when linking the final cubin during :py:obj:`~.cuLinkComplete`
    and will have similar consequences as offline relocatable device code
    linking.

    `optionValues` must remain valid for the life of the CUlinkState if
    output options are used. No other references to inputs are maintained
    after this call returns.

    Parameters
    ----------
    numOptions : unsigned int
        Size of options arrays
    options : list[:py:obj:`~.CUjit_option`]
        Array of linker and compiler options
    optionValues : list[Any]
        Array of option values, each cast to void *

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`
    stateOut : :py:obj:`~.CUlinkState`
        On success, this will contain a CUlinkState to specify and complete
        this action

    See Also
    --------
    :py:obj:`~.cuLinkAddData`, :py:obj:`~.cuLinkAddFile`, :py:obj:`~.cuLinkComplete`, :py:obj:`~.cuLinkDestroy`

    Notes
    -----
    For LTO-IR input, only LTO-IR compiled with toolkits prior to CUDA 12.0 will be accepted
    """
    optionValues = [] if optionValues is None else optionValues
    options = [] if options is None else options
    if not all(isinstance(_x, (CUjit_option)) for _x in options):
        raise TypeError("Argument 'options' is not instance of type (expected tuple[cydriver.CUjit_option] or list[cydriver.CUjit_option]")
    if numOptions > len(options): raise RuntimeError("List is too small: " + str(len(options)) + " < " + str(numOptions))
    if numOptions > len(optionValues): raise RuntimeError("List is too small: " + str(len(optionValues)) + " < " + str(numOptions))
    cdef vector[cydriver.CUjit_option] cyoptions = [pyoptions.value for pyoptions in (options)]
    pylist = [_HelperCUjit_option(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(options, optionValues)]
    cdef _InputVoidPtrPtrHelper voidStarHelperoptionValues = _InputVoidPtrPtrHelper(pylist)
    cdef void** cyoptionValues_ptr = <void**><void_ptr>voidStarHelperoptionValues.cptr
    cdef CUlinkState stateOut = CUlinkState()
    with nogil:
        err = cydriver.cuLinkCreate(numOptions, cyoptions.data(), cyoptionValues_ptr, stateOut._pvt_ptr)
    stateOut._keepalive.append(voidStarHelperoptionValues)
    for option in pylist:
        stateOut._keepalive.append(option)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], stateOut)
{{endif}}

{{if 'cuLinkAddData_v2' in found_functions}}

@cython.embedsignature(True)
def cuLinkAddData(state, typename not None : CUjitInputType, data, size_t size, char* name, unsigned int numOptions, options : Optional[tuple[CUjit_option] | list[CUjit_option]], optionValues : Optional[tuple[Any] | list[Any]]):
    """ Add an input to a pending linker invocation.

    Ownership of `data` is retained by the caller. No reference is retained
    to any inputs after this call returns.

    This method accepts only compiler options, which are used if the data
    must be compiled from PTX, and does not accept any of
    :py:obj:`~.CU_JIT_WALL_TIME`, :py:obj:`~.CU_JIT_INFO_LOG_BUFFER`,
    :py:obj:`~.CU_JIT_ERROR_LOG_BUFFER`,
    :py:obj:`~.CU_JIT_TARGET_FROM_CUCONTEXT`, or :py:obj:`~.CU_JIT_TARGET`.

    Parameters
    ----------
    state : :py:obj:`~.CUlinkState`
        A pending linker action.
    typename : :py:obj:`~.CUjitInputType`
        The type of the input data.
    data : Any
        The input data. PTX must be NULL-terminated.
    size : size_t
        The length of the input data.
    name : bytes
        An optional name for this input in log messages.
    numOptions : unsigned int
        Size of options.
    options : list[:py:obj:`~.CUjit_option`]
        Options to be applied only for this input (overrides options from
        :py:obj:`~.cuLinkCreate`).
    optionValues : list[Any]
        Array of option values, each cast to void *.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`

    See Also
    --------
    :py:obj:`~.cuLinkCreate`, :py:obj:`~.cuLinkAddFile`, :py:obj:`~.cuLinkComplete`, :py:obj:`~.cuLinkDestroy`

    Notes
    -----
    For LTO-IR input, only LTO-IR compiled with toolkits prior to CUDA 12.0 will be accepted
    """
    optionValues = [] if optionValues is None else optionValues
    options = [] if options is None else options
    if not all(isinstance(_x, (CUjit_option)) for _x in options):
        raise TypeError("Argument 'options' is not instance of type (expected tuple[cydriver.CUjit_option] or list[cydriver.CUjit_option]")
    cdef cydriver.CUlinkState cystate
    if state is None:
        pstate = 0
    elif isinstance(state, (CUlinkState,)):
        pstate = int(state)
    else:
        pstate = int(CUlinkState(state))
    cystate = <cydriver.CUlinkState><void_ptr>pstate
    cdef cydriver.CUjitInputType cytypename = typename.value
    cydata = _HelperInputVoidPtr(data)
    cdef void* cydata_ptr = <void*><void_ptr>cydata.cptr
    if numOptions > len(options): raise RuntimeError("List is too small: " + str(len(options)) + " < " + str(numOptions))
    if numOptions > len(optionValues): raise RuntimeError("List is too small: " + str(len(optionValues)) + " < " + str(numOptions))
    cdef vector[cydriver.CUjit_option] cyoptions = [pyoptions.value for pyoptions in (options)]
    pylist = [_HelperCUjit_option(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(options, optionValues)]
    cdef _InputVoidPtrPtrHelper voidStarHelperoptionValues = _InputVoidPtrPtrHelper(pylist)
    cdef void** cyoptionValues_ptr = <void**><void_ptr>voidStarHelperoptionValues.cptr
    with nogil:
        err = cydriver.cuLinkAddData(cystate, cytypename, cydata_ptr, size, name, numOptions, cyoptions.data(), cyoptionValues_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuLinkAddFile_v2' in found_functions}}

@cython.embedsignature(True)
def cuLinkAddFile(state, typename not None : CUjitInputType, char* path, unsigned int numOptions, options : Optional[tuple[CUjit_option] | list[CUjit_option]], optionValues : Optional[tuple[Any] | list[Any]]):
    """ Add a file input to a pending linker invocation.

    No reference is retained to any inputs after this call returns.

    This method accepts only compiler options, which are used if the input
    must be compiled from PTX, and does not accept any of
    :py:obj:`~.CU_JIT_WALL_TIME`, :py:obj:`~.CU_JIT_INFO_LOG_BUFFER`,
    :py:obj:`~.CU_JIT_ERROR_LOG_BUFFER`,
    :py:obj:`~.CU_JIT_TARGET_FROM_CUCONTEXT`, or :py:obj:`~.CU_JIT_TARGET`.

    This method is equivalent to invoking :py:obj:`~.cuLinkAddData` on the
    contents of the file.

    Parameters
    ----------
    state : :py:obj:`~.CUlinkState`
        A pending linker action
    typename : :py:obj:`~.CUjitInputType`
        The type of the input data
    path : bytes
        Path to the input file
    numOptions : unsigned int
        Size of options
    options : list[:py:obj:`~.CUjit_option`]
        Options to be applied only for this input (overrides options from
        :py:obj:`~.cuLinkCreate`)
    optionValues : list[Any]
        Array of option values, each cast to void *

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_FILE_NOT_FOUND` :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`

    See Also
    --------
    :py:obj:`~.cuLinkCreate`, :py:obj:`~.cuLinkAddData`, :py:obj:`~.cuLinkComplete`, :py:obj:`~.cuLinkDestroy`

    Notes
    -----
    For LTO-IR input, only LTO-IR compiled with toolkits prior to CUDA 12.0 will be accepted
    """
    optionValues = [] if optionValues is None else optionValues
    options = [] if options is None else options
    if not all(isinstance(_x, (CUjit_option)) for _x in options):
        raise TypeError("Argument 'options' is not instance of type (expected tuple[cydriver.CUjit_option] or list[cydriver.CUjit_option]")
    cdef cydriver.CUlinkState cystate
    if state is None:
        pstate = 0
    elif isinstance(state, (CUlinkState,)):
        pstate = int(state)
    else:
        pstate = int(CUlinkState(state))
    cystate = <cydriver.CUlinkState><void_ptr>pstate
    cdef cydriver.CUjitInputType cytypename = typename.value
    if numOptions > len(options): raise RuntimeError("List is too small: " + str(len(options)) + " < " + str(numOptions))
    if numOptions > len(optionValues): raise RuntimeError("List is too small: " + str(len(optionValues)) + " < " + str(numOptions))
    cdef vector[cydriver.CUjit_option] cyoptions = [pyoptions.value for pyoptions in (options)]
    pylist = [_HelperCUjit_option(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(options, optionValues)]
    cdef _InputVoidPtrPtrHelper voidStarHelperoptionValues = _InputVoidPtrPtrHelper(pylist)
    cdef void** cyoptionValues_ptr = <void**><void_ptr>voidStarHelperoptionValues.cptr
    with nogil:
        err = cydriver.cuLinkAddFile(cystate, cytypename, path, numOptions, cyoptions.data(), cyoptionValues_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuLinkComplete' in found_functions}}

@cython.embedsignature(True)
def cuLinkComplete(state):
    """ Complete a pending linker invocation.

    Completes the pending linker action and returns the cubin image for the
    linked device code, which can be used with
    :py:obj:`~.cuModuleLoadData`. The cubin is owned by `state`, so it
    should be loaded before `state` is destroyed via
    :py:obj:`~.cuLinkDestroy`. This call does not destroy `state`.

    Parameters
    ----------
    state : :py:obj:`~.CUlinkState`
        A pending linker invocation

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    cubinOut : Any
        On success, this will point to the output image
    sizeOut : int
        Optional parameter to receive the size of the generated image

    See Also
    --------
    :py:obj:`~.cuLinkCreate`, :py:obj:`~.cuLinkAddData`, :py:obj:`~.cuLinkAddFile`, :py:obj:`~.cuLinkDestroy`, :py:obj:`~.cuModuleLoadData`
    """
    cdef cydriver.CUlinkState cystate
    if state is None:
        pstate = 0
    elif isinstance(state, (CUlinkState,)):
        pstate = int(state)
    else:
        pstate = int(CUlinkState(state))
    cystate = <cydriver.CUlinkState><void_ptr>pstate
    cdef void_ptr cubinOut = 0
    cdef size_t sizeOut = 0
    with nogil:
        err = cydriver.cuLinkComplete(cystate, <void**>&cubinOut, &sizeOut)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], cubinOut, sizeOut)
{{endif}}

{{if 'cuLinkDestroy' in found_functions}}

@cython.embedsignature(True)
def cuLinkDestroy(state):
    """ Destroys state for a JIT linker invocation.

    Parameters
    ----------
    state : :py:obj:`~.CUlinkState`
        State object for the linker invocation

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuLinkCreate`
    """
    cdef cydriver.CUlinkState cystate
    if state is None:
        pstate = 0
    elif isinstance(state, (CUlinkState,)):
        pstate = int(state)
    else:
        pstate = int(CUlinkState(state))
    cystate = <cydriver.CUlinkState><void_ptr>pstate
    with nogil:
        err = cydriver.cuLinkDestroy(cystate)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuModuleGetTexRef' in found_functions}}

@cython.embedsignature(True)
def cuModuleGetTexRef(hmod, char* name):
    """ Returns a handle to a texture reference.

    [Deprecated]

    Returns in `*pTexRef` the handle of the texture reference of name
    `name` in the module `hmod`. If no texture reference of that name
    exists, :py:obj:`~.cuModuleGetTexRef()` returns
    :py:obj:`~.CUDA_ERROR_NOT_FOUND`. This texture reference handle should
    not be destroyed, since it will be destroyed when the module is
    unloaded.

    Parameters
    ----------
    hmod : :py:obj:`~.CUmodule`
        Module to retrieve texture reference from
    name : bytes
        Name of texture reference to retrieve

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
    pTexRef : :py:obj:`~.CUtexref`
        Returned texture reference

    See Also
    --------
    :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetSurfRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`
    """
    cdef cydriver.CUmodule cyhmod
    if hmod is None:
        phmod = 0
    elif isinstance(hmod, (CUmodule,)):
        phmod = int(hmod)
    else:
        phmod = int(CUmodule(hmod))
    cyhmod = <cydriver.CUmodule><void_ptr>phmod
    cdef CUtexref pTexRef = CUtexref()
    with nogil:
        err = cydriver.cuModuleGetTexRef(<cydriver.CUtexref*>pTexRef._pvt_ptr, cyhmod, name)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pTexRef)
{{endif}}

{{if 'cuModuleGetSurfRef' in found_functions}}

@cython.embedsignature(True)
def cuModuleGetSurfRef(hmod, char* name):
    """ Returns a handle to a surface reference.

    [Deprecated]

    Returns in `*pSurfRef` the handle of the surface reference of name
    `name` in the module `hmod`. If no surface reference of that name
    exists, :py:obj:`~.cuModuleGetSurfRef()` returns
    :py:obj:`~.CUDA_ERROR_NOT_FOUND`.

    Parameters
    ----------
    hmod : :py:obj:`~.CUmodule`
        Module to retrieve surface reference from
    name : bytes
        Name of surface reference to retrieve

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
    pSurfRef : :py:obj:`~.CUsurfref`
        Returned surface reference

    See Also
    --------
    :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`
    """
    cdef cydriver.CUmodule cyhmod
    if hmod is None:
        phmod = 0
    elif isinstance(hmod, (CUmodule,)):
        phmod = int(hmod)
    else:
        phmod = int(CUmodule(hmod))
    cyhmod = <cydriver.CUmodule><void_ptr>phmod
    cdef CUsurfref pSurfRef = CUsurfref()
    with nogil:
        err = cydriver.cuModuleGetSurfRef(<cydriver.CUsurfref*>pSurfRef._pvt_ptr, cyhmod, name)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pSurfRef)
{{endif}}

{{if 'cuLibraryLoadData' in found_functions}}

@cython.embedsignature(True)
def cuLibraryLoadData(code, jitOptions : Optional[tuple[CUjit_option] | list[CUjit_option]], jitOptionsValues : Optional[tuple[Any] | list[Any]], unsigned int numJitOptions, libraryOptions : Optional[tuple[CUlibraryOption] | list[CUlibraryOption]], libraryOptionValues : Optional[tuple[Any] | list[Any]], unsigned int numLibraryOptions):
    """ Load a library with specified code and options.

    Takes a pointer `code` and loads the corresponding library `library`
    based on the application defined library loading mode:

    - If module loading is set to EAGER, via the environment variables
      described in "Module loading", `library` is loaded eagerly into all
      contexts at the time of the call and future contexts at the time of
      creation until the library is unloaded with
      :py:obj:`~.cuLibraryUnload()`.

    - If the environment variables are set to LAZY, `library` is not
      immediately loaded onto all existent contexts and will only be loaded
      when a function is needed for that context, such as a kernel launch.

    These environment variables are described in the CUDA programming guide
    under the "CUDA environment variables" section.

    The `code` may be a `cubin` or `fatbin` as output by nvcc, or a NULL-
    terminated `PTX`, either as output by nvcc or hand-written. A fatbin
    should also contain relocatable code when doing separate compilation.

    Options are passed as an array via `jitOptions` and any corresponding
    parameters are passed in `jitOptionsValues`. The number of total JIT
    options is supplied via `numJitOptions`. Any outputs will be returned
    via `jitOptionsValues`.

    Library load options are passed as an array via `libraryOptions` and
    any corresponding parameters are passed in `libraryOptionValues`. The
    number of total library load options is supplied via
    `numLibraryOptions`.

    Parameters
    ----------
    code : Any
        Code to load
    jitOptions : list[:py:obj:`~.CUjit_option`]
        Options for JIT
    jitOptionsValues : list[Any]
        Option values for JIT
    numJitOptions : unsigned int
        Number of options
    libraryOptions : list[:py:obj:`~.CUlibraryOption`]
        Options for loading
    libraryOptionValues : list[Any]
        Option values for loading
    numLibraryOptions : unsigned int
        Number of options for loading

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    library : :py:obj:`~.CUlibrary`
        Returned library

    See Also
    --------
    :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`

    Notes
    -----
    If the library contains managed variables and no device in the system supports managed variables this call is expected to return :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    """
    libraryOptionValues = [] if libraryOptionValues is None else libraryOptionValues
    libraryOptions = [] if libraryOptions is None else libraryOptions
    if not all(isinstance(_x, (CUlibraryOption)) for _x in libraryOptions):
        raise TypeError("Argument 'libraryOptions' is not instance of type (expected tuple[cydriver.CUlibraryOption] or list[cydriver.CUlibraryOption]")
    jitOptionsValues = [] if jitOptionsValues is None else jitOptionsValues
    jitOptions = [] if jitOptions is None else jitOptions
    if not all(isinstance(_x, (CUjit_option)) for _x in jitOptions):
        raise TypeError("Argument 'jitOptions' is not instance of type (expected tuple[cydriver.CUjit_option] or list[cydriver.CUjit_option]")
    cdef CUlibrary library = CUlibrary()
    cycode = _HelperInputVoidPtr(code)
    cdef void* cycode_ptr = <void*><void_ptr>cycode.cptr
    cdef vector[cydriver.CUjit_option] cyjitOptions = [pyjitOptions.value for pyjitOptions in (jitOptions)]
    pylist = [_HelperCUjit_option(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(jitOptions, jitOptionsValues)]
    cdef _InputVoidPtrPtrHelper voidStarHelperjitOptionsValues = _InputVoidPtrPtrHelper(pylist)
    cdef void** cyjitOptionsValues_ptr = <void**><void_ptr>voidStarHelperjitOptionsValues.cptr
    if numJitOptions > len(jitOptions): raise RuntimeError("List is too small: " + str(len(jitOptions)) + " < " + str(numJitOptions))
    if numJitOptions > len(jitOptionsValues): raise RuntimeError("List is too small: " + str(len(jitOptionsValues)) + " < " + str(numJitOptions))
    cdef vector[cydriver.CUlibraryOption] cylibraryOptions = [pylibraryOptions.value for pylibraryOptions in (libraryOptions)]
    pylist = [_HelperCUlibraryOption(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(libraryOptions, libraryOptionValues)]
    cdef _InputVoidPtrPtrHelper voidStarHelperlibraryOptionValues = _InputVoidPtrPtrHelper(pylist)
    cdef void** cylibraryOptionValues_ptr = <void**><void_ptr>voidStarHelperlibraryOptionValues.cptr
    if numLibraryOptions > len(libraryOptions): raise RuntimeError("List is too small: " + str(len(libraryOptions)) + " < " + str(numLibraryOptions))
    if numLibraryOptions > len(libraryOptionValues): raise RuntimeError("List is too small: " + str(len(libraryOptionValues)) + " < " + str(numLibraryOptions))
    with nogil:
        err = cydriver.cuLibraryLoadData(<cydriver.CUlibrary*>library._pvt_ptr, cycode_ptr, cyjitOptions.data(), cyjitOptionsValues_ptr, numJitOptions, cylibraryOptions.data(), cylibraryOptionValues_ptr, numLibraryOptions)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], library)
{{endif}}

{{if 'cuLibraryLoadFromFile' in found_functions}}

@cython.embedsignature(True)
def cuLibraryLoadFromFile(char* fileName, jitOptions : Optional[tuple[CUjit_option] | list[CUjit_option]], jitOptionsValues : Optional[tuple[Any] | list[Any]], unsigned int numJitOptions, libraryOptions : Optional[tuple[CUlibraryOption] | list[CUlibraryOption]], libraryOptionValues : Optional[tuple[Any] | list[Any]], unsigned int numLibraryOptions):
    """ Load a library with specified file and options.

    Takes a pointer `code` and loads the corresponding library `library`
    based on the application defined library loading mode:

    - If module loading is set to EAGER, via the environment variables
      described in "Module loading", `library` is loaded eagerly into all
      contexts at the time of the call and future contexts at the time of
      creation until the library is unloaded with
      :py:obj:`~.cuLibraryUnload()`.

    - If the environment variables are set to LAZY, `library` is not
      immediately loaded onto all existent contexts and will only be loaded
      when a function is needed for that context, such as a kernel launch.

    These environment variables are described in the CUDA programming guide
    under the "CUDA environment variables" section.

    The file should be a `cubin` file as output by nvcc, or a `PTX` file
    either as output by nvcc or handwritten, or a `fatbin` file as output
    by nvcc. A fatbin should also contain relocatable code when doing
    separate compilation.

    Options are passed as an array via `jitOptions` and any corresponding
    parameters are passed in `jitOptionsValues`. The number of total
    options is supplied via `numJitOptions`. Any outputs will be returned
    via `jitOptionsValues`.

    Library load options are passed as an array via `libraryOptions` and
    any corresponding parameters are passed in `libraryOptionValues`. The
    number of total library load options is supplied via
    `numLibraryOptions`.

    Parameters
    ----------
    fileName : bytes
        File to load from
    jitOptions : list[:py:obj:`~.CUjit_option`]
        Options for JIT
    jitOptionsValues : list[Any]
        Option values for JIT
    numJitOptions : unsigned int
        Number of options
    libraryOptions : list[:py:obj:`~.CUlibraryOption`]
        Options for loading
    libraryOptionValues : list[Any]
        Option values for loading
    numLibraryOptions : unsigned int
        Number of options for loading

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    library : :py:obj:`~.CUlibrary`
        Returned library

    See Also
    --------
    :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`

    Notes
    -----
    If the library contains managed variables and no device in the system supports managed variables this call is expected to return :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    """
    libraryOptionValues = [] if libraryOptionValues is None else libraryOptionValues
    libraryOptions = [] if libraryOptions is None else libraryOptions
    if not all(isinstance(_x, (CUlibraryOption)) for _x in libraryOptions):
        raise TypeError("Argument 'libraryOptions' is not instance of type (expected tuple[cydriver.CUlibraryOption] or list[cydriver.CUlibraryOption]")
    jitOptionsValues = [] if jitOptionsValues is None else jitOptionsValues
    jitOptions = [] if jitOptions is None else jitOptions
    if not all(isinstance(_x, (CUjit_option)) for _x in jitOptions):
        raise TypeError("Argument 'jitOptions' is not instance of type (expected tuple[cydriver.CUjit_option] or list[cydriver.CUjit_option]")
    cdef CUlibrary library = CUlibrary()
    cdef vector[cydriver.CUjit_option] cyjitOptions = [pyjitOptions.value for pyjitOptions in (jitOptions)]
    pylist = [_HelperCUjit_option(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(jitOptions, jitOptionsValues)]
    cdef _InputVoidPtrPtrHelper voidStarHelperjitOptionsValues = _InputVoidPtrPtrHelper(pylist)
    cdef void** cyjitOptionsValues_ptr = <void**><void_ptr>voidStarHelperjitOptionsValues.cptr
    if numJitOptions > len(jitOptions): raise RuntimeError("List is too small: " + str(len(jitOptions)) + " < " + str(numJitOptions))
    if numJitOptions > len(jitOptionsValues): raise RuntimeError("List is too small: " + str(len(jitOptionsValues)) + " < " + str(numJitOptions))
    cdef vector[cydriver.CUlibraryOption] cylibraryOptions = [pylibraryOptions.value for pylibraryOptions in (libraryOptions)]
    pylist = [_HelperCUlibraryOption(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(libraryOptions, libraryOptionValues)]
    cdef _InputVoidPtrPtrHelper voidStarHelperlibraryOptionValues = _InputVoidPtrPtrHelper(pylist)
    cdef void** cylibraryOptionValues_ptr = <void**><void_ptr>voidStarHelperlibraryOptionValues.cptr
    if numLibraryOptions > len(libraryOptions): raise RuntimeError("List is too small: " + str(len(libraryOptions)) + " < " + str(numLibraryOptions))
    if numLibraryOptions > len(libraryOptionValues): raise RuntimeError("List is too small: " + str(len(libraryOptionValues)) + " < " + str(numLibraryOptions))
    with nogil:
        err = cydriver.cuLibraryLoadFromFile(<cydriver.CUlibrary*>library._pvt_ptr, fileName, cyjitOptions.data(), cyjitOptionsValues_ptr, numJitOptions, cylibraryOptions.data(), cylibraryOptionValues_ptr, numLibraryOptions)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], library)
{{endif}}

{{if 'cuLibraryUnload' in found_functions}}

@cython.embedsignature(True)
def cuLibraryUnload(library):
    """ Unloads a library.

    Unloads the library specified with `library`

    Parameters
    ----------
    library : :py:obj:`~.CUlibrary`
        Library to unload

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuModuleUnload`
    """
    cdef cydriver.CUlibrary cylibrary
    if library is None:
        plibrary = 0
    elif isinstance(library, (CUlibrary,)):
        plibrary = int(library)
    else:
        plibrary = int(CUlibrary(library))
    cylibrary = <cydriver.CUlibrary><void_ptr>plibrary
    with nogil:
        err = cydriver.cuLibraryUnload(cylibrary)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuLibraryGetKernel' in found_functions}}

@cython.embedsignature(True)
def cuLibraryGetKernel(library, char* name):
    """ Returns a kernel handle.

    Returns in `pKernel` the handle of the kernel with name `name` located
    in library `library`. If kernel handle is not found, the call returns
    :py:obj:`~.CUDA_ERROR_NOT_FOUND`.

    Parameters
    ----------
    library : :py:obj:`~.CUlibrary`
        Library to retrieve kernel from
    name : bytes
        Name of kernel to retrieve

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
    pKernel : :py:obj:`~.CUkernel`
        Returned kernel handle

    See Also
    --------
    :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuKernelGetFunction`, :py:obj:`~.cuLibraryGetModule`, :py:obj:`~.cuModuleGetFunction`
    """
    cdef cydriver.CUlibrary cylibrary
    if library is None:
        plibrary = 0
    elif isinstance(library, (CUlibrary,)):
        plibrary = int(library)
    else:
        plibrary = int(CUlibrary(library))
    cylibrary = <cydriver.CUlibrary><void_ptr>plibrary
    cdef CUkernel pKernel = CUkernel()
    with nogil:
        err = cydriver.cuLibraryGetKernel(<cydriver.CUkernel*>pKernel._pvt_ptr, cylibrary, name)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pKernel)
{{endif}}

{{if 'cuLibraryGetKernelCount' in found_functions}}

@cython.embedsignature(True)
def cuLibraryGetKernelCount(lib):
    """ Returns the number of kernels within a library.

    Returns in `count` the number of kernels in `lib`.

    Parameters
    ----------
    lib : :py:obj:`~.CUlibrary`
        Library to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    count : unsigned int
        Number of kernels found within the library
    """
    cdef cydriver.CUlibrary cylib
    if lib is None:
        plib = 0
    elif isinstance(lib, (CUlibrary,)):
        plib = int(lib)
    else:
        plib = int(CUlibrary(lib))
    cylib = <cydriver.CUlibrary><void_ptr>plib
    cdef unsigned int count = 0
    with nogil:
        err = cydriver.cuLibraryGetKernelCount(&count, cylib)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], count)
{{endif}}

{{if 'cuLibraryEnumerateKernels' in found_functions}}

@cython.embedsignature(True)
def cuLibraryEnumerateKernels(unsigned int numKernels, lib):
    """ Retrieve the kernel handles within a library.

    Returns in `kernels` a maximum number of `numKernels` kernel handles
    within `lib`. The returned kernel handle becomes invalid when the
    library is unloaded.

    Parameters
    ----------
    numKernels : unsigned int
        Maximum number of kernel handles may be returned to the buffer
    lib : :py:obj:`~.CUlibrary`
        Library to query from

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    kernels : list[:py:obj:`~.CUkernel`]
        Buffer where the kernel handles are returned to

    See Also
    --------
    :py:obj:`~.cuLibraryGetKernelCount`
    """
    cdef cydriver.CUlibrary cylib
    if lib is None:
        plib = 0
    elif isinstance(lib, (CUlibrary,)):
        plib = int(lib)
    else:
        plib = int(CUlibrary(lib))
    cylib = <cydriver.CUlibrary><void_ptr>plib
    cdef cydriver.CUkernel* cykernels = NULL
    pykernels = []
    if numKernels != 0:
        cykernels = <cydriver.CUkernel*>calloc(numKernels, sizeof(cydriver.CUkernel))
        if cykernels is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(numKernels) + 'x' + str(sizeof(cydriver.CUkernel)))
    with nogil:
        err = cydriver.cuLibraryEnumerateKernels(cykernels, numKernels, cylib)
    if CUresult(err) == CUresult(0):
        pykernels = [CUkernel(init_value=<void_ptr>cykernels[idx]) for idx in range(numKernels)]
    if cykernels is not NULL:
        free(cykernels)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pykernels)
{{endif}}

{{if 'cuLibraryGetModule' in found_functions}}

@cython.embedsignature(True)
def cuLibraryGetModule(library):
    """ Returns a module handle.

    Returns in `pMod` the module handle associated with the current context
    located in library `library`. If module handle is not found, the call
    returns :py:obj:`~.CUDA_ERROR_NOT_FOUND`.

    Parameters
    ----------
    library : :py:obj:`~.CUlibrary`
        Library to retrieve module from

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`
    pMod : :py:obj:`~.CUmodule`
        Returned module handle

    See Also
    --------
    :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuModuleGetFunction`
    """
    cdef cydriver.CUlibrary cylibrary
    if library is None:
        plibrary = 0
    elif isinstance(library, (CUlibrary,)):
        plibrary = int(library)
    else:
        plibrary = int(CUlibrary(library))
    cylibrary = <cydriver.CUlibrary><void_ptr>plibrary
    cdef CUmodule pMod = CUmodule()
    with nogil:
        err = cydriver.cuLibraryGetModule(<cydriver.CUmodule*>pMod._pvt_ptr, cylibrary)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pMod)
{{endif}}

{{if 'cuKernelGetFunction' in found_functions}}

@cython.embedsignature(True)
def cuKernelGetFunction(kernel):
    """ Returns a function handle.

    Returns in `pFunc` the handle of the function for the requested kernel
    `kernel` and the current context. If function handle is not found, the
    call returns :py:obj:`~.CUDA_ERROR_NOT_FOUND`.

    Parameters
    ----------
    kernel : :py:obj:`~.CUkernel`
        Kernel to retrieve function for the requested context

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`
    pFunc : :py:obj:`~.CUfunction`
        Returned function handle

    See Also
    --------
    :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuLibraryGetKernel`, :py:obj:`~.cuLibraryGetModule`, :py:obj:`~.cuModuleGetFunction`
    """
    cdef cydriver.CUkernel cykernel
    if kernel is None:
        pkernel = 0
    elif isinstance(kernel, (CUkernel,)):
        pkernel = int(kernel)
    else:
        pkernel = int(CUkernel(kernel))
    cykernel = <cydriver.CUkernel><void_ptr>pkernel
    cdef CUfunction pFunc = CUfunction()
    with nogil:
        err = cydriver.cuKernelGetFunction(<cydriver.CUfunction*>pFunc._pvt_ptr, cykernel)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pFunc)
{{endif}}

{{if 'cuKernelGetLibrary' in found_functions}}

@cython.embedsignature(True)
def cuKernelGetLibrary(kernel):
    """ Returns a library handle.

    Returns in `pLib` the handle of the library for the requested kernel
    `kernel`

    Parameters
    ----------
    kernel : :py:obj:`~.CUkernel`
        Kernel to retrieve library handle

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
    pLib : :py:obj:`~.CUlibrary`
        Returned library handle

    See Also
    --------
    :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuLibraryGetKernel`
    """
    cdef cydriver.CUkernel cykernel
    if kernel is None:
        pkernel = 0
    elif isinstance(kernel, (CUkernel,)):
        pkernel = int(kernel)
    else:
        pkernel = int(CUkernel(kernel))
    cykernel = <cydriver.CUkernel><void_ptr>pkernel
    cdef CUlibrary pLib = CUlibrary()
    with nogil:
        err = cydriver.cuKernelGetLibrary(<cydriver.CUlibrary*>pLib._pvt_ptr, cykernel)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pLib)
{{endif}}

{{if 'cuLibraryGetGlobal' in found_functions}}

@cython.embedsignature(True)
def cuLibraryGetGlobal(library, char* name):
    """ Returns a global device pointer.

    Returns in `*dptr` and `*bytes` the base pointer and size of the global
    with name `name` for the requested library `library` and the current
    context. If no global for the requested name `name` exists, the call
    returns :py:obj:`~.CUDA_ERROR_NOT_FOUND`. One of the parameters `dptr`
    or `numbytes` (not both) can be NULL in which case it is ignored.

    Parameters
    ----------
    library : :py:obj:`~.CUlibrary`
        Library to retrieve global from
    name : bytes
        Name of global to retrieve

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`
    dptr : :py:obj:`~.CUdeviceptr`
        Returned global device pointer for the requested context
    numbytes : int
        Returned global size in bytes

    See Also
    --------
    :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuLibraryGetModule`, :py:obj:`~.cuModuleGetGlobal`
    """
    cdef cydriver.CUlibrary cylibrary
    if library is None:
        plibrary = 0
    elif isinstance(library, (CUlibrary,)):
        plibrary = int(library)
    else:
        plibrary = int(CUlibrary(library))
    cylibrary = <cydriver.CUlibrary><void_ptr>plibrary
    cdef CUdeviceptr dptr = CUdeviceptr()
    cdef size_t numbytes = 0
    with nogil:
        err = cydriver.cuLibraryGetGlobal(<cydriver.CUdeviceptr*>dptr._pvt_ptr, &numbytes, cylibrary, name)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], dptr, numbytes)
{{endif}}

{{if 'cuLibraryGetManaged' in found_functions}}

@cython.embedsignature(True)
def cuLibraryGetManaged(library, char* name):
    """ Returns a pointer to managed memory.

    Returns in `*dptr` and `*bytes` the base pointer and size of the
    managed memory with name `name` for the requested library `library`. If
    no managed memory with the requested name `name` exists, the call
    returns :py:obj:`~.CUDA_ERROR_NOT_FOUND`. One of the parameters `dptr`
    or `numbytes` (not both) can be NULL in which case it is ignored. Note
    that managed memory for library `library` is shared across devices and
    is registered when the library is loaded into atleast one context.

    Parameters
    ----------
    library : :py:obj:`~.CUlibrary`
        Library to retrieve managed memory from
    name : bytes
        Name of managed memory to retrieve

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
    dptr : :py:obj:`~.CUdeviceptr`
        Returned pointer to the managed memory
    numbytes : int
        Returned memory size in bytes

    See Also
    --------
    :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`
    """
    cdef cydriver.CUlibrary cylibrary
    if library is None:
        plibrary = 0
    elif isinstance(library, (CUlibrary,)):
        plibrary = int(library)
    else:
        plibrary = int(CUlibrary(library))
    cylibrary = <cydriver.CUlibrary><void_ptr>plibrary
    cdef CUdeviceptr dptr = CUdeviceptr()
    cdef size_t numbytes = 0
    with nogil:
        err = cydriver.cuLibraryGetManaged(<cydriver.CUdeviceptr*>dptr._pvt_ptr, &numbytes, cylibrary, name)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], dptr, numbytes)
{{endif}}

{{if 'cuLibraryGetUnifiedFunction' in found_functions}}

@cython.embedsignature(True)
def cuLibraryGetUnifiedFunction(library, char* symbol):
    """ Returns a pointer to a unified function.

    Returns in `*fptr` the function pointer to a unified function denoted
    by `symbol`. If no unified function with name `symbol` exists, the call
    returns :py:obj:`~.CUDA_ERROR_NOT_FOUND`. If there is no device with
    attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_UNIFIED_FUNCTION_POINTERS`
    present in the system, the call may return
    :py:obj:`~.CUDA_ERROR_NOT_FOUND`.

    Parameters
    ----------
    library : :py:obj:`~.CUlibrary`
        Library to retrieve function pointer memory from
    symbol : bytes
        Name of function pointer to retrieve

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
    fptr : Any
        Returned pointer to a unified function

    See Also
    --------
    :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`
    """
    cdef cydriver.CUlibrary cylibrary
    if library is None:
        plibrary = 0
    elif isinstance(library, (CUlibrary,)):
        plibrary = int(library)
    else:
        plibrary = int(CUlibrary(library))
    cylibrary = <cydriver.CUlibrary><void_ptr>plibrary
    cdef void_ptr fptr = 0
    with nogil:
        err = cydriver.cuLibraryGetUnifiedFunction(<void**>&fptr, cylibrary, symbol)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], fptr)
{{endif}}

{{if 'cuKernelGetAttribute' in found_functions}}

@cython.embedsignature(True)
def cuKernelGetAttribute(attrib not None : CUfunction_attribute, kernel, dev):
    """ Returns information about a kernel.

    Returns in `*pi` the integer value of the attribute `attrib` for the
    kernel `kernel` for the requested device `dev`. The supported
    attributes are:

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK`: The maximum
      number of threads per block, beyond which a launch of the kernel
      would fail. This number depends on both the kernel and the requested
      device.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES`: The size in bytes of
      statically-allocated shared memory per block required by this kernel.
      This does not include dynamically-allocated shared memory requested
      by the user at runtime.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES`: The size in bytes of
      user-allocated constant memory required by this kernel.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES`: The size in bytes of
      local memory used by each thread of this kernel.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_NUM_REGS`: The number of registers used
      by each thread of this kernel.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_PTX_VERSION`: The PTX virtual
      architecture version for which the kernel was compiled. This value is
      the major PTX version * 10

      - the minor PTX version, so a PTX version 1.3 function would return
        the value 13. Note that this may return the undefined value of 0
        for cubins compiled prior to CUDA 3.0.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_BINARY_VERSION`: The binary architecture
      version for which the kernel was compiled. This value is the major
      binary version * 10 + the minor binary version, so a binary version
      1.3 function would return the value 13. Note that this will return a
      value of 10 for legacy cubins that do not have a properly-encoded
      binary architecture version.

    - :py:obj:`~.CU_FUNC_CACHE_MODE_CA`: The attribute to indicate whether
      the kernel has been compiled with user specified option "-Xptxas
      --dlcm=ca" set.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES`: The
      maximum size in bytes of dynamically-allocated shared memory.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT`:
      Preferred shared memory-L1 cache split ratio in percent of total
      shared memory.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET`: If this
      attribute is set, the kernel must launch with a valid cluster size
      specified.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH`: The required
      cluster width in blocks.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT`: The required
      cluster height in blocks.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH`: The required
      cluster depth in blocks.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED`:
      Indicates whether the function can be launched with non-portable
      cluster size. 1 is allowed, 0 is disallowed. A non-portable cluster
      size may only function on the specific SKUs the program is tested on.
      The launch might fail if the program is run on a different hardware
      platform. CUDA API provides cudaOccupancyMaxActiveClusters to assist
      with checking whether the desired size can be launched on the current
      device. A portable cluster size is guaranteed to be functional on all
      compute capabilities higher than the target compute capability. The
      portable cluster size for sm_90 is 8 blocks per cluster. This value
      may increase for future compute capabilities. The specific hardware
      unit may support higher cluster sizes thats not guaranteed to be
      portable.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE`:
      The block scheduling policy of a function. The value type is
      CUclusterSchedulingPolicy.

    Parameters
    ----------
    attrib : :py:obj:`~.CUfunction_attribute`
        Attribute requested
    kernel : :py:obj:`~.CUkernel`
        Kernel to query attribute of
    dev : :py:obj:`~.CUdevice`
        Device to query attribute of

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    pi : int
        Returned attribute value

    See Also
    --------
    :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuKernelSetAttribute`, :py:obj:`~.cuLibraryGetKernel`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuKernelGetFunction`, :py:obj:`~.cuLibraryGetModule`, :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuFuncGetAttribute`

    Notes
    -----
    If another thread is trying to set the same attribute on the same device using :py:obj:`~.cuKernelSetAttribute()` simultaneously, the attribute query will give the old or new value depending on the interleavings chosen by the OS scheduler and memory consistency.
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef cydriver.CUkernel cykernel
    if kernel is None:
        pkernel = 0
    elif isinstance(kernel, (CUkernel,)):
        pkernel = int(kernel)
    else:
        pkernel = int(CUkernel(kernel))
    cykernel = <cydriver.CUkernel><void_ptr>pkernel
    cdef int pi = 0
    cdef cydriver.CUfunction_attribute cyattrib = attrib.value
    with nogil:
        err = cydriver.cuKernelGetAttribute(&pi, cyattrib, cykernel, cydev)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pi)
{{endif}}

{{if 'cuKernelSetAttribute' in found_functions}}

@cython.embedsignature(True)
def cuKernelSetAttribute(attrib not None : CUfunction_attribute, int val, kernel, dev):
    """ Sets information about a kernel.

    This call sets the value of a specified attribute `attrib` on the
    kernel `kernel` for the requested device `dev` to an integer value
    specified by `val`. This function returns CUDA_SUCCESS if the new value
    of the attribute could be successfully set. If the set fails, this call
    will return an error. Not all attributes can have values set.
    Attempting to set a value on a read-only attribute will result in an
    error (CUDA_ERROR_INVALID_VALUE)

    Note that attributes set using :py:obj:`~.cuFuncSetAttribute()` will
    override the attribute set by this API irrespective of whether the call
    to :py:obj:`~.cuFuncSetAttribute()` is made before or after this API
    call. However, :py:obj:`~.cuKernelGetAttribute()` will always return
    the attribute value set by this API.

    Supported attributes are:

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES`: This is
      the maximum size in bytes of dynamically-allocated shared memory. The
      value should contain the requested maximum size of dynamically-
      allocated shared memory. The sum of this value and the function
      attribute :py:obj:`~.CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES` cannot
      exceed the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN`.
      The maximal size of requestable dynamic shared memory may differ by
      GPU architecture.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT`: On
      devices where the L1 cache and shared memory use the same hardware
      resources, this sets the shared memory carveout preference, in
      percent of the total shared memory. See
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR`
      This is only a hint, and the driver can choose a different ratio if
      required to execute the function.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH`: The required
      cluster width in blocks. The width, height, and depth values must
      either all be 0 or all be positive. The validity of the cluster
      dimensions is checked at launch time. If the value is set during
      compile time, it cannot be set at runtime. Setting it at runtime will
      return CUDA_ERROR_NOT_PERMITTED.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT`: The required
      cluster height in blocks. The width, height, and depth values must
      either all be 0 or all be positive. The validity of the cluster
      dimensions is checked at launch time. If the value is set during
      compile time, it cannot be set at runtime. Setting it at runtime will
      return CUDA_ERROR_NOT_PERMITTED.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH`: The required
      cluster depth in blocks. The width, height, and depth values must
      either all be 0 or all be positive. The validity of the cluster
      dimensions is checked at launch time. If the value is set during
      compile time, it cannot be set at runtime. Setting it at runtime will
      return CUDA_ERROR_NOT_PERMITTED.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED`:
      Indicates whether the function can be launched with non-portable
      cluster size. 1 is allowed, 0 is disallowed.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE`:
      The block scheduling policy of a function. The value type is
      CUclusterSchedulingPolicy.

    Parameters
    ----------
    attrib : :py:obj:`~.CUfunction_attribute`
        Attribute requested
    val : int
        Value to set
    kernel : :py:obj:`~.CUkernel`
        Kernel to set attribute of
    dev : :py:obj:`~.CUdevice`
        Device to set attribute of

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

    See Also
    --------
    :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuKernelGetAttribute`, :py:obj:`~.cuLibraryGetKernel`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuKernelGetFunction`, :py:obj:`~.cuLibraryGetModule`, :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuFuncSetAttribute`

    Notes
    -----
    The API has stricter locking requirements in comparison to its legacy counterpart :py:obj:`~.cuFuncSetAttribute()` due to device-wide semantics. If multiple threads are trying to set the same attribute on the same device simultaneously, the attribute setting will depend on the interleavings chosen by the OS scheduler and memory consistency.
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef cydriver.CUkernel cykernel
    if kernel is None:
        pkernel = 0
    elif isinstance(kernel, (CUkernel,)):
        pkernel = int(kernel)
    else:
        pkernel = int(CUkernel(kernel))
    cykernel = <cydriver.CUkernel><void_ptr>pkernel
    cdef cydriver.CUfunction_attribute cyattrib = attrib.value
    with nogil:
        err = cydriver.cuKernelSetAttribute(cyattrib, val, cykernel, cydev)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuKernelSetCacheConfig' in found_functions}}

@cython.embedsignature(True)
def cuKernelSetCacheConfig(kernel, config not None : CUfunc_cache, dev):
    """ Sets the preferred cache configuration for a device kernel.

    On devices where the L1 cache and shared memory use the same hardware
    resources, this sets through `config` the preferred cache configuration
    for the device kernel `kernel` on the requested device `dev`. This is
    only a preference. The driver will use the requested configuration if
    possible, but it is free to choose a different configuration if
    required to execute `kernel`. Any context-wide preference set via
    :py:obj:`~.cuCtxSetCacheConfig()` will be overridden by this per-kernel
    setting.

    Note that attributes set using :py:obj:`~.cuFuncSetCacheConfig()` will
    override the attribute set by this API irrespective of whether the call
    to :py:obj:`~.cuFuncSetCacheConfig()` is made before or after this API
    call.

    This setting does nothing on devices where the size of the L1 cache and
    shared memory are fixed.

    Launching a kernel with a different preference than the most recent
    preference setting may insert a device-side synchronization point.

    The supported cache configurations are:

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE`: no preference for shared
      memory or L1 (default)

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_SHARED`: prefer larger shared memory
      and smaller L1 cache

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_L1`: prefer larger L1 cache and
      smaller shared memory

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_EQUAL`: prefer equal sized L1 cache
      and shared memory

    Parameters
    ----------
    kernel : :py:obj:`~.CUkernel`
        Kernel to configure cache for
    config : :py:obj:`~.CUfunc_cache`
        Requested cache configuration
    dev : :py:obj:`~.CUdevice`
        Device to set attribute of

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

    See Also
    --------
    :py:obj:`~.cuLibraryLoadData`, :py:obj:`~.cuLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`, :py:obj:`~.cuLibraryGetKernel`, :py:obj:`~.cuKernelGetFunction`, :py:obj:`~.cuLibraryGetModule`, :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuLaunchKernel`

    Notes
    -----
    The API has stricter locking requirements in comparison to its legacy counterpart :py:obj:`~.cuFuncSetCacheConfig()` due to device-wide semantics. If multiple threads are trying to set a config on the same device simultaneously, the cache config setting will depend on the interleavings chosen by the OS scheduler and memory consistency.
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef cydriver.CUkernel cykernel
    if kernel is None:
        pkernel = 0
    elif isinstance(kernel, (CUkernel,)):
        pkernel = int(kernel)
    else:
        pkernel = int(CUkernel(kernel))
    cykernel = <cydriver.CUkernel><void_ptr>pkernel
    cdef cydriver.CUfunc_cache cyconfig = config.value
    with nogil:
        err = cydriver.cuKernelSetCacheConfig(cykernel, cyconfig, cydev)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuKernelGetName' in found_functions}}

@cython.embedsignature(True)
def cuKernelGetName(hfunc):
    """ Returns the function name for a :py:obj:`~.CUkernel` handle.

    Returns in `**name` the function name associated with the kernel handle
    `hfunc` . The function name is returned as a null-terminated string.
    The returned name is only valid when the kernel handle is valid. If the
    library is unloaded or reloaded, one must call the API again to get the
    updated name. This API may return a mangled name if the function is not
    declared as having C linkage. If either `**name` or `hfunc` is NULL,
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUkernel`
        The function handle to retrieve the name for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    name : bytes
        The returned name of the function
    """
    cdef cydriver.CUkernel cyhfunc
    if hfunc is None:
        phfunc = 0
    elif isinstance(hfunc, (CUkernel,)):
        phfunc = int(hfunc)
    else:
        phfunc = int(CUkernel(hfunc))
    cyhfunc = <cydriver.CUkernel><void_ptr>phfunc
    cdef const char* name = NULL
    with nogil:
        err = cydriver.cuKernelGetName(&name, cyhfunc)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], <bytes>name if name != NULL else None)
{{endif}}

{{if 'cuKernelGetParamInfo' in found_functions}}

@cython.embedsignature(True)
def cuKernelGetParamInfo(kernel, size_t paramIndex):
    """ Returns the offset and size of a kernel parameter in the device-side parameter layout.

    Queries the kernel parameter at `paramIndex` into `kernel's` list of
    parameters, and returns in `paramOffset` and `paramSize` the offset and
    size, respectively, where the parameter will reside in the device-side
    parameter layout. This information can be used to update kernel node
    parameters from the device via
    :py:obj:`~.cudaGraphKernelNodeSetParam()` and
    :py:obj:`~.cudaGraphKernelNodeUpdatesApply()`. `paramIndex` must be
    less than the number of parameters that `kernel` takes. `paramSize` can
    be set to NULL if only the parameter offset is desired.

    Parameters
    ----------
    kernel : :py:obj:`~.CUkernel`
        The kernel to query
    paramIndex : size_t
        The parameter index to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    paramOffset : int
        Returns the offset into the device-side parameter layout at which
        the parameter resides
    paramSize : int
        Optionally returns the size of the parameter in the device-side
        parameter layout

    See Also
    --------
    :py:obj:`~.cuFuncGetParamInfo`
    """
    cdef cydriver.CUkernel cykernel
    if kernel is None:
        pkernel = 0
    elif isinstance(kernel, (CUkernel,)):
        pkernel = int(kernel)
    else:
        pkernel = int(CUkernel(kernel))
    cykernel = <cydriver.CUkernel><void_ptr>pkernel
    cdef size_t paramOffset = 0
    cdef size_t paramSize = 0
    with nogil:
        err = cydriver.cuKernelGetParamInfo(cykernel, paramIndex, &paramOffset, &paramSize)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], paramOffset, paramSize)
{{endif}}

{{if 'cuMemGetInfo_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemGetInfo():
    """ Gets free and total memory.

    Returns in `*total` the total amount of memory available to the the
    current context. Returns in `*free` the amount of memory on the device
    that is free according to the OS. CUDA is not guaranteed to be able to
    allocate all of the memory that the OS reports as free. In a multi-
    tenet situation, free estimate returned is prone to race condition
    where a new allocation/free done by a different process or a different
    thread in the same process between the time when free memory was
    estimated and reported, will result in deviation in free value reported
    and actual free memory.

    The integrated GPU on Tegra shares memory with CPU and other component
    of the SoC. The free and total values returned by the API excludes the
    SWAP memory space maintained by the OS on some platforms. The OS may
    move some of the memory pages into swap area as the GPU or CPU allocate
    or access memory. See Tegra app note on how to calculate total and free
    memory on Tegra.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    free : int
        Returned free memory in bytes
    total : int
        Returned total memory in bytes

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemGetInfo`
    """
    cdef size_t free = 0
    cdef size_t total = 0
    with nogil:
        err = cydriver.cuMemGetInfo(&free, &total)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], free, total)
{{endif}}

{{if 'cuMemAlloc_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemAlloc(size_t bytesize):
    """ Allocates device memory.

    Allocates `bytesize` bytes of linear memory on the device and returns
    in `*dptr` a pointer to the allocated memory. The allocated memory is
    suitably aligned for any kind of variable. The memory is not cleared.
    If `bytesize` is 0, :py:obj:`~.cuMemAlloc()` returns
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

    Parameters
    ----------
    bytesize : size_t
        Requested allocation size in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    dptr : :py:obj:`~.CUdeviceptr`
        Returned device pointer

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMalloc`
    """
    cdef CUdeviceptr dptr = CUdeviceptr()
    with nogil:
        err = cydriver.cuMemAlloc(<cydriver.CUdeviceptr*>dptr._pvt_ptr, bytesize)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], dptr)
{{endif}}

{{if 'cuMemAllocPitch_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemAllocPitch(size_t WidthInBytes, size_t Height, unsigned int ElementSizeBytes):
    """ Allocates pitched device memory.

    Allocates at least `WidthInBytes` * `Height` bytes of linear memory on
    the device and returns in `*dptr` a pointer to the allocated memory.
    The function may pad the allocation to ensure that corresponding
    pointers in any given row will continue to meet the alignment
    requirements for coalescing as the address is updated from row to row.
    `ElementSizeBytes` specifies the size of the largest reads and writes
    that will be performed on the memory range. `ElementSizeBytes` may be
    4, 8 or 16 (since coalesced memory transactions are not possible on
    other data sizes). If `ElementSizeBytes` is smaller than the actual
    read/write size of a kernel, the kernel will run correctly, but
    possibly at reduced speed. The pitch returned in `*pPitch` by
    :py:obj:`~.cuMemAllocPitch()` is the width in bytes of the allocation.
    The intended usage of pitch is as a separate parameter of the
    allocation, used to compute addresses within the 2D array. Given the
    row and column of an array element of type T, the address is computed
    as:

    **View CUDA Toolkit Documentation for a C++ code example**

    The pitch returned by :py:obj:`~.cuMemAllocPitch()` is guaranteed to
    work with :py:obj:`~.cuMemcpy2D()` under all circumstances. For
    allocations of 2D arrays, it is recommended that programmers consider
    performing pitch allocations using :py:obj:`~.cuMemAllocPitch()`. Due
    to alignment restrictions in the hardware, this is especially true if
    the application will be performing 2D memory copies between different
    regions of device memory (whether linear memory or CUDA arrays).

    The byte alignment of the pitch returned by
    :py:obj:`~.cuMemAllocPitch()` is guaranteed to match or exceed the
    alignment requirement for texture binding with
    :py:obj:`~.cuTexRefSetAddress2D()`.

    Parameters
    ----------
    WidthInBytes : size_t
        Requested allocation width in bytes
    Height : size_t
        Requested allocation height in rows
    ElementSizeBytes : unsigned int
        Size of largest reads/writes for range

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    dptr : :py:obj:`~.CUdeviceptr`
        Returned device pointer
    pPitch : int
        Returned pitch of allocation in bytes

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMallocPitch`
    """
    cdef CUdeviceptr dptr = CUdeviceptr()
    cdef size_t pPitch = 0
    with nogil:
        err = cydriver.cuMemAllocPitch(<cydriver.CUdeviceptr*>dptr._pvt_ptr, &pPitch, WidthInBytes, Height, ElementSizeBytes)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], dptr, pPitch)
{{endif}}

{{if 'cuMemFree_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemFree(dptr):
    """ Frees device memory.

    Frees the memory space pointed to by `dptr`, which must have been
    returned by a previous call to one of the following memory allocation
    APIs - :py:obj:`~.cuMemAlloc()`, :py:obj:`~.cuMemAllocPitch()`,
    :py:obj:`~.cuMemAllocManaged()`, :py:obj:`~.cuMemAllocAsync()`,
    :py:obj:`~.cuMemAllocFromPoolAsync()`

    Note - This API will not perform any implict synchronization when the
    pointer was allocated with :py:obj:`~.cuMemAllocAsync` or
    :py:obj:`~.cuMemAllocFromPoolAsync`. Callers must ensure that all
    accesses to these pointer have completed before invoking
    :py:obj:`~.cuMemFree`. For best performance and memory reuse, users
    should use :py:obj:`~.cuMemFreeAsync` to free memory allocated via the
    stream ordered memory allocator. For all other pointers, this API may
    perform implicit synchronization.

    Parameters
    ----------
    dptr : :py:obj:`~.CUdeviceptr`
        Pointer to memory to free

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemAllocManaged`, :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemAllocFromPoolAsync`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaFree`
    """
    cdef cydriver.CUdeviceptr cydptr
    if dptr is None:
        pdptr = 0
    elif isinstance(dptr, (CUdeviceptr,)):
        pdptr = int(dptr)
    else:
        pdptr = int(CUdeviceptr(dptr))
    cydptr = <cydriver.CUdeviceptr><void_ptr>pdptr
    with nogil:
        err = cydriver.cuMemFree(cydptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemGetAddressRange_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemGetAddressRange(dptr):
    """ Get information on memory allocations.

    Returns the base address in `*pbase` and size in `*psize` of the
    allocation by :py:obj:`~.cuMemAlloc()` or :py:obj:`~.cuMemAllocPitch()`
    that contains the input pointer `dptr`. Both parameters `pbase` and
    `psize` are optional. If one of them is NULL, it is ignored.

    Parameters
    ----------
    dptr : :py:obj:`~.CUdeviceptr`
        Device pointer to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pbase : :py:obj:`~.CUdeviceptr`
        Returned base address
    psize : int
        Returned size of device memory allocation

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`
    """
    cdef cydriver.CUdeviceptr cydptr
    if dptr is None:
        pdptr = 0
    elif isinstance(dptr, (CUdeviceptr,)):
        pdptr = int(dptr)
    else:
        pdptr = int(CUdeviceptr(dptr))
    cydptr = <cydriver.CUdeviceptr><void_ptr>pdptr
    cdef CUdeviceptr pbase = CUdeviceptr()
    cdef size_t psize = 0
    with nogil:
        err = cydriver.cuMemGetAddressRange(<cydriver.CUdeviceptr*>pbase._pvt_ptr, &psize, cydptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], pbase, psize)
{{endif}}

{{if 'cuMemAllocHost_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemAllocHost(size_t bytesize):
    """ Allocates page-locked host memory.

    Allocates `bytesize` bytes of host memory that is page-locked and
    accessible to the device. The driver tracks the virtual memory ranges
    allocated with this function and automatically accelerates calls to
    functions such as :py:obj:`~.cuMemcpy()`. Since the memory can be
    accessed directly by the device, it can be read or written with much
    higher bandwidth than pageable memory obtained with functions such as
    :py:obj:`~.malloc()`.

    On systems where
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`
    is true, :py:obj:`~.cuMemAllocHost` may not page-lock the allocated
    memory.

    Page-locking excessive amounts of memory with
    :py:obj:`~.cuMemAllocHost()` may degrade system performance, since it
    reduces the amount of memory available to the system for paging. As a
    result, this function is best used sparingly to allocate staging areas
    for data exchange between host and device.

    Note all host memory allocated using :py:obj:`~.cuMemAllocHost()` will
    automatically be immediately accessible to all contexts on all devices
    which support unified addressing (as may be queried using
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING`). The device pointer
    that may be used to access this host memory from those contexts is
    always equal to the returned host pointer `*pp`. See :py:obj:`~.Unified
    Addressing` for additional details.

    Parameters
    ----------
    bytesize : size_t
        Requested allocation size in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    pp : Any
        Returned pointer to host memory

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMallocHost`
    """
    cdef void_ptr pp = 0
    with nogil:
        err = cydriver.cuMemAllocHost(<void**>&pp, bytesize)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pp)
{{endif}}

{{if 'cuMemFreeHost' in found_functions}}

@cython.embedsignature(True)
def cuMemFreeHost(p):
    """ Frees page-locked host memory.

    Frees the memory space pointed to by `p`, which must have been returned
    by a previous call to :py:obj:`~.cuMemAllocHost()`.

    Parameters
    ----------
    p : Any
        Pointer to memory to free

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaFreeHost`
    """
    cyp = _HelperInputVoidPtr(p)
    cdef void* cyp_ptr = <void*><void_ptr>cyp.cptr
    with nogil:
        err = cydriver.cuMemFreeHost(cyp_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemHostAlloc' in found_functions}}

@cython.embedsignature(True)
def cuMemHostAlloc(size_t bytesize, unsigned int Flags):
    """ Allocates page-locked host memory.

    Allocates `bytesize` bytes of host memory that is page-locked and
    accessible to the device. The driver tracks the virtual memory ranges
    allocated with this function and automatically accelerates calls to
    functions such as :py:obj:`~.cuMemcpyHtoD()`. Since the memory can be
    accessed directly by the device, it can be read or written with much
    higher bandwidth than pageable memory obtained with functions such as
    :py:obj:`~.malloc()`.

    On systems where
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`
    is true, :py:obj:`~.cuMemHostAlloc` may not page-lock the allocated
    memory.

    Page-locking excessive amounts of memory may degrade system
    performance, since it reduces the amount of memory available to the
    system for paging. As a result, this function is best used sparingly to
    allocate staging areas for data exchange between host and device.

    The `Flags` parameter enables different options to be specified that
    affect the allocation, as follows.

    - :py:obj:`~.CU_MEMHOSTALLOC_PORTABLE`: The memory returned by this
      call will be considered as pinned memory by all CUDA contexts, not
      just the one that performed the allocation.

    - :py:obj:`~.CU_MEMHOSTALLOC_DEVICEMAP`: Maps the allocation into the
      CUDA address space. The device pointer to the memory may be obtained
      by calling :py:obj:`~.cuMemHostGetDevicePointer()`.

    - :py:obj:`~.CU_MEMHOSTALLOC_WRITECOMBINED`: Allocates the memory as
      write-combined (WC). WC memory can be transferred across the PCI
      Express bus more quickly on some system configurations, but cannot be
      read efficiently by most CPUs. WC memory is a good option for buffers
      that will be written by the CPU and read by the GPU via mapped pinned
      memory or host->device transfers.

    All of these flags are orthogonal to one another: a developer may
    allocate memory that is portable, mapped and/or write-combined with no
    restrictions.

    The :py:obj:`~.CU_MEMHOSTALLOC_DEVICEMAP` flag may be specified on CUDA
    contexts for devices that do not support mapped pinned memory. The
    failure is deferred to :py:obj:`~.cuMemHostGetDevicePointer()` because
    the memory may be mapped into other CUDA contexts via the
    :py:obj:`~.CU_MEMHOSTALLOC_PORTABLE` flag.

    The memory allocated by this function must be freed with
    :py:obj:`~.cuMemFreeHost()`.

    Note all host memory allocated using :py:obj:`~.cuMemHostAlloc()` will
    automatically be immediately accessible to all contexts on all devices
    which support unified addressing (as may be queried using
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING`). Unless the flag
    :py:obj:`~.CU_MEMHOSTALLOC_WRITECOMBINED` is specified, the device
    pointer that may be used to access this host memory from those contexts
    is always equal to the returned host pointer `*pp`. If the flag
    :py:obj:`~.CU_MEMHOSTALLOC_WRITECOMBINED` is specified, then the
    function :py:obj:`~.cuMemHostGetDevicePointer()` must be used to query
    the device pointer, even if the context supports unified addressing.
    See :py:obj:`~.Unified Addressing` for additional details.

    Parameters
    ----------
    bytesize : size_t
        Requested allocation size in bytes
    Flags : unsigned int
        Flags for allocation request

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    pp : Any
        Returned pointer to host memory

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaHostAlloc`
    """
    cdef void_ptr pp = 0
    with nogil:
        err = cydriver.cuMemHostAlloc(<void**>&pp, bytesize, Flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pp)
{{endif}}

{{if 'cuMemHostGetDevicePointer_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemHostGetDevicePointer(p, unsigned int Flags):
    """ Passes back device pointer of mapped pinned memory.

    Passes back the device pointer `pdptr` corresponding to the mapped,
    pinned host buffer `p` allocated by :py:obj:`~.cuMemHostAlloc`.

    :py:obj:`~.cuMemHostGetDevicePointer()` will fail if the
    :py:obj:`~.CU_MEMHOSTALLOC_DEVICEMAP` flag was not specified at the
    time the memory was allocated, or if the function is called on a GPU
    that does not support mapped pinned memory.

    For devices that have a non-zero value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM`,
    the memory can also be accessed from the device using the host pointer
    `p`. The device pointer returned by
    :py:obj:`~.cuMemHostGetDevicePointer()` may or may not match the
    original host pointer `p` and depends on the devices visible to the
    application. If all devices visible to the application have a non-zero
    value for the device attribute, the device pointer returned by
    :py:obj:`~.cuMemHostGetDevicePointer()` will match the original pointer
    `p`. If any device visible to the application has a zero value for the
    device attribute, the device pointer returned by
    :py:obj:`~.cuMemHostGetDevicePointer()` will not match the original
    host pointer `p`, but it will be suitable for use on all devices
    provided Unified Virtual Addressing is enabled. In such systems, it is
    valid to access the memory using either pointer on devices that have a
    non-zero value for the device attribute. Note however that such devices
    should access the memory using only one of the two pointers and not
    both.

    `Flags` provides for future releases. For now, it must be set to 0.

    Parameters
    ----------
    p : Any
        Host pointer
    Flags : unsigned int
        Options (must be 0)

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pdptr : :py:obj:`~.CUdeviceptr`
        Returned device pointer

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaHostGetDevicePointer`
    """
    cdef CUdeviceptr pdptr = CUdeviceptr()
    cyp = _HelperInputVoidPtr(p)
    cdef void* cyp_ptr = <void*><void_ptr>cyp.cptr
    with nogil:
        err = cydriver.cuMemHostGetDevicePointer(<cydriver.CUdeviceptr*>pdptr._pvt_ptr, cyp_ptr, Flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pdptr)
{{endif}}

{{if 'cuMemHostGetFlags' in found_functions}}

@cython.embedsignature(True)
def cuMemHostGetFlags(p):
    """ Passes back flags that were used for a pinned allocation.

    Passes back the flags `pFlags` that were specified when allocating the
    pinned host buffer `p` allocated by :py:obj:`~.cuMemHostAlloc`.

    :py:obj:`~.cuMemHostGetFlags()` will fail if the pointer does not
    reside in an allocation performed by :py:obj:`~.cuMemAllocHost()` or
    :py:obj:`~.cuMemHostAlloc()`.

    Parameters
    ----------
    p : Any
        Host pointer

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pFlags : unsigned int
        Returned flags word

    See Also
    --------
    :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cudaHostGetFlags`
    """
    cdef unsigned int pFlags = 0
    cyp = _HelperInputVoidPtr(p)
    cdef void* cyp_ptr = <void*><void_ptr>cyp.cptr
    with nogil:
        err = cydriver.cuMemHostGetFlags(&pFlags, cyp_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pFlags)
{{endif}}

{{if 'cuMemAllocManaged' in found_functions}}

@cython.embedsignature(True)
def cuMemAllocManaged(size_t bytesize, unsigned int flags):
    """ Allocates memory that will be automatically managed by the Unified Memory system.

    Allocates `bytesize` bytes of managed memory on the device and returns
    in `*dptr` a pointer to the allocated memory. If the device doesn't
    support allocating managed memory, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    is returned. Support for managed memory can be queried using the device
    attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY`. The allocated
    memory is suitably aligned for any kind of variable. The memory is not
    cleared. If `bytesize` is 0, :py:obj:`~.cuMemAllocManaged` returns
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE`. The pointer is valid on the CPU
    and on all GPUs in the system that support managed memory. All accesses
    to this pointer must obey the Unified Memory programming model.

    `flags` specifies the default stream association for this allocation.
    `flags` must be one of :py:obj:`~.CU_MEM_ATTACH_GLOBAL` or
    :py:obj:`~.CU_MEM_ATTACH_HOST`. If :py:obj:`~.CU_MEM_ATTACH_GLOBAL` is
    specified, then this memory is accessible from any stream on any
    device. If :py:obj:`~.CU_MEM_ATTACH_HOST` is specified, then the
    allocation should not be accessed from devices that have a zero value
    for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`; an explicit
    call to :py:obj:`~.cuStreamAttachMemAsync` will be required to enable
    access on such devices.

    If the association is later changed via
    :py:obj:`~.cuStreamAttachMemAsync` to a single stream, the default
    association as specified during :py:obj:`~.cuMemAllocManaged` is
    restored when that stream is destroyed. For managed variables, the
    default association is always :py:obj:`~.CU_MEM_ATTACH_GLOBAL`. Note
    that destroying a stream is an asynchronous operation, and as a result,
    the change to default association won't happen until all work in the
    stream has completed.

    Memory allocated with :py:obj:`~.cuMemAllocManaged` should be released
    with :py:obj:`~.cuMemFree`.

    Device memory oversubscription is possible for GPUs that have a non-
    zero value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. Managed
    memory on such GPUs may be evicted from device memory to host memory at
    any time by the Unified Memory driver in order to make room for other
    allocations.

    In a system where all GPUs have a non-zero value for the device
    attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`,
    managed memory may not be populated when this API returns and instead
    may be populated on access. In such systems, managed memory can migrate
    to any processor's memory at any time. The Unified Memory driver will
    employ heuristics to maintain data locality and prevent excessive page
    faults to the extent possible. The application can also guide the
    driver about memory usage patterns via :py:obj:`~.cuMemAdvise`. The
    application can also explicitly migrate memory to a desired processor's
    memory via :py:obj:`~.cuMemPrefetchAsync`.

    In a multi-GPU system where all of the GPUs have a zero value for the
    device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` and all the
    GPUs have peer-to-peer support with each other, the physical storage
    for managed memory is created on the GPU which is active at the time
    :py:obj:`~.cuMemAllocManaged` is called. All other GPUs will reference
    the data at reduced bandwidth via peer mappings over the PCIe bus. The
    Unified Memory driver does not migrate memory among such GPUs.

    In a multi-GPU system where not all GPUs have peer-to-peer support with
    each other and where the value of the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` is zero for
    at least one of those GPUs, the location chosen for physical storage of
    managed memory is system-dependent.

    - On Linux, the location chosen will be device memory as long as the
      current set of active contexts are on devices that either have peer-
      to-peer support with each other or have a non-zero value for the
      device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. If there
      is an active context on a GPU that does not have a non-zero value for
      that device attribute and it does not have peer-to-peer support with
      the other devices that have active contexts on them, then the
      location for physical storage will be 'zero-copy' or host memory.
      Note that this means that managed memory that is located in device
      memory is migrated to host memory if a new context is created on a
      GPU that doesn't have a non-zero value for the device attribute and
      does not support peer-to-peer with at least one of the other devices
      that has an active context. This in turn implies that context
      creation may fail if there is insufficient host memory to migrate all
      managed allocations.

    - On Windows, the physical storage is always created in 'zero-copy' or
      host memory. All GPUs will reference the data at reduced bandwidth
      over the PCIe bus. In these circumstances, use of the environment
      variable CUDA_VISIBLE_DEVICES is recommended to restrict CUDA to only
      use those GPUs that have peer-to-peer support. Alternatively, users
      can also set CUDA_MANAGED_FORCE_DEVICE_ALLOC to a non-zero value to
      force the driver to always use device memory for physical storage.
      When this environment variable is set to a non-zero value, all
      contexts created in that process on devices that support managed
      memory have to be peer-to-peer compatible with each other. Context
      creation will fail if a context is created on a device that supports
      managed memory and is not peer-to-peer compatible with any of the
      other managed memory supporting devices on which contexts were
      previously created, even if those contexts have been destroyed. These
      environment variables are described in the CUDA programming guide
      under the "CUDA environment variables" section.

    - On ARM, managed memory is not available on discrete gpu with Drive
      PX-2.

    Parameters
    ----------
    bytesize : size_t
        Requested allocation size in bytes
    flags : unsigned int
        Must be one of :py:obj:`~.CU_MEM_ATTACH_GLOBAL` or
        :py:obj:`~.CU_MEM_ATTACH_HOST`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    dptr : :py:obj:`~.CUdeviceptr`
        Returned device pointer

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuStreamAttachMemAsync`, :py:obj:`~.cudaMallocManaged`
    """
    cdef CUdeviceptr dptr = CUdeviceptr()
    with nogil:
        err = cydriver.cuMemAllocManaged(<cydriver.CUdeviceptr*>dptr._pvt_ptr, bytesize, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], dptr)
{{endif}}

{{if 'cuDeviceRegisterAsyncNotification' in found_functions}}

ctypedef struct cuAsyncCallbackData_st:
    cydriver.CUasyncCallback callback
    void *userData

ctypedef cuAsyncCallbackData_st cuAsyncCallbackData

@cython.show_performance_hints(False)
cdef void cuAsyncNotificationCallbackWrapper(cydriver.CUasyncNotificationInfo *info, void *data, cydriver.CUasyncCallbackHandle handle) nogil:
    cdef cuAsyncCallbackData *cbData = <cuAsyncCallbackData *>data
    with gil:
        cbData.callback(info, cbData.userData, handle)

@cython.embedsignature(True)
def cuDeviceRegisterAsyncNotification(device, callbackFunc, userData):
    """ Registers a callback function to receive async notifications.

    Registers `callbackFunc` to receive async notifications.

    The `userData` parameter is passed to the callback function at async
    notification time.   Likewise, `callback` is also passed to the
    callback function to distinguish between multiple registered callbacks.

    The callback function being registered should be designed to return
    quickly (~10ms).   Any long running tasks should be queued for
    execution on an application thread.

    Callbacks may not call cuDeviceRegisterAsyncNotification or
    cuDeviceUnregisterAsyncNotification. Doing so will result in
    :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`. Async notification callbacks
    execute in an undefined order and may be serialized.

    Returns in `*callback` a handle representing the registered callback
    instance.

    Parameters
    ----------
    device : :py:obj:`~.CUdevice`
        The device on which to register the callback
    callbackFunc : :py:obj:`~.CUasyncCallback`
        The function to register as a callback
    userData : Any
        A generic pointer to user data. This is passed into the callback
        function.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    callback : :py:obj:`~.CUasyncCallbackHandle`
        A handle representing the registered callback instance

    See Also
    --------
    :py:obj:`~.cuDeviceUnregisterAsyncNotification`
    """
    cdef cydriver.CUasyncCallback cycallbackFunc
    if callbackFunc is None:
        pcallbackFunc = 0
    elif isinstance(callbackFunc, (CUasyncCallback,)):
        pcallbackFunc = int(callbackFunc)
    else:
        pcallbackFunc = int(CUasyncCallback(callbackFunc))
    cycallbackFunc = <cydriver.CUasyncCallback><void_ptr>pcallbackFunc
    cdef cydriver.CUdevice cydevice
    if device is None:
        pdevice = 0
    elif isinstance(device, (CUdevice,)):
        pdevice = int(device)
    else:
        pdevice = int(CUdevice(device))
    cydevice = <cydriver.CUdevice>pdevice
    cyuserData = _HelperInputVoidPtr(userData)
    cdef void* cyuserData_ptr = <void*><void_ptr>cyuserData.cptr

    cdef cuAsyncCallbackData *cbData = NULL
    cbData = <cuAsyncCallbackData *>malloc(sizeof(cbData[0]))
    if cbData == NULL:
        return (CUresult.CUDA_ERROR_OUT_OF_MEMORY, None)
    cbData.callback = cycallbackFunc
    cbData.userData = cyuserData_ptr

    cdef CUasyncCallbackHandle callback = CUasyncCallbackHandle()
    with nogil:
        err = cydriver.cuDeviceRegisterAsyncNotification(cydevice, <cydriver.CUasyncCallback>cuAsyncNotificationCallbackWrapper, <void *>cbData, <cydriver.CUasyncCallbackHandle*>callback._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        free(cbData)
    else:
        m_global._allocated[int(callback)] = cbData
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], callback)
{{endif}}

{{if 'cuDeviceUnregisterAsyncNotification' in found_functions}}

@cython.embedsignature(True)
def cuDeviceUnregisterAsyncNotification(device, callback):
    """ Unregisters an async notification callback.

    Unregisters `callback` so that the corresponding callback function will
    stop receiving async notifications.

    Parameters
    ----------
    device : :py:obj:`~.CUdevice`
        The device from which to remove `callback`.
    callback : :py:obj:`~.CUasyncCallbackHandle`
        The callback instance to unregister from receiving async
        notifications.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_UNKNOWN`

    See Also
    --------
    :py:obj:`~.cuDeviceRegisterAsyncNotification`
    """
    cdef cydriver.CUasyncCallbackHandle cycallback
    if callback is None:
        pcallback = 0
    elif isinstance(callback, (CUasyncCallbackHandle,)):
        pcallback = int(callback)
    else:
        pcallback = int(CUasyncCallbackHandle(callback))
    cycallback = <cydriver.CUasyncCallbackHandle><void_ptr>pcallback
    cdef cydriver.CUdevice cydevice
    if device is None:
        pdevice = 0
    elif isinstance(device, (CUdevice,)):
        pdevice = int(device)
    else:
        pdevice = int(CUdevice(device))
    cydevice = <cydriver.CUdevice>pdevice
    with nogil:
        err = cydriver.cuDeviceUnregisterAsyncNotification(cydevice, cycallback)
    if err == cydriver.CUDA_SUCCESS:
        free(m_global._allocated[pcallback])
        m_global._allocated.erase(<void_ptr>pcallback)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuDeviceGetByPCIBusId' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetByPCIBusId(char* pciBusId):
    """ Returns a handle to a compute device.

    Returns in `*device` a device handle given a PCI bus ID string.

    where `domain`, `bus`, `device`, and `function` are all hexadecimal
    values

    Parameters
    ----------
    pciBusId : bytes
        String in one of the following forms:

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    dev : :py:obj:`~.CUdevice`
        Returned device handle

    See Also
    --------
    :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetPCIBusId`, :py:obj:`~.cudaDeviceGetByPCIBusId`
    """
    cdef CUdevice dev = CUdevice()
    with nogil:
        err = cydriver.cuDeviceGetByPCIBusId(<cydriver.CUdevice*>dev._pvt_ptr, pciBusId)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], dev)
{{endif}}

{{if 'cuDeviceGetPCIBusId' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetPCIBusId(int length, dev):
    """ Returns a PCI Bus Id string for the device.

    Returns an ASCII string identifying the device `dev` in the NULL-
    terminated string pointed to by `pciBusId`. `length` specifies the
    maximum length of the string that may be returned.

    where `domain`, `bus`, `device`, and `function` are all hexadecimal
    values. pciBusId should be large enough to store 13 characters
    including the NULL-terminator.

    Parameters
    ----------
    length : int
        Maximum length of string to store in `name`
    dev : :py:obj:`~.CUdevice`
        Device to get identifier string for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    pciBusId : bytes
        Returned identifier string for the device in the following format

    See Also
    --------
    :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetByPCIBusId`, :py:obj:`~.cudaDeviceGetPCIBusId`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    pypciBusId = b" " * length
    cdef char* pciBusId = pypciBusId
    with nogil:
        err = cydriver.cuDeviceGetPCIBusId(pciBusId, length, cydev)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pypciBusId)
{{endif}}

{{if 'cuIpcGetEventHandle' in found_functions}}

@cython.embedsignature(True)
def cuIpcGetEventHandle(event):
    """ Gets an interprocess handle for a previously allocated event.

    Takes as input a previously allocated event. This event must have been
    created with the :py:obj:`~.CU_EVENT_INTERPROCESS` and
    :py:obj:`~.CU_EVENT_DISABLE_TIMING` flags set. This opaque handle may
    be copied into other processes and opened with
    :py:obj:`~.cuIpcOpenEventHandle` to allow efficient hardware
    synchronization between GPU work in different processes.

    After the event has been opened in the importing process,
    :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventSynchronize`,
    :py:obj:`~.cuStreamWaitEvent` and :py:obj:`~.cuEventQuery` may be used
    in either process. Performing operations on the imported event after
    the exported event has been freed with :py:obj:`~.cuEventDestroy` will
    result in undefined behavior.

    IPC functionality is restricted to devices with support for unified
    addressing on Linux and Windows operating systems. IPC functionality on
    Windows is supported for compatibility purposes but not recommended as
    it comes with performance cost. Users can test their device for IPC
    functionality by calling :py:obj:`~.cuDeviceGetAttribute` with
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED`

    Parameters
    ----------
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event allocated with :py:obj:`~.CU_EVENT_INTERPROCESS` and
        :py:obj:`~.CU_EVENT_DISABLE_TIMING` flags.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_MAP_FAILED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pHandle : :py:obj:`~.CUipcEventHandle`
        Pointer to a user allocated CUipcEventHandle in which to return the
        opaque event handle

    See Also
    --------
    :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuIpcOpenEventHandle`, :py:obj:`~.cuIpcGetMemHandle`, :py:obj:`~.cuIpcOpenMemHandle`, :py:obj:`~.cuIpcCloseMemHandle`, :py:obj:`~.cudaIpcGetEventHandle`
    """
    cdef cydriver.CUevent cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (CUevent,)):
        pevent = int(event)
    else:
        pevent = int(CUevent(event))
    cyevent = <cydriver.CUevent><void_ptr>pevent
    cdef CUipcEventHandle pHandle = CUipcEventHandle()
    with nogil:
        err = cydriver.cuIpcGetEventHandle(<cydriver.CUipcEventHandle*>pHandle._pvt_ptr, cyevent)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pHandle)
{{endif}}

{{if 'cuIpcOpenEventHandle' in found_functions}}

@cython.embedsignature(True)
def cuIpcOpenEventHandle(handle not None : CUipcEventHandle):
    """ Opens an interprocess event handle for use in the current process.

    Opens an interprocess event handle exported from another process with
    :py:obj:`~.cuIpcGetEventHandle`. This function returns a
    :py:obj:`~.CUevent` that behaves like a locally created event with the
    :py:obj:`~.CU_EVENT_DISABLE_TIMING` flag specified. This event must be
    freed with :py:obj:`~.cuEventDestroy`.

    Performing operations on the imported event after the exported event
    has been freed with :py:obj:`~.cuEventDestroy` will result in undefined
    behavior.

    IPC functionality is restricted to devices with support for unified
    addressing on Linux and Windows operating systems. IPC functionality on
    Windows is supported for compatibility purposes but not recommended as
    it comes with performance cost. Users can test their device for IPC
    functionality by calling :py:obj:`~.cuapiDeviceGetAttribute` with
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED`

    Parameters
    ----------
    handle : :py:obj:`~.CUipcEventHandle`
        Interprocess handle to open

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_MAP_FAILED`, :py:obj:`~.CUDA_ERROR_PEER_ACCESS_UNSUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phEvent : :py:obj:`~.CUevent`
        Returns the imported event

    See Also
    --------
    :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuIpcGetEventHandle`, :py:obj:`~.cuIpcGetMemHandle`, :py:obj:`~.cuIpcOpenMemHandle`, :py:obj:`~.cuIpcCloseMemHandle`, :py:obj:`~.cudaIpcOpenEventHandle`
    """
    cdef CUevent phEvent = CUevent()
    with nogil:
        err = cydriver.cuIpcOpenEventHandle(<cydriver.CUevent*>phEvent._pvt_ptr, handle._pvt_ptr[0])
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phEvent)
{{endif}}

{{if 'cuIpcGetMemHandle' in found_functions}}

@cython.embedsignature(True)
def cuIpcGetMemHandle(dptr):
    """ Gets an interprocess memory handle for an existing device memory allocation.

    Takes a pointer to the base of an existing device memory allocation
    created with :py:obj:`~.cuMemAlloc` and exports it for use in another
    process. This is a lightweight operation and may be called multiple
    times on an allocation without adverse effects.

    If a region of memory is freed with :py:obj:`~.cuMemFree` and a
    subsequent call to :py:obj:`~.cuMemAlloc` returns memory with the same
    device address, :py:obj:`~.cuIpcGetMemHandle` will return a unique
    handle for the new memory.

    IPC functionality is restricted to devices with support for unified
    addressing on Linux and Windows operating systems. IPC functionality on
    Windows is supported for compatibility purposes but not recommended as
    it comes with performance cost. Users can test their device for IPC
    functionality by calling :py:obj:`~.cuapiDeviceGetAttribute` with
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED`

    Parameters
    ----------
    dptr : :py:obj:`~.CUdeviceptr`
        Base pointer to previously allocated device memory

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_MAP_FAILED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pHandle : :py:obj:`~.CUipcMemHandle`
        Pointer to user allocated :py:obj:`~.CUipcMemHandle` to return the
        handle in.

    See Also
    --------
    :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuIpcGetEventHandle`, :py:obj:`~.cuIpcOpenEventHandle`, :py:obj:`~.cuIpcOpenMemHandle`, :py:obj:`~.cuIpcCloseMemHandle`, :py:obj:`~.cudaIpcGetMemHandle`
    """
    cdef cydriver.CUdeviceptr cydptr
    if dptr is None:
        pdptr = 0
    elif isinstance(dptr, (CUdeviceptr,)):
        pdptr = int(dptr)
    else:
        pdptr = int(CUdeviceptr(dptr))
    cydptr = <cydriver.CUdeviceptr><void_ptr>pdptr
    cdef CUipcMemHandle pHandle = CUipcMemHandle()
    with nogil:
        err = cydriver.cuIpcGetMemHandle(<cydriver.CUipcMemHandle*>pHandle._pvt_ptr, cydptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pHandle)
{{endif}}

{{if 'cuIpcOpenMemHandle_v2' in found_functions}}

@cython.embedsignature(True)
def cuIpcOpenMemHandle(handle not None : CUipcMemHandle, unsigned int Flags):
    """ Opens an interprocess memory handle exported from another process and returns a device pointer usable in the local process.

    Maps memory exported from another process with
    :py:obj:`~.cuIpcGetMemHandle` into the current device address space.
    For contexts on different devices :py:obj:`~.cuIpcOpenMemHandle` can
    attempt to enable peer access between the devices as if the user called
    :py:obj:`~.cuCtxEnablePeerAccess`. This behavior is controlled by the
    :py:obj:`~.CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS` flag.
    :py:obj:`~.cuDeviceCanAccessPeer` can determine if a mapping is
    possible.

    Contexts that may open :py:obj:`~.CUipcMemHandles` are restricted in
    the following way. :py:obj:`~.CUipcMemHandles` from each
    :py:obj:`~.CUdevice` in a given process may only be opened by one
    :py:obj:`~.CUcontext` per :py:obj:`~.CUdevice` per other process.

    If the memory handle has already been opened by the current context,
    the reference count on the handle is incremented by 1 and the existing
    device pointer is returned.

    Memory returned from :py:obj:`~.cuIpcOpenMemHandle` must be freed with
    :py:obj:`~.cuIpcCloseMemHandle`.

    Calling :py:obj:`~.cuMemFree` on an exported memory region before
    calling :py:obj:`~.cuIpcCloseMemHandle` in the importing context will
    result in undefined behavior.

    IPC functionality is restricted to devices with support for unified
    addressing on Linux and Windows operating systems. IPC functionality on
    Windows is supported for compatibility purposes but not recommended as
    it comes with performance cost. Users can test their device for IPC
    functionality by calling :py:obj:`~.cuapiDeviceGetAttribute` with
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED`

    Parameters
    ----------
    handle : :py:obj:`~.CUipcMemHandle`
        :py:obj:`~.CUipcMemHandle` to open
    Flags : unsigned int
        Flags for this operation. Must be specified as
        :py:obj:`~.CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_MAP_FAILED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_TOO_MANY_PEERS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pdptr : :py:obj:`~.CUdeviceptr`
        Returned device pointer

    See Also
    --------
    :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuIpcGetEventHandle`, :py:obj:`~.cuIpcOpenEventHandle`, :py:obj:`~.cuIpcGetMemHandle`, :py:obj:`~.cuIpcCloseMemHandle`, :py:obj:`~.cuCtxEnablePeerAccess`, :py:obj:`~.cuDeviceCanAccessPeer`, :py:obj:`~.cudaIpcOpenMemHandle`

    Notes
    -----
    No guarantees are made about the address returned in `*pdptr`. In particular, multiple processes may not receive the same address for the same `handle`.
    """
    cdef CUdeviceptr pdptr = CUdeviceptr()
    with nogil:
        err = cydriver.cuIpcOpenMemHandle(<cydriver.CUdeviceptr*>pdptr._pvt_ptr, handle._pvt_ptr[0], Flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pdptr)
{{endif}}

{{if 'cuIpcCloseMemHandle' in found_functions}}

@cython.embedsignature(True)
def cuIpcCloseMemHandle(dptr):
    """ Attempts to close memory mapped with :py:obj:`~.cuIpcOpenMemHandle`.

    Decrements the reference count of the memory returned by
    :py:obj:`~.cuIpcOpenMemHandle` by 1. When the reference count reaches
    0, this API unmaps the memory. The original allocation in the exporting
    process as well as imported mappings in other processes will be
    unaffected.

    Any resources used to enable peer access will be freed if this is the
    last mapping using them.

    IPC functionality is restricted to devices with support for unified
    addressing on Linux and Windows operating systems. IPC functionality on
    Windows is supported for compatibility purposes but not recommended as
    it comes with performance cost. Users can test their device for IPC
    functionality by calling :py:obj:`~.cuapiDeviceGetAttribute` with
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED`

    Parameters
    ----------
    dptr : :py:obj:`~.CUdeviceptr`
        Device pointer returned by :py:obj:`~.cuIpcOpenMemHandle`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_MAP_FAILED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuIpcGetEventHandle`, :py:obj:`~.cuIpcOpenEventHandle`, :py:obj:`~.cuIpcGetMemHandle`, :py:obj:`~.cuIpcOpenMemHandle`, :py:obj:`~.cudaIpcCloseMemHandle`
    """
    cdef cydriver.CUdeviceptr cydptr
    if dptr is None:
        pdptr = 0
    elif isinstance(dptr, (CUdeviceptr,)):
        pdptr = int(dptr)
    else:
        pdptr = int(CUdeviceptr(dptr))
    cydptr = <cydriver.CUdeviceptr><void_ptr>pdptr
    with nogil:
        err = cydriver.cuIpcCloseMemHandle(cydptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemHostRegister_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemHostRegister(p, size_t bytesize, unsigned int Flags):
    """ Registers an existing host memory range for use by CUDA.

    Page-locks the memory range specified by `p` and `bytesize` and maps it
    for the device(s) as specified by `Flags`. This memory range also is
    added to the same tracking mechanism as :py:obj:`~.cuMemHostAlloc` to
    automatically accelerate calls to functions such as
    :py:obj:`~.cuMemcpyHtoD()`. Since the memory can be accessed directly
    by the device, it can be read or written with much higher bandwidth
    than pageable memory that has not been registered. Page-locking
    excessive amounts of memory may degrade system performance, since it
    reduces the amount of memory available to the system for paging. As a
    result, this function is best used sparingly to register staging areas
    for data exchange between host and device.

    On systems where
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`
    is true, :py:obj:`~.cuMemHostRegister` will not page-lock the memory
    range specified by `ptr` but only populate unpopulated pages.

    The `Flags` parameter enables different options to be specified that
    affect the allocation, as follows.

    - :py:obj:`~.CU_MEMHOSTREGISTER_PORTABLE`: The memory returned by this
      call will be considered as pinned memory by all CUDA contexts, not
      just the one that performed the allocation.

    - :py:obj:`~.CU_MEMHOSTREGISTER_DEVICEMAP`: Maps the allocation into
      the CUDA address space. The device pointer to the memory may be
      obtained by calling :py:obj:`~.cuMemHostGetDevicePointer()`.

    - :py:obj:`~.CU_MEMHOSTREGISTER_IOMEMORY`: The pointer is treated as
      pointing to some I/O memory space, e.g. the PCI Express resource of a
      3rd party device.

    - :py:obj:`~.CU_MEMHOSTREGISTER_READ_ONLY`: The pointer is treated as
      pointing to memory that is considered read-only by the device. On
      platforms without
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
      this flag is required in order to register memory mapped to the CPU
      as read-only. Support for the use of this flag can be queried from
      the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED`.
      Using this flag with a current context associated with a device that
      does not have this attribute set will cause
      :py:obj:`~.cuMemHostRegister` to error with CUDA_ERROR_NOT_SUPPORTED.

    All of these flags are orthogonal to one another: a developer may page-
    lock memory that is portable or mapped with no restrictions.

    The :py:obj:`~.CU_MEMHOSTREGISTER_DEVICEMAP` flag may be specified on
    CUDA contexts for devices that do not support mapped pinned memory. The
    failure is deferred to :py:obj:`~.cuMemHostGetDevicePointer()` because
    the memory may be mapped into other CUDA contexts via the
    :py:obj:`~.CU_MEMHOSTREGISTER_PORTABLE` flag.

    For devices that have a non-zero value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM`,
    the memory can also be accessed from the device using the host pointer
    `p`. The device pointer returned by
    :py:obj:`~.cuMemHostGetDevicePointer()` may or may not match the
    original host pointer `ptr` and depends on the devices visible to the
    application. If all devices visible to the application have a non-zero
    value for the device attribute, the device pointer returned by
    :py:obj:`~.cuMemHostGetDevicePointer()` will match the original pointer
    `ptr`. If any device visible to the application has a zero value for
    the device attribute, the device pointer returned by
    :py:obj:`~.cuMemHostGetDevicePointer()` will not match the original
    host pointer `ptr`, but it will be suitable for use on all devices
    provided Unified Virtual Addressing is enabled. In such systems, it is
    valid to access the memory using either pointer on devices that have a
    non-zero value for the device attribute. Note however that such devices
    should access the memory using only of the two pointers and not both.

    The memory page-locked by this function must be unregistered with
    :py:obj:`~.cuMemHostUnregister()`.

    Parameters
    ----------
    p : Any
        Host pointer to memory to page-lock
    bytesize : size_t
        Size in bytes of the address range to page-lock
    Flags : unsigned int
        Flags for allocation request

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuMemHostUnregister`, :py:obj:`~.cuMemHostGetFlags`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cudaHostRegister`
    """
    cyp = _HelperInputVoidPtr(p)
    cdef void* cyp_ptr = <void*><void_ptr>cyp.cptr
    with nogil:
        err = cydriver.cuMemHostRegister(cyp_ptr, bytesize, Flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemHostUnregister' in found_functions}}

@cython.embedsignature(True)
def cuMemHostUnregister(p):
    """ Unregisters a memory range that was registered with cuMemHostRegister.

    Unmaps the memory range whose base address is specified by `p`, and
    makes it pageable again.

    The base address must be the same one specified to
    :py:obj:`~.cuMemHostRegister()`.

    Parameters
    ----------
    p : Any
        Host pointer to memory to unregister

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED`,

    See Also
    --------
    :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cudaHostUnregister`
    """
    cyp = _HelperInputVoidPtr(p)
    cdef void* cyp_ptr = <void*><void_ptr>cyp.cptr
    with nogil:
        err = cydriver.cuMemHostUnregister(cyp_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpy' in found_functions}}

@cython.embedsignature(True)
def cuMemcpy(dst, src, size_t ByteCount):
    """ Copies memory.

    Copies data between two pointers. `dst` and `src` are base pointers of
    the destination and source, respectively. `ByteCount` specifies the
    number of bytes to copy. Note that this function infers the type of the
    transfer (host to host, host to device, device to device, or device to
    host) from the pointer values. This function is only allowed in
    contexts which support unified addressing.

    Parameters
    ----------
    dst : :py:obj:`~.CUdeviceptr`
        Destination unified virtual address space pointer
    src : :py:obj:`~.CUdeviceptr`
        Source unified virtual address space pointer
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`
    """
    cdef cydriver.CUdeviceptr cysrc
    if src is None:
        psrc = 0
    elif isinstance(src, (CUdeviceptr,)):
        psrc = int(src)
    else:
        psrc = int(CUdeviceptr(src))
    cysrc = <cydriver.CUdeviceptr><void_ptr>psrc
    cdef cydriver.CUdeviceptr cydst
    if dst is None:
        pdst = 0
    elif isinstance(dst, (CUdeviceptr,)):
        pdst = int(dst)
    else:
        pdst = int(CUdeviceptr(dst))
    cydst = <cydriver.CUdeviceptr><void_ptr>pdst
    with nogil:
        err = cydriver.cuMemcpy(cydst, cysrc, ByteCount)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpyPeer' in found_functions}}

@cython.embedsignature(True)
def cuMemcpyPeer(dstDevice, dstContext, srcDevice, srcContext, size_t ByteCount):
    """ Copies device memory between two contexts.

    Copies from device memory in one context to device memory in another
    context. `dstDevice` is the base device pointer of the destination
    memory and `dstContext` is the destination context. `srcDevice` is the
    base device pointer of the source memory and `srcContext` is the source
    pointer. `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    dstContext : :py:obj:`~.CUcontext`
        Destination context
    srcDevice : :py:obj:`~.CUdeviceptr`
        Source device pointer
    srcContext : :py:obj:`~.CUcontext`
        Source context
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpy3DPeer`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyPeerAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cudaMemcpyPeer`
    """
    cdef cydriver.CUcontext cysrcContext
    if srcContext is None:
        psrcContext = 0
    elif isinstance(srcContext, (CUcontext,)):
        psrcContext = int(srcContext)
    else:
        psrcContext = int(CUcontext(srcContext))
    cysrcContext = <cydriver.CUcontext><void_ptr>psrcContext
    cdef cydriver.CUdeviceptr cysrcDevice
    if srcDevice is None:
        psrcDevice = 0
    elif isinstance(srcDevice, (CUdeviceptr,)):
        psrcDevice = int(srcDevice)
    else:
        psrcDevice = int(CUdeviceptr(srcDevice))
    cysrcDevice = <cydriver.CUdeviceptr><void_ptr>psrcDevice
    cdef cydriver.CUcontext cydstContext
    if dstContext is None:
        pdstContext = 0
    elif isinstance(dstContext, (CUcontext,)):
        pdstContext = int(dstContext)
    else:
        pdstContext = int(CUcontext(dstContext))
    cydstContext = <cydriver.CUcontext><void_ptr>pdstContext
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    with nogil:
        err = cydriver.cuMemcpyPeer(cydstDevice, cydstContext, cysrcDevice, cysrcContext, ByteCount)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpyHtoD_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpyHtoD(dstDevice, srcHost, size_t ByteCount):
    """ Copies memory from Host to Device.

    Copies from host memory to device memory. `dstDevice` and `srcHost` are
    the base addresses of the destination and source, respectively.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    srcHost : Any
        Source host pointer
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyToSymbol`
    """
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    cysrcHost = _HelperInputVoidPtr(srcHost)
    cdef void* cysrcHost_ptr = <void*><void_ptr>cysrcHost.cptr
    with nogil:
        err = cydriver.cuMemcpyHtoD(cydstDevice, cysrcHost_ptr, ByteCount)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpyDtoH_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpyDtoH(dstHost, srcDevice, size_t ByteCount):
    """ Copies memory from Device to Host.

    Copies from device to host memory. `dstHost` and `srcDevice` specify
    the base pointers of the destination and source, respectively.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstHost : Any
        Destination host pointer
    srcDevice : :py:obj:`~.CUdeviceptr`
        Source device pointer
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyFromSymbol`
    """
    cdef cydriver.CUdeviceptr cysrcDevice
    if srcDevice is None:
        psrcDevice = 0
    elif isinstance(srcDevice, (CUdeviceptr,)):
        psrcDevice = int(srcDevice)
    else:
        psrcDevice = int(CUdeviceptr(srcDevice))
    cysrcDevice = <cydriver.CUdeviceptr><void_ptr>psrcDevice
    cydstHost = _HelperInputVoidPtr(dstHost)
    cdef void* cydstHost_ptr = <void*><void_ptr>cydstHost.cptr
    with nogil:
        err = cydriver.cuMemcpyDtoH(cydstHost_ptr, cysrcDevice, ByteCount)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpyDtoD_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpyDtoD(dstDevice, srcDevice, size_t ByteCount):
    """ Copies memory from Device to Device.

    Copies from device memory to device memory. `dstDevice` and `srcDevice`
    are the base pointers of the destination and source, respectively.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    srcDevice : :py:obj:`~.CUdeviceptr`
        Source device pointer
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`
    """
    cdef cydriver.CUdeviceptr cysrcDevice
    if srcDevice is None:
        psrcDevice = 0
    elif isinstance(srcDevice, (CUdeviceptr,)):
        psrcDevice = int(srcDevice)
    else:
        psrcDevice = int(CUdeviceptr(srcDevice))
    cysrcDevice = <cydriver.CUdeviceptr><void_ptr>psrcDevice
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    with nogil:
        err = cydriver.cuMemcpyDtoD(cydstDevice, cysrcDevice, ByteCount)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpyDtoA_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpyDtoA(dstArray, size_t dstOffset, srcDevice, size_t ByteCount):
    """ Copies memory from Device to Array.

    Copies from device memory to a 1D CUDA array. `dstArray` and
    `dstOffset` specify the CUDA array handle and starting index of the
    destination data. `srcDevice` specifies the base pointer of the source.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstArray : :py:obj:`~.CUarray`
        Destination array
    dstOffset : size_t
        Offset in bytes of destination array
    srcDevice : :py:obj:`~.CUdeviceptr`
        Source device pointer
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpyToArray`
    """
    cdef cydriver.CUdeviceptr cysrcDevice
    if srcDevice is None:
        psrcDevice = 0
    elif isinstance(srcDevice, (CUdeviceptr,)):
        psrcDevice = int(srcDevice)
    else:
        psrcDevice = int(CUdeviceptr(srcDevice))
    cysrcDevice = <cydriver.CUdeviceptr><void_ptr>psrcDevice
    cdef cydriver.CUarray cydstArray
    if dstArray is None:
        pdstArray = 0
    elif isinstance(dstArray, (CUarray,)):
        pdstArray = int(dstArray)
    else:
        pdstArray = int(CUarray(dstArray))
    cydstArray = <cydriver.CUarray><void_ptr>pdstArray
    with nogil:
        err = cydriver.cuMemcpyDtoA(cydstArray, dstOffset, cysrcDevice, ByteCount)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpyAtoD_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpyAtoD(dstDevice, srcArray, size_t srcOffset, size_t ByteCount):
    """ Copies memory from Array to Device.

    Copies from one 1D CUDA array to device memory. `dstDevice` specifies
    the base pointer of the destination and must be naturally aligned with
    the CUDA array elements. `srcArray` and `srcOffset` specify the CUDA
    array handle and the offset in bytes into the array where the copy is
    to begin. `ByteCount` specifies the number of bytes to copy and must be
    evenly divisible by the array element size.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    srcArray : :py:obj:`~.CUarray`
        Source array
    srcOffset : size_t
        Offset in bytes of source array
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpyFromArray`
    """
    cdef cydriver.CUarray cysrcArray
    if srcArray is None:
        psrcArray = 0
    elif isinstance(srcArray, (CUarray,)):
        psrcArray = int(srcArray)
    else:
        psrcArray = int(CUarray(srcArray))
    cysrcArray = <cydriver.CUarray><void_ptr>psrcArray
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    with nogil:
        err = cydriver.cuMemcpyAtoD(cydstDevice, cysrcArray, srcOffset, ByteCount)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpyHtoA_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpyHtoA(dstArray, size_t dstOffset, srcHost, size_t ByteCount):
    """ Copies memory from Host to Array.

    Copies from host memory to a 1D CUDA array. `dstArray` and `dstOffset`
    specify the CUDA array handle and starting offset in bytes of the
    destination data. `pSrc` specifies the base address of the source.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstArray : :py:obj:`~.CUarray`
        Destination array
    dstOffset : size_t
        Offset in bytes of destination array
    srcHost : Any
        Source host pointer
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpyToArray`
    """
    cdef cydriver.CUarray cydstArray
    if dstArray is None:
        pdstArray = 0
    elif isinstance(dstArray, (CUarray,)):
        pdstArray = int(dstArray)
    else:
        pdstArray = int(CUarray(dstArray))
    cydstArray = <cydriver.CUarray><void_ptr>pdstArray
    cysrcHost = _HelperInputVoidPtr(srcHost)
    cdef void* cysrcHost_ptr = <void*><void_ptr>cysrcHost.cptr
    with nogil:
        err = cydriver.cuMemcpyHtoA(cydstArray, dstOffset, cysrcHost_ptr, ByteCount)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpyAtoH_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpyAtoH(dstHost, srcArray, size_t srcOffset, size_t ByteCount):
    """ Copies memory from Array to Host.

    Copies from one 1D CUDA array to host memory. `dstHost` specifies the
    base pointer of the destination. `srcArray` and `srcOffset` specify the
    CUDA array handle and starting offset in bytes of the source data.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstHost : Any
        Destination device pointer
    srcArray : :py:obj:`~.CUarray`
        Source array
    srcOffset : size_t
        Offset in bytes of source array
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpyFromArray`
    """
    cdef cydriver.CUarray cysrcArray
    if srcArray is None:
        psrcArray = 0
    elif isinstance(srcArray, (CUarray,)):
        psrcArray = int(srcArray)
    else:
        psrcArray = int(CUarray(srcArray))
    cysrcArray = <cydriver.CUarray><void_ptr>psrcArray
    cydstHost = _HelperInputVoidPtr(dstHost)
    cdef void* cydstHost_ptr = <void*><void_ptr>cydstHost.cptr
    with nogil:
        err = cydriver.cuMemcpyAtoH(cydstHost_ptr, cysrcArray, srcOffset, ByteCount)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpyAtoA_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpyAtoA(dstArray, size_t dstOffset, srcArray, size_t srcOffset, size_t ByteCount):
    """ Copies memory from Array to Array.

    Copies from one 1D CUDA array to another. `dstArray` and `srcArray`
    specify the handles of the destination and source CUDA arrays for the
    copy, respectively. `dstOffset` and `srcOffset` specify the destination
    and source offsets in bytes into the CUDA arrays. `ByteCount` is the
    number of bytes to be copied. The size of the elements in the CUDA
    arrays need not be the same format, but the elements must be the same
    size; and count must be evenly divisible by that size.

    Parameters
    ----------
    dstArray : :py:obj:`~.CUarray`
        Destination array
    dstOffset : size_t
        Offset in bytes of destination array
    srcArray : :py:obj:`~.CUarray`
        Source array
    srcOffset : size_t
        Offset in bytes of source array
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpyArrayToArray`
    """
    cdef cydriver.CUarray cysrcArray
    if srcArray is None:
        psrcArray = 0
    elif isinstance(srcArray, (CUarray,)):
        psrcArray = int(srcArray)
    else:
        psrcArray = int(CUarray(srcArray))
    cysrcArray = <cydriver.CUarray><void_ptr>psrcArray
    cdef cydriver.CUarray cydstArray
    if dstArray is None:
        pdstArray = 0
    elif isinstance(dstArray, (CUarray,)):
        pdstArray = int(dstArray)
    else:
        pdstArray = int(CUarray(dstArray))
    cydstArray = <cydriver.CUarray><void_ptr>pdstArray
    with nogil:
        err = cydriver.cuMemcpyAtoA(cydstArray, dstOffset, cysrcArray, srcOffset, ByteCount)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpy2D_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpy2D(pCopy : Optional[CUDA_MEMCPY2D]):
    """ Copies memory for 2D arrays.

    Perform a 2D memory copy according to the parameters specified in
    `pCopy`. The :py:obj:`~.CUDA_MEMCPY2D` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.srcMemoryType` and :py:obj:`~.dstMemoryType` specify the
      type of memory of the source and destination, respectively;
      :py:obj:`~.CUmemorytype_enum` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.srcArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.srcHost` and :py:obj:`~.srcPitch` specify the (host) base
    address of the source data and the bytes per row to apply.
    :py:obj:`~.srcArray` is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (device)
    base address of the source data and the bytes per row to apply.
    :py:obj:`~.srcArray` is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.srcArray` specifies the handle of the source data.
    :py:obj:`~.srcHost`, :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` are
    ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.dstHost` and :py:obj:`~.dstPitch` specify the (host) base
    address of the destination data and the bytes per row to apply.
    :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.dstArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (device)
    base address of the destination data and the bytes per row to apply.
    :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.dstArray` specifies the handle of the destination data.
    :py:obj:`~.dstHost`, :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` are
    ignored.

    - :py:obj:`~.srcXInBytes` and :py:obj:`~.srcY` specify the base address
      of the source data for the copy.

    For host pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.srcXInBytes` must be evenly divisible by
    the array element size.

    - :py:obj:`~.dstXInBytes` and :py:obj:`~.dstY` specify the base address
      of the destination data for the copy.

    For host pointers, the base address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.dstXInBytes` must be evenly divisible by
    the array element size.

    - :py:obj:`~.WidthInBytes` and :py:obj:`~.Height` specify the width (in
      bytes) and height of the 2D copy being performed.

    - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
      :py:obj:`~.dstPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + dstXInBytes.

    :py:obj:`~.cuMemcpy2D()` returns an error if any pitch is greater than
    the maximum allowed (:py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PITCH`).
    :py:obj:`~.cuMemAllocPitch()` passes back pitches that always work with
    :py:obj:`~.cuMemcpy2D()`. On intra-device memory copies (device to
    device, CUDA array to device, CUDA array to CUDA array),
    :py:obj:`~.cuMemcpy2D()` may fail for pitches not computed by
    :py:obj:`~.cuMemAllocPitch()`. :py:obj:`~.cuMemcpy2DUnaligned()` does
    not have this restriction, but may run significantly slower in the
    cases where :py:obj:`~.cuMemcpy2D()` would have returned an error code.

    Parameters
    ----------
    pCopy : :py:obj:`~.CUDA_MEMCPY2D`
        Parameters for the memory copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpy2DFromArray`
    """
    cdef cydriver.CUDA_MEMCPY2D* cypCopy_ptr = pCopy._pvt_ptr if pCopy is not None else NULL
    with nogil:
        err = cydriver.cuMemcpy2D(cypCopy_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpy2DUnaligned_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpy2DUnaligned(pCopy : Optional[CUDA_MEMCPY2D]):
    """ Copies memory for 2D arrays.

    Perform a 2D memory copy according to the parameters specified in
    `pCopy`. The :py:obj:`~.CUDA_MEMCPY2D` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.srcMemoryType` and :py:obj:`~.dstMemoryType` specify the
      type of memory of the source and destination, respectively;
      :py:obj:`~.CUmemorytype_enum` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.srcArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.srcHost` and :py:obj:`~.srcPitch` specify the (host) base
    address of the source data and the bytes per row to apply.
    :py:obj:`~.srcArray` is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (device)
    base address of the source data and the bytes per row to apply.
    :py:obj:`~.srcArray` is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.srcArray` specifies the handle of the source data.
    :py:obj:`~.srcHost`, :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` are
    ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.dstArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.dstHost` and :py:obj:`~.dstPitch` specify the (host) base
    address of the destination data and the bytes per row to apply.
    :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (device)
    base address of the destination data and the bytes per row to apply.
    :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.dstArray` specifies the handle of the destination data.
    :py:obj:`~.dstHost`, :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` are
    ignored.

    - :py:obj:`~.srcXInBytes` and :py:obj:`~.srcY` specify the base address
      of the source data for the copy.

    For host pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.srcXInBytes` must be evenly divisible by
    the array element size.

    - :py:obj:`~.dstXInBytes` and :py:obj:`~.dstY` specify the base address
      of the destination data for the copy.

    For host pointers, the base address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.dstXInBytes` must be evenly divisible by
    the array element size.

    - :py:obj:`~.WidthInBytes` and :py:obj:`~.Height` specify the width (in
      bytes) and height of the 2D copy being performed.

    - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
      :py:obj:`~.dstPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + dstXInBytes.

    :py:obj:`~.cuMemcpy2D()` returns an error if any pitch is greater than
    the maximum allowed (:py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PITCH`).
    :py:obj:`~.cuMemAllocPitch()` passes back pitches that always work with
    :py:obj:`~.cuMemcpy2D()`. On intra-device memory copies (device to
    device, CUDA array to device, CUDA array to CUDA array),
    :py:obj:`~.cuMemcpy2D()` may fail for pitches not computed by
    :py:obj:`~.cuMemAllocPitch()`. :py:obj:`~.cuMemcpy2DUnaligned()` does
    not have this restriction, but may run significantly slower in the
    cases where :py:obj:`~.cuMemcpy2D()` would have returned an error code.

    Parameters
    ----------
    pCopy : :py:obj:`~.CUDA_MEMCPY2D`
        Parameters for the memory copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpy2DFromArray`
    """
    cdef cydriver.CUDA_MEMCPY2D* cypCopy_ptr = pCopy._pvt_ptr if pCopy is not None else NULL
    with nogil:
        err = cydriver.cuMemcpy2DUnaligned(cypCopy_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpy3D_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpy3D(pCopy : Optional[CUDA_MEMCPY3D]):
    """ Copies memory for 3D arrays.

    Perform a 3D memory copy according to the parameters specified in
    `pCopy`. The :py:obj:`~.CUDA_MEMCPY3D` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.srcMemoryType` and :py:obj:`~.dstMemoryType` specify the
      type of memory of the source and destination, respectively;
      :py:obj:`~.CUmemorytype_enum` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.srcArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.srcHost`, :py:obj:`~.srcPitch` and :py:obj:`~.srcHeight`
    specify the (host) base address of the source data, the bytes per row,
    and the height of each 2D slice of the 3D array. :py:obj:`~.srcArray`
    is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.srcDevice`, :py:obj:`~.srcPitch` and :py:obj:`~.srcHeight`
    specify the (device) base address of the source data, the bytes per
    row, and the height of each 2D slice of the 3D array.
    :py:obj:`~.srcArray` is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.srcArray` specifies the handle of the source data.
    :py:obj:`~.srcHost`, :py:obj:`~.srcDevice`, :py:obj:`~.srcPitch` and
    :py:obj:`~.srcHeight` are ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.dstArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.dstHost` and :py:obj:`~.dstPitch` specify the (host) base
    address of the destination data, the bytes per row, and the height of
    each 2D slice of the 3D array. :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (device)
    base address of the destination data, the bytes per row, and the height
    of each 2D slice of the 3D array. :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.dstArray` specifies the handle of the destination data.
    :py:obj:`~.dstHost`, :py:obj:`~.dstDevice`, :py:obj:`~.dstPitch` and
    :py:obj:`~.dstHeight` are ignored.

    - :py:obj:`~.srcXInBytes`, :py:obj:`~.srcY` and :py:obj:`~.srcZ`
      specify the base address of the source data for the copy.

    For host pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.srcXInBytes` must be evenly divisible by
    the array element size.

    - dstXInBytes, :py:obj:`~.dstY` and :py:obj:`~.dstZ` specify the base
      address of the destination data for the copy.

    For host pointers, the base address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.dstXInBytes` must be evenly divisible by
    the array element size.

    - :py:obj:`~.WidthInBytes`, :py:obj:`~.Height` and :py:obj:`~.Depth`
      specify the width (in bytes), height and depth of the 3D copy being
      performed.

    - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
      :py:obj:`~.dstPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + dstXInBytes.

    - If specified, :py:obj:`~.srcHeight` must be greater than or equal to
      :py:obj:`~.Height` + :py:obj:`~.srcY`, and :py:obj:`~.dstHeight` must
      be greater than or equal to :py:obj:`~.Height` + :py:obj:`~.dstY`.

    :py:obj:`~.cuMemcpy3D()` returns an error if any pitch is greater than
    the maximum allowed (:py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PITCH`).

    The :py:obj:`~.srcLOD` and :py:obj:`~.dstLOD` members of the
    :py:obj:`~.CUDA_MEMCPY3D` structure must be set to 0.

    Parameters
    ----------
    pCopy : :py:obj:`~.CUDA_MEMCPY3D`
        Parameters for the memory copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy3D`
    """
    cdef cydriver.CUDA_MEMCPY3D* cypCopy_ptr = pCopy._pvt_ptr if pCopy is not None else NULL
    with nogil:
        err = cydriver.cuMemcpy3D(cypCopy_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpy3DPeer' in found_functions}}

@cython.embedsignature(True)
def cuMemcpy3DPeer(pCopy : Optional[CUDA_MEMCPY3D_PEER]):
    """ Copies memory between contexts.

    Perform a 3D memory copy according to the parameters specified in
    `pCopy`. See the definition of the :py:obj:`~.CUDA_MEMCPY3D_PEER`
    structure for documentation of its parameters.

    Parameters
    ----------
    pCopy : :py:obj:`~.CUDA_MEMCPY3D_PEER`
        Parameters for the memory copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyPeer`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyPeerAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cudaMemcpy3DPeer`
    """
    cdef cydriver.CUDA_MEMCPY3D_PEER* cypCopy_ptr = pCopy._pvt_ptr if pCopy is not None else NULL
    with nogil:
        err = cydriver.cuMemcpy3DPeer(cypCopy_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpyAsync' in found_functions}}

@cython.embedsignature(True)
def cuMemcpyAsync(dst, src, size_t ByteCount, hStream):
    """ Copies memory asynchronously.

    Copies data between two pointers. `dst` and `src` are base pointers of
    the destination and source, respectively. `ByteCount` specifies the
    number of bytes to copy. Note that this function infers the type of the
    transfer (host to host, host to device, device to device, or device to
    host) from the pointer values. This function is only allowed in
    contexts which support unified addressing.

    Parameters
    ----------
    dst : :py:obj:`~.CUdeviceptr`
        Destination unified virtual address space pointer
    src : :py:obj:`~.CUdeviceptr`
        Source unified virtual address space pointer
    ByteCount : size_t
        Size of memory copy in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUdeviceptr cysrc
    if src is None:
        psrc = 0
    elif isinstance(src, (CUdeviceptr,)):
        psrc = int(src)
    else:
        psrc = int(CUdeviceptr(src))
    cysrc = <cydriver.CUdeviceptr><void_ptr>psrc
    cdef cydriver.CUdeviceptr cydst
    if dst is None:
        pdst = 0
    elif isinstance(dst, (CUdeviceptr,)):
        pdst = int(dst)
    else:
        pdst = int(CUdeviceptr(dst))
    cydst = <cydriver.CUdeviceptr><void_ptr>pdst
    with nogil:
        err = cydriver.cuMemcpyAsync(cydst, cysrc, ByteCount, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpyPeerAsync' in found_functions}}

@cython.embedsignature(True)
def cuMemcpyPeerAsync(dstDevice, dstContext, srcDevice, srcContext, size_t ByteCount, hStream):
    """ Copies device memory between two contexts asynchronously.

    Copies from device memory in one context to device memory in another
    context. `dstDevice` is the base device pointer of the destination
    memory and `dstContext` is the destination context. `srcDevice` is the
    base device pointer of the source memory and `srcContext` is the source
    pointer. `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    dstContext : :py:obj:`~.CUcontext`
        Destination context
    srcDevice : :py:obj:`~.CUdeviceptr`
        Source device pointer
    srcContext : :py:obj:`~.CUcontext`
        Source context
    ByteCount : size_t
        Size of memory copy in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyPeer`, :py:obj:`~.cuMemcpy3DPeer`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cudaMemcpyPeerAsync`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUcontext cysrcContext
    if srcContext is None:
        psrcContext = 0
    elif isinstance(srcContext, (CUcontext,)):
        psrcContext = int(srcContext)
    else:
        psrcContext = int(CUcontext(srcContext))
    cysrcContext = <cydriver.CUcontext><void_ptr>psrcContext
    cdef cydriver.CUdeviceptr cysrcDevice
    if srcDevice is None:
        psrcDevice = 0
    elif isinstance(srcDevice, (CUdeviceptr,)):
        psrcDevice = int(srcDevice)
    else:
        psrcDevice = int(CUdeviceptr(srcDevice))
    cysrcDevice = <cydriver.CUdeviceptr><void_ptr>psrcDevice
    cdef cydriver.CUcontext cydstContext
    if dstContext is None:
        pdstContext = 0
    elif isinstance(dstContext, (CUcontext,)):
        pdstContext = int(dstContext)
    else:
        pdstContext = int(CUcontext(dstContext))
    cydstContext = <cydriver.CUcontext><void_ptr>pdstContext
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    with nogil:
        err = cydriver.cuMemcpyPeerAsync(cydstDevice, cydstContext, cysrcDevice, cysrcContext, ByteCount, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpyHtoDAsync_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpyHtoDAsync(dstDevice, srcHost, size_t ByteCount, hStream):
    """ Copies memory from Host to Device.

    Copies from host memory to device memory. `dstDevice` and `srcHost` are
    the base addresses of the destination and source, respectively.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    srcHost : Any
        Source host pointer
    ByteCount : size_t
        Size of memory copy in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    cysrcHost = _HelperInputVoidPtr(srcHost)
    cdef void* cysrcHost_ptr = <void*><void_ptr>cysrcHost.cptr
    with nogil:
        err = cydriver.cuMemcpyHtoDAsync(cydstDevice, cysrcHost_ptr, ByteCount, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpyDtoHAsync_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpyDtoHAsync(dstHost, srcDevice, size_t ByteCount, hStream):
    """ Copies memory from Device to Host.

    Copies from device to host memory. `dstHost` and `srcDevice` specify
    the base pointers of the destination and source, respectively.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstHost : Any
        Destination host pointer
    srcDevice : :py:obj:`~.CUdeviceptr`
        Source device pointer
    ByteCount : size_t
        Size of memory copy in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUdeviceptr cysrcDevice
    if srcDevice is None:
        psrcDevice = 0
    elif isinstance(srcDevice, (CUdeviceptr,)):
        psrcDevice = int(srcDevice)
    else:
        psrcDevice = int(CUdeviceptr(srcDevice))
    cysrcDevice = <cydriver.CUdeviceptr><void_ptr>psrcDevice
    cydstHost = _HelperInputVoidPtr(dstHost)
    cdef void* cydstHost_ptr = <void*><void_ptr>cydstHost.cptr
    with nogil:
        err = cydriver.cuMemcpyDtoHAsync(cydstHost_ptr, cysrcDevice, ByteCount, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpyDtoDAsync_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpyDtoDAsync(dstDevice, srcDevice, size_t ByteCount, hStream):
    """ Copies memory from Device to Device.

    Copies from device memory to device memory. `dstDevice` and `srcDevice`
    are the base pointers of the destination and source, respectively.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    srcDevice : :py:obj:`~.CUdeviceptr`
        Source device pointer
    ByteCount : size_t
        Size of memory copy in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUdeviceptr cysrcDevice
    if srcDevice is None:
        psrcDevice = 0
    elif isinstance(srcDevice, (CUdeviceptr,)):
        psrcDevice = int(srcDevice)
    else:
        psrcDevice = int(CUdeviceptr(srcDevice))
    cysrcDevice = <cydriver.CUdeviceptr><void_ptr>psrcDevice
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    with nogil:
        err = cydriver.cuMemcpyDtoDAsync(cydstDevice, cysrcDevice, ByteCount, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpyHtoAAsync_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpyHtoAAsync(dstArray, size_t dstOffset, srcHost, size_t ByteCount, hStream):
    """ Copies memory from Host to Array.

    Copies from host memory to a 1D CUDA array. `dstArray` and `dstOffset`
    specify the CUDA array handle and starting offset in bytes of the
    destination data. `srcHost` specifies the base address of the source.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstArray : :py:obj:`~.CUarray`
        Destination array
    dstOffset : size_t
        Offset in bytes of destination array
    srcHost : Any
        Source host pointer
    ByteCount : size_t
        Size of memory copy in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyToArrayAsync`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUarray cydstArray
    if dstArray is None:
        pdstArray = 0
    elif isinstance(dstArray, (CUarray,)):
        pdstArray = int(dstArray)
    else:
        pdstArray = int(CUarray(dstArray))
    cydstArray = <cydriver.CUarray><void_ptr>pdstArray
    cysrcHost = _HelperInputVoidPtr(srcHost)
    cdef void* cysrcHost_ptr = <void*><void_ptr>cysrcHost.cptr
    with nogil:
        err = cydriver.cuMemcpyHtoAAsync(cydstArray, dstOffset, cysrcHost_ptr, ByteCount, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpyAtoHAsync_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpyAtoHAsync(dstHost, srcArray, size_t srcOffset, size_t ByteCount, hStream):
    """ Copies memory from Array to Host.

    Copies from one 1D CUDA array to host memory. `dstHost` specifies the
    base pointer of the destination. `srcArray` and `srcOffset` specify the
    CUDA array handle and starting offset in bytes of the source data.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstHost : Any
        Destination pointer
    srcArray : :py:obj:`~.CUarray`
        Source array
    srcOffset : size_t
        Offset in bytes of source array
    ByteCount : size_t
        Size of memory copy in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyFromArrayAsync`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUarray cysrcArray
    if srcArray is None:
        psrcArray = 0
    elif isinstance(srcArray, (CUarray,)):
        psrcArray = int(srcArray)
    else:
        psrcArray = int(CUarray(srcArray))
    cysrcArray = <cydriver.CUarray><void_ptr>psrcArray
    cydstHost = _HelperInputVoidPtr(dstHost)
    cdef void* cydstHost_ptr = <void*><void_ptr>cydstHost.cptr
    with nogil:
        err = cydriver.cuMemcpyAtoHAsync(cydstHost_ptr, cysrcArray, srcOffset, ByteCount, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpy2DAsync_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpy2DAsync(pCopy : Optional[CUDA_MEMCPY2D], hStream):
    """ Copies memory for 2D arrays.

    Perform a 2D memory copy according to the parameters specified in
    `pCopy`. The :py:obj:`~.CUDA_MEMCPY2D` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.srcMemoryType` and :py:obj:`~.dstMemoryType` specify the
      type of memory of the source and destination, respectively;
      :py:obj:`~.CUmemorytype_enum` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.srcHost` and :py:obj:`~.srcPitch` specify the (host) base
    address of the source data and the bytes per row to apply.
    :py:obj:`~.srcArray` is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.srcArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (device)
    base address of the source data and the bytes per row to apply.
    :py:obj:`~.srcArray` is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.srcArray` specifies the handle of the source data.
    :py:obj:`~.srcHost`, :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` are
    ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.dstArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.dstHost` and :py:obj:`~.dstPitch` specify the (host) base
    address of the destination data and the bytes per row to apply.
    :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (device)
    base address of the destination data and the bytes per row to apply.
    :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.dstArray` specifies the handle of the destination data.
    :py:obj:`~.dstHost`, :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` are
    ignored.

    - :py:obj:`~.srcXInBytes` and :py:obj:`~.srcY` specify the base address
      of the source data for the copy.

    For host pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.srcXInBytes` must be evenly divisible by
    the array element size.

    - :py:obj:`~.dstXInBytes` and :py:obj:`~.dstY` specify the base address
      of the destination data for the copy.

    For host pointers, the base address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.dstXInBytes` must be evenly divisible by
    the array element size.

    - :py:obj:`~.WidthInBytes` and :py:obj:`~.Height` specify the width (in
      bytes) and height of the 2D copy being performed.

    - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
      :py:obj:`~.dstPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + dstXInBytes.

    - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
      :py:obj:`~.dstPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + dstXInBytes.

    - If specified, :py:obj:`~.srcHeight` must be greater than or equal to
      :py:obj:`~.Height` + :py:obj:`~.srcY`, and :py:obj:`~.dstHeight` must
      be greater than or equal to :py:obj:`~.Height` + :py:obj:`~.dstY`.

    :py:obj:`~.cuMemcpy2DAsync()` returns an error if any pitch is greater
    than the maximum allowed (:py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PITCH`).
    :py:obj:`~.cuMemAllocPitch()` passes back pitches that always work with
    :py:obj:`~.cuMemcpy2D()`. On intra-device memory copies (device to
    device, CUDA array to device, CUDA array to CUDA array),
    :py:obj:`~.cuMemcpy2DAsync()` may fail for pitches not computed by
    :py:obj:`~.cuMemAllocPitch()`.

    Parameters
    ----------
    pCopy : :py:obj:`~.CUDA_MEMCPY2D`
        Parameters for the memory copy
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpy2DAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`, :py:obj:`~.cudaMemcpy2DFromArrayAsync`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUDA_MEMCPY2D* cypCopy_ptr = pCopy._pvt_ptr if pCopy is not None else NULL
    with nogil:
        err = cydriver.cuMemcpy2DAsync(cypCopy_ptr, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpy3DAsync_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpy3DAsync(pCopy : Optional[CUDA_MEMCPY3D], hStream):
    """ Copies memory for 3D arrays.

    Perform a 3D memory copy according to the parameters specified in
    `pCopy`. The :py:obj:`~.CUDA_MEMCPY3D` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.srcMemoryType` and :py:obj:`~.dstMemoryType` specify the
      type of memory of the source and destination, respectively;
      :py:obj:`~.CUmemorytype_enum` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.srcArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.srcHost`, :py:obj:`~.srcPitch` and :py:obj:`~.srcHeight`
    specify the (host) base address of the source data, the bytes per row,
    and the height of each 2D slice of the 3D array. :py:obj:`~.srcArray`
    is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.srcDevice`, :py:obj:`~.srcPitch` and :py:obj:`~.srcHeight`
    specify the (device) base address of the source data, the bytes per
    row, and the height of each 2D slice of the 3D array.
    :py:obj:`~.srcArray` is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.srcArray` specifies the handle of the source data.
    :py:obj:`~.srcHost`, :py:obj:`~.srcDevice`, :py:obj:`~.srcPitch` and
    :py:obj:`~.srcHeight` are ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.dstArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.dstHost` and :py:obj:`~.dstPitch` specify the (host) base
    address of the destination data, the bytes per row, and the height of
    each 2D slice of the 3D array. :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (device)
    base address of the destination data, the bytes per row, and the height
    of each 2D slice of the 3D array. :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.dstArray` specifies the handle of the destination data.
    :py:obj:`~.dstHost`, :py:obj:`~.dstDevice`, :py:obj:`~.dstPitch` and
    :py:obj:`~.dstHeight` are ignored.

    - :py:obj:`~.srcXInBytes`, :py:obj:`~.srcY` and :py:obj:`~.srcZ`
      specify the base address of the source data for the copy.

    For host pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.srcXInBytes` must be evenly divisible by
    the array element size.

    - dstXInBytes, :py:obj:`~.dstY` and :py:obj:`~.dstZ` specify the base
      address of the destination data for the copy.

    For host pointers, the base address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.dstXInBytes` must be evenly divisible by
    the array element size.

    - :py:obj:`~.WidthInBytes`, :py:obj:`~.Height` and :py:obj:`~.Depth`
      specify the width (in bytes), height and depth of the 3D copy being
      performed.

    - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
      :py:obj:`~.dstPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + dstXInBytes.

    - If specified, :py:obj:`~.srcHeight` must be greater than or equal to
      :py:obj:`~.Height` + :py:obj:`~.srcY`, and :py:obj:`~.dstHeight` must
      be greater than or equal to :py:obj:`~.Height` + :py:obj:`~.dstY`.

    :py:obj:`~.cuMemcpy3DAsync()` returns an error if any pitch is greater
    than the maximum allowed (:py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PITCH`).

    The :py:obj:`~.srcLOD` and :py:obj:`~.dstLOD` members of the
    :py:obj:`~.CUDA_MEMCPY3D` structure must be set to 0.

    Parameters
    ----------
    pCopy : :py:obj:`~.CUDA_MEMCPY3D`
        Parameters for the memory copy
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpy3DAsync`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUDA_MEMCPY3D* cypCopy_ptr = pCopy._pvt_ptr if pCopy is not None else NULL
    with nogil:
        err = cydriver.cuMemcpy3DAsync(cypCopy_ptr, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpy3DPeerAsync' in found_functions}}

@cython.embedsignature(True)
def cuMemcpy3DPeerAsync(pCopy : Optional[CUDA_MEMCPY3D_PEER], hStream):
    """ Copies memory between contexts asynchronously.

    Perform a 3D memory copy according to the parameters specified in
    `pCopy`. See the definition of the :py:obj:`~.CUDA_MEMCPY3D_PEER`
    structure for documentation of its parameters.

    Parameters
    ----------
    pCopy : :py:obj:`~.CUDA_MEMCPY3D_PEER`
        Parameters for the memory copy
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyPeer`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyPeerAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cudaMemcpy3DPeerAsync`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUDA_MEMCPY3D_PEER* cypCopy_ptr = pCopy._pvt_ptr if pCopy is not None else NULL
    with nogil:
        err = cydriver.cuMemcpy3DPeerAsync(cypCopy_ptr, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpyBatchAsync_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpyBatchAsync(dsts : Optional[tuple[CUdeviceptr] | list[CUdeviceptr]], srcs : Optional[tuple[CUdeviceptr] | list[CUdeviceptr]], sizes : tuple[int] | list[int], size_t count, attrs : Optional[tuple[CUmemcpyAttributes] | list[CUmemcpyAttributes]], attrsIdxs : tuple[int] | list[int], size_t numAttrs, hStream):
    """ Performs a batch of memory copies asynchronously.

    Performs a batch of memory copies. The batch as a whole executes in
    stream order but copies within a batch are not guaranteed to execute in
    any specific order. This API only supports pointer-to-pointer copies.
    For copies involving CUDA arrays, please see
    :py:obj:`~.cuMemcpy3DBatchAsync`.

    Performs memory copies from source buffers specified in `srcs` to
    destination buffers specified in `dsts`. The size of each copy is
    specified in `sizes`. All three arrays must be of the same length as
    specified by `count`. Since there are no ordering guarantees for copies
    within a batch, specifying any dependent copies within a batch will
    result in undefined behavior.

    Every copy in the batch has to be associated with a set of attributes
    specified in the `attrs` array. Each entry in this array can apply to
    more than one copy. This can be done by specifying in the `attrsIdxs`
    array, the index of the first copy that the corresponding entry in the
    `attrs` array applies to. Both `attrs` and `attrsIdxs` must be of the
    same length as specified by `numAttrs`. For example, if a batch has 10
    copies listed in dst/src/sizes, the first 6 of which have one set of
    attributes and the remaining 4 another, then `numAttrs` will be 2,
    `attrsIdxs` will be {0, 6} and `attrs` will contains the two sets of
    attributes. Note that the first entry in `attrsIdxs` must always be 0.
    Also, each entry must be greater than the previous entry and the last
    entry should be less than `count`. Furthermore, `numAttrs` must be
    lesser than or equal to `count`.

    The :py:obj:`~.CUmemcpyAttributes.srcAccessOrder` indicates the source
    access ordering to be observed for copies associated with the
    attribute. If the source access order is set to
    :py:obj:`~.CU_MEMCPY_SRC_ACCESS_ORDER_STREAM`, then the source will be
    accessed in stream order. If the source access order is set to
    :py:obj:`~.CU_MEMCPY_SRC_ACCESS_ORDER_DURING_API_CALL` then it
    indicates that access to the source pointer can be out of stream order
    and all accesses must be complete before the API call returns. This
    flag is suited for ephemeral sources (ex., stack variables) when it's
    known that no prior operations in the stream can be accessing the
    memory and also that the lifetime of the memory is limited to the scope
    that the source variable was declared in. Specifying this flag allows
    the driver to optimize the copy and removes the need for the user to
    synchronize the stream after the API call. If the source access order
    is set to :py:obj:`~.CU_MEMCPY_SRC_ACCESS_ORDER_ANY` then it indicates
    that access to the source pointer can be out of stream order and the
    accesses can happen even after the API call returns. This flag is
    suited for host pointers allocated outside CUDA (ex., via malloc) when
    it's known that no prior operations in the stream can be accessing the
    memory. Specifying this flag allows the driver to optimize the copy on
    certain platforms. Each memcpy operation in the batch must have a valid
    :py:obj:`~.CUmemcpyAttributes` corresponding to it including the
    appropriate srcAccessOrder setting, otherwise the API will return
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

    The :py:obj:`~.CUmemcpyAttributes.srcLocHint` and
    :py:obj:`~.CUmemcpyAttributes.dstLocHint` allows applications to
    specify hint locations for operands of a copy when the operand doesn't
    have a fixed location. That is, these hints are only applicable for
    managed memory pointers on devices where
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` is true or
    system-allocated pageable memory on devices where
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS` is true. For
    other cases, these hints are ignored.

    The :py:obj:`~.CUmemcpyAttributes.flags` field can be used to specify
    certain flags for copies. Setting the
    :py:obj:`~.CU_MEMCPY_FLAG_PREFER_OVERLAP_WITH_COMPUTE` flag indicates
    that the associated copies should preferably overlap with any compute
    work. Note that this flag is a hint and can be ignored depending on the
    platform and other parameters of the copy.

    Parameters
    ----------
    dsts : list[:py:obj:`~.CUdeviceptr`]
        Array of destination pointers.
    srcs : list[:py:obj:`~.CUdeviceptr`]
        Array of memcpy source pointers.
    sizes : list[int]
        Array of sizes for memcpy operations.
    count : size_t
        Size of `dsts`, `srcs` and `sizes` arrays
    attrs : list[:py:obj:`~.CUmemcpyAttributes`]
        Array of memcpy attributes.
    attrsIdxs : list[int]
        Array of indices to specify which copies each entry in the `attrs`
        array applies to. The attributes specified in attrs[k] will be
        applied to copies starting from attrsIdxs[k] through attrsIdxs[k+1]
        - 1. Also attrs[numAttrs-1] will apply to copies starting from
        attrsIdxs[numAttrs-1] through count - 1.
    numAttrs : size_t
        Size of `attrs` and `attrsIdxs` arrays.
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to enqueue the operations in. Must not be legacy NULL
        stream.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    if not all(isinstance(_x, (int)) for _x in attrsIdxs):
        raise TypeError("Argument 'attrsIdxs' is not instance of type (expected tuple[int] or list[int]")
    attrs = [] if attrs is None else attrs
    if not all(isinstance(_x, (CUmemcpyAttributes,)) for _x in attrs):
        raise TypeError("Argument 'attrs' is not instance of type (expected tuple[cydriver.CUmemcpyAttributes,] or list[cydriver.CUmemcpyAttributes,]")
    if not all(isinstance(_x, (int)) for _x in sizes):
        raise TypeError("Argument 'sizes' is not instance of type (expected tuple[int] or list[int]")
    srcs = [] if srcs is None else srcs
    if not all(isinstance(_x, (CUdeviceptr,)) for _x in srcs):
        raise TypeError("Argument 'srcs' is not instance of type (expected tuple[cydriver.CUdeviceptr,] or list[cydriver.CUdeviceptr,]")
    dsts = [] if dsts is None else dsts
    if not all(isinstance(_x, (CUdeviceptr,)) for _x in dsts):
        raise TypeError("Argument 'dsts' is not instance of type (expected tuple[cydriver.CUdeviceptr,] or list[cydriver.CUdeviceptr,]")
    cdef cydriver.CUdeviceptr* cydsts = NULL
    if len(dsts) > 1:
        cydsts = <cydriver.CUdeviceptr*> calloc(len(dsts), sizeof(cydriver.CUdeviceptr))
        if cydsts is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dsts)) + 'x' + str(sizeof(cydriver.CUdeviceptr)))
        else:
            for idx in range(len(dsts)):
                cydsts[idx] = <cydriver.CUdeviceptr>(<CUdeviceptr>dsts[idx])._pvt_ptr[0]
    elif len(dsts) == 1:
        cydsts = <cydriver.CUdeviceptr*>(<CUdeviceptr>dsts[0])._pvt_ptr
    cdef cydriver.CUdeviceptr* cysrcs = NULL
    if len(srcs) > 1:
        cysrcs = <cydriver.CUdeviceptr*> calloc(len(srcs), sizeof(cydriver.CUdeviceptr))
        if cysrcs is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(srcs)) + 'x' + str(sizeof(cydriver.CUdeviceptr)))
        else:
            for idx in range(len(srcs)):
                cysrcs[idx] = <cydriver.CUdeviceptr>(<CUdeviceptr>srcs[idx])._pvt_ptr[0]
    elif len(srcs) == 1:
        cysrcs = <cydriver.CUdeviceptr*>(<CUdeviceptr>srcs[0])._pvt_ptr
    cdef vector[size_t] cysizes = sizes
    if count > <size_t>len(dsts): raise RuntimeError("List is too small: " + str(len(dsts)) + " < " + str(count))
    if count > <size_t>len(srcs): raise RuntimeError("List is too small: " + str(len(srcs)) + " < " + str(count))
    if count > <size_t>len(sizes): raise RuntimeError("List is too small: " + str(len(sizes)) + " < " + str(count))
    cdef cydriver.CUmemcpyAttributes* cyattrs = NULL
    if len(attrs) > 1:
        cyattrs = <cydriver.CUmemcpyAttributes*> calloc(len(attrs), sizeof(cydriver.CUmemcpyAttributes))
        if cyattrs is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(attrs)) + 'x' + str(sizeof(cydriver.CUmemcpyAttributes)))
        for idx in range(len(attrs)):
            string.memcpy(&cyattrs[idx], (<CUmemcpyAttributes>attrs[idx])._pvt_ptr, sizeof(cydriver.CUmemcpyAttributes))
    elif len(attrs) == 1:
        cyattrs = (<CUmemcpyAttributes>attrs[0])._pvt_ptr
    cdef vector[size_t] cyattrsIdxs = attrsIdxs
    if numAttrs > <size_t>len(attrs): raise RuntimeError("List is too small: " + str(len(attrs)) + " < " + str(numAttrs))
    if numAttrs > <size_t>len(attrsIdxs): raise RuntimeError("List is too small: " + str(len(attrsIdxs)) + " < " + str(numAttrs))
    with nogil:
        err = cydriver.cuMemcpyBatchAsync(cydsts, cysrcs, cysizes.data(), count, cyattrs, cyattrsIdxs.data(), numAttrs, cyhStream)
    if len(dsts) > 1 and cydsts is not NULL:
        free(cydsts)
    if len(srcs) > 1 and cysrcs is not NULL:
        free(cysrcs)
    if len(attrs) > 1 and cyattrs is not NULL:
        free(cyattrs)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemcpy3DBatchAsync_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemcpy3DBatchAsync(size_t numOps, opList : Optional[tuple[CUDA_MEMCPY3D_BATCH_OP] | list[CUDA_MEMCPY3D_BATCH_OP]], unsigned long long flags, hStream):
    """ Performs a batch of 3D memory copies asynchronously.

    Performs a batch of memory copies. The batch as a whole executes in
    stream order but copies within a batch are not guaranteed to execute in
    any specific order. Note that this means specifying any dependent
    copies within a batch will result in undefined behavior.

    Performs memory copies as specified in the `opList` array. The length
    of this array is specified in `numOps`. Each entry in this array
    describes a copy operation. This includes among other things, the
    source and destination operands for the copy as specified in
    :py:obj:`~.CUDA_MEMCPY3D_BATCH_OP.src` and
    :py:obj:`~.CUDA_MEMCPY3D_BATCH_OP.dst` respectively. The source and
    destination operands of a copy can either be a pointer or a CUDA array.
    The width, height and depth of a copy is specified in
    :py:obj:`~.CUDA_MEMCPY3D_BATCH_OP.extent`. The width, height and depth
    of a copy are specified in elements and must not be zero. For pointer-
    to-pointer copies, the element size is considered to be 1. For pointer
    to CUDA array or vice versa copies, the element size is determined by
    the CUDA array. For CUDA array to CUDA array copies, the element size
    of the two CUDA arrays must match.

    For a given operand, if :py:obj:`~.CUmemcpy3DOperand`::type is
    specified as :py:obj:`~.CU_MEMCPY_OPERAND_TYPE_POINTER`, then
    :py:obj:`~.CUmemcpy3DOperand`::op::ptr will be used. The
    :py:obj:`~.CUmemcpy3DOperand`::op::ptr::ptr field must contain the
    pointer where the copy should begin. The
    :py:obj:`~.CUmemcpy3DOperand`::op::ptr::rowLength field specifies the
    length of each row in elements and must either be zero or be greater
    than or equal to the width of the copy specified in
    :py:obj:`~.CUDA_MEMCPY3D_BATCH_OP`::extent::width. The
    :py:obj:`~.CUmemcpy3DOperand`::op::ptr::layerHeight field specifies the
    height of each layer and must either be zero or be greater than or
    equal to the height of the copy specified in
    :py:obj:`~.CUDA_MEMCPY3D_BATCH_OP`::extent::height. When either of
    these values is zero, that aspect of the operand is considered to be
    tightly packed according to the copy extent. For managed memory
    pointers on devices where
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` is true or
    system-allocated pageable memory on devices where
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS` is true, the
    :py:obj:`~.CUmemcpy3DOperand`::op::ptr::locHint field can be used to
    hint the location of the operand.

    If an operand's type is specified as
    :py:obj:`~.CU_MEMCPY_OPERAND_TYPE_ARRAY`, then
    :py:obj:`~.CUmemcpy3DOperand`::op::array will be used. The
    :py:obj:`~.CUmemcpy3DOperand`::op::array::array field specifies the
    CUDA array and :py:obj:`~.CUmemcpy3DOperand`::op::array::offset
    specifies the 3D offset into that array where the copy begins.

    The :py:obj:`~.CUmemcpyAttributes.srcAccessOrder` indicates the source
    access ordering to be observed for copies associated with the
    attribute. If the source access order is set to
    :py:obj:`~.CU_MEMCPY_SRC_ACCESS_ORDER_STREAM`, then the source will be
    accessed in stream order. If the source access order is set to
    :py:obj:`~.CU_MEMCPY_SRC_ACCESS_ORDER_DURING_API_CALL` then it
    indicates that access to the source pointer can be out of stream order
    and all accesses must be complete before the API call returns. This
    flag is suited for ephemeral sources (ex., stack variables) when it's
    known that no prior operations in the stream can be accessing the
    memory and also that the lifetime of the memory is limited to the scope
    that the source variable was declared in. Specifying this flag allows
    the driver to optimize the copy and removes the need for the user to
    synchronize the stream after the API call. If the source access order
    is set to :py:obj:`~.CU_MEMCPY_SRC_ACCESS_ORDER_ANY` then it indicates
    that access to the source pointer can be out of stream order and the
    accesses can happen even after the API call returns. This flag is
    suited for host pointers allocated outside CUDA (ex., via malloc) when
    it's known that no prior operations in the stream can be accessing the
    memory. Specifying this flag allows the driver to optimize the copy on
    certain platforms. Each memcopy operation in `opList` must have a valid
    srcAccessOrder setting, otherwise this API will return
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

    The :py:obj:`~.CUmemcpyAttributes.flags` field can be used to specify
    certain flags for copies. Setting the
    :py:obj:`~.CU_MEMCPY_FLAG_PREFER_OVERLAP_WITH_COMPUTE` flag indicates
    that the associated copies should preferably overlap with any compute
    work. Note that this flag is a hint and can be ignored depending on the
    platform and other parameters of the copy.

    Parameters
    ----------
    numOps : size_t
        Total number of memcpy operations.
    opList : list[:py:obj:`~.CUDA_MEMCPY3D_BATCH_OP`]
        Array of size `numOps` containing the actual memcpy operations.
    flags : unsigned long long
        Flags for future use, must be zero now.
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to enqueue the operations in. Must not be default NULL
        stream.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    opList = [] if opList is None else opList
    if not all(isinstance(_x, (CUDA_MEMCPY3D_BATCH_OP,)) for _x in opList):
        raise TypeError("Argument 'opList' is not instance of type (expected tuple[cydriver.CUDA_MEMCPY3D_BATCH_OP,] or list[cydriver.CUDA_MEMCPY3D_BATCH_OP,]")
    if numOps > <size_t>len(opList): raise RuntimeError("List is too small: " + str(len(opList)) + " < " + str(numOps))
    cdef cydriver.CUDA_MEMCPY3D_BATCH_OP* cyopList = NULL
    if len(opList) > 1:
        cyopList = <cydriver.CUDA_MEMCPY3D_BATCH_OP*> calloc(len(opList), sizeof(cydriver.CUDA_MEMCPY3D_BATCH_OP))
        if cyopList is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(opList)) + 'x' + str(sizeof(cydriver.CUDA_MEMCPY3D_BATCH_OP)))
        for idx in range(len(opList)):
            string.memcpy(&cyopList[idx], (<CUDA_MEMCPY3D_BATCH_OP>opList[idx])._pvt_ptr, sizeof(cydriver.CUDA_MEMCPY3D_BATCH_OP))
    elif len(opList) == 1:
        cyopList = (<CUDA_MEMCPY3D_BATCH_OP>opList[0])._pvt_ptr
    with nogil:
        err = cydriver.cuMemcpy3DBatchAsync(numOps, cyopList, flags, cyhStream)
    if len(opList) > 1 and cyopList is not NULL:
        free(cyopList)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemsetD8_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemsetD8(dstDevice, unsigned char uc, size_t N):
    """ Initializes device memory.

    Sets the memory range of `N` 8-bit values to the specified value `uc`.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    uc : unsigned char
        Value to set
    N : size_t
        Number of elements

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset`
    """
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    with nogil:
        err = cydriver.cuMemsetD8(cydstDevice, uc, N)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemsetD16_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemsetD16(dstDevice, unsigned short us, size_t N):
    """ Initializes device memory.

    Sets the memory range of `N` 16-bit values to the specified value `us`.
    The `dstDevice` pointer must be two byte aligned.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    us : unsigned short
        Value to set
    N : size_t
        Number of elements

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset`
    """
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    with nogil:
        err = cydriver.cuMemsetD16(cydstDevice, us, N)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemsetD32_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemsetD32(dstDevice, unsigned int ui, size_t N):
    """ Initializes device memory.

    Sets the memory range of `N` 32-bit values to the specified value `ui`.
    The `dstDevice` pointer must be four byte aligned.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    ui : unsigned int
        Value to set
    N : size_t
        Number of elements

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset`
    """
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    with nogil:
        err = cydriver.cuMemsetD32(cydstDevice, ui, N)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemsetD2D8_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemsetD2D8(dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height):
    """ Initializes device memory.

    Sets the 2D memory range of `Width` 8-bit values to the specified value
    `uc`. `Height` specifies the number of rows to set, and `dstPitch`
    specifies the number of bytes between each row. This function performs
    fastest when the pitch is one that has been passed back by
    :py:obj:`~.cuMemAllocPitch()`.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    dstPitch : size_t
        Pitch of destination device pointer(Unused if `Height` is 1)
    uc : unsigned char
        Value to set
    Width : size_t
        Width of row
    Height : size_t
        Number of rows

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2D`
    """
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    with nogil:
        err = cydriver.cuMemsetD2D8(cydstDevice, dstPitch, uc, Width, Height)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemsetD2D16_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemsetD2D16(dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height):
    """ Initializes device memory.

    Sets the 2D memory range of `Width` 16-bit values to the specified
    value `us`. `Height` specifies the number of rows to set, and
    `dstPitch` specifies the number of bytes between each row. The
    `dstDevice` pointer and `dstPitch` offset must be two byte aligned.
    This function performs fastest when the pitch is one that has been
    passed back by :py:obj:`~.cuMemAllocPitch()`.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    dstPitch : size_t
        Pitch of destination device pointer(Unused if `Height` is 1)
    us : unsigned short
        Value to set
    Width : size_t
        Width of row
    Height : size_t
        Number of rows

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2D`
    """
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    with nogil:
        err = cydriver.cuMemsetD2D16(cydstDevice, dstPitch, us, Width, Height)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemsetD2D32_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemsetD2D32(dstDevice, size_t dstPitch, unsigned int ui, size_t Width, size_t Height):
    """ Initializes device memory.

    Sets the 2D memory range of `Width` 32-bit values to the specified
    value `ui`. `Height` specifies the number of rows to set, and
    `dstPitch` specifies the number of bytes between each row. The
    `dstDevice` pointer and `dstPitch` offset must be four byte aligned.
    This function performs fastest when the pitch is one that has been
    passed back by :py:obj:`~.cuMemAllocPitch()`.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    dstPitch : size_t
        Pitch of destination device pointer(Unused if `Height` is 1)
    ui : unsigned int
        Value to set
    Width : size_t
        Width of row
    Height : size_t
        Number of rows

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2D`
    """
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    with nogil:
        err = cydriver.cuMemsetD2D32(cydstDevice, dstPitch, ui, Width, Height)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemsetD8Async' in found_functions}}

@cython.embedsignature(True)
def cuMemsetD8Async(dstDevice, unsigned char uc, size_t N, hStream):
    """ Sets device memory.

    Sets the memory range of `N` 8-bit values to the specified value `uc`.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    uc : unsigned char
        Value to set
    N : size_t
        Number of elements
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemsetAsync`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    with nogil:
        err = cydriver.cuMemsetD8Async(cydstDevice, uc, N, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemsetD16Async' in found_functions}}

@cython.embedsignature(True)
def cuMemsetD16Async(dstDevice, unsigned short us, size_t N, hStream):
    """ Sets device memory.

    Sets the memory range of `N` 16-bit values to the specified value `us`.
    The `dstDevice` pointer must be two byte aligned.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    us : unsigned short
        Value to set
    N : size_t
        Number of elements
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemsetAsync`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    with nogil:
        err = cydriver.cuMemsetD16Async(cydstDevice, us, N, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemsetD32Async' in found_functions}}

@cython.embedsignature(True)
def cuMemsetD32Async(dstDevice, unsigned int ui, size_t N, hStream):
    """ Sets device memory.

    Sets the memory range of `N` 32-bit values to the specified value `ui`.
    The `dstDevice` pointer must be four byte aligned.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    ui : unsigned int
        Value to set
    N : size_t
        Number of elements
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemsetAsync`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    with nogil:
        err = cydriver.cuMemsetD32Async(cydstDevice, ui, N, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemsetD2D8Async' in found_functions}}

@cython.embedsignature(True)
def cuMemsetD2D8Async(dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height, hStream):
    """ Sets device memory.

    Sets the 2D memory range of `Width` 8-bit values to the specified value
    `uc`. `Height` specifies the number of rows to set, and `dstPitch`
    specifies the number of bytes between each row. This function performs
    fastest when the pitch is one that has been passed back by
    :py:obj:`~.cuMemAllocPitch()`.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    dstPitch : size_t
        Pitch of destination device pointer(Unused if `Height` is 1)
    uc : unsigned char
        Value to set
    Width : size_t
        Width of row
    Height : size_t
        Number of rows
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2DAsync`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    with nogil:
        err = cydriver.cuMemsetD2D8Async(cydstDevice, dstPitch, uc, Width, Height, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemsetD2D16Async' in found_functions}}

@cython.embedsignature(True)
def cuMemsetD2D16Async(dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height, hStream):
    """ Sets device memory.

    Sets the 2D memory range of `Width` 16-bit values to the specified
    value `us`. `Height` specifies the number of rows to set, and
    `dstPitch` specifies the number of bytes between each row. The
    `dstDevice` pointer and `dstPitch` offset must be two byte aligned.
    This function performs fastest when the pitch is one that has been
    passed back by :py:obj:`~.cuMemAllocPitch()`.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    dstPitch : size_t
        Pitch of destination device pointer(Unused if `Height` is 1)
    us : unsigned short
        Value to set
    Width : size_t
        Width of row
    Height : size_t
        Number of rows
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2DAsync`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    with nogil:
        err = cydriver.cuMemsetD2D16Async(cydstDevice, dstPitch, us, Width, Height, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemsetD2D32Async' in found_functions}}

@cython.embedsignature(True)
def cuMemsetD2D32Async(dstDevice, size_t dstPitch, unsigned int ui, size_t Width, size_t Height, hStream):
    """ Sets device memory.

    Sets the 2D memory range of `Width` 32-bit values to the specified
    value `ui`. `Height` specifies the number of rows to set, and
    `dstPitch` specifies the number of bytes between each row. The
    `dstDevice` pointer and `dstPitch` offset must be four byte aligned.
    This function performs fastest when the pitch is one that has been
    passed back by :py:obj:`~.cuMemAllocPitch()`.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    dstPitch : size_t
        Pitch of destination device pointer(Unused if `Height` is 1)
    ui : unsigned int
        Value to set
    Width : size_t
        Width of row
    Height : size_t
        Number of rows
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2DAsync`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUdeviceptr cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdeviceptr,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
    cydstDevice = <cydriver.CUdeviceptr><void_ptr>pdstDevice
    with nogil:
        err = cydriver.cuMemsetD2D32Async(cydstDevice, dstPitch, ui, Width, Height, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuArrayCreate_v2' in found_functions}}

@cython.embedsignature(True)
def cuArrayCreate(pAllocateArray : Optional[CUDA_ARRAY_DESCRIPTOR]):
    """ Creates a 1D or 2D CUDA array.

    Creates a CUDA array according to the :py:obj:`~.CUDA_ARRAY_DESCRIPTOR`
    structure `pAllocateArray` and returns a handle to the new CUDA array
    in `*pHandle`. The :py:obj:`~.CUDA_ARRAY_DESCRIPTOR` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - `Width`, and `Height` are the width, and height of the CUDA array (in
      elements); the CUDA array is one-dimensional if height is 0, two-
      dimensional otherwise;

    - :py:obj:`~.Format` specifies the format of the elements;
      :py:obj:`~.CUarray_format` is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - `NumChannels` specifies the number of packed components per CUDA
      array element; it may be 1, 2, or 4;

    Here are examples of CUDA array descriptions:

    Description for a CUDA array of 2048 floats:

    **View CUDA Toolkit Documentation for a C++ code example**

    Description for a 64 x 64 CUDA array of floats:

    **View CUDA Toolkit Documentation for a C++ code example**

    Description for a `width` x `height` CUDA array of 64-bit, 4x16-bit
    float16's:

    **View CUDA Toolkit Documentation for a C++ code example**

    Description for a `width` x `height` CUDA array of 16-bit elements,
    each of which is two 8-bit unsigned chars:

    **View CUDA Toolkit Documentation for a C++ code example**

    Parameters
    ----------
    pAllocateArray : :py:obj:`~.CUDA_ARRAY_DESCRIPTOR`
        Array descriptor

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    pHandle : :py:obj:`~.CUarray`
        Returned array

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMallocArray`
    """
    cdef CUarray pHandle = CUarray()
    cdef cydriver.CUDA_ARRAY_DESCRIPTOR* cypAllocateArray_ptr = pAllocateArray._pvt_ptr if pAllocateArray is not None else NULL
    with nogil:
        err = cydriver.cuArrayCreate(<cydriver.CUarray*>pHandle._pvt_ptr, cypAllocateArray_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pHandle)
{{endif}}

{{if 'cuArrayGetDescriptor_v2' in found_functions}}

@cython.embedsignature(True)
def cuArrayGetDescriptor(hArray):
    """ Get a 1D or 2D CUDA array descriptor.

    Returns in `*pArrayDescriptor` a descriptor containing information on
    the format and dimensions of the CUDA array `hArray`. It is useful for
    subroutines that have been passed a CUDA array, but need to know the
    CUDA array parameters for validation or other purposes.

    Parameters
    ----------
    hArray : :py:obj:`~.CUarray`
        Array to get descriptor of

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    pArrayDescriptor : :py:obj:`~.CUDA_ARRAY_DESCRIPTOR`
        Returned array descriptor

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaArrayGetInfo`
    """
    cdef cydriver.CUarray cyhArray
    if hArray is None:
        phArray = 0
    elif isinstance(hArray, (CUarray,)):
        phArray = int(hArray)
    else:
        phArray = int(CUarray(hArray))
    cyhArray = <cydriver.CUarray><void_ptr>phArray
    cdef CUDA_ARRAY_DESCRIPTOR pArrayDescriptor = CUDA_ARRAY_DESCRIPTOR()
    with nogil:
        err = cydriver.cuArrayGetDescriptor(<cydriver.CUDA_ARRAY_DESCRIPTOR*>pArrayDescriptor._pvt_ptr, cyhArray)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pArrayDescriptor)
{{endif}}

{{if 'cuArrayGetSparseProperties' in found_functions}}

@cython.embedsignature(True)
def cuArrayGetSparseProperties(array):
    """ Returns the layout properties of a sparse CUDA array.

    Returns the layout properties of a sparse CUDA array in
    `sparseProperties` If the CUDA array is not allocated with flag
    :py:obj:`~.CUDA_ARRAY3D_SPARSE` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    will be returned.

    If the returned value in :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.flags`
    contains :py:obj:`~.CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL`, then
    :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailSize` represents the
    total size of the array. Otherwise, it will be zero. Also, the returned
    value in :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailFirstLevel` is
    always zero. Note that the `array` must have been allocated using
    :py:obj:`~.cuArrayCreate` or :py:obj:`~.cuArray3DCreate`. For CUDA
    arrays obtained using :py:obj:`~.cuMipmappedArrayGetLevel`,
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned. Instead,
    :py:obj:`~.cuMipmappedArrayGetSparseProperties` must be used to obtain
    the sparse properties of the entire CUDA mipmapped array to which
    `array` belongs to.

    Parameters
    ----------
    array : :py:obj:`~.CUarray`
        CUDA array to get the sparse properties of

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    sparseProperties : :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES`
        Pointer to :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES`

    See Also
    --------
    :py:obj:`~.cuMipmappedArrayGetSparseProperties`, :py:obj:`~.cuMemMapArrayAsync`
    """
    cdef cydriver.CUarray cyarray
    if array is None:
        parray = 0
    elif isinstance(array, (CUarray,)):
        parray = int(array)
    else:
        parray = int(CUarray(array))
    cyarray = <cydriver.CUarray><void_ptr>parray
    cdef CUDA_ARRAY_SPARSE_PROPERTIES sparseProperties = CUDA_ARRAY_SPARSE_PROPERTIES()
    with nogil:
        err = cydriver.cuArrayGetSparseProperties(<cydriver.CUDA_ARRAY_SPARSE_PROPERTIES*>sparseProperties._pvt_ptr, cyarray)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], sparseProperties)
{{endif}}

{{if 'cuMipmappedArrayGetSparseProperties' in found_functions}}

@cython.embedsignature(True)
def cuMipmappedArrayGetSparseProperties(mipmap):
    """ Returns the layout properties of a sparse CUDA mipmapped array.

    Returns the sparse array layout properties in `sparseProperties` If the
    CUDA mipmapped array is not allocated with flag
    :py:obj:`~.CUDA_ARRAY3D_SPARSE` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    will be returned.

    For non-layered CUDA mipmapped arrays,
    :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailSize` returns the size
    of the mip tail region. The mip tail region includes all mip levels
    whose width, height or depth is less than that of the tile. For layered
    CUDA mipmapped arrays, if
    :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.flags` contains
    :py:obj:`~.CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL`, then
    :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailSize` specifies the size
    of the mip tail of all layers combined. Otherwise,
    :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailSize` specifies mip tail
    size per layer. The returned value of
    :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailFirstLevel` is valid
    only if :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailSize` is non-
    zero.

    Parameters
    ----------
    mipmap : :py:obj:`~.CUmipmappedArray`
        CUDA mipmapped array to get the sparse properties of

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    sparseProperties : :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES`
        Pointer to :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES`

    See Also
    --------
    :py:obj:`~.cuArrayGetSparseProperties`, :py:obj:`~.cuMemMapArrayAsync`
    """
    cdef cydriver.CUmipmappedArray cymipmap
    if mipmap is None:
        pmipmap = 0
    elif isinstance(mipmap, (CUmipmappedArray,)):
        pmipmap = int(mipmap)
    else:
        pmipmap = int(CUmipmappedArray(mipmap))
    cymipmap = <cydriver.CUmipmappedArray><void_ptr>pmipmap
    cdef CUDA_ARRAY_SPARSE_PROPERTIES sparseProperties = CUDA_ARRAY_SPARSE_PROPERTIES()
    with nogil:
        err = cydriver.cuMipmappedArrayGetSparseProperties(<cydriver.CUDA_ARRAY_SPARSE_PROPERTIES*>sparseProperties._pvt_ptr, cymipmap)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], sparseProperties)
{{endif}}

{{if 'cuArrayGetMemoryRequirements' in found_functions}}

@cython.embedsignature(True)
def cuArrayGetMemoryRequirements(array, device):
    """ Returns the memory requirements of a CUDA array.

    Returns the memory requirements of a CUDA array in `memoryRequirements`
    If the CUDA array is not allocated with flag
    :py:obj:`~.CUDA_ARRAY3D_DEFERRED_MAPPING`
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned.

    The returned value in :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS.size`
    represents the total size of the CUDA array. The returned value in
    :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS.alignment` represents the
    alignment necessary for mapping the CUDA array.

    Parameters
    ----------
    array : :py:obj:`~.CUarray`
        CUDA array to get the memory requirements of
    device : :py:obj:`~.CUdevice`
        Device to get the memory requirements for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    memoryRequirements : :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS`
        Pointer to :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS`

    See Also
    --------
    :py:obj:`~.cuMipmappedArrayGetMemoryRequirements`, :py:obj:`~.cuMemMapArrayAsync`
    """
    cdef cydriver.CUdevice cydevice
    if device is None:
        pdevice = 0
    elif isinstance(device, (CUdevice,)):
        pdevice = int(device)
    else:
        pdevice = int(CUdevice(device))
    cydevice = <cydriver.CUdevice>pdevice
    cdef cydriver.CUarray cyarray
    if array is None:
        parray = 0
    elif isinstance(array, (CUarray,)):
        parray = int(array)
    else:
        parray = int(CUarray(array))
    cyarray = <cydriver.CUarray><void_ptr>parray
    cdef CUDA_ARRAY_MEMORY_REQUIREMENTS memoryRequirements = CUDA_ARRAY_MEMORY_REQUIREMENTS()
    with nogil:
        err = cydriver.cuArrayGetMemoryRequirements(<cydriver.CUDA_ARRAY_MEMORY_REQUIREMENTS*>memoryRequirements._pvt_ptr, cyarray, cydevice)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], memoryRequirements)
{{endif}}

{{if 'cuMipmappedArrayGetMemoryRequirements' in found_functions}}

@cython.embedsignature(True)
def cuMipmappedArrayGetMemoryRequirements(mipmap, device):
    """ Returns the memory requirements of a CUDA mipmapped array.

    Returns the memory requirements of a CUDA mipmapped array in
    `memoryRequirements` If the CUDA mipmapped array is not allocated with
    flag :py:obj:`~.CUDA_ARRAY3D_DEFERRED_MAPPING`
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned.

    The returned value in :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS.size`
    represents the total size of the CUDA mipmapped array. The returned
    value in :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS.alignment`
    represents the alignment necessary for mapping the CUDA mipmapped
    array.

    Parameters
    ----------
    mipmap : :py:obj:`~.CUmipmappedArray`
        CUDA mipmapped array to get the memory requirements of
    device : :py:obj:`~.CUdevice`
        Device to get the memory requirements for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    memoryRequirements : :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS`
        Pointer to :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS`

    See Also
    --------
    :py:obj:`~.cuArrayGetMemoryRequirements`, :py:obj:`~.cuMemMapArrayAsync`
    """
    cdef cydriver.CUdevice cydevice
    if device is None:
        pdevice = 0
    elif isinstance(device, (CUdevice,)):
        pdevice = int(device)
    else:
        pdevice = int(CUdevice(device))
    cydevice = <cydriver.CUdevice>pdevice
    cdef cydriver.CUmipmappedArray cymipmap
    if mipmap is None:
        pmipmap = 0
    elif isinstance(mipmap, (CUmipmappedArray,)):
        pmipmap = int(mipmap)
    else:
        pmipmap = int(CUmipmappedArray(mipmap))
    cymipmap = <cydriver.CUmipmappedArray><void_ptr>pmipmap
    cdef CUDA_ARRAY_MEMORY_REQUIREMENTS memoryRequirements = CUDA_ARRAY_MEMORY_REQUIREMENTS()
    with nogil:
        err = cydriver.cuMipmappedArrayGetMemoryRequirements(<cydriver.CUDA_ARRAY_MEMORY_REQUIREMENTS*>memoryRequirements._pvt_ptr, cymipmap, cydevice)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], memoryRequirements)
{{endif}}

{{if 'cuArrayGetPlane' in found_functions}}

@cython.embedsignature(True)
def cuArrayGetPlane(hArray, unsigned int planeIdx):
    """ Gets a CUDA array plane from a CUDA array.

    Returns in `pPlaneArray` a CUDA array that represents a single format
    plane of the CUDA array `hArray`.

    If `planeIdx` is greater than the maximum number of planes in this
    array or if the array does not have a multi-planar format e.g:
    :py:obj:`~.CU_AD_FORMAT_NV12`, then
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

    Note that if the `hArray` has format :py:obj:`~.CU_AD_FORMAT_NV12`,
    then passing in 0 for `planeIdx` returns a CUDA array of the same size
    as `hArray` but with one channel and
    :py:obj:`~.CU_AD_FORMAT_UNSIGNED_INT8` as its format. If 1 is passed
    for `planeIdx`, then the returned CUDA array has half the height and
    width of `hArray` with two channels and
    :py:obj:`~.CU_AD_FORMAT_UNSIGNED_INT8` as its format.

    Parameters
    ----------
    hArray : :py:obj:`~.CUarray`
        Multiplanar CUDA array
    planeIdx : unsigned int
        Plane index

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    pPlaneArray : :py:obj:`~.CUarray`
        Returned CUDA array referenced by the `planeIdx`

    See Also
    --------
    :py:obj:`~.cuArrayCreate`, :py:obj:`~.cudaArrayGetPlane`
    """
    cdef cydriver.CUarray cyhArray
    if hArray is None:
        phArray = 0
    elif isinstance(hArray, (CUarray,)):
        phArray = int(hArray)
    else:
        phArray = int(CUarray(hArray))
    cyhArray = <cydriver.CUarray><void_ptr>phArray
    cdef CUarray pPlaneArray = CUarray()
    with nogil:
        err = cydriver.cuArrayGetPlane(<cydriver.CUarray*>pPlaneArray._pvt_ptr, cyhArray, planeIdx)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pPlaneArray)
{{endif}}

{{if 'cuArrayDestroy' in found_functions}}

@cython.embedsignature(True)
def cuArrayDestroy(hArray):
    """ Destroys a CUDA array.

    Destroys the CUDA array `hArray`.

    Parameters
    ----------
    hArray : :py:obj:`~.CUarray`
        Array to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ARRAY_IS_MAPPED`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaFreeArray`
    """
    cdef cydriver.CUarray cyhArray
    if hArray is None:
        phArray = 0
    elif isinstance(hArray, (CUarray,)):
        phArray = int(hArray)
    else:
        phArray = int(CUarray(hArray))
    cyhArray = <cydriver.CUarray><void_ptr>phArray
    with nogil:
        err = cydriver.cuArrayDestroy(cyhArray)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuArray3DCreate_v2' in found_functions}}

@cython.embedsignature(True)
def cuArray3DCreate(pAllocateArray : Optional[CUDA_ARRAY3D_DESCRIPTOR]):
    """ Creates a 3D CUDA array.

    Creates a CUDA array according to the
    :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR` structure `pAllocateArray` and
    returns a handle to the new CUDA array in `*pHandle`. The
    :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - `Width`, `Height`, and `Depth` are the width, height, and depth of
      the CUDA array (in elements); the following types of CUDA arrays can
      be allocated:

      - A 1D array is allocated if `Height` and `Depth` extents are both
        zero.

      - A 2D array is allocated if only `Depth` extent is zero.

      - A 3D array is allocated if all three extents are non-zero.

      - A 1D layered CUDA array is allocated if only `Height` is zero and
        the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is set. Each layer is a
        1D array. The number of layers is determined by the depth extent.

      - A 2D layered CUDA array is allocated if all three extents are non-
        zero and the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is set. Each
        layer is a 2D array. The number of layers is determined by the
        depth extent.

      - A cubemap CUDA array is allocated if all three extents are non-zero
        and the :py:obj:`~.CUDA_ARRAY3D_CUBEMAP` flag is set. `Width` must
        be equal to `Height`, and `Depth` must be six. A cubemap is a
        special type of 2D layered CUDA array, where the six layers
        represent the six faces of a cube. The order of the six layers in
        memory is the same as that listed in
        :py:obj:`~.CUarray_cubemap_face`.

      - A cubemap layered CUDA array is allocated if all three extents are
        non-zero, and both, :py:obj:`~.CUDA_ARRAY3D_CUBEMAP` and
        :py:obj:`~.CUDA_ARRAY3D_LAYERED` flags are set. `Width` must be
        equal to `Height`, and `Depth` must be a multiple of six. A cubemap
        layered CUDA array is a special type of 2D layered CUDA array that
        consists of a collection of cubemaps. The first six layers
        represent the first cubemap, the next six layers form the second
        cubemap, and so on.

    - :py:obj:`~.Format` specifies the format of the elements;
      :py:obj:`~.CUarray_format` is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - `NumChannels` specifies the number of packed components per CUDA
      array element; it may be 1, 2, or 4;

    - :py:obj:`~.Flags` may be set to

      - :py:obj:`~.CUDA_ARRAY3D_LAYERED` to enable creation of layered CUDA
        arrays. If this flag is set, `Depth` specifies the number of
        layers, not the depth of a 3D array.

      - :py:obj:`~.CUDA_ARRAY3D_SURFACE_LDST` to enable surface references
        to be bound to the CUDA array. If this flag is not set,
        :py:obj:`~.cuSurfRefSetArray` will fail when attempting to bind the
        CUDA array to a surface reference.

      - :py:obj:`~.CUDA_ARRAY3D_CUBEMAP` to enable creation of cubemaps. If
        this flag is set, `Width` must be equal to `Height`, and `Depth`
        must be six. If the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is also
        set, then `Depth` must be a multiple of six.

      - :py:obj:`~.CUDA_ARRAY3D_TEXTURE_GATHER` to indicate that the CUDA
        array will be used for texture gather. Texture gather can only be
        performed on 2D CUDA arrays.

    `Width`, `Height` and `Depth` must meet certain size requirements as
    listed in the following table. All values are specified in elements.
    Note that for brevity's sake, the full name of the device attribute is
    not specified. For ex., TEXTURE1D_WIDTH refers to the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH`.

    Note that 2D CUDA arrays have different size requirements if the
    :py:obj:`~.CUDA_ARRAY3D_TEXTURE_GATHER` flag is set. `Width` and
    `Height` must not be greater than
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH` and
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT`
    respectively, in that case.

    **View CUDA Toolkit Documentation for a table example**

    Here are examples of CUDA array descriptions:

    Description for a CUDA array of 2048 floats:

    **View CUDA Toolkit Documentation for a C++ code example**

    Description for a 64 x 64 CUDA array of floats:

    **View CUDA Toolkit Documentation for a C++ code example**

    Description for a `width` x `height` x `depth` CUDA array of 64-bit,
    4x16-bit float16's:

    **View CUDA Toolkit Documentation for a C++ code example**

    Parameters
    ----------
    pAllocateArray : :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR`
        3D array descriptor

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    pHandle : :py:obj:`~.CUarray`
        Returned array

    See Also
    --------
    :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMalloc3DArray`
    """
    cdef CUarray pHandle = CUarray()
    cdef cydriver.CUDA_ARRAY3D_DESCRIPTOR* cypAllocateArray_ptr = pAllocateArray._pvt_ptr if pAllocateArray is not None else NULL
    with nogil:
        err = cydriver.cuArray3DCreate(<cydriver.CUarray*>pHandle._pvt_ptr, cypAllocateArray_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pHandle)
{{endif}}

{{if 'cuArray3DGetDescriptor_v2' in found_functions}}

@cython.embedsignature(True)
def cuArray3DGetDescriptor(hArray):
    """ Get a 3D CUDA array descriptor.

    Returns in `*pArrayDescriptor` a descriptor containing information on
    the format and dimensions of the CUDA array `hArray`. It is useful for
    subroutines that have been passed a CUDA array, but need to know the
    CUDA array parameters for validation or other purposes.

    This function may be called on 1D and 2D arrays, in which case the
    `Height` and/or `Depth` members of the descriptor struct will be set to
    0.

    Parameters
    ----------
    hArray : :py:obj:`~.CUarray`
        3D array to get descriptor of

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`
    pArrayDescriptor : :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR`
        Returned 3D array descriptor

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaArrayGetInfo`
    """
    cdef cydriver.CUarray cyhArray
    if hArray is None:
        phArray = 0
    elif isinstance(hArray, (CUarray,)):
        phArray = int(hArray)
    else:
        phArray = int(CUarray(hArray))
    cyhArray = <cydriver.CUarray><void_ptr>phArray
    cdef CUDA_ARRAY3D_DESCRIPTOR pArrayDescriptor = CUDA_ARRAY3D_DESCRIPTOR()
    with nogil:
        err = cydriver.cuArray3DGetDescriptor(<cydriver.CUDA_ARRAY3D_DESCRIPTOR*>pArrayDescriptor._pvt_ptr, cyhArray)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pArrayDescriptor)
{{endif}}

{{if 'cuMipmappedArrayCreate' in found_functions}}

@cython.embedsignature(True)
def cuMipmappedArrayCreate(pMipmappedArrayDesc : Optional[CUDA_ARRAY3D_DESCRIPTOR], unsigned int numMipmapLevels):
    """ Creates a CUDA mipmapped array.

    Creates a CUDA mipmapped array according to the
    :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR` structure `pMipmappedArrayDesc` and
    returns a handle to the new CUDA mipmapped array in `*pHandle`.
    `numMipmapLevels` specifies the number of mipmap levels to be
    allocated. This value is clamped to the range [1, 1 +
    floor(log2(max(width, height, depth)))].

    The :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - `Width`, `Height`, and `Depth` are the width, height, and depth of
      the CUDA array (in elements); the following types of CUDA arrays can
      be allocated:

      - A 1D mipmapped array is allocated if `Height` and `Depth` extents
        are both zero.

      - A 2D mipmapped array is allocated if only `Depth` extent is zero.

      - A 3D mipmapped array is allocated if all three extents are non-
        zero.

      - A 1D layered CUDA mipmapped array is allocated if only `Height` is
        zero and the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is set. Each
        layer is a 1D array. The number of layers is determined by the
        depth extent.

      - A 2D layered CUDA mipmapped array is allocated if all three extents
        are non-zero and the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is set.
        Each layer is a 2D array. The number of layers is determined by the
        depth extent.

      - A cubemap CUDA mipmapped array is allocated if all three extents
        are non-zero and the :py:obj:`~.CUDA_ARRAY3D_CUBEMAP` flag is set.
        `Width` must be equal to `Height`, and `Depth` must be six. A
        cubemap is a special type of 2D layered CUDA array, where the six
        layers represent the six faces of a cube. The order of the six
        layers in memory is the same as that listed in
        :py:obj:`~.CUarray_cubemap_face`.

      - A cubemap layered CUDA mipmapped array is allocated if all three
        extents are non-zero, and both, :py:obj:`~.CUDA_ARRAY3D_CUBEMAP`
        and :py:obj:`~.CUDA_ARRAY3D_LAYERED` flags are set. `Width` must be
        equal to `Height`, and `Depth` must be a multiple of six. A cubemap
        layered CUDA array is a special type of 2D layered CUDA array that
        consists of a collection of cubemaps. The first six layers
        represent the first cubemap, the next six layers form the second
        cubemap, and so on.

    - :py:obj:`~.Format` specifies the format of the elements;
      :py:obj:`~.CUarray_format` is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - `NumChannels` specifies the number of packed components per CUDA
      array element; it may be 1, 2, or 4;

    - :py:obj:`~.Flags` may be set to

      - :py:obj:`~.CUDA_ARRAY3D_LAYERED` to enable creation of layered CUDA
        mipmapped arrays. If this flag is set, `Depth` specifies the number
        of layers, not the depth of a 3D array.

      - :py:obj:`~.CUDA_ARRAY3D_SURFACE_LDST` to enable surface references
        to be bound to individual mipmap levels of the CUDA mipmapped
        array. If this flag is not set, :py:obj:`~.cuSurfRefSetArray` will
        fail when attempting to bind a mipmap level of the CUDA mipmapped
        array to a surface reference.

    - :py:obj:`~.CUDA_ARRAY3D_CUBEMAP` to enable creation of mipmapped
    cubemaps. If this flag is set, `Width` must be equal to `Height`, and
    `Depth` must be six. If the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is
    also set, then `Depth` must be a multiple of six.

      - :py:obj:`~.CUDA_ARRAY3D_TEXTURE_GATHER` to indicate that the CUDA
        mipmapped array will be used for texture gather. Texture gather can
        only be performed on 2D CUDA mipmapped arrays.

    `Width`, `Height` and `Depth` must meet certain size requirements as
    listed in the following table. All values are specified in elements.
    Note that for brevity's sake, the full name of the device attribute is
    not specified. For ex., TEXTURE1D_MIPMAPPED_WIDTH refers to the device
    attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH`.

    **View CUDA Toolkit Documentation for a table example**

    Parameters
    ----------
    pMipmappedArrayDesc : :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR`
        mipmapped array descriptor
    numMipmapLevels : unsigned int
        Number of mipmap levels

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    pHandle : :py:obj:`~.CUmipmappedArray`
        Returned mipmapped array

    See Also
    --------
    :py:obj:`~.cuMipmappedArrayDestroy`, :py:obj:`~.cuMipmappedArrayGetLevel`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cudaMallocMipmappedArray`
    """
    cdef CUmipmappedArray pHandle = CUmipmappedArray()
    cdef cydriver.CUDA_ARRAY3D_DESCRIPTOR* cypMipmappedArrayDesc_ptr = pMipmappedArrayDesc._pvt_ptr if pMipmappedArrayDesc is not None else NULL
    with nogil:
        err = cydriver.cuMipmappedArrayCreate(<cydriver.CUmipmappedArray*>pHandle._pvt_ptr, cypMipmappedArrayDesc_ptr, numMipmapLevels)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pHandle)
{{endif}}

{{if 'cuMipmappedArrayGetLevel' in found_functions}}

@cython.embedsignature(True)
def cuMipmappedArrayGetLevel(hMipmappedArray, unsigned int level):
    """ Gets a mipmap level of a CUDA mipmapped array.

    Returns in `*pLevelArray` a CUDA array that represents a single mipmap
    level of the CUDA mipmapped array `hMipmappedArray`.

    If `level` is greater than the maximum number of levels in this
    mipmapped array, :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

    Parameters
    ----------
    hMipmappedArray : :py:obj:`~.CUmipmappedArray`
        CUDA mipmapped array
    level : unsigned int
        Mipmap level

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    pLevelArray : :py:obj:`~.CUarray`
        Returned mipmap level CUDA array

    See Also
    --------
    :py:obj:`~.cuMipmappedArrayCreate`, :py:obj:`~.cuMipmappedArrayDestroy`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cudaGetMipmappedArrayLevel`
    """
    cdef cydriver.CUmipmappedArray cyhMipmappedArray
    if hMipmappedArray is None:
        phMipmappedArray = 0
    elif isinstance(hMipmappedArray, (CUmipmappedArray,)):
        phMipmappedArray = int(hMipmappedArray)
    else:
        phMipmappedArray = int(CUmipmappedArray(hMipmappedArray))
    cyhMipmappedArray = <cydriver.CUmipmappedArray><void_ptr>phMipmappedArray
    cdef CUarray pLevelArray = CUarray()
    with nogil:
        err = cydriver.cuMipmappedArrayGetLevel(<cydriver.CUarray*>pLevelArray._pvt_ptr, cyhMipmappedArray, level)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pLevelArray)
{{endif}}

{{if 'cuMipmappedArrayDestroy' in found_functions}}

@cython.embedsignature(True)
def cuMipmappedArrayDestroy(hMipmappedArray):
    """ Destroys a CUDA mipmapped array.

    Destroys the CUDA mipmapped array `hMipmappedArray`.

    Parameters
    ----------
    hMipmappedArray : :py:obj:`~.CUmipmappedArray`
        Mipmapped array to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ARRAY_IS_MAPPED`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`

    See Also
    --------
    :py:obj:`~.cuMipmappedArrayCreate`, :py:obj:`~.cuMipmappedArrayGetLevel`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cudaFreeMipmappedArray`
    """
    cdef cydriver.CUmipmappedArray cyhMipmappedArray
    if hMipmappedArray is None:
        phMipmappedArray = 0
    elif isinstance(hMipmappedArray, (CUmipmappedArray,)):
        phMipmappedArray = int(hMipmappedArray)
    else:
        phMipmappedArray = int(CUmipmappedArray(hMipmappedArray))
    cyhMipmappedArray = <cydriver.CUmipmappedArray><void_ptr>phMipmappedArray
    with nogil:
        err = cydriver.cuMipmappedArrayDestroy(cyhMipmappedArray)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemGetHandleForAddressRange' in found_functions}}

@cython.embedsignature(True)
def cuMemGetHandleForAddressRange(dptr, size_t size, handleType not None : CUmemRangeHandleType, unsigned long long flags):
    """ Retrieve handle for an address range.

    Get a handle of the specified type to an address range. When requesting
    CUmemRangeHandleType::CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD, address
    range obtained by a prior call to either :py:obj:`~.cuMemAlloc` or
    :py:obj:`~.cuMemAddressReserve` is supported if the
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED` device attribute
    returns true. If the address range was obtained via
    :py:obj:`~.cuMemAddressReserve`, it must also be fully mapped via
    :py:obj:`~.cuMemMap`. Address range obtained by a prior call to either
    :py:obj:`~.cuMemAllocHost` or :py:obj:`~.cuMemHostAlloc` is supported
    if the :py:obj:`~.CU_DEVICE_ATTRIBUTE_HOST_ALLOC_DMA_BUF_SUPPORTED`
    device attribute returns true.

    As of CUDA 13.0, querying support for address range obtained by calling
    :py:obj:`~.cuMemAllocHost` or :py:obj:`~.cuMemHostAlloc` using the
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED` device attribute is
    deprecated.

    Users must ensure the `dptr` and `size` are aligned to the host page
    size.

    The `handle` will be interpreted as a pointer to an integer to store
    the dma_buf file descriptor. Users must ensure the entire address range
    is backed and mapped when the address range is allocated by
    :py:obj:`~.cuMemAddressReserve`. All the physical allocations backing
    the address range must be resident on the same device and have
    identical allocation properties. Users are also expected to retrieve a
    new handle every time the underlying physical allocation(s)
    corresponding to a previously queried VA range are changed.

    For CUmemRangeHandleType::CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD, users
    may set flags to
    :py:obj:`~.CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE`. Which when set
    on a supported platform, will give a DMA_BUF handle mapped via PCIE
    BAR1 or will return an error otherwise.

    Parameters
    ----------
    dptr : :py:obj:`~.CUdeviceptr`
        Pointer to a valid CUDA device allocation. Must be aligned to host
        page size.
    size : size_t
        Length of the address range. Must be aligned to host page size.
    handleType : :py:obj:`~.CUmemRangeHandleType`
        Type of handle requested (defines type and size of the `handle`
        output parameter)
    flags : unsigned long long
        When requesting
        CUmemRangeHandleType::CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD the value
        could be :py:obj:`~.CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE`,
        otherwise 0.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    handle : Any
        Pointer to the location where the returned handle will be stored.
    """
    cdef cydriver.CUdeviceptr cydptr
    if dptr is None:
        pdptr = 0
    elif isinstance(dptr, (CUdeviceptr,)):
        pdptr = int(dptr)
    else:
        pdptr = int(CUdeviceptr(dptr))
    cydptr = <cydriver.CUdeviceptr><void_ptr>pdptr
    cdef int handle = 0
    cdef void* cyhandle_ptr = <void*>&handle
    cdef cydriver.CUmemRangeHandleType cyhandleType = handleType.value
    with nogil:
        err = cydriver.cuMemGetHandleForAddressRange(cyhandle_ptr, cydptr, size, cyhandleType, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], handle)
{{endif}}

{{if 'cuMemBatchDecompressAsync' in found_functions}}

@cython.embedsignature(True)
def cuMemBatchDecompressAsync(paramsArray : Optional[CUmemDecompressParams], size_t count, unsigned int flags, stream):
    """ Submit a batch of `count` independent decompression operations.

    Each of the `count` decompression operations is described by a single
    entry in the `paramsArray` array. Once the batch has been submitted,
    the function will return, and decompression will happen asynchronously
    w.r.t. the CPU. To the work completion tracking mechanisms in the CUDA
    driver, the batch will be considered a single unit of work and
    processed according to stream semantics, i.e., it is not possible to
    query the completion of individual decompression operations within a
    batch.

    The memory pointed to by each of :py:obj:`~.CUmemDecompressParams.src`,
    :py:obj:`~.CUmemDecompressParams.dst`, and
    :py:obj:`~.CUmemDecompressParams.dstActBytes`, must be capable of usage
    with the hardware decompress feature. That is, for each of said
    pointers, the pointer attribute
    :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE` should give a
    non-zero value. To ensure this, the memory backing the pointers should
    have been allocated using one of the following CUDA memory allocators:

    - :py:obj:`~.cuMemAlloc()`

    - :py:obj:`~.cuMemCreate()` with the usage flag
      :py:obj:`~.CU_MEM_CREATE_USAGE_HW_DECOMPRESS`

    - :py:obj:`~.cuMemAllocFromPoolAsync()` from a pool that was created
      with the usage flag
      :py:obj:`~.CU_MEM_POOL_CREATE_USAGE_HW_DECOMPRESS` Additionally,
      :py:obj:`~.CUmemDecompressParams.src`,
      :py:obj:`~.CUmemDecompressParams.dst`, and
      :py:obj:`~.CUmemDecompressParams.dstActBytes`, must all be accessible
      from the device associated with the context where `stream` was
      created. For information on how to ensure this, see the documentation
      for the allocator of interest.

    Parameters
    ----------
    paramsArray : :py:obj:`~.CUmemDecompressParams`
        The array of structures describing the independent decompression
        operations.
    count : size_t
        The number of entries in `paramsArray` array.
    flags : unsigned int
        Must be 0.
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream where the work will be enqueued.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    errorIndex : int
        The index into `paramsArray` of the decompression operation for
        which the error returned by this function pertains to. If `index`
        is SIZE_MAX and the value returned is not :py:obj:`~.CUDA_SUCCESS`,
        then the error returned by this function should be considered a
        general error that does not pertain to a particular decompression
        operation. May be `NULL`, in which case, no index will be recorded
        in the event of error.

    See Also
    --------
    :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuMemAllocFromPoolAsync`
    """
    cdef cydriver.CUstream cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (CUstream,)):
        pstream = int(stream)
    else:
        pstream = int(CUstream(stream))
    cystream = <cydriver.CUstream><void_ptr>pstream
    cdef cydriver.CUmemDecompressParams* cyparamsArray_ptr = paramsArray._pvt_ptr if paramsArray is not None else NULL
    cdef size_t errorIndex = 0
    with nogil:
        err = cydriver.cuMemBatchDecompressAsync(cyparamsArray_ptr, count, flags, &errorIndex, cystream)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], errorIndex)
{{endif}}

{{if 'cuMemAddressReserve' in found_functions}}

@cython.embedsignature(True)
def cuMemAddressReserve(size_t size, size_t alignment, addr, unsigned long long flags):
    """ Allocate an address range reservation.

    Reserves a virtual address range based on the given parameters, giving
    the starting address of the range in `ptr`. This API requires a system
    that supports UVA. The size and address parameters must be a multiple
    of the host page size and the alignment must be a power of two or zero
    for default alignment. If `addr` is 0, then the driver chooses the
    address at which to place the start of the reservation whereas when it
    is non-zero then the driver treats it as a hint about where to place
    the reservation.

    Parameters
    ----------
    size : size_t
        Size of the reserved virtual address range requested
    alignment : size_t
        Alignment of the reserved virtual address range requested
    addr : :py:obj:`~.CUdeviceptr`
        Hint address for the start of the address range
    flags : unsigned long long
        Currently unused, must be zero

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    ptr : :py:obj:`~.CUdeviceptr`
        Resulting pointer to start of virtual address range allocated

    See Also
    --------
    :py:obj:`~.cuMemAddressFree`
    """
    cdef cydriver.CUdeviceptr cyaddr
    if addr is None:
        paddr = 0
    elif isinstance(addr, (CUdeviceptr,)):
        paddr = int(addr)
    else:
        paddr = int(CUdeviceptr(addr))
    cyaddr = <cydriver.CUdeviceptr><void_ptr>paddr
    cdef CUdeviceptr ptr = CUdeviceptr()
    with nogil:
        err = cydriver.cuMemAddressReserve(<cydriver.CUdeviceptr*>ptr._pvt_ptr, size, alignment, cyaddr, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], ptr)
{{endif}}

{{if 'cuMemAddressFree' in found_functions}}

@cython.embedsignature(True)
def cuMemAddressFree(ptr, size_t size):
    """ Free an address range reservation.

    Frees a virtual address range reserved by cuMemAddressReserve. The size
    must match what was given to memAddressReserve and the ptr given must
    match what was returned from memAddressReserve.

    Parameters
    ----------
    ptr : :py:obj:`~.CUdeviceptr`
        Starting address of the virtual address range to free
    size : size_t
        Size of the virtual address region to free

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuMemAddressReserve`
    """
    cdef cydriver.CUdeviceptr cyptr
    if ptr is None:
        pptr = 0
    elif isinstance(ptr, (CUdeviceptr,)):
        pptr = int(ptr)
    else:
        pptr = int(CUdeviceptr(ptr))
    cyptr = <cydriver.CUdeviceptr><void_ptr>pptr
    with nogil:
        err = cydriver.cuMemAddressFree(cyptr, size)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemCreate' in found_functions}}

@cython.embedsignature(True)
def cuMemCreate(size_t size, prop : Optional[CUmemAllocationProp], unsigned long long flags):
    """ Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.

    This creates a memory allocation on the target device specified through
    the `prop` structure. The created allocation will not have any device
    or host mappings. The generic memory `handle` for the allocation can be
    mapped to the address space of calling process via
    :py:obj:`~.cuMemMap`. This handle cannot be transmitted directly to
    other processes (see :py:obj:`~.cuMemExportToShareableHandle`). On
    Windows, the caller must also pass an LPSECURITYATTRIBUTE in `prop` to
    be associated with this handle which limits or allows access to this
    handle for a recipient process (see
    :py:obj:`~.CUmemAllocationProp.win32HandleMetaData` for more). The
    `size` of this allocation must be a multiple of the the value given via
    :py:obj:`~.cuMemGetAllocationGranularity` with the
    :py:obj:`~.CU_MEM_ALLOC_GRANULARITY_MINIMUM` flag. To create a CPU
    allocation that doesn't target any specific NUMA nodes, applications
    must set :py:obj:`~.CUmemAllocationProp`::CUmemLocation::type to
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST`.
    :py:obj:`~.CUmemAllocationProp`::CUmemLocation::id is ignored for HOST
    allocations. HOST allocations are not IPC capable and
    :py:obj:`~.CUmemAllocationProp.requestedHandleTypes` must be 0, any
    other value will result in :py:obj:`~.CUDA_ERROR_INVALID_VALUE`. To
    create a CPU allocation targeting a specific host NUMA node,
    applications must set
    :py:obj:`~.CUmemAllocationProp`::CUmemLocation::type to
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA` and
    :py:obj:`~.CUmemAllocationProp`::CUmemLocation::id must specify the
    NUMA ID of the CPU. On systems where NUMA is not available
    :py:obj:`~.CUmemAllocationProp`::CUmemLocation::id must be set to 0.
    Specifying :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT` as the
    :py:obj:`~.CUmemLocation.type` will result in
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

    Applications that intend to use :py:obj:`~.CU_MEM_HANDLE_TYPE_FABRIC`
    based memory sharing must ensure: (1) `nvidia-caps-imex-channels`
    character device is created by the driver and is listed under
    /proc/devices (2) have at least one IMEX channel file accessible by the
    user launching the application.

    When exporter and importer CUDA processes have been granted access to
    the same IMEX channel, they can securely share memory.

    The IMEX channel security model works on a per user basis. Which means
    all processes under a user can share memory if the user has access to a
    valid IMEX channel. When multi-user isolation is desired, a separate
    IMEX channel is required for each user.

    These channel files exist in /dev/nvidia-caps-imex-channels/channel*
    and can be created using standard OS native calls like mknod on Linux.
    For example: To create channel0 with the major number from
    /proc/devices users can execute the following command: `mknod
    /dev/nvidia-caps-imex-channels/channel0 c <major number> 0`

    If :py:obj:`~.CUmemAllocationProp`::allocFlags::usage contains
    :py:obj:`~.CU_MEM_CREATE_USAGE_TILE_POOL` flag then the memory
    allocation is intended only to be used as backing tile pool for sparse
    CUDA arrays and sparse CUDA mipmapped arrays. (see
    :py:obj:`~.cuMemMapArrayAsync`).

    Parameters
    ----------
    size : size_t
        Size of the allocation requested
    prop : :py:obj:`~.CUmemAllocationProp`
        Properties of the allocation to create.
    flags : unsigned long long
        flags for future use, must be zero now.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    handle : :py:obj:`~.CUmemGenericAllocationHandle`
        Value of handle returned. All operations on this allocation are to
        be performed using this handle.

    See Also
    --------
    :py:obj:`~.cuMemRelease`, :py:obj:`~.cuMemExportToShareableHandle`, :py:obj:`~.cuMemImportFromShareableHandle`
    """
    cdef CUmemGenericAllocationHandle handle = CUmemGenericAllocationHandle()
    cdef cydriver.CUmemAllocationProp* cyprop_ptr = prop._pvt_ptr if prop is not None else NULL
    with nogil:
        err = cydriver.cuMemCreate(<cydriver.CUmemGenericAllocationHandle*>handle._pvt_ptr, size, cyprop_ptr, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], handle)
{{endif}}

{{if 'cuMemRelease' in found_functions}}

@cython.embedsignature(True)
def cuMemRelease(handle):
    """ Release a memory handle representing a memory allocation which was previously allocated through cuMemCreate.

    Frees the memory that was allocated on a device through cuMemCreate.

    The memory allocation will be freed when all outstanding mappings to
    the memory are unmapped and when all outstanding references to the
    handle (including it's shareable counterparts) are also released. The
    generic memory handle can be freed when there are still outstanding
    mappings made with this handle. Each time a recipient process imports a
    shareable handle, it needs to pair it with :py:obj:`~.cuMemRelease` for
    the handle to be freed. If `handle` is not a valid handle the behavior
    is undefined.

    Parameters
    ----------
    handle : :py:obj:`~.CUmemGenericAllocationHandle`
        Value of handle which was returned previously by cuMemCreate.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuMemCreate`
    """
    cdef cydriver.CUmemGenericAllocationHandle cyhandle
    if handle is None:
        phandle = 0
    elif isinstance(handle, (CUmemGenericAllocationHandle,)):
        phandle = int(handle)
    else:
        phandle = int(CUmemGenericAllocationHandle(handle))
    cyhandle = <cydriver.CUmemGenericAllocationHandle><void_ptr>phandle
    with nogil:
        err = cydriver.cuMemRelease(cyhandle)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemMap' in found_functions}}

@cython.embedsignature(True)
def cuMemMap(ptr, size_t size, size_t offset, handle, unsigned long long flags):
    """ Maps an allocation handle to a reserved virtual address range.

    Maps bytes of memory represented by `handle` starting from byte
    `offset` to `size` to address range [`addr`, `addr` + `size`]. This
    range must be an address reservation previously reserved with
    :py:obj:`~.cuMemAddressReserve`, and `offset` + `size` must be less
    than the size of the memory allocation. Both `ptr`, `size`, and
    `offset` must be a multiple of the value given via
    :py:obj:`~.cuMemGetAllocationGranularity` with the
    :py:obj:`~.CU_MEM_ALLOC_GRANULARITY_MINIMUM` flag. If `handle`
    represents a multicast object, `ptr`, `size` and `offset` must be
    aligned to the value returned by :py:obj:`~.cuMulticastGetGranularity`
    with the flag :py:obj:`~.CU_MULTICAST_MINIMUM_GRANULARITY`. For best
    performance however, it is recommended that `ptr`, `size` and `offset`
    be aligned to the value returned by
    :py:obj:`~.cuMulticastGetGranularity` with the flag
    :py:obj:`~.CU_MULTICAST_RECOMMENDED_GRANULARITY`.

    When `handle` represents a multicast object, this call may return
    CUDA_ERROR_ILLEGAL_STATE if the system configuration is in an illegal
    state. In such cases, to continue using multicast, verify that the
    system configuration is in a valid state and all required driver
    daemons are running properly.

    Please note calling :py:obj:`~.cuMemMap` does not make the address
    accessible, the caller needs to update accessibility of a contiguous
    mapped VA range by calling :py:obj:`~.cuMemSetAccess`.

    Once a recipient process obtains a shareable memory handle from
    :py:obj:`~.cuMemImportFromShareableHandle`, the process must use
    :py:obj:`~.cuMemMap` to map the memory into its address ranges before
    setting accessibility with :py:obj:`~.cuMemSetAccess`.

    :py:obj:`~.cuMemMap` can only create mappings on VA range reservations
    that are not currently mapped.

    Parameters
    ----------
    ptr : :py:obj:`~.CUdeviceptr`
        Address where memory will be mapped.
    size : size_t
        Size of the memory mapping.
    offset : size_t
        Offset into the memory represented by
    handle : :py:obj:`~.CUmemGenericAllocationHandle`
        Handle to a shareable memory
    flags : unsigned long long
        flags for future use, must be zero now.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE`

    See Also
    --------
    :py:obj:`~.cuMemUnmap`, :py:obj:`~.cuMemSetAccess`, :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemAddressReserve`, :py:obj:`~.cuMemImportFromShareableHandle`
    """
    cdef cydriver.CUmemGenericAllocationHandle cyhandle
    if handle is None:
        phandle = 0
    elif isinstance(handle, (CUmemGenericAllocationHandle,)):
        phandle = int(handle)
    else:
        phandle = int(CUmemGenericAllocationHandle(handle))
    cyhandle = <cydriver.CUmemGenericAllocationHandle><void_ptr>phandle
    cdef cydriver.CUdeviceptr cyptr
    if ptr is None:
        pptr = 0
    elif isinstance(ptr, (CUdeviceptr,)):
        pptr = int(ptr)
    else:
        pptr = int(CUdeviceptr(ptr))
    cyptr = <cydriver.CUdeviceptr><void_ptr>pptr
    with nogil:
        err = cydriver.cuMemMap(cyptr, size, offset, cyhandle, flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemMapArrayAsync' in found_functions}}

@cython.embedsignature(True)
def cuMemMapArrayAsync(mapInfoList : Optional[tuple[CUarrayMapInfo] | list[CUarrayMapInfo]], unsigned int count, hStream):
    """ Maps or unmaps subregions of sparse CUDA arrays and sparse CUDA mipmapped arrays.

    Performs map or unmap operations on subregions of sparse CUDA arrays
    and sparse CUDA mipmapped arrays. Each operation is specified by a
    :py:obj:`~.CUarrayMapInfo` entry in the `mapInfoList` array of size
    `count`. The structure :py:obj:`~.CUarrayMapInfo` is defined as follow:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.CUarrayMapInfo.resourceType` specifies the type of
    resource to be operated on. If :py:obj:`~.CUarrayMapInfo.resourceType`
    is set to :py:obj:`~.CUresourcetype`::CU_RESOURCE_TYPE_ARRAY then
    :py:obj:`~.CUarrayMapInfo`::resource::array must be set to a valid
    sparse CUDA array handle. The CUDA array must be either a 2D, 2D
    layered or 3D CUDA array and must have been allocated using
    :py:obj:`~.cuArrayCreate` or :py:obj:`~.cuArray3DCreate` with the flag
    :py:obj:`~.CUDA_ARRAY3D_SPARSE` or
    :py:obj:`~.CUDA_ARRAY3D_DEFERRED_MAPPING`. For CUDA arrays obtained
    using :py:obj:`~.cuMipmappedArrayGetLevel`,
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned. If
    :py:obj:`~.CUarrayMapInfo.resourceType` is set to
    :py:obj:`~.CUresourcetype`::CU_RESOURCE_TYPE_MIPMAPPED_ARRAY then
    :py:obj:`~.CUarrayMapInfo`::resource::mipmap must be set to a valid
    sparse CUDA mipmapped array handle. The CUDA mipmapped array must be
    either a 2D, 2D layered or 3D CUDA mipmapped array and must have been
    allocated using :py:obj:`~.cuMipmappedArrayCreate` with the flag
    :py:obj:`~.CUDA_ARRAY3D_SPARSE` or
    :py:obj:`~.CUDA_ARRAY3D_DEFERRED_MAPPING`.

    :py:obj:`~.CUarrayMapInfo.subresourceType` specifies the type of
    subresource within the resource.
    :py:obj:`~.CUarraySparseSubresourceType_enum` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where
    :py:obj:`~.CUarraySparseSubresourceType`::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL
    indicates a sparse-miplevel which spans at least one tile in every
    dimension. The remaining miplevels which are too small to span at least
    one tile in any dimension constitute the mip tail region as indicated
    by
    :py:obj:`~.CUarraySparseSubresourceType`::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL
    subresource type.

    If :py:obj:`~.CUarrayMapInfo.subresourceType` is set to
    :py:obj:`~.CUarraySparseSubresourceType`::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL
    then :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel struct must
    contain valid array subregion offsets and extents. The
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::offsetX,
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::offsetY and
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::offsetZ must
    specify valid X, Y and Z offsets respectively. The
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::extentWidth,
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::extentHeight and
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::extentDepth must
    specify valid width, height and depth extents respectively. These
    offsets and extents must be aligned to the corresponding tile
    dimension. For CUDA mipmapped arrays
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::level must
    specify a valid mip level index. Otherwise, must be zero. For layered
    CUDA arrays and layered CUDA mipmapped arrays
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::layer must
    specify a valid layer index. Otherwise, must be zero.
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::offsetZ must be
    zero and
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::extentDepth must
    be set to 1 for 2D and 2D layered CUDA arrays and CUDA mipmapped
    arrays. Tile extents can be obtained by calling
    :py:obj:`~.cuArrayGetSparseProperties` and
    :py:obj:`~.cuMipmappedArrayGetSparseProperties`

    If :py:obj:`~.CUarrayMapInfo.subresourceType` is set to
    :py:obj:`~.CUarraySparseSubresourceType`::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL
    then :py:obj:`~.CUarrayMapInfo`::subresource::miptail struct must
    contain valid mip tail offset in
    :py:obj:`~.CUarrayMapInfo`::subresource::miptail::offset and size in
    :py:obj:`~.CUarrayMapInfo`::subresource::miptail::size. Both, mip tail
    offset and mip tail size must be aligned to the tile size. For layered
    CUDA mipmapped arrays which don't have the flag
    :py:obj:`~.CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL` set in
    :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.flags` as returned by
    :py:obj:`~.cuMipmappedArrayGetSparseProperties`,
    :py:obj:`~.CUarrayMapInfo`::subresource::miptail::layer must specify a
    valid layer index. Otherwise, must be zero.

    If :py:obj:`~.CUarrayMapInfo`::resource::array or
    :py:obj:`~.CUarrayMapInfo`::resource::mipmap was created with
    :py:obj:`~.CUDA_ARRAY3D_DEFERRED_MAPPING` flag set the
    :py:obj:`~.CUarrayMapInfo.subresourceType` and the contents of
    :py:obj:`~.CUarrayMapInfo`::subresource will be ignored.

    :py:obj:`~.CUarrayMapInfo.memOperationType` specifies the type of
    operation. :py:obj:`~.CUmemOperationType` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.CUarrayMapInfo.memOperationType` is set to
    :py:obj:`~.CUmemOperationType`::CU_MEM_OPERATION_TYPE_MAP then the
    subresource will be mapped onto the tile pool memory specified by
    :py:obj:`~.CUarrayMapInfo`::memHandle at offset
    :py:obj:`~.CUarrayMapInfo.offset`. The tile pool allocation has to be
    created by specifying the :py:obj:`~.CU_MEM_CREATE_USAGE_TILE_POOL`
    flag when calling :py:obj:`~.cuMemCreate`. Also,
    :py:obj:`~.CUarrayMapInfo.memHandleType` must be set to
    :py:obj:`~.CUmemHandleType`::CU_MEM_HANDLE_TYPE_GENERIC.

    If :py:obj:`~.CUarrayMapInfo.memOperationType` is set to
    :py:obj:`~.CUmemOperationType`::CU_MEM_OPERATION_TYPE_UNMAP then an
    unmapping operation is performed. :py:obj:`~.CUarrayMapInfo`::memHandle
    must be NULL.

    :py:obj:`~.CUarrayMapInfo.deviceBitMask` specifies the list of devices
    that must map or unmap physical memory. Currently, this mask must have
    exactly one bit set, and the corresponding device must match the device
    associated with the stream. If
    :py:obj:`~.CUarrayMapInfo.memOperationType` is set to
    :py:obj:`~.CUmemOperationType`::CU_MEM_OPERATION_TYPE_MAP, the device
    must also match the device associated with the tile pool memory
    allocation as specified by :py:obj:`~.CUarrayMapInfo`::memHandle.

    :py:obj:`~.CUarrayMapInfo.flags` and
    :py:obj:`~.CUarrayMapInfo.reserved`[] are unused and must be set to
    zero.

    Parameters
    ----------
    mapInfoList : list[:py:obj:`~.CUarrayMapInfo`]
        List of :py:obj:`~.CUarrayMapInfo`
    count : unsigned int
        Count of :py:obj:`~.CUarrayMapInfo` in `mapInfoList`
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier for the stream to use for map or unmap operations

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuMipmappedArrayCreate`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuMemCreate`, :py:obj:`~.cuArrayGetSparseProperties`, :py:obj:`~.cuMipmappedArrayGetSparseProperties`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    mapInfoList = [] if mapInfoList is None else mapInfoList
    if not all(isinstance(_x, (CUarrayMapInfo,)) for _x in mapInfoList):
        raise TypeError("Argument 'mapInfoList' is not instance of type (expected tuple[cydriver.CUarrayMapInfo,] or list[cydriver.CUarrayMapInfo,]")
    cdef cydriver.CUarrayMapInfo* cymapInfoList = NULL
    if len(mapInfoList) > 1:
        cymapInfoList = <cydriver.CUarrayMapInfo*> calloc(len(mapInfoList), sizeof(cydriver.CUarrayMapInfo))
        if cymapInfoList is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(mapInfoList)) + 'x' + str(sizeof(cydriver.CUarrayMapInfo)))
        for idx in range(len(mapInfoList)):
            string.memcpy(&cymapInfoList[idx], (<CUarrayMapInfo>mapInfoList[idx])._pvt_ptr, sizeof(cydriver.CUarrayMapInfo))
    elif len(mapInfoList) == 1:
        cymapInfoList = (<CUarrayMapInfo>mapInfoList[0])._pvt_ptr
    if count > len(mapInfoList): raise RuntimeError("List is too small: " + str(len(mapInfoList)) + " < " + str(count))
    with nogil:
        err = cydriver.cuMemMapArrayAsync(cymapInfoList, count, cyhStream)
    if len(mapInfoList) > 1 and cymapInfoList is not NULL:
        free(cymapInfoList)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemUnmap' in found_functions}}

@cython.embedsignature(True)
def cuMemUnmap(ptr, size_t size):
    """ Unmap the backing memory of a given address range.

    The range must be the entire contiguous address range that was mapped
    to. In other words, :py:obj:`~.cuMemUnmap` cannot unmap a sub-range of
    an address range mapped by :py:obj:`~.cuMemCreate` /
    :py:obj:`~.cuMemMap`. Any backing memory allocations will be freed if
    there are no existing mappings and there are no unreleased memory
    handles.

    When :py:obj:`~.cuMemUnmap` returns successfully the address range is
    converted to an address reservation and can be used for a future calls
    to :py:obj:`~.cuMemMap`. Any new mapping to this virtual address will
    need to have access granted through :py:obj:`~.cuMemSetAccess`, as all
    mappings start with no accessibility setup.

    Parameters
    ----------
    ptr : :py:obj:`~.CUdeviceptr`
        Starting address for the virtual address range to unmap
    size : size_t
        Size of the virtual address range to unmap

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemAddressReserve`
    """
    cdef cydriver.CUdeviceptr cyptr
    if ptr is None:
        pptr = 0
    elif isinstance(ptr, (CUdeviceptr,)):
        pptr = int(ptr)
    else:
        pptr = int(CUdeviceptr(ptr))
    cyptr = <cydriver.CUdeviceptr><void_ptr>pptr
    with nogil:
        err = cydriver.cuMemUnmap(cyptr, size)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemSetAccess' in found_functions}}

@cython.embedsignature(True)
def cuMemSetAccess(ptr, size_t size, desc : Optional[tuple[CUmemAccessDesc] | list[CUmemAccessDesc]], size_t count):
    """ Set the access flags for each location specified in `desc` for the given virtual address range.

    Given the virtual address range via `ptr` and `size`, and the locations
    in the array given by `desc` and `count`, set the access flags for the
    target locations. The range must be a fully mapped address range
    containing all allocations created by :py:obj:`~.cuMemMap` /
    :py:obj:`~.cuMemCreate`. Users cannot specify
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA` accessibility for
    allocations created on with other location types. Note: When
    :py:obj:`~.CUmemAccessDesc`::CUmemLocation::type is
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA`,
    :py:obj:`~.CUmemAccessDesc`::CUmemLocation::id is ignored. When setting
    the access flags for a virtual address range mapping a multicast
    object, `ptr` and `size` must be aligned to the value returned by
    :py:obj:`~.cuMulticastGetGranularity` with the flag
    :py:obj:`~.CU_MULTICAST_MINIMUM_GRANULARITY`. For best performance
    however, it is recommended that `ptr` and `size` be aligned to the
    value returned by :py:obj:`~.cuMulticastGetGranularity` with the flag
    :py:obj:`~.CU_MULTICAST_RECOMMENDED_GRANULARITY`.

    Parameters
    ----------
    ptr : :py:obj:`~.CUdeviceptr`
        Starting address for the virtual address range
    size : size_t
        Length of the virtual address range
    desc : list[:py:obj:`~.CUmemAccessDesc`]
        Array of :py:obj:`~.CUmemAccessDesc` that describe how to change
        the
    count : size_t
        Number of :py:obj:`~.CUmemAccessDesc` in `desc`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuMemSetAccess`, :py:obj:`~.cuMemCreate`, :py:obj:`~.py`:obj:`~.cuMemMap`
    """
    desc = [] if desc is None else desc
    if not all(isinstance(_x, (CUmemAccessDesc,)) for _x in desc):
        raise TypeError("Argument 'desc' is not instance of type (expected tuple[cydriver.CUmemAccessDesc,] or list[cydriver.CUmemAccessDesc,]")
    cdef cydriver.CUdeviceptr cyptr
    if ptr is None:
        pptr = 0
    elif isinstance(ptr, (CUdeviceptr,)):
        pptr = int(ptr)
    else:
        pptr = int(CUdeviceptr(ptr))
    cyptr = <cydriver.CUdeviceptr><void_ptr>pptr
    cdef cydriver.CUmemAccessDesc* cydesc = NULL
    if len(desc) > 1:
        cydesc = <cydriver.CUmemAccessDesc*> calloc(len(desc), sizeof(cydriver.CUmemAccessDesc))
        if cydesc is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(desc)) + 'x' + str(sizeof(cydriver.CUmemAccessDesc)))
        for idx in range(len(desc)):
            string.memcpy(&cydesc[idx], (<CUmemAccessDesc>desc[idx])._pvt_ptr, sizeof(cydriver.CUmemAccessDesc))
    elif len(desc) == 1:
        cydesc = (<CUmemAccessDesc>desc[0])._pvt_ptr
    if count > <size_t>len(desc): raise RuntimeError("List is too small: " + str(len(desc)) + " < " + str(count))
    with nogil:
        err = cydriver.cuMemSetAccess(cyptr, size, cydesc, count)
    if len(desc) > 1 and cydesc is not NULL:
        free(cydesc)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemGetAccess' in found_functions}}

@cython.embedsignature(True)
def cuMemGetAccess(location : Optional[CUmemLocation], ptr):
    """ Get the access `flags` set for the given `location` and `ptr`.

    Parameters
    ----------
    location : :py:obj:`~.CUmemLocation`
        Location in which to check the flags for
    ptr : :py:obj:`~.CUdeviceptr`
        Address in which to check the access flags for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    flags : unsigned long long
        Flags set for this location

    See Also
    --------
    :py:obj:`~.cuMemSetAccess`
    """
    cdef cydriver.CUdeviceptr cyptr
    if ptr is None:
        pptr = 0
    elif isinstance(ptr, (CUdeviceptr,)):
        pptr = int(ptr)
    else:
        pptr = int(CUdeviceptr(ptr))
    cyptr = <cydriver.CUdeviceptr><void_ptr>pptr
    cdef unsigned long long flags = 0
    cdef cydriver.CUmemLocation* cylocation_ptr = location._pvt_ptr if location is not None else NULL
    with nogil:
        err = cydriver.cuMemGetAccess(&flags, cylocation_ptr, cyptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], flags)
{{endif}}

{{if 'cuMemExportToShareableHandle' in found_functions}}

@cython.embedsignature(True)
def cuMemExportToShareableHandle(handle, handleType not None : CUmemAllocationHandleType, unsigned long long flags):
    """ Exports an allocation to a requested shareable handle type.

    Given a CUDA memory handle, create a shareable memory allocation handle
    that can be used to share the memory with other processes. The
    recipient process can convert the shareable handle back into a CUDA
    memory handle using :py:obj:`~.cuMemImportFromShareableHandle` and map
    it with :py:obj:`~.cuMemMap`. The implementation of what this handle is
    and how it can be transferred is defined by the requested handle type
    in `handleType`

    Once all shareable handles are closed and the allocation is released,
    the allocated memory referenced will be released back to the OS and
    uses of the CUDA handle afterward will lead to undefined behavior.

    This API can also be used in conjunction with other APIs (e.g. Vulkan,
    OpenGL) that support importing memory from the shareable type

    Parameters
    ----------
    handle : :py:obj:`~.CUmemGenericAllocationHandle`
        CUDA handle for the memory allocation
    handleType : :py:obj:`~.CUmemAllocationHandleType`
        Type of shareable handle requested (defines type and size of the
        `shareableHandle` output parameter)
    flags : unsigned long long
        Reserved, must be zero

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    shareableHandle : Any
        Pointer to the location in which to store the requested handle type

    See Also
    --------
    :py:obj:`~.cuMemImportFromShareableHandle`
    """
    cdef cydriver.CUmemGenericAllocationHandle cyhandle
    if handle is None:
        phandle = 0
    elif isinstance(handle, (CUmemGenericAllocationHandle,)):
        phandle = int(handle)
    else:
        phandle = int(CUmemGenericAllocationHandle(handle))
    cyhandle = <cydriver.CUmemGenericAllocationHandle><void_ptr>phandle
    cdef _HelperCUmemAllocationHandleType cyshareableHandle = _HelperCUmemAllocationHandleType(handleType)
    cdef void* cyshareableHandle_ptr = <void*><void_ptr>cyshareableHandle.cptr
    cdef cydriver.CUmemAllocationHandleType cyhandleType = handleType.value
    with nogil:
        err = cydriver.cuMemExportToShareableHandle(cyshareableHandle_ptr, cyhandle, cyhandleType, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], cyshareableHandle.pyObj())
{{endif}}

{{if 'cuMemImportFromShareableHandle' in found_functions}}

@cython.embedsignature(True)
def cuMemImportFromShareableHandle(osHandle, shHandleType not None : CUmemAllocationHandleType):
    """ Imports an allocation from a requested shareable handle type.

    If the current process cannot support the memory described by this
    shareable handle, this API will error as
    :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`.

    If `shHandleType` is :py:obj:`~.CU_MEM_HANDLE_TYPE_FABRIC` and the
    importer process has not been granted access to the same IMEX channel
    as the exporter process, this API will error as
    :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`.

    Parameters
    ----------
    osHandle : Any
        Shareable Handle representing the memory allocation that is to be
        imported.
    shHandleType : :py:obj:`~.CUmemAllocationHandleType`
        handle type of the exported handle
        :py:obj:`~.CUmemAllocationHandleType`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    handle : :py:obj:`~.CUmemGenericAllocationHandle`
        CUDA Memory handle for the memory allocation.

    See Also
    --------
    :py:obj:`~.cuMemExportToShareableHandle`, :py:obj:`~.cuMemMap`, :py:obj:`~.cuMemRelease`

    Notes
    -----
    Importing shareable handles exported from some graphics APIs(VUlkan, OpenGL, etc) created on devices under an SLI group may not be supported, and thus this API will return CUDA_ERROR_NOT_SUPPORTED. There is no guarantee that the contents of `handle` will be the same CUDA memory handle for the same given OS shareable handle, or the same underlying allocation.
    """
    cdef CUmemGenericAllocationHandle handle = CUmemGenericAllocationHandle()
    cyosHandle = _HelperInputVoidPtr(osHandle)
    cdef void* cyosHandle_ptr = <void*><void_ptr>cyosHandle.cptr
    cdef cydriver.CUmemAllocationHandleType cyshHandleType = shHandleType.value
    with nogil:
        err = cydriver.cuMemImportFromShareableHandle(<cydriver.CUmemGenericAllocationHandle*>handle._pvt_ptr, cyosHandle_ptr, cyshHandleType)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], handle)
{{endif}}

{{if 'cuMemGetAllocationGranularity' in found_functions}}

@cython.embedsignature(True)
def cuMemGetAllocationGranularity(prop : Optional[CUmemAllocationProp], option not None : CUmemAllocationGranularity_flags):
    """ Calculates either the minimal or recommended granularity.

    Calculates either the minimal or recommended granularity for a given
    allocation specification and returns it in granularity. This
    granularity can be used as a multiple for alignment, size, or address
    mapping.

    Parameters
    ----------
    prop : :py:obj:`~.CUmemAllocationProp`
        Property for which to determine the granularity for
    option : :py:obj:`~.CUmemAllocationGranularity_flags`
        Determines which granularity to return

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    granularity : int
        Returned granularity.

    See Also
    --------
    :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemMap`
    """
    cdef size_t granularity = 0
    cdef cydriver.CUmemAllocationProp* cyprop_ptr = prop._pvt_ptr if prop is not None else NULL
    cdef cydriver.CUmemAllocationGranularity_flags cyoption = option.value
    with nogil:
        err = cydriver.cuMemGetAllocationGranularity(&granularity, cyprop_ptr, cyoption)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], granularity)
{{endif}}

{{if 'cuMemGetAllocationPropertiesFromHandle' in found_functions}}

@cython.embedsignature(True)
def cuMemGetAllocationPropertiesFromHandle(handle):
    """ Retrieve the contents of the property structure defining properties for this handle.

    Parameters
    ----------
    handle : :py:obj:`~.CUmemGenericAllocationHandle`
        Handle which to perform the query on

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    prop : :py:obj:`~.CUmemAllocationProp`
        Pointer to a properties structure which will hold the information
        about this handle

    See Also
    --------
    :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemImportFromShareableHandle`
    """
    cdef cydriver.CUmemGenericAllocationHandle cyhandle
    if handle is None:
        phandle = 0
    elif isinstance(handle, (CUmemGenericAllocationHandle,)):
        phandle = int(handle)
    else:
        phandle = int(CUmemGenericAllocationHandle(handle))
    cyhandle = <cydriver.CUmemGenericAllocationHandle><void_ptr>phandle
    cdef CUmemAllocationProp prop = CUmemAllocationProp()
    with nogil:
        err = cydriver.cuMemGetAllocationPropertiesFromHandle(<cydriver.CUmemAllocationProp*>prop._pvt_ptr, cyhandle)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], prop)
{{endif}}

{{if 'cuMemRetainAllocationHandle' in found_functions}}

@cython.embedsignature(True)
def cuMemRetainAllocationHandle(addr):
    """ Given an address `addr`, returns the allocation handle of the backing memory allocation.

    The handle is guaranteed to be the same handle value used to map the
    memory. If the address requested is not mapped, the function will fail.
    The returned handle must be released with corresponding number of calls
    to :py:obj:`~.cuMemRelease`.

    Parameters
    ----------
    addr : Any
        Memory address to query, that has been mapped previously.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    handle : :py:obj:`~.CUmemGenericAllocationHandle`
        CUDA Memory handle for the backing memory allocation.

    See Also
    --------
    :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemRelease`, :py:obj:`~.cuMemMap`

    Notes
    -----
    The address `addr`, can be any address in a range previously mapped by :py:obj:`~.cuMemMap`, and not necessarily the start address.
    """
    cdef CUmemGenericAllocationHandle handle = CUmemGenericAllocationHandle()
    cyaddr = _HelperInputVoidPtr(addr)
    cdef void* cyaddr_ptr = <void*><void_ptr>cyaddr.cptr
    with nogil:
        err = cydriver.cuMemRetainAllocationHandle(<cydriver.CUmemGenericAllocationHandle*>handle._pvt_ptr, cyaddr_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], handle)
{{endif}}

{{if 'cuMemFreeAsync' in found_functions}}

@cython.embedsignature(True)
def cuMemFreeAsync(dptr, hStream):
    """ Frees memory with stream ordered semantics.

    Inserts a free operation into `hStream`. The allocation must not be
    accessed after stream execution reaches the free. After this API
    returns, accessing the memory from any subsequent work launched on the
    GPU or querying its pointer attributes results in undefined behavior.

    Parameters
    ----------
    dptr : :py:obj:`~.CUdeviceptr`
        memory to free
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream establishing the stream ordering contract.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` (default stream specified with no current context), :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    Notes
    -----
    During stream capture, this function results in the creation of a free node and must therefore be passed the address of a graph allocation.
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUdeviceptr cydptr
    if dptr is None:
        pdptr = 0
    elif isinstance(dptr, (CUdeviceptr,)):
        pdptr = int(dptr)
    else:
        pdptr = int(CUdeviceptr(dptr))
    cydptr = <cydriver.CUdeviceptr><void_ptr>pdptr
    with nogil:
        err = cydriver.cuMemFreeAsync(cydptr, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemAllocAsync' in found_functions}}

@cython.embedsignature(True)
def cuMemAllocAsync(size_t bytesize, hStream):
    """ Allocates memory with stream ordered semantics.

    Inserts an allocation operation into `hStream`. A pointer to the
    allocated memory is returned immediately in *dptr. The allocation must
    not be accessed until the the allocation operation completes. The
    allocation comes from the memory pool current to the stream's device.

    Parameters
    ----------
    bytesize : size_t
        Number of bytes to allocate
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream establishing the stream ordering contract and the memory
        pool to allocate from

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` (default stream specified with no current context), :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    dptr : :py:obj:`~.CUdeviceptr`
        Returned device pointer

    See Also
    --------
    :py:obj:`~.cuMemAllocFromPoolAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceSetMemPool`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuMemPoolSetAccess`, :py:obj:`~.cuMemPoolSetAttribute`

    Notes
    -----
    The default memory pool of a device contains device memory from that device.

    Basic stream ordering allows future work submitted into the same stream to use the allocation. Stream query, stream synchronize, and CUDA events can be used to guarantee that the allocation operation completes before work submitted in a separate stream runs.

    During stream capture, this function results in the creation of an allocation node. In this case, the allocation is owned by the graph instead of the memory pool. The memory pool's properties are used to set the node's creation parameters.
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef CUdeviceptr dptr = CUdeviceptr()
    with nogil:
        err = cydriver.cuMemAllocAsync(<cydriver.CUdeviceptr*>dptr._pvt_ptr, bytesize, cyhStream)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], dptr)
{{endif}}

{{if 'cuMemPoolTrimTo' in found_functions}}

@cython.embedsignature(True)
def cuMemPoolTrimTo(pool, size_t minBytesToKeep):
    """ Tries to release memory back to the OS.

    Releases memory back to the OS until the pool contains fewer than
    minBytesToKeep reserved bytes, or there is no more memory that the
    allocator can safely release. The allocator cannot release OS
    allocations that back outstanding asynchronous allocations. The OS
    allocations may happen at different granularity from the user
    allocations.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        The memory pool to trim
    minBytesToKeep : size_t
        If the pool has less than minBytesToKeep reserved, the TrimTo
        operation is a no-op. Otherwise the pool will be guaranteed to have
        at least minBytesToKeep bytes reserved after the operation.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`

    Notes
    -----
    : Allocations that have not been freed count as outstanding.

    : Allocations that have been asynchronously freed but whose completion has not been observed on the host (eg. by a synchronize) can count as outstanding.
    """
    cdef cydriver.CUmemoryPool cypool
    if pool is None:
        ppool = 0
    elif isinstance(pool, (CUmemoryPool,)):
        ppool = int(pool)
    else:
        ppool = int(CUmemoryPool(pool))
    cypool = <cydriver.CUmemoryPool><void_ptr>ppool
    with nogil:
        err = cydriver.cuMemPoolTrimTo(cypool, minBytesToKeep)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemPoolSetAttribute' in found_functions}}

@cython.embedsignature(True)
def cuMemPoolSetAttribute(pool, attr not None : CUmemPool_attribute, value):
    """ Sets attributes of a memory pool.

    Supported attributes are:

    - :py:obj:`~.CU_MEMPOOL_ATTR_RELEASE_THRESHOLD`: (value type =
      cuuint64_t) Amount of reserved memory in bytes to hold onto before
      trying to release memory back to the OS. When more than the release
      threshold bytes of memory are held by the memory pool, the allocator
      will try to release memory back to the OS on the next call to stream,
      event or context synchronize. (default 0)

    - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES`: (value
      type = int) Allow :py:obj:`~.cuMemAllocAsync` to use memory
      asynchronously freed in another stream as long as a stream ordering
      dependency of the allocating stream on the free action exists. Cuda
      events and null stream interactions can create the required stream
      ordered dependencies. (default enabled)

    - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC`: (value type =
      int) Allow reuse of already completed frees when there is no
      dependency between the free and allocation. (default enabled)

    - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES`: (value
      type = int) Allow :py:obj:`~.cuMemAllocAsync` to insert new stream
      dependencies in order to establish the stream ordering required to
      reuse a piece of memory released by :py:obj:`~.cuMemFreeAsync`
      (default enabled).

    - :py:obj:`~.CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH`: (value type =
      cuuint64_t) Reset the high watermark that tracks the amount of
      backing memory that was allocated for the memory pool. It is illegal
      to set this attribute to a non-zero value.

    - :py:obj:`~.CU_MEMPOOL_ATTR_USED_MEM_HIGH`: (value type = cuuint64_t)
      Reset the high watermark that tracks the amount of used memory that
      was allocated for the memory pool.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        The memory pool to modify
    attr : :py:obj:`~.CUmemPool_attribute`
        The attribute to modify
    value : Any
        Pointer to the value to assign

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`
    """
    cdef cydriver.CUmemoryPool cypool
    if pool is None:
        ppool = 0
    elif isinstance(pool, (CUmemoryPool,)):
        ppool = int(pool)
    else:
        ppool = int(CUmemoryPool(pool))
    cypool = <cydriver.CUmemoryPool><void_ptr>ppool
    cdef cydriver.CUmemPool_attribute cyattr = attr.value
    cdef _HelperCUmemPool_attribute cyvalue = _HelperCUmemPool_attribute(attr, value, is_getter=False)
    cdef void* cyvalue_ptr = <void*><void_ptr>cyvalue.cptr
    with nogil:
        err = cydriver.cuMemPoolSetAttribute(cypool, cyattr, cyvalue_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemPoolGetAttribute' in found_functions}}

@cython.embedsignature(True)
def cuMemPoolGetAttribute(pool, attr not None : CUmemPool_attribute):
    """ Gets attributes of a memory pool.

    Supported attributes are:

    - :py:obj:`~.CU_MEMPOOL_ATTR_RELEASE_THRESHOLD`: (value type =
      cuuint64_t) Amount of reserved memory in bytes to hold onto before
      trying to release memory back to the OS. When more than the release
      threshold bytes of memory are held by the memory pool, the allocator
      will try to release memory back to the OS on the next call to stream,
      event or context synchronize. (default 0)

    - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES`: (value
      type = int) Allow :py:obj:`~.cuMemAllocAsync` to use memory
      asynchronously freed in another stream as long as a stream ordering
      dependency of the allocating stream on the free action exists. Cuda
      events and null stream interactions can create the required stream
      ordered dependencies. (default enabled)

    - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC`: (value type =
      int) Allow reuse of already completed frees when there is no
      dependency between the free and allocation. (default enabled)

    - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES`: (value
      type = int) Allow :py:obj:`~.cuMemAllocAsync` to insert new stream
      dependencies in order to establish the stream ordering required to
      reuse a piece of memory released by :py:obj:`~.cuMemFreeAsync`
      (default enabled).

    - :py:obj:`~.CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT`: (value type =
      cuuint64_t) Amount of backing memory currently allocated for the
      mempool

    - :py:obj:`~.CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH`: (value type =
      cuuint64_t) High watermark of backing memory allocated for the
      mempool since the last time it was reset.

    - :py:obj:`~.CU_MEMPOOL_ATTR_USED_MEM_CURRENT`: (value type =
      cuuint64_t) Amount of memory from the pool that is currently in use
      by the application.

    - :py:obj:`~.CU_MEMPOOL_ATTR_USED_MEM_HIGH`: (value type = cuuint64_t)
      High watermark of the amount of memory from the pool that was in use
      by the application.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        The memory pool to get attributes of
    attr : :py:obj:`~.CUmemPool_attribute`
        The attribute to get

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    value : Any
        Retrieved value

    See Also
    --------
    :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`
    """
    cdef cydriver.CUmemoryPool cypool
    if pool is None:
        ppool = 0
    elif isinstance(pool, (CUmemoryPool,)):
        ppool = int(pool)
    else:
        ppool = int(CUmemoryPool(pool))
    cypool = <cydriver.CUmemoryPool><void_ptr>ppool
    cdef cydriver.CUmemPool_attribute cyattr = attr.value
    cdef _HelperCUmemPool_attribute cyvalue = _HelperCUmemPool_attribute(attr, 0, is_getter=True)
    cdef void* cyvalue_ptr = <void*><void_ptr>cyvalue.cptr
    with nogil:
        err = cydriver.cuMemPoolGetAttribute(cypool, cyattr, cyvalue_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], cyvalue.pyObj())
{{endif}}

{{if 'cuMemPoolSetAccess' in found_functions}}

@cython.embedsignature(True)
def cuMemPoolSetAccess(pool, map : Optional[tuple[CUmemAccessDesc] | list[CUmemAccessDesc]], size_t count):
    """ Controls visibility of pools between devices.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        The pool being modified
    map : list[:py:obj:`~.CUmemAccessDesc`]
        Array of access descriptors. Each descriptor instructs the access
        to enable for a single gpu.
    count : size_t
        Number of descriptors in the map array.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`
    """
    map = [] if map is None else map
    if not all(isinstance(_x, (CUmemAccessDesc,)) for _x in map):
        raise TypeError("Argument 'map' is not instance of type (expected tuple[cydriver.CUmemAccessDesc,] or list[cydriver.CUmemAccessDesc,]")
    cdef cydriver.CUmemoryPool cypool
    if pool is None:
        ppool = 0
    elif isinstance(pool, (CUmemoryPool,)):
        ppool = int(pool)
    else:
        ppool = int(CUmemoryPool(pool))
    cypool = <cydriver.CUmemoryPool><void_ptr>ppool
    cdef cydriver.CUmemAccessDesc* cymap = NULL
    if len(map) > 1:
        cymap = <cydriver.CUmemAccessDesc*> calloc(len(map), sizeof(cydriver.CUmemAccessDesc))
        if cymap is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(map)) + 'x' + str(sizeof(cydriver.CUmemAccessDesc)))
        for idx in range(len(map)):
            string.memcpy(&cymap[idx], (<CUmemAccessDesc>map[idx])._pvt_ptr, sizeof(cydriver.CUmemAccessDesc))
    elif len(map) == 1:
        cymap = (<CUmemAccessDesc>map[0])._pvt_ptr
    if count > <size_t>len(map): raise RuntimeError("List is too small: " + str(len(map)) + " < " + str(count))
    with nogil:
        err = cydriver.cuMemPoolSetAccess(cypool, cymap, count)
    if len(map) > 1 and cymap is not NULL:
        free(cymap)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemPoolGetAccess' in found_functions}}

@cython.embedsignature(True)
def cuMemPoolGetAccess(memPool, location : Optional[CUmemLocation]):
    """ Returns the accessibility of a pool from a device.

    Returns the accessibility of the pool's memory from the specified
    location.

    Parameters
    ----------
    memPool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        the pool being queried
    location : :py:obj:`~.CUmemLocation`
        the location accessing the pool

    Returns
    -------
    CUresult

    flags : :py:obj:`~.CUmemAccess_flags`
        the accessibility of the pool from the specified location

    See Also
    --------
    :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`
    """
    cdef cydriver.CUmemoryPool cymemPool
    if memPool is None:
        pmemPool = 0
    elif isinstance(memPool, (CUmemoryPool,)):
        pmemPool = int(memPool)
    else:
        pmemPool = int(CUmemoryPool(memPool))
    cymemPool = <cydriver.CUmemoryPool><void_ptr>pmemPool
    cdef cydriver.CUmemAccess_flags flags
    cdef cydriver.CUmemLocation* cylocation_ptr = location._pvt_ptr if location is not None else NULL
    with nogil:
        err = cydriver.cuMemPoolGetAccess(&flags, cymemPool, cylocation_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], CUmemAccess_flags(flags))
{{endif}}

{{if 'cuMemPoolCreate' in found_functions}}

@cython.embedsignature(True)
def cuMemPoolCreate(poolProps : Optional[CUmemPoolProps]):
    """ Creates a memory pool.

    Creates a CUDA memory pool and returns the handle in `pool`. The
    `poolProps` determines the properties of the pool such as the backing
    device and IPC capabilities.

    To create a memory pool for HOST memory not targeting a specific NUMA
    node, applications must set set
    :py:obj:`~.CUmemPoolProps`::CUmemLocation::type to
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST`.
    :py:obj:`~.CUmemPoolProps`::CUmemLocation::id is ignored for such
    pools. Pools created with the type
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST` are not IPC capable and
    :py:obj:`~.CUmemPoolProps.handleTypes` must be 0, any other values will
    result in :py:obj:`~.CUDA_ERROR_INVALID_VALUE`. To create a memory pool
    targeting a specific host NUMA node, applications must set
    :py:obj:`~.CUmemPoolProps`::CUmemLocation::type to
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA` and
    :py:obj:`~.CUmemPoolProps`::CUmemLocation::id must specify the NUMA ID
    of the host memory node. Specifying
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT` as the
    :py:obj:`~.CUmemPoolProps`::CUmemLocation::type will result in
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE`. By default, the pool's memory
    will be accessible from the device it is allocated on. In the case of
    pools created with :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA` or
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST`, their default accessibility will
    be from the host CPU. Applications can control the maximum size of the
    pool by specifying a non-zero value for
    :py:obj:`~.CUmemPoolProps.maxSize`. If set to 0, the maximum size of
    the pool will default to a system dependent value.

    Applications that intend to use :py:obj:`~.CU_MEM_HANDLE_TYPE_FABRIC`
    based memory sharing must ensure: (1) `nvidia-caps-imex-channels`
    character device is created by the driver and is listed under
    /proc/devices (2) have at least one IMEX channel file accessible by the
    user launching the application.

    When exporter and importer CUDA processes have been granted access to
    the same IMEX channel, they can securely share memory.

    The IMEX channel security model works on a per user basis. Which means
    all processes under a user can share memory if the user has access to a
    valid IMEX channel. When multi-user isolation is desired, a separate
    IMEX channel is required for each user.

    These channel files exist in /dev/nvidia-caps-imex-channels/channel*
    and can be created using standard OS native calls like mknod on Linux.
    For example: To create channel0 with the major number from
    /proc/devices users can execute the following command: `mknod
    /dev/nvidia-caps-imex-channels/channel0 c <major number> 0`

    Parameters
    ----------
    poolProps : :py:obj:`~.CUmemPoolProps`
        None

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    pool : :py:obj:`~.CUmemoryPool`
        None

    See Also
    --------
    :py:obj:`~.cuDeviceSetMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuMemAllocFromPoolAsync`, :py:obj:`~.cuMemPoolExportToShareableHandle`

    Notes
    -----
    Specifying CU_MEM_HANDLE_TYPE_NONE creates a memory pool that will not support IPC.
    """
    cdef CUmemoryPool pool = CUmemoryPool()
    cdef cydriver.CUmemPoolProps* cypoolProps_ptr = poolProps._pvt_ptr if poolProps is not None else NULL
    with nogil:
        err = cydriver.cuMemPoolCreate(<cydriver.CUmemoryPool*>pool._pvt_ptr, cypoolProps_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pool)
{{endif}}

{{if 'cuMemPoolDestroy' in found_functions}}

@cython.embedsignature(True)
def cuMemPoolDestroy(pool):
    """ Destroys the specified memory pool.

    If any pointers obtained from this pool haven't been freed or the pool
    has free operations that haven't completed when
    :py:obj:`~.cuMemPoolDestroy` is invoked, the function will return
    immediately and the resources associated with the pool will be released
    automatically once there are no more outstanding allocations.

    Destroying the current mempool of a device sets the default mempool of
    that device as the current mempool for that device.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        None

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceSetMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuMemPoolCreate`

    Notes
    -----
    A device's default memory pool cannot be destroyed.
    """
    cdef cydriver.CUmemoryPool cypool
    if pool is None:
        ppool = 0
    elif isinstance(pool, (CUmemoryPool,)):
        ppool = int(pool)
    else:
        ppool = int(CUmemoryPool(pool))
    cypool = <cydriver.CUmemoryPool><void_ptr>ppool
    with nogil:
        err = cydriver.cuMemPoolDestroy(cypool)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemGetDefaultMemPool' in found_functions}}

@cython.embedsignature(True)
def cuMemGetDefaultMemPool(location : Optional[CUmemLocation], typename not None : CUmemAllocationType):
    """ Returns the default memory pool for a given location and allocation type.

    The memory location can be of one of
    :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE`,
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST` or
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA`. The allocation type can be
    one of :py:obj:`~.CU_MEM_ALLOCATION_TYPE_PINNED` or
    :py:obj:`~.CU_MEM_ALLOCATION_TYPE_MANAGED`. When the allocation type is
    :py:obj:`~.CU_MEM_ALLOCATION_TYPE_MANAGED`, the location type can also
    be :py:obj:`~.CU_MEM_LOCATION_TYPE_NONE` to indicate no preferred
    location for the managed memory pool. In all other cases, the call
    returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

    Parameters
    ----------
    location : :py:obj:`~.CUmemLocation`
        None
    typename : :py:obj:`~.CUmemAllocationType`
        None

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    pool_out : :py:obj:`~.CUmemoryPool`
        None

    See Also
    --------
    :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemPoolTrimTo`, :py:obj:`~.cuMemPoolGetAttribute`, :py:obj:`~.cuMemPoolSetAttribute`, :py:obj:`~.cuMemPoolSetAccess`, :py:obj:`~.cuMemGetMemPool`, :py:obj:`~.cuMemPoolCreate`
    """
    cdef CUmemoryPool pool_out = CUmemoryPool()
    cdef cydriver.CUmemLocation* cylocation_ptr = location._pvt_ptr if location is not None else NULL
    cdef cydriver.CUmemAllocationType cytypename = typename.value
    with nogil:
        err = cydriver.cuMemGetDefaultMemPool(<cydriver.CUmemoryPool*>pool_out._pvt_ptr, cylocation_ptr, cytypename)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pool_out)
{{endif}}

{{if 'cuMemGetMemPool' in found_functions}}

@cython.embedsignature(True)
def cuMemGetMemPool(location : Optional[CUmemLocation], typename not None : CUmemAllocationType):
    """ Gets the current memory pool for a memory location and of a particular allocation type.

    The memory location can be of one of
    :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE`,
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST` or
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA`. The allocation type can be
    one of :py:obj:`~.CU_MEM_ALLOCATION_TYPE_PINNED` or
    :py:obj:`~.CU_MEM_ALLOCATION_TYPE_MANAGED`. When the allocation type is
    :py:obj:`~.CU_MEM_ALLOCATION_TYPE_MANAGED`, the location type can also
    be :py:obj:`~.CU_MEM_LOCATION_TYPE_NONE` to indicate no preferred
    location for the managed memory pool. In all other cases, the call
    returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    Returns the last pool provided to :py:obj:`~.cuMemSetMemPool` or
    :py:obj:`~.cuDeviceSetMemPool` for this location and allocation type or
    the location's default memory pool if :py:obj:`~.cuMemSetMemPool` or
    :py:obj:`~.cuDeviceSetMemPool` for that allocType and location has
    never been called. By default the current mempool of a location is the
    default mempool for a device. Otherwise the returned pool must have
    been set with :py:obj:`~.cuDeviceSetMemPool`.

    Parameters
    ----------
    location : :py:obj:`~.CUmemLocation`
        None
    typename : :py:obj:`~.CUmemAllocationType`
        None

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pool : :py:obj:`~.CUmemoryPool`
        None

    See Also
    --------
    :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuDeviceSetMemPool`, :py:obj:`~.cuMemSetMemPool`
    """
    cdef CUmemoryPool pool = CUmemoryPool()
    cdef cydriver.CUmemLocation* cylocation_ptr = location._pvt_ptr if location is not None else NULL
    cdef cydriver.CUmemAllocationType cytypename = typename.value
    with nogil:
        err = cydriver.cuMemGetMemPool(<cydriver.CUmemoryPool*>pool._pvt_ptr, cylocation_ptr, cytypename)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pool)
{{endif}}

{{if 'cuMemSetMemPool' in found_functions}}

@cython.embedsignature(True)
def cuMemSetMemPool(location : Optional[CUmemLocation], typename not None : CUmemAllocationType, pool):
    """ Sets the current memory pool for a memory location and allocation type.

    The memory location can be of one of
    :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE`,
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST` or
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA`. The allocation type can be
    one of :py:obj:`~.CU_MEM_ALLOCATION_TYPE_PINNED` or
    :py:obj:`~.CU_MEM_ALLOCATION_TYPE_MANAGED`. When the allocation type is
    :py:obj:`~.CU_MEM_ALLOCATION_TYPE_MANAGED`, the location type can also
    be :py:obj:`~.CU_MEM_LOCATION_TYPE_NONE` to indicate no preferred
    location for the managed memory pool. In all other cases, the call
    returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

    When a memory pool is set as the current memory pool, the location
    parameter should be the same as the location of the pool. The location
    and allocation type specified must match those of the pool otherwise
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned. By default, a memory
    location's current memory pool is its default memory pool that can be
    obtained via :py:obj:`~.cuMemGetDefaultMemPool`. If the location type
    is :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE` and the allocation type is
    :py:obj:`~.CU_MEM_ALLOCATION_TYPE_PINNED`, then this API is the
    equivalent of calling :py:obj:`~.cuDeviceSetMemPool` with the location
    id as the device. For further details on the implications, please refer
    to the documentation for :py:obj:`~.cuDeviceSetMemPool`.

    Parameters
    ----------
    location : :py:obj:`~.CUmemLocation`
        None
    typename : :py:obj:`~.CUmemAllocationType`
        None
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        None

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemGetMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuMemPoolDestroy`, :py:obj:`~.cuMemAllocFromPoolAsync`

    Notes
    -----
    Use :py:obj:`~.cuMemAllocFromPoolAsync` to specify asynchronous allocations from a device different than the one the stream runs on.
    """
    cdef cydriver.CUmemoryPool cypool
    if pool is None:
        ppool = 0
    elif isinstance(pool, (CUmemoryPool,)):
        ppool = int(pool)
    else:
        ppool = int(CUmemoryPool(pool))
    cypool = <cydriver.CUmemoryPool><void_ptr>ppool
    cdef cydriver.CUmemLocation* cylocation_ptr = location._pvt_ptr if location is not None else NULL
    cdef cydriver.CUmemAllocationType cytypename = typename.value
    with nogil:
        err = cydriver.cuMemSetMemPool(cylocation_ptr, cytypename, cypool)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemAllocFromPoolAsync' in found_functions}}

@cython.embedsignature(True)
def cuMemAllocFromPoolAsync(size_t bytesize, pool, hStream):
    """ Allocates memory from a specified pool with stream ordered semantics.

    Inserts an allocation operation into `hStream`. A pointer to the
    allocated memory is returned immediately in *dptr. The allocation must
    not be accessed until the the allocation operation completes. The
    allocation comes from the specified memory pool.

    Parameters
    ----------
    bytesize : size_t
        Number of bytes to allocate
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        The pool to allocate from
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream establishing the stream ordering semantic

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` (default stream specified with no current context), :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    dptr : :py:obj:`~.CUdeviceptr`
        Returned device pointer

    See Also
    --------
    :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuMemPoolSetAccess`, :py:obj:`~.cuMemPoolSetAttribute`

    Notes
    -----
    During stream capture, this function results in the creation of an allocation node. In this case, the allocation is owned by the graph instead of the memory pool. The memory pool's properties are used to set the node's creation parameters.
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUmemoryPool cypool
    if pool is None:
        ppool = 0
    elif isinstance(pool, (CUmemoryPool,)):
        ppool = int(pool)
    else:
        ppool = int(CUmemoryPool(pool))
    cypool = <cydriver.CUmemoryPool><void_ptr>ppool
    cdef CUdeviceptr dptr = CUdeviceptr()
    with nogil:
        err = cydriver.cuMemAllocFromPoolAsync(<cydriver.CUdeviceptr*>dptr._pvt_ptr, bytesize, cypool, cyhStream)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], dptr)
{{endif}}

{{if 'cuMemPoolExportToShareableHandle' in found_functions}}

@cython.embedsignature(True)
def cuMemPoolExportToShareableHandle(pool, handleType not None : CUmemAllocationHandleType, unsigned long long flags):
    """ Exports a memory pool to the requested handle type.

    Given an IPC capable mempool, create an OS handle to share the pool
    with another process. A recipient process can convert the shareable
    handle into a mempool with
    :py:obj:`~.cuMemPoolImportFromShareableHandle`. Individual pointers can
    then be shared with the :py:obj:`~.cuMemPoolExportPointer` and
    :py:obj:`~.cuMemPoolImportPointer` APIs. The implementation of what the
    shareable handle is and how it can be transferred is defined by the
    requested handle type.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        pool to export
    handleType : :py:obj:`~.CUmemAllocationHandleType`
        the type of handle to create
    flags : unsigned long long
        must be 0

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    handle_out : Any
        Returned OS handle

    See Also
    --------
    :py:obj:`~.cuMemPoolImportFromShareableHandle`, :py:obj:`~.cuMemPoolExportPointer`, :py:obj:`~.cuMemPoolImportPointer`, :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuMemPoolSetAccess`, :py:obj:`~.cuMemPoolSetAttribute`

    Notes
    -----
    : To create an IPC capable mempool, create a mempool with a CUmemAllocationHandleType other than CU_MEM_HANDLE_TYPE_NONE.
    """
    cdef cydriver.CUmemoryPool cypool
    if pool is None:
        ppool = 0
    elif isinstance(pool, (CUmemoryPool,)):
        ppool = int(pool)
    else:
        ppool = int(CUmemoryPool(pool))
    cypool = <cydriver.CUmemoryPool><void_ptr>ppool
    cdef _HelperCUmemAllocationHandleType cyhandle_out = _HelperCUmemAllocationHandleType(handleType)
    cdef void* cyhandle_out_ptr = <void*><void_ptr>cyhandle_out.cptr
    cdef cydriver.CUmemAllocationHandleType cyhandleType = handleType.value
    with nogil:
        err = cydriver.cuMemPoolExportToShareableHandle(cyhandle_out_ptr, cypool, cyhandleType, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], cyhandle_out.pyObj())
{{endif}}

{{if 'cuMemPoolImportFromShareableHandle' in found_functions}}

@cython.embedsignature(True)
def cuMemPoolImportFromShareableHandle(handle, handleType not None : CUmemAllocationHandleType, unsigned long long flags):
    """ imports a memory pool from a shared handle.

    Specific allocations can be imported from the imported pool with
    cuMemPoolImportPointer.

    If `handleType` is :py:obj:`~.CU_MEM_HANDLE_TYPE_FABRIC` and the
    importer process has not been granted access to the same IMEX channel
    as the exporter process, this API will error as
    :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`.

    Parameters
    ----------
    handle : Any
        OS handle of the pool to open
    handleType : :py:obj:`~.CUmemAllocationHandleType`
        The type of handle being imported
    flags : unsigned long long
        must be 0

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    pool_out : :py:obj:`~.CUmemoryPool`
        Returned memory pool

    See Also
    --------
    :py:obj:`~.cuMemPoolExportToShareableHandle`, :py:obj:`~.cuMemPoolExportPointer`, :py:obj:`~.cuMemPoolImportPointer`

    Notes
    -----
    Imported memory pools do not support creating new allocations. As such imported memory pools may not be used in cuDeviceSetMemPool or :py:obj:`~.cuMemAllocFromPoolAsync` calls.
    """
    cdef CUmemoryPool pool_out = CUmemoryPool()
    cyhandle = _HelperInputVoidPtr(handle)
    cdef void* cyhandle_ptr = <void*><void_ptr>cyhandle.cptr
    cdef cydriver.CUmemAllocationHandleType cyhandleType = handleType.value
    with nogil:
        err = cydriver.cuMemPoolImportFromShareableHandle(<cydriver.CUmemoryPool*>pool_out._pvt_ptr, cyhandle_ptr, cyhandleType, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pool_out)
{{endif}}

{{if 'cuMemPoolExportPointer' in found_functions}}

@cython.embedsignature(True)
def cuMemPoolExportPointer(ptr):
    """ Export data to share a memory pool allocation between processes.

    Constructs `shareData_out` for sharing a specific allocation from an
    already shared memory pool. The recipient process can import the
    allocation with the :py:obj:`~.cuMemPoolImportPointer` api. The data is
    not a handle and may be shared through any IPC mechanism.

    Parameters
    ----------
    ptr : :py:obj:`~.CUdeviceptr`
        pointer to memory being exported

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    shareData_out : :py:obj:`~.CUmemPoolPtrExportData`
        Returned export data

    See Also
    --------
    :py:obj:`~.cuMemPoolExportToShareableHandle`, :py:obj:`~.cuMemPoolImportFromShareableHandle`, :py:obj:`~.cuMemPoolImportPointer`
    """
    cdef cydriver.CUdeviceptr cyptr
    if ptr is None:
        pptr = 0
    elif isinstance(ptr, (CUdeviceptr,)):
        pptr = int(ptr)
    else:
        pptr = int(CUdeviceptr(ptr))
    cyptr = <cydriver.CUdeviceptr><void_ptr>pptr
    cdef CUmemPoolPtrExportData shareData_out = CUmemPoolPtrExportData()
    with nogil:
        err = cydriver.cuMemPoolExportPointer(<cydriver.CUmemPoolPtrExportData*>shareData_out._pvt_ptr, cyptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], shareData_out)
{{endif}}

{{if 'cuMemPoolImportPointer' in found_functions}}

@cython.embedsignature(True)
def cuMemPoolImportPointer(pool, shareData : Optional[CUmemPoolPtrExportData]):
    """ Import a memory pool allocation from another process.

    Returns in `ptr_out` a pointer to the imported memory. The imported
    memory must not be accessed before the allocation operation completes
    in the exporting process. The imported memory must be freed from all
    importing processes before being freed in the exporting process. The
    pointer may be freed with cuMemFree or cuMemFreeAsync. If
    cuMemFreeAsync is used, the free must be completed on the importing
    process before the free operation on the exporting process.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        pool from which to import
    shareData : :py:obj:`~.CUmemPoolPtrExportData`
        data specifying the memory to import

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    ptr_out : :py:obj:`~.CUdeviceptr`
        pointer to imported memory

    See Also
    --------
    :py:obj:`~.cuMemPoolExportToShareableHandle`, :py:obj:`~.cuMemPoolImportFromShareableHandle`, :py:obj:`~.cuMemPoolExportPointer`

    Notes
    -----
    The cuMemFreeAsync api may be used in the exporting process before the cuMemFreeAsync operation completes in its stream as long as the cuMemFreeAsync in the exporting process specifies a stream with a stream dependency on the importing process's cuMemFreeAsync.
    """
    cdef cydriver.CUmemoryPool cypool
    if pool is None:
        ppool = 0
    elif isinstance(pool, (CUmemoryPool,)):
        ppool = int(pool)
    else:
        ppool = int(CUmemoryPool(pool))
    cypool = <cydriver.CUmemoryPool><void_ptr>ppool
    cdef CUdeviceptr ptr_out = CUdeviceptr()
    cdef cydriver.CUmemPoolPtrExportData* cyshareData_ptr = shareData._pvt_ptr if shareData is not None else NULL
    with nogil:
        err = cydriver.cuMemPoolImportPointer(<cydriver.CUdeviceptr*>ptr_out._pvt_ptr, cypool, cyshareData_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], ptr_out)
{{endif}}

{{if 'cuMulticastCreate' in found_functions}}

@cython.embedsignature(True)
def cuMulticastCreate(prop : Optional[CUmulticastObjectProp]):
    """ Create a generic allocation handle representing a multicast object described by the given properties.

    This creates a multicast object as described by `prop`. The number of
    participating devices is specified by
    :py:obj:`~.CUmulticastObjectProp.numDevices`. Devices can be added to
    the multicast object via :py:obj:`~.cuMulticastAddDevice`. All
    participating devices must be added to the multicast object before
    memory can be bound to it. Memory is bound to the multicast object via
    either :py:obj:`~.cuMulticastBindMem` or
    :py:obj:`~.cuMulticastBindAddr`, and can be unbound via
    :py:obj:`~.cuMulticastUnbind`. The total amount of memory that can be
    bound per device is specified by
    :py:obj:`~.py`:obj:`~.CUmulticastObjectProp.size`. This size must be a
    multiple of the value returned by :py:obj:`~.cuMulticastGetGranularity`
    with the flag :py:obj:`~.CU_MULTICAST_GRANULARITY_MINIMUM`. For best
    performance however, the size should be aligned to the value returned
    by :py:obj:`~.cuMulticastGetGranularity` with the flag
    :py:obj:`~.CU_MULTICAST_GRANULARITY_RECOMMENDED`.

    After all participating devices have been added, multicast objects can
    also be mapped to a device's virtual address space using the virtual
    memory management APIs (see :py:obj:`~.cuMemMap` and
    :py:obj:`~.cuMemSetAccess`). Multicast objects can also be shared with
    other processes by requesting a shareable handle via
    :py:obj:`~.cuMemExportToShareableHandle`. Note that the desired types
    of shareable handles must be specified in the bitmask
    :py:obj:`~.CUmulticastObjectProp.handleTypes`. Multicast objects can be
    released using the virtual memory management API
    :py:obj:`~.cuMemRelease`.

    Parameters
    ----------
    prop : :py:obj:`~.CUmulticastObjectProp`
        Properties of the multicast object to create.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    mcHandle : :py:obj:`~.CUmemGenericAllocationHandle`
        Value of handle returned.

    See Also
    --------
    :py:obj:`~.cuMulticastAddDevice`, :py:obj:`~.cuMulticastBindMem`, :py:obj:`~.cuMulticastBindAddr`, :py:obj:`~.cuMulticastUnbind`

    :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemRelease`, :py:obj:`~.cuMemExportToShareableHandle`, :py:obj:`~.cuMemImportFromShareableHandle`
    """
    cdef CUmemGenericAllocationHandle mcHandle = CUmemGenericAllocationHandle()
    cdef cydriver.CUmulticastObjectProp* cyprop_ptr = prop._pvt_ptr if prop is not None else NULL
    with nogil:
        err = cydriver.cuMulticastCreate(<cydriver.CUmemGenericAllocationHandle*>mcHandle._pvt_ptr, cyprop_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], mcHandle)
{{endif}}

{{if 'cuMulticastAddDevice' in found_functions}}

@cython.embedsignature(True)
def cuMulticastAddDevice(mcHandle, dev):
    """ Associate a device to a multicast object.

    Associates a device to a multicast object. The added device will be a
    part of the multicast team of size specified by
    :py:obj:`~.CUmulticastObjectProp.numDevices` during
    :py:obj:`~.cuMulticastCreate`. The association of the device to the
    multicast object is permanent during the life time of the multicast
    object. All devices must be added to the multicast team before any
    memory can be bound to any device in the team. Any calls to
    :py:obj:`~.cuMulticastBindMem` or :py:obj:`~.cuMulticastBindAddr` will
    block until all devices have been added. Similarly all devices must be
    added to the multicast team before a virtual address range can be
    mapped to the multicast object. A call to :py:obj:`~.cuMemMap` will
    block until all devices have been added.

    Parameters
    ----------
    mcHandle : :py:obj:`~.CUmemGenericAllocationHandle`
        Handle representing a multicast object.
    dev : :py:obj:`~.CUdevice`
        Device that will be associated to the multicast object.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuMulticastCreate`, :py:obj:`~.cuMulticastBindMem`, :py:obj:`~.cuMulticastBindAddr`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef cydriver.CUmemGenericAllocationHandle cymcHandle
    if mcHandle is None:
        pmcHandle = 0
    elif isinstance(mcHandle, (CUmemGenericAllocationHandle,)):
        pmcHandle = int(mcHandle)
    else:
        pmcHandle = int(CUmemGenericAllocationHandle(mcHandle))
    cymcHandle = <cydriver.CUmemGenericAllocationHandle><void_ptr>pmcHandle
    with nogil:
        err = cydriver.cuMulticastAddDevice(cymcHandle, cydev)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMulticastBindMem' in found_functions}}

@cython.embedsignature(True)
def cuMulticastBindMem(mcHandle, size_t mcOffset, memHandle, size_t memOffset, size_t size, unsigned long long flags):
    """ Bind a memory allocation represented by a handle to a multicast object.

    Binds a memory allocation specified by `memHandle` and created via
    :py:obj:`~.cuMemCreate` to a multicast object represented by `mcHandle`
    and created via :py:obj:`~.cuMulticastCreate`. The intended `size` of
    the bind, the offset in the multicast range `mcOffset` as well as the
    offset in the memory `memOffset` must be a multiple of the value
    returned by :py:obj:`~.cuMulticastGetGranularity` with the flag
    :py:obj:`~.CU_MULTICAST_GRANULARITY_MINIMUM`. For best performance
    however, `size`, `mcOffset` and `memOffset` should be aligned to the
    granularity of the memory allocation(see
    :py:obj:`~.cuMemGetAllocationGranularity`) or to the value returned by
    :py:obj:`~.cuMulticastGetGranularity` with the flag
    :py:obj:`~.CU_MULTICAST_GRANULARITY_RECOMMENDED`.

    The `size` + `memOffset` cannot be larger than the size of the
    allocated memory. Similarly the `size` + `mcOffset` cannot be larger
    than the size of the multicast object. The memory allocation must have
    beeen created on one of the devices that was added to the multicast
    team via :py:obj:`~.cuMulticastAddDevice`. Externally shareable as well
    as imported multicast objects can be bound only to externally shareable
    memory. Note that this call will return CUDA_ERROR_OUT_OF_MEMORY if
    there are insufficient resources required to perform the bind. This
    call may also return CUDA_ERROR_SYSTEM_NOT_READY if the necessary
    system software is not initialized or running.

    This call may return CUDA_ERROR_ILLEGAL_STATE if the system
    configuration is in an illegal state. In such cases, to continue using
    multicast, verify that the system configuration is in a valid state and
    all required driver daemons are running properly.

    Parameters
    ----------
    mcHandle : :py:obj:`~.CUmemGenericAllocationHandle`
        Handle representing a multicast object.
    mcOffset : size_t
        Offset into the multicast object for attachment.
    memHandle : :py:obj:`~.CUmemGenericAllocationHandle`
        Handle representing a memory allocation.
    memOffset : size_t
        Offset into the memory for attachment.
    size : size_t
        Size of the memory that will be bound to the multicast object.
    flags : unsigned long long
        Flags for future use, must be zero for now.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_SYSTEM_NOT_READY`, :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE`

    See Also
    --------
    :py:obj:`~.cuMulticastCreate`, :py:obj:`~.cuMulticastAddDevice`, :py:obj:`~.cuMemCreate`
    """
    cdef cydriver.CUmemGenericAllocationHandle cymemHandle
    if memHandle is None:
        pmemHandle = 0
    elif isinstance(memHandle, (CUmemGenericAllocationHandle,)):
        pmemHandle = int(memHandle)
    else:
        pmemHandle = int(CUmemGenericAllocationHandle(memHandle))
    cymemHandle = <cydriver.CUmemGenericAllocationHandle><void_ptr>pmemHandle
    cdef cydriver.CUmemGenericAllocationHandle cymcHandle
    if mcHandle is None:
        pmcHandle = 0
    elif isinstance(mcHandle, (CUmemGenericAllocationHandle,)):
        pmcHandle = int(mcHandle)
    else:
        pmcHandle = int(CUmemGenericAllocationHandle(mcHandle))
    cymcHandle = <cydriver.CUmemGenericAllocationHandle><void_ptr>pmcHandle
    with nogil:
        err = cydriver.cuMulticastBindMem(cymcHandle, mcOffset, cymemHandle, memOffset, size, flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMulticastBindAddr' in found_functions}}

@cython.embedsignature(True)
def cuMulticastBindAddr(mcHandle, size_t mcOffset, memptr, size_t size, unsigned long long flags):
    """ Bind a memory allocation represented by a virtual address to a multicast object.

    Binds a memory allocation specified by its mapped address `memptr` to a
    multicast object represented by `mcHandle`. The memory must have been
    allocated via :py:obj:`~.cuMemCreate` or :py:obj:`~.cudaMallocAsync`.
    The intended `size` of the bind, the offset in the multicast range
    `mcOffset` and `memptr` must be a multiple of the value returned by
    :py:obj:`~.cuMulticastGetGranularity` with the flag
    :py:obj:`~.CU_MULTICAST_GRANULARITY_MINIMUM`. For best performance
    however, `size`, `mcOffset` and `memptr` should be aligned to the value
    returned by :py:obj:`~.cuMulticastGetGranularity` with the flag
    :py:obj:`~.CU_MULTICAST_GRANULARITY_RECOMMENDED`.

    The `size` cannot be larger than the size of the allocated memory.
    Similarly the `size` + `mcOffset` cannot be larger than the total size
    of the multicast object. The memory allocation must have beeen created
    on one of the devices that was added to the multicast team via
    :py:obj:`~.cuMulticastAddDevice`. Externally shareable as well as
    imported multicast objects can be bound only to externally shareable
    memory. Note that this call will return CUDA_ERROR_OUT_OF_MEMORY if
    there are insufficient resources required to perform the bind. This
    call may also return CUDA_ERROR_SYSTEM_NOT_READY if the necessary
    system software is not initialized or running.

    This call may return CUDA_ERROR_ILLEGAL_STATE if the system
    configuration is in an illegal state. In such cases, to continue using
    multicast, verify that the system configuration is in a valid state and
    all required driver daemons are running properly.

    Parameters
    ----------
    mcHandle : :py:obj:`~.CUmemGenericAllocationHandle`
        Handle representing a multicast object.
    mcOffset : size_t
        Offset into multicast va range for attachment.
    memptr : :py:obj:`~.CUdeviceptr`
        Virtual address of the memory allocation.
    size : size_t
        Size of memory that will be bound to the multicast object.
    flags : unsigned long long
        Flags for future use, must be zero now.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_SYSTEM_NOT_READY`, :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE`

    See Also
    --------
    :py:obj:`~.cuMulticastCreate`, :py:obj:`~.cuMulticastAddDevice`, :py:obj:`~.cuMemCreate`
    """
    cdef cydriver.CUdeviceptr cymemptr
    if memptr is None:
        pmemptr = 0
    elif isinstance(memptr, (CUdeviceptr,)):
        pmemptr = int(memptr)
    else:
        pmemptr = int(CUdeviceptr(memptr))
    cymemptr = <cydriver.CUdeviceptr><void_ptr>pmemptr
    cdef cydriver.CUmemGenericAllocationHandle cymcHandle
    if mcHandle is None:
        pmcHandle = 0
    elif isinstance(mcHandle, (CUmemGenericAllocationHandle,)):
        pmcHandle = int(mcHandle)
    else:
        pmcHandle = int(CUmemGenericAllocationHandle(mcHandle))
    cymcHandle = <cydriver.CUmemGenericAllocationHandle><void_ptr>pmcHandle
    with nogil:
        err = cydriver.cuMulticastBindAddr(cymcHandle, mcOffset, cymemptr, size, flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMulticastUnbind' in found_functions}}

@cython.embedsignature(True)
def cuMulticastUnbind(mcHandle, dev, size_t mcOffset, size_t size):
    """ Unbind any memory allocations bound to a multicast object at a given offset and upto a given size.

    Unbinds any memory allocations hosted on `dev` and bound to a multicast
    object at `mcOffset` and upto a given `size`. The intended `size` of
    the unbind and the offset in the multicast range ( `mcOffset` ) must be
    a multiple of the value returned by
    :py:obj:`~.cuMulticastGetGranularity` flag
    :py:obj:`~.CU_MULTICAST_GRANULARITY_MINIMUM`. The `size` + `mcOffset`
    cannot be larger than the total size of the multicast object.

    Parameters
    ----------
    mcHandle : :py:obj:`~.CUmemGenericAllocationHandle`
        Handle representing a multicast object.
    dev : :py:obj:`~.CUdevice`
        Device that hosts the memory allocation.
    mcOffset : size_t
        Offset into the multicast object.
    size : size_t
        Desired size to unbind.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuMulticastBindMem`, :py:obj:`~.cuMulticastBindAddr`

    Notes
    -----
    Warning: The `mcOffset` and the `size` must match the corresponding values specified during the bind call. Any other values may result in undefined behavior.
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef cydriver.CUmemGenericAllocationHandle cymcHandle
    if mcHandle is None:
        pmcHandle = 0
    elif isinstance(mcHandle, (CUmemGenericAllocationHandle,)):
        pmcHandle = int(mcHandle)
    else:
        pmcHandle = int(CUmemGenericAllocationHandle(mcHandle))
    cymcHandle = <cydriver.CUmemGenericAllocationHandle><void_ptr>pmcHandle
    with nogil:
        err = cydriver.cuMulticastUnbind(cymcHandle, cydev, mcOffset, size)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMulticastGetGranularity' in found_functions}}

@cython.embedsignature(True)
def cuMulticastGetGranularity(prop : Optional[CUmulticastObjectProp], option not None : CUmulticastGranularity_flags):
    """ Calculates either the minimal or recommended granularity for multicast object.

    Calculates either the minimal or recommended granularity for a given
    set of multicast object properties and returns it in granularity. This
    granularity can be used as a multiple for size, bind offsets and
    address mappings of the multicast object.

    Parameters
    ----------
    prop : :py:obj:`~.CUmulticastObjectProp`
        Properties of the multicast object.
    option : :py:obj:`~.CUmulticastGranularity_flags`
        Determines which granularity to return.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    granularity : int
        Returned granularity.

    See Also
    --------
    :py:obj:`~.cuMulticastCreate`, :py:obj:`~.cuMulticastBindMem`, :py:obj:`~.cuMulticastBindAddr`, :py:obj:`~.cuMulticastUnbind`
    """
    cdef size_t granularity = 0
    cdef cydriver.CUmulticastObjectProp* cyprop_ptr = prop._pvt_ptr if prop is not None else NULL
    cdef cydriver.CUmulticastGranularity_flags cyoption = option.value
    with nogil:
        err = cydriver.cuMulticastGetGranularity(&granularity, cyprop_ptr, cyoption)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], granularity)
{{endif}}

{{if 'cuPointerGetAttribute' in found_functions}}

@cython.embedsignature(True)
def cuPointerGetAttribute(attribute not None : CUpointer_attribute, ptr):
    """ Returns information about a pointer.

    The supported attributes are:

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_CONTEXT`:

    - Returns in `*data` the :py:obj:`~.CUcontext` in which `ptr` was
      allocated or registered. The type of `data` must be
      :py:obj:`~.CUcontext` *.

    - If `ptr` was not allocated by, mapped by, or registered with a
      :py:obj:`~.CUcontext` which uses unified virtual addressing then
      :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_MEMORY_TYPE`:

    - Returns in `*data` the physical memory type of the memory that `ptr`
      addresses as a :py:obj:`~.CUmemorytype` enumerated value. The type of
      `data` must be unsigned int.

    - If `ptr` addresses device memory then `*data` is set to
      :py:obj:`~.CU_MEMORYTYPE_DEVICE`. The particular :py:obj:`~.CUdevice`
      on which the memory resides is the :py:obj:`~.CUdevice` of the
      :py:obj:`~.CUcontext` returned by the
      :py:obj:`~.CU_POINTER_ATTRIBUTE_CONTEXT` attribute of `ptr`.

    - If `ptr` addresses host memory then `*data` is set to
      :py:obj:`~.CU_MEMORYTYPE_HOST`.

    - If `ptr` was not allocated by, mapped by, or registered with a
      :py:obj:`~.CUcontext` which uses unified virtual addressing then
      :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

    - If the current :py:obj:`~.CUcontext` does not support unified virtual
      addressing then :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` is returned.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_DEVICE_POINTER`:

    - Returns in `*data` the device pointer value through which `ptr` may
      be accessed by kernels running in the current :py:obj:`~.CUcontext`.
      The type of `data` must be CUdeviceptr *.

    - If there exists no device pointer value through which kernels running
      in the current :py:obj:`~.CUcontext` may access `ptr` then
      :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

    - If there is no current :py:obj:`~.CUcontext` then
      :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` is returned.

    - Except in the exceptional disjoint addressing cases discussed below,
      the value returned in `*data` will equal the input value `ptr`.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_HOST_POINTER`:

    - Returns in `*data` the host pointer value through which `ptr` may be
      accessed by by the host program. The type of `data` must be void **.
      If there exists no host pointer value through which the host program
      may directly access `ptr` then :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
      is returned.

    - Except in the exceptional disjoint addressing cases discussed below,
      the value returned in `*data` will equal the input value `ptr`.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_P2P_TOKENS`:

    - Returns in `*data` two tokens for use with the nv-p2p.h Linux kernel
      interface. `data` must be a struct of type
      CUDA_POINTER_ATTRIBUTE_P2P_TOKENS.

    - `ptr` must be a pointer to memory obtained from
      :py:obj:`~.py`:obj:`~.cuMemAlloc()`. Note that p2pToken and
      vaSpaceToken are only valid for the lifetime of the source
      allocation. A subsequent allocation at the same address may return
      completely different tokens. Querying this attribute has a side
      effect of setting the attribute
      :py:obj:`~.CU_POINTER_ATTRIBUTE_SYNC_MEMOPS` for the region of memory
      that `ptr` points to.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_SYNC_MEMOPS`:

    - A boolean attribute which when set, ensures that synchronous memory
      operations initiated on the region of memory that `ptr` points to
      will always synchronize. See further documentation in the section
      titled "API synchronization behavior" to learn more about cases when
      synchronous memory operations can exhibit asynchronous behavior.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_BUFFER_ID`:

    - Returns in `*data` a buffer ID which is guaranteed to be unique
      within the process. `data` must point to an unsigned long long.

    - `ptr` must be a pointer to memory obtained from a CUDA memory
      allocation API. Every memory allocation from any of the CUDA memory
      allocation APIs will have a unique ID over a process lifetime.
      Subsequent allocations do not reuse IDs from previous freed
      allocations. IDs are only unique within a single process.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_MANAGED`:

    - Returns in `*data` a boolean that indicates whether the pointer
      points to managed memory or not.

    - If `ptr` is not a valid CUDA pointer then
      :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL`:

    - Returns in `*data` an integer representing a device ordinal of a
      device against which the memory was allocated or registered.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE`:

    - Returns in `*data` a boolean that indicates if this pointer maps to
      an allocation that is suitable for :py:obj:`~.cudaIpcGetMemHandle`.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_RANGE_START_ADDR`:

    - Returns in `*data` the starting address for the allocation referenced
      by the device pointer `ptr`. Note that this is not necessarily the
      address of the mapped region, but the address of the mappable address
      range `ptr` references (e.g. from :py:obj:`~.cuMemAddressReserve`).

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_RANGE_SIZE`:

    - Returns in `*data` the size for the allocation referenced by the
      device pointer `ptr`. Note that this is not necessarily the size of
      the mapped region, but the size of the mappable address range `ptr`
      references (e.g. from :py:obj:`~.cuMemAddressReserve`). To retrieve
      the size of the mapped region, see :py:obj:`~.cuMemGetAddressRange`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_MAPPED`:

    - Returns in `*data` a boolean that indicates if this pointer is in a
      valid address range that is mapped to a backing allocation.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES`:

    - Returns a bitmask of the allowed handle types for an allocation that
      may be passed to :py:obj:`~.cuMemExportToShareableHandle`.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE`:

    - Returns in `*data` the handle to the mempool that the allocation was
      obtained from.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE`:

    - Returns in `*data` a boolean that indicates whether the pointer
      points to memory that is capable to be used for hardware accelerated
      decompression.

    Note that for most allocations in the unified virtual address space the
    host and device pointer for accessing the allocation will be the same.
    The exceptions to this are

    - user memory registered using :py:obj:`~.cuMemHostRegister`

    - host memory allocated using :py:obj:`~.cuMemHostAlloc` with the
      :py:obj:`~.CU_MEMHOSTALLOC_WRITECOMBINED` flag For these types of
      allocation there will exist separate, disjoint host and device
      addresses for accessing the allocation. In particular

    - The host address will correspond to an invalid unmapped device
      address (which will result in an exception if accessed from the
      device)

    - The device address will correspond to an invalid unmapped host
      address (which will result in an exception if accessed from the
      host). For these types of allocations, querying
      :py:obj:`~.CU_POINTER_ATTRIBUTE_HOST_POINTER` and
      :py:obj:`~.CU_POINTER_ATTRIBUTE_DEVICE_POINTER` may be used to
      retrieve the host and device addresses from either address.

    Parameters
    ----------
    attribute : :py:obj:`~.CUpointer_attribute`
        Pointer attribute to query
    ptr : :py:obj:`~.CUdeviceptr`
        Pointer

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    data : Any
        Returned pointer attribute value

    See Also
    --------
    :py:obj:`~.cuPointerSetAttribute`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuMemHostUnregister`, :py:obj:`~.cudaPointerGetAttributes`
    """
    cdef cydriver.CUdeviceptr cyptr
    if ptr is None:
        pptr = 0
    elif isinstance(ptr, (CUdeviceptr,)):
        pptr = int(ptr)
    else:
        pptr = int(CUdeviceptr(ptr))
    cyptr = <cydriver.CUdeviceptr><void_ptr>pptr
    cdef _HelperCUpointer_attribute cydata = _HelperCUpointer_attribute(attribute, 0, is_getter=True)
    cdef void* cydata_ptr = <void*><void_ptr>cydata.cptr
    cdef cydriver.CUpointer_attribute cyattribute = attribute.value
    with nogil:
        err = cydriver.cuPointerGetAttribute(cydata_ptr, cyattribute, cyptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], cydata.pyObj())
{{endif}}

{{if 'cuMemPrefetchAsync_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemPrefetchAsync(devPtr, size_t count, location not None : CUmemLocation, unsigned int flags, hStream):
    """ Prefetches memory to the specified destination location.

    Prefetches memory to the specified destination location. `devPtr` is
    the base device pointer of the memory to be prefetched and `location`
    specifies the destination location. `count` specifies the number of
    bytes to copy. `hStream` is the stream in which the operation is
    enqueued. The memory range must refer to managed memory allocated via
    :py:obj:`~.cuMemAllocManaged` or declared via managed variables.

    Specifying :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE` for
    :py:obj:`~.CUmemLocation.type` will prefetch memory to GPU specified by
    device ordinal :py:obj:`~.CUmemLocation.id` which must have non-zero
    value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`.
    Additionally, `hStream` must be associated with a device that has a
    non-zero value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. Specifying
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST` as :py:obj:`~.CUmemLocation.type`
    will prefetch data to host memory. Applications can request prefetching
    memory to a specific host NUMA node by specifying
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA` for
    :py:obj:`~.CUmemLocation.type` and a valid host NUMA node id in
    :py:obj:`~.CUmemLocation.id` Users can also request prefetching memory
    to the host NUMA node closest to the current thread's CPU by specifying
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT` for
    :py:obj:`~.CUmemLocation.type`. Note when
    :py:obj:`~.CUmemLocation.type` is etiher
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST` OR
    :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT`,
    :py:obj:`~.CUmemLocation.id` will be ignored.

    The start address and end address of the memory range will be rounded
    down and rounded up respectively to be aligned to CPU page size before
    the prefetch operation is enqueued in the stream.

    If no physical memory has been allocated for this region, then this
    memory region will be populated and mapped on the destination device.
    If there's insufficient memory to prefetch the desired region, the
    Unified Memory driver may evict pages from other
    :py:obj:`~.cuMemAllocManaged` allocations to host memory in order to
    make room. Device memory allocated using :py:obj:`~.cuMemAlloc` or
    :py:obj:`~.cuArrayCreate` will not be evicted.

    By default, any mappings to the previous location of the migrated pages
    are removed and mappings for the new location are only setup on the
    destination location. The exact behavior however also depends on the
    settings applied to this memory range via :py:obj:`~.cuMemAdvise` as
    described below:

    If :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY` was set on any subset of
    this memory range, then that subset will create a read-only copy of the
    pages on destination location. If however the destination location is a
    host NUMA node, then any pages of that subset that are already in
    another host NUMA node will be transferred to the destination.

    If :py:obj:`~.CU_MEM_ADVISE_SET_PREFERRED_LOCATION` was called on any
    subset of this memory range, then the pages will be migrated to
    `location` even if `location` is not the preferred location of any
    pages in the memory range.

    If :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY` was called on any subset
    of this memory range, then mappings to those pages from all the
    appropriate processors are updated to refer to the new location if
    establishing such a mapping is possible. Otherwise, those mappings are
    cleared.

    Note that this API is not required for functionality and only serves to
    improve performance by allowing the application to migrate data to a
    suitable location before it is accessed. Memory accesses to this range
    are always coherent and are allowed even when the data is actively
    being migrated.

    Note that this function is asynchronous with respect to the host and
    all work on other devices.

    Parameters
    ----------
    devPtr : :py:obj:`~.CUdeviceptr`
        Pointer to be prefetched
    count : size_t
        Size in bytes
    location : :py:obj:`~.CUmemLocation`
        Location to prefetch to
    flags : unsigned int
        flags for future use, must be zero now.
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to enqueue prefetch operation

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`

    See Also
    --------
    :py:obj:`~.cuMemcpy`, :py:obj:`~.cuMemcpyPeer`, :py:obj:`~.cuMemcpyAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cuMemAdvise`, :py:obj:`~.cudaMemPrefetchAsync`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUdeviceptr cydevPtr
    if devPtr is None:
        pdevPtr = 0
    elif isinstance(devPtr, (CUdeviceptr,)):
        pdevPtr = int(devPtr)
    else:
        pdevPtr = int(CUdeviceptr(devPtr))
    cydevPtr = <cydriver.CUdeviceptr><void_ptr>pdevPtr
    with nogil:
        err = cydriver.cuMemPrefetchAsync(cydevPtr, count, location._pvt_ptr[0], flags, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemAdvise_v2' in found_functions}}

@cython.embedsignature(True)
def cuMemAdvise(devPtr, size_t count, advice not None : CUmem_advise, location not None : CUmemLocation):
    """ Advise about the usage of a given memory range.

    Advise the Unified Memory subsystem about the usage pattern for the
    memory range starting at `devPtr` with a size of `count` bytes. The
    start address and end address of the memory range will be rounded down
    and rounded up respectively to be aligned to CPU page size before the
    advice is applied. The memory range must refer to managed memory
    allocated via :py:obj:`~.cuMemAllocManaged` or declared via managed
    variables. The memory range could also refer to system-allocated
    pageable memory provided it represents a valid, host-accessible region
    of memory and all additional constraints imposed by `advice` as
    outlined below are also satisfied. Specifying an invalid system-
    allocated pageable memory range results in an error being returned.

    The `advice` parameter can take the following values:

    - :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY`: This implies that the data
      is mostly going to be read from and only occasionally written to. Any
      read accesses from any processor to this region will create a read-
      only copy of at least the accessed pages in that processor's memory.
      Additionally, if :py:obj:`~.cuMemPrefetchAsync` is called on this
      region, it will create a read-only copy of the data on the
      destination processor. If the target location for
      :py:obj:`~.cuMemPrefetchAsync` is a host NUMA node and a read-only
      copy already exists on another host NUMA node, that copy will be
      migrated to the targeted host NUMA node. If any processor writes to
      this region, all copies of the corresponding page will be invalidated
      except for the one where the write occurred. If the writing processor
      is the CPU and the preferred location of the page is a host NUMA
      node, then the page will also be migrated to that host NUMA node. The
      `location` argument is ignored for this advice. Note that for a page
      to be read-duplicated, the accessing processor must either be the CPU
      or a GPU that has a non-zero value for the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. Also, if a
      context is created on a device that does not have the device
      attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`
      set, then read-duplication will not occur until all such contexts are
      destroyed. If the memory region refers to valid system-allocated
      pageable memory, then the accessing device must have a non-zero value
      for the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS` for a read-
      only copy to be created on that device. Note however that if the
      accessing device also has a non-zero value for the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
      then setting this advice will not create a read-only copy when that
      device accesses this memory region.

    - :py:obj:`~.CU_MEM_ADVISE_UNSET_READ_MOSTLY`: Undoes the effect of
      :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY` and also prevents the
      Unified Memory driver from attempting heuristic read-duplication on
      the memory range. Any read-duplicated copies of the data will be
      collapsed into a single copy. The location for the collapsed copy
      will be the preferred location if the page has a preferred location
      and one of the read-duplicated copies was resident at that location.
      Otherwise, the location chosen is arbitrary. Note: The `location`
      argument is ignored for this advice.

    - :py:obj:`~.CU_MEM_ADVISE_SET_PREFERRED_LOCATION`: This advice sets
      the preferred location for the data to be the memory belonging to
      `location`. When :py:obj:`~.CUmemLocation.type` is
      :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST`, :py:obj:`~.CUmemLocation.id`
      is ignored and the preferred location is set to be host memory. To
      set the preferred location to a specific host NUMA node, applications
      must set :py:obj:`~.CUmemLocation.type` to
      :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA` and
      :py:obj:`~.CUmemLocation.id` must specify the NUMA ID of the host
      NUMA node. If :py:obj:`~.CUmemLocation.type` is set to
      :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT`,
      :py:obj:`~.CUmemLocation.id` will be ignored and the the host NUMA
      node closest to the calling thread's CPU will be used as the
      preferred location. If :py:obj:`~.CUmemLocation.type` is a
      :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE`, then
      :py:obj:`~.CUmemLocation.id` must be a valid device ordinal and the
      device must have a non-zero value for the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. Setting
      the preferred location does not cause data to migrate to that
      location immediately. Instead, it guides the migration policy when a
      fault occurs on that memory region. If the data is already in its
      preferred location and the faulting processor can establish a mapping
      without requiring the data to be migrated, then data migration will
      be avoided. On the other hand, if the data is not in its preferred
      location or if a direct mapping cannot be established, then it will
      be migrated to the processor accessing it. It is important to note
      that setting the preferred location does not prevent data prefetching
      done using :py:obj:`~.cuMemPrefetchAsync`. Having a preferred
      location can override the page thrash detection and resolution logic
      in the Unified Memory driver. Normally, if a page is detected to be
      constantly thrashing between for example host and device memory, the
      page may eventually be pinned to host memory by the Unified Memory
      driver. But if the preferred location is set as device memory, then
      the page will continue to thrash indefinitely. If
      :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY` is also set on this memory
      region or any subset of it, then the policies associated with that
      advice will override the policies of this advice, unless read
      accesses from `location` will not result in a read-only copy being
      created on that procesor as outlined in description for the advice
      :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY`. If the memory region
      refers to valid system-allocated pageable memory, and
      :py:obj:`~.CUmemLocation.type` is CU_MEM_LOCATION_TYPE_DEVICE then
      :py:obj:`~.CUmemLocation.id` must be a valid device that has a non-
      zero alue for the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`.

    - :py:obj:`~.CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION`: Undoes the effect
      of :py:obj:`~.CU_MEM_ADVISE_SET_PREFERRED_LOCATION` and changes the
      preferred location to none. The `location` argument is ignored for
      this advice.

    - :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY`: This advice implies that
      the data will be accessed by processor `location`. The
      :py:obj:`~.CUmemLocation.type` must be either
      :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE` with
      :py:obj:`~.CUmemLocation.id` representing a valid device ordinal or
      :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST` and
      :py:obj:`~.CUmemLocation.id` will be ignored. All other location
      types are invalid. If :py:obj:`~.CUmemLocation.id` is a GPU, then the
      device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` must be
      non-zero. This advice does not cause data migration and has no impact
      on the location of the data per se. Instead, it causes the data to
      always be mapped in the specified processor's page tables, as long as
      the location of the data permits a mapping to be established. If the
      data gets migrated for any reason, the mappings are updated
      accordingly. This advice is recommended in scenarios where data
      locality is not important, but avoiding faults is. Consider for
      example a system containing multiple GPUs with peer-to-peer access
      enabled, where the data located on one GPU is occasionally accessed
      by peer GPUs. In such scenarios, migrating data over to the other
      GPUs is not as important because the accesses are infrequent and the
      overhead of migration may be too high. But preventing faults can
      still help improve performance, and so having a mapping set up in
      advance is useful. Note that on CPU access of this data, the data may
      be migrated to host memory because the CPU typically cannot access
      device memory directly. Any GPU that had the
      :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY` flag set for this data will
      now have its mapping updated to point to the page in host memory. If
      :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY` is also set on this memory
      region or any subset of it, then the policies associated with that
      advice will override the policies of this advice. Additionally, if
      the preferred location of this memory region or any subset of it is
      also `location`, then the policies associated with
      :py:obj:`~.CU_MEM_ADVISE_SET_PREFERRED_LOCATION` will override the
      policies of this advice. If the memory region refers to valid system-
      allocated pageable memory, and :py:obj:`~.CUmemLocation.type` is
      :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE` then device in
      :py:obj:`~.CUmemLocation.id` must have a non-zero value for the
      device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`. Additionally,
      if :py:obj:`~.CUmemLocation.id` has a non-zero value for the device
      attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
      then this call has no effect.

    - :py:obj:`~.CU_MEM_ADVISE_UNSET_ACCESSED_BY`: Undoes the effect of
      :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY`. Any mappings to the data
      from `location` may be removed at any time causing accesses to result
      in non-fatal page faults. If the memory region refers to valid
      system-allocated pageable memory, and :py:obj:`~.CUmemLocation.type`
      is :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE` then device in
      :py:obj:`~.CUmemLocation.id` must have a non-zero value for the
      device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`. Additionally,
      if :py:obj:`~.CUmemLocation.id` has a non-zero value for the device
      attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
      then this call has no effect.

    Parameters
    ----------
    devPtr : :py:obj:`~.CUdeviceptr`
        Pointer to memory to set the advice for
    count : size_t
        Size in bytes of the memory range
    advice : :py:obj:`~.CUmem_advise`
        Advice to be applied for the specified memory range
    location : :py:obj:`~.CUmemLocation`
        location to apply the advice for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`

    See Also
    --------
    :py:obj:`~.cuMemcpy`, :py:obj:`~.cuMemcpyPeer`, :py:obj:`~.cuMemcpyAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cuMemPrefetchAsync`, :py:obj:`~.cudaMemAdvise`
    """
    cdef cydriver.CUdeviceptr cydevPtr
    if devPtr is None:
        pdevPtr = 0
    elif isinstance(devPtr, (CUdeviceptr,)):
        pdevPtr = int(devPtr)
    else:
        pdevPtr = int(CUdeviceptr(devPtr))
    cydevPtr = <cydriver.CUdeviceptr><void_ptr>pdevPtr
    cdef cydriver.CUmem_advise cyadvice = advice.value
    with nogil:
        err = cydriver.cuMemAdvise(cydevPtr, count, cyadvice, location._pvt_ptr[0])
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemPrefetchBatchAsync' in found_functions}}

@cython.embedsignature(True)
def cuMemPrefetchBatchAsync(dptrs : Optional[tuple[CUdeviceptr] | list[CUdeviceptr]], sizes : tuple[int] | list[int], size_t count, prefetchLocs : Optional[tuple[CUmemLocation] | list[CUmemLocation]], prefetchLocIdxs : tuple[int] | list[int], size_t numPrefetchLocs, unsigned long long flags, hStream):
    """ Performs a batch of memory prefetches asynchronously.

    Performs a batch of memory prefetches. The batch as a whole executes in
    stream order but operations within a batch are not guaranteed to
    execute in any specific order. All devices in the system must have a
    non-zero value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` otherwise the
    API will return an error.

    The semantics of the individual prefetch operations are as described in
    :py:obj:`~.cuMemPrefetchAsync`.

    Performs memory prefetch on address ranges specified in `dptrs` and
    `sizes`. Both arrays must be of the same length as specified by
    `count`. Each memory range specified must refer to managed memory
    allocated via :py:obj:`~.cuMemAllocManaged` or declared via managed
    variables or it may also refer to system-allocated memory when all
    devices have a non-zero value for
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`. The prefetch
    location for every operation in the batch is specified in the
    `prefetchLocs` array. Each entry in this array can apply to more than
    one operation. This can be done by specifying in the `prefetchLocIdxs`
    array, the index of the first prefetch operation that the corresponding
    entry in the `prefetchLocs` array applies to. Both `prefetchLocs` and
    `prefetchLocIdxs` must be of the same length as specified by
    `numPrefetchLocs`. For example, if a batch has 10 prefetches listed in
    dptrs/sizes, the first 4 of which are to be prefetched to one location
    and the remaining 6 are to be prefetched to another, then
    `numPrefetchLocs` will be 2, `prefetchLocIdxs` will be {0, 4} and
    `prefetchLocs` will contain the two locations. Note the first entry in
    `prefetchLocIdxs` must always be 0. Also, each entry must be greater
    than the previous entry and the last entry should be less than `count`.
    Furthermore, `numPrefetchLocs` must be lesser than or equal to `count`.

    Parameters
    ----------
    dptrs : list[:py:obj:`~.CUdeviceptr`]
        Array of pointers to be prefetched
    sizes : list[int]
        Array of sizes for memory prefetch operations.
    count : size_t
        Size of `dptrs` and `sizes` arrays.
    prefetchLocs : list[:py:obj:`~.CUmemLocation`]
        Array of locations to prefetch to.
    prefetchLocIdxs : list[int]
        Array of indices to specify which operands each entry in the
        `prefetchLocs` array applies to. The locations specified in
        prefetchLocs[k] will be applied to copies starting from
        prefetchLocIdxs[k] through prefetchLocIdxs[k+1] - 1. Also
        prefetchLocs[numPrefetchLocs - 1] will apply to prefetches starting
        from prefetchLocIdxs[numPrefetchLocs - 1] through count - 1.
    numPrefetchLocs : size_t
        Size of `prefetchLocs` and `prefetchLocIdxs` arrays.
    flags : unsigned long long
        Flags reserved for future use. Must be zero.
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to enqueue the operations in. Must not be legacy NULL
        stream.

    Returns
    -------
    CUresult

    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    if not all(isinstance(_x, (int)) for _x in prefetchLocIdxs):
        raise TypeError("Argument 'prefetchLocIdxs' is not instance of type (expected tuple[int] or list[int]")
    prefetchLocs = [] if prefetchLocs is None else prefetchLocs
    if not all(isinstance(_x, (CUmemLocation,)) for _x in prefetchLocs):
        raise TypeError("Argument 'prefetchLocs' is not instance of type (expected tuple[cydriver.CUmemLocation,] or list[cydriver.CUmemLocation,]")
    if not all(isinstance(_x, (int)) for _x in sizes):
        raise TypeError("Argument 'sizes' is not instance of type (expected tuple[int] or list[int]")
    dptrs = [] if dptrs is None else dptrs
    if not all(isinstance(_x, (CUdeviceptr,)) for _x in dptrs):
        raise TypeError("Argument 'dptrs' is not instance of type (expected tuple[cydriver.CUdeviceptr,] or list[cydriver.CUdeviceptr,]")
    cdef cydriver.CUdeviceptr* cydptrs = NULL
    if len(dptrs) > 1:
        cydptrs = <cydriver.CUdeviceptr*> calloc(len(dptrs), sizeof(cydriver.CUdeviceptr))
        if cydptrs is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dptrs)) + 'x' + str(sizeof(cydriver.CUdeviceptr)))
        else:
            for idx in range(len(dptrs)):
                cydptrs[idx] = <cydriver.CUdeviceptr>(<CUdeviceptr>dptrs[idx])._pvt_ptr[0]
    elif len(dptrs) == 1:
        cydptrs = <cydriver.CUdeviceptr*>(<CUdeviceptr>dptrs[0])._pvt_ptr
    cdef vector[size_t] cysizes = sizes
    if count > <size_t>len(dptrs): raise RuntimeError("List is too small: " + str(len(dptrs)) + " < " + str(count))
    if count > <size_t>len(sizes): raise RuntimeError("List is too small: " + str(len(sizes)) + " < " + str(count))
    cdef cydriver.CUmemLocation* cyprefetchLocs = NULL
    if len(prefetchLocs) > 1:
        cyprefetchLocs = <cydriver.CUmemLocation*> calloc(len(prefetchLocs), sizeof(cydriver.CUmemLocation))
        if cyprefetchLocs is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(prefetchLocs)) + 'x' + str(sizeof(cydriver.CUmemLocation)))
        for idx in range(len(prefetchLocs)):
            string.memcpy(&cyprefetchLocs[idx], (<CUmemLocation>prefetchLocs[idx])._pvt_ptr, sizeof(cydriver.CUmemLocation))
    elif len(prefetchLocs) == 1:
        cyprefetchLocs = (<CUmemLocation>prefetchLocs[0])._pvt_ptr
    cdef vector[size_t] cyprefetchLocIdxs = prefetchLocIdxs
    if numPrefetchLocs > <size_t>len(prefetchLocs): raise RuntimeError("List is too small: " + str(len(prefetchLocs)) + " < " + str(numPrefetchLocs))
    if numPrefetchLocs > <size_t>len(prefetchLocIdxs): raise RuntimeError("List is too small: " + str(len(prefetchLocIdxs)) + " < " + str(numPrefetchLocs))
    with nogil:
        err = cydriver.cuMemPrefetchBatchAsync(cydptrs, cysizes.data(), count, cyprefetchLocs, cyprefetchLocIdxs.data(), numPrefetchLocs, flags, cyhStream)
    if len(dptrs) > 1 and cydptrs is not NULL:
        free(cydptrs)
    if len(prefetchLocs) > 1 and cyprefetchLocs is not NULL:
        free(cyprefetchLocs)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemDiscardBatchAsync' in found_functions}}

@cython.embedsignature(True)
def cuMemDiscardBatchAsync(dptrs : Optional[tuple[CUdeviceptr] | list[CUdeviceptr]], sizes : tuple[int] | list[int], size_t count, unsigned long long flags, hStream):
    """ Performs a batch of memory discards asynchronously.

    Performs a batch of memory discards. The batch as a whole executes in
    stream order but operations within a batch are not guaranteed to
    execute in any specific order. All devices in the system must have a
    non-zero value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` otherwise the
    API will return an error.

    Discarding a memory range informs the driver that the contents of that
    range are no longer useful. Discarding memory ranges allows the driver
    to optimize certain data migrations and can also help reduce memory
    pressure. This operation can be undone on any part of the range by
    either writing to it or prefetching it via
    :py:obj:`~.cuMemPrefetchAsync` or :py:obj:`~.cuMemPrefetchBatchAsync`.
    Reading from a discarded range, without a subsequent write or prefetch
    to that part of the range, will return an indeterminate value. Note
    that any reads, writes or prefetches to any part of the memory range
    that occur simultaneously with the discard operation result in
    undefined behavior.

    Performs memory discard on address ranges specified in `dptrs` and
    `sizes`. Both arrays must be of the same length as specified by
    `count`. Each memory range specified must refer to managed memory
    allocated via :py:obj:`~.cuMemAllocManaged` or declared via managed
    variables or it may also refer to system-allocated memory when all
    devices have a non-zero value for
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`.

    Parameters
    ----------
    dptrs : list[:py:obj:`~.CUdeviceptr`]
        Array of pointers to be discarded
    sizes : list[int]
        Array of sizes for memory discard operations.
    count : size_t
        Size of `dptrs` and `sizes` arrays.
    flags : unsigned long long
        Flags reserved for future use. Must be zero.
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to enqueue the operations in. Must not be legacy NULL
        stream.

    Returns
    -------
    CUresult

    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    if not all(isinstance(_x, (int)) for _x in sizes):
        raise TypeError("Argument 'sizes' is not instance of type (expected tuple[int] or list[int]")
    dptrs = [] if dptrs is None else dptrs
    if not all(isinstance(_x, (CUdeviceptr,)) for _x in dptrs):
        raise TypeError("Argument 'dptrs' is not instance of type (expected tuple[cydriver.CUdeviceptr,] or list[cydriver.CUdeviceptr,]")
    cdef cydriver.CUdeviceptr* cydptrs = NULL
    if len(dptrs) > 1:
        cydptrs = <cydriver.CUdeviceptr*> calloc(len(dptrs), sizeof(cydriver.CUdeviceptr))
        if cydptrs is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dptrs)) + 'x' + str(sizeof(cydriver.CUdeviceptr)))
        else:
            for idx in range(len(dptrs)):
                cydptrs[idx] = <cydriver.CUdeviceptr>(<CUdeviceptr>dptrs[idx])._pvt_ptr[0]
    elif len(dptrs) == 1:
        cydptrs = <cydriver.CUdeviceptr*>(<CUdeviceptr>dptrs[0])._pvt_ptr
    cdef vector[size_t] cysizes = sizes
    if count > <size_t>len(dptrs): raise RuntimeError("List is too small: " + str(len(dptrs)) + " < " + str(count))
    if count > <size_t>len(sizes): raise RuntimeError("List is too small: " + str(len(sizes)) + " < " + str(count))
    with nogil:
        err = cydriver.cuMemDiscardBatchAsync(cydptrs, cysizes.data(), count, flags, cyhStream)
    if len(dptrs) > 1 and cydptrs is not NULL:
        free(cydptrs)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemDiscardAndPrefetchBatchAsync' in found_functions}}

@cython.embedsignature(True)
def cuMemDiscardAndPrefetchBatchAsync(dptrs : Optional[tuple[CUdeviceptr] | list[CUdeviceptr]], sizes : tuple[int] | list[int], size_t count, prefetchLocs : Optional[tuple[CUmemLocation] | list[CUmemLocation]], prefetchLocIdxs : tuple[int] | list[int], size_t numPrefetchLocs, unsigned long long flags, hStream):
    """ Performs a batch of memory discards and prefetches asynchronously.

    Performs a batch of memory discards followed by prefetches. The batch
    as a whole executes in stream order but operations within a batch are
    not guaranteed to execute in any specific order. All devices in the
    system must have a non-zero value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` otherwise the
    API will return an error.

    Calling :py:obj:`~.cuMemDiscardAndPrefetchBatchAsync` is semantically
    equivalent to calling :py:obj:`~.cuMemDiscardBatchAsync` followed by
    :py:obj:`~.cuMemPrefetchBatchAsync`, but is more optimal. For more
    details on what discarding and prefetching imply, please refer to
    :py:obj:`~.cuMemDiscardBatchAsync` and
    :py:obj:`~.cuMemPrefetchBatchAsync` respectively. Note that any reads,
    writes or prefetches to any part of the memory range that occur
    simultaneously with this combined discard+prefetch operation result in
    undefined behavior.

    Performs memory discard and prefetch on address ranges specified in
    `dptrs` and `sizes`. Both arrays must be of the same length as
    specified by `count`. Each memory range specified must refer to managed
    memory allocated via :py:obj:`~.cuMemAllocManaged` or declared via
    managed variables or it may also refer to system-allocated memory when
    all devices have a non-zero value for
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`. Every operation
    in the batch has to be associated with a valid location to prefetch the
    address range to and specified in the `prefetchLocs` array. Each entry
    in this array can apply to more than one operation. This can be done by
    specifying in the `prefetchLocIdxs` array, the index of the first
    operation that the corresponding entry in the `prefetchLocs` array
    applies to. Both `prefetchLocs` and `prefetchLocIdxs` must be of the
    same length as specified by `numPrefetchLocs`. For example, if a batch
    has 10 operations listed in dptrs/sizes, the first 6 of which are to be
    prefetched to one location and the remaining 4 are to be prefetched to
    another, then `numPrefetchLocs` will be 2, `prefetchLocIdxs` will be
    {0, 6} and `prefetchLocs` will contain the two set of locations. Note
    the first entry in `prefetchLocIdxs` must always be 0. Also, each entry
    must be greater than the previous entry and the last entry should be
    less than `count`. Furthermore, `numPrefetchLocs` must be lesser than
    or equal to `count`.

    Parameters
    ----------
    dptrs : list[:py:obj:`~.CUdeviceptr`]
        Array of pointers to be discarded
    sizes : list[int]
        Array of sizes for memory discard operations.
    count : size_t
        Size of `dptrs` and `sizes` arrays.
    prefetchLocs : list[:py:obj:`~.CUmemLocation`]
        Array of locations to prefetch to.
    prefetchLocIdxs : list[int]
        Array of indices to specify which operands each entry in the
        `prefetchLocs` array applies to. The locations specified in
        prefetchLocs[k] will be applied to operations starting from
        prefetchLocIdxs[k] through prefetchLocIdxs[k+1] - 1. Also
        prefetchLocs[numPrefetchLocs - 1] will apply to copies starting
        from prefetchLocIdxs[numPrefetchLocs - 1] through count - 1.
    numPrefetchLocs : size_t
        Size of `prefetchLocs` and `prefetchLocIdxs` arrays.
    flags : unsigned long long
        Flags reserved for future use. Must be zero.
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to enqueue the operations in. Must not be legacy NULL
        stream.

    Returns
    -------
    CUresult

    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    if not all(isinstance(_x, (int)) for _x in prefetchLocIdxs):
        raise TypeError("Argument 'prefetchLocIdxs' is not instance of type (expected tuple[int] or list[int]")
    prefetchLocs = [] if prefetchLocs is None else prefetchLocs
    if not all(isinstance(_x, (CUmemLocation,)) for _x in prefetchLocs):
        raise TypeError("Argument 'prefetchLocs' is not instance of type (expected tuple[cydriver.CUmemLocation,] or list[cydriver.CUmemLocation,]")
    if not all(isinstance(_x, (int)) for _x in sizes):
        raise TypeError("Argument 'sizes' is not instance of type (expected tuple[int] or list[int]")
    dptrs = [] if dptrs is None else dptrs
    if not all(isinstance(_x, (CUdeviceptr,)) for _x in dptrs):
        raise TypeError("Argument 'dptrs' is not instance of type (expected tuple[cydriver.CUdeviceptr,] or list[cydriver.CUdeviceptr,]")
    cdef cydriver.CUdeviceptr* cydptrs = NULL
    if len(dptrs) > 1:
        cydptrs = <cydriver.CUdeviceptr*> calloc(len(dptrs), sizeof(cydriver.CUdeviceptr))
        if cydptrs is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dptrs)) + 'x' + str(sizeof(cydriver.CUdeviceptr)))
        else:
            for idx in range(len(dptrs)):
                cydptrs[idx] = <cydriver.CUdeviceptr>(<CUdeviceptr>dptrs[idx])._pvt_ptr[0]
    elif len(dptrs) == 1:
        cydptrs = <cydriver.CUdeviceptr*>(<CUdeviceptr>dptrs[0])._pvt_ptr
    cdef vector[size_t] cysizes = sizes
    if count > <size_t>len(dptrs): raise RuntimeError("List is too small: " + str(len(dptrs)) + " < " + str(count))
    if count > <size_t>len(sizes): raise RuntimeError("List is too small: " + str(len(sizes)) + " < " + str(count))
    cdef cydriver.CUmemLocation* cyprefetchLocs = NULL
    if len(prefetchLocs) > 1:
        cyprefetchLocs = <cydriver.CUmemLocation*> calloc(len(prefetchLocs), sizeof(cydriver.CUmemLocation))
        if cyprefetchLocs is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(prefetchLocs)) + 'x' + str(sizeof(cydriver.CUmemLocation)))
        for idx in range(len(prefetchLocs)):
            string.memcpy(&cyprefetchLocs[idx], (<CUmemLocation>prefetchLocs[idx])._pvt_ptr, sizeof(cydriver.CUmemLocation))
    elif len(prefetchLocs) == 1:
        cyprefetchLocs = (<CUmemLocation>prefetchLocs[0])._pvt_ptr
    cdef vector[size_t] cyprefetchLocIdxs = prefetchLocIdxs
    if numPrefetchLocs > <size_t>len(prefetchLocs): raise RuntimeError("List is too small: " + str(len(prefetchLocs)) + " < " + str(numPrefetchLocs))
    if numPrefetchLocs > <size_t>len(prefetchLocIdxs): raise RuntimeError("List is too small: " + str(len(prefetchLocIdxs)) + " < " + str(numPrefetchLocs))
    with nogil:
        err = cydriver.cuMemDiscardAndPrefetchBatchAsync(cydptrs, cysizes.data(), count, cyprefetchLocs, cyprefetchLocIdxs.data(), numPrefetchLocs, flags, cyhStream)
    if len(dptrs) > 1 and cydptrs is not NULL:
        free(cydptrs)
    if len(prefetchLocs) > 1 and cyprefetchLocs is not NULL:
        free(cyprefetchLocs)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuMemRangeGetAttribute' in found_functions}}

@cython.embedsignature(True)
def cuMemRangeGetAttribute(size_t dataSize, attribute not None : CUmem_range_attribute, devPtr, size_t count):
    """ Query an attribute of a given memory range.

    Query an attribute about the memory range starting at `devPtr` with a
    size of `count` bytes. The memory range must refer to managed memory
    allocated via :py:obj:`~.cuMemAllocManaged` or declared via managed
    variables.

    The `attribute` parameter can take the following values:

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY`: If this attribute is
      specified, `data` will be interpreted as a 32-bit integer, and
      `dataSize` must be 4. The result returned will be 1 if all pages in
      the given memory range have read-duplication enabled, or 0 otherwise.

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION`: If this
      attribute is specified, `data` will be interpreted as a 32-bit
      integer, and `dataSize` must be 4. The result returned will be a GPU
      device id if all pages in the memory range have that GPU as their
      preferred location, or it will be CU_DEVICE_CPU if all pages in the
      memory range have the CPU as their preferred location, or it will be
      CU_DEVICE_INVALID if either all the pages don't have the same
      preferred location or some of the pages don't have a preferred
      location at all. Note that the actual location of the pages in the
      memory range at the time of the query may be different from the
      preferred location.

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY`: If this attribute is
      specified, `data` will be interpreted as an array of 32-bit integers,
      and `dataSize` must be a non-zero multiple of 4. The result returned
      will be a list of device ids that had
      :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY` set for that entire memory
      range. If any device does not have that advice set for the entire
      memory range, that device will not be included. If `data` is larger
      than the number of devices that have that advice set for that memory
      range, CU_DEVICE_INVALID will be returned in all the extra space
      provided. For ex., if `dataSize` is 12 (i.e. `data` has 3 elements)
      and only device 0 has the advice set, then the result returned will
      be { 0, CU_DEVICE_INVALID, CU_DEVICE_INVALID }. If `data` is smaller
      than the number of devices that have that advice set, then only as
      many devices will be returned as can fit in the array. There is no
      guarantee on which specific devices will be returned, however.

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION`: If this
      attribute is specified, `data` will be interpreted as a 32-bit
      integer, and `dataSize` must be 4. The result returned will be the
      last location to which all pages in the memory range were prefetched
      explicitly via :py:obj:`~.cuMemPrefetchAsync`. This will either be a
      GPU id or CU_DEVICE_CPU depending on whether the last location for
      prefetch was a GPU or the CPU respectively. If any page in the memory
      range was never explicitly prefetched or if all pages were not
      prefetched to the same location, CU_DEVICE_INVALID will be returned.
      Note that this simply returns the last location that the application
      requested to prefetch the memory range to. It gives no indication as
      to whether the prefetch operation to that location has completed or
      even begun.

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE`: If this
      attribute is specified, `data` will be interpreted as a
      :py:obj:`~.CUmemLocationType`, and `dataSize` must be
      sizeof(CUmemLocationType). The :py:obj:`~.CUmemLocationType` returned
      will be :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE` if all pages in the
      memory range have the same GPU as their preferred location, or
      :py:obj:`~.CUmemLocationType` will be
      :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST` if all pages in the memory
      range have the CPU as their preferred location, or it will be
      :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA` if all the pages in the
      memory range have the same host NUMA node ID as their preferred
      location or it will be :py:obj:`~.CU_MEM_LOCATION_TYPE_INVALID` if
      either all the pages don't have the same preferred location or some
      of the pages don't have a preferred location at all. Note that the
      actual location type of the pages in the memory range at the time of
      the query may be different from the preferred location type.

      - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_ID`: If this
        attribute is specified, `data` will be interpreted as a 32-bit
        integer, and `dataSize` must be 4. If the
        :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE` query
        for the same address range returns
        :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE`, it will be a valid device
        ordinal or if it returns
        :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA`, it will be a valid host
        NUMA node ID or if it returns any other location type, the id
        should be ignored.

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE`: If
      this attribute is specified, `data` will be interpreted as a
      :py:obj:`~.CUmemLocationType`, and `dataSize` must be
      sizeof(CUmemLocationType). The result returned will be the last
      location to which all pages in the memory range were prefetched
      explicitly via :py:obj:`~.cuMemPrefetchAsync`. The
      :py:obj:`~.CUmemLocationType` returned will be
      :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE` if the last prefetch location
      was a GPU or :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST` if it was the CPU
      or :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA` if the last prefetch
      location was a specific host NUMA node. If any page in the memory
      range was never explicitly prefetched or if all pages were not
      prefetched to the same location, :py:obj:`~.CUmemLocationType` will
      be :py:obj:`~.CU_MEM_LOCATION_TYPE_INVALID`. Note that this simply
      returns the last location type that the application requested to
      prefetch the memory range to. It gives no indication as to whether
      the prefetch operation to that location has completed or even begun.

      - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_ID`: If
        this attribute is specified, `data` will be interpreted as a 32-bit
        integer, and `dataSize` must be 4. If the
        :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE`
        query for the same address range returns
        :py:obj:`~.CU_MEM_LOCATION_TYPE_DEVICE`, it will be a valid device
        ordinal or if it returns
        :py:obj:`~.CU_MEM_LOCATION_TYPE_HOST_NUMA`, it will be a valid host
        NUMA node ID or if it returns any other location type, the id
        should be ignored.

    Parameters
    ----------
    dataSize : size_t
        Array containing the size of data
    attribute : :py:obj:`~.CUmem_range_attribute`
        The attribute to query
    devPtr : :py:obj:`~.CUdeviceptr`
        Start of the range to query
    count : size_t
        Size of the range to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    data : Any
        A pointers to a memory location where the result of each attribute
        query will be written to.

    See Also
    --------
    :py:obj:`~.cuMemRangeGetAttributes`, :py:obj:`~.cuMemPrefetchAsync`, :py:obj:`~.cuMemAdvise`, :py:obj:`~.cudaMemRangeGetAttribute`
    """
    cdef cydriver.CUdeviceptr cydevPtr
    if devPtr is None:
        pdevPtr = 0
    elif isinstance(devPtr, (CUdeviceptr,)):
        pdevPtr = int(devPtr)
    else:
        pdevPtr = int(CUdeviceptr(devPtr))
    cydevPtr = <cydriver.CUdeviceptr><void_ptr>pdevPtr
    cdef _HelperCUmem_range_attribute cydata = _HelperCUmem_range_attribute(attribute, dataSize)
    cdef void* cydata_ptr = <void*><void_ptr>cydata.cptr
    cdef cydriver.CUmem_range_attribute cyattribute = attribute.value
    with nogil:
        err = cydriver.cuMemRangeGetAttribute(cydata_ptr, dataSize, cyattribute, cydevPtr, count)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], cydata.pyObj())
{{endif}}

{{if 'cuMemRangeGetAttributes' in found_functions}}

@cython.embedsignature(True)
def cuMemRangeGetAttributes(dataSizes : tuple[int] | list[int], attributes : Optional[tuple[CUmem_range_attribute] | list[CUmem_range_attribute]], size_t numAttributes, devPtr, size_t count):
    """ Query attributes of a given memory range.

    Query attributes of the memory range starting at `devPtr` with a size
    of `count` bytes. The memory range must refer to managed memory
    allocated via :py:obj:`~.cuMemAllocManaged` or declared via managed
    variables. The `attributes` array will be interpreted to have
    `numAttributes` entries. The `dataSizes` array will also be interpreted
    to have `numAttributes` entries. The results of the query will be
    stored in `data`.

    The list of supported attributes are given below. Please refer to
    :py:obj:`~.cuMemRangeGetAttribute` for attribute descriptions and
    restrictions.

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY`

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION`

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY`

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION`

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE`

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_ID`

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE`

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_ID`

    Parameters
    ----------
    dataSizes : list[int]
        Array containing the sizes of each result
    attributes : list[:py:obj:`~.CUmem_range_attribute`]
        An array of attributes to query (numAttributes and the number of
        attributes in this array should match)
    numAttributes : size_t
        Number of attributes to query
    devPtr : :py:obj:`~.CUdeviceptr`
        Start of the range to query
    count : size_t
        Size of the range to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    data : list[Any]
        A two-dimensional array containing pointers to memory locations
        where the result of each attribute query will be written to.

    See Also
    --------
    :py:obj:`~.cuMemRangeGetAttribute`, :py:obj:`~.cuMemAdvise`, :py:obj:`~.cuMemPrefetchAsync`, :py:obj:`~.cudaMemRangeGetAttributes`
    """
    cdef cydriver.CUdeviceptr cydevPtr
    if devPtr is None:
        pdevPtr = 0
    elif isinstance(devPtr, (CUdeviceptr,)):
        pdevPtr = int(devPtr)
    else:
        pdevPtr = int(CUdeviceptr(devPtr))
    cydevPtr = <cydriver.CUdeviceptr><void_ptr>pdevPtr
    attributes = [] if attributes is None else attributes
    if not all(isinstance(_x, (CUmem_range_attribute)) for _x in attributes):
        raise TypeError("Argument 'attributes' is not instance of type (expected tuple[cydriver.CUmem_range_attribute] or list[cydriver.CUmem_range_attribute]")
    if not all(isinstance(_x, (int)) for _x in dataSizes):
        raise TypeError("Argument 'dataSizes' is not instance of type (expected tuple[int] or list[int]")
    pylist = [_HelperCUmem_range_attribute(pyattributes, pydataSizes) for (pyattributes, pydataSizes) in zip(attributes, dataSizes)]
    cdef _InputVoidPtrPtrHelper voidStarHelperdata = _InputVoidPtrPtrHelper(pylist)
    cdef void** cyvoidStarHelper_ptr = <void**><void_ptr>voidStarHelperdata.cptr
    cdef vector[size_t] cydataSizes = dataSizes
    cdef vector[cydriver.CUmem_range_attribute] cyattributes = [pyattributes.value for pyattributes in (attributes)]
    if numAttributes > <size_t>len(dataSizes): raise RuntimeError("List is too small: " + str(len(dataSizes)) + " < " + str(numAttributes))
    if numAttributes > <size_t>len(attributes): raise RuntimeError("List is too small: " + str(len(attributes)) + " < " + str(numAttributes))
    with nogil:
        err = cydriver.cuMemRangeGetAttributes(cyvoidStarHelper_ptr, cydataSizes.data(), cyattributes.data(), numAttributes, cydevPtr, count)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], [obj.pyObj() for obj in pylist])
{{endif}}

{{if 'cuPointerSetAttribute' in found_functions}}

@cython.embedsignature(True)
def cuPointerSetAttribute(value, attribute not None : CUpointer_attribute, ptr):
    """ Set attributes on a previously allocated memory region.

    The supported attributes are:

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_SYNC_MEMOPS`:

    - A boolean attribute that can either be set (1) or unset (0). When
      set, the region of memory that `ptr` points to is guaranteed to
      always synchronize memory operations that are synchronous. If there
      are some previously initiated synchronous memory operations that are
      pending when this attribute is set, the function does not return
      until those memory operations are complete. See further documentation
      in the section titled "API synchronization behavior" to learn more
      about cases when synchronous memory operations can exhibit
      asynchronous behavior. `value` will be considered as a pointer to an
      unsigned integer to which this attribute is to be set.

    Parameters
    ----------
    value : Any
        Pointer to memory containing the value to be set
    attribute : :py:obj:`~.CUpointer_attribute`
        Pointer attribute to set
    ptr : :py:obj:`~.CUdeviceptr`
        Pointer to a memory region allocated using CUDA memory allocation
        APIs

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`

    See Also
    --------
    :py:obj:`~.cuPointerGetAttribute`, :py:obj:`~.cuPointerGetAttributes`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuMemHostUnregister`
    """
    cdef cydriver.CUdeviceptr cyptr
    if ptr is None:
        pptr = 0
    elif isinstance(ptr, (CUdeviceptr,)):
        pptr = int(ptr)
    else:
        pptr = int(CUdeviceptr(ptr))
    cyptr = <cydriver.CUdeviceptr><void_ptr>pptr
    cdef _HelperCUpointer_attribute cyvalue = _HelperCUpointer_attribute(attribute, value, is_getter=False)
    cdef void* cyvalue_ptr = <void*><void_ptr>cyvalue.cptr
    cdef cydriver.CUpointer_attribute cyattribute = attribute.value
    with nogil:
        err = cydriver.cuPointerSetAttribute(cyvalue_ptr, cyattribute, cyptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuPointerGetAttributes' in found_functions}}

@cython.embedsignature(True)
def cuPointerGetAttributes(unsigned int numAttributes, attributes : Optional[tuple[CUpointer_attribute] | list[CUpointer_attribute]], ptr):
    """ Returns information about a pointer.

    The supported attributes are (refer to
    :py:obj:`~.cuPointerGetAttribute` for attribute descriptions and
    restrictions):

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_CONTEXT`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_MEMORY_TYPE`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_DEVICE_POINTER`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_HOST_POINTER`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_SYNC_MEMOPS`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_BUFFER_ID`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_MANAGED`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_RANGE_START_ADDR`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_RANGE_SIZE`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_MAPPED`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE`

    Unlike :py:obj:`~.cuPointerGetAttribute`, this function will not return
    an error when the `ptr` encountered is not a valid CUDA pointer.
    Instead, the attributes are assigned default NULL values and
    CUDA_SUCCESS is returned.

    If `ptr` was not allocated by, mapped by, or registered with a
    :py:obj:`~.CUcontext` which uses UVA (Unified Virtual Addressing),
    :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` is returned.

    Parameters
    ----------
    numAttributes : unsigned int
        Number of attributes to query
    attributes : list[:py:obj:`~.CUpointer_attribute`]
        An array of attributes to query (numAttributes and the number of
        attributes in this array should match)
    ptr : :py:obj:`~.CUdeviceptr`
        Pointer to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    data : list[Any]
        A two-dimensional array containing pointers to memory locations
        where the result of each attribute query will be written to.

    See Also
    --------
    :py:obj:`~.cuPointerGetAttribute`, :py:obj:`~.cuPointerSetAttribute`, :py:obj:`~.cudaPointerGetAttributes`
    """
    cdef cydriver.CUdeviceptr cyptr
    if ptr is None:
        pptr = 0
    elif isinstance(ptr, (CUdeviceptr,)):
        pptr = int(ptr)
    else:
        pptr = int(CUdeviceptr(ptr))
    cyptr = <cydriver.CUdeviceptr><void_ptr>pptr
    attributes = [] if attributes is None else attributes
    if not all(isinstance(_x, (CUpointer_attribute)) for _x in attributes):
        raise TypeError("Argument 'attributes' is not instance of type (expected tuple[cydriver.CUpointer_attribute] or list[cydriver.CUpointer_attribute]")
    if numAttributes > len(attributes): raise RuntimeError("List is too small: " + str(len(attributes)) + " < " + str(numAttributes))
    cdef vector[cydriver.CUpointer_attribute] cyattributes = [pyattributes.value for pyattributes in (attributes)]
    pylist = [_HelperCUpointer_attribute(pyattributes, 0, is_getter=True) for pyattributes in attributes]
    cdef _InputVoidPtrPtrHelper voidStarHelperdata = _InputVoidPtrPtrHelper(pylist)
    cdef void** cyvoidStarHelper_ptr = <void**><void_ptr>voidStarHelperdata.cptr
    with nogil:
        err = cydriver.cuPointerGetAttributes(numAttributes, cyattributes.data(), cyvoidStarHelper_ptr, cyptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], [obj.pyObj() for obj in pylist])
{{endif}}

{{if 'cuStreamCreate' in found_functions}}

@cython.embedsignature(True)
def cuStreamCreate(unsigned int Flags):
    """ Create a stream.

    Creates a stream and returns a handle in `phStream`. The `Flags`
    argument determines behaviors of the stream.

    Valid values for `Flags` are:

    - :py:obj:`~.CU_STREAM_DEFAULT`: Default stream creation flag.

    - :py:obj:`~.CU_STREAM_NON_BLOCKING`: Specifies that work running in
      the created stream may run concurrently with work in stream 0 (the
      NULL stream), and that the created stream should perform no implicit
      synchronization with stream 0.

    Parameters
    ----------
    Flags : unsigned int
        Parameters for stream creation

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    phStream : :py:obj:`~.CUstream`
        Returned newly created stream

    See Also
    --------
    :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreateWithPriority`, :py:obj:`~.cuGreenCtxStreamCreate`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cuStreamGetDevice` :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithFlags`
    """
    cdef CUstream phStream = CUstream()
    with nogil:
        err = cydriver.cuStreamCreate(<cydriver.CUstream*>phStream._pvt_ptr, Flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phStream)
{{endif}}

{{if 'cuStreamCreateWithPriority' in found_functions}}

@cython.embedsignature(True)
def cuStreamCreateWithPriority(unsigned int flags, int priority):
    """ Create a stream with the given priority.

    Creates a stream with the specified priority and returns a handle in
    `phStream`. This affects the scheduling priority of work in the stream.
    Priorities provide a hint to preferentially run work with higher
    priority when possible, but do not preempt already-running work or
    provide any other functional guarantee on execution order.

    `priority` follows a convention where lower numbers represent higher
    priorities. '0' represents default priority. The range of meaningful
    numerical priorities can be queried using
    :py:obj:`~.cuCtxGetStreamPriorityRange`. If the specified priority is
    outside the numerical range returned by
    :py:obj:`~.cuCtxGetStreamPriorityRange`, it will automatically be
    clamped to the lowest or the highest number in the range.

    Parameters
    ----------
    flags : unsigned int
        Flags for stream creation. See :py:obj:`~.cuStreamCreate` for a
        list of valid flags
    priority : int
        Stream priority. Lower numbers represent higher priorities. See
        :py:obj:`~.cuCtxGetStreamPriorityRange` for more information about
        meaningful stream priorities that can be passed.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    phStream : :py:obj:`~.CUstream`
        Returned newly created stream

    See Also
    --------
    :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuGreenCtxStreamCreate`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuCtxGetStreamPriorityRange`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cuStreamGetDevice`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamCreateWithPriority`

    Notes
    -----
    Stream priorities are supported only on GPUs with compute capability 3.5 or higher.

    In the current implementation, only compute kernels launched in priority streams are affected by the stream's priority. Stream priorities have no effect on host-to-device and device-to-host memory operations.
    """
    cdef CUstream phStream = CUstream()
    with nogil:
        err = cydriver.cuStreamCreateWithPriority(<cydriver.CUstream*>phStream._pvt_ptr, flags, priority)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phStream)
{{endif}}

{{if 'cuStreamGetPriority' in found_functions}}

@cython.embedsignature(True)
def cuStreamGetPriority(hStream):
    """ Query the priority of a given stream.

    Query the priority of a stream created using
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamCreateWithPriority` or
    :py:obj:`~.cuGreenCtxStreamCreate` and return the priority in
    `priority`. Note that if the stream was created with a priority outside
    the numerical range returned by
    :py:obj:`~.cuCtxGetStreamPriorityRange`, this function returns the
    clamped priority. See :py:obj:`~.cuStreamCreateWithPriority` for
    details about priority clamping.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Handle to the stream to be queried

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    priority : int
        Pointer to a signed integer in which the stream's priority is
        returned

    See Also
    --------
    :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamCreateWithPriority`, :py:obj:`~.cuGreenCtxStreamCreate`, :py:obj:`~.cuCtxGetStreamPriorityRange`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cuStreamGetDevice`, :py:obj:`~.cudaStreamGetPriority`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef int priority = 0
    with nogil:
        err = cydriver.cuStreamGetPriority(cyhStream, &priority)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], priority)
{{endif}}

{{if 'cuStreamGetDevice' in found_functions}}

@cython.embedsignature(True)
def cuStreamGetDevice(hStream):
    """ Returns the device handle of the stream.

    Returns in `*device` the device handle of the stream

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Handle to the stream to be queried

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    device : :py:obj:`~.CUdevice`
        Returns the device to which a stream belongs

    See Also
    --------
    :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuGreenCtxStreamCreate`, :py:obj:`~.cuStreamGetFlags`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef CUdevice device = CUdevice()
    with nogil:
        err = cydriver.cuStreamGetDevice(cyhStream, <cydriver.CUdevice*>device._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], device)
{{endif}}

{{if 'cuStreamGetFlags' in found_functions}}

@cython.embedsignature(True)
def cuStreamGetFlags(hStream):
    """ Query the flags of a given stream.

    Query the flags of a stream created using :py:obj:`~.cuStreamCreate`,
    :py:obj:`~.cuStreamCreateWithPriority` or
    :py:obj:`~.cuGreenCtxStreamCreate` and return the flags in `flags`.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Handle to the stream to be queried

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    flags : unsigned int
        Pointer to an unsigned integer in which the stream's flags are
        returned The value returned in `flags` is a logical 'OR' of all
        flags that were used while creating this stream. See
        :py:obj:`~.cuStreamCreate` for the list of valid flags

    See Also
    --------
    :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuGreenCtxStreamCreate`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cudaStreamGetFlags`, :py:obj:`~.cuStreamGetDevice`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef unsigned int flags = 0
    with nogil:
        err = cydriver.cuStreamGetFlags(cyhStream, &flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], flags)
{{endif}}

{{if 'cuStreamGetId' in found_functions}}

@cython.embedsignature(True)
def cuStreamGetId(hStream):
    """ Returns the unique Id associated with the stream handle supplied.

    Returns in `streamId` the unique Id which is associated with the given
    stream handle. The Id is unique for the life of the program.

    The stream handle `hStream` can refer to any of the following:

    - a stream created via any of the CUDA driver APIs such as
      :py:obj:`~.cuStreamCreate` and
      :py:obj:`~.cuStreamCreateWithPriority`, or their runtime API
      equivalents such as :py:obj:`~.cudaStreamCreate`,
      :py:obj:`~.cudaStreamCreateWithFlags` and
      :py:obj:`~.cudaStreamCreateWithPriority`. Passing an invalid handle
      will result in undefined behavior.

    - any of the special streams such as the NULL stream,
      :py:obj:`~.CU_STREAM_LEGACY` and :py:obj:`~.CU_STREAM_PER_THREAD`.
      The runtime API equivalents of these are also accepted, which are
      NULL, :py:obj:`~.cudaStreamLegacy` and
      :py:obj:`~.cudaStreamPerThread` respectively.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Handle to the stream to be queried

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    streamId : unsigned long long
        Pointer to store the Id of the stream

    See Also
    --------
    :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cudaStreamGetId`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef unsigned long long streamId = 0
    with nogil:
        err = cydriver.cuStreamGetId(cyhStream, &streamId)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], streamId)
{{endif}}

{{if 'cuStreamGetCtx' in found_functions}}

@cython.embedsignature(True)
def cuStreamGetCtx(hStream):
    """ Query the context associated with a stream.

    Returns the CUDA context that the stream is associated with.

    If the stream was created via the API
    :py:obj:`~.cuGreenCtxStreamCreate`, the returned context is equivalent
    to the one returned by :py:obj:`~.cuCtxFromGreenCtx()` on the green
    context associated with the stream at creation time.

    The stream handle `hStream` can refer to any of the following:

    - a stream created via any of the CUDA driver APIs such as
      :py:obj:`~.cuStreamCreate` and
      :py:obj:`~.cuStreamCreateWithPriority`, or their runtime API
      equivalents such as :py:obj:`~.cudaStreamCreate`,
      :py:obj:`~.cudaStreamCreateWithFlags` and
      :py:obj:`~.cudaStreamCreateWithPriority`. The returned context is the
      context that was active in the calling thread when the stream was
      created. Passing an invalid handle will result in undefined behavior.

    - any of the special streams such as the NULL stream,
      :py:obj:`~.CU_STREAM_LEGACY` and :py:obj:`~.CU_STREAM_PER_THREAD`.
      The runtime API equivalents of these are also accepted, which are
      NULL, :py:obj:`~.cudaStreamLegacy` and
      :py:obj:`~.cudaStreamPerThread` respectively. Specifying any of the
      special handles will return the context current to the calling
      thread. If no context is current to the calling thread,
      :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` is returned.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Handle to the stream to be queried

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    pctx : :py:obj:`~.CUcontext`
        Returned context associated with the stream

    See Also
    --------
    :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreateWithPriority`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cuStreamGetDevice` :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithFlags`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef CUcontext pctx = CUcontext()
    with nogil:
        err = cydriver.cuStreamGetCtx(cyhStream, <cydriver.CUcontext*>pctx._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pctx)
{{endif}}

{{if 'cuStreamGetCtx_v2' in found_functions}}

@cython.embedsignature(True)
def cuStreamGetCtx_v2(hStream):
    """ Query the contexts associated with a stream.

    Returns the contexts that the stream is associated with.

    If the stream is associated with a green context, the API returns the
    green context in `pGreenCtx` and the primary context of the associated
    device in `pCtx`.

    If the stream is associated with a regular context, the API returns the
    regular context in `pCtx` and NULL in `pGreenCtx`.

    The stream handle `hStream` can refer to any of the following:

    - a stream created via any of the CUDA driver APIs such as
      :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamCreateWithPriority`
      and :py:obj:`~.cuGreenCtxStreamCreate`, or their runtime API
      equivalents such as :py:obj:`~.cudaStreamCreate`,
      :py:obj:`~.cudaStreamCreateWithFlags` and
      :py:obj:`~.cudaStreamCreateWithPriority`. Passing an invalid handle
      will result in undefined behavior.

    - any of the special streams such as the NULL stream,
      :py:obj:`~.CU_STREAM_LEGACY` and :py:obj:`~.CU_STREAM_PER_THREAD`.
      The runtime API equivalents of these are also accepted, which are
      NULL, :py:obj:`~.cudaStreamLegacy` and
      :py:obj:`~.cudaStreamPerThread` respectively. If any of the special
      handles are specified, the API will operate on the context current to
      the calling thread. If a green context (that was converted via
      :py:obj:`~.cuCtxFromGreenCtx()` before setting it current) is current
      to the calling thread, the API will return the green context in
      `pGreenCtx` and the primary context of the associated device in
      `pCtx`. If a regular context is current, the API returns the regular
      context in `pCtx` and NULL in `pGreenCtx`. Note that specifying
      :py:obj:`~.CU_STREAM_PER_THREAD` or :py:obj:`~.cudaStreamPerThread`
      will return :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` if a green context
      is current to the calling thread. If no context is current to the
      calling thread, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` is returned.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Handle to the stream to be queried

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    pCtx : :py:obj:`~.CUcontext`
        Returned regular context associated with the stream
    pGreenCtx : :py:obj:`~.CUgreenCtx`
        Returned green context if the stream is associated with a green
        context or NULL if not

    See Also
    --------
    :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreate` :py:obj:`~.cuStreamCreateWithPriority`, :py:obj:`~.cuGreenCtxStreamCreate`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cuStreamGetDevice`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithFlags`,
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef CUcontext pCtx = CUcontext()
    cdef CUgreenCtx pGreenCtx = CUgreenCtx()
    with nogil:
        err = cydriver.cuStreamGetCtx_v2(cyhStream, <cydriver.CUcontext*>pCtx._pvt_ptr, <cydriver.CUgreenCtx*>pGreenCtx._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], pCtx, pGreenCtx)
{{endif}}

{{if 'cuStreamWaitEvent' in found_functions}}

@cython.embedsignature(True)
def cuStreamWaitEvent(hStream, hEvent, unsigned int Flags):
    """ Make a compute stream wait on an event.

    Makes all future work submitted to `hStream` wait for all work captured
    in `hEvent`. See :py:obj:`~.cuEventRecord()` for details on what is
    captured by an event. The synchronization will be performed efficiently
    on the device when applicable. `hEvent` may be from a different context
    or device than `hStream`.

    flags include:

    - :py:obj:`~.CU_EVENT_WAIT_DEFAULT`: Default event creation flag.

    - :py:obj:`~.CU_EVENT_WAIT_EXTERNAL`: Event is captured in the graph as
      an external event node when performing stream capture. This flag is
      invalid outside of stream capture.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to wait
    hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to wait on (may not be NULL)
    Flags : unsigned int
        See :py:obj:`~.CUevent_capture_flags`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`,

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cudaStreamWaitEvent`
    """
    cdef cydriver.CUevent cyhEvent
    if hEvent is None:
        phEvent = 0
    elif isinstance(hEvent, (CUevent,)):
        phEvent = int(hEvent)
    else:
        phEvent = int(CUevent(hEvent))
    cyhEvent = <cydriver.CUevent><void_ptr>phEvent
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    with nogil:
        err = cydriver.cuStreamWaitEvent(cyhStream, cyhEvent, Flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuStreamAddCallback' in found_functions}}

ctypedef struct cuStreamCallbackData_st:
    cydriver.CUstreamCallback callback
    void *userData

ctypedef cuStreamCallbackData_st cuStreamCallbackData

@cython.show_performance_hints(False)
cdef void cuStreamCallbackWrapper(cydriver.CUstream stream, cydriver.CUresult status, void *data) nogil:
    cdef cuStreamCallbackData *cbData = <cuStreamCallbackData *>data
    with gil:
        cbData.callback(stream, status, cbData.userData)
    free(cbData)

@cython.embedsignature(True)
def cuStreamAddCallback(hStream, callback, userData, unsigned int flags):
    """ Add a callback to a compute stream.

    Adds a callback to be called on the host after all currently enqueued
    items in the stream have completed. For each cuStreamAddCallback call,
    the callback will be executed exactly once. The callback will block
    later work in the stream until it is finished.

    The callback may be passed :py:obj:`~.CUDA_SUCCESS` or an error code.
    In the event of a device error, all subsequently executed callbacks
    will receive an appropriate :py:obj:`~.CUresult`.

    Callbacks must not make any CUDA API calls. Attempting to use a CUDA
    API will result in :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`. Callbacks must
    not perform any synchronization that may depend on outstanding device
    work or other callbacks that are not mandated to run earlier. Callbacks
    without a mandated order (in independent streams) execute in undefined
    order and may be serialized.

    For the purposes of Unified Memory, callback execution makes a number
    of guarantees:

    - The callback stream is considered idle for the duration of the
      callback. Thus, for example, a callback may always use memory
      attached to the callback stream.

    - The start of execution of a callback has the same effect as
      synchronizing an event recorded in the same stream immediately prior
      to the callback. It thus synchronizes streams which have been
      "joined" prior to the callback.

    - Adding device work to any stream does not have the effect of making
      the stream active until all preceding host functions and stream
      callbacks have executed. Thus, for example, a callback might use
      global attached memory even if work has been added to another stream,
      if the work has been ordered behind the callback with an event.

    - Completion of a callback does not cause a stream to become active
      except as described above. The callback stream will remain idle if no
      device work follows the callback, and will remain idle across
      consecutive callbacks without device work in between. Thus, for
      example, stream synchronization can be done by signaling from a
      callback at the end of the stream.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to add callback to
    callback : :py:obj:`~.CUstreamCallback`
        The function to call once preceding stream operations are complete
    userData : Any
        User specified data to be passed to the callback function
    flags : unsigned int
        Reserved for future use, must be 0

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuMemAllocManaged`, :py:obj:`~.cuStreamAttachMemAsync`, :py:obj:`~.cuLaunchHostFunc`, :py:obj:`~.cudaStreamAddCallback`

    Notes
    -----
    This function is slated for eventual deprecation and removal. If you do not require the callback to execute in case of a device error, consider using :py:obj:`~.cuLaunchHostFunc`. Additionally, this function is not supported with :py:obj:`~.cuStreamBeginCapture` and :py:obj:`~.cuStreamEndCapture`, unlike :py:obj:`~.cuLaunchHostFunc`.
    """
    cdef cydriver.CUstreamCallback cycallback
    if callback is None:
        pcallback = 0
    elif isinstance(callback, (CUstreamCallback,)):
        pcallback = int(callback)
    else:
        pcallback = int(CUstreamCallback(callback))
    cycallback = <cydriver.CUstreamCallback><void_ptr>pcallback
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cyuserData = _HelperInputVoidPtr(userData)
    cdef void* cyuserData_ptr = <void*><void_ptr>cyuserData.cptr

    cdef cuStreamCallbackData *cbData = NULL
    cbData = <cuStreamCallbackData *>malloc(sizeof(cbData[0]))
    if cbData == NULL:
        return (CUresult.CUDA_ERROR_OUT_OF_MEMORY,)
    cbData.callback = cycallback
    cbData.userData = cyuserData_ptr

    with nogil:
        err = cydriver.cuStreamAddCallback(cyhStream, <cydriver.CUstreamCallback>cuStreamCallbackWrapper, <void *>cbData, flags)
    if err != cydriver.CUDA_SUCCESS:
        free(cbData)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuStreamBeginCapture_v2' in found_functions}}

@cython.embedsignature(True)
def cuStreamBeginCapture(hStream, mode not None : CUstreamCaptureMode):
    """ Begins graph capture on a stream.

    Begin graph capture on `hStream`. When a stream is in capture mode, all
    operations pushed into the stream will not be executed, but will
    instead be captured into a graph, which will be returned via
    :py:obj:`~.cuStreamEndCapture`. Capture may not be initiated if
    `stream` is CU_STREAM_LEGACY. Capture must be ended on the same stream
    in which it was initiated, and it may only be initiated if the stream
    is not already in capture mode. The capture mode may be queried via
    :py:obj:`~.cuStreamIsCapturing`. A unique id representing the capture
    sequence may be queried via :py:obj:`~.cuStreamGetCaptureInfo`.

    If `mode` is not :py:obj:`~.CU_STREAM_CAPTURE_MODE_RELAXED`,
    :py:obj:`~.cuStreamEndCapture` must be called on this stream from the
    same thread.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream in which to initiate capture
    mode : :py:obj:`~.CUstreamCaptureMode`
        Controls the interaction of this capture sequence with other API
        calls that are potentially unsafe. For more details see
        :py:obj:`~.cuThreadExchangeStreamCaptureMode`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamIsCapturing`, :py:obj:`~.cuStreamEndCapture`, :py:obj:`~.cuThreadExchangeStreamCaptureMode`

    Notes
    -----
    Kernels captured using this API must not use texture and surface references. Reading or writing through any texture or surface reference is undefined behavior. This restriction does not apply to texture and surface objects.
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUstreamCaptureMode cymode = mode.value
    with nogil:
        err = cydriver.cuStreamBeginCapture(cyhStream, cymode)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuStreamBeginCaptureToGraph' in found_functions}}

@cython.embedsignature(True)
def cuStreamBeginCaptureToGraph(hStream, hGraph, dependencies : Optional[tuple[CUgraphNode] | list[CUgraphNode]], dependencyData : Optional[tuple[CUgraphEdgeData] | list[CUgraphEdgeData]], size_t numDependencies, mode not None : CUstreamCaptureMode):
    """ Begins graph capture on a stream to an existing graph.

    Begin graph capture on `hStream`, placing new nodes into an existing
    graph. When a stream is in capture mode, all operations pushed into the
    stream will not be executed, but will instead be captured into
    `hGraph`. The graph will not be instantiable until the user calls
    :py:obj:`~.cuStreamEndCapture`.

    Capture may not be initiated if `stream` is CU_STREAM_LEGACY. Capture
    must be ended on the same stream in which it was initiated, and it may
    only be initiated if the stream is not already in capture mode. The
    capture mode may be queried via :py:obj:`~.cuStreamIsCapturing`. A
    unique id representing the capture sequence may be queried via
    :py:obj:`~.cuStreamGetCaptureInfo`.

    If `mode` is not :py:obj:`~.CU_STREAM_CAPTURE_MODE_RELAXED`,
    :py:obj:`~.cuStreamEndCapture` must be called on this stream from the
    same thread.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream in which to initiate capture.
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to capture into.
    dependencies : list[:py:obj:`~.CUgraphNode`]
        Dependencies of the first node captured in the stream. Can be NULL
        if numDependencies is 0.
    dependencyData : list[:py:obj:`~.CUgraphEdgeData`]
        Optional array of data associated with each dependency.
    numDependencies : size_t
        Number of dependencies.
    mode : :py:obj:`~.CUstreamCaptureMode`
        Controls the interaction of this capture sequence with other API
        calls that are potentially unsafe. For more details see
        :py:obj:`~.cuThreadExchangeStreamCaptureMode`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuStreamBeginCapture`, :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamIsCapturing`, :py:obj:`~.cuStreamEndCapture`, :py:obj:`~.cuThreadExchangeStreamCaptureMode`, :py:obj:`~.cuGraphAddNode`

    Notes
    -----
    Kernels captured using this API must not use texture and surface references. Reading or writing through any texture or surface reference is undefined behavior. This restriction does not apply to texture and surface objects.
    """
    dependencyData = [] if dependencyData is None else dependencyData
    if not all(isinstance(_x, (CUgraphEdgeData,)) for _x in dependencyData):
        raise TypeError("Argument 'dependencyData' is not instance of type (expected tuple[cydriver.CUgraphEdgeData,] or list[cydriver.CUgraphEdgeData,]")
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode,)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUgraphNode* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cydriver.CUgraphNode*> calloc(len(dependencies), sizeof(cydriver.CUgraphNode))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cydriver.CUgraphNode>(<CUgraphNode>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cydriver.CUgraphNode*>(<CUgraphNode>dependencies[0])._pvt_ptr
    cdef cydriver.CUgraphEdgeData* cydependencyData = NULL
    if len(dependencyData) > 1:
        cydependencyData = <cydriver.CUgraphEdgeData*> calloc(len(dependencyData), sizeof(cydriver.CUgraphEdgeData))
        if cydependencyData is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencyData)) + 'x' + str(sizeof(cydriver.CUgraphEdgeData)))
        for idx in range(len(dependencyData)):
            string.memcpy(&cydependencyData[idx], (<CUgraphEdgeData>dependencyData[idx])._pvt_ptr, sizeof(cydriver.CUgraphEdgeData))
    elif len(dependencyData) == 1:
        cydependencyData = (<CUgraphEdgeData>dependencyData[0])._pvt_ptr
    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    if numDependencies > <size_t>len(dependencyData): raise RuntimeError("List is too small: " + str(len(dependencyData)) + " < " + str(numDependencies))
    cdef cydriver.CUstreamCaptureMode cymode = mode.value
    with nogil:
        err = cydriver.cuStreamBeginCaptureToGraph(cyhStream, cyhGraph, cydependencies, cydependencyData, numDependencies, cymode)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if len(dependencyData) > 1 and cydependencyData is not NULL:
        free(cydependencyData)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuThreadExchangeStreamCaptureMode' in found_functions}}

@cython.embedsignature(True)
def cuThreadExchangeStreamCaptureMode(mode not None : CUstreamCaptureMode):
    """ Swaps the stream capture interaction mode for a thread.

    Sets the calling thread's stream capture interaction mode to the value
    contained in `*mode`, and overwrites `*mode` with the previous mode for
    the thread. To facilitate deterministic behavior across function or
    module boundaries, callers are encouraged to use this API in a push-pop
    fashion:

    **View CUDA Toolkit Documentation for a C++ code example**

    During stream capture (see :py:obj:`~.cuStreamBeginCapture`), some
    actions, such as a call to :py:obj:`~.cudaMalloc`, may be unsafe. In
    the case of :py:obj:`~.cudaMalloc`, the operation is not enqueued
    asynchronously to a stream, and is not observed by stream capture.
    Therefore, if the sequence of operations captured via
    :py:obj:`~.cuStreamBeginCapture` depended on the allocation being
    replayed whenever the graph is launched, the captured graph would be
    invalid.

    Therefore, stream capture places restrictions on API calls that can be
    made within or concurrently to a
    :py:obj:`~.cuStreamBeginCapture`-:py:obj:`~.cuStreamEndCapture`
    sequence. This behavior can be controlled via this API and flags to
    :py:obj:`~.cuStreamBeginCapture`.

    A thread's mode is one of the following:

    - `CU_STREAM_CAPTURE_MODE_GLOBAL:` This is the default mode. If the
      local thread has an ongoing capture sequence that was not initiated
      with `CU_STREAM_CAPTURE_MODE_RELAXED` at `cuStreamBeginCapture`, or
      if any other thread has a concurrent capture sequence initiated with
      `CU_STREAM_CAPTURE_MODE_GLOBAL`, this thread is prohibited from
      potentially unsafe API calls.

    - `CU_STREAM_CAPTURE_MODE_THREAD_LOCAL:` If the local thread has an
      ongoing capture sequence not initiated with
      `CU_STREAM_CAPTURE_MODE_RELAXED`, it is prohibited from potentially
      unsafe API calls. Concurrent capture sequences in other threads are
      ignored.

    - `CU_STREAM_CAPTURE_MODE_RELAXED:` The local thread is not prohibited
      from potentially unsafe API calls. Note that the thread is still
      prohibited from API calls which necessarily conflict with stream
      capture, for example, attempting :py:obj:`~.cuEventQuery` on an event
      that was last recorded inside a capture sequence.

    Parameters
    ----------
    mode : :py:obj:`~.CUstreamCaptureMode`
        Pointer to mode value to swap with the current mode

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    mode : :py:obj:`~.CUstreamCaptureMode`
        Pointer to mode value to swap with the current mode

    See Also
    --------
    :py:obj:`~.cuStreamBeginCapture`
    """
    cdef cydriver.CUstreamCaptureMode cymode = mode.value
    with nogil:
        err = cydriver.cuThreadExchangeStreamCaptureMode(&cymode)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], CUstreamCaptureMode(cymode))
{{endif}}

{{if 'cuStreamEndCapture' in found_functions}}

@cython.embedsignature(True)
def cuStreamEndCapture(hStream):
    """ Ends capture on a stream, returning the captured graph.

    End capture on `hStream`, returning the captured graph via `phGraph`.
    Capture must have been initiated on `hStream` via a call to
    :py:obj:`~.cuStreamBeginCapture`. If capture was invalidated, due to a
    violation of the rules of stream capture, then a NULL graph will be
    returned.

    If the `mode` argument to :py:obj:`~.cuStreamBeginCapture` was not
    :py:obj:`~.CU_STREAM_CAPTURE_MODE_RELAXED`, this call must be from the
    same thread as :py:obj:`~.cuStreamBeginCapture`.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD`
    phGraph : :py:obj:`~.CUgraph`
        The captured graph

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamBeginCapture`, :py:obj:`~.cuStreamIsCapturing`, :py:obj:`~.cuGraphDestroy`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef CUgraph phGraph = CUgraph()
    with nogil:
        err = cydriver.cuStreamEndCapture(cyhStream, <cydriver.CUgraph*>phGraph._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraph)
{{endif}}

{{if 'cuStreamIsCapturing' in found_functions}}

@cython.embedsignature(True)
def cuStreamIsCapturing(hStream):
    """ Returns a stream's capture status.

    Return the capture status of `hStream` via `captureStatus`. After a
    successful call, `*captureStatus` will contain one of the following:

    - :py:obj:`~.CU_STREAM_CAPTURE_STATUS_NONE`: The stream is not
      capturing.

    - :py:obj:`~.CU_STREAM_CAPTURE_STATUS_ACTIVE`: The stream is capturing.

    - :py:obj:`~.CU_STREAM_CAPTURE_STATUS_INVALIDATED`: The stream was
      capturing but an error has invalidated the capture sequence. The
      capture sequence must be terminated with
      :py:obj:`~.cuStreamEndCapture` on the stream where it was initiated
      in order to continue using `hStream`.

    Note that, if this is called on :py:obj:`~.CU_STREAM_LEGACY` (the "null
    stream") while a blocking stream in the same context is capturing, it
    will return :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT` and
    `*captureStatus` is unspecified after the call. The blocking stream
    capture is not invalidated.

    When a blocking stream is capturing, the legacy stream is in an
    unusable state until the blocking stream capture is terminated. The
    legacy stream is not supported for stream capture, but attempted use
    would have an implicit dependency on the capturing stream(s).

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT`
    captureStatus : :py:obj:`~.CUstreamCaptureStatus`
        Returns the stream's capture status

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamBeginCapture`, :py:obj:`~.cuStreamEndCapture`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUstreamCaptureStatus captureStatus
    with nogil:
        err = cydriver.cuStreamIsCapturing(cyhStream, &captureStatus)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], CUstreamCaptureStatus(captureStatus))
{{endif}}

{{if 'cuStreamGetCaptureInfo_v3' in found_functions}}

@cython.embedsignature(True)
def cuStreamGetCaptureInfo(hStream):
    """ Query a stream's capture state.

    Query stream state related to stream capture.

    If called on :py:obj:`~.CU_STREAM_LEGACY` (the "null stream") while a
    stream not created with :py:obj:`~.CU_STREAM_NON_BLOCKING` is
    capturing, returns :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT`.

    Valid data (other than capture status) is returned only if both of the
    following are true:

    - the call returns CUDA_SUCCESS

    - the returned capture status is
      :py:obj:`~.CU_STREAM_CAPTURE_STATUS_ACTIVE`

    If `edgeData_out` is non-NULL then `dependencies_out` must be as well.
    If `dependencies_out` is non-NULL and `edgeData_out` is NULL, but there
    is non-zero edge data for one or more of the current stream
    dependencies, the call will return :py:obj:`~.CUDA_ERROR_LOSSY_QUERY`.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT`, :py:obj:`~.CUDA_ERROR_LOSSY_QUERY`
    captureStatus_out : :py:obj:`~.CUstreamCaptureStatus`
        Location to return the capture status of the stream; required
    id_out : :py:obj:`~.cuuint64_t`
        Optional location to return an id for the capture sequence, which
        is unique over the lifetime of the process
    graph_out : :py:obj:`~.CUgraph`
        Optional location to return the graph being captured into. All
        operations other than destroy and node removal are permitted on the
        graph while the capture sequence is in progress. This API does not
        transfer ownership of the graph, which is transferred or destroyed
        at :py:obj:`~.cuStreamEndCapture`. Note that the graph handle may
        be invalidated before end of capture for certain errors. Nodes that
        are or become unreachable from the original stream at
        :py:obj:`~.cuStreamEndCapture` due to direct actions on the graph
        do not trigger :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNJOINED`.
    dependencies_out : list[:py:obj:`~.CUgraphNode`]
        Optional location to store a pointer to an array of nodes. The next
        node to be captured in the stream will depend on this set of nodes,
        absent operations such as event wait which modify this set. The
        array pointer is valid until the next API call which operates on
        the stream or until the capture is terminated. The node handles may
        be copied out and are valid until they or the graph is destroyed.
        The driver-owned array may also be passed directly to APIs that
        operate on the graph (not the stream) without copying.
    edgeData_out : list[:py:obj:`~.CUgraphEdgeData`]
        Optional location to store a pointer to an array of graph edge
        data. This array parallels `dependencies_out`; the next node to be
        added has an edge to `dependencies_out`[i] with annotation
        `edgeData_out`[i] for each `i`. The array pointer is valid until
        the next API call which operates on the stream or until the capture
        is terminated.
    numDependencies_out : int
        Optional location to store the size of the array returned in
        dependencies_out.

    See Also
    --------
    :py:obj:`~.cuStreamBeginCapture`, :py:obj:`~.cuStreamIsCapturing`, :py:obj:`~.cuStreamUpdateCaptureDependencies`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUstreamCaptureStatus captureStatus_out
    cdef cuuint64_t id_out = cuuint64_t()
    cdef CUgraph graph_out = CUgraph()
    cdef const cydriver.CUgraphNode* cydependencies_out = NULL
    pydependencies_out = []
    cdef const cydriver.CUgraphEdgeData* cyedgeData_out = NULL
    pyedgeData_out = []
    cdef size_t numDependencies_out = 0
    with nogil:
        err = cydriver.cuStreamGetCaptureInfo(cyhStream, &captureStatus_out, <cydriver.cuuint64_t*>id_out._pvt_ptr, <cydriver.CUgraph*>graph_out._pvt_ptr, &cydependencies_out, &cyedgeData_out, &numDependencies_out)
    if CUresult(err) == CUresult(0):
        pydependencies_out = [CUgraphNode(init_value=<void_ptr>cydependencies_out[idx]) for idx in range(numDependencies_out)]
    if CUresult(err) == CUresult(0):
        pyedgeData_out = [CUgraphEdgeData(_ptr=<void_ptr>&cyedgeData_out[idx]) for idx in range(numDependencies_out)]
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None, None, None, None, None)
    return (_dict_CUresult[err], CUstreamCaptureStatus(captureStatus_out), id_out, graph_out, pydependencies_out, pyedgeData_out, numDependencies_out)
{{endif}}

{{if 'cuStreamUpdateCaptureDependencies_v2' in found_functions}}

@cython.embedsignature(True)
def cuStreamUpdateCaptureDependencies(hStream, dependencies : Optional[tuple[CUgraphNode] | list[CUgraphNode]], dependencyData : Optional[tuple[CUgraphEdgeData] | list[CUgraphEdgeData]], size_t numDependencies, unsigned int flags):
    """ Update the set of dependencies in a capturing stream.

    Modifies the dependency set of a capturing stream. The dependency set
    is the set of nodes that the next captured node in the stream will
    depend on along with the edge data for those dependencies.

    Valid flags are :py:obj:`~.CU_STREAM_ADD_CAPTURE_DEPENDENCIES` and
    :py:obj:`~.CU_STREAM_SET_CAPTURE_DEPENDENCIES`. These control whether
    the set passed to the API is added to the existing set or replaces it.
    A flags value of 0 defaults to
    :py:obj:`~.CU_STREAM_ADD_CAPTURE_DEPENDENCIES`.

    Nodes that are removed from the dependency set via this API do not
    result in :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNJOINED` if they are
    unreachable from the stream at :py:obj:`~.cuStreamEndCapture`.

    Returns :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE` if the stream is not
    capturing.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to update
    dependencies : list[:py:obj:`~.CUgraphNode`]
        The set of dependencies to add
    dependencyData : list[:py:obj:`~.CUgraphEdgeData`]
        Optional array of data associated with each dependency.
    numDependencies : size_t
        The size of the dependencies array
    flags : unsigned int
        See above

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE`

    See Also
    --------
    :py:obj:`~.cuStreamBeginCapture`, :py:obj:`~.cuStreamGetCaptureInfo`
    """
    dependencyData = [] if dependencyData is None else dependencyData
    if not all(isinstance(_x, (CUgraphEdgeData,)) for _x in dependencyData):
        raise TypeError("Argument 'dependencyData' is not instance of type (expected tuple[cydriver.CUgraphEdgeData,] or list[cydriver.CUgraphEdgeData,]")
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode,)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUgraphNode* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cydriver.CUgraphNode*> calloc(len(dependencies), sizeof(cydriver.CUgraphNode))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cydriver.CUgraphNode>(<CUgraphNode>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cydriver.CUgraphNode*>(<CUgraphNode>dependencies[0])._pvt_ptr
    cdef cydriver.CUgraphEdgeData* cydependencyData = NULL
    if len(dependencyData) > 1:
        cydependencyData = <cydriver.CUgraphEdgeData*> calloc(len(dependencyData), sizeof(cydriver.CUgraphEdgeData))
        if cydependencyData is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencyData)) + 'x' + str(sizeof(cydriver.CUgraphEdgeData)))
        for idx in range(len(dependencyData)):
            string.memcpy(&cydependencyData[idx], (<CUgraphEdgeData>dependencyData[idx])._pvt_ptr, sizeof(cydriver.CUgraphEdgeData))
    elif len(dependencyData) == 1:
        cydependencyData = (<CUgraphEdgeData>dependencyData[0])._pvt_ptr
    with nogil:
        err = cydriver.cuStreamUpdateCaptureDependencies(cyhStream, cydependencies, cydependencyData, numDependencies, flags)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if len(dependencyData) > 1 and cydependencyData is not NULL:
        free(cydependencyData)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuStreamAttachMemAsync' in found_functions}}

@cython.embedsignature(True)
def cuStreamAttachMemAsync(hStream, dptr, size_t length, unsigned int flags):
    """ Attach memory to a stream asynchronously.

    Enqueues an operation in `hStream` to specify stream association of
    `length` bytes of memory starting from `dptr`. This function is a
    stream-ordered operation, meaning that it is dependent on, and will
    only take effect when, previous work in stream has completed. Any
    previous association is automatically replaced.

    `dptr` must point to one of the following types of memories:

    - managed memory declared using the managed keyword or allocated with
      :py:obj:`~.cuMemAllocManaged`.

    - a valid host-accessible region of system-allocated pageable memory.
      This type of memory may only be specified if the device associated
      with the stream reports a non-zero value for the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`.

    For managed allocations, `length` must be either zero or the entire
    allocation's size. Both indicate that the entire allocation's stream
    association is being changed. Currently, it is not possible to change
    stream association for a portion of a managed allocation.

    For pageable host allocations, `length` must be non-zero.

    The stream association is specified using `flags` which must be one of
    :py:obj:`~.CUmemAttach_flags`. If the :py:obj:`~.CU_MEM_ATTACH_GLOBAL`
    flag is specified, the memory can be accessed by any stream on any
    device. If the :py:obj:`~.CU_MEM_ATTACH_HOST` flag is specified, the
    program makes a guarantee that it won't access the memory on the device
    from any stream on a device that has a zero value for the device
    attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. If
    the :py:obj:`~.CU_MEM_ATTACH_SINGLE` flag is specified and `hStream` is
    associated with a device that has a zero value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`, the program
    makes a guarantee that it will only access the memory on the device
    from `hStream`. It is illegal to attach singly to the NULL stream,
    because the NULL stream is a virtual global stream and not a specific
    stream. An error will be returned in this case.

    When memory is associated with a single stream, the Unified Memory
    system will allow CPU access to this memory region so long as all
    operations in `hStream` have completed, regardless of whether other
    streams are active. In effect, this constrains exclusive ownership of
    the managed memory region by an active GPU to per-stream activity
    instead of whole-GPU activity.

    Accessing memory on the device from streams that are not associated
    with it will produce undefined results. No error checking is performed
    by the Unified Memory system to ensure that kernels launched into other
    streams do not access this region.

    It is a program's responsibility to order calls to
    :py:obj:`~.cuStreamAttachMemAsync` via events, synchronization or other
    means to ensure legal access to memory at all times. Data visibility
    and coherency will be changed appropriately for all kernels which
    follow a stream-association change.

    If `hStream` is destroyed while data is associated with it, the
    association is removed and the association reverts to the default
    visibility of the allocation as specified at
    :py:obj:`~.cuMemAllocManaged`. For managed variables, the default
    association is always :py:obj:`~.CU_MEM_ATTACH_GLOBAL`. Note that
    destroying a stream is an asynchronous operation, and as a result, the
    change to default association won't happen until all work in the stream
    has completed.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream in which to enqueue the attach operation
    dptr : :py:obj:`~.CUdeviceptr`
        Pointer to memory (must be a pointer to managed memory or to a
        valid host-accessible region of system-allocated pageable memory)
    length : size_t
        Length of memory
    flags : unsigned int
        Must be one of :py:obj:`~.CUmemAttach_flags`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuMemAllocManaged`, :py:obj:`~.cudaStreamAttachMemAsync`
    """
    cdef cydriver.CUdeviceptr cydptr
    if dptr is None:
        pdptr = 0
    elif isinstance(dptr, (CUdeviceptr,)):
        pdptr = int(dptr)
    else:
        pdptr = int(CUdeviceptr(dptr))
    cydptr = <cydriver.CUdeviceptr><void_ptr>pdptr
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    with nogil:
        err = cydriver.cuStreamAttachMemAsync(cyhStream, cydptr, length, flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuStreamQuery' in found_functions}}

@cython.embedsignature(True)
def cuStreamQuery(hStream):
    """ Determine status of a compute stream.

    Returns :py:obj:`~.CUDA_SUCCESS` if all operations in the stream
    specified by `hStream` have completed, or
    :py:obj:`~.CUDA_ERROR_NOT_READY` if not.

    For the purposes of Unified Memory, a return value of
    :py:obj:`~.CUDA_SUCCESS` is equivalent to having called
    :py:obj:`~.cuStreamSynchronize()`.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to query status of

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_READY`

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamQuery`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    with nogil:
        err = cydriver.cuStreamQuery(cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuStreamSynchronize' in found_functions}}

@cython.embedsignature(True)
def cuStreamSynchronize(hStream):
    """ Wait until a stream's tasks are completed.

    Waits until the device has completed all operations in the stream
    specified by `hStream`. If the context was created with the
    :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC` flag, the CPU thread will block
    until the stream is finished with all of its tasks.

    \note_null_stream

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to wait for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamSynchronize`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    with nogil:
        err = cydriver.cuStreamSynchronize(cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuStreamDestroy_v2' in found_functions}}

@cython.embedsignature(True)
def cuStreamDestroy(hStream):
    """ Destroys a stream.

    Destroys the stream specified by `hStream`.

    In case the device is still doing work in the stream `hStream` when
    :py:obj:`~.cuStreamDestroy()` is called, the function will return
    immediately and the resources associated with `hStream` will be
    released automatically once the device has completed all work in
    `hStream`.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamDestroy`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    with nogil:
        err = cydriver.cuStreamDestroy(cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuStreamCopyAttributes' in found_functions}}

@cython.embedsignature(True)
def cuStreamCopyAttributes(dst, src):
    """ Copies attributes from source stream to destination stream.

    Copies attributes from source stream `src` to destination stream `dst`.
    Both streams must have the same context.

    Parameters
    ----------
    dst : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Destination stream
    src : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Source stream For list of attributes see :py:obj:`~.CUstreamAttrID`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.CUaccessPolicyWindow`
    """
    cdef cydriver.CUstream cysrc
    if src is None:
        psrc = 0
    elif isinstance(src, (CUstream,)):
        psrc = int(src)
    else:
        psrc = int(CUstream(src))
    cysrc = <cydriver.CUstream><void_ptr>psrc
    cdef cydriver.CUstream cydst
    if dst is None:
        pdst = 0
    elif isinstance(dst, (CUstream,)):
        pdst = int(dst)
    else:
        pdst = int(CUstream(dst))
    cydst = <cydriver.CUstream><void_ptr>pdst
    with nogil:
        err = cydriver.cuStreamCopyAttributes(cydst, cysrc)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuStreamGetAttribute' in found_functions}}

@cython.embedsignature(True)
def cuStreamGetAttribute(hStream, attr not None : CUstreamAttrID):
    """ Queries stream attribute.

    Queries attribute `attr` from `hStream` and stores it in corresponding
    member of `value_out`.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`

    attr : :py:obj:`~.CUstreamAttrID`


    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    value_out : :py:obj:`~.CUstreamAttrValue`


    See Also
    --------
    :py:obj:`~.CUaccessPolicyWindow`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUstreamAttrID cyattr = attr.value
    cdef CUstreamAttrValue value_out = CUstreamAttrValue()
    with nogil:
        err = cydriver.cuStreamGetAttribute(cyhStream, cyattr, <cydriver.CUstreamAttrValue*>value_out._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], value_out)
{{endif}}

{{if 'cuStreamSetAttribute' in found_functions}}

@cython.embedsignature(True)
def cuStreamSetAttribute(hStream, attr not None : CUstreamAttrID, value : Optional[CUstreamAttrValue]):
    """ Sets stream attribute.

    Sets attribute `attr` on `hStream` from corresponding attribute of
    `value`. The updated attribute will be applied to subsequent work
    submitted to the stream. It will not affect previously submitted work.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`

    attr : :py:obj:`~.CUstreamAttrID`

    value : :py:obj:`~.CUstreamAttrValue`


    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.CUaccessPolicyWindow`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUstreamAttrID cyattr = attr.value
    cdef cydriver.CUstreamAttrValue* cyvalue_ptr = value._pvt_ptr if value is not None else NULL
    with nogil:
        err = cydriver.cuStreamSetAttribute(cyhStream, cyattr, cyvalue_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuEventCreate' in found_functions}}

@cython.embedsignature(True)
def cuEventCreate(unsigned int Flags):
    """ Creates an event.

    Creates an event *phEvent for the current context with the flags
    specified via `Flags`. Valid flags include:

    - :py:obj:`~.CU_EVENT_DEFAULT`: Default event creation flag.

    - :py:obj:`~.CU_EVENT_BLOCKING_SYNC`: Specifies that the created event
      should use blocking synchronization. A CPU thread that uses
      :py:obj:`~.cuEventSynchronize()` to wait on an event created with
      this flag will block until the event has actually been recorded.

    - :py:obj:`~.CU_EVENT_DISABLE_TIMING`: Specifies that the created event
      does not need to record timing data. Events created with this flag
      specified and the :py:obj:`~.CU_EVENT_BLOCKING_SYNC` flag not
      specified will provide the best performance when used with
      :py:obj:`~.cuStreamWaitEvent()` and :py:obj:`~.cuEventQuery()`.

    - :py:obj:`~.CU_EVENT_INTERPROCESS`: Specifies that the created event
      may be used as an interprocess event by
      :py:obj:`~.cuIpcGetEventHandle()`. :py:obj:`~.CU_EVENT_INTERPROCESS`
      must be specified along with :py:obj:`~.CU_EVENT_DISABLE_TIMING`.

    Parameters
    ----------
    Flags : unsigned int
        Event creation flags

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    phEvent : :py:obj:`~.CUevent`
        Returns newly created event

    See Also
    --------
    :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cudaEventCreate`, :py:obj:`~.cudaEventCreateWithFlags`
    """
    cdef CUevent phEvent = CUevent()
    with nogil:
        err = cydriver.cuEventCreate(<cydriver.CUevent*>phEvent._pvt_ptr, Flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phEvent)
{{endif}}

{{if 'cuEventRecord' in found_functions}}

@cython.embedsignature(True)
def cuEventRecord(hEvent, hStream):
    """ Records an event.

    Captures in `hEvent` the contents of `hStream` at the time of this
    call. `hEvent` and `hStream` must be from the same context otherwise
    :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is returned. Calls such as
    :py:obj:`~.cuEventQuery()` or :py:obj:`~.cuStreamWaitEvent()` will then
    examine or wait for completion of the work that was captured. Uses of
    `hStream` after this call do not modify `hEvent`. See note on default
    stream behavior for what is captured in the default case.

    :py:obj:`~.cuEventRecord()` can be called multiple times on the same
    event and will overwrite the previously captured state. Other APIs such
    as :py:obj:`~.cuStreamWaitEvent()` use the most recently captured state
    at the time of the API call, and are not affected by later calls to
    :py:obj:`~.cuEventRecord()`. Before the first call to
    :py:obj:`~.cuEventRecord()`, an event represents an empty set of work,
    so for example :py:obj:`~.cuEventQuery()` would return
    :py:obj:`~.CUDA_SUCCESS`.

    Parameters
    ----------
    hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to record
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to record event for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cudaEventRecord`, :py:obj:`~.cuEventRecordWithFlags`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUevent cyhEvent
    if hEvent is None:
        phEvent = 0
    elif isinstance(hEvent, (CUevent,)):
        phEvent = int(hEvent)
    else:
        phEvent = int(CUevent(hEvent))
    cyhEvent = <cydriver.CUevent><void_ptr>phEvent
    with nogil:
        err = cydriver.cuEventRecord(cyhEvent, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuEventRecordWithFlags' in found_functions}}

@cython.embedsignature(True)
def cuEventRecordWithFlags(hEvent, hStream, unsigned int flags):
    """ Records an event.

    Captures in `hEvent` the contents of `hStream` at the time of this
    call. `hEvent` and `hStream` must be from the same context otherwise
    :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is returned. Calls such as
    :py:obj:`~.cuEventQuery()` or :py:obj:`~.cuStreamWaitEvent()` will then
    examine or wait for completion of the work that was captured. Uses of
    `hStream` after this call do not modify `hEvent`. See note on default
    stream behavior for what is captured in the default case.

    :py:obj:`~.cuEventRecordWithFlags()` can be called multiple times on
    the same event and will overwrite the previously captured state. Other
    APIs such as :py:obj:`~.cuStreamWaitEvent()` use the most recently
    captured state at the time of the API call, and are not affected by
    later calls to :py:obj:`~.cuEventRecordWithFlags()`. Before the first
    call to :py:obj:`~.cuEventRecordWithFlags()`, an event represents an
    empty set of work, so for example :py:obj:`~.cuEventQuery()` would
    return :py:obj:`~.CUDA_SUCCESS`.

    flags include:

    - :py:obj:`~.CU_EVENT_RECORD_DEFAULT`: Default event creation flag.

    - :py:obj:`~.CU_EVENT_RECORD_EXTERNAL`: Event is captured in the graph
      as an external event node when performing stream capture. This flag
      is invalid outside of stream capture.

    Parameters
    ----------
    hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to record
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to record event for
    flags : unsigned int
        See :py:obj:`~.CUevent_capture_flags`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cudaEventRecord`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUevent cyhEvent
    if hEvent is None:
        phEvent = 0
    elif isinstance(hEvent, (CUevent,)):
        phEvent = int(hEvent)
    else:
        phEvent = int(CUevent(hEvent))
    cyhEvent = <cydriver.CUevent><void_ptr>phEvent
    with nogil:
        err = cydriver.cuEventRecordWithFlags(cyhEvent, cyhStream, flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuEventQuery' in found_functions}}

@cython.embedsignature(True)
def cuEventQuery(hEvent):
    """ Queries an event's status.

    Queries the status of all work currently captured by `hEvent`. See
    :py:obj:`~.cuEventRecord()` for details on what is captured by an
    event.

    Returns :py:obj:`~.CUDA_SUCCESS` if all captured work has been
    completed, or :py:obj:`~.CUDA_ERROR_NOT_READY` if any captured work is
    incomplete.

    For the purposes of Unified Memory, a return value of
    :py:obj:`~.CUDA_SUCCESS` is equivalent to having called
    :py:obj:`~.cuEventSynchronize()`.

    Parameters
    ----------
    hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_READY`

    See Also
    --------
    :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cudaEventQuery`
    """
    cdef cydriver.CUevent cyhEvent
    if hEvent is None:
        phEvent = 0
    elif isinstance(hEvent, (CUevent,)):
        phEvent = int(hEvent)
    else:
        phEvent = int(CUevent(hEvent))
    cyhEvent = <cydriver.CUevent><void_ptr>phEvent
    with nogil:
        err = cydriver.cuEventQuery(cyhEvent)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuEventSynchronize' in found_functions}}

@cython.embedsignature(True)
def cuEventSynchronize(hEvent):
    """ Waits for an event to complete.

    Waits until the completion of all work currently captured in `hEvent`.
    See :py:obj:`~.cuEventRecord()` for details on what is captured by an
    event.

    Waiting for an event that was created with the
    :py:obj:`~.CU_EVENT_BLOCKING_SYNC` flag will cause the calling CPU
    thread to block until the event has been completed by the device. If
    the :py:obj:`~.CU_EVENT_BLOCKING_SYNC` flag has not been set, then the
    CPU thread will busy-wait until the event has been completed by the
    device.

    Parameters
    ----------
    hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to wait for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cudaEventSynchronize`
    """
    cdef cydriver.CUevent cyhEvent
    if hEvent is None:
        phEvent = 0
    elif isinstance(hEvent, (CUevent,)):
        phEvent = int(hEvent)
    else:
        phEvent = int(CUevent(hEvent))
    cyhEvent = <cydriver.CUevent><void_ptr>phEvent
    with nogil:
        err = cydriver.cuEventSynchronize(cyhEvent)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuEventDestroy_v2' in found_functions}}

@cython.embedsignature(True)
def cuEventDestroy(hEvent):
    """ Destroys an event.

    Destroys the event specified by `hEvent`.

    An event may be destroyed before it is complete (i.e., while
    :py:obj:`~.cuEventQuery()` would return
    :py:obj:`~.CUDA_ERROR_NOT_READY`). In this case, the call does not
    block on completion of the event, and any associated resources will
    automatically be released asynchronously at completion.

    Parameters
    ----------
    hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cudaEventDestroy`
    """
    cdef cydriver.CUevent cyhEvent
    if hEvent is None:
        phEvent = 0
    elif isinstance(hEvent, (CUevent,)):
        phEvent = int(hEvent)
    else:
        phEvent = int(CUevent(hEvent))
    cyhEvent = <cydriver.CUevent><void_ptr>phEvent
    with nogil:
        err = cydriver.cuEventDestroy(cyhEvent)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuEventElapsedTime_v2' in found_functions}}

@cython.embedsignature(True)
def cuEventElapsedTime(hStart, hEnd):
    """ Computes the elapsed time between two events.

    Computes the elapsed time between two events (in milliseconds with a
    resolution of around 0.5 microseconds). Note this API is not guaranteed
    to return the latest errors for pending work. As such this API is
    intended to serve as an elapsed time calculation only and any polling
    for completion on the events to be compared should be done with
    :py:obj:`~.cuEventQuery` instead.

    If either event was last recorded in a non-NULL stream, the resulting
    time may be greater than expected (even if both used the same stream
    handle). This happens because the :py:obj:`~.cuEventRecord()` operation
    takes place asynchronously and there is no guarantee that the measured
    latency is actually just between the two events. Any number of other
    different stream operations could execute in between the two measured
    events, thus altering the timing in a significant way.

    If :py:obj:`~.cuEventRecord()` has not been called on either event then
    :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is returned. If
    :py:obj:`~.cuEventRecord()` has been called on both events but one or
    both of them has not yet been completed (that is,
    :py:obj:`~.cuEventQuery()` would return
    :py:obj:`~.CUDA_ERROR_NOT_READY` on at least one of the events),
    :py:obj:`~.CUDA_ERROR_NOT_READY` is returned. If either event was
    created with the :py:obj:`~.CU_EVENT_DISABLE_TIMING` flag, then this
    function will return :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`.

    Parameters
    ----------
    hStart : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Starting event
    hEnd : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Ending event

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_READY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    pMilliseconds : float
        Time between `hStart` and `hEnd` in ms

    See Also
    --------
    :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cudaEventElapsedTime`
    """
    cdef cydriver.CUevent cyhEnd
    if hEnd is None:
        phEnd = 0
    elif isinstance(hEnd, (CUevent,)):
        phEnd = int(hEnd)
    else:
        phEnd = int(CUevent(hEnd))
    cyhEnd = <cydriver.CUevent><void_ptr>phEnd
    cdef cydriver.CUevent cyhStart
    if hStart is None:
        phStart = 0
    elif isinstance(hStart, (CUevent,)):
        phStart = int(hStart)
    else:
        phStart = int(CUevent(hStart))
    cyhStart = <cydriver.CUevent><void_ptr>phStart
    cdef float pMilliseconds = 0
    with nogil:
        err = cydriver.cuEventElapsedTime(&pMilliseconds, cyhStart, cyhEnd)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pMilliseconds)
{{endif}}

{{if 'cuImportExternalMemory' in found_functions}}

@cython.embedsignature(True)
def cuImportExternalMemory(memHandleDesc : Optional[CUDA_EXTERNAL_MEMORY_HANDLE_DESC]):
    """ Imports an external memory object.

    Imports an externally allocated memory object and returns a handle to
    that in `extMem_out`.

    The properties of the handle being imported must be described in
    `memHandleDesc`. The :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`
    structure is defined as follows:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` specifies the
    type of handle being imported. :py:obj:`~.CUexternalMemoryHandleType`
    is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD`, then
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::fd must be a
    valid file descriptor referencing a memory object. Ownership of the
    file descriptor is transferred to the CUDA driver when the handle is
    imported successfully. Performing any operations on the file descriptor
    after it is imported results in undefined behavior.

    If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32`, then exactly
    one of
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle and
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name must
    not be NULL. If
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle is
    not NULL, then it must represent a valid shared NT handle that
    references a memory object. Ownership of this handle is not transferred
    to CUDA after the import operation, so the application must release the
    handle using the appropriate system call. If
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must point to a NULL-terminated array of UTF-16
    characters that refers to a memory object.

    If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT`, then
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle
    must be non-NULL and
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name must
    be NULL. The handle specified must be a globally shared KMT handle.
    This handle does not hold a reference to the underlying object, and
    thus will be invalid when all references to the memory object are
    destroyed.

    If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP`, then exactly one
    of :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle
    and :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name
    must not be NULL. If
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle is
    not NULL, then it must represent a valid shared NT handle that is
    returned by ID3D12Device::CreateSharedHandle when referring to a
    ID3D12Heap object. This handle holds a reference to the underlying
    object. If
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must point to a NULL-terminated array of UTF-16
    characters that refers to a ID3D12Heap object.

    If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE`, then exactly
    one of
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle and
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name must
    not be NULL. If
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle is
    not NULL, then it must represent a valid shared NT handle that is
    returned by ID3D12Device::CreateSharedHandle when referring to a
    ID3D12Resource object. This handle holds a reference to the underlying
    object. If
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must point to a NULL-terminated array of UTF-16
    characters that refers to a ID3D12Resource object.

    If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE`, then
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle
    must represent a valid shared NT handle that is returned by
    IDXGIResource1::CreateSharedHandle when referring to a ID3D11Resource
    object. If
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must point to a NULL-terminated array of UTF-16
    characters that refers to a ID3D11Resource object.

    If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT`, then
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle
    must represent a valid shared KMT handle that is returned by
    IDXGIResource::GetSharedHandle when referring to a ID3D11Resource
    object and
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name must
    be NULL.

    If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF`, then
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::nvSciBufObject
    must be non-NULL and reference a valid NvSciBuf object. If the NvSciBuf
    object imported into CUDA is also mapped by other drivers, then the
    application must use :py:obj:`~.cuWaitExternalSemaphoresAsync` or
    :py:obj:`~.cuSignalExternalSemaphoresAsync` as appropriate barriers to
    maintain coherence between CUDA and the other drivers. See
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC` and
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC` for
    memory synchronization.

    If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_DMABUF_FD`, then
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::fd must be a
    valid file descriptor referencing a dma_buf object and
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.flags` must be zero.
    Importing a dma_buf object is supported only on Tegra Jetson platform
    starting with Thor series. Mapping an imported dma_buf object as CUDA
    mipmapped array using
    :py:obj:`~.cuExternalMemoryGetMappedMipmappedArray` is not supported.

    The size of the memory object must be specified in
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.size`.

    Specifying the flag :py:obj:`~.CUDA_EXTERNAL_MEMORY_DEDICATED` in
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.flags` indicates that the
    resource is a dedicated resource. The definition of what a dedicated
    resource is outside the scope of this extension. This flag must be set
    if :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is one of the
    following: :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE`
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE`
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT`

    Parameters
    ----------
    memHandleDesc : :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`
        Memory import handle descriptor

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OPERATING_SYSTEM`
    extMem_out : :py:obj:`~.CUexternalMemory`
        Returned handle to an external memory object

    See Also
    --------
    :py:obj:`~.cuDestroyExternalMemory`, :py:obj:`~.cuExternalMemoryGetMappedBuffer`, :py:obj:`~.cuExternalMemoryGetMappedMipmappedArray`

    Notes
    -----
    If the Vulkan memory imported into CUDA is mapped on the CPU then the application must use vkInvalidateMappedMemoryRanges/vkFlushMappedMemoryRanges as well as appropriate Vulkan pipeline barriers to maintain coherence between CPU and GPU. For more information on these APIs, please refer to "Synchronization
    and Cache Control" chapter from Vulkan specification.
    """
    cdef CUexternalMemory extMem_out = CUexternalMemory()
    cdef cydriver.CUDA_EXTERNAL_MEMORY_HANDLE_DESC* cymemHandleDesc_ptr = memHandleDesc._pvt_ptr if memHandleDesc is not None else NULL
    with nogil:
        err = cydriver.cuImportExternalMemory(<cydriver.CUexternalMemory*>extMem_out._pvt_ptr, cymemHandleDesc_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], extMem_out)
{{endif}}

{{if 'cuExternalMemoryGetMappedBuffer' in found_functions}}

@cython.embedsignature(True)
def cuExternalMemoryGetMappedBuffer(extMem, bufferDesc : Optional[CUDA_EXTERNAL_MEMORY_BUFFER_DESC]):
    """ Maps a buffer onto an imported memory object.

    Maps a buffer onto an imported memory object and returns a device
    pointer in `devPtr`.

    The properties of the buffer being mapped must be described in
    `bufferDesc`. The :py:obj:`~.CUDA_EXTERNAL_MEMORY_BUFFER_DESC`
    structure is defined as follows:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.CUDA_EXTERNAL_MEMORY_BUFFER_DESC.offset` is the offset
    in the memory object where the buffer's base address is.
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_BUFFER_DESC.size` is the size of the
    buffer. :py:obj:`~.CUDA_EXTERNAL_MEMORY_BUFFER_DESC.flags` must be
    zero.

    The offset and size have to be suitably aligned to match the
    requirements of the external API. Mapping two buffers whose ranges
    overlap may or may not result in the same virtual address being
    returned for the overlapped portion. In such cases, the application
    must ensure that all accesses to that region from the GPU are volatile.
    Otherwise writes made via one address are not guaranteed to be visible
    via the other address, even if they're issued by the same thread. It is
    recommended that applications map the combined range instead of mapping
    separate buffers and then apply the appropriate offsets to the returned
    pointer to derive the individual buffers.

    The returned pointer `devPtr` must be freed using
    :py:obj:`~.cuMemFree`.

    Parameters
    ----------
    extMem : :py:obj:`~.CUexternalMemory`
        Handle to external memory object
    bufferDesc : :py:obj:`~.CUDA_EXTERNAL_MEMORY_BUFFER_DESC`
        Buffer descriptor

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    devPtr : :py:obj:`~.CUdeviceptr`
        Returned device pointer to buffer

    See Also
    --------
    :py:obj:`~.cuImportExternalMemory`, :py:obj:`~.cuDestroyExternalMemory`, :py:obj:`~.cuExternalMemoryGetMappedMipmappedArray`
    """
    cdef cydriver.CUexternalMemory cyextMem
    if extMem is None:
        pextMem = 0
    elif isinstance(extMem, (CUexternalMemory,)):
        pextMem = int(extMem)
    else:
        pextMem = int(CUexternalMemory(extMem))
    cyextMem = <cydriver.CUexternalMemory><void_ptr>pextMem
    cdef CUdeviceptr devPtr = CUdeviceptr()
    cdef cydriver.CUDA_EXTERNAL_MEMORY_BUFFER_DESC* cybufferDesc_ptr = bufferDesc._pvt_ptr if bufferDesc is not None else NULL
    with nogil:
        err = cydriver.cuExternalMemoryGetMappedBuffer(<cydriver.CUdeviceptr*>devPtr._pvt_ptr, cyextMem, cybufferDesc_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], devPtr)
{{endif}}

{{if 'cuExternalMemoryGetMappedMipmappedArray' in found_functions}}

@cython.embedsignature(True)
def cuExternalMemoryGetMappedMipmappedArray(extMem, mipmapDesc : Optional[CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC]):
    """ Maps a CUDA mipmapped array onto an external memory object.

    Maps a CUDA mipmapped array onto an external object and returns a
    handle to it in `mipmap`.

    The properties of the CUDA mipmapped array being mapped must be
    described in `mipmapDesc`. The structure
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC` is defined as
    follows:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC.offset` is
    the offset in the memory object where the base level of the mipmap
    chain is.
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC.arrayDesc`
    describes the format, dimensions and type of the base level of the
    mipmap chain. For further details on these parameters, please refer to
    the documentation for :py:obj:`~.cuMipmappedArrayCreate`. Note that if
    the mipmapped array is bound as a color target in the graphics API,
    then the flag :py:obj:`~.CUDA_ARRAY3D_COLOR_ATTACHMENT` must be
    specified in
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC`::arrayDesc::Flags.
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC.numLevels`
    specifies the total number of levels in the mipmap chain.

    If `extMem` was imported from a handle of type
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF`, then
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC.numLevels` must be
    equal to 1.

    Mapping `extMem` imported from a handle of type
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_DMABUF_FD`, is not supported.

    The returned CUDA mipmapped array must be freed using
    :py:obj:`~.cuMipmappedArrayDestroy`.

    Parameters
    ----------
    extMem : :py:obj:`~.CUexternalMemory`
        Handle to external memory object
    mipmapDesc : :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC`
        CUDA array descriptor

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    mipmap : :py:obj:`~.CUmipmappedArray`
        Returned CUDA mipmapped array

    See Also
    --------
    :py:obj:`~.cuImportExternalMemory`, :py:obj:`~.cuDestroyExternalMemory`, :py:obj:`~.cuExternalMemoryGetMappedBuffer`
    """
    cdef cydriver.CUexternalMemory cyextMem
    if extMem is None:
        pextMem = 0
    elif isinstance(extMem, (CUexternalMemory,)):
        pextMem = int(extMem)
    else:
        pextMem = int(CUexternalMemory(extMem))
    cyextMem = <cydriver.CUexternalMemory><void_ptr>pextMem
    cdef CUmipmappedArray mipmap = CUmipmappedArray()
    cdef cydriver.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC* cymipmapDesc_ptr = mipmapDesc._pvt_ptr if mipmapDesc is not None else NULL
    with nogil:
        err = cydriver.cuExternalMemoryGetMappedMipmappedArray(<cydriver.CUmipmappedArray*>mipmap._pvt_ptr, cyextMem, cymipmapDesc_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], mipmap)
{{endif}}

{{if 'cuDestroyExternalMemory' in found_functions}}

@cython.embedsignature(True)
def cuDestroyExternalMemory(extMem):
    """ Destroys an external memory object.

    Destroys the specified external memory object. Any existing buffers and
    CUDA mipmapped arrays mapped onto this object must no longer be used
    and must be explicitly freed using :py:obj:`~.cuMemFree` and
    :py:obj:`~.cuMipmappedArrayDestroy` respectively.

    Parameters
    ----------
    extMem : :py:obj:`~.CUexternalMemory`
        External memory object to be destroyed

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuImportExternalMemory`, :py:obj:`~.cuExternalMemoryGetMappedBuffer`, :py:obj:`~.cuExternalMemoryGetMappedMipmappedArray`
    """
    cdef cydriver.CUexternalMemory cyextMem
    if extMem is None:
        pextMem = 0
    elif isinstance(extMem, (CUexternalMemory,)):
        pextMem = int(extMem)
    else:
        pextMem = int(CUexternalMemory(extMem))
    cyextMem = <cydriver.CUexternalMemory><void_ptr>pextMem
    with nogil:
        err = cydriver.cuDestroyExternalMemory(cyextMem)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuImportExternalSemaphore' in found_functions}}

@cython.embedsignature(True)
def cuImportExternalSemaphore(semHandleDesc : Optional[CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC]):
    """ Imports an external semaphore.

    Imports an externally allocated synchronization object and returns a
    handle to that in `extSem_out`.

    The properties of the handle being imported must be described in
    `semHandleDesc`. The :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC` is
    defined as follows:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` specifies
    the type of handle being imported.
    :py:obj:`~.CUexternalSemaphoreHandleType` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD`, then
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::fd must be a
    valid file descriptor referencing a synchronization object. Ownership
    of the file descriptor is transferred to the CUDA driver when the
    handle is imported successfully. Performing any operations on the file
    descriptor after it is imported results in undefined behavior.

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32`, then
    exactly one of
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    and
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name
    must not be NULL. If
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    is not NULL, then it must represent a valid shared NT handle that
    references a synchronization object. Ownership of this handle is not
    transferred to CUDA after the import operation, so the application must
    release the handle using the appropriate system call. If
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must name a valid synchronization object.

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT`, then
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    must be non-NULL and
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name
    must be NULL. The handle specified must be a globally shared KMT
    handle. This handle does not hold a reference to the underlying object,
    and thus will be invalid when all references to the synchronization
    object are destroyed.

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE`, then exactly
    one of
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    and
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name
    must not be NULL. If
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    is not NULL, then it must represent a valid shared NT handle that is
    returned by ID3D12Device::CreateSharedHandle when referring to a
    ID3D12Fence object. This handle holds a reference to the underlying
    object. If
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must name a valid synchronization object that refers
    to a valid ID3D12Fence object.

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE`, then
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    represents a valid shared NT handle that is returned by
    ID3D11Fence::CreateSharedHandle. If
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must name a valid synchronization object that refers
    to a valid ID3D11Fence object.

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC`, then
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::nvSciSyncObj
    represents a valid NvSciSyncObj.

    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX`, then
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    represents a valid shared NT handle that is returned by
    IDXGIResource1::CreateSharedHandle when referring to a IDXGIKeyedMutex
    object. If
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must name a valid synchronization object that refers
    to a valid IDXGIKeyedMutex object.

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT`,
    then
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    represents a valid shared KMT handle that is returned by
    IDXGIResource::GetSharedHandle when referring to a IDXGIKeyedMutex
    object and
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name
    must be NULL.

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD`,
    then :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::fd must
    be a valid file descriptor referencing a synchronization object.
    Ownership of the file descriptor is transferred to the CUDA driver when
    the handle is imported successfully. Performing any operations on the
    file descriptor after it is imported results in undefined behavior.

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32`,
    then exactly one of
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    and
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name
    must not be NULL. If
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    is not NULL, then it must represent a valid shared NT handle that
    references a synchronization object. Ownership of this handle is not
    transferred to CUDA after the import operation, so the application must
    release the handle using the appropriate system call. If
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must name a valid synchronization object.

    Parameters
    ----------
    semHandleDesc : :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`
        Semaphore import handle descriptor

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OPERATING_SYSTEM`
    extSem_out : :py:obj:`~.CUexternalSemaphore`
        Returned handle to an external semaphore

    See Also
    --------
    :py:obj:`~.cuDestroyExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """
    cdef CUexternalSemaphore extSem_out = CUexternalSemaphore()
    cdef cydriver.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC* cysemHandleDesc_ptr = semHandleDesc._pvt_ptr if semHandleDesc is not None else NULL
    with nogil:
        err = cydriver.cuImportExternalSemaphore(<cydriver.CUexternalSemaphore*>extSem_out._pvt_ptr, cysemHandleDesc_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], extSem_out)
{{endif}}

{{if 'cuSignalExternalSemaphoresAsync' in found_functions}}

@cython.embedsignature(True)
def cuSignalExternalSemaphoresAsync(extSemArray : Optional[tuple[CUexternalSemaphore] | list[CUexternalSemaphore]], paramsArray : Optional[tuple[CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS] | list[CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS]], unsigned int numExtSems, stream):
    """ Signals a set of external semaphore objects.

    Enqueues a signal operation on a set of externally allocated semaphore
    object in the specified stream. The operations will be executed when
    all prior operations in the stream complete.

    The exact semantics of signaling a semaphore depends on the type of the
    object.

    If the semaphore object is any one of the following types:
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT` then
    signaling the semaphore will set it to the signaled state.

    If the semaphore object is any one of the following types:
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32`
    then the semaphore will be set to the value specified in
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS`::params::fence::value.

    If the semaphore object is of the type
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC` this API sets
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS`::params::nvSciSync::fence
    to a value that can be used by subsequent waiters of the same NvSciSync
    object to order operations with those currently submitted in `stream`.
    Such an update will overwrite previous contents of
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS`::params::nvSciSync::fence.
    By default, signaling such an external semaphore object causes
    appropriate memory synchronization operations to be performed over all
    external memory objects that are imported as
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF`. This ensures that
    any subsequent accesses made by other importers of the same set of
    NvSciBuf memory object(s) are coherent. These operations can be skipped
    by specifying the flag
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC`, which
    can be used as a performance optimization when data coherency is not
    required. But specifying this flag in scenarios where data coherency is
    required results in undefined behavior. Also, for semaphore object of
    the type :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC`, if
    the NvSciSyncAttrList used to create the NvSciSyncObj had not set the
    flags in :py:obj:`~.cuDeviceGetNvSciSyncAttributes` to
    CUDA_NVSCISYNC_ATTR_SIGNAL, this API will return
    CUDA_ERROR_NOT_SUPPORTED. NvSciSyncFence associated with semaphore
    object of the type
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC` can be
    deterministic. For this the NvSciSyncAttrList used to create the
    semaphore object must have value of
    NvSciSyncAttrKey_RequireDeterministicFences key set to true.
    Deterministic fences allow users to enqueue a wait over the semaphore
    object even before corresponding signal is enqueued. For such a
    semaphore object, CUDA guarantees that each signal operation will
    increment the fence value by '1'. Users are expected to track count of
    signals enqueued on the semaphore object and insert waits accordingly.
    When such a semaphore object is signaled from multiple streams, due to
    concurrent stream execution, it is possible that the order in which the
    semaphore gets signaled is indeterministic. This could lead to waiters
    of the semaphore getting unblocked incorrectly. Users are expected to
    handle such situations, either by not using the same semaphore object
    with deterministic fence support enabled in different streams or by
    adding explicit dependency amongst such streams so that the semaphore
    is signaled in order. NvSciSyncFence associated with semaphore object
    of the type :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC` can
    be timestamp enabled. For this the NvSciSyncAttrList used to create the
    object must have the value of NvSciSyncAttrKey_WaiterRequireTimestamps
    key set to true. Timestamps are emitted asynchronously by the GPU and
    CUDA saves the GPU timestamp in the corresponding NvSciSyncFence at the
    time of signal on GPU. Users are expected to convert GPU clocks to CPU
    clocks using appropriate scaling functions. Users are expected to wait
    for the completion of the fence before extracting timestamp using
    appropriate NvSciSync APIs. Users are expected to ensure that there is
    only one outstanding timestamp enabled fence per Cuda-NvSciSync object
    at any point of time, failing which leads to undefined behavior.
    Extracting the timestamp before the corresponding fence is signalled
    could lead to undefined behaviour. Timestamp extracted via appropriate
    NvSciSync API would be in microseconds.

    If the semaphore object is any one of the following types:
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT`
    then the keyed mutex will be released with the key specified in
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_PARAMS`::params::keyedmutex::key.

    Parameters
    ----------
    extSemArray : list[:py:obj:`~.CUexternalSemaphore`]
        Set of external semaphores to be signaled
    paramsArray : list[:py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS`]
        Array of semaphore parameters
    numExtSems : unsigned int
        Number of semaphores to signal
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to enqueue the signal operations in

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuDestroyExternalSemaphore`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """
    cdef cydriver.CUstream cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (CUstream,)):
        pstream = int(stream)
    else:
        pstream = int(CUstream(stream))
    cystream = <cydriver.CUstream><void_ptr>pstream
    paramsArray = [] if paramsArray is None else paramsArray
    if not all(isinstance(_x, (CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,)) for _x in paramsArray):
        raise TypeError("Argument 'paramsArray' is not instance of type (expected tuple[cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,] or list[cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS,]")
    extSemArray = [] if extSemArray is None else extSemArray
    if not all(isinstance(_x, (CUexternalSemaphore,)) for _x in extSemArray):
        raise TypeError("Argument 'extSemArray' is not instance of type (expected tuple[cydriver.CUexternalSemaphore,] or list[cydriver.CUexternalSemaphore,]")
    cdef cydriver.CUexternalSemaphore* cyextSemArray = NULL
    if len(extSemArray) > 1:
        cyextSemArray = <cydriver.CUexternalSemaphore*> calloc(len(extSemArray), sizeof(cydriver.CUexternalSemaphore))
        if cyextSemArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(extSemArray)) + 'x' + str(sizeof(cydriver.CUexternalSemaphore)))
        else:
            for idx in range(len(extSemArray)):
                cyextSemArray[idx] = <cydriver.CUexternalSemaphore>(<CUexternalSemaphore>extSemArray[idx])._pvt_ptr[0]
    elif len(extSemArray) == 1:
        cyextSemArray = <cydriver.CUexternalSemaphore*>(<CUexternalSemaphore>extSemArray[0])._pvt_ptr
    cdef cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS* cyparamsArray = NULL
    if len(paramsArray) > 1:
        cyparamsArray = <cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS*> calloc(len(paramsArray), sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS))
        if cyparamsArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(paramsArray)) + 'x' + str(sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS)))
        for idx in range(len(paramsArray)):
            string.memcpy(&cyparamsArray[idx], (<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS>paramsArray[idx])._pvt_ptr, sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS))
    elif len(paramsArray) == 1:
        cyparamsArray = (<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS>paramsArray[0])._pvt_ptr
    if numExtSems > len(extSemArray): raise RuntimeError("List is too small: " + str(len(extSemArray)) + " < " + str(numExtSems))
    if numExtSems > len(paramsArray): raise RuntimeError("List is too small: " + str(len(paramsArray)) + " < " + str(numExtSems))
    with nogil:
        err = cydriver.cuSignalExternalSemaphoresAsync(cyextSemArray, cyparamsArray, numExtSems, cystream)
    if len(extSemArray) > 1 and cyextSemArray is not NULL:
        free(cyextSemArray)
    if len(paramsArray) > 1 and cyparamsArray is not NULL:
        free(cyparamsArray)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuWaitExternalSemaphoresAsync' in found_functions}}

@cython.embedsignature(True)
def cuWaitExternalSemaphoresAsync(extSemArray : Optional[tuple[CUexternalSemaphore] | list[CUexternalSemaphore]], paramsArray : Optional[tuple[CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS] | list[CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS]], unsigned int numExtSems, stream):
    """ Waits on a set of external semaphore objects.

    Enqueues a wait operation on a set of externally allocated semaphore
    object in the specified stream. The operations will be executed when
    all prior operations in the stream complete.

    The exact semantics of waiting on a semaphore depends on the type of
    the object.

    If the semaphore object is any one of the following types:
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT` then
    waiting on the semaphore will wait until the semaphore reaches the
    signaled state. The semaphore will then be reset to the unsignaled
    state. Therefore for every signal operation, there can only be one wait
    operation.

    If the semaphore object is any one of the following types:
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32`
    then waiting on the semaphore will wait until the value of the
    semaphore is greater than or equal to
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS`::params::fence::value.

    If the semaphore object is of the type
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC` then, waiting
    on the semaphore will wait until the
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS`::params::nvSciSync::fence
    is signaled by the signaler of the NvSciSyncObj that was associated
    with this semaphore object. By default, waiting on such an external
    semaphore object causes appropriate memory synchronization operations
    to be performed over all external memory objects that are imported as
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF`. This ensures that
    any subsequent accesses made by other importers of the same set of
    NvSciBuf memory object(s) are coherent. These operations can be skipped
    by specifying the flag
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC`, which
    can be used as a performance optimization when data coherency is not
    required. But specifying this flag in scenarios where data coherency is
    required results in undefined behavior. Also, for semaphore object of
    the type :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC`, if
    the NvSciSyncAttrList used to create the NvSciSyncObj had not set the
    flags in :py:obj:`~.cuDeviceGetNvSciSyncAttributes` to
    CUDA_NVSCISYNC_ATTR_WAIT, this API will return
    CUDA_ERROR_NOT_SUPPORTED.

    If the semaphore object is any one of the following types:
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT`
    then the keyed mutex will be acquired when it is released with the key
    specified in
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS`::params::keyedmutex::key
    or until the timeout specified by
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS`::params::keyedmutex::timeoutMs
    has lapsed. The timeout interval can either be a finite value specified
    in milliseconds or an infinite value. In case an infinite value is
    specified the timeout never elapses. The windows INFINITE macro must be
    used to specify infinite timeout.

    Parameters
    ----------
    extSemArray : list[:py:obj:`~.CUexternalSemaphore`]
        External semaphores to be waited on
    paramsArray : list[:py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS`]
        Array of semaphore parameters
    numExtSems : unsigned int
        Number of semaphores to wait on
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to enqueue the wait operations in

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_TIMEOUT`

    See Also
    --------
    :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuDestroyExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`
    """
    cdef cydriver.CUstream cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (CUstream,)):
        pstream = int(stream)
    else:
        pstream = int(CUstream(stream))
    cystream = <cydriver.CUstream><void_ptr>pstream
    paramsArray = [] if paramsArray is None else paramsArray
    if not all(isinstance(_x, (CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,)) for _x in paramsArray):
        raise TypeError("Argument 'paramsArray' is not instance of type (expected tuple[cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,] or list[cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS,]")
    extSemArray = [] if extSemArray is None else extSemArray
    if not all(isinstance(_x, (CUexternalSemaphore,)) for _x in extSemArray):
        raise TypeError("Argument 'extSemArray' is not instance of type (expected tuple[cydriver.CUexternalSemaphore,] or list[cydriver.CUexternalSemaphore,]")
    cdef cydriver.CUexternalSemaphore* cyextSemArray = NULL
    if len(extSemArray) > 1:
        cyextSemArray = <cydriver.CUexternalSemaphore*> calloc(len(extSemArray), sizeof(cydriver.CUexternalSemaphore))
        if cyextSemArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(extSemArray)) + 'x' + str(sizeof(cydriver.CUexternalSemaphore)))
        else:
            for idx in range(len(extSemArray)):
                cyextSemArray[idx] = <cydriver.CUexternalSemaphore>(<CUexternalSemaphore>extSemArray[idx])._pvt_ptr[0]
    elif len(extSemArray) == 1:
        cyextSemArray = <cydriver.CUexternalSemaphore*>(<CUexternalSemaphore>extSemArray[0])._pvt_ptr
    cdef cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS* cyparamsArray = NULL
    if len(paramsArray) > 1:
        cyparamsArray = <cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS*> calloc(len(paramsArray), sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS))
        if cyparamsArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(paramsArray)) + 'x' + str(sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS)))
        for idx in range(len(paramsArray)):
            string.memcpy(&cyparamsArray[idx], (<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS>paramsArray[idx])._pvt_ptr, sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS))
    elif len(paramsArray) == 1:
        cyparamsArray = (<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS>paramsArray[0])._pvt_ptr
    if numExtSems > len(extSemArray): raise RuntimeError("List is too small: " + str(len(extSemArray)) + " < " + str(numExtSems))
    if numExtSems > len(paramsArray): raise RuntimeError("List is too small: " + str(len(paramsArray)) + " < " + str(numExtSems))
    with nogil:
        err = cydriver.cuWaitExternalSemaphoresAsync(cyextSemArray, cyparamsArray, numExtSems, cystream)
    if len(extSemArray) > 1 and cyextSemArray is not NULL:
        free(cyextSemArray)
    if len(paramsArray) > 1 and cyparamsArray is not NULL:
        free(cyparamsArray)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuDestroyExternalSemaphore' in found_functions}}

@cython.embedsignature(True)
def cuDestroyExternalSemaphore(extSem):
    """ Destroys an external semaphore.

    Destroys an external semaphore object and releases any references to
    the underlying resource. Any outstanding signals or waits must have
    completed before the semaphore is destroyed.

    Parameters
    ----------
    extSem : :py:obj:`~.CUexternalSemaphore`
        External semaphore to be destroyed

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """
    cdef cydriver.CUexternalSemaphore cyextSem
    if extSem is None:
        pextSem = 0
    elif isinstance(extSem, (CUexternalSemaphore,)):
        pextSem = int(extSem)
    else:
        pextSem = int(CUexternalSemaphore(extSem))
    cyextSem = <cydriver.CUexternalSemaphore><void_ptr>pextSem
    with nogil:
        err = cydriver.cuDestroyExternalSemaphore(cyextSem)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuStreamWaitValue32_v2' in found_functions}}

@cython.embedsignature(True)
def cuStreamWaitValue32(stream, addr, value, unsigned int flags):
    """ Wait on a memory location.

    Enqueues a synchronization of the stream on the given memory location.
    Work ordered after the operation will block until the given condition
    on the memory is satisfied. By default, the condition is to wait for
    (int32_t)(*addr - value) >= 0, a cyclic greater-or-equal. Other
    condition types can be specified via `flags`.

    If the memory was registered via :py:obj:`~.cuMemHostRegister()`, the
    device pointer should be obtained with
    :py:obj:`~.cuMemHostGetDevicePointer()`. This function cannot be used
    with managed memory (:py:obj:`~.cuMemAllocManaged`).

    Support for CU_STREAM_WAIT_VALUE_NOR can be queried with
    :py:obj:`~.cuDeviceGetAttribute()` and
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V2`.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to synchronize on the memory location.
    addr : :py:obj:`~.CUdeviceptr`
        The memory location to wait on.
    value : Any
        The value to compare with the memory location.
    flags : unsigned int
        See :py:obj:`~.CUstreamWaitValue_flags`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamWaitValue64`, :py:obj:`~.cuStreamWriteValue32`, :py:obj:`~.cuStreamWriteValue64`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuStreamWaitEvent`

    Notes
    -----
    Warning: Improper use of this API may deadlock the application. Synchronization ordering established through this API is not visible to CUDA. CUDA tasks that are (even indirectly) ordered by this API should also have that order expressed with CUDA-visible dependencies such as events. This ensures that the scheduler does not serialize them in an improper order.
    """
    cdef cydriver.cuuint32_t cyvalue
    if value is None:
        pvalue = 0
    elif isinstance(value, (cuuint32_t,)):
        pvalue = int(value)
    else:
        pvalue = int(cuuint32_t(value))
    cyvalue = <cydriver.cuuint32_t><void_ptr>pvalue
    cdef cydriver.CUdeviceptr cyaddr
    if addr is None:
        paddr = 0
    elif isinstance(addr, (CUdeviceptr,)):
        paddr = int(addr)
    else:
        paddr = int(CUdeviceptr(addr))
    cyaddr = <cydriver.CUdeviceptr><void_ptr>paddr
    cdef cydriver.CUstream cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (CUstream,)):
        pstream = int(stream)
    else:
        pstream = int(CUstream(stream))
    cystream = <cydriver.CUstream><void_ptr>pstream
    with nogil:
        err = cydriver.cuStreamWaitValue32(cystream, cyaddr, cyvalue, flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuStreamWaitValue64_v2' in found_functions}}

@cython.embedsignature(True)
def cuStreamWaitValue64(stream, addr, value, unsigned int flags):
    """ Wait on a memory location.

    Enqueues a synchronization of the stream on the given memory location.
    Work ordered after the operation will block until the given condition
    on the memory is satisfied. By default, the condition is to wait for
    (int64_t)(*addr - value) >= 0, a cyclic greater-or-equal. Other
    condition types can be specified via `flags`.

    If the memory was registered via :py:obj:`~.cuMemHostRegister()`, the
    device pointer should be obtained with
    :py:obj:`~.cuMemHostGetDevicePointer()`.

    Support for this can be queried with :py:obj:`~.cuDeviceGetAttribute()`
    and :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS`.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to synchronize on the memory location.
    addr : :py:obj:`~.CUdeviceptr`
        The memory location to wait on.
    value : Any
        The value to compare with the memory location.
    flags : unsigned int
        See :py:obj:`~.CUstreamWaitValue_flags`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamWaitValue32`, :py:obj:`~.cuStreamWriteValue32`, :py:obj:`~.cuStreamWriteValue64`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuStreamWaitEvent`

    Notes
    -----
    Warning: Improper use of this API may deadlock the application. Synchronization ordering established through this API is not visible to CUDA. CUDA tasks that are (even indirectly) ordered by this API should also have that order expressed with CUDA-visible dependencies such as events. This ensures that the scheduler does not serialize them in an improper order.
    """
    cdef cydriver.cuuint64_t cyvalue
    if value is None:
        pvalue = 0
    elif isinstance(value, (cuuint64_t,)):
        pvalue = int(value)
    else:
        pvalue = int(cuuint64_t(value))
    cyvalue = <cydriver.cuuint64_t><void_ptr>pvalue
    cdef cydriver.CUdeviceptr cyaddr
    if addr is None:
        paddr = 0
    elif isinstance(addr, (CUdeviceptr,)):
        paddr = int(addr)
    else:
        paddr = int(CUdeviceptr(addr))
    cyaddr = <cydriver.CUdeviceptr><void_ptr>paddr
    cdef cydriver.CUstream cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (CUstream,)):
        pstream = int(stream)
    else:
        pstream = int(CUstream(stream))
    cystream = <cydriver.CUstream><void_ptr>pstream
    with nogil:
        err = cydriver.cuStreamWaitValue64(cystream, cyaddr, cyvalue, flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuStreamWriteValue32_v2' in found_functions}}

@cython.embedsignature(True)
def cuStreamWriteValue32(stream, addr, value, unsigned int flags):
    """ Write a value to memory.

    Write a value to memory.

    If the memory was registered via :py:obj:`~.cuMemHostRegister()`, the
    device pointer should be obtained with
    :py:obj:`~.cuMemHostGetDevicePointer()`. This function cannot be used
    with managed memory (:py:obj:`~.cuMemAllocManaged`).

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to do the write in.
    addr : :py:obj:`~.CUdeviceptr`
        The device address to write to.
    value : Any
        The value to write.
    flags : unsigned int
        See :py:obj:`~.CUstreamWriteValue_flags`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamWriteValue64`, :py:obj:`~.cuStreamWaitValue32`, :py:obj:`~.cuStreamWaitValue64`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuEventRecord`
    """
    cdef cydriver.cuuint32_t cyvalue
    if value is None:
        pvalue = 0
    elif isinstance(value, (cuuint32_t,)):
        pvalue = int(value)
    else:
        pvalue = int(cuuint32_t(value))
    cyvalue = <cydriver.cuuint32_t><void_ptr>pvalue
    cdef cydriver.CUdeviceptr cyaddr
    if addr is None:
        paddr = 0
    elif isinstance(addr, (CUdeviceptr,)):
        paddr = int(addr)
    else:
        paddr = int(CUdeviceptr(addr))
    cyaddr = <cydriver.CUdeviceptr><void_ptr>paddr
    cdef cydriver.CUstream cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (CUstream,)):
        pstream = int(stream)
    else:
        pstream = int(CUstream(stream))
    cystream = <cydriver.CUstream><void_ptr>pstream
    with nogil:
        err = cydriver.cuStreamWriteValue32(cystream, cyaddr, cyvalue, flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuStreamWriteValue64_v2' in found_functions}}

@cython.embedsignature(True)
def cuStreamWriteValue64(stream, addr, value, unsigned int flags):
    """ Write a value to memory.

    Write a value to memory.

    If the memory was registered via :py:obj:`~.cuMemHostRegister()`, the
    device pointer should be obtained with
    :py:obj:`~.cuMemHostGetDevicePointer()`.

    Support for this can be queried with :py:obj:`~.cuDeviceGetAttribute()`
    and :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS`.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to do the write in.
    addr : :py:obj:`~.CUdeviceptr`
        The device address to write to.
    value : Any
        The value to write.
    flags : unsigned int
        See :py:obj:`~.CUstreamWriteValue_flags`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamWriteValue32`, :py:obj:`~.cuStreamWaitValue32`, :py:obj:`~.cuStreamWaitValue64`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuEventRecord`
    """
    cdef cydriver.cuuint64_t cyvalue
    if value is None:
        pvalue = 0
    elif isinstance(value, (cuuint64_t,)):
        pvalue = int(value)
    else:
        pvalue = int(cuuint64_t(value))
    cyvalue = <cydriver.cuuint64_t><void_ptr>pvalue
    cdef cydriver.CUdeviceptr cyaddr
    if addr is None:
        paddr = 0
    elif isinstance(addr, (CUdeviceptr,)):
        paddr = int(addr)
    else:
        paddr = int(CUdeviceptr(addr))
    cyaddr = <cydriver.CUdeviceptr><void_ptr>paddr
    cdef cydriver.CUstream cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (CUstream,)):
        pstream = int(stream)
    else:
        pstream = int(CUstream(stream))
    cystream = <cydriver.CUstream><void_ptr>pstream
    with nogil:
        err = cydriver.cuStreamWriteValue64(cystream, cyaddr, cyvalue, flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuStreamBatchMemOp_v2' in found_functions}}

@cython.embedsignature(True)
def cuStreamBatchMemOp(stream, unsigned int count, paramArray : Optional[tuple[CUstreamBatchMemOpParams] | list[CUstreamBatchMemOpParams]], unsigned int flags):
    """ Batch operations to synchronize the stream via memory operations.

    This is a batch version of :py:obj:`~.cuStreamWaitValue32()` and
    :py:obj:`~.cuStreamWriteValue32()`. Batching operations may avoid some
    performance overhead in both the API call and the device execution
    versus adding them to the stream in separate API calls. The operations
    are enqueued in the order they appear in the array.

    See :py:obj:`~.CUstreamBatchMemOpType` for the full set of supported
    operations, and :py:obj:`~.cuStreamWaitValue32()`,
    :py:obj:`~.cuStreamWaitValue64()`, :py:obj:`~.cuStreamWriteValue32()`,
    and :py:obj:`~.cuStreamWriteValue64()` for details of specific
    operations.

    See related APIs for details on querying support for specific
    operations.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to enqueue the operations in.
    count : unsigned int
        The number of operations in the array. Must be less than 256.
    paramArray : list[:py:obj:`~.CUstreamBatchMemOpParams`]
        The types and parameters of the individual operations.
    flags : unsigned int
        Reserved for future expansion; must be 0.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamWaitValue32`, :py:obj:`~.cuStreamWaitValue64`, :py:obj:`~.cuStreamWriteValue32`, :py:obj:`~.cuStreamWriteValue64`, :py:obj:`~.cuMemHostRegister`

    Notes
    -----
    Warning: Improper use of this API may deadlock the application. Synchronization ordering established through this API is not visible to CUDA. CUDA tasks that are (even indirectly) ordered by this API should also have that order expressed with CUDA-visible dependencies such as events. This ensures that the scheduler does not serialize them in an improper order.
    """
    paramArray = [] if paramArray is None else paramArray
    if not all(isinstance(_x, (CUstreamBatchMemOpParams,)) for _x in paramArray):
        raise TypeError("Argument 'paramArray' is not instance of type (expected tuple[cydriver.CUstreamBatchMemOpParams,] or list[cydriver.CUstreamBatchMemOpParams,]")
    cdef cydriver.CUstream cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (CUstream,)):
        pstream = int(stream)
    else:
        pstream = int(CUstream(stream))
    cystream = <cydriver.CUstream><void_ptr>pstream
    if count > len(paramArray): raise RuntimeError("List is too small: " + str(len(paramArray)) + " < " + str(count))
    cdef cydriver.CUstreamBatchMemOpParams* cyparamArray = NULL
    if len(paramArray) > 1:
        cyparamArray = <cydriver.CUstreamBatchMemOpParams*> calloc(len(paramArray), sizeof(cydriver.CUstreamBatchMemOpParams))
        if cyparamArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(paramArray)) + 'x' + str(sizeof(cydriver.CUstreamBatchMemOpParams)))
        for idx in range(len(paramArray)):
            string.memcpy(&cyparamArray[idx], (<CUstreamBatchMemOpParams>paramArray[idx])._pvt_ptr, sizeof(cydriver.CUstreamBatchMemOpParams))
    elif len(paramArray) == 1:
        cyparamArray = (<CUstreamBatchMemOpParams>paramArray[0])._pvt_ptr
    with nogil:
        err = cydriver.cuStreamBatchMemOp(cystream, count, cyparamArray, flags)
    if len(paramArray) > 1 and cyparamArray is not NULL:
        free(cyparamArray)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuFuncGetAttribute' in found_functions}}

@cython.embedsignature(True)
def cuFuncGetAttribute(attrib not None : CUfunction_attribute, hfunc):
    """ Returns information about a function.

    Returns in `*pi` the integer value of the attribute `attrib` on the
    kernel given by `hfunc`. The supported attributes are:

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK`: The maximum
      number of threads per block, beyond which a launch of the function
      would fail. This number depends on both the function and the device
      on which the function is currently loaded.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES`: The size in bytes of
      statically-allocated shared memory per block required by this
      function. This does not include dynamically-allocated shared memory
      requested by the user at runtime.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES`: The size in bytes of
      user-allocated constant memory required by this function.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES`: The size in bytes of
      local memory used by each thread of this function.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_NUM_REGS`: The number of registers used
      by each thread of this function.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_PTX_VERSION`: The PTX virtual
      architecture version for which the function was compiled. This value
      is the major PTX version * 10

      - the minor PTX version, so a PTX version 1.3 function would return
        the value 13. Note that this may return the undefined value of 0
        for cubins compiled prior to CUDA 3.0.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_BINARY_VERSION`: The binary architecture
      version for which the function was compiled. This value is the major
      binary version * 10 + the minor binary version, so a binary version
      1.3 function would return the value 13. Note that this will return a
      value of 10 for legacy cubins that do not have a properly-encoded
      binary architecture version.

    - :py:obj:`~.CU_FUNC_CACHE_MODE_CA`: The attribute to indicate whether
      the function has been compiled with user specified option "-Xptxas
      --dlcm=ca" set .

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES`: The
      maximum size in bytes of dynamically-allocated shared memory.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT`:
      Preferred shared memory-L1 cache split ratio in percent of total
      shared memory.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET`: If this
      attribute is set, the kernel must launch with a valid cluster size
      specified.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH`: The required
      cluster width in blocks.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT`: The required
      cluster height in blocks.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH`: The required
      cluster depth in blocks.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED`:
      Indicates whether the function can be launched with non-portable
      cluster size. 1 is allowed, 0 is disallowed. A non-portable cluster
      size may only function on the specific SKUs the program is tested on.
      The launch might fail if the program is run on a different hardware
      platform. CUDA API provides cudaOccupancyMaxActiveClusters to assist
      with checking whether the desired size can be launched on the current
      device. A portable cluster size is guaranteed to be functional on all
      compute capabilities higher than the target compute capability. The
      portable cluster size for sm_90 is 8 blocks per cluster. This value
      may increase for future compute capabilities. The specific hardware
      unit may support higher cluster sizes thats not guaranteed to be
      portable.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE`:
      The block scheduling policy of a function. The value type is
      CUclusterSchedulingPolicy.

    With a few execeptions, function attributes may also be queried on
    unloaded function handles returned from
    :py:obj:`~.cuModuleEnumerateFunctions`.
    :py:obj:`~.CUDA_ERROR_FUNCTION_NOT_LOADED` is returned if the attribute
    requires a fully loaded function but the function is not loaded. The
    loading state of a function may be queried using
    :py:obj:`~.cuFuncIsloaded`. :py:obj:`~.cuFuncLoad` may be called to
    explicitly load a function before querying the following attributes
    that require the function to be loaded:

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK`

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES`

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES`

    Parameters
    ----------
    attrib : :py:obj:`~.CUfunction_attribute`
        Attribute requested
    hfunc : :py:obj:`~.CUfunction`
        Function to query attribute of

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_FUNCTION_NOT_LOADED`
    pi : int
        Returned attribute value

    See Also
    --------
    :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cudaFuncGetAttributes`, :py:obj:`~.cudaFuncSetAttribute`, :py:obj:`~.cuFuncIsLoaded`, :py:obj:`~.cuFuncLoad`, :py:obj:`~.cuKernelGetAttribute`
    """
    cdef cydriver.CUfunction cyhfunc
    if hfunc is None:
        phfunc = 0
    elif isinstance(hfunc, (CUfunction,)):
        phfunc = int(hfunc)
    else:
        phfunc = int(CUfunction(hfunc))
    cyhfunc = <cydriver.CUfunction><void_ptr>phfunc
    cdef int pi = 0
    cdef cydriver.CUfunction_attribute cyattrib = attrib.value
    with nogil:
        err = cydriver.cuFuncGetAttribute(&pi, cyattrib, cyhfunc)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pi)
{{endif}}

{{if 'cuFuncSetAttribute' in found_functions}}

@cython.embedsignature(True)
def cuFuncSetAttribute(hfunc, attrib not None : CUfunction_attribute, int value):
    """ Sets information about a function.

    This call sets the value of a specified attribute `attrib` on the
    kernel given by `hfunc` to an integer value specified by `val` This
    function returns CUDA_SUCCESS if the new value of the attribute could
    be successfully set. If the set fails, this call will return an error.
    Not all attributes can have values set. Attempting to set a value on a
    read-only attribute will result in an error (CUDA_ERROR_INVALID_VALUE)

    Supported attributes for the cuFuncSetAttribute call are:

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES`: This
      maximum size in bytes of dynamically-allocated shared memory. The
      value should contain the requested maximum size of dynamically-
      allocated shared memory. The sum of this value and the function
      attribute :py:obj:`~.CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES` cannot
      exceed the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN`.
      The maximal size of requestable dynamic shared memory may differ by
      GPU architecture.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT`: On
      devices where the L1 cache and shared memory use the same hardware
      resources, this sets the shared memory carveout preference, in
      percent of the total shared memory. See
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR`
      This is only a hint, and the driver can choose a different ratio if
      required to execute the function.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH`: The required
      cluster width in blocks. The width, height, and depth values must
      either all be 0 or all be positive. The validity of the cluster
      dimensions is checked at launch time. If the value is set during
      compile time, it cannot be set at runtime. Setting it at runtime will
      return CUDA_ERROR_NOT_PERMITTED.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT`: The required
      cluster height in blocks. The width, height, and depth values must
      either all be 0 or all be positive. The validity of the cluster
      dimensions is checked at launch time. If the value is set during
      compile time, it cannot be set at runtime. Setting it at runtime will
      return CUDA_ERROR_NOT_PERMITTED.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH`: The required
      cluster depth in blocks. The width, height, and depth values must
      either all be 0 or all be positive. The validity of the cluster
      dimensions is checked at launch time. If the value is set during
      compile time, it cannot be set at runtime. Setting it at runtime will
      return CUDA_ERROR_NOT_PERMITTED.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED`:
      Indicates whether the function can be launched with non-portable
      cluster size. 1 is allowed, 0 is disallowed.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE`:
      The block scheduling policy of a function. The value type is
      CUclusterSchedulingPolicy.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Function to query attribute of
    attrib : :py:obj:`~.CUfunction_attribute`
        Attribute requested
    value : int
        The value to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cudaFuncGetAttributes`, :py:obj:`~.cudaFuncSetAttribute`, :py:obj:`~.cuKernelSetAttribute`
    """
    cdef cydriver.CUfunction cyhfunc
    if hfunc is None:
        phfunc = 0
    elif isinstance(hfunc, (CUfunction,)):
        phfunc = int(hfunc)
    else:
        phfunc = int(CUfunction(hfunc))
    cyhfunc = <cydriver.CUfunction><void_ptr>phfunc
    cdef cydriver.CUfunction_attribute cyattrib = attrib.value
    with nogil:
        err = cydriver.cuFuncSetAttribute(cyhfunc, cyattrib, value)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuFuncSetCacheConfig' in found_functions}}

@cython.embedsignature(True)
def cuFuncSetCacheConfig(hfunc, config not None : CUfunc_cache):
    """ Sets the preferred cache configuration for a device function.

    On devices where the L1 cache and shared memory use the same hardware
    resources, this sets through `config` the preferred cache configuration
    for the device function `hfunc`. This is only a preference. The driver
    will use the requested configuration if possible, but it is free to
    choose a different configuration if required to execute `hfunc`. Any
    context-wide preference set via :py:obj:`~.cuCtxSetCacheConfig()` will
    be overridden by this per-function setting unless the per-function
    setting is :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE`. In that case, the
    current context-wide setting will be used.

    This setting does nothing on devices where the size of the L1 cache and
    shared memory are fixed.

    Launching a kernel with a different preference than the most recent
    preference setting may insert a device-side synchronization point.

    The supported cache configurations are:

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE`: no preference for shared
      memory or L1 (default)

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_SHARED`: prefer larger shared memory
      and smaller L1 cache

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_L1`: prefer larger L1 cache and
      smaller shared memory

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_EQUAL`: prefer equal sized L1 cache
      and shared memory

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Kernel to configure cache for
    config : :py:obj:`~.CUfunc_cache`
        Requested cache configuration

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cudaFuncSetCacheConfig`, :py:obj:`~.cuKernelSetCacheConfig`
    """
    cdef cydriver.CUfunction cyhfunc
    if hfunc is None:
        phfunc = 0
    elif isinstance(hfunc, (CUfunction,)):
        phfunc = int(hfunc)
    else:
        phfunc = int(CUfunction(hfunc))
    cyhfunc = <cydriver.CUfunction><void_ptr>phfunc
    cdef cydriver.CUfunc_cache cyconfig = config.value
    with nogil:
        err = cydriver.cuFuncSetCacheConfig(cyhfunc, cyconfig)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuFuncGetModule' in found_functions}}

@cython.embedsignature(True)
def cuFuncGetModule(hfunc):
    """ Returns a module handle.

    Returns in `*hmod` the handle of the module that function `hfunc` is
    located in. The lifetime of the module corresponds to the lifetime of
    the context it was loaded in or until the module is explicitly
    unloaded.

    The CUDA runtime manages its own modules loaded into the primary
    context. If the handle returned by this API refers to a module loaded
    by the CUDA runtime, calling :py:obj:`~.cuModuleUnload()` on that
    module will result in undefined behavior.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Function to retrieve module for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
    hmod : :py:obj:`~.CUmodule`
        Returned module handle
    """
    cdef cydriver.CUfunction cyhfunc
    if hfunc is None:
        phfunc = 0
    elif isinstance(hfunc, (CUfunction,)):
        phfunc = int(hfunc)
    else:
        phfunc = int(CUfunction(hfunc))
    cyhfunc = <cydriver.CUfunction><void_ptr>phfunc
    cdef CUmodule hmod = CUmodule()
    with nogil:
        err = cydriver.cuFuncGetModule(<cydriver.CUmodule*>hmod._pvt_ptr, cyhfunc)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], hmod)
{{endif}}

{{if 'cuFuncGetName' in found_functions}}

@cython.embedsignature(True)
def cuFuncGetName(hfunc):
    """ Returns the function name for a :py:obj:`~.CUfunction` handle.

    Returns in `**name` the function name associated with the function
    handle `hfunc` . The function name is returned as a null-terminated
    string. The returned name is only valid when the function handle is
    valid. If the module is unloaded or reloaded, one must call the API
    again to get the updated name. This API may return a mangled name if
    the function is not declared as having C linkage. If either `**name` or
    `hfunc` is NULL, :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        The function handle to retrieve the name for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    name : bytes
        The returned name of the function
    """
    cdef cydriver.CUfunction cyhfunc
    if hfunc is None:
        phfunc = 0
    elif isinstance(hfunc, (CUfunction,)):
        phfunc = int(hfunc)
    else:
        phfunc = int(CUfunction(hfunc))
    cyhfunc = <cydriver.CUfunction><void_ptr>phfunc
    cdef const char* name = NULL
    with nogil:
        err = cydriver.cuFuncGetName(&name, cyhfunc)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], <bytes>name if name != NULL else None)
{{endif}}

{{if 'cuFuncGetParamInfo' in found_functions}}

@cython.embedsignature(True)
def cuFuncGetParamInfo(func, size_t paramIndex):
    """ Returns the offset and size of a kernel parameter in the device-side parameter layout.

    Queries the kernel parameter at `paramIndex` into `func's` list of
    parameters, and returns in `paramOffset` and `paramSize` the offset and
    size, respectively, where the parameter will reside in the device-side
    parameter layout. This information can be used to update kernel node
    parameters from the device via
    :py:obj:`~.cudaGraphKernelNodeSetParam()` and
    :py:obj:`~.cudaGraphKernelNodeUpdatesApply()`. `paramIndex` must be
    less than the number of parameters that `func` takes. `paramSize` can
    be set to NULL if only the parameter offset is desired.

    Parameters
    ----------
    func : :py:obj:`~.CUfunction`
        The function to query
    paramIndex : size_t
        The parameter index to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    paramOffset : int
        Returns the offset into the device-side parameter layout at which
        the parameter resides
    paramSize : int
        Optionally returns the size of the parameter in the device-side
        parameter layout

    See Also
    --------
    :py:obj:`~.cuKernelGetParamInfo`
    """
    cdef cydriver.CUfunction cyfunc
    if func is None:
        pfunc = 0
    elif isinstance(func, (CUfunction,)):
        pfunc = int(func)
    else:
        pfunc = int(CUfunction(func))
    cyfunc = <cydriver.CUfunction><void_ptr>pfunc
    cdef size_t paramOffset = 0
    cdef size_t paramSize = 0
    with nogil:
        err = cydriver.cuFuncGetParamInfo(cyfunc, paramIndex, &paramOffset, &paramSize)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], paramOffset, paramSize)
{{endif}}

{{if 'cuFuncIsLoaded' in found_functions}}

@cython.embedsignature(True)
def cuFuncIsLoaded(function):
    """ Returns if the function is loaded.

    Returns in `state` the loading state of `function`.

    Parameters
    ----------
    function : :py:obj:`~.CUfunction`
        the function to check

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    state : :py:obj:`~.CUfunctionLoadingState`
        returned loading state

    See Also
    --------
    :py:obj:`~.cuFuncLoad`, :py:obj:`~.cuModuleEnumerateFunctions`
    """
    cdef cydriver.CUfunction cyfunction
    if function is None:
        pfunction = 0
    elif isinstance(function, (CUfunction,)):
        pfunction = int(function)
    else:
        pfunction = int(CUfunction(function))
    cyfunction = <cydriver.CUfunction><void_ptr>pfunction
    cdef cydriver.CUfunctionLoadingState state
    with nogil:
        err = cydriver.cuFuncIsLoaded(&state, cyfunction)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], CUfunctionLoadingState(state))
{{endif}}

{{if 'cuFuncLoad' in found_functions}}

@cython.embedsignature(True)
def cuFuncLoad(function):
    """ Loads a function.

    Finalizes function loading for `function`. Calling this API with a
    fully loaded function has no effect.

    Parameters
    ----------
    function : :py:obj:`~.CUfunction`
        the function to load

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuModuleEnumerateFunctions`, :py:obj:`~.cuFuncIsLoaded`
    """
    cdef cydriver.CUfunction cyfunction
    if function is None:
        pfunction = 0
    elif isinstance(function, (CUfunction,)):
        pfunction = int(function)
    else:
        pfunction = int(CUfunction(function))
    cyfunction = <cydriver.CUfunction><void_ptr>pfunction
    with nogil:
        err = cydriver.cuFuncLoad(cyfunction)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuLaunchKernel' in found_functions}}

@cython.embedsignature(True)
def cuLaunchKernel(f, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, hStream, kernelParams, void_ptr extra):
    """ Launches a CUDA function :py:obj:`~.CUfunction` or a CUDA kernel :py:obj:`~.CUkernel`.

    Invokes the function :py:obj:`~.CUfunction` or the kernel
    :py:obj:`~.CUkernel` `f` on a `gridDimX` x `gridDimY` x `gridDimZ` grid
    of blocks. Each block contains `blockDimX` x `blockDimY` x `blockDimZ`
    threads.

    `sharedMemBytes` sets the amount of dynamic shared memory that will be
    available to each thread block.

    Kernel parameters to `f` can be specified in one of two ways:

    1) Kernel parameters can be specified via `kernelParams`. If `f` has N
    parameters, then `kernelParams` needs to be an array of N pointers.
    Each of `kernelParams`[0] through `kernelParams`[N-1] must point to a
    region of memory from which the actual kernel parameter will be copied.
    The number of kernel parameters and their offsets and sizes do not need
    to be specified as that information is retrieved directly from the
    kernel's image.

    2) Kernel parameters can also be packaged by the application into a
    single buffer that is passed in via the `extra` parameter. This places
    the burden on the application of knowing each kernel parameter's size
    and alignment/padding within the buffer. Here is an example of using
    the `extra` parameter in this manner:

    **View CUDA Toolkit Documentation for a C++ code example**

    The `extra` parameter exists to allow :py:obj:`~.cuLaunchKernel` to
    take additional less commonly used arguments. `extra` specifies a list
    of names of extra settings and their corresponding values. Each extra
    setting name is immediately followed by the corresponding value. The
    list must be terminated with either NULL or
    :py:obj:`~.CU_LAUNCH_PARAM_END`.

    - :py:obj:`~.CU_LAUNCH_PARAM_END`, which indicates the end of the
      `extra` array;

    - :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER`, which specifies that the
      next value in `extra` will be a pointer to a buffer containing all
      the kernel parameters for launching kernel `f`;

    - :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_SIZE`, which specifies that the
      next value in `extra` will be a pointer to a size_t containing the
      size of the buffer specified with
      :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER`;

    The error :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned if
    kernel parameters are specified with both `kernelParams` and `extra`
    (i.e. both `kernelParams` and `extra` are non-NULL).

    Calling :py:obj:`~.cuLaunchKernel()` invalidates the persistent
    function state set through the following deprecated APIs:
    :py:obj:`~.cuFuncSetBlockShape()`, :py:obj:`~.cuFuncSetSharedSize()`,
    :py:obj:`~.cuParamSetSize()`, :py:obj:`~.cuParamSeti()`,
    :py:obj:`~.cuParamSetf()`, :py:obj:`~.cuParamSetv()`.

    Note that to use :py:obj:`~.cuLaunchKernel()`, the kernel `f` must
    either have been compiled with toolchain version 3.2 or later so that
    it will contain kernel parameter information, or have no kernel
    parameters. If either of these conditions is not met, then
    :py:obj:`~.cuLaunchKernel()` will return
    :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`.

    Note that the API can also be used to launch context-less kernel
    :py:obj:`~.CUkernel` by querying the handle using
    :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
    casting to :py:obj:`~.CUfunction`. Here, the context to launch the
    kernel on will either be taken from the specified stream `hStream` or
    the current context in case of NULL stream.

    Parameters
    ----------
    f : :py:obj:`~.CUfunction`
        Function :py:obj:`~.CUfunction` or Kernel :py:obj:`~.CUkernel` to
        launch
    gridDimX : unsigned int
        Width of grid in blocks
    gridDimY : unsigned int
        Height of grid in blocks
    gridDimZ : unsigned int
        Depth of grid in blocks
    blockDimX : unsigned int
        X dimension of each thread block
    blockDimY : unsigned int
        Y dimension of each thread block
    blockDimZ : unsigned int
        Z dimension of each thread block
    sharedMemBytes : unsigned int
        Dynamic shared-memory size per thread block in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier
    kernelParams : Any
        Array of pointers to kernel parameters
    extra : list[Any]
        Extra options

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`

    See Also
    --------
    :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cudaLaunchKernel`, :py:obj:`~.cuLibraryGetKernel`, :py:obj:`~.cuKernelSetCacheConfig`, :py:obj:`~.cuKernelGetAttribute`, :py:obj:`~.cuKernelSetAttribute`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUfunction cyf
    if f is None:
        pf = 0
    elif isinstance(f, (CUfunction,)):
        pf = int(f)
    else:
        pf = int(CUfunction(f))
    cyf = <cydriver.CUfunction><void_ptr>pf
    cykernelParams = _HelperKernelParams(kernelParams)
    cdef void** cykernelParams_ptr = <void**><void_ptr>cykernelParams.ckernelParams
    with nogil:
        err = cydriver.cuLaunchKernel(cyf, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, cyhStream, cykernelParams_ptr, <void**>extra)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuLaunchKernelEx' in found_functions}}

@cython.embedsignature(True)
def cuLaunchKernelEx(config : Optional[CUlaunchConfig], f, kernelParams, void_ptr extra):
    """ Launches a CUDA function :py:obj:`~.CUfunction` or a CUDA kernel :py:obj:`~.CUkernel` with launch-time configuration.

    Invokes the function :py:obj:`~.CUfunction` or the kernel
    :py:obj:`~.CUkernel` `f` with the specified launch-time configuration
    `config`.

    The :py:obj:`~.CUlaunchConfig` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.CUlaunchConfig.gridDimX` is the width of the grid in
      blocks.

    - :py:obj:`~.CUlaunchConfig.gridDimY` is the height of the grid in
      blocks.

    - :py:obj:`~.CUlaunchConfig.gridDimZ` is the depth of the grid in
      blocks.

    - :py:obj:`~.CUlaunchConfig.blockDimX` is the X dimension of each
      thread block.

    - :py:obj:`~.CUlaunchConfig.blockDimX` is the Y dimension of each
      thread block.

    - :py:obj:`~.CUlaunchConfig.blockDimZ` is the Z dimension of each
      thread block.

    - :py:obj:`~.CUlaunchConfig.sharedMemBytes` is the dynamic shared-
      memory size per thread block in bytes.

    - :py:obj:`~.CUlaunchConfig.hStream` is the handle to the stream to
      perform the launch in. The CUDA context associated with this stream
      must match that associated with function f.

    - :py:obj:`~.CUlaunchConfig.attrs` is an array of
      :py:obj:`~.CUlaunchConfig.numAttrs` continguous
      :py:obj:`~.CUlaunchAttribute` elements. The value of this pointer is
      not considered if :py:obj:`~.CUlaunchConfig.numAttrs` is zero.
      However, in that case, it is recommended to set the pointer to NULL.

    - :py:obj:`~.CUlaunchConfig.numAttrs` is the number of attributes
      populating the first :py:obj:`~.CUlaunchConfig.numAttrs` positions of
      the :py:obj:`~.CUlaunchConfig.attrs` array.

    Launch-time configuration is specified by adding entries to
    :py:obj:`~.CUlaunchConfig.attrs`. Each entry is an attribute ID and a
    corresponding attribute value.

    The :py:obj:`~.CUlaunchAttribute` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.CUlaunchAttribute.id` is a unique enum identifying the
      attribute.

    - :py:obj:`~.CUlaunchAttribute.value` is a union that hold the
      attribute value.

    An example of using the `config` parameter:

    **View CUDA Toolkit Documentation for a C++ code example**

    The :py:obj:`~.CUlaunchAttributeID` enum is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    and the corresponding :py:obj:`~.CUlaunchAttributeValue` union as :

    **View CUDA Toolkit Documentation for a C++ code example**

    Setting :py:obj:`~.CU_LAUNCH_ATTRIBUTE_COOPERATIVE` to a non-zero value
    causes the kernel launch to be a cooperative launch, with exactly the
    same usage and semantics of :py:obj:`~.cuLaunchCooperativeKernel`.

    Setting
    :py:obj:`~.CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION` to a
    non-zero values causes the kernel to use programmatic means to resolve
    its stream dependency -- enabling the CUDA runtime to opportunistically
    allow the grid's execution to overlap with the previous kernel in the
    stream, if that kernel requests the overlap.

    :py:obj:`~.CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT` records an event
    along with the kernel launch. Event recorded through this launch
    attribute is guaranteed to only trigger after all block in the
    associated kernel trigger the event. A block can trigger the event
    through PTX launchdep.release or CUDA builtin function
    cudaTriggerProgrammaticLaunchCompletion(). A trigger can also be
    inserted at the beginning of each block's execution if
    triggerAtBlockStart is set to non-0. Note that dependents (including
    the CPU thread calling :py:obj:`~.cuEventSynchronize()`) are not
    guaranteed to observe the release precisely when it is released. For
    example, :py:obj:`~.cuEventSynchronize()` may only observe the event
    trigger long after the associated kernel has completed. This recording
    type is primarily meant for establishing programmatic dependency
    between device tasks. The event supplied must not be an interprocess or
    interop event. The event must disable timing (i.e. created with
    :py:obj:`~.CU_EVENT_DISABLE_TIMING` flag set).

    :py:obj:`~.CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT` records an
    event along with the kernel launch. Nominally, the event is triggered
    once all blocks of the kernel have begun execution. Currently this is a
    best effort. If a kernel B has a launch completion dependency on a
    kernel A, B may wait until A is complete. Alternatively, blocks of B
    may begin before all blocks of A have begun, for example:

    - If B can claim execution resources unavailable to A, for example if
      they run on different GPUs.

    - If B is a higher priority than A.

    Exercise caution if such an ordering inversion could lead to deadlock.
    The event supplied must not be an interprocess or interop event. The
    event must disable timing (i.e. must be created with the
    :py:obj:`~.CU_EVENT_DISABLE_TIMING` flag set).

    Setting :py:obj:`~.CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE` to
    1 on a captured launch causes the resulting kernel node to be device-
    updatable. This attribute is specific to graphs, and passing it to a
    launch in a non-capturing stream results in an error. Passing a value
    other than 0 or 1 is not allowed.

    On success, a handle will be returned via
    :py:obj:`~.CUlaunchAttributeValue`::deviceUpdatableKernelNode::devNode
    which can be passed to the various device-side update functions to
    update the node's kernel parameters from within another kernel. For
    more information on the types of device updates that can be made, as
    well as the relevant limitations thereof, see
    :py:obj:`~.cudaGraphKernelNodeUpdatesApply`.

    Kernel nodes which are device-updatable have additional restrictions
    compared to regular kernel nodes. Firstly, device-updatable nodes
    cannot be removed from their graph via :py:obj:`~.cuGraphDestroyNode`.
    Additionally, once opted-in to this functionality, a node cannot opt
    out, and any attempt to set the attribute to 0 will result in an error.
    Graphs containing one or more device-updatable node also do not allow
    multiple instantiation.

    :py:obj:`~.CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION` allows the
    kernel launch to specify a preferred substitute cluster dimension.
    Blocks may be grouped according to either the dimensions specified with
    this attribute (grouped into a "preferred substitute cluster"), or the
    one specified with :py:obj:`~.CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION`
    attribute (grouped into a "regular cluster"). The cluster dimensions of
    a "preferred substitute cluster" shall be an integer multiple greater
    than zero of the regular cluster dimensions. The device will attempt -
    on a best-effort basis - to group thread blocks into preferred clusters
    over grouping them into regular clusters. When it deems necessary
    (primarily when the device temporarily runs out of physical resources
    to launch the larger preferred clusters), the device may switch to
    launch the regular clusters instead to attempt to utilize as much of
    the physical device resources as possible.

    Each type of cluster will have its enumeration / coordinate setup as if
    the grid consists solely of its type of cluster. For example, if the
    preferred substitute cluster dimensions double the regular cluster
    dimensions, there might be simultaneously a regular cluster indexed at
    (1,0,0), and a preferred cluster indexed at (1,0,0). In this example,
    the preferred substitute cluster (1,0,0) replaces regular clusters
    (2,0,0) and (3,0,0) and groups their blocks.

    This attribute will only take effect when a regular cluster dimension
    has been specified. The preferred substitute The preferred substitute
    cluster dimension must be an integer multiple greater than zero of the
    regular cluster dimension and must divide the grid. It must also be no
    more than `maxBlocksPerCluster`, if it is set in the kernel's
    `__launch_bounds__`. Otherwise it must be less than the maximum value
    the driver can support. Otherwise, setting this attribute to a value
    physically unable to fit on any particular device is permitted.

    The effect of other attributes is consistent with their effect when set
    via persistent APIs.

    See :py:obj:`~.cuStreamSetAttribute` for

    - :py:obj:`~.CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW`

    - :py:obj:`~.CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY`

    See :py:obj:`~.cuFuncSetAttribute` for

    - :py:obj:`~.CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION`

    - :py:obj:`~.CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE`

    Kernel parameters to `f` can be specified in the same ways that they
    can be using :py:obj:`~.cuLaunchKernel`.

    Note that the API can also be used to launch context-less kernel
    :py:obj:`~.CUkernel` by querying the handle using
    :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
    casting to :py:obj:`~.CUfunction`. Here, the context to launch the
    kernel on will either be taken from the specified stream
    :py:obj:`~.CUlaunchConfig.hStream` or the current context in case of
    NULL stream.

    Parameters
    ----------
    config : :py:obj:`~.CUlaunchConfig`
        Config to launch
    f : :py:obj:`~.CUfunction`
        Function :py:obj:`~.CUfunction` or Kernel :py:obj:`~.CUkernel` to
        launch
    kernelParams : Any
        Array of pointers to kernel parameters
    extra : list[Any]
        Extra options

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`

    See Also
    --------
    :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cudaLaunchKernel`, :py:obj:`~.cudaLaunchKernelEx`, :py:obj:`~.cuLibraryGetKernel`, :py:obj:`~.cuKernelSetCacheConfig`, :py:obj:`~.cuKernelGetAttribute`, :py:obj:`~.cuKernelSetAttribute`
    """
    cdef cydriver.CUfunction cyf
    if f is None:
        pf = 0
    elif isinstance(f, (CUfunction,)):
        pf = int(f)
    else:
        pf = int(CUfunction(f))
    cyf = <cydriver.CUfunction><void_ptr>pf
    cdef cydriver.CUlaunchConfig* cyconfig_ptr = config._pvt_ptr if config is not None else NULL
    cykernelParams = _HelperKernelParams(kernelParams)
    cdef void** cykernelParams_ptr = <void**><void_ptr>cykernelParams.ckernelParams
    with nogil:
        err = cydriver.cuLaunchKernelEx(cyconfig_ptr, cyf, cykernelParams_ptr, <void**>extra)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuLaunchCooperativeKernel' in found_functions}}

@cython.embedsignature(True)
def cuLaunchCooperativeKernel(f, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, hStream, kernelParams):
    """ Launches a CUDA function :py:obj:`~.CUfunction` or a CUDA kernel :py:obj:`~.CUkernel` where thread blocks can cooperate and synchronize as they execute.

    Invokes the function :py:obj:`~.CUfunction` or the kernel
    :py:obj:`~.CUkernel` `f` on a `gridDimX` x `gridDimY` x `gridDimZ` grid
    of blocks. Each block contains `blockDimX` x `blockDimY` x `blockDimZ`
    threads.

    `sharedMemBytes` sets the amount of dynamic shared memory that will be
    available to each thread block.

    The device on which this kernel is invoked must have a non-zero value
    for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH`.

    The total number of blocks launched cannot exceed the maximum number of
    blocks per multiprocessor as returned by
    :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessor` (or
    :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags`) times
    the number of multiprocessors as specified by the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT`.

    The kernel cannot make use of CUDA dynamic parallelism.

    Kernel parameters must be specified via `kernelParams`. If `f` has N
    parameters, then `kernelParams` needs to be an array of N pointers.
    Each of `kernelParams`[0] through `kernelParams`[N-1] must point to a
    region of memory from which the actual kernel parameter will be copied.
    The number of kernel parameters and their offsets and sizes do not need
    to be specified as that information is retrieved directly from the
    kernel's image.

    Calling :py:obj:`~.cuLaunchCooperativeKernel()` sets persistent
    function state that is the same as function state set through
    :py:obj:`~.cuLaunchKernel` API

    When the kernel `f` is launched via
    :py:obj:`~.cuLaunchCooperativeKernel()`, the previous block shape,
    shared size and parameter info associated with `f` is overwritten.

    Note that to use :py:obj:`~.cuLaunchCooperativeKernel()`, the kernel
    `f` must either have been compiled with toolchain version 3.2 or later
    so that it will contain kernel parameter information, or have no kernel
    parameters. If either of these conditions is not met, then
    :py:obj:`~.cuLaunchCooperativeKernel()` will return
    :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`.

    Note that the API can also be used to launch context-less kernel
    :py:obj:`~.CUkernel` by querying the handle using
    :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
    casting to :py:obj:`~.CUfunction`. Here, the context to launch the
    kernel on will either be taken from the specified stream `hStream` or
    the current context in case of NULL stream.

    Parameters
    ----------
    f : :py:obj:`~.CUfunction`
        Function :py:obj:`~.CUfunction` or Kernel :py:obj:`~.CUkernel` to
        launch
    gridDimX : unsigned int
        Width of grid in blocks
    gridDimY : unsigned int
        Height of grid in blocks
    gridDimZ : unsigned int
        Depth of grid in blocks
    blockDimX : unsigned int
        X dimension of each thread block
    blockDimY : unsigned int
        Y dimension of each thread block
    blockDimZ : unsigned int
        Z dimension of each thread block
    sharedMemBytes : unsigned int
        Dynamic shared-memory size per thread block in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier
    kernelParams : Any
        Array of pointers to kernel parameters

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`

    See Also
    --------
    :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuLaunchCooperativeKernelMultiDevice`, :py:obj:`~.cudaLaunchCooperativeKernel`, :py:obj:`~.cuLibraryGetKernel`, :py:obj:`~.cuKernelSetCacheConfig`, :py:obj:`~.cuKernelGetAttribute`, :py:obj:`~.cuKernelSetAttribute`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUfunction cyf
    if f is None:
        pf = 0
    elif isinstance(f, (CUfunction,)):
        pf = int(f)
    else:
        pf = int(CUfunction(f))
    cyf = <cydriver.CUfunction><void_ptr>pf
    cykernelParams = _HelperKernelParams(kernelParams)
    cdef void** cykernelParams_ptr = <void**><void_ptr>cykernelParams.ckernelParams
    with nogil:
        err = cydriver.cuLaunchCooperativeKernel(cyf, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, cyhStream, cykernelParams_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuLaunchCooperativeKernelMultiDevice' in found_functions}}

@cython.embedsignature(True)
def cuLaunchCooperativeKernelMultiDevice(launchParamsList : Optional[tuple[CUDA_LAUNCH_PARAMS] | list[CUDA_LAUNCH_PARAMS]], unsigned int numDevices, unsigned int flags):
    """ Launches CUDA functions on multiple devices where thread blocks can cooperate and synchronize as they execute.

    [Deprecated]

    Invokes kernels as specified in the `launchParamsList` array where each
    element of the array specifies all the parameters required to perform a
    single kernel launch. These kernels can cooperate and synchronize as
    they execute. The size of the array is specified by `numDevices`.

    No two kernels can be launched on the same device. All the devices
    targeted by this multi-device launch must be identical. All devices
    must have a non-zero value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH`.

    All kernels launched must be identical with respect to the compiled
    code. Note that any device, constant or managed variables present in
    the module that owns the kernel launched on each device, are
    independently instantiated on every device. It is the application's
    responsibility to ensure these variables are initialized and used
    appropriately.

    The size of the grids as specified in blocks, the size of the blocks
    themselves and the amount of shared memory used by each thread block
    must also match across all launched kernels.

    The streams used to launch these kernels must have been created via
    either :py:obj:`~.cuStreamCreate` or
    :py:obj:`~.cuStreamCreateWithPriority`. The NULL stream or
    :py:obj:`~.CU_STREAM_LEGACY` or :py:obj:`~.CU_STREAM_PER_THREAD` cannot
    be used.

    The total number of blocks launched per kernel cannot exceed the
    maximum number of blocks per multiprocessor as returned by
    :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessor` (or
    :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags`) times
    the number of multiprocessors as specified by the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT`. Since the total
    number of blocks launched per device has to match across all devices,
    the maximum number of blocks that can be launched per device will be
    limited by the device with the least number of multiprocessors.

    The kernels cannot make use of CUDA dynamic parallelism.

    The :py:obj:`~.CUDA_LAUNCH_PARAMS` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.function` specifies the kernel to be
      launched. All functions must be identical with respect to the
      compiled code. Note that you can also specify context-less kernel
      :py:obj:`~.CUkernel` by querying the handle using
      :py:obj:`~.cuLibraryGetKernel()` and then casting to
      :py:obj:`~.CUfunction`. In this case, the context to launch the
      kernel on be taken from the specified stream
      :py:obj:`~.CUDA_LAUNCH_PARAMS.hStream`.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.gridDimX` is the width of the grid in
      blocks. This must match across all kernels launched.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.gridDimY` is the height of the grid in
      blocks. This must match across all kernels launched.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.gridDimZ` is the depth of the grid in
      blocks. This must match across all kernels launched.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.blockDimX` is the X dimension of each
      thread block. This must match across all kernels launched.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.blockDimX` is the Y dimension of each
      thread block. This must match across all kernels launched.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.blockDimZ` is the Z dimension of each
      thread block. This must match across all kernels launched.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.sharedMemBytes` is the dynamic shared-
      memory size per thread block in bytes. This must match across all
      kernels launched.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.hStream` is the handle to the stream to
      perform the launch in. This cannot be the NULL stream or
      :py:obj:`~.CU_STREAM_LEGACY` or :py:obj:`~.CU_STREAM_PER_THREAD`. The
      CUDA context associated with this stream must match that associated
      with :py:obj:`~.CUDA_LAUNCH_PARAMS.function`.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.kernelParams` is an array of pointers
      to kernel parameters. If :py:obj:`~.CUDA_LAUNCH_PARAMS.function` has
      N parameters, then :py:obj:`~.CUDA_LAUNCH_PARAMS.kernelParams` needs
      to be an array of N pointers. Each of
      :py:obj:`~.CUDA_LAUNCH_PARAMS.kernelParams`[0] through
      :py:obj:`~.CUDA_LAUNCH_PARAMS.kernelParams`[N-1] must point to a
      region of memory from which the actual kernel parameter will be
      copied. The number of kernel parameters and their offsets and sizes
      do not need to be specified as that information is retrieved directly
      from the kernel's image.

    By default, the kernel won't begin execution on any GPU until all prior
    work in all the specified streams has completed. This behavior can be
    overridden by specifying the flag
    :py:obj:`~.CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC`.
    When this flag is specified, each kernel will only wait for prior work
    in the stream corresponding to that GPU to complete before it begins
    execution.

    Similarly, by default, any subsequent work pushed in any of the
    specified streams will not begin execution until the kernels on all
    GPUs have completed. This behavior can be overridden by specifying the
    flag
    :py:obj:`~.CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC`.
    When this flag is specified, any subsequent work pushed in any of the
    specified streams will only wait for the kernel launched on the GPU
    corresponding to that stream to complete before it begins execution.

    Calling :py:obj:`~.cuLaunchCooperativeKernelMultiDevice()` sets
    persistent function state that is the same as function state set
    through :py:obj:`~.cuLaunchKernel` API when called individually for
    each element in `launchParamsList`.

    When kernels are launched via
    :py:obj:`~.cuLaunchCooperativeKernelMultiDevice()`, the previous block
    shape, shared size and parameter info associated with each
    :py:obj:`~.CUDA_LAUNCH_PARAMS.function` in `launchParamsList` is
    overwritten.

    Note that to use :py:obj:`~.cuLaunchCooperativeKernelMultiDevice()`,
    the kernels must either have been compiled with toolchain version 3.2
    or later so that it will contain kernel parameter information, or have
    no kernel parameters. If either of these conditions is not met, then
    :py:obj:`~.cuLaunchCooperativeKernelMultiDevice()` will return
    :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`.

    Parameters
    ----------
    launchParamsList : list[:py:obj:`~.CUDA_LAUNCH_PARAMS`]
        List of launch parameters, one per device
    numDevices : unsigned int
        Size of the `launchParamsList` array
    flags : unsigned int
        Flags to control launch behavior

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`

    See Also
    --------
    :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuLaunchCooperativeKernel`, :py:obj:`~.cudaLaunchCooperativeKernelMultiDevice`
    """
    launchParamsList = [] if launchParamsList is None else launchParamsList
    if not all(isinstance(_x, (CUDA_LAUNCH_PARAMS,)) for _x in launchParamsList):
        raise TypeError("Argument 'launchParamsList' is not instance of type (expected tuple[cydriver.CUDA_LAUNCH_PARAMS,] or list[cydriver.CUDA_LAUNCH_PARAMS,]")
    cdef cydriver.CUDA_LAUNCH_PARAMS* cylaunchParamsList = NULL
    if len(launchParamsList) > 1:
        cylaunchParamsList = <cydriver.CUDA_LAUNCH_PARAMS*> calloc(len(launchParamsList), sizeof(cydriver.CUDA_LAUNCH_PARAMS))
        if cylaunchParamsList is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(launchParamsList)) + 'x' + str(sizeof(cydriver.CUDA_LAUNCH_PARAMS)))
        for idx in range(len(launchParamsList)):
            string.memcpy(&cylaunchParamsList[idx], (<CUDA_LAUNCH_PARAMS>launchParamsList[idx])._pvt_ptr, sizeof(cydriver.CUDA_LAUNCH_PARAMS))
    elif len(launchParamsList) == 1:
        cylaunchParamsList = (<CUDA_LAUNCH_PARAMS>launchParamsList[0])._pvt_ptr
    if numDevices > len(launchParamsList): raise RuntimeError("List is too small: " + str(len(launchParamsList)) + " < " + str(numDevices))
    with nogil:
        err = cydriver.cuLaunchCooperativeKernelMultiDevice(cylaunchParamsList, numDevices, flags)
    if len(launchParamsList) > 1 and cylaunchParamsList is not NULL:
        free(cylaunchParamsList)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuLaunchHostFunc' in found_functions}}

ctypedef struct cuHostCallbackData_st:
    cydriver.CUhostFn callback
    void *userData

ctypedef cuHostCallbackData_st cuHostCallbackData

@cython.show_performance_hints(False)
cdef void cuHostCallbackWrapper(void *data) nogil:
    cdef cuHostCallbackData *cbData = <cuHostCallbackData *>data
    with gil:
        cbData.callback(cbData.userData)
    free(cbData)

@cython.embedsignature(True)
def cuLaunchHostFunc(hStream, fn, userData):
    """ Enqueues a host function call in a stream.

    Enqueues a host function to run in a stream. The function will be
    called after currently enqueued work and will block work added after
    it.

    The host function must not make any CUDA API calls. Attempting to use a
    CUDA API may result in :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, but this
    is not required. The host function must not perform any synchronization
    that may depend on outstanding CUDA work not mandated to run earlier.
    Host functions without a mandated order (such as in independent
    streams) execute in undefined order and may be serialized.

    For the purposes of Unified Memory, execution makes a number of
    guarantees:

    - The stream is considered idle for the duration of the function's
      execution. Thus, for example, the function may always use memory
      attached to the stream it was enqueued in.

    - The start of execution of the function has the same effect as
      synchronizing an event recorded in the same stream immediately prior
      to the function. It thus synchronizes streams which have been
      "joined" prior to the function.

    - Adding device work to any stream does not have the effect of making
      the stream active until all preceding host functions and stream
      callbacks have executed. Thus, for example, a function might use
      global attached memory even if work has been added to another stream,
      if the work has been ordered behind the function call with an event.

    - Completion of the function does not cause a stream to become active
      except as described above. The stream will remain idle if no device
      work follows the function, and will remain idle across consecutive
      host functions or stream callbacks without device work in between.
      Thus, for example, stream synchronization can be done by signaling
      from a host function at the end of the stream.

    Note that, in contrast to :py:obj:`~.cuStreamAddCallback`, the function
    will not be called in the event of an error in the CUDA context.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to enqueue function call in
    fn : :py:obj:`~.CUhostFn`
        The function to call once preceding stream operations are complete
    userData : Any
        User-specified data to be passed to the function

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuMemAllocManaged`, :py:obj:`~.cuStreamAttachMemAsync`, :py:obj:`~.cuStreamAddCallback`
    """
    cdef cydriver.CUhostFn cyfn
    if fn is None:
        pfn = 0
    elif isinstance(fn, (CUhostFn,)):
        pfn = int(fn)
    else:
        pfn = int(CUhostFn(fn))
    cyfn = <cydriver.CUhostFn><void_ptr>pfn
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cyuserData = _HelperInputVoidPtr(userData)
    cdef void* cyuserData_ptr = <void*><void_ptr>cyuserData.cptr

    cdef cuHostCallbackData *cbData = NULL
    cbData = <cuHostCallbackData *>malloc(sizeof(cbData[0]))
    if cbData == NULL:
        return (CUresult.CUDA_ERROR_OUT_OF_MEMORY,)
    cbData.callback = cyfn
    cbData.userData = cyuserData_ptr

    with nogil:
        err = cydriver.cuLaunchHostFunc(cyhStream, <cydriver.CUhostFn>cuHostCallbackWrapper, <void *>cbData)
    if err != cydriver.CUDA_SUCCESS:
        free(cbData)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuFuncSetBlockShape' in found_functions}}

@cython.embedsignature(True)
def cuFuncSetBlockShape(hfunc, int x, int y, int z):
    """ Sets the block-dimensions for the function.

    [Deprecated]

    Specifies the `x`, `y`, and `z` dimensions of the thread blocks that
    are created when the kernel given by `hfunc` is launched.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Kernel to specify dimensions of
    x : int
        X dimension
    y : int
        Y dimension
    z : int
        Z dimension

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """
    cdef cydriver.CUfunction cyhfunc
    if hfunc is None:
        phfunc = 0
    elif isinstance(hfunc, (CUfunction,)):
        phfunc = int(hfunc)
    else:
        phfunc = int(CUfunction(hfunc))
    cyhfunc = <cydriver.CUfunction><void_ptr>phfunc
    with nogil:
        err = cydriver.cuFuncSetBlockShape(cyhfunc, x, y, z)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuFuncSetSharedSize' in found_functions}}

@cython.embedsignature(True)
def cuFuncSetSharedSize(hfunc, unsigned int numbytes):
    """ Sets the dynamic shared-memory size for the function.

    [Deprecated]

    Sets through `numbytes` the amount of dynamic shared memory that will
    be available to each thread block when the kernel given by `hfunc` is
    launched.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Kernel to specify dynamic shared-memory size for
    numbytes : unsigned int
        Dynamic shared-memory size per thread in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """
    cdef cydriver.CUfunction cyhfunc
    if hfunc is None:
        phfunc = 0
    elif isinstance(hfunc, (CUfunction,)):
        phfunc = int(hfunc)
    else:
        phfunc = int(CUfunction(hfunc))
    cyhfunc = <cydriver.CUfunction><void_ptr>phfunc
    with nogil:
        err = cydriver.cuFuncSetSharedSize(cyhfunc, numbytes)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuParamSetSize' in found_functions}}

@cython.embedsignature(True)
def cuParamSetSize(hfunc, unsigned int numbytes):
    """ Sets the parameter size for the function.

    [Deprecated]

    Sets through `numbytes` the total size in bytes needed by the function
    parameters of the kernel corresponding to `hfunc`.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Kernel to set parameter size for
    numbytes : unsigned int
        Size of parameter list in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """
    cdef cydriver.CUfunction cyhfunc
    if hfunc is None:
        phfunc = 0
    elif isinstance(hfunc, (CUfunction,)):
        phfunc = int(hfunc)
    else:
        phfunc = int(CUfunction(hfunc))
    cyhfunc = <cydriver.CUfunction><void_ptr>phfunc
    with nogil:
        err = cydriver.cuParamSetSize(cyhfunc, numbytes)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuParamSeti' in found_functions}}

@cython.embedsignature(True)
def cuParamSeti(hfunc, int offset, unsigned int value):
    """ Adds an integer parameter to the function's argument list.

    [Deprecated]

    Sets an integer parameter that will be specified the next time the
    kernel corresponding to `hfunc` will be invoked. `offset` is a byte
    offset.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Kernel to add parameter to
    offset : int
        Offset to add parameter to argument list
    value : unsigned int
        Value of parameter

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """
    cdef cydriver.CUfunction cyhfunc
    if hfunc is None:
        phfunc = 0
    elif isinstance(hfunc, (CUfunction,)):
        phfunc = int(hfunc)
    else:
        phfunc = int(CUfunction(hfunc))
    cyhfunc = <cydriver.CUfunction><void_ptr>phfunc
    with nogil:
        err = cydriver.cuParamSeti(cyhfunc, offset, value)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuParamSetf' in found_functions}}

@cython.embedsignature(True)
def cuParamSetf(hfunc, int offset, float value):
    """ Adds a floating-point parameter to the function's argument list.

    [Deprecated]

    Sets a floating-point parameter that will be specified the next time
    the kernel corresponding to `hfunc` will be invoked. `offset` is a byte
    offset.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Kernel to add parameter to
    offset : int
        Offset to add parameter to argument list
    value : float
        Value of parameter

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """
    cdef cydriver.CUfunction cyhfunc
    if hfunc is None:
        phfunc = 0
    elif isinstance(hfunc, (CUfunction,)):
        phfunc = int(hfunc)
    else:
        phfunc = int(CUfunction(hfunc))
    cyhfunc = <cydriver.CUfunction><void_ptr>phfunc
    with nogil:
        err = cydriver.cuParamSetf(cyhfunc, offset, value)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuParamSetv' in found_functions}}

@cython.embedsignature(True)
def cuParamSetv(hfunc, int offset, ptr, unsigned int numbytes):
    """ Adds arbitrary data to the function's argument list.

    [Deprecated]

    Copies an arbitrary amount of data (specified in `numbytes`) from `ptr`
    into the parameter space of the kernel corresponding to `hfunc`.
    `offset` is a byte offset.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Kernel to add data to
    offset : int
        Offset to add data to argument list
    ptr : Any
        Pointer to arbitrary data
    numbytes : unsigned int
        Size of data to copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """
    cdef cydriver.CUfunction cyhfunc
    if hfunc is None:
        phfunc = 0
    elif isinstance(hfunc, (CUfunction,)):
        phfunc = int(hfunc)
    else:
        phfunc = int(CUfunction(hfunc))
    cyhfunc = <cydriver.CUfunction><void_ptr>phfunc
    cyptr = _HelperInputVoidPtr(ptr)
    cdef void* cyptr_ptr = <void*><void_ptr>cyptr.cptr
    with nogil:
        err = cydriver.cuParamSetv(cyhfunc, offset, cyptr_ptr, numbytes)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuLaunch' in found_functions}}

@cython.embedsignature(True)
def cuLaunch(f):
    """ Launches a CUDA function.

    [Deprecated]

    Invokes the kernel `f` on a 1 x 1 x 1 grid of blocks. The block
    contains the number of threads specified by a previous call to
    :py:obj:`~.cuFuncSetBlockShape()`.

    The block shape, dynamic shared memory size, and parameter information
    must be set using :py:obj:`~.cuFuncSetBlockShape()`,
    :py:obj:`~.cuFuncSetSharedSize()`, :py:obj:`~.cuParamSetSize()`,
    :py:obj:`~.cuParamSeti()`, :py:obj:`~.cuParamSetf()`, and
    :py:obj:`~.cuParamSetv()` prior to calling this function.

    Launching a function via :py:obj:`~.cuLaunchKernel()` invalidates the
    function's block shape, dynamic shared memory size, and parameter
    information. After launching via cuLaunchKernel, this state must be re-
    initialized prior to calling this function. Failure to do so results in
    undefined behavior.

    Parameters
    ----------
    f : :py:obj:`~.CUfunction`
        Kernel to launch

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`

    See Also
    --------
    :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """
    cdef cydriver.CUfunction cyf
    if f is None:
        pf = 0
    elif isinstance(f, (CUfunction,)):
        pf = int(f)
    else:
        pf = int(CUfunction(f))
    cyf = <cydriver.CUfunction><void_ptr>pf
    with nogil:
        err = cydriver.cuLaunch(cyf)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuLaunchGrid' in found_functions}}

@cython.embedsignature(True)
def cuLaunchGrid(f, int grid_width, int grid_height):
    """ Launches a CUDA function.

    [Deprecated]

    Invokes the kernel `f` on a `grid_width` x `grid_height` grid of
    blocks. Each block contains the number of threads specified by a
    previous call to :py:obj:`~.cuFuncSetBlockShape()`.

    The block shape, dynamic shared memory size, and parameter information
    must be set using :py:obj:`~.cuFuncSetBlockShape()`,
    :py:obj:`~.cuFuncSetSharedSize()`, :py:obj:`~.cuParamSetSize()`,
    :py:obj:`~.cuParamSeti()`, :py:obj:`~.cuParamSetf()`, and
    :py:obj:`~.cuParamSetv()` prior to calling this function.

    Launching a function via :py:obj:`~.cuLaunchKernel()` invalidates the
    function's block shape, dynamic shared memory size, and parameter
    information. After launching via cuLaunchKernel, this state must be re-
    initialized prior to calling this function. Failure to do so results in
    undefined behavior.

    Parameters
    ----------
    f : :py:obj:`~.CUfunction`
        Kernel to launch
    grid_width : int
        Width of grid in blocks
    grid_height : int
        Height of grid in blocks

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`

    See Also
    --------
    :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """
    cdef cydriver.CUfunction cyf
    if f is None:
        pf = 0
    elif isinstance(f, (CUfunction,)):
        pf = int(f)
    else:
        pf = int(CUfunction(f))
    cyf = <cydriver.CUfunction><void_ptr>pf
    with nogil:
        err = cydriver.cuLaunchGrid(cyf, grid_width, grid_height)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuLaunchGridAsync' in found_functions}}

@cython.embedsignature(True)
def cuLaunchGridAsync(f, int grid_width, int grid_height, hStream):
    """ Launches a CUDA function.

    [Deprecated]

    Invokes the kernel `f` on a `grid_width` x `grid_height` grid of
    blocks. Each block contains the number of threads specified by a
    previous call to :py:obj:`~.cuFuncSetBlockShape()`.

    The block shape, dynamic shared memory size, and parameter information
    must be set using :py:obj:`~.cuFuncSetBlockShape()`,
    :py:obj:`~.cuFuncSetSharedSize()`, :py:obj:`~.cuParamSetSize()`,
    :py:obj:`~.cuParamSeti()`, :py:obj:`~.cuParamSetf()`, and
    :py:obj:`~.cuParamSetv()` prior to calling this function.

    Launching a function via :py:obj:`~.cuLaunchKernel()` invalidates the
    function's block shape, dynamic shared memory size, and parameter
    information. After launching via cuLaunchKernel, this state must be re-
    initialized prior to calling this function. Failure to do so results in
    undefined behavior.

    \note_null_stream

    Parameters
    ----------
    f : :py:obj:`~.CUfunction`
        Kernel to launch
    grid_width : int
        Width of grid in blocks
    grid_height : int
        Height of grid in blocks
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`

    See Also
    --------
    :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchKernel`

    Notes
    -----
    In certain cases where cubins are created with no ABI (i.e., using `ptxas` `None` `no`), this function may serialize kernel launches. The CUDA driver retains asynchronous behavior by growing the per-thread stack as needed per launch and not shrinking it afterwards.
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUfunction cyf
    if f is None:
        pf = 0
    elif isinstance(f, (CUfunction,)):
        pf = int(f)
    else:
        pf = int(CUfunction(f))
    cyf = <cydriver.CUfunction><void_ptr>pf
    with nogil:
        err = cydriver.cuLaunchGridAsync(cyf, grid_width, grid_height, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuParamSetTexRef' in found_functions}}

@cython.embedsignature(True)
def cuParamSetTexRef(hfunc, int texunit, hTexRef):
    """ Adds a texture-reference to the function's argument list.

    [Deprecated]

    Makes the CUDA array or linear memory bound to the texture reference
    `hTexRef` available to a device program as a texture. In this version
    of CUDA, the texture-reference must be obtained via
    :py:obj:`~.cuModuleGetTexRef()` and the `texunit` parameter must be set
    to :py:obj:`~.CU_PARAM_TR_DEFAULT`.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Kernel to add texture-reference to
    texunit : int
        Texture unit (must be :py:obj:`~.CU_PARAM_TR_DEFAULT`)
    hTexRef : :py:obj:`~.CUtexref`
        Texture-reference to add to argument list

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef cydriver.CUfunction cyhfunc
    if hfunc is None:
        phfunc = 0
    elif isinstance(hfunc, (CUfunction,)):
        phfunc = int(hfunc)
    else:
        phfunc = int(CUfunction(hfunc))
    cyhfunc = <cydriver.CUfunction><void_ptr>phfunc
    with nogil:
        err = cydriver.cuParamSetTexRef(cyhfunc, texunit, cyhTexRef)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuFuncSetSharedMemConfig' in found_functions}}

@cython.embedsignature(True)
def cuFuncSetSharedMemConfig(hfunc, config not None : CUsharedconfig):
    """ Sets the shared memory configuration for a device function.

    [Deprecated]

    On devices with configurable shared memory banks, this function will
    force all subsequent launches of the specified device function to have
    the given shared memory bank size configuration. On any given launch of
    the function, the shared memory configuration of the device will be
    temporarily changed if needed to suit the function's preferred
    configuration. Changes in shared memory configuration between
    subsequent launches of functions, may introduce a device side
    synchronization point.

    Any per-function setting of shared memory bank size set via
    :py:obj:`~.cuFuncSetSharedMemConfig` will override the context wide
    setting set with :py:obj:`~.cuCtxSetSharedMemConfig`.

    Changing the shared memory bank size will not increase shared memory
    usage or affect occupancy of kernels, but may have major effects on
    performance. Larger bank sizes will allow for greater potential
    bandwidth to shared memory, but will change what kinds of accesses to
    shared memory will result in bank conflicts.

    This function will do nothing on devices with fixed shared memory bank
    size.

    The supported bank configurations are:

    - :py:obj:`~.CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE`: use the context's
      shared memory configuration when launching this function.

    - :py:obj:`~.CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE`: set shared
      memory bank width to be natively four bytes when launching this
      function.

    - :py:obj:`~.CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE`: set shared
      memory bank width to be natively eight bytes when launching this
      function.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        kernel to be given a shared memory config
    config : :py:obj:`~.CUsharedconfig`
        requested shared memory configuration

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxGetSharedMemConfig`, :py:obj:`~.cuCtxSetSharedMemConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cudaFuncSetSharedMemConfig`
    """
    cdef cydriver.CUfunction cyhfunc
    if hfunc is None:
        phfunc = 0
    elif isinstance(hfunc, (CUfunction,)):
        phfunc = int(hfunc)
    else:
        phfunc = int(CUfunction(hfunc))
    cyhfunc = <cydriver.CUfunction><void_ptr>phfunc
    cdef cydriver.CUsharedconfig cyconfig = config.value
    with nogil:
        err = cydriver.cuFuncSetSharedMemConfig(cyhfunc, cyconfig)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphCreate' in found_functions}}

@cython.embedsignature(True)
def cuGraphCreate(unsigned int flags):
    """ Creates a graph.

    Creates an empty graph, which is returned via `phGraph`.

    Parameters
    ----------
    flags : unsigned int
        Graph creation flags, must be 0

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    phGraph : :py:obj:`~.CUgraph`
        Returns newly created graph

    See Also
    --------
    :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`, :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphDestroy`, :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphClone`
    """
    cdef CUgraph phGraph = CUgraph()
    with nogil:
        err = cydriver.cuGraphCreate(<cydriver.CUgraph*>phGraph._pvt_ptr, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraph)
{{endif}}

{{if 'cuGraphAddKernelNode_v2' in found_functions}}

@cython.embedsignature(True)
def cuGraphAddKernelNode(hGraph, dependencies : Optional[tuple[CUgraphNode] | list[CUgraphNode]], size_t numDependencies, nodeParams : Optional[CUDA_KERNEL_NODE_PARAMS]):
    """ Creates a kernel execution node and adds it to a graph.

    Creates a new kernel execution node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and
    arguments specified in `nodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `dependencies` may not have any duplicate entries. A
    handle to the new node will be returned in `phGraphNode`.

    The CUDA_KERNEL_NODE_PARAMS structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    When the graph is launched, the node will invoke kernel `func` on a
    (`gridDimX` x `gridDimY` x `gridDimZ`) grid of blocks. Each block
    contains (`blockDimX` x `blockDimY` x `blockDimZ`) threads.

    `sharedMemBytes` sets the amount of dynamic shared memory that will be
    available to each thread block.

    Kernel parameters to `func` can be specified in one of two ways:

    1) Kernel parameters can be specified via `kernelParams`. If the kernel
    has N parameters, then `kernelParams` needs to be an array of N
    pointers. Each pointer, from `kernelParams`[0] to `kernelParams`[N-1],
    points to the region of memory from which the actual parameter will be
    copied. The number of kernel parameters and their offsets and sizes do
    not need to be specified as that information is retrieved directly from
    the kernel's image.

    2) Kernel parameters for non-cooperative kernels can also be packaged
    by the application into a single buffer that is passed in via `extra`.
    This places the burden on the application of knowing each kernel
    parameter's size and alignment/padding within the buffer. The `extra`
    parameter exists to allow this function to take additional less
    commonly used arguments. `extra` specifies a list of names of extra
    settings and their corresponding values. Each extra setting name is
    immediately followed by the corresponding value. The list must be
    terminated with either NULL or CU_LAUNCH_PARAM_END.

    - :py:obj:`~.CU_LAUNCH_PARAM_END`, which indicates the end of the
      `extra` array;

    - :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER`, which specifies that the
      next value in `extra` will be a pointer to a buffer containing all
      the kernel parameters for launching kernel `func`;

    - :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_SIZE`, which specifies that the
      next value in `extra` will be a pointer to a size_t containing the
      size of the buffer specified with
      :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER`;

    The error :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned if
    kernel parameters are specified with both `kernelParams` and `extra`
    (i.e. both `kernelParams` and `extra` are non-NULL).
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned if `extra` is
    used for a cooperative kernel.

    The `kernelParams` or `extra` array, as well as the argument values it
    points to, are copied during this call.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : list[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    nodeParams : :py:obj:`~.CUDA_KERNEL_NODE_PARAMS`
        Parameters for the GPU execution node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuLaunchCooperativeKernel`, :py:obj:`~.cuGraphKernelNodeGetParams`, :py:obj:`~.cuGraphKernelNodeSetParams`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`

    Notes
    -----
    Kernels launched using graphs must not use texture and surface references. Reading or writing through any texture or surface reference is undefined behavior. This restriction does not apply to texture and surface objects.
    """
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode,)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef cydriver.CUgraphNode* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cydriver.CUgraphNode*> calloc(len(dependencies), sizeof(cydriver.CUgraphNode))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cydriver.CUgraphNode>(<CUgraphNode>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cydriver.CUgraphNode*>(<CUgraphNode>dependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef cydriver.CUDA_KERNEL_NODE_PARAMS* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphAddKernelNode(<cydriver.CUgraphNode*>phGraphNode._pvt_ptr, cyhGraph, cydependencies, numDependencies, cynodeParams_ptr)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraphNode)
{{endif}}

{{if 'cuGraphKernelNodeGetParams_v2' in found_functions}}

@cython.embedsignature(True)
def cuGraphKernelNodeGetParams(hNode):
    """ Returns a kernel node's parameters.

    Returns the parameters of kernel node `hNode` in `nodeParams`. The
    `kernelParams` or `extra` array returned in `nodeParams`, as well as
    the argument values it points to, are owned by the node. This memory
    remains valid until the node is destroyed or its parameters are
    modified, and should not be modified directly. Use
    :py:obj:`~.cuGraphKernelNodeSetParams` to update the parameters of this
    node.

    The params will contain either `kernelParams` or `extra`, according to
    which of these was most recently set on the node.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    nodeParams : :py:obj:`~.CUDA_KERNEL_NODE_PARAMS`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphKernelNodeSetParams`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef CUDA_KERNEL_NODE_PARAMS nodeParams = CUDA_KERNEL_NODE_PARAMS()
    with nogil:
        err = cydriver.cuGraphKernelNodeGetParams(cyhNode, <cydriver.CUDA_KERNEL_NODE_PARAMS*>nodeParams._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], nodeParams)
{{endif}}

{{if 'cuGraphKernelNodeSetParams_v2' in found_functions}}

@cython.embedsignature(True)
def cuGraphKernelNodeSetParams(hNode, nodeParams : Optional[CUDA_KERNEL_NODE_PARAMS]):
    """ Sets a kernel node's parameters.

    Sets the parameters of kernel node `hNode` to `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.CUDA_KERNEL_NODE_PARAMS`
        Parameters to copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

    See Also
    --------
    :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphKernelNodeGetParams`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUDA_KERNEL_NODE_PARAMS* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphKernelNodeSetParams(cyhNode, cynodeParams_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphAddMemcpyNode' in found_functions}}

@cython.embedsignature(True)
def cuGraphAddMemcpyNode(hGraph, dependencies : Optional[tuple[CUgraphNode] | list[CUgraphNode]], size_t numDependencies, copyParams : Optional[CUDA_MEMCPY3D], ctx):
    """ Creates a memcpy node and adds it to a graph.

    Creates a new memcpy node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies`. It is
    possible for `numDependencies` to be 0, in which case the node will be
    placed at the root of the graph. `dependencies` may not have any
    duplicate entries. A handle to the new node will be returned in
    `phGraphNode`.

    When the graph is launched, the node will perform the memcpy described
    by `copyParams`. See :py:obj:`~.cuMemcpy3D()` for a description of the
    structure and its restrictions.

    Memcpy nodes have some additional restrictions with regards to managed
    memory, if the system contains at least one device which has a zero
    value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. If one or
    more of the operands refer to managed memory, then using the memory
    type :py:obj:`~.CU_MEMORYTYPE_UNIFIED` is disallowed for those
    operand(s). The managed memory will be treated as residing on either
    the host or the device, depending on which memory type is specified.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : list[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    copyParams : :py:obj:`~.CUDA_MEMCPY3D`
        Parameters for the memory copy
    ctx : :py:obj:`~.CUcontext`
        Context on which to run the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuGraphMemcpyNodeGetParams`, :py:obj:`~.cuGraphMemcpyNodeSetParams`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """
    cdef cydriver.CUcontext cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (CUcontext,)):
        pctx = int(ctx)
    else:
        pctx = int(CUcontext(ctx))
    cyctx = <cydriver.CUcontext><void_ptr>pctx
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode,)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef cydriver.CUgraphNode* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cydriver.CUgraphNode*> calloc(len(dependencies), sizeof(cydriver.CUgraphNode))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cydriver.CUgraphNode>(<CUgraphNode>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cydriver.CUgraphNode*>(<CUgraphNode>dependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef cydriver.CUDA_MEMCPY3D* cycopyParams_ptr = copyParams._pvt_ptr if copyParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphAddMemcpyNode(<cydriver.CUgraphNode*>phGraphNode._pvt_ptr, cyhGraph, cydependencies, numDependencies, cycopyParams_ptr, cyctx)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraphNode)
{{endif}}

{{if 'cuGraphMemcpyNodeGetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphMemcpyNodeGetParams(hNode):
    """ Returns a memcpy node's parameters.

    Returns the parameters of memcpy node `hNode` in `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    nodeParams : :py:obj:`~.CUDA_MEMCPY3D`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphMemcpyNodeSetParams`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef CUDA_MEMCPY3D nodeParams = CUDA_MEMCPY3D()
    with nogil:
        err = cydriver.cuGraphMemcpyNodeGetParams(cyhNode, <cydriver.CUDA_MEMCPY3D*>nodeParams._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], nodeParams)
{{endif}}

{{if 'cuGraphMemcpyNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphMemcpyNodeSetParams(hNode, nodeParams : Optional[CUDA_MEMCPY3D]):
    """ Sets a memcpy node's parameters.

    Sets the parameters of memcpy node `hNode` to `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.CUDA_MEMCPY3D`
        Parameters to copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphMemcpyNodeGetParams`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUDA_MEMCPY3D* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphMemcpyNodeSetParams(cyhNode, cynodeParams_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphAddMemsetNode' in found_functions}}

@cython.embedsignature(True)
def cuGraphAddMemsetNode(hGraph, dependencies : Optional[tuple[CUgraphNode] | list[CUgraphNode]], size_t numDependencies, memsetParams : Optional[CUDA_MEMSET_NODE_PARAMS], ctx):
    """ Creates a memset node and adds it to a graph.

    Creates a new memset node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies`. It is
    possible for `numDependencies` to be 0, in which case the node will be
    placed at the root of the graph. `dependencies` may not have any
    duplicate entries. A handle to the new node will be returned in
    `phGraphNode`.

    The element size must be 1, 2, or 4 bytes. When the graph is launched,
    the node will perform the memset described by `memsetParams`.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : list[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    memsetParams : :py:obj:`~.CUDA_MEMSET_NODE_PARAMS`
        Parameters for the memory set
    ctx : :py:obj:`~.CUcontext`
        Context on which to run the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuGraphMemsetNodeGetParams`, :py:obj:`~.cuGraphMemsetNodeSetParams`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`
    """
    cdef cydriver.CUcontext cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (CUcontext,)):
        pctx = int(ctx)
    else:
        pctx = int(CUcontext(ctx))
    cyctx = <cydriver.CUcontext><void_ptr>pctx
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode,)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef cydriver.CUgraphNode* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cydriver.CUgraphNode*> calloc(len(dependencies), sizeof(cydriver.CUgraphNode))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cydriver.CUgraphNode>(<CUgraphNode>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cydriver.CUgraphNode*>(<CUgraphNode>dependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef cydriver.CUDA_MEMSET_NODE_PARAMS* cymemsetParams_ptr = memsetParams._pvt_ptr if memsetParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphAddMemsetNode(<cydriver.CUgraphNode*>phGraphNode._pvt_ptr, cyhGraph, cydependencies, numDependencies, cymemsetParams_ptr, cyctx)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraphNode)
{{endif}}

{{if 'cuGraphMemsetNodeGetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphMemsetNodeGetParams(hNode):
    """ Returns a memset node's parameters.

    Returns the parameters of memset node `hNode` in `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    nodeParams : :py:obj:`~.CUDA_MEMSET_NODE_PARAMS`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuGraphAddMemsetNode`, :py:obj:`~.cuGraphMemsetNodeSetParams`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef CUDA_MEMSET_NODE_PARAMS nodeParams = CUDA_MEMSET_NODE_PARAMS()
    with nogil:
        err = cydriver.cuGraphMemsetNodeGetParams(cyhNode, <cydriver.CUDA_MEMSET_NODE_PARAMS*>nodeParams._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], nodeParams)
{{endif}}

{{if 'cuGraphMemsetNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphMemsetNodeSetParams(hNode, nodeParams : Optional[CUDA_MEMSET_NODE_PARAMS]):
    """ Sets a memset node's parameters.

    Sets the parameters of memset node `hNode` to `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.CUDA_MEMSET_NODE_PARAMS`
        Parameters to copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuGraphAddMemsetNode`, :py:obj:`~.cuGraphMemsetNodeGetParams`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUDA_MEMSET_NODE_PARAMS* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphMemsetNodeSetParams(cyhNode, cynodeParams_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphAddHostNode' in found_functions}}

@cython.embedsignature(True)
def cuGraphAddHostNode(hGraph, dependencies : Optional[tuple[CUgraphNode] | list[CUgraphNode]], size_t numDependencies, nodeParams : Optional[CUDA_HOST_NODE_PARAMS]):
    """ Creates a host execution node and adds it to a graph.

    Creates a new CPU execution node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and
    arguments specified in `nodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `dependencies` may not have any duplicate entries. A
    handle to the new node will be returned in `phGraphNode`.

    When the graph is launched, the node will invoke the specified CPU
    function. Host nodes are not supported under MPS with pre-Volta GPUs.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : list[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    nodeParams : :py:obj:`~.CUDA_HOST_NODE_PARAMS`
        Parameters for the host node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuLaunchHostFunc`, :py:obj:`~.cuGraphHostNodeGetParams`, :py:obj:`~.cuGraphHostNodeSetParams`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode,)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef cydriver.CUgraphNode* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cydriver.CUgraphNode*> calloc(len(dependencies), sizeof(cydriver.CUgraphNode))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cydriver.CUgraphNode>(<CUgraphNode>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cydriver.CUgraphNode*>(<CUgraphNode>dependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef cydriver.CUDA_HOST_NODE_PARAMS* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphAddHostNode(<cydriver.CUgraphNode*>phGraphNode._pvt_ptr, cyhGraph, cydependencies, numDependencies, cynodeParams_ptr)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraphNode)
{{endif}}

{{if 'cuGraphHostNodeGetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphHostNodeGetParams(hNode):
    """ Returns a host node's parameters.

    Returns the parameters of host node `hNode` in `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    nodeParams : :py:obj:`~.CUDA_HOST_NODE_PARAMS`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cuLaunchHostFunc`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphHostNodeSetParams`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef CUDA_HOST_NODE_PARAMS nodeParams = CUDA_HOST_NODE_PARAMS()
    with nogil:
        err = cydriver.cuGraphHostNodeGetParams(cyhNode, <cydriver.CUDA_HOST_NODE_PARAMS*>nodeParams._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], nodeParams)
{{endif}}

{{if 'cuGraphHostNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphHostNodeSetParams(hNode, nodeParams : Optional[CUDA_HOST_NODE_PARAMS]):
    """ Sets a host node's parameters.

    Sets the parameters of host node `hNode` to `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.CUDA_HOST_NODE_PARAMS`
        Parameters to copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuLaunchHostFunc`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphHostNodeGetParams`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUDA_HOST_NODE_PARAMS* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphHostNodeSetParams(cyhNode, cynodeParams_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphAddChildGraphNode' in found_functions}}

@cython.embedsignature(True)
def cuGraphAddChildGraphNode(hGraph, dependencies : Optional[tuple[CUgraphNode] | list[CUgraphNode]], size_t numDependencies, childGraph):
    """ Creates a child graph node and adds it to a graph.

    Creates a new node which executes an embedded graph, and adds it to
    `hGraph` with `numDependencies` dependencies specified via
    `dependencies`. It is possible for `numDependencies` to be 0, in which
    case the node will be placed at the root of the graph. `dependencies`
    may not have any duplicate entries. A handle to the new node will be
    returned in `phGraphNode`.

    If `childGraph` contains allocation nodes, free nodes, or conditional
    nodes, this call will return an error.

    The node executes an embedded child graph. The child graph is cloned in
    this call.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : list[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    childGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph to clone into this node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphChildGraphNodeGetGraph`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`, :py:obj:`~.cuGraphClone`
    """
    cdef cydriver.CUgraph cychildGraph
    if childGraph is None:
        pchildGraph = 0
    elif isinstance(childGraph, (CUgraph,)):
        pchildGraph = int(childGraph)
    else:
        pchildGraph = int(CUgraph(childGraph))
    cychildGraph = <cydriver.CUgraph><void_ptr>pchildGraph
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode,)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef cydriver.CUgraphNode* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cydriver.CUgraphNode*> calloc(len(dependencies), sizeof(cydriver.CUgraphNode))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cydriver.CUgraphNode>(<CUgraphNode>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cydriver.CUgraphNode*>(<CUgraphNode>dependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    with nogil:
        err = cydriver.cuGraphAddChildGraphNode(<cydriver.CUgraphNode*>phGraphNode._pvt_ptr, cyhGraph, cydependencies, numDependencies, cychildGraph)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraphNode)
{{endif}}

{{if 'cuGraphChildGraphNodeGetGraph' in found_functions}}

@cython.embedsignature(True)
def cuGraphChildGraphNodeGetGraph(hNode):
    """ Gets a handle to the embedded graph of a child graph node.

    Gets a handle to the embedded graph in a child graph node. This call
    does not clone the graph. Changes to the graph will be reflected in the
    node, and the node retains ownership of the graph.

    Allocation and free nodes cannot be added to the returned graph.
    Attempting to do so will return an error.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the embedded graph for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    phGraph : :py:obj:`~.CUgraph`
        Location to store a handle to the graph

    See Also
    --------
    :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphNodeFindInClone`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef CUgraph phGraph = CUgraph()
    with nogil:
        err = cydriver.cuGraphChildGraphNodeGetGraph(cyhNode, <cydriver.CUgraph*>phGraph._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraph)
{{endif}}

{{if 'cuGraphAddEmptyNode' in found_functions}}

@cython.embedsignature(True)
def cuGraphAddEmptyNode(hGraph, dependencies : Optional[tuple[CUgraphNode] | list[CUgraphNode]], size_t numDependencies):
    """ Creates an empty node and adds it to a graph.

    Creates a new node which performs no operation, and adds it to `hGraph`
    with `numDependencies` dependencies specified via `dependencies`. It is
    possible for `numDependencies` to be 0, in which case the node will be
    placed at the root of the graph. `dependencies` may not have any
    duplicate entries. A handle to the new node will be returned in
    `phGraphNode`.

    An empty node performs no operation during execution, but can be used
    for transitive ordering. For example, a phased execution graph with 2
    groups of n nodes with a barrier between them can be represented using
    an empty node and 2*n dependency edges, rather than no empty node and
    n^2 dependency edges.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : list[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode,)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef cydriver.CUgraphNode* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cydriver.CUgraphNode*> calloc(len(dependencies), sizeof(cydriver.CUgraphNode))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cydriver.CUgraphNode>(<CUgraphNode>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cydriver.CUgraphNode*>(<CUgraphNode>dependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    with nogil:
        err = cydriver.cuGraphAddEmptyNode(<cydriver.CUgraphNode*>phGraphNode._pvt_ptr, cyhGraph, cydependencies, numDependencies)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraphNode)
{{endif}}

{{if 'cuGraphAddEventRecordNode' in found_functions}}

@cython.embedsignature(True)
def cuGraphAddEventRecordNode(hGraph, dependencies : Optional[tuple[CUgraphNode] | list[CUgraphNode]], size_t numDependencies, event):
    """ Creates an event record node and adds it to a graph.

    Creates a new event record node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and event
    specified in `event`. It is possible for `numDependencies` to be 0, in
    which case the node will be placed at the root of the graph.
    `dependencies` may not have any duplicate entries. A handle to the new
    node will be returned in `phGraphNode`.

    Each launch of the graph will record `event` to capture execution of
    the node's dependencies.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : list[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event for the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """
    cdef cydriver.CUevent cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (CUevent,)):
        pevent = int(event)
    else:
        pevent = int(CUevent(event))
    cyevent = <cydriver.CUevent><void_ptr>pevent
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode,)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef cydriver.CUgraphNode* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cydriver.CUgraphNode*> calloc(len(dependencies), sizeof(cydriver.CUgraphNode))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cydriver.CUgraphNode>(<CUgraphNode>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cydriver.CUgraphNode*>(<CUgraphNode>dependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    with nogil:
        err = cydriver.cuGraphAddEventRecordNode(<cydriver.CUgraphNode*>phGraphNode._pvt_ptr, cyhGraph, cydependencies, numDependencies, cyevent)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraphNode)
{{endif}}

{{if 'cuGraphEventRecordNodeGetEvent' in found_functions}}

@cython.embedsignature(True)
def cuGraphEventRecordNodeGetEvent(hNode):
    """ Returns the event associated with an event record node.

    Returns the event of event record node `hNode` in `event_out`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the event for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    event_out : :py:obj:`~.CUevent`
        Pointer to return the event

    See Also
    --------
    :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphEventRecordNodeSetEvent`, :py:obj:`~.cuGraphEventWaitNodeGetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef CUevent event_out = CUevent()
    with nogil:
        err = cydriver.cuGraphEventRecordNodeGetEvent(cyhNode, <cydriver.CUevent*>event_out._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], event_out)
{{endif}}

{{if 'cuGraphEventRecordNodeSetEvent' in found_functions}}

@cython.embedsignature(True)
def cuGraphEventRecordNodeSetEvent(hNode, event):
    """ Sets an event record node's event.

    Sets the event of event record node `hNode` to `event`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the event for
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to use

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

    See Also
    --------
    :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphEventRecordNodeGetEvent`, :py:obj:`~.cuGraphEventWaitNodeSetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`
    """
    cdef cydriver.CUevent cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (CUevent,)):
        pevent = int(event)
    else:
        pevent = int(CUevent(event))
    cyevent = <cydriver.CUevent><void_ptr>pevent
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    with nogil:
        err = cydriver.cuGraphEventRecordNodeSetEvent(cyhNode, cyevent)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphAddEventWaitNode' in found_functions}}

@cython.embedsignature(True)
def cuGraphAddEventWaitNode(hGraph, dependencies : Optional[tuple[CUgraphNode] | list[CUgraphNode]], size_t numDependencies, event):
    """ Creates an event wait node and adds it to a graph.

    Creates a new event wait node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and event
    specified in `event`. It is possible for `numDependencies` to be 0, in
    which case the node will be placed at the root of the graph.
    `dependencies` may not have any duplicate entries. A handle to the new
    node will be returned in `phGraphNode`.

    The graph node will wait for all work captured in `event`. See
    :py:obj:`~.cuEventRecord()` for details on what is captured by an
    event. `event` may be from a different context or device than the
    launch stream.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : list[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event for the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """
    cdef cydriver.CUevent cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (CUevent,)):
        pevent = int(event)
    else:
        pevent = int(CUevent(event))
    cyevent = <cydriver.CUevent><void_ptr>pevent
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode,)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef cydriver.CUgraphNode* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cydriver.CUgraphNode*> calloc(len(dependencies), sizeof(cydriver.CUgraphNode))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cydriver.CUgraphNode>(<CUgraphNode>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cydriver.CUgraphNode*>(<CUgraphNode>dependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    with nogil:
        err = cydriver.cuGraphAddEventWaitNode(<cydriver.CUgraphNode*>phGraphNode._pvt_ptr, cyhGraph, cydependencies, numDependencies, cyevent)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraphNode)
{{endif}}

{{if 'cuGraphEventWaitNodeGetEvent' in found_functions}}

@cython.embedsignature(True)
def cuGraphEventWaitNodeGetEvent(hNode):
    """ Returns the event associated with an event wait node.

    Returns the event of event wait node `hNode` in `event_out`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the event for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    event_out : :py:obj:`~.CUevent`
        Pointer to return the event

    See Also
    --------
    :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphEventWaitNodeSetEvent`, :py:obj:`~.cuGraphEventRecordNodeGetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef CUevent event_out = CUevent()
    with nogil:
        err = cydriver.cuGraphEventWaitNodeGetEvent(cyhNode, <cydriver.CUevent*>event_out._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], event_out)
{{endif}}

{{if 'cuGraphEventWaitNodeSetEvent' in found_functions}}

@cython.embedsignature(True)
def cuGraphEventWaitNodeSetEvent(hNode, event):
    """ Sets an event wait node's event.

    Sets the event of event wait node `hNode` to `event`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the event for
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to use

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

    See Also
    --------
    :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphEventWaitNodeGetEvent`, :py:obj:`~.cuGraphEventRecordNodeSetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`
    """
    cdef cydriver.CUevent cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (CUevent,)):
        pevent = int(event)
    else:
        pevent = int(CUevent(event))
    cyevent = <cydriver.CUevent><void_ptr>pevent
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    with nogil:
        err = cydriver.cuGraphEventWaitNodeSetEvent(cyhNode, cyevent)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphAddExternalSemaphoresSignalNode' in found_functions}}

@cython.embedsignature(True)
def cuGraphAddExternalSemaphoresSignalNode(hGraph, dependencies : Optional[tuple[CUgraphNode] | list[CUgraphNode]], size_t numDependencies, nodeParams : Optional[CUDA_EXT_SEM_SIGNAL_NODE_PARAMS]):
    """ Creates an external semaphore signal node and adds it to a graph.

    Creates a new external semaphore signal node and adds it to `hGraph`
    with `numDependencies` dependencies specified via `dependencies` and
    arguments specified in `nodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `dependencies` may not have any duplicate entries. A
    handle to the new node will be returned in `phGraphNode`.

    Performs a signal operation on a set of externally allocated semaphore
    objects when the node is launched. The operation(s) will occur after
    all of the node's dependencies have completed.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : list[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    nodeParams : :py:obj:`~.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS`
        Parameters for the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphExternalSemaphoresSignalNodeGetParams`, :py:obj:`~.cuGraphExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode,)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef cydriver.CUgraphNode* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cydriver.CUgraphNode*> calloc(len(dependencies), sizeof(cydriver.CUgraphNode))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cydriver.CUgraphNode>(<CUgraphNode>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cydriver.CUgraphNode*>(<CUgraphNode>dependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef cydriver.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphAddExternalSemaphoresSignalNode(<cydriver.CUgraphNode*>phGraphNode._pvt_ptr, cyhGraph, cydependencies, numDependencies, cynodeParams_ptr)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraphNode)
{{endif}}

{{if 'cuGraphExternalSemaphoresSignalNodeGetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphExternalSemaphoresSignalNodeGetParams(hNode):
    """ Returns an external semaphore signal node's parameters.

    Returns the parameters of an external semaphore signal node `hNode` in
    `params_out`. The `extSemArray` and `paramsArray` returned in
    `params_out`, are owned by the node. This memory remains valid until
    the node is destroyed or its parameters are modified, and should not be
    modified directly. Use
    :py:obj:`~.cuGraphExternalSemaphoresSignalNodeSetParams` to update the
    parameters of this node.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    params_out : :py:obj:`~.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuGraphExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef CUDA_EXT_SEM_SIGNAL_NODE_PARAMS params_out = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS()
    with nogil:
        err = cydriver.cuGraphExternalSemaphoresSignalNodeGetParams(cyhNode, <cydriver.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS*>params_out._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], params_out)
{{endif}}

{{if 'cuGraphExternalSemaphoresSignalNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphExternalSemaphoresSignalNodeSetParams(hNode, nodeParams : Optional[CUDA_EXT_SEM_SIGNAL_NODE_PARAMS]):
    """ Sets an external semaphore signal node's parameters.

    Sets the parameters of an external semaphore signal node `hNode` to
    `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS`
        Parameters to copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

    See Also
    --------
    :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuGraphExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphExternalSemaphoresSignalNodeSetParams(cyhNode, cynodeParams_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphAddExternalSemaphoresWaitNode' in found_functions}}

@cython.embedsignature(True)
def cuGraphAddExternalSemaphoresWaitNode(hGraph, dependencies : Optional[tuple[CUgraphNode] | list[CUgraphNode]], size_t numDependencies, nodeParams : Optional[CUDA_EXT_SEM_WAIT_NODE_PARAMS]):
    """ Creates an external semaphore wait node and adds it to a graph.

    Creates a new external semaphore wait node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and
    arguments specified in `nodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `dependencies` may not have any duplicate entries. A
    handle to the new node will be returned in `phGraphNode`.

    Performs a wait operation on a set of externally allocated semaphore
    objects when the node is launched. The node's dependencies will not be
    launched until the wait operation has completed.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : list[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    nodeParams : :py:obj:`~.CUDA_EXT_SEM_WAIT_NODE_PARAMS`
        Parameters for the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphExternalSemaphoresWaitNodeGetParams`, :py:obj:`~.cuGraphExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode,)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef cydriver.CUgraphNode* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cydriver.CUgraphNode*> calloc(len(dependencies), sizeof(cydriver.CUgraphNode))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cydriver.CUgraphNode>(<CUgraphNode>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cydriver.CUgraphNode*>(<CUgraphNode>dependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef cydriver.CUDA_EXT_SEM_WAIT_NODE_PARAMS* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphAddExternalSemaphoresWaitNode(<cydriver.CUgraphNode*>phGraphNode._pvt_ptr, cyhGraph, cydependencies, numDependencies, cynodeParams_ptr)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraphNode)
{{endif}}

{{if 'cuGraphExternalSemaphoresWaitNodeGetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphExternalSemaphoresWaitNodeGetParams(hNode):
    """ Returns an external semaphore wait node's parameters.

    Returns the parameters of an external semaphore wait node `hNode` in
    `params_out`. The `extSemArray` and `paramsArray` returned in
    `params_out`, are owned by the node. This memory remains valid until
    the node is destroyed or its parameters are modified, and should not be
    modified directly. Use
    :py:obj:`~.cuGraphExternalSemaphoresSignalNodeSetParams` to update the
    parameters of this node.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    params_out : :py:obj:`~.CUDA_EXT_SEM_WAIT_NODE_PARAMS`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuGraphExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef CUDA_EXT_SEM_WAIT_NODE_PARAMS params_out = CUDA_EXT_SEM_WAIT_NODE_PARAMS()
    with nogil:
        err = cydriver.cuGraphExternalSemaphoresWaitNodeGetParams(cyhNode, <cydriver.CUDA_EXT_SEM_WAIT_NODE_PARAMS*>params_out._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], params_out)
{{endif}}

{{if 'cuGraphExternalSemaphoresWaitNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphExternalSemaphoresWaitNodeSetParams(hNode, nodeParams : Optional[CUDA_EXT_SEM_WAIT_NODE_PARAMS]):
    """ Sets an external semaphore wait node's parameters.

    Sets the parameters of an external semaphore wait node `hNode` to
    `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.CUDA_EXT_SEM_WAIT_NODE_PARAMS`
        Parameters to copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

    See Also
    --------
    :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuGraphExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUDA_EXT_SEM_WAIT_NODE_PARAMS* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphExternalSemaphoresWaitNodeSetParams(cyhNode, cynodeParams_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphAddBatchMemOpNode' in found_functions}}

@cython.embedsignature(True)
def cuGraphAddBatchMemOpNode(hGraph, dependencies : Optional[tuple[CUgraphNode] | list[CUgraphNode]], size_t numDependencies, nodeParams : Optional[CUDA_BATCH_MEM_OP_NODE_PARAMS]):
    """ Creates a batch memory operation node and adds it to a graph.

    Creates a new batch memory operation node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and
    arguments specified in `nodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `dependencies` may not have any duplicate entries. A
    handle to the new node will be returned in `phGraphNode`.

    When the node is added, the paramArray inside `nodeParams` is copied
    and therefore it can be freed after the call returns.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : list[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    nodeParams : :py:obj:`~.CUDA_BATCH_MEM_OP_NODE_PARAMS`
        Parameters for the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuStreamWaitValue32`, :py:obj:`~.cuStreamWriteValue32`, :py:obj:`~.cuStreamWaitValue64`, :py:obj:`~.cuStreamWriteValue64`, :py:obj:`~.cuGraphBatchMemOpNodeGetParams`, :py:obj:`~.cuGraphBatchMemOpNodeSetParams`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`

    Notes
    -----
    Warning: Improper use of this API may deadlock the application. Synchronization ordering established through this API is not visible to CUDA. CUDA tasks that are (even indirectly) ordered by this API should also have that order expressed with CUDA-visible dependencies such as events. This ensures that the scheduler does not serialize them in an improper order.
    """
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode,)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef cydriver.CUgraphNode* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cydriver.CUgraphNode*> calloc(len(dependencies), sizeof(cydriver.CUgraphNode))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cydriver.CUgraphNode>(<CUgraphNode>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cydriver.CUgraphNode*>(<CUgraphNode>dependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef cydriver.CUDA_BATCH_MEM_OP_NODE_PARAMS* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphAddBatchMemOpNode(<cydriver.CUgraphNode*>phGraphNode._pvt_ptr, cyhGraph, cydependencies, numDependencies, cynodeParams_ptr)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraphNode)
{{endif}}

{{if 'cuGraphBatchMemOpNodeGetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphBatchMemOpNodeGetParams(hNode):
    """ Returns a batch mem op node's parameters.

    Returns the parameters of batch mem op node `hNode` in
    `nodeParams_out`. The `paramArray` returned in `nodeParams_out` is
    owned by the node. This memory remains valid until the node is
    destroyed or its parameters are modified, and should not be modified
    directly. Use :py:obj:`~.cuGraphBatchMemOpNodeSetParams` to update the
    parameters of this node.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    nodeParams_out : :py:obj:`~.CUDA_BATCH_MEM_OP_NODE_PARAMS`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuGraphAddBatchMemOpNode`, :py:obj:`~.cuGraphBatchMemOpNodeSetParams`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef CUDA_BATCH_MEM_OP_NODE_PARAMS nodeParams_out = CUDA_BATCH_MEM_OP_NODE_PARAMS()
    with nogil:
        err = cydriver.cuGraphBatchMemOpNodeGetParams(cyhNode, <cydriver.CUDA_BATCH_MEM_OP_NODE_PARAMS*>nodeParams_out._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], nodeParams_out)
{{endif}}

{{if 'cuGraphBatchMemOpNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphBatchMemOpNodeSetParams(hNode, nodeParams : Optional[CUDA_BATCH_MEM_OP_NODE_PARAMS]):
    """ Sets a batch mem op node's parameters.

    Sets the parameters of batch mem op node `hNode` to `nodeParams`.

    The paramArray inside `nodeParams` is copied and therefore it can be
    freed after the call returns.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.CUDA_BATCH_MEM_OP_NODE_PARAMS`
        Parameters to copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

    See Also
    --------
    :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuGraphAddBatchMemOpNode`, :py:obj:`~.cuGraphBatchMemOpNodeGetParams`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUDA_BATCH_MEM_OP_NODE_PARAMS* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphBatchMemOpNodeSetParams(cyhNode, cynodeParams_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphExecBatchMemOpNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphExecBatchMemOpNodeSetParams(hGraphExec, hNode, nodeParams : Optional[CUDA_BATCH_MEM_OP_NODE_PARAMS]):
    """ Sets the parameters for a batch mem op node in the given graphExec.

    Sets the parameters of a batch mem op node in an executable graph
    `hGraphExec`. The node is identified by the corresponding node `hNode`
    in the non-executable graph, from which the executable graph was
    instantiated.

    The following fields on operations may be modified on an executable
    graph:

    op.waitValue.address op.waitValue.value[64] op.waitValue.flags bits
    corresponding to wait type (i.e. CU_STREAM_WAIT_VALUE_FLUSH bit cannot
    be modified) op.writeValue.address op.writeValue.value[64]

    Other fields, such as the context, count or type of operations, and
    other types of operations such as membars, may not be modified.

    `hNode` must not have been removed from the original graph.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    The paramArray inside `nodeParams` is copied and therefore it can be
    freed after the call returns.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Batch mem op node from the graph from which graphExec was
        instantiated
    nodeParams : :py:obj:`~.CUDA_BATCH_MEM_OP_NODE_PARAMS`
        Updated Parameters to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuGraphAddBatchMemOpNode`, :py:obj:`~.cuGraphBatchMemOpNodeGetParams`, :py:obj:`~.cuGraphBatchMemOpNodeSetParams`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    cdef cydriver.CUDA_BATCH_MEM_OP_NODE_PARAMS* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphExecBatchMemOpNodeSetParams(cyhGraphExec, cyhNode, cynodeParams_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphAddMemAllocNode' in found_functions}}

@cython.embedsignature(True)
def cuGraphAddMemAllocNode(hGraph, dependencies : Optional[tuple[CUgraphNode] | list[CUgraphNode]], size_t numDependencies, nodeParams : Optional[CUDA_MEM_ALLOC_NODE_PARAMS]):
    """ Creates an allocation node and adds it to a graph.

    Creates a new allocation node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and
    arguments specified in `nodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `dependencies` may not have any duplicate entries. A
    handle to the new node will be returned in `phGraphNode`.

    When :py:obj:`~.cuGraphAddMemAllocNode` creates an allocation node, it
    returns the address of the allocation in `nodeParams.dptr`. The
    allocation's address remains fixed across instantiations and launches.

    If the allocation is freed in the same graph, by creating a free node
    using :py:obj:`~.cuGraphAddMemFreeNode`, the allocation can be accessed
    by nodes ordered after the allocation node but before the free node.
    These allocations cannot be freed outside the owning graph, and they
    can only be freed once in the owning graph.

    If the allocation is not freed in the same graph, then it can be
    accessed not only by nodes in the graph which are ordered after the
    allocation node, but also by stream operations ordered after the
    graph's execution but before the allocation is freed.

    Allocations which are not freed in the same graph can be freed by:

    - passing the allocation to :py:obj:`~.cuMemFreeAsync` or
      :py:obj:`~.cuMemFree`;

    - launching a graph with a free node for that allocation; or

    - specifying
      :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH` during
      instantiation, which makes each launch behave as though it called
      :py:obj:`~.cuMemFreeAsync` for every unfreed allocation.

    It is not possible to free an allocation in both the owning graph and
    another graph. If the allocation is freed in the same graph, a free
    node cannot be added to another graph. If the allocation is freed in
    another graph, a free node can no longer be added to the owning graph.

    The following restrictions apply to graphs which contain allocation
    and/or memory free nodes:

    - Nodes and edges of the graph cannot be deleted.

    - The graph can only be used in a child node if the ownership is moved
      to the parent.

    - Only one instantiation of the graph may exist at any point in time.

    - The graph cannot be cloned.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : list[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    nodeParams : :py:obj:`~.CUDA_MEM_ALLOC_NODE_PARAMS`
        Parameters for the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphAddMemFreeNode`, :py:obj:`~.cuGraphMemAllocNodeGetParams`, :py:obj:`~.cuDeviceGraphMemTrim`, :py:obj:`~.cuDeviceGetGraphMemAttribute`, :py:obj:`~.cuDeviceSetGraphMemAttribute`, :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode,)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef cydriver.CUgraphNode* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cydriver.CUgraphNode*> calloc(len(dependencies), sizeof(cydriver.CUgraphNode))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cydriver.CUgraphNode>(<CUgraphNode>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cydriver.CUgraphNode*>(<CUgraphNode>dependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef cydriver.CUDA_MEM_ALLOC_NODE_PARAMS* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphAddMemAllocNode(<cydriver.CUgraphNode*>phGraphNode._pvt_ptr, cyhGraph, cydependencies, numDependencies, cynodeParams_ptr)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraphNode)
{{endif}}

{{if 'cuGraphMemAllocNodeGetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphMemAllocNodeGetParams(hNode):
    """ Returns a memory alloc node's parameters.

    Returns the parameters of a memory alloc node `hNode` in `params_out`.
    The `poolProps` and `accessDescs` returned in `params_out`, are owned
    by the node. This memory remains valid until the node is destroyed. The
    returned parameters must not be modified.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    params_out : :py:obj:`~.CUDA_MEM_ALLOC_NODE_PARAMS`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cuGraphAddMemAllocNode`, :py:obj:`~.cuGraphMemFreeNodeGetParams`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef CUDA_MEM_ALLOC_NODE_PARAMS params_out = CUDA_MEM_ALLOC_NODE_PARAMS()
    with nogil:
        err = cydriver.cuGraphMemAllocNodeGetParams(cyhNode, <cydriver.CUDA_MEM_ALLOC_NODE_PARAMS*>params_out._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], params_out)
{{endif}}

{{if 'cuGraphAddMemFreeNode' in found_functions}}

@cython.embedsignature(True)
def cuGraphAddMemFreeNode(hGraph, dependencies : Optional[tuple[CUgraphNode] | list[CUgraphNode]], size_t numDependencies, dptr):
    """ Creates a memory free node and adds it to a graph.

    Creates a new memory free node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and
    arguments specified in `nodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `dependencies` may not have any duplicate entries. A
    handle to the new node will be returned in `phGraphNode`.

    :py:obj:`~.cuGraphAddMemFreeNode` will return
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if the user attempts to free:

    - an allocation twice in the same graph.

    - an address that was not returned by an allocation node.

    - an invalid address.

    The following restrictions apply to graphs which contain allocation
    and/or memory free nodes:

    - Nodes and edges of the graph cannot be deleted.

    - The graph can only be used in a child node if the ownership is moved
      to the parent.

    - Only one instantiation of the graph may exist at any point in time.

    - The graph cannot be cloned.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : list[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    dptr : :py:obj:`~.CUdeviceptr`
        Address of memory to free

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphAddMemAllocNode`, :py:obj:`~.cuGraphMemFreeNodeGetParams`, :py:obj:`~.cuDeviceGraphMemTrim`, :py:obj:`~.cuDeviceGetGraphMemAttribute`, :py:obj:`~.cuDeviceSetGraphMemAttribute`, :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """
    cdef cydriver.CUdeviceptr cydptr
    if dptr is None:
        pdptr = 0
    elif isinstance(dptr, (CUdeviceptr,)):
        pdptr = int(dptr)
    else:
        pdptr = int(CUdeviceptr(dptr))
    cydptr = <cydriver.CUdeviceptr><void_ptr>pdptr
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode,)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef cydriver.CUgraphNode* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cydriver.CUgraphNode*> calloc(len(dependencies), sizeof(cydriver.CUgraphNode))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cydriver.CUgraphNode>(<CUgraphNode>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cydriver.CUgraphNode*>(<CUgraphNode>dependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    with nogil:
        err = cydriver.cuGraphAddMemFreeNode(<cydriver.CUgraphNode*>phGraphNode._pvt_ptr, cyhGraph, cydependencies, numDependencies, cydptr)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraphNode)
{{endif}}

{{if 'cuGraphMemFreeNodeGetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphMemFreeNodeGetParams(hNode):
    """ Returns a memory free node's parameters.

    Returns the address of a memory free node `hNode` in `dptr_out`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    dptr_out : :py:obj:`~.CUdeviceptr`
        Pointer to return the device address

    See Also
    --------
    :py:obj:`~.cuGraphAddMemFreeNode`, :py:obj:`~.cuGraphMemAllocNodeGetParams`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef CUdeviceptr dptr_out = CUdeviceptr()
    with nogil:
        err = cydriver.cuGraphMemFreeNodeGetParams(cyhNode, <cydriver.CUdeviceptr*>dptr_out._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], dptr_out)
{{endif}}

{{if 'cuDeviceGraphMemTrim' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGraphMemTrim(device):
    """ Free unused memory that was cached on the specified device for use with graphs back to the OS.

    Blocks which are not in use by a graph that is either currently
    executing or scheduled to execute are freed back to the operating
    system.

    Parameters
    ----------
    device : :py:obj:`~.CUdevice`
        The device for which cached memory should be freed.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`

    See Also
    --------
    :py:obj:`~.cuGraphAddMemAllocNode`, :py:obj:`~.cuGraphAddMemFreeNode`, :py:obj:`~.cuDeviceSetGraphMemAttribute`, :py:obj:`~.cuDeviceGetGraphMemAttribute`
    """
    cdef cydriver.CUdevice cydevice
    if device is None:
        pdevice = 0
    elif isinstance(device, (CUdevice,)):
        pdevice = int(device)
    else:
        pdevice = int(CUdevice(device))
    cydevice = <cydriver.CUdevice>pdevice
    with nogil:
        err = cydriver.cuDeviceGraphMemTrim(cydevice)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuDeviceGetGraphMemAttribute' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetGraphMemAttribute(device, attr not None : CUgraphMem_attribute):
    """ Query asynchronous allocation attributes related to graphs.

    Valid attributes are:

    - :py:obj:`~.CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT`: Amount of memory, in
      bytes, currently associated with graphs

    - :py:obj:`~.CU_GRAPH_MEM_ATTR_USED_MEM_HIGH`: High watermark of
      memory, in bytes, associated with graphs since the last time it was
      reset. High watermark can only be reset to zero.

    - :py:obj:`~.CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT`: Amount of memory,
      in bytes, currently allocated for use by the CUDA graphs asynchronous
      allocator.

    - :py:obj:`~.CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH`: High watermark of
      memory, in bytes, currently allocated for use by the CUDA graphs
      asynchronous allocator.

    Parameters
    ----------
    device : :py:obj:`~.CUdevice`
        Specifies the scope of the query
    attr : :py:obj:`~.CUgraphMem_attribute`
        attribute to get

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    value : Any
        retrieved value

    See Also
    --------
    :py:obj:`~.cuDeviceSetGraphMemAttribute`, :py:obj:`~.cuGraphAddMemAllocNode`, :py:obj:`~.cuGraphAddMemFreeNode`
    """
    cdef cydriver.CUdevice cydevice
    if device is None:
        pdevice = 0
    elif isinstance(device, (CUdevice,)):
        pdevice = int(device)
    else:
        pdevice = int(CUdevice(device))
    cydevice = <cydriver.CUdevice>pdevice
    cdef cydriver.CUgraphMem_attribute cyattr = attr.value
    cdef _HelperCUgraphMem_attribute cyvalue = _HelperCUgraphMem_attribute(attr, 0, is_getter=True)
    cdef void* cyvalue_ptr = <void*><void_ptr>cyvalue.cptr
    with nogil:
        err = cydriver.cuDeviceGetGraphMemAttribute(cydevice, cyattr, cyvalue_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], cyvalue.pyObj())
{{endif}}

{{if 'cuDeviceSetGraphMemAttribute' in found_functions}}

@cython.embedsignature(True)
def cuDeviceSetGraphMemAttribute(device, attr not None : CUgraphMem_attribute, value):
    """ Set asynchronous allocation attributes related to graphs.

    Valid attributes are:

    - :py:obj:`~.CU_GRAPH_MEM_ATTR_USED_MEM_HIGH`: High watermark of
      memory, in bytes, associated with graphs since the last time it was
      reset. High watermark can only be reset to zero.

    - :py:obj:`~.CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH`: High watermark of
      memory, in bytes, currently allocated for use by the CUDA graphs
      asynchronous allocator.

    Parameters
    ----------
    device : :py:obj:`~.CUdevice`
        Specifies the scope of the query
    attr : :py:obj:`~.CUgraphMem_attribute`
        attribute to get
    value : Any
        pointer to value to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`

    See Also
    --------
    :py:obj:`~.cuDeviceGetGraphMemAttribute`, :py:obj:`~.cuGraphAddMemAllocNode`, :py:obj:`~.cuGraphAddMemFreeNode`
    """
    cdef cydriver.CUdevice cydevice
    if device is None:
        pdevice = 0
    elif isinstance(device, (CUdevice,)):
        pdevice = int(device)
    else:
        pdevice = int(CUdevice(device))
    cydevice = <cydriver.CUdevice>pdevice
    cdef cydriver.CUgraphMem_attribute cyattr = attr.value
    cdef _HelperCUgraphMem_attribute cyvalue = _HelperCUgraphMem_attribute(attr, value, is_getter=False)
    cdef void* cyvalue_ptr = <void*><void_ptr>cyvalue.cptr
    with nogil:
        err = cydriver.cuDeviceSetGraphMemAttribute(cydevice, cyattr, cyvalue_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphClone' in found_functions}}

@cython.embedsignature(True)
def cuGraphClone(originalGraph):
    """ Clones a graph.

    This function creates a copy of `originalGraph` and returns it in
    `phGraphClone`. All parameters are copied into the cloned graph. The
    original graph may be modified after this call without affecting the
    clone.

    Child graph nodes in the original graph are recursively copied into the
    clone.

    Parameters
    ----------
    originalGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to clone

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    phGraphClone : :py:obj:`~.CUgraph`
        Returns newly created cloned graph

    See Also
    --------
    :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphNodeFindInClone`

    Notes
    -----
    : Cloning is not supported for graphs which contain memory allocation nodes, memory free nodes, or conditional nodes.
    """
    cdef cydriver.CUgraph cyoriginalGraph
    if originalGraph is None:
        poriginalGraph = 0
    elif isinstance(originalGraph, (CUgraph,)):
        poriginalGraph = int(originalGraph)
    else:
        poriginalGraph = int(CUgraph(originalGraph))
    cyoriginalGraph = <cydriver.CUgraph><void_ptr>poriginalGraph
    cdef CUgraph phGraphClone = CUgraph()
    with nogil:
        err = cydriver.cuGraphClone(<cydriver.CUgraph*>phGraphClone._pvt_ptr, cyoriginalGraph)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraphClone)
{{endif}}

{{if 'cuGraphNodeFindInClone' in found_functions}}

@cython.embedsignature(True)
def cuGraphNodeFindInClone(hOriginalNode, hClonedGraph):
    """ Finds a cloned version of a node.

    This function returns the node in `hClonedGraph` corresponding to
    `hOriginalNode` in the original graph.

    `hClonedGraph` must have been cloned from `hOriginalGraph` via
    :py:obj:`~.cuGraphClone`. `hOriginalNode` must have been in
    `hOriginalGraph` at the time of the call to :py:obj:`~.cuGraphClone`,
    and the corresponding cloned node in `hClonedGraph` must not have been
    removed. The cloned node is then returned via `phClonedNode`.

    Parameters
    ----------
    hOriginalNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Handle to the original node
    hClonedGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Cloned graph to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    phNode : :py:obj:`~.CUgraphNode`
        Returns handle to the cloned node

    See Also
    --------
    :py:obj:`~.cuGraphClone`
    """
    cdef cydriver.CUgraph cyhClonedGraph
    if hClonedGraph is None:
        phClonedGraph = 0
    elif isinstance(hClonedGraph, (CUgraph,)):
        phClonedGraph = int(hClonedGraph)
    else:
        phClonedGraph = int(CUgraph(hClonedGraph))
    cyhClonedGraph = <cydriver.CUgraph><void_ptr>phClonedGraph
    cdef cydriver.CUgraphNode cyhOriginalNode
    if hOriginalNode is None:
        phOriginalNode = 0
    elif isinstance(hOriginalNode, (CUgraphNode,)):
        phOriginalNode = int(hOriginalNode)
    else:
        phOriginalNode = int(CUgraphNode(hOriginalNode))
    cyhOriginalNode = <cydriver.CUgraphNode><void_ptr>phOriginalNode
    cdef CUgraphNode phNode = CUgraphNode()
    with nogil:
        err = cydriver.cuGraphNodeFindInClone(<cydriver.CUgraphNode*>phNode._pvt_ptr, cyhOriginalNode, cyhClonedGraph)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phNode)
{{endif}}

{{if 'cuGraphNodeGetType' in found_functions}}

@cython.embedsignature(True)
def cuGraphNodeGetType(hNode):
    """ Returns a node's type.

    Returns the node type of `hNode` in `typename`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    typename : :py:obj:`~.CUgraphNodeType`
        Pointer to return the node type

    See Also
    --------
    :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphChildGraphNodeGetGraph`, :py:obj:`~.cuGraphKernelNodeGetParams`, :py:obj:`~.cuGraphKernelNodeSetParams`, :py:obj:`~.cuGraphHostNodeGetParams`, :py:obj:`~.cuGraphHostNodeSetParams`, :py:obj:`~.cuGraphMemcpyNodeGetParams`, :py:obj:`~.cuGraphMemcpyNodeSetParams`, :py:obj:`~.cuGraphMemsetNodeGetParams`, :py:obj:`~.cuGraphMemsetNodeSetParams`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUgraphNodeType typename
    with nogil:
        err = cydriver.cuGraphNodeGetType(cyhNode, &typename)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], CUgraphNodeType(typename))
{{endif}}

{{if 'cuGraphGetNodes' in found_functions}}

@cython.embedsignature(True)
def cuGraphGetNodes(hGraph, size_t numNodes = 0):
    """ Returns a graph's nodes.

    Returns a list of `hGraph's` nodes. `nodes` may be NULL, in which case
    this function will return the number of nodes in `numNodes`. Otherwise,
    `numNodes` entries will be filled in. If `numNodes` is higher than the
    actual number of nodes, the remaining entries in `nodes` will be set to
    NULL, and the number of nodes actually obtained will be returned in
    `numNodes`.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to query
    numNodes : int
        See description

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    nodes : list[:py:obj:`~.CUgraphNode`]
        Pointer to return the nodes
    numNodes : int
        See description

    See Also
    --------
    :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphNodeGetType`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """
    cdef size_t _graph_length = numNodes
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef cydriver.CUgraphNode* cynodes = NULL
    pynodes = []
    if _graph_length != 0:
        cynodes = <cydriver.CUgraphNode*>calloc(_graph_length, sizeof(cydriver.CUgraphNode))
        if cynodes is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cydriver.CUgraphNode)))
    with nogil:
        err = cydriver.cuGraphGetNodes(cyhGraph, cynodes, &numNodes)
    if CUresult(err) == CUresult(0):
        pynodes = [CUgraphNode(init_value=<void_ptr>cynodes[idx]) for idx in range(_graph_length)]
    if cynodes is not NULL:
        free(cynodes)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], pynodes, numNodes)
{{endif}}

{{if 'cuGraphGetRootNodes' in found_functions}}

@cython.embedsignature(True)
def cuGraphGetRootNodes(hGraph, size_t numRootNodes = 0):
    """ Returns a graph's root nodes.

    Returns a list of `hGraph's` root nodes. `rootNodes` may be NULL, in
    which case this function will return the number of root nodes in
    `numRootNodes`. Otherwise, `numRootNodes` entries will be filled in. If
    `numRootNodes` is higher than the actual number of root nodes, the
    remaining entries in `rootNodes` will be set to NULL, and the number of
    nodes actually obtained will be returned in `numRootNodes`.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to query
    numRootNodes : int
        See description

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    rootNodes : list[:py:obj:`~.CUgraphNode`]
        Pointer to return the root nodes
    numRootNodes : int
        See description

    See Also
    --------
    :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphNodeGetType`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """
    cdef size_t _graph_length = numRootNodes
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef cydriver.CUgraphNode* cyrootNodes = NULL
    pyrootNodes = []
    if _graph_length != 0:
        cyrootNodes = <cydriver.CUgraphNode*>calloc(_graph_length, sizeof(cydriver.CUgraphNode))
        if cyrootNodes is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cydriver.CUgraphNode)))
    with nogil:
        err = cydriver.cuGraphGetRootNodes(cyhGraph, cyrootNodes, &numRootNodes)
    if CUresult(err) == CUresult(0):
        pyrootNodes = [CUgraphNode(init_value=<void_ptr>cyrootNodes[idx]) for idx in range(_graph_length)]
    if cyrootNodes is not NULL:
        free(cyrootNodes)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], pyrootNodes, numRootNodes)
{{endif}}

{{if 'cuGraphGetEdges_v2' in found_functions}}

@cython.embedsignature(True)
def cuGraphGetEdges(hGraph, size_t numEdges = 0):
    """ Returns a graph's dependency edges.

    Returns a list of `hGraph's` dependency edges. Edges are returned via
    corresponding indices in `from`, `to` and `edgeData`; that is, the node
    in `to`[i] has a dependency on the node in `from`[i] with data
    `edgeData`[i]. `from` and `to` may both be NULL, in which case this
    function only returns the number of edges in `numEdges`. Otherwise,
    `numEdges` entries will be filled in. If `numEdges` is higher than the
    actual number of edges, the remaining entries in `from` and `to` will
    be set to NULL, and the number of edges actually returned will be
    written to `numEdges`. `edgeData` may alone be NULL, in which case the
    edges must all have default (zeroed) edge data. Attempting a lossy
    query via NULL `edgeData` will result in
    :py:obj:`~.CUDA_ERROR_LOSSY_QUERY`. If `edgeData` is non-NULL then
    `from` and `to` must be as well.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to get the edges from
    numEdges : int
        See description

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_LOSSY_QUERY`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    from : list[:py:obj:`~.CUgraphNode`]
        Location to return edge endpoints
    to : list[:py:obj:`~.CUgraphNode`]
        Location to return edge endpoints
    edgeData : list[:py:obj:`~.CUgraphEdgeData`]
        Optional location to return edge data
    numEdges : int
        See description

    See Also
    --------
    :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphAddDependencies`, :py:obj:`~.cuGraphRemoveDependencies`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """
    cdef size_t _graph_length = numEdges
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef cydriver.CUgraphNode* cyfrom_ = NULL
    pyfrom_ = []
    if _graph_length != 0:
        cyfrom_ = <cydriver.CUgraphNode*>calloc(_graph_length, sizeof(cydriver.CUgraphNode))
        if cyfrom_ is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cydriver.CUgraphNode)))
    cdef cydriver.CUgraphNode* cyto = NULL
    pyto = []
    if _graph_length != 0:
        cyto = <cydriver.CUgraphNode*>calloc(_graph_length, sizeof(cydriver.CUgraphNode))
        if cyto is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cydriver.CUgraphNode)))
    cdef cydriver.CUgraphEdgeData* cyedgeData = NULL
    pyedgeData = []
    if _graph_length != 0:
        cyedgeData = <cydriver.CUgraphEdgeData*>calloc(_graph_length, sizeof(cydriver.CUgraphEdgeData))
        if cyedgeData is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cydriver.CUgraphEdgeData)))
    with nogil:
        err = cydriver.cuGraphGetEdges(cyhGraph, cyfrom_, cyto, cyedgeData, &numEdges)
    if CUresult(err) == CUresult(0):
        pyfrom_ = [CUgraphNode(init_value=<void_ptr>cyfrom_[idx]) for idx in range(_graph_length)]
    if cyfrom_ is not NULL:
        free(cyfrom_)
    if CUresult(err) == CUresult(0):
        pyto = [CUgraphNode(init_value=<void_ptr>cyto[idx]) for idx in range(_graph_length)]
    if cyto is not NULL:
        free(cyto)
    if CUresult(err) == CUresult(0):
        pyedgeData = [CUgraphEdgeData(_ptr=<void_ptr>&cyedgeData[idx]) for idx in range(_graph_length)]
    if cyedgeData is not NULL:
        free(cyedgeData)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None, None, None)
    return (_dict_CUresult[err], pyfrom_, pyto, pyedgeData, numEdges)
{{endif}}

{{if 'cuGraphNodeGetDependencies_v2' in found_functions}}

@cython.embedsignature(True)
def cuGraphNodeGetDependencies(hNode, size_t numDependencies = 0):
    """ Returns a node's dependencies.

    Returns a list of `node's` dependencies. `dependencies` may be NULL, in
    which case this function will return the number of dependencies in
    `numDependencies`. Otherwise, `numDependencies` entries will be filled
    in. If `numDependencies` is higher than the actual number of
    dependencies, the remaining entries in `dependencies` will be set to
    NULL, and the number of nodes actually obtained will be returned in
    `numDependencies`.

    Note that if an edge has non-zero (non-default) edge data and
    `edgeData` is NULL, this API will return
    :py:obj:`~.CUDA_ERROR_LOSSY_QUERY`. If `edgeData` is non-NULL, then
    `dependencies` must be as well.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to query
    numDependencies : int
        See description

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_LOSSY_QUERY`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    dependencies : list[:py:obj:`~.CUgraphNode`]
        Pointer to return the dependencies
    edgeData : list[:py:obj:`~.CUgraphEdgeData`]
        Optional array to return edge data for each dependency
    numDependencies : int
        See description

    See Also
    --------
    :py:obj:`~.cuGraphNodeGetDependentNodes`, :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphAddDependencies`, :py:obj:`~.cuGraphRemoveDependencies`
    """
    cdef size_t _graph_length = numDependencies
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUgraphNode* cydependencies = NULL
    pydependencies = []
    if _graph_length != 0:
        cydependencies = <cydriver.CUgraphNode*>calloc(_graph_length, sizeof(cydriver.CUgraphNode))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cydriver.CUgraphNode)))
    cdef cydriver.CUgraphEdgeData* cyedgeData = NULL
    pyedgeData = []
    if _graph_length != 0:
        cyedgeData = <cydriver.CUgraphEdgeData*>calloc(_graph_length, sizeof(cydriver.CUgraphEdgeData))
        if cyedgeData is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cydriver.CUgraphEdgeData)))
    with nogil:
        err = cydriver.cuGraphNodeGetDependencies(cyhNode, cydependencies, cyedgeData, &numDependencies)
    if CUresult(err) == CUresult(0):
        pydependencies = [CUgraphNode(init_value=<void_ptr>cydependencies[idx]) for idx in range(_graph_length)]
    if cydependencies is not NULL:
        free(cydependencies)
    if CUresult(err) == CUresult(0):
        pyedgeData = [CUgraphEdgeData(_ptr=<void_ptr>&cyedgeData[idx]) for idx in range(_graph_length)]
    if cyedgeData is not NULL:
        free(cyedgeData)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None, None)
    return (_dict_CUresult[err], pydependencies, pyedgeData, numDependencies)
{{endif}}

{{if 'cuGraphNodeGetDependentNodes_v2' in found_functions}}

@cython.embedsignature(True)
def cuGraphNodeGetDependentNodes(hNode, size_t numDependentNodes = 0):
    """ Returns a node's dependent nodes.

    Returns a list of `node's` dependent nodes. `dependentNodes` may be
    NULL, in which case this function will return the number of dependent
    nodes in `numDependentNodes`. Otherwise, `numDependentNodes` entries
    will be filled in. If `numDependentNodes` is higher than the actual
    number of dependent nodes, the remaining entries in `dependentNodes`
    will be set to NULL, and the number of nodes actually obtained will be
    returned in `numDependentNodes`.

    Note that if an edge has non-zero (non-default) edge data and
    `edgeData` is NULL, this API will return
    :py:obj:`~.CUDA_ERROR_LOSSY_QUERY`. If `edgeData` is non-NULL, then
    `dependentNodes` must be as well.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to query
    numDependentNodes : int
        See description

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_LOSSY_QUERY`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    dependentNodes : list[:py:obj:`~.CUgraphNode`]
        Pointer to return the dependent nodes
    edgeData : list[:py:obj:`~.CUgraphEdgeData`]
        Optional pointer to return edge data for dependent nodes
    numDependentNodes : int
        See description

    See Also
    --------
    :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphAddDependencies`, :py:obj:`~.cuGraphRemoveDependencies`
    """
    cdef size_t _graph_length = numDependentNodes
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUgraphNode* cydependentNodes = NULL
    pydependentNodes = []
    if _graph_length != 0:
        cydependentNodes = <cydriver.CUgraphNode*>calloc(_graph_length, sizeof(cydriver.CUgraphNode))
        if cydependentNodes is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cydriver.CUgraphNode)))
    cdef cydriver.CUgraphEdgeData* cyedgeData = NULL
    pyedgeData = []
    if _graph_length != 0:
        cyedgeData = <cydriver.CUgraphEdgeData*>calloc(_graph_length, sizeof(cydriver.CUgraphEdgeData))
        if cyedgeData is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cydriver.CUgraphEdgeData)))
    with nogil:
        err = cydriver.cuGraphNodeGetDependentNodes(cyhNode, cydependentNodes, cyedgeData, &numDependentNodes)
    if CUresult(err) == CUresult(0):
        pydependentNodes = [CUgraphNode(init_value=<void_ptr>cydependentNodes[idx]) for idx in range(_graph_length)]
    if cydependentNodes is not NULL:
        free(cydependentNodes)
    if CUresult(err) == CUresult(0):
        pyedgeData = [CUgraphEdgeData(_ptr=<void_ptr>&cyedgeData[idx]) for idx in range(_graph_length)]
    if cyedgeData is not NULL:
        free(cyedgeData)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None, None)
    return (_dict_CUresult[err], pydependentNodes, pyedgeData, numDependentNodes)
{{endif}}

{{if 'cuGraphAddDependencies_v2' in found_functions}}

@cython.embedsignature(True)
def cuGraphAddDependencies(hGraph, from_ : Optional[tuple[CUgraphNode] | list[CUgraphNode]], to : Optional[tuple[CUgraphNode] | list[CUgraphNode]], edgeData : Optional[tuple[CUgraphEdgeData] | list[CUgraphEdgeData]], size_t numDependencies):
    """ Adds dependency edges to a graph.

    The number of dependencies to be added is defined by `numDependencies`
    Elements in `from` and `to` at corresponding indices define a
    dependency. Each node in `from` and `to` must belong to `hGraph`.

    If `numDependencies` is 0, elements in `from` and `to` will be ignored.
    Specifying an existing dependency will return an error.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which dependencies are added
    from : list[:py:obj:`~.CUgraphNode`]
        Array of nodes that provide the dependencies
    to : list[:py:obj:`~.CUgraphNode`]
        Array of dependent nodes
    edgeData : list[:py:obj:`~.CUgraphEdgeData`]
        Optional array of edge data. If NULL, default (zeroed) edge data is
        assumed.
    numDependencies : size_t
        Number of dependencies to be added

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuGraphRemoveDependencies`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """
    edgeData = [] if edgeData is None else edgeData
    if not all(isinstance(_x, (CUgraphEdgeData,)) for _x in edgeData):
        raise TypeError("Argument 'edgeData' is not instance of type (expected tuple[cydriver.CUgraphEdgeData,] or list[cydriver.CUgraphEdgeData,]")
    to = [] if to is None else to
    if not all(isinstance(_x, (CUgraphNode,)) for _x in to):
        raise TypeError("Argument 'to' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    from_ = [] if from_ is None else from_
    if not all(isinstance(_x, (CUgraphNode,)) for _x in from_):
        raise TypeError("Argument 'from_' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef cydriver.CUgraphNode* cyfrom_ = NULL
    if len(from_) > 1:
        cyfrom_ = <cydriver.CUgraphNode*> calloc(len(from_), sizeof(cydriver.CUgraphNode))
        if cyfrom_ is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(from_)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(from_)):
                cyfrom_[idx] = <cydriver.CUgraphNode>(<CUgraphNode>from_[idx])._pvt_ptr[0]
    elif len(from_) == 1:
        cyfrom_ = <cydriver.CUgraphNode*>(<CUgraphNode>from_[0])._pvt_ptr
    cdef cydriver.CUgraphNode* cyto = NULL
    if len(to) > 1:
        cyto = <cydriver.CUgraphNode*> calloc(len(to), sizeof(cydriver.CUgraphNode))
        if cyto is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(to)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(to)):
                cyto[idx] = <cydriver.CUgraphNode>(<CUgraphNode>to[idx])._pvt_ptr[0]
    elif len(to) == 1:
        cyto = <cydriver.CUgraphNode*>(<CUgraphNode>to[0])._pvt_ptr
    cdef cydriver.CUgraphEdgeData* cyedgeData = NULL
    if len(edgeData) > 1:
        cyedgeData = <cydriver.CUgraphEdgeData*> calloc(len(edgeData), sizeof(cydriver.CUgraphEdgeData))
        if cyedgeData is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(edgeData)) + 'x' + str(sizeof(cydriver.CUgraphEdgeData)))
        for idx in range(len(edgeData)):
            string.memcpy(&cyedgeData[idx], (<CUgraphEdgeData>edgeData[idx])._pvt_ptr, sizeof(cydriver.CUgraphEdgeData))
    elif len(edgeData) == 1:
        cyedgeData = (<CUgraphEdgeData>edgeData[0])._pvt_ptr
    with nogil:
        err = cydriver.cuGraphAddDependencies(cyhGraph, cyfrom_, cyto, cyedgeData, numDependencies)
    if len(from_) > 1 and cyfrom_ is not NULL:
        free(cyfrom_)
    if len(to) > 1 and cyto is not NULL:
        free(cyto)
    if len(edgeData) > 1 and cyedgeData is not NULL:
        free(cyedgeData)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphRemoveDependencies_v2' in found_functions}}

@cython.embedsignature(True)
def cuGraphRemoveDependencies(hGraph, from_ : Optional[tuple[CUgraphNode] | list[CUgraphNode]], to : Optional[tuple[CUgraphNode] | list[CUgraphNode]], edgeData : Optional[tuple[CUgraphEdgeData] | list[CUgraphEdgeData]], size_t numDependencies):
    """ Removes dependency edges from a graph.

    The number of `dependencies` to be removed is defined by
    `numDependencies`. Elements in `from` and `to` at corresponding indices
    define a dependency. Each node in `from` and `to` must belong to
    `hGraph`.

    If `numDependencies` is 0, elements in `from` and `to` will be ignored.
    Specifying an edge that does not exist in the graph, with data matching
    `edgeData`, results in an error. `edgeData` is nullable, which is
    equivalent to passing default (zeroed) data for each edge.

    Dependencies cannot be removed from graphs which contain allocation or
    free nodes. Any attempt to do so will return an error.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph from which to remove dependencies
    from : list[:py:obj:`~.CUgraphNode`]
        Array of nodes that provide the dependencies
    to : list[:py:obj:`~.CUgraphNode`]
        Array of dependent nodes
    edgeData : list[:py:obj:`~.CUgraphEdgeData`]
        Optional array of edge data. If NULL, edge data is assumed to be
        default (zeroed).
    numDependencies : size_t
        Number of dependencies to be removed

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuGraphAddDependencies`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """
    edgeData = [] if edgeData is None else edgeData
    if not all(isinstance(_x, (CUgraphEdgeData,)) for _x in edgeData):
        raise TypeError("Argument 'edgeData' is not instance of type (expected tuple[cydriver.CUgraphEdgeData,] or list[cydriver.CUgraphEdgeData,]")
    to = [] if to is None else to
    if not all(isinstance(_x, (CUgraphNode,)) for _x in to):
        raise TypeError("Argument 'to' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    from_ = [] if from_ is None else from_
    if not all(isinstance(_x, (CUgraphNode,)) for _x in from_):
        raise TypeError("Argument 'from_' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef cydriver.CUgraphNode* cyfrom_ = NULL
    if len(from_) > 1:
        cyfrom_ = <cydriver.CUgraphNode*> calloc(len(from_), sizeof(cydriver.CUgraphNode))
        if cyfrom_ is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(from_)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(from_)):
                cyfrom_[idx] = <cydriver.CUgraphNode>(<CUgraphNode>from_[idx])._pvt_ptr[0]
    elif len(from_) == 1:
        cyfrom_ = <cydriver.CUgraphNode*>(<CUgraphNode>from_[0])._pvt_ptr
    cdef cydriver.CUgraphNode* cyto = NULL
    if len(to) > 1:
        cyto = <cydriver.CUgraphNode*> calloc(len(to), sizeof(cydriver.CUgraphNode))
        if cyto is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(to)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(to)):
                cyto[idx] = <cydriver.CUgraphNode>(<CUgraphNode>to[idx])._pvt_ptr[0]
    elif len(to) == 1:
        cyto = <cydriver.CUgraphNode*>(<CUgraphNode>to[0])._pvt_ptr
    cdef cydriver.CUgraphEdgeData* cyedgeData = NULL
    if len(edgeData) > 1:
        cyedgeData = <cydriver.CUgraphEdgeData*> calloc(len(edgeData), sizeof(cydriver.CUgraphEdgeData))
        if cyedgeData is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(edgeData)) + 'x' + str(sizeof(cydriver.CUgraphEdgeData)))
        for idx in range(len(edgeData)):
            string.memcpy(&cyedgeData[idx], (<CUgraphEdgeData>edgeData[idx])._pvt_ptr, sizeof(cydriver.CUgraphEdgeData))
    elif len(edgeData) == 1:
        cyedgeData = (<CUgraphEdgeData>edgeData[0])._pvt_ptr
    with nogil:
        err = cydriver.cuGraphRemoveDependencies(cyhGraph, cyfrom_, cyto, cyedgeData, numDependencies)
    if len(from_) > 1 and cyfrom_ is not NULL:
        free(cyfrom_)
    if len(to) > 1 and cyto is not NULL:
        free(cyto)
    if len(edgeData) > 1 and cyedgeData is not NULL:
        free(cyedgeData)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphDestroyNode' in found_functions}}

@cython.embedsignature(True)
def cuGraphDestroyNode(hNode):
    """ Remove a node from the graph.

    Removes `hNode` from its graph. This operation also severs any
    dependencies of other nodes on `hNode` and vice versa.

    Nodes which belong to a graph which contains allocation or free nodes
    cannot be destroyed. Any attempt to do so will return an error.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to remove

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    with nogil:
        err = cydriver.cuGraphDestroyNode(cyhNode)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphInstantiateWithFlags' in found_functions}}

@cython.embedsignature(True)
def cuGraphInstantiate(hGraph, unsigned long long flags):
    """ Creates an executable graph from a graph.

    Instantiates `hGraph` as an executable graph. The graph is validated
    for any structural constraints or intra-node constraints which were not
    previously validated. If instantiation is successful, a handle to the
    instantiated graph is returned in `phGraphExec`.

    The `flags` parameter controls the behavior of instantiation and
    subsequent graph launches. Valid flags are:

    - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH`, which
      configures a graph containing memory allocation nodes to
      automatically free any unfreed memory allocations before the graph is
      relaunched.

    - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH`, which
      configures the graph for launch from the device. If this flag is
      passed, the executable graph handle returned can be used to launch
      the graph from both the host and device. This flag can only be used
      on platforms which support unified addressing. This flag cannot be
      used in conjunction with
      :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH`.

    - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY`, which
      causes the graph to use the priorities from the per-node attributes
      rather than the priority of the launch stream during execution. Note
      that priorities are only available on kernel nodes, and are copied
      from stream priority during stream capture.

    If `hGraph` contains any allocation or free nodes, there can be at most
    one executable graph in existence for that graph at a time. An attempt
    to instantiate a second executable graph before destroying the first
    with :py:obj:`~.cuGraphExecDestroy` will result in an error. The same
    also applies if `hGraph` contains any device-updatable kernel nodes.

    If `hGraph` contains kernels which call device-side cudaGraphLaunch()
    from multiple contexts, this will result in an error.

    Graphs instantiated for launch on the device have additional
    restrictions which do not apply to host graphs:

    - The graph's nodes must reside on a single context.

    - The graph can only contain kernel nodes, memcpy nodes, memset nodes,
      and child graph nodes.

    - The graph cannot be empty and must contain at least one kernel,
      memcpy, or memset node. Operation-specific restrictions are outlined
      below.

    - Kernel nodes:

      - Use of CUDA Dynamic Parallelism is not permitted.

      - Cooperative launches are permitted as long as MPS is not in use.

    - Memcpy nodes:

      - Only copies involving device memory and/or pinned device-mapped
        host memory are permitted.

      - Copies involving CUDA arrays are not permitted.

      - Both operands must be accessible from the current context, and the
        current context must match the context of other nodes in the graph.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to instantiate
    flags : unsigned long long
        Flags to control instantiation. See
        :py:obj:`~.CUgraphInstantiate_flags`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphExec : :py:obj:`~.CUgraphExec`
        Returns instantiated graph

    See Also
    --------
    :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphUpload`, :py:obj:`~.cuGraphLaunch`, :py:obj:`~.cuGraphExecDestroy`
    """
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef CUgraphExec phGraphExec = CUgraphExec()
    with nogil:
        err = cydriver.cuGraphInstantiate(<cydriver.CUgraphExec*>phGraphExec._pvt_ptr, cyhGraph, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraphExec)
{{endif}}

{{if 'cuGraphInstantiateWithParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphInstantiateWithParams(hGraph, instantiateParams : Optional[CUDA_GRAPH_INSTANTIATE_PARAMS]):
    """ Creates an executable graph from a graph.

    Instantiates `hGraph` as an executable graph according to the
    `instantiateParams` structure. The graph is validated for any
    structural constraints or intra-node constraints which were not
    previously validated. If instantiation is successful, a handle to the
    instantiated graph is returned in `phGraphExec`.

    `instantiateParams` controls the behavior of instantiation and
    subsequent graph launches, as well as returning more detailed
    information in the event of an error.
    :py:obj:`~.CUDA_GRAPH_INSTANTIATE_PARAMS` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    The `flags` field controls the behavior of instantiation and subsequent
    graph launches. Valid flags are:

    - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH`, which
      configures a graph containing memory allocation nodes to
      automatically free any unfreed memory allocations before the graph is
      relaunched.

    - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD`, which will perform an
      upload of the graph into `hUploadStream` once the graph has been
      instantiated.

    - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH`, which
      configures the graph for launch from the device. If this flag is
      passed, the executable graph handle returned can be used to launch
      the graph from both the host and device. This flag can only be used
      on platforms which support unified addressing. This flag cannot be
      used in conjunction with
      :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH`.

    - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY`, which
      causes the graph to use the priorities from the per-node attributes
      rather than the priority of the launch stream during execution. Note
      that priorities are only available on kernel nodes, and are copied
      from stream priority during stream capture.

    If `hGraph` contains any allocation or free nodes, there can be at most
    one executable graph in existence for that graph at a time. An attempt
    to instantiate a second executable graph before destroying the first
    with :py:obj:`~.cuGraphExecDestroy` will result in an error. The same
    also applies if `hGraph` contains any device-updatable kernel nodes.

    If `hGraph` contains kernels which call device-side cudaGraphLaunch()
    from multiple contexts, this will result in an error.

    Graphs instantiated for launch on the device have additional
    restrictions which do not apply to host graphs:

    - The graph's nodes must reside on a single context.

    - The graph can only contain kernel nodes, memcpy nodes, memset nodes,
      and child graph nodes.

    - The graph cannot be empty and must contain at least one kernel,
      memcpy, or memset node. Operation-specific restrictions are outlined
      below.

    - Kernel nodes:

      - Use of CUDA Dynamic Parallelism is not permitted.

      - Cooperative launches are permitted as long as MPS is not in use.

    - Memcpy nodes:

      - Only copies involving device memory and/or pinned device-mapped
        host memory are permitted.

      - Copies involving CUDA arrays are not permitted.

      - Both operands must be accessible from the current context, and the
        current context must match the context of other nodes in the graph.

    In the event of an error, the `result_out` and `hErrNode_out` fields
    will contain more information about the nature of the error. Possible
    error reporting includes:

    - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_ERROR`, if passed an invalid value
      or if an unexpected error occurred which is described by the return
      value of the function. `hErrNode_out` will be set to NULL.

    - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_INVALID_STRUCTURE`, if the graph
      structure is invalid. `hErrNode_out` will be set to one of the
      offending nodes.

    - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_NODE_OPERATION_NOT_SUPPORTED`, if
      the graph is instantiated for device launch but contains a node of an
      unsupported node type, or a node which performs unsupported
      operations, such as use of CUDA dynamic parallelism within a kernel
      node. `hErrNode_out` will be set to this node.

    - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_MULTIPLE_CTXS_NOT_SUPPORTED`, if
      the graph is instantiated for device launch but a nodes context
      differs from that of another node. This error can also be returned if
      a graph is not instantiated for device launch and it contains kernels
      which call device-side cudaGraphLaunch() from multiple contexts.
      `hErrNode_out` will be set to this node.

    If instantiation is successful, `result_out` will be set to
    :py:obj:`~.CUDA_GRAPH_INSTANTIATE_SUCCESS`, and `hErrNode_out` will be
    set to NULL.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to instantiate
    instantiateParams : :py:obj:`~.CUDA_GRAPH_INSTANTIATE_PARAMS`
        Instantiation parameters

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    phGraphExec : :py:obj:`~.CUgraphExec`
        Returns instantiated graph

    See Also
    --------
    :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphExecDestroy`
    """
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef CUgraphExec phGraphExec = CUgraphExec()
    cdef cydriver.CUDA_GRAPH_INSTANTIATE_PARAMS* cyinstantiateParams_ptr = instantiateParams._pvt_ptr if instantiateParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphInstantiateWithParams(<cydriver.CUgraphExec*>phGraphExec._pvt_ptr, cyhGraph, cyinstantiateParams_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraphExec)
{{endif}}

{{if 'cuGraphExecGetFlags' in found_functions}}

@cython.embedsignature(True)
def cuGraphExecGetFlags(hGraphExec):
    """ Query the instantiation flags of an executable graph.

    Returns the flags that were passed to instantiation for the given
    executable graph. :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD` will
    not be returned by this API as it does not affect the resulting
    executable graph.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    flags : :py:obj:`~.cuuint64_t`
        Returns the instantiation flags

    See Also
    --------
    :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphInstantiateWithParams`
    """
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    cdef cuuint64_t flags = cuuint64_t()
    with nogil:
        err = cydriver.cuGraphExecGetFlags(cyhGraphExec, <cydriver.cuuint64_t*>flags._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], flags)
{{endif}}

{{if 'cuGraphExecKernelNodeSetParams_v2' in found_functions}}

@cython.embedsignature(True)
def cuGraphExecKernelNodeSetParams(hGraphExec, hNode, nodeParams : Optional[CUDA_KERNEL_NODE_PARAMS]):
    """ Sets the parameters for a kernel node in the given graphExec.

    Sets the parameters of a kernel node in an executable graph
    `hGraphExec`. The node is identified by the corresponding node `hNode`
    in the non-executable graph, from which the executable graph was
    instantiated.

    `hNode` must not have been removed from the original graph. All
    `nodeParams` fields may change, but the following restrictions apply to
    `func` updates:

    - The owning context of the function cannot change.

    - A node whose function originally did not use CUDA dynamic parallelism
      cannot be updated to a function which uses CDP

    - A node whose function originally did not make device-side update
      calls cannot be updated to a function which makes device-side update
      calls.

    - If `hGraphExec` was not instantiated for device launch, a node whose
      function originally did not use device-side cudaGraphLaunch() cannot
      be updated to a function which uses device-side cudaGraphLaunch()
      unless the node resides on the same context as nodes which contained
      such calls at instantiate-time. If no such calls were present at
      instantiation, these updates cannot be performed at all.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    If `hNode` is a device-updatable kernel node, the next upload/launch of
    `hGraphExec` will overwrite any previous device-side updates.
    Additionally, applying host updates to a device-updatable kernel node
    while it is being updated from the device will result in undefined
    behavior.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        kernel node from the graph from which graphExec was instantiated
    nodeParams : :py:obj:`~.CUDA_KERNEL_NODE_PARAMS`
        Updated Parameters to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    cdef cydriver.CUDA_KERNEL_NODE_PARAMS* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphExecKernelNodeSetParams(cyhGraphExec, cyhNode, cynodeParams_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphExecMemcpyNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphExecMemcpyNodeSetParams(hGraphExec, hNode, copyParams : Optional[CUDA_MEMCPY3D], ctx):
    """ Sets the parameters for a memcpy node in the given graphExec.

    Updates the work represented by `hNode` in `hGraphExec` as though
    `hNode` had contained `copyParams` at instantiation. hNode must remain
    in the graph which was used to instantiate `hGraphExec`. Changed edges
    to and from hNode are ignored.

    The source and destination memory in `copyParams` must be allocated
    from the same contexts as the original source and destination memory.
    Both the instantiation-time memory operands and the memory operands in
    `copyParams` must be 1-dimensional. Zero-length operations are not
    supported.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. hNode is also not modified by this call.

    Returns CUDA_ERROR_INVALID_VALUE if the memory operands' mappings
    changed or either the original or new memory operands are
    multidimensional.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Memcpy node from the graph which was used to instantiate graphExec
    copyParams : :py:obj:`~.CUDA_MEMCPY3D`
        The updated parameters to set
    ctx : :py:obj:`~.CUcontext`
        Context on which to run the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef cydriver.CUcontext cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (CUcontext,)):
        pctx = int(ctx)
    else:
        pctx = int(CUcontext(ctx))
    cyctx = <cydriver.CUcontext><void_ptr>pctx
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    cdef cydriver.CUDA_MEMCPY3D* cycopyParams_ptr = copyParams._pvt_ptr if copyParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphExecMemcpyNodeSetParams(cyhGraphExec, cyhNode, cycopyParams_ptr, cyctx)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphExecMemsetNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphExecMemsetNodeSetParams(hGraphExec, hNode, memsetParams : Optional[CUDA_MEMSET_NODE_PARAMS], ctx):
    """ Sets the parameters for a memset node in the given graphExec.

    Updates the work represented by `hNode` in `hGraphExec` as though
    `hNode` had contained `memsetParams` at instantiation. hNode must
    remain in the graph which was used to instantiate `hGraphExec`. Changed
    edges to and from hNode are ignored.

    Zero sized operations are not supported.

    The new destination pointer in memsetParams must be to the same kind of
    allocation as the original destination pointer and have the same
    context association and device mapping as the original destination
    pointer.

    Both the value and pointer address may be updated.   Changing other
    aspects of the memset (width, height, element size or pitch) may cause
    the update to be rejected. Specifically, for 2d memsets, all dimension
    changes are rejected. For 1d memsets, changes in height are explicitly
    rejected and other changes are opportunistically allowed if the
    resulting work maps onto the work resources already allocated for the
    node.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. hNode is also not modified by this call.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Memset node from the graph which was used to instantiate graphExec
    memsetParams : :py:obj:`~.CUDA_MEMSET_NODE_PARAMS`
        The updated parameters to set
    ctx : :py:obj:`~.CUcontext`
        Context on which to run the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddMemsetNode`, :py:obj:`~.cuGraphMemsetNodeSetParams`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef cydriver.CUcontext cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (CUcontext,)):
        pctx = int(ctx)
    else:
        pctx = int(CUcontext(ctx))
    cyctx = <cydriver.CUcontext><void_ptr>pctx
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    cdef cydriver.CUDA_MEMSET_NODE_PARAMS* cymemsetParams_ptr = memsetParams._pvt_ptr if memsetParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphExecMemsetNodeSetParams(cyhGraphExec, cyhNode, cymemsetParams_ptr, cyctx)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphExecHostNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphExecHostNodeSetParams(hGraphExec, hNode, nodeParams : Optional[CUDA_HOST_NODE_PARAMS]):
    """ Sets the parameters for a host node in the given graphExec.

    Updates the work represented by `hNode` in `hGraphExec` as though
    `hNode` had contained `nodeParams` at instantiation. hNode must remain
    in the graph which was used to instantiate `hGraphExec`. Changed edges
    to and from hNode are ignored.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. hNode is also not modified by this call.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Host node from the graph which was used to instantiate graphExec
    nodeParams : :py:obj:`~.CUDA_HOST_NODE_PARAMS`
        The updated parameters to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphHostNodeSetParams`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    cdef cydriver.CUDA_HOST_NODE_PARAMS* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphExecHostNodeSetParams(cyhGraphExec, cyhNode, cynodeParams_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphExecChildGraphNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphExecChildGraphNodeSetParams(hGraphExec, hNode, childGraph):
    """ Updates node parameters in the child graph node in the given graphExec.

    Updates the work represented by `hNode` in `hGraphExec` as though the
    nodes contained in `hNode's` graph had the parameters contained in
    `childGraph's` nodes at instantiation. `hNode` must remain in the graph
    which was used to instantiate `hGraphExec`. Changed edges to and from
    `hNode` are ignored.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    The topology of `childGraph`, as well as the node insertion order, must
    match that of the graph contained in `hNode`. See
    :py:obj:`~.cuGraphExecUpdate()` for a list of restrictions on what can
    be updated in an instantiated graph. The update is recursive, so child
    graph nodes contained within the top level child graph will also be
    updated.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Host node from the graph which was used to instantiate graphExec
    childGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph supplying the updated parameters

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphChildGraphNodeGetGraph`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef cydriver.CUgraph cychildGraph
    if childGraph is None:
        pchildGraph = 0
    elif isinstance(childGraph, (CUgraph,)):
        pchildGraph = int(childGraph)
    else:
        pchildGraph = int(CUgraph(childGraph))
    cychildGraph = <cydriver.CUgraph><void_ptr>pchildGraph
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    with nogil:
        err = cydriver.cuGraphExecChildGraphNodeSetParams(cyhGraphExec, cyhNode, cychildGraph)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphExecEventRecordNodeSetEvent' in found_functions}}

@cython.embedsignature(True)
def cuGraphExecEventRecordNodeSetEvent(hGraphExec, hNode, event):
    """ Sets the event for an event record node in the given graphExec.

    Sets the event of an event record node in an executable graph
    `hGraphExec`. The node is identified by the corresponding node `hNode`
    in the non-executable graph, from which the executable graph was
    instantiated.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        event record node from the graph from which graphExec was
        instantiated
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Updated event to use

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphEventRecordNodeGetEvent`, :py:obj:`~.cuGraphEventWaitNodeSetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef cydriver.CUevent cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (CUevent,)):
        pevent = int(event)
    else:
        pevent = int(CUevent(event))
    cyevent = <cydriver.CUevent><void_ptr>pevent
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    with nogil:
        err = cydriver.cuGraphExecEventRecordNodeSetEvent(cyhGraphExec, cyhNode, cyevent)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphExecEventWaitNodeSetEvent' in found_functions}}

@cython.embedsignature(True)
def cuGraphExecEventWaitNodeSetEvent(hGraphExec, hNode, event):
    """ Sets the event for an event wait node in the given graphExec.

    Sets the event of an event wait node in an executable graph
    `hGraphExec`. The node is identified by the corresponding node `hNode`
    in the non-executable graph, from which the executable graph was
    instantiated.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        event wait node from the graph from which graphExec was
        instantiated
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Updated event to use

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphEventWaitNodeGetEvent`, :py:obj:`~.cuGraphEventRecordNodeSetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef cydriver.CUevent cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (CUevent,)):
        pevent = int(event)
    else:
        pevent = int(CUevent(event))
    cyevent = <cydriver.CUevent><void_ptr>pevent
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    with nogil:
        err = cydriver.cuGraphExecEventWaitNodeSetEvent(cyhGraphExec, cyhNode, cyevent)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphExecExternalSemaphoresSignalNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphExecExternalSemaphoresSignalNodeSetParams(hGraphExec, hNode, nodeParams : Optional[CUDA_EXT_SEM_SIGNAL_NODE_PARAMS]):
    """ Sets the parameters for an external semaphore signal node in the given graphExec.

    Sets the parameters of an external semaphore signal node in an
    executable graph `hGraphExec`. The node is identified by the
    corresponding node `hNode` in the non-executable graph, from which the
    executable graph was instantiated.

    `hNode` must not have been removed from the original graph.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    Changing `nodeParams->numExtSems` is not supported.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        semaphore signal node from the graph from which graphExec was
        instantiated
    nodeParams : :py:obj:`~.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS`
        Updated Parameters to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    cdef cydriver.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphExecExternalSemaphoresSignalNodeSetParams(cyhGraphExec, cyhNode, cynodeParams_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphExecExternalSemaphoresWaitNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphExecExternalSemaphoresWaitNodeSetParams(hGraphExec, hNode, nodeParams : Optional[CUDA_EXT_SEM_WAIT_NODE_PARAMS]):
    """ Sets the parameters for an external semaphore wait node in the given graphExec.

    Sets the parameters of an external semaphore wait node in an executable
    graph `hGraphExec`. The node is identified by the corresponding node
    `hNode` in the non-executable graph, from which the executable graph
    was instantiated.

    `hNode` must not have been removed from the original graph.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    Changing `nodeParams->numExtSems` is not supported.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        semaphore wait node from the graph from which graphExec was
        instantiated
    nodeParams : :py:obj:`~.CUDA_EXT_SEM_WAIT_NODE_PARAMS`
        Updated Parameters to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphExecNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    cdef cydriver.CUDA_EXT_SEM_WAIT_NODE_PARAMS* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphExecExternalSemaphoresWaitNodeSetParams(cyhGraphExec, cyhNode, cynodeParams_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphNodeSetEnabled' in found_functions}}

@cython.embedsignature(True)
def cuGraphNodeSetEnabled(hGraphExec, hNode, unsigned int isEnabled):
    """ Enables or disables the specified node in the given graphExec.

    Sets `hNode` to be either enabled or disabled. Disabled nodes are
    functionally equivalent to empty nodes until they are reenabled.
    Existing node parameters are not affected by disabling/enabling the
    node.

    The node is identified by the corresponding node `hNode` in the non-
    executable graph, from which the executable graph was instantiated.

    `hNode` must not have been removed from the original graph.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    If `hNode` is a device-updatable kernel node, the next upload/launch of
    `hGraphExec` will overwrite any previous device-side updates.
    Additionally, applying host updates to a device-updatable kernel node
    while it is being updated from the device will result in undefined
    behavior.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node from the graph from which graphExec was instantiated
    isEnabled : unsigned int
        Node is enabled if != 0, otherwise the node is disabled

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphNodeGetEnabled`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate` :py:obj:`~.cuGraphLaunch`

    Notes
    -----
    Currently only kernel, memset and memcpy nodes are supported.
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    with nogil:
        err = cydriver.cuGraphNodeSetEnabled(cyhGraphExec, cyhNode, isEnabled)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphNodeGetEnabled' in found_functions}}

@cython.embedsignature(True)
def cuGraphNodeGetEnabled(hGraphExec, hNode):
    """ Query whether a node in the given graphExec is enabled.

    Sets isEnabled to 1 if `hNode` is enabled, or 0 if `hNode` is disabled.

    The node is identified by the corresponding node `hNode` in the non-
    executable graph, from which the executable graph was instantiated.

    `hNode` must not have been removed from the original graph.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node from the graph from which graphExec was instantiated

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    isEnabled : unsigned int
        Location to return the enabled status of the node

    See Also
    --------
    :py:obj:`~.cuGraphNodeSetEnabled`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate` :py:obj:`~.cuGraphLaunch`

    Notes
    -----
    Currently only kernel, memset and memcpy nodes are supported.

    This function will not reflect device-side updates for device-updatable kernel nodes.
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    cdef unsigned int isEnabled = 0
    with nogil:
        err = cydriver.cuGraphNodeGetEnabled(cyhGraphExec, cyhNode, &isEnabled)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], isEnabled)
{{endif}}

{{if 'cuGraphUpload' in found_functions}}

@cython.embedsignature(True)
def cuGraphUpload(hGraphExec, hStream):
    """ Uploads an executable graph in a stream.

    Uploads `hGraphExec` to the device in `hStream` without executing it.
    Uploads of the same `hGraphExec` will be serialized. Each upload is
    ordered behind both any previous work in `hStream` and any previous
    launches of `hGraphExec`. Uses memory cached by `stream` to back the
    allocations owned by `hGraphExec`.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        Executable graph to upload
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream in which to upload the graph

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphLaunch`, :py:obj:`~.cuGraphExecDestroy`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    with nogil:
        err = cydriver.cuGraphUpload(cyhGraphExec, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphLaunch' in found_functions}}

@cython.embedsignature(True)
def cuGraphLaunch(hGraphExec, hStream):
    """ Launches an executable graph in a stream.

    Executes `hGraphExec` in `hStream`. Only one instance of `hGraphExec`
    may be executing at a time. Each launch is ordered behind both any
    previous work in `hStream` and any previous launches of `hGraphExec`.
    To execute a graph concurrently, it must be instantiated multiple times
    into multiple executable graphs.

    If any allocations created by `hGraphExec` remain unfreed (from a
    previous launch) and `hGraphExec` was not instantiated with
    :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH`, the launch
    will fail with :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        Executable graph to launch
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream in which to launch the graph

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphUpload`, :py:obj:`~.cuGraphExecDestroy`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    with nogil:
        err = cydriver.cuGraphLaunch(cyhGraphExec, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphExecDestroy' in found_functions}}

@cython.embedsignature(True)
def cuGraphExecDestroy(hGraphExec):
    """ Destroys an executable graph.

    Destroys the executable graph specified by `hGraphExec`, as well as all
    of its executable nodes. If the executable graph is in-flight, it will
    not be terminated, but rather freed asynchronously on completion.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        Executable graph to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphUpload`, :py:obj:`~.cuGraphLaunch`
    """
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    with nogil:
        err = cydriver.cuGraphExecDestroy(cyhGraphExec)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphDestroy' in found_functions}}

@cython.embedsignature(True)
def cuGraphDestroy(hGraph):
    """ Destroys a graph.

    Destroys the graph specified by `hGraph`, as well as all of its nodes.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuGraphCreate`
    """
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    with nogil:
        err = cydriver.cuGraphDestroy(cyhGraph)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphExecUpdate_v2' in found_functions}}

@cython.embedsignature(True)
def cuGraphExecUpdate(hGraphExec, hGraph):
    """ Check whether an executable graph can be updated with a graph and perform the update if possible.

    Updates the node parameters in the instantiated graph specified by
    `hGraphExec` with the node parameters in a topologically identical
    graph specified by `hGraph`.

    Limitations:

    - Kernel nodes:

      - The owning context of the function cannot change.

      - A node whose function originally did not use CUDA dynamic
        parallelism cannot be updated to a function which uses CDP.

      - A node whose function originally did not make device-side update
        calls cannot be updated to a function which makes device-side
        update calls.

      - A cooperative node cannot be updated to a non-cooperative node, and
        vice-versa.

      - If the graph was instantiated with
        CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY, the priority
        attribute cannot change. Equality is checked on the originally
        requested priority values, before they are clamped to the device's
        supported range.

      - If `hGraphExec` was not instantiated for device launch, a node
        whose function originally did not use device-side cudaGraphLaunch()
        cannot be updated to a function which uses device-side
        cudaGraphLaunch() unless the node resides on the same context as
        nodes which contained such calls at instantiate-time. If no such
        calls were present at instantiation, these updates cannot be
        performed at all.

      - Neither `hGraph` nor `hGraphExec` may contain device-updatable
        kernel nodes.

    - Memset and memcpy nodes:

      - The CUDA device(s) to which the operand(s) was allocated/mapped
        cannot change.

      - The source/destination memory must be allocated from the same
        contexts as the original source/destination memory.

      - For 2d memsets, only address and assigned value may be updated.

      - For 1d memsets, updating dimensions is also allowed, but may fail
        if the resulting operation doesn't map onto the work resources
        already allocated for the node.

    - Additional memcpy node restrictions:

      - Changing either the source or destination memory type(i.e.
        CU_MEMORYTYPE_DEVICE, CU_MEMORYTYPE_ARRAY, etc.) is not supported.

    - External semaphore wait nodes and record nodes:

      - Changing the number of semaphores is not supported.

    - Conditional nodes:

      - Changing node parameters is not supported.

      - Changing parameters of nodes within the conditional body graph is
        subject to the rules above.

      - Conditional handle flags and default values are updated as part of
        the graph update.

    Note: The API may add further restrictions in future releases. The
    return code should always be checked.

    cuGraphExecUpdate sets the result member of `resultInfo` to
    CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED under the following
    conditions:

    - The count of nodes directly in `hGraphExec` and `hGraph` differ, in
      which case resultInfo->errorNode is set to NULL.

    - `hGraph` has more exit nodes than `hGraph`, in which case
      resultInfo->errorNode is set to one of the exit nodes in hGraph.

    - A node in `hGraph` has a different number of dependencies than the
      node from `hGraphExec` it is paired with, in which case
      resultInfo->errorNode is set to the node from `hGraph`.

    - A node in `hGraph` has a dependency that does not match with the
      corresponding dependency of the paired node from `hGraphExec`.
      resultInfo->errorNode will be set to the node from `hGraph`.
      resultInfo->errorFromNode will be set to the mismatched dependency.
      The dependencies are paired based on edge order and a dependency does
      not match when the nodes are already paired based on other edges
      examined in the graph.

    cuGraphExecUpdate sets the result member of `resultInfo` to:

    - CU_GRAPH_EXEC_UPDATE_ERROR if passed an invalid value.

    - CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED if the graph topology
      changed

    - CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED if the type of a node
      changed, in which case `hErrorNode_out` is set to the node from
      `hGraph`.

    - CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE if the
      function changed in an unsupported way(see note above), in which case
      `hErrorNode_out` is set to the node from `hGraph`

    - CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED if any parameters to a
      node changed in a way that is not supported, in which case
      `hErrorNode_out` is set to the node from `hGraph`.

    - CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED if any attributes of a
      node changed in a way that is not supported, in which case
      `hErrorNode_out` is set to the node from `hGraph`.

    - CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED if something about a node is
      unsupported, like the node's type or configuration, in which case
      `hErrorNode_out` is set to the node from `hGraph`

    If the update fails for a reason not listed above, the result member of
    `resultInfo` will be set to CU_GRAPH_EXEC_UPDATE_ERROR. If the update
    succeeds, the result member will be set to
    CU_GRAPH_EXEC_UPDATE_SUCCESS.

    cuGraphExecUpdate returns CUDA_SUCCESS when the updated was performed
    successfully. It returns CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE if the
    graph update was not performed because it included changes which
    violated constraints specific to instantiated graph update.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The instantiated graph to be updated
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph containing the updated parameters

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE`,
    resultInfo : :py:obj:`~.CUgraphExecUpdateResultInfo`
        the error info structure

    See Also
    --------
    :py:obj:`~.cuGraphInstantiate`
    """
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    cdef CUgraphExecUpdateResultInfo resultInfo = CUgraphExecUpdateResultInfo()
    with nogil:
        err = cydriver.cuGraphExecUpdate(cyhGraphExec, cyhGraph, <cydriver.CUgraphExecUpdateResultInfo*>resultInfo._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], resultInfo)
{{endif}}

{{if 'cuGraphKernelNodeCopyAttributes' in found_functions}}

@cython.embedsignature(True)
def cuGraphKernelNodeCopyAttributes(dst, src):
    """ Copies attributes from source node to destination node.

    Copies attributes from source node `src` to destination node `dst`.
    Both node must have the same context.

    Parameters
    ----------
    dst : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Destination node
    src : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Source node For list of attributes see
        :py:obj:`~.CUkernelNodeAttrID`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.CUaccessPolicyWindow`
    """
    cdef cydriver.CUgraphNode cysrc
    if src is None:
        psrc = 0
    elif isinstance(src, (CUgraphNode,)):
        psrc = int(src)
    else:
        psrc = int(CUgraphNode(src))
    cysrc = <cydriver.CUgraphNode><void_ptr>psrc
    cdef cydriver.CUgraphNode cydst
    if dst is None:
        pdst = 0
    elif isinstance(dst, (CUgraphNode,)):
        pdst = int(dst)
    else:
        pdst = int(CUgraphNode(dst))
    cydst = <cydriver.CUgraphNode><void_ptr>pdst
    with nogil:
        err = cydriver.cuGraphKernelNodeCopyAttributes(cydst, cysrc)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphKernelNodeGetAttribute' in found_functions}}

@cython.embedsignature(True)
def cuGraphKernelNodeGetAttribute(hNode, attr not None : CUkernelNodeAttrID):
    """ Queries node attribute.

    Queries attribute `attr` from node `hNode` and stores it in
    corresponding member of `value_out`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`

    attr : :py:obj:`~.CUkernelNodeAttrID`


    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    value_out : :py:obj:`~.CUkernelNodeAttrValue`


    See Also
    --------
    :py:obj:`~.CUaccessPolicyWindow`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUkernelNodeAttrID cyattr = attr.value
    cdef CUkernelNodeAttrValue value_out = CUkernelNodeAttrValue()
    with nogil:
        err = cydriver.cuGraphKernelNodeGetAttribute(cyhNode, cyattr, <cydriver.CUkernelNodeAttrValue*>value_out._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], value_out)
{{endif}}

{{if 'cuGraphKernelNodeSetAttribute' in found_functions}}

@cython.embedsignature(True)
def cuGraphKernelNodeSetAttribute(hNode, attr not None : CUkernelNodeAttrID, value : Optional[CUkernelNodeAttrValue]):
    """ Sets node attribute.

    Sets attribute `attr` on node `hNode` from corresponding attribute of
    `value`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`

    attr : :py:obj:`~.CUkernelNodeAttrID`

    value : :py:obj:`~.CUkernelNodeAttrValue`


    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.CUaccessPolicyWindow`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUkernelNodeAttrID cyattr = attr.value
    cdef cydriver.CUkernelNodeAttrValue* cyvalue_ptr = value._pvt_ptr if value is not None else NULL
    with nogil:
        err = cydriver.cuGraphKernelNodeSetAttribute(cyhNode, cyattr, cyvalue_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphDebugDotPrint' in found_functions}}

@cython.embedsignature(True)
def cuGraphDebugDotPrint(hGraph, char* path, unsigned int flags):
    """ Write a DOT file describing graph structure.

    Using the provided `hGraph`, write to `path` a DOT formatted
    description of the graph. By default this includes the graph topology,
    node types, node id, kernel names and memcpy direction. `flags` can be
    specified to write more detailed information about each node type such
    as parameter values, kernel attributes, node and function handles.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph to create a DOT file from
    path : bytes
        The path to write the DOT file to
    flags : unsigned int
        Flags from CUgraphDebugDot_flags for specifying which additional
        node information to write

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OPERATING_SYSTEM`
    """
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    with nogil:
        err = cydriver.cuGraphDebugDotPrint(cyhGraph, path, flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuUserObjectCreate' in found_functions}}

@cython.embedsignature(True)
def cuUserObjectCreate(ptr, destroy, unsigned int initialRefcount, unsigned int flags):
    """ Create a user object.

    Create a user object with the specified destructor callback and initial
    reference count. The initial references are owned by the caller.

    Destructor callbacks cannot make CUDA API calls and should avoid
    blocking behavior, as they are executed by a shared internal thread.
    Another thread may be signaled to perform such actions, if it does not
    block forward progress of tasks scheduled through CUDA.

    See CUDA User Objects in the CUDA C++ Programming Guide for more
    information on user objects.

    Parameters
    ----------
    ptr : Any
        The pointer to pass to the destroy function
    destroy : :py:obj:`~.CUhostFn`
        Callback to free the user object when it is no longer in use
    initialRefcount : unsigned int
        The initial refcount to create the object with, typically 1. The
        initial references are owned by the calling thread.
    flags : unsigned int
        Currently it is required to pass
        :py:obj:`~.CU_USER_OBJECT_NO_DESTRUCTOR_SYNC`, which is the only
        defined flag. This indicates that the destroy callback cannot be
        waited on by any CUDA API. Users requiring synchronization of the
        callback should signal its completion manually.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    object_out : :py:obj:`~.CUuserObject`
        Location to return the user object handle

    See Also
    --------
    :py:obj:`~.cuUserObjectRetain`, :py:obj:`~.cuUserObjectRelease`, :py:obj:`~.cuGraphRetainUserObject`, :py:obj:`~.cuGraphReleaseUserObject`, :py:obj:`~.cuGraphCreate`
    """
    cdef cydriver.CUhostFn cydestroy
    if destroy is None:
        pdestroy = 0
    elif isinstance(destroy, (CUhostFn,)):
        pdestroy = int(destroy)
    else:
        pdestroy = int(CUhostFn(destroy))
    cydestroy = <cydriver.CUhostFn><void_ptr>pdestroy
    cdef CUuserObject object_out = CUuserObject()
    cyptr = _HelperInputVoidPtr(ptr)
    cdef void* cyptr_ptr = <void*><void_ptr>cyptr.cptr
    with nogil:
        err = cydriver.cuUserObjectCreate(<cydriver.CUuserObject*>object_out._pvt_ptr, cyptr_ptr, cydestroy, initialRefcount, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], object_out)
{{endif}}

{{if 'cuUserObjectRetain' in found_functions}}

@cython.embedsignature(True)
def cuUserObjectRetain(object, unsigned int count):
    """ Retain a reference to a user object.

    Retains new references to a user object. The new references are owned
    by the caller.

    See CUDA User Objects in the CUDA C++ Programming Guide for more
    information on user objects.

    Parameters
    ----------
    object : :py:obj:`~.CUuserObject`
        The object to retain
    count : unsigned int
        The number of references to retain, typically 1. Must be nonzero
        and not larger than INT_MAX.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuUserObjectCreate`, :py:obj:`~.cuUserObjectRelease`, :py:obj:`~.cuGraphRetainUserObject`, :py:obj:`~.cuGraphReleaseUserObject`, :py:obj:`~.cuGraphCreate`
    """
    cdef cydriver.CUuserObject cyobject
    if object is None:
        pobject = 0
    elif isinstance(object, (CUuserObject,)):
        pobject = int(object)
    else:
        pobject = int(CUuserObject(object))
    cyobject = <cydriver.CUuserObject><void_ptr>pobject
    with nogil:
        err = cydriver.cuUserObjectRetain(cyobject, count)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuUserObjectRelease' in found_functions}}

@cython.embedsignature(True)
def cuUserObjectRelease(object, unsigned int count):
    """ Release a reference to a user object.

    Releases user object references owned by the caller. The object's
    destructor is invoked if the reference count reaches zero.

    It is undefined behavior to release references not owned by the caller,
    or to use a user object handle after all references are released.

    See CUDA User Objects in the CUDA C++ Programming Guide for more
    information on user objects.

    Parameters
    ----------
    object : :py:obj:`~.CUuserObject`
        The object to release
    count : unsigned int
        The number of references to release, typically 1. Must be nonzero
        and not larger than INT_MAX.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuUserObjectCreate`, :py:obj:`~.cuUserObjectRetain`, :py:obj:`~.cuGraphRetainUserObject`, :py:obj:`~.cuGraphReleaseUserObject`, :py:obj:`~.cuGraphCreate`
    """
    cdef cydriver.CUuserObject cyobject
    if object is None:
        pobject = 0
    elif isinstance(object, (CUuserObject,)):
        pobject = int(object)
    else:
        pobject = int(CUuserObject(object))
    cyobject = <cydriver.CUuserObject><void_ptr>pobject
    with nogil:
        err = cydriver.cuUserObjectRelease(cyobject, count)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphRetainUserObject' in found_functions}}

@cython.embedsignature(True)
def cuGraphRetainUserObject(graph, object, unsigned int count, unsigned int flags):
    """ Retain a reference to a user object from a graph.

    Creates or moves user object references that will be owned by a CUDA
    graph.

    See CUDA User Objects in the CUDA C++ Programming Guide for more
    information on user objects.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph to associate the reference with
    object : :py:obj:`~.CUuserObject`
        The user object to retain a reference for
    count : unsigned int
        The number of references to add to the graph, typically 1. Must be
        nonzero and not larger than INT_MAX.
    flags : unsigned int
        The optional flag :py:obj:`~.CU_GRAPH_USER_OBJECT_MOVE` transfers
        references from the calling thread, rather than create new
        references. Pass 0 to create new references.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuUserObjectCreate`, :py:obj:`~.cuUserObjectRetain`, :py:obj:`~.cuUserObjectRelease`, :py:obj:`~.cuGraphReleaseUserObject`, :py:obj:`~.cuGraphCreate`
    """
    cdef cydriver.CUuserObject cyobject
    if object is None:
        pobject = 0
    elif isinstance(object, (CUuserObject,)):
        pobject = int(object)
    else:
        pobject = int(CUuserObject(object))
    cyobject = <cydriver.CUuserObject><void_ptr>pobject
    cdef cydriver.CUgraph cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (CUgraph,)):
        pgraph = int(graph)
    else:
        pgraph = int(CUgraph(graph))
    cygraph = <cydriver.CUgraph><void_ptr>pgraph
    with nogil:
        err = cydriver.cuGraphRetainUserObject(cygraph, cyobject, count, flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphReleaseUserObject' in found_functions}}

@cython.embedsignature(True)
def cuGraphReleaseUserObject(graph, object, unsigned int count):
    """ Release a user object reference from a graph.

    Releases user object references owned by a graph.

    See CUDA User Objects in the CUDA C++ Programming Guide for more
    information on user objects.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph that will release the reference
    object : :py:obj:`~.CUuserObject`
        The user object to release a reference for
    count : unsigned int
        The number of references to release, typically 1. Must be nonzero
        and not larger than INT_MAX.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuUserObjectCreate`, :py:obj:`~.cuUserObjectRetain`, :py:obj:`~.cuUserObjectRelease`, :py:obj:`~.cuGraphRetainUserObject`, :py:obj:`~.cuGraphCreate`
    """
    cdef cydriver.CUuserObject cyobject
    if object is None:
        pobject = 0
    elif isinstance(object, (CUuserObject,)):
        pobject = int(object)
    else:
        pobject = int(CUuserObject(object))
    cyobject = <cydriver.CUuserObject><void_ptr>pobject
    cdef cydriver.CUgraph cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (CUgraph,)):
        pgraph = int(graph)
    else:
        pgraph = int(CUgraph(graph))
    cygraph = <cydriver.CUgraph><void_ptr>pgraph
    with nogil:
        err = cydriver.cuGraphReleaseUserObject(cygraph, cyobject, count)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphAddNode_v2' in found_functions}}

@cython.embedsignature(True)
def cuGraphAddNode(hGraph, dependencies : Optional[tuple[CUgraphNode] | list[CUgraphNode]], dependencyData : Optional[tuple[CUgraphEdgeData] | list[CUgraphEdgeData]], size_t numDependencies, nodeParams : Optional[CUgraphNodeParams]):
    """ Adds a node of arbitrary type to a graph.

    Creates a new node in `hGraph` described by `nodeParams` with
    `numDependencies` dependencies specified via `dependencies`.
    `numDependencies` may be 0. `dependencies` may be null if
    `numDependencies` is 0. `dependencies` may not have any duplicate
    entries.

    `nodeParams` is a tagged union. The node type should be specified in
    the `typename` field, and type-specific parameters in the corresponding
    union member. All unused bytes - that is, `reserved0` and all bytes
    past the utilized union member - must be set to zero. It is recommended
    to use brace initialization or memset to ensure all bytes are
    initialized.

    Note that for some node types, `nodeParams` may contain "out
    parameters" which are modified during the call, such as
    `nodeParams->alloc.dptr`.

    A handle to the new node will be returned in `phGraphNode`.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : list[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    dependencyData : list[:py:obj:`~.CUgraphEdgeData`]
        Optional edge data for the dependencies. If NULL, the data is
        assumed to be default (zeroed) for all dependencies.
    numDependencies : size_t
        Number of dependencies
    nodeParams : :py:obj:`~.CUgraphNodeParams`
        Specification of the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphNodeSetParams`, :py:obj:`~.cuGraphExecNodeSetParams`
    """
    dependencyData = [] if dependencyData is None else dependencyData
    if not all(isinstance(_x, (CUgraphEdgeData,)) for _x in dependencyData):
        raise TypeError("Argument 'dependencyData' is not instance of type (expected tuple[cydriver.CUgraphEdgeData,] or list[cydriver.CUgraphEdgeData,]")
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode,)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cydriver.CUgraphNode,] or list[cydriver.CUgraphNode,]")
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef cydriver.CUgraphNode* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cydriver.CUgraphNode*> calloc(len(dependencies), sizeof(cydriver.CUgraphNode))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cydriver.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cydriver.CUgraphNode>(<CUgraphNode>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cydriver.CUgraphNode*>(<CUgraphNode>dependencies[0])._pvt_ptr
    cdef cydriver.CUgraphEdgeData* cydependencyData = NULL
    if len(dependencyData) > 1:
        cydependencyData = <cydriver.CUgraphEdgeData*> calloc(len(dependencyData), sizeof(cydriver.CUgraphEdgeData))
        if cydependencyData is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencyData)) + 'x' + str(sizeof(cydriver.CUgraphEdgeData)))
        for idx in range(len(dependencyData)):
            string.memcpy(&cydependencyData[idx], (<CUgraphEdgeData>dependencyData[idx])._pvt_ptr, sizeof(cydriver.CUgraphEdgeData))
    elif len(dependencyData) == 1:
        cydependencyData = (<CUgraphEdgeData>dependencyData[0])._pvt_ptr
    cdef cydriver.CUgraphNodeParams* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphAddNode(<cydriver.CUgraphNode*>phGraphNode._pvt_ptr, cyhGraph, cydependencies, cydependencyData, numDependencies, cynodeParams_ptr)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if len(dependencyData) > 1 and cydependencyData is not NULL:
        free(cydependencyData)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phGraphNode)
{{endif}}

{{if 'cuGraphNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphNodeSetParams(hNode, nodeParams : Optional[CUgraphNodeParams]):
    """ Update's a graph node's parameters.

    Sets the parameters of graph node `hNode` to `nodeParams`. The node
    type specified by `nodeParams->type` must match the type of `hNode`.
    `nodeParams` must be fully initialized and all unused bytes (reserved,
    padding) zeroed.

    Modifying parameters is not supported for node types
    CU_GRAPH_NODE_TYPE_MEM_ALLOC and CU_GRAPH_NODE_TYPE_MEM_FREE.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.CUgraphNodeParams`
        Parameters to copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphExecNodeSetParams`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUgraphNodeParams* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphNodeSetParams(cyhNode, cynodeParams_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphExecNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cuGraphExecNodeSetParams(hGraphExec, hNode, nodeParams : Optional[CUgraphNodeParams]):
    """ Update's a graph node's parameters in an instantiated graph.

    Sets the parameters of a node in an executable graph `hGraphExec`. The
    node is identified by the corresponding node `hNode` in the non-
    executable graph from which the executable graph was instantiated.
    `hNode` must not have been removed from the original graph.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    Allowed changes to parameters on executable graphs are as follows:

    **View CUDA Toolkit Documentation for a table example**

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to update the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Corresponding node from the graph from which graphExec was
        instantiated
    nodeParams : :py:obj:`~.CUgraphNodeParams`
        Updated Parameters to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`, :py:obj:`~.cuGraphNodeSetParams` :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef cydriver.CUgraphNode cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (CUgraphNode,)):
        phNode = int(hNode)
    else:
        phNode = int(CUgraphNode(hNode))
    cyhNode = <cydriver.CUgraphNode><void_ptr>phNode
    cdef cydriver.CUgraphExec cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (CUgraphExec,)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
    cyhGraphExec = <cydriver.CUgraphExec><void_ptr>phGraphExec
    cdef cydriver.CUgraphNodeParams* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cydriver.cuGraphExecNodeSetParams(cyhGraphExec, cyhNode, cynodeParams_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphConditionalHandleCreate' in found_functions}}

@cython.embedsignature(True)
def cuGraphConditionalHandleCreate(hGraph, ctx, unsigned int defaultLaunchValue, unsigned int flags):
    """ Create a conditional handle.

    Creates a conditional handle associated with `hGraph`.

    The conditional handle must be associated with a conditional node in
    this graph or one of its children.

    Handles not associated with a conditional node may cause graph
    instantiation to fail.

    Handles can only be set from the context with which they are
    associated.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph which will contain the conditional node using this handle.
    ctx : :py:obj:`~.CUcontext`
        Context for the handle and associated conditional node.
    defaultLaunchValue : unsigned int
        Optional initial value for the conditional variable. Applied at the
        beginning of each graph execution if CU_GRAPH_COND_ASSIGN_DEFAULT
        is set in `flags`.
    flags : unsigned int
        Currently must be CU_GRAPH_COND_ASSIGN_DEFAULT or 0.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    pHandle_out : :py:obj:`~.CUgraphConditionalHandle`
        Pointer used to return the handle to the caller.

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`
    """
    cdef cydriver.CUcontext cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (CUcontext,)):
        pctx = int(ctx)
    else:
        pctx = int(CUcontext(ctx))
    cyctx = <cydriver.CUcontext><void_ptr>pctx
    cdef cydriver.CUgraph cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (CUgraph,)):
        phGraph = int(hGraph)
    else:
        phGraph = int(CUgraph(hGraph))
    cyhGraph = <cydriver.CUgraph><void_ptr>phGraph
    cdef CUgraphConditionalHandle pHandle_out = CUgraphConditionalHandle()
    with nogil:
        err = cydriver.cuGraphConditionalHandleCreate(<cydriver.CUgraphConditionalHandle*>pHandle_out._pvt_ptr, cyhGraph, cyctx, defaultLaunchValue, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pHandle_out)
{{endif}}

{{if 'cuOccupancyMaxActiveBlocksPerMultiprocessor' in found_functions}}

@cython.embedsignature(True)
def cuOccupancyMaxActiveBlocksPerMultiprocessor(func, int blockSize, size_t dynamicSMemSize):
    """ Returns occupancy of a function.

    Returns in `*numBlocks` the number of the maximum active blocks per
    streaming multiprocessor.

    Note that the API can also be used with context-less kernel
    :py:obj:`~.CUkernel` by querying the handle using
    :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
    casting to :py:obj:`~.CUfunction`. Here, the context to use for
    calculations will be the current context.

    Parameters
    ----------
    func : :py:obj:`~.CUfunction`
        Kernel for which occupancy is calculated
    blockSize : int
        Block size the kernel is intended to be launched with
    dynamicSMemSize : size_t
        Per-block dynamic shared memory usage intended, in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    numBlocks : int
        Returned occupancy

    See Also
    --------
    :py:obj:`~.cudaOccupancyMaxActiveBlocksPerMultiprocessor`
    """
    cdef cydriver.CUfunction cyfunc
    if func is None:
        pfunc = 0
    elif isinstance(func, (CUfunction,)):
        pfunc = int(func)
    else:
        pfunc = int(CUfunction(func))
    cyfunc = <cydriver.CUfunction><void_ptr>pfunc
    cdef int numBlocks = 0
    with nogil:
        err = cydriver.cuOccupancyMaxActiveBlocksPerMultiprocessor(&numBlocks, cyfunc, blockSize, dynamicSMemSize)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], numBlocks)
{{endif}}

{{if 'cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags' in found_functions}}

@cython.embedsignature(True)
def cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(func, int blockSize, size_t dynamicSMemSize, unsigned int flags):
    """ Returns occupancy of a function.

    Returns in `*numBlocks` the number of the maximum active blocks per
    streaming multiprocessor.

    The `Flags` parameter controls how special cases are handled. The valid
    flags are:

    - :py:obj:`~.CU_OCCUPANCY_DEFAULT`, which maintains the default
      behavior as :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessor`;

    - :py:obj:`~.CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE`, which suppresses
      the default behavior on platform where global caching affects
      occupancy. On such platforms, if caching is enabled, but per-block SM
      resource usage would result in zero occupancy, the occupancy
      calculator will calculate the occupancy as if caching is disabled.
      Setting :py:obj:`~.CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE` makes the
      occupancy calculator to return 0 in such cases. More information can
      be found about this feature in the "Unified L1/Texture Cache" section
      of the Maxwell tuning guide.

    Note that the API can also be with launch context-less kernel
    :py:obj:`~.CUkernel` by querying the handle using
    :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
    casting to :py:obj:`~.CUfunction`. Here, the context to use for
    calculations will be the current context.

    Parameters
    ----------
    func : :py:obj:`~.CUfunction`
        Kernel for which occupancy is calculated
    blockSize : int
        Block size the kernel is intended to be launched with
    dynamicSMemSize : size_t
        Per-block dynamic shared memory usage intended, in bytes
    flags : unsigned int
        Requested behavior for the occupancy calculator

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    numBlocks : int
        Returned occupancy

    See Also
    --------
    :py:obj:`~.cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags`
    """
    cdef cydriver.CUfunction cyfunc
    if func is None:
        pfunc = 0
    elif isinstance(func, (CUfunction,)):
        pfunc = int(func)
    else:
        pfunc = int(CUfunction(func))
    cyfunc = <cydriver.CUfunction><void_ptr>pfunc
    cdef int numBlocks = 0
    with nogil:
        err = cydriver.cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(&numBlocks, cyfunc, blockSize, dynamicSMemSize, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], numBlocks)
{{endif}}

{{if 'cuOccupancyMaxPotentialBlockSize' in found_functions}}

@cython.embedsignature(True)
def cuOccupancyMaxPotentialBlockSize(func, blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit):
    """ Suggest a launch configuration with reasonable occupancy.

    Returns in `*blockSize` a reasonable block size that can achieve the
    maximum occupancy (or, the maximum number of active warps with the
    fewest blocks per multiprocessor), and in `*minGridSize` the minimum
    grid size to achieve the maximum occupancy.

    If `blockSizeLimit` is 0, the configurator will use the maximum block
    size permitted by the device / function instead.

    If per-block dynamic shared memory allocation is not needed, the user
    should leave both `blockSizeToDynamicSMemSize` and `dynamicSMemSize` as
    0.

    If per-block dynamic shared memory allocation is needed, then if the
    dynamic shared memory size is constant regardless of block size, the
    size should be passed through `dynamicSMemSize`, and
    `blockSizeToDynamicSMemSize` should be NULL.

    Otherwise, if the per-block dynamic shared memory size varies with
    different block sizes, the user needs to provide a unary function
    through `blockSizeToDynamicSMemSize` that computes the dynamic shared
    memory needed by `func` for any given block size. `dynamicSMemSize` is
    ignored. An example signature is:

    **View CUDA Toolkit Documentation for a C++ code example**

    Note that the API can also be used with context-less kernel
    :py:obj:`~.CUkernel` by querying the handle using
    :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
    casting to :py:obj:`~.CUfunction`. Here, the context to use for
    calculations will be the current context.

    Parameters
    ----------
    func : :py:obj:`~.CUfunction`
        Kernel for which launch configuration is calculated
    blockSizeToDynamicSMemSize : :py:obj:`~.CUoccupancyB2DSize`
        A function that calculates how much per-block dynamic shared memory
        `func` uses based on the block size
    dynamicSMemSize : size_t
        Dynamic shared memory usage intended, in bytes
    blockSizeLimit : int
        The maximum block size `func` is designed to handle

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    minGridSize : int
        Returned minimum grid size needed to achieve the maximum occupancy
    blockSize : int
        Returned maximum block size that can achieve the maximum occupancy

    See Also
    --------
    :py:obj:`~.cudaOccupancyMaxPotentialBlockSize`
    """
    cdef cydriver.CUoccupancyB2DSize cyblockSizeToDynamicSMemSize
    if blockSizeToDynamicSMemSize is None:
        pblockSizeToDynamicSMemSize = 0
    elif isinstance(blockSizeToDynamicSMemSize, (CUoccupancyB2DSize,)):
        pblockSizeToDynamicSMemSize = int(blockSizeToDynamicSMemSize)
    else:
        pblockSizeToDynamicSMemSize = int(CUoccupancyB2DSize(blockSizeToDynamicSMemSize))
    cyblockSizeToDynamicSMemSize = <cydriver.CUoccupancyB2DSize><void_ptr>pblockSizeToDynamicSMemSize
    cdef cydriver.CUfunction cyfunc
    if func is None:
        pfunc = 0
    elif isinstance(func, (CUfunction,)):
        pfunc = int(func)
    else:
        pfunc = int(CUfunction(func))
    cyfunc = <cydriver.CUfunction><void_ptr>pfunc
    cdef int minGridSize = 0
    cdef int blockSize = 0
    with nogil:
        err = cydriver.cuOccupancyMaxPotentialBlockSize(&minGridSize, &blockSize, cyfunc, cyblockSizeToDynamicSMemSize, dynamicSMemSize, blockSizeLimit)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], minGridSize, blockSize)
{{endif}}

{{if 'cuOccupancyMaxPotentialBlockSizeWithFlags' in found_functions}}

@cython.embedsignature(True)
def cuOccupancyMaxPotentialBlockSizeWithFlags(func, blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit, unsigned int flags):
    """ Suggest a launch configuration with reasonable occupancy.

    An extended version of :py:obj:`~.cuOccupancyMaxPotentialBlockSize`. In
    addition to arguments passed to
    :py:obj:`~.cuOccupancyMaxPotentialBlockSize`,
    :py:obj:`~.cuOccupancyMaxPotentialBlockSizeWithFlags` also takes a
    `Flags` parameter.

    The `Flags` parameter controls how special cases are handled. The valid
    flags are:

    - :py:obj:`~.CU_OCCUPANCY_DEFAULT`, which maintains the default
      behavior as :py:obj:`~.cuOccupancyMaxPotentialBlockSize`;

    - :py:obj:`~.CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE`, which suppresses
      the default behavior on platform where global caching affects
      occupancy. On such platforms, the launch configurations that produces
      maximal occupancy might not support global caching. Setting
      :py:obj:`~.CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE` guarantees that the
      the produced launch configuration is global caching compatible at a
      potential cost of occupancy. More information can be found about this
      feature in the "Unified L1/Texture Cache" section of the Maxwell
      tuning guide.

    Note that the API can also be used with context-less kernel
    :py:obj:`~.CUkernel` by querying the handle using
    :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
    casting to :py:obj:`~.CUfunction`. Here, the context to use for
    calculations will be the current context.

    Parameters
    ----------
    func : :py:obj:`~.CUfunction`
        Kernel for which launch configuration is calculated
    blockSizeToDynamicSMemSize : :py:obj:`~.CUoccupancyB2DSize`
        A function that calculates how much per-block dynamic shared memory
        `func` uses based on the block size
    dynamicSMemSize : size_t
        Dynamic shared memory usage intended, in bytes
    blockSizeLimit : int
        The maximum block size `func` is designed to handle
    flags : unsigned int
        Options

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    minGridSize : int
        Returned minimum grid size needed to achieve the maximum occupancy
    blockSize : int
        Returned maximum block size that can achieve the maximum occupancy

    See Also
    --------
    :py:obj:`~.cudaOccupancyMaxPotentialBlockSizeWithFlags`
    """
    cdef cydriver.CUoccupancyB2DSize cyblockSizeToDynamicSMemSize
    if blockSizeToDynamicSMemSize is None:
        pblockSizeToDynamicSMemSize = 0
    elif isinstance(blockSizeToDynamicSMemSize, (CUoccupancyB2DSize,)):
        pblockSizeToDynamicSMemSize = int(blockSizeToDynamicSMemSize)
    else:
        pblockSizeToDynamicSMemSize = int(CUoccupancyB2DSize(blockSizeToDynamicSMemSize))
    cyblockSizeToDynamicSMemSize = <cydriver.CUoccupancyB2DSize><void_ptr>pblockSizeToDynamicSMemSize
    cdef cydriver.CUfunction cyfunc
    if func is None:
        pfunc = 0
    elif isinstance(func, (CUfunction,)):
        pfunc = int(func)
    else:
        pfunc = int(CUfunction(func))
    cyfunc = <cydriver.CUfunction><void_ptr>pfunc
    cdef int minGridSize = 0
    cdef int blockSize = 0
    with nogil:
        err = cydriver.cuOccupancyMaxPotentialBlockSizeWithFlags(&minGridSize, &blockSize, cyfunc, cyblockSizeToDynamicSMemSize, dynamicSMemSize, blockSizeLimit, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], minGridSize, blockSize)
{{endif}}

{{if 'cuOccupancyAvailableDynamicSMemPerBlock' in found_functions}}

@cython.embedsignature(True)
def cuOccupancyAvailableDynamicSMemPerBlock(func, int numBlocks, int blockSize):
    """ Returns dynamic shared memory available per block when launching `numBlocks` blocks on SM.

    Returns in `*dynamicSmemSize` the maximum size of dynamic shared memory
    to allow `numBlocks` blocks per SM.

    Note that the API can also be used with context-less kernel
    :py:obj:`~.CUkernel` by querying the handle using
    :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
    casting to :py:obj:`~.CUfunction`. Here, the context to use for
    calculations will be the current context.

    Parameters
    ----------
    func : :py:obj:`~.CUfunction`
        Kernel function for which occupancy is calculated
    numBlocks : int
        Number of blocks to fit on SM
    blockSize : int
        Size of the blocks

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    dynamicSmemSize : int
        Returned maximum dynamic shared memory
    """
    cdef cydriver.CUfunction cyfunc
    if func is None:
        pfunc = 0
    elif isinstance(func, (CUfunction,)):
        pfunc = int(func)
    else:
        pfunc = int(CUfunction(func))
    cyfunc = <cydriver.CUfunction><void_ptr>pfunc
    cdef size_t dynamicSmemSize = 0
    with nogil:
        err = cydriver.cuOccupancyAvailableDynamicSMemPerBlock(&dynamicSmemSize, cyfunc, numBlocks, blockSize)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], dynamicSmemSize)
{{endif}}

{{if 'cuOccupancyMaxPotentialClusterSize' in found_functions}}

@cython.embedsignature(True)
def cuOccupancyMaxPotentialClusterSize(func, config : Optional[CUlaunchConfig]):
    """ Given the kernel function (`func`) and launch configuration (`config`), return the maximum cluster size in `*clusterSize`.

    The cluster dimensions in `config` are ignored. If func has a required
    cluster size set (see :py:obj:`~.cudaFuncGetAttributes` /
    :py:obj:`~.cuFuncGetAttribute`),`*clusterSize` will reflect the
    required cluster size.

    By default this function will always return a value that's portable on
    future hardware. A higher value may be returned if the kernel function
    allows non-portable cluster sizes.

    This function will respect the compile time launch bounds.

    Note that the API can also be used with context-less kernel
    :py:obj:`~.CUkernel` by querying the handle using
    :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
    casting to :py:obj:`~.CUfunction`. Here, the context to use for
    calculations will either be taken from the specified stream
    `config->hStream` or the current context in case of NULL stream.

    Parameters
    ----------
    func : :py:obj:`~.CUfunction`
        Kernel function for which maximum cluster size is calculated
    config : :py:obj:`~.CUlaunchConfig`
        Launch configuration for the given kernel function

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    clusterSize : int
        Returned maximum cluster size that can be launched for the given
        kernel function and launch configuration

    See Also
    --------
    :py:obj:`~.cudaFuncGetAttributes`, :py:obj:`~.cuFuncGetAttribute`
    """
    cdef cydriver.CUfunction cyfunc
    if func is None:
        pfunc = 0
    elif isinstance(func, (CUfunction,)):
        pfunc = int(func)
    else:
        pfunc = int(CUfunction(func))
    cyfunc = <cydriver.CUfunction><void_ptr>pfunc
    cdef int clusterSize = 0
    cdef cydriver.CUlaunchConfig* cyconfig_ptr = config._pvt_ptr if config is not None else NULL
    with nogil:
        err = cydriver.cuOccupancyMaxPotentialClusterSize(&clusterSize, cyfunc, cyconfig_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], clusterSize)
{{endif}}

{{if 'cuOccupancyMaxActiveClusters' in found_functions}}

@cython.embedsignature(True)
def cuOccupancyMaxActiveClusters(func, config : Optional[CUlaunchConfig]):
    """ Given the kernel function (`func`) and launch configuration (`config`), return the maximum number of clusters that could co-exist on the target device in `*numClusters`.

    If the function has required cluster size already set (see
    :py:obj:`~.cudaFuncGetAttributes` / :py:obj:`~.cuFuncGetAttribute`),
    the cluster size from config must either be unspecified or match the
    required size. Without required sizes, the cluster size must be
    specified in config, else the function will return an error.

    Note that various attributes of the kernel function may affect
    occupancy calculation. Runtime environment may affect how the hardware
    schedules the clusters, so the calculated occupancy is not guaranteed
    to be achievable.

    Note that the API can also be used with context-less kernel
    :py:obj:`~.CUkernel` by querying the handle using
    :py:obj:`~.cuLibraryGetKernel()` and then passing it to the API by
    casting to :py:obj:`~.CUfunction`. Here, the context to use for
    calculations will either be taken from the specified stream
    `config->hStream` or the current context in case of NULL stream.

    Parameters
    ----------
    func : :py:obj:`~.CUfunction`
        Kernel function for which maximum number of clusters are calculated
    config : :py:obj:`~.CUlaunchConfig`
        Launch configuration for the given kernel function

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_CLUSTER_SIZE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    numClusters : int
        Returned maximum number of clusters that could co-exist on the
        target device

    See Also
    --------
    :py:obj:`~.cudaFuncGetAttributes`, :py:obj:`~.cuFuncGetAttribute`
    """
    cdef cydriver.CUfunction cyfunc
    if func is None:
        pfunc = 0
    elif isinstance(func, (CUfunction,)):
        pfunc = int(func)
    else:
        pfunc = int(CUfunction(func))
    cyfunc = <cydriver.CUfunction><void_ptr>pfunc
    cdef int numClusters = 0
    cdef cydriver.CUlaunchConfig* cyconfig_ptr = config._pvt_ptr if config is not None else NULL
    with nogil:
        err = cydriver.cuOccupancyMaxActiveClusters(&numClusters, cyfunc, cyconfig_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], numClusters)
{{endif}}

{{if 'cuTexRefSetArray' in found_functions}}

@cython.embedsignature(True)
def cuTexRefSetArray(hTexRef, hArray, unsigned int Flags):
    """ Binds an array as a texture reference.

    [Deprecated]

    Binds the CUDA array `hArray` to the texture reference `hTexRef`. Any
    previous address or CUDA array state associated with the texture
    reference is superseded by this function. `Flags` must be set to
    :py:obj:`~.CU_TRSA_OVERRIDE_FORMAT`. Any CUDA array previously bound to
    `hTexRef` is unbound.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference to bind
    hArray : :py:obj:`~.CUarray`
        Array to bind
    Flags : unsigned int
        Options (must be :py:obj:`~.CU_TRSA_OVERRIDE_FORMAT`)

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUarray cyhArray
    if hArray is None:
        phArray = 0
    elif isinstance(hArray, (CUarray,)):
        phArray = int(hArray)
    else:
        phArray = int(CUarray(hArray))
    cyhArray = <cydriver.CUarray><void_ptr>phArray
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    with nogil:
        err = cydriver.cuTexRefSetArray(cyhTexRef, cyhArray, Flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuTexRefSetMipmappedArray' in found_functions}}

@cython.embedsignature(True)
def cuTexRefSetMipmappedArray(hTexRef, hMipmappedArray, unsigned int Flags):
    """ Binds a mipmapped array to a texture reference.

    [Deprecated]

    Binds the CUDA mipmapped array `hMipmappedArray` to the texture
    reference `hTexRef`. Any previous address or CUDA array state
    associated with the texture reference is superseded by this function.
    `Flags` must be set to :py:obj:`~.CU_TRSA_OVERRIDE_FORMAT`. Any CUDA
    array previously bound to `hTexRef` is unbound.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference to bind
    hMipmappedArray : :py:obj:`~.CUmipmappedArray`
        Mipmapped array to bind
    Flags : unsigned int
        Options (must be :py:obj:`~.CU_TRSA_OVERRIDE_FORMAT`)

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUmipmappedArray cyhMipmappedArray
    if hMipmappedArray is None:
        phMipmappedArray = 0
    elif isinstance(hMipmappedArray, (CUmipmappedArray,)):
        phMipmappedArray = int(hMipmappedArray)
    else:
        phMipmappedArray = int(CUmipmappedArray(hMipmappedArray))
    cyhMipmappedArray = <cydriver.CUmipmappedArray><void_ptr>phMipmappedArray
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    with nogil:
        err = cydriver.cuTexRefSetMipmappedArray(cyhTexRef, cyhMipmappedArray, Flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuTexRefSetAddress_v2' in found_functions}}

@cython.embedsignature(True)
def cuTexRefSetAddress(hTexRef, dptr, size_t numbytes):
    """ Binds an address as a texture reference.

    [Deprecated]

    Binds a linear address range to the texture reference `hTexRef`. Any
    previous address or CUDA array state associated with the texture
    reference is superseded by this function. Any memory previously bound
    to `hTexRef` is unbound.

    Since the hardware enforces an alignment requirement on texture base
    addresses, :py:obj:`~.cuTexRefSetAddress()` passes back a byte offset
    in `*ByteOffset` that must be applied to texture fetches in order to
    read from the desired memory. This offset must be divided by the texel
    size and passed to kernels that read from the texture so they can be
    applied to the :py:obj:`~.tex1Dfetch()` function.

    If the device memory pointer was returned from
    :py:obj:`~.cuMemAlloc()`, the offset is guaranteed to be 0 and NULL may
    be passed as the `ByteOffset` parameter.

    The total number of elements (or texels) in the linear address range
    cannot exceed
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH`. The
    number of elements is computed as (`numbytes` / bytesPerElement), where
    bytesPerElement is determined from the data format and number of
    components set using :py:obj:`~.cuTexRefSetFormat()`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference to bind
    dptr : :py:obj:`~.CUdeviceptr`
        Device pointer to bind
    numbytes : size_t
        Size of memory to bind in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    ByteOffset : int
        Returned byte offset

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUdeviceptr cydptr
    if dptr is None:
        pdptr = 0
    elif isinstance(dptr, (CUdeviceptr,)):
        pdptr = int(dptr)
    else:
        pdptr = int(CUdeviceptr(dptr))
    cydptr = <cydriver.CUdeviceptr><void_ptr>pdptr
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef size_t ByteOffset = 0
    with nogil:
        err = cydriver.cuTexRefSetAddress(&ByteOffset, cyhTexRef, cydptr, numbytes)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], ByteOffset)
{{endif}}

{{if 'cuTexRefSetAddress2D_v3' in found_functions}}

@cython.embedsignature(True)
def cuTexRefSetAddress2D(hTexRef, desc : Optional[CUDA_ARRAY_DESCRIPTOR], dptr, size_t Pitch):
    """ Binds an address as a 2D texture reference.

    [Deprecated]

    Binds a linear address range to the texture reference `hTexRef`. Any
    previous address or CUDA array state associated with the texture
    reference is superseded by this function. Any memory previously bound
    to `hTexRef` is unbound.

    Using a :py:obj:`~.tex2D()` function inside a kernel requires a call to
    either :py:obj:`~.cuTexRefSetArray()` to bind the corresponding texture
    reference to an array, or :py:obj:`~.cuTexRefSetAddress2D()` to bind
    the texture reference to linear memory.

    Function calls to :py:obj:`~.cuTexRefSetFormat()` cannot follow calls
    to :py:obj:`~.cuTexRefSetAddress2D()` for the same texture reference.

    It is required that `dptr` be aligned to the appropriate hardware-
    specific texture alignment. You can query this value using the device
    attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT`. If an
    unaligned `dptr` is supplied, :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is
    returned.

    `Pitch` has to be aligned to the hardware-specific texture pitch
    alignment. This value can be queried using the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT`. If an
    unaligned `Pitch` is supplied, :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is
    returned.

    Width and Height, which are specified in elements (or texels), cannot
    exceed :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH`
    and :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT`
    respectively. `Pitch`, which is specified in bytes, cannot exceed
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference to bind
    desc : :py:obj:`~.CUDA_ARRAY_DESCRIPTOR`
        Descriptor of CUDA array
    dptr : :py:obj:`~.CUdeviceptr`
        Device pointer to bind
    Pitch : size_t
        Line pitch in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUdeviceptr cydptr
    if dptr is None:
        pdptr = 0
    elif isinstance(dptr, (CUdeviceptr,)):
        pdptr = int(dptr)
    else:
        pdptr = int(CUdeviceptr(dptr))
    cydptr = <cydriver.CUdeviceptr><void_ptr>pdptr
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef cydriver.CUDA_ARRAY_DESCRIPTOR* cydesc_ptr = desc._pvt_ptr if desc is not None else NULL
    with nogil:
        err = cydriver.cuTexRefSetAddress2D(cyhTexRef, cydesc_ptr, cydptr, Pitch)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuTexRefSetFormat' in found_functions}}

@cython.embedsignature(True)
def cuTexRefSetFormat(hTexRef, fmt not None : CUarray_format, int NumPackedComponents):
    """ Sets the format for a texture reference.

    [Deprecated]

    Specifies the format of the data to be read by the texture reference
    `hTexRef`. `fmt` and `NumPackedComponents` are exactly analogous to the
    :py:obj:`~.Format` and :py:obj:`~.NumChannels` members of the
    :py:obj:`~.CUDA_ARRAY_DESCRIPTOR` structure: They specify the format of
    each component and the number of components per array element.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    fmt : :py:obj:`~.CUarray_format`
        Format to set
    NumPackedComponents : int
        Number of components per array element

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`, :py:obj:`~.cudaCreateChannelDesc`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef cydriver.CUarray_format cyfmt = fmt.value
    with nogil:
        err = cydriver.cuTexRefSetFormat(cyhTexRef, cyfmt, NumPackedComponents)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuTexRefSetAddressMode' in found_functions}}

@cython.embedsignature(True)
def cuTexRefSetAddressMode(hTexRef, int dim, am not None : CUaddress_mode):
    """ Sets the addressing mode for a texture reference.

    [Deprecated]

    Specifies the addressing mode `am` for the given dimension `dim` of the
    texture reference `hTexRef`. If `dim` is zero, the addressing mode is
    applied to the first parameter of the functions used to fetch from the
    texture; if `dim` is 1, the second, and so on.
    :py:obj:`~.CUaddress_mode` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    Note that this call has no effect if `hTexRef` is bound to linear
    memory. Also, if the flag, :py:obj:`~.CU_TRSF_NORMALIZED_COORDINATES`,
    is not set, the only supported address mode is
    :py:obj:`~.CU_TR_ADDRESS_MODE_CLAMP`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    dim : int
        Dimension
    am : :py:obj:`~.CUaddress_mode`
        Addressing mode to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef cydriver.CUaddress_mode cyam = am.value
    with nogil:
        err = cydriver.cuTexRefSetAddressMode(cyhTexRef, dim, cyam)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuTexRefSetFilterMode' in found_functions}}

@cython.embedsignature(True)
def cuTexRefSetFilterMode(hTexRef, fm not None : CUfilter_mode):
    """ Sets the filtering mode for a texture reference.

    [Deprecated]

    Specifies the filtering mode `fm` to be used when reading memory
    through the texture reference `hTexRef`. :py:obj:`~.CUfilter_mode_enum`
    is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    Note that this call has no effect if `hTexRef` is bound to linear
    memory.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    fm : :py:obj:`~.CUfilter_mode`
        Filtering mode to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef cydriver.CUfilter_mode cyfm = fm.value
    with nogil:
        err = cydriver.cuTexRefSetFilterMode(cyhTexRef, cyfm)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuTexRefSetMipmapFilterMode' in found_functions}}

@cython.embedsignature(True)
def cuTexRefSetMipmapFilterMode(hTexRef, fm not None : CUfilter_mode):
    """ Sets the mipmap filtering mode for a texture reference.

    [Deprecated]

    Specifies the mipmap filtering mode `fm` to be used when reading memory
    through the texture reference `hTexRef`. :py:obj:`~.CUfilter_mode_enum`
    is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    Note that this call has no effect if `hTexRef` is not bound to a
    mipmapped array.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    fm : :py:obj:`~.CUfilter_mode`
        Filtering mode to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef cydriver.CUfilter_mode cyfm = fm.value
    with nogil:
        err = cydriver.cuTexRefSetMipmapFilterMode(cyhTexRef, cyfm)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuTexRefSetMipmapLevelBias' in found_functions}}

@cython.embedsignature(True)
def cuTexRefSetMipmapLevelBias(hTexRef, float bias):
    """ Sets the mipmap level bias for a texture reference.

    [Deprecated]

    Specifies the mipmap level bias `bias` to be added to the specified
    mipmap level when reading memory through the texture reference
    `hTexRef`.

    Note that this call has no effect if `hTexRef` is not bound to a
    mipmapped array.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    bias : float
        Mipmap level bias

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    with nogil:
        err = cydriver.cuTexRefSetMipmapLevelBias(cyhTexRef, bias)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuTexRefSetMipmapLevelClamp' in found_functions}}

@cython.embedsignature(True)
def cuTexRefSetMipmapLevelClamp(hTexRef, float minMipmapLevelClamp, float maxMipmapLevelClamp):
    """ Sets the mipmap min/max mipmap level clamps for a texture reference.

    [Deprecated]

    Specifies the min/max mipmap level clamps, `minMipmapLevelClamp` and
    `maxMipmapLevelClamp` respectively, to be used when reading memory
    through the texture reference `hTexRef`.

    Note that this call has no effect if `hTexRef` is not bound to a
    mipmapped array.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    minMipmapLevelClamp : float
        Mipmap min level clamp
    maxMipmapLevelClamp : float
        Mipmap max level clamp

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    with nogil:
        err = cydriver.cuTexRefSetMipmapLevelClamp(cyhTexRef, minMipmapLevelClamp, maxMipmapLevelClamp)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuTexRefSetMaxAnisotropy' in found_functions}}

@cython.embedsignature(True)
def cuTexRefSetMaxAnisotropy(hTexRef, unsigned int maxAniso):
    """ Sets the maximum anisotropy for a texture reference.

    [Deprecated]

    Specifies the maximum anisotropy `maxAniso` to be used when reading
    memory through the texture reference `hTexRef`.

    Note that this call has no effect if `hTexRef` is bound to linear
    memory.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    maxAniso : unsigned int
        Maximum anisotropy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    with nogil:
        err = cydriver.cuTexRefSetMaxAnisotropy(cyhTexRef, maxAniso)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuTexRefSetBorderColor' in found_functions}}

@cython.embedsignature(True)
def cuTexRefSetBorderColor(hTexRef, float pBorderColor):
    """ Sets the border color for a texture reference.

    [Deprecated]

    Specifies the value of the RGBA color via the `pBorderColor` to the
    texture reference `hTexRef`. The color value supports only float type
    and holds color components in the following sequence: pBorderColor[0]
    holds 'R' component pBorderColor[1] holds 'G' component pBorderColor[2]
    holds 'B' component pBorderColor[3] holds 'A' component

    Note that the color values can be set only when the Address mode is set
    to CU_TR_ADDRESS_MODE_BORDER using :py:obj:`~.cuTexRefSetAddressMode`.
    Applications using integer border color values have to
    "reinterpret_cast" their values to float.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    pBorderColor : float
        RGBA color

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetBorderColor`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    with nogil:
        err = cydriver.cuTexRefSetBorderColor(cyhTexRef, &pBorderColor)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuTexRefSetFlags' in found_functions}}

@cython.embedsignature(True)
def cuTexRefSetFlags(hTexRef, unsigned int Flags):
    """ Sets the flags for a texture reference.

    [Deprecated]

    Specifies optional flags via `Flags` to specify the behavior of data
    returned through the texture reference `hTexRef`. The valid flags are:

    - :py:obj:`~.CU_TRSF_READ_AS_INTEGER`, which suppresses the default
      behavior of having the texture promote integer data to floating point
      data in the range [0, 1]. Note that texture with 32-bit integer
      format would not be promoted, regardless of whether or not this flag
      is specified;

    - :py:obj:`~.CU_TRSF_NORMALIZED_COORDINATES`, which suppresses the
      default behavior of having the texture coordinates range from [0,
      Dim) where Dim is the width or height of the CUDA array. Instead, the
      texture coordinates [0, 1.0) reference the entire breadth of the
      array dimension;

    - :py:obj:`~.CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION`, which disables
      any trilinear filtering optimizations. Trilinear optimizations
      improve texture filtering performance by allowing bilinear filtering
      on textures in scenarios where it can closely approximate the
      expected results.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    Flags : unsigned int
        Optional flags to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    with nogil:
        err = cydriver.cuTexRefSetFlags(cyhTexRef, Flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuTexRefGetAddress_v2' in found_functions}}

@cython.embedsignature(True)
def cuTexRefGetAddress(hTexRef):
    """ Gets the address associated with a texture reference.

    [Deprecated]

    Returns in `*pdptr` the base address bound to the texture reference
    `hTexRef`, or returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if the
    texture reference is not bound to any device memory range.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pdptr : :py:obj:`~.CUdeviceptr`
        Returned device address

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef CUdeviceptr pdptr = CUdeviceptr()
    with nogil:
        err = cydriver.cuTexRefGetAddress(<cydriver.CUdeviceptr*>pdptr._pvt_ptr, cyhTexRef)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pdptr)
{{endif}}

{{if 'cuTexRefGetArray' in found_functions}}

@cython.embedsignature(True)
def cuTexRefGetArray(hTexRef):
    """ Gets the array bound to a texture reference.

    [Deprecated]

    Returns in `*phArray` the CUDA array bound to the texture reference
    `hTexRef`, or returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if the
    texture reference is not bound to any CUDA array.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phArray : :py:obj:`~.CUarray`
        Returned array

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef CUarray phArray = CUarray()
    with nogil:
        err = cydriver.cuTexRefGetArray(<cydriver.CUarray*>phArray._pvt_ptr, cyhTexRef)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phArray)
{{endif}}

{{if 'cuTexRefGetMipmappedArray' in found_functions}}

@cython.embedsignature(True)
def cuTexRefGetMipmappedArray(hTexRef):
    """ Gets the mipmapped array bound to a texture reference.

    [Deprecated]

    Returns in `*phMipmappedArray` the CUDA mipmapped array bound to the
    texture reference `hTexRef`, or returns
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if the texture reference is not
    bound to any CUDA mipmapped array.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phMipmappedArray : :py:obj:`~.CUmipmappedArray`
        Returned mipmapped array

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef CUmipmappedArray phMipmappedArray = CUmipmappedArray()
    with nogil:
        err = cydriver.cuTexRefGetMipmappedArray(<cydriver.CUmipmappedArray*>phMipmappedArray._pvt_ptr, cyhTexRef)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phMipmappedArray)
{{endif}}

{{if 'cuTexRefGetAddressMode' in found_functions}}

@cython.embedsignature(True)
def cuTexRefGetAddressMode(hTexRef, int dim):
    """ Gets the addressing mode used by a texture reference.

    [Deprecated]

    Returns in `*pam` the addressing mode corresponding to the dimension
    `dim` of the texture reference `hTexRef`. Currently, the only valid
    value for `dim` are 0 and 1.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    dim : int
        Dimension

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pam : :py:obj:`~.CUaddress_mode`
        Returned addressing mode

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef cydriver.CUaddress_mode pam
    with nogil:
        err = cydriver.cuTexRefGetAddressMode(&pam, cyhTexRef, dim)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], CUaddress_mode(pam))
{{endif}}

{{if 'cuTexRefGetFilterMode' in found_functions}}

@cython.embedsignature(True)
def cuTexRefGetFilterMode(hTexRef):
    """ Gets the filter-mode used by a texture reference.

    [Deprecated]

    Returns in `*pfm` the filtering mode of the texture reference
    `hTexRef`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pfm : :py:obj:`~.CUfilter_mode`
        Returned filtering mode

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef cydriver.CUfilter_mode pfm
    with nogil:
        err = cydriver.cuTexRefGetFilterMode(&pfm, cyhTexRef)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], CUfilter_mode(pfm))
{{endif}}

{{if 'cuTexRefGetFormat' in found_functions}}

@cython.embedsignature(True)
def cuTexRefGetFormat(hTexRef):
    """ Gets the format used by a texture reference.

    [Deprecated]

    Returns in `*pFormat` and `*pNumChannels` the format and number of
    components of the CUDA array bound to the texture reference `hTexRef`.
    If `pFormat` or `pNumChannels` is NULL, it will be ignored.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pFormat : :py:obj:`~.CUarray_format`
        Returned format
    pNumChannels : int
        Returned number of components

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef cydriver.CUarray_format pFormat
    cdef int pNumChannels = 0
    with nogil:
        err = cydriver.cuTexRefGetFormat(&pFormat, &pNumChannels, cyhTexRef)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], CUarray_format(pFormat), pNumChannels)
{{endif}}

{{if 'cuTexRefGetMipmapFilterMode' in found_functions}}

@cython.embedsignature(True)
def cuTexRefGetMipmapFilterMode(hTexRef):
    """ Gets the mipmap filtering mode for a texture reference.

    [Deprecated]

    Returns the mipmap filtering mode in `pfm` that's used when reading
    memory through the texture reference `hTexRef`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pfm : :py:obj:`~.CUfilter_mode`
        Returned mipmap filtering mode

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef cydriver.CUfilter_mode pfm
    with nogil:
        err = cydriver.cuTexRefGetMipmapFilterMode(&pfm, cyhTexRef)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], CUfilter_mode(pfm))
{{endif}}

{{if 'cuTexRefGetMipmapLevelBias' in found_functions}}

@cython.embedsignature(True)
def cuTexRefGetMipmapLevelBias(hTexRef):
    """ Gets the mipmap level bias for a texture reference.

    [Deprecated]

    Returns the mipmap level bias in `pBias` that's added to the specified
    mipmap level when reading memory through the texture reference
    `hTexRef`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pbias : float
        Returned mipmap level bias

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef float pbias = 0
    with nogil:
        err = cydriver.cuTexRefGetMipmapLevelBias(&pbias, cyhTexRef)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pbias)
{{endif}}

{{if 'cuTexRefGetMipmapLevelClamp' in found_functions}}

@cython.embedsignature(True)
def cuTexRefGetMipmapLevelClamp(hTexRef):
    """ Gets the min/max mipmap level clamps for a texture reference.

    [Deprecated]

    Returns the min/max mipmap level clamps in `pminMipmapLevelClamp` and
    `pmaxMipmapLevelClamp` that's used when reading memory through the
    texture reference `hTexRef`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pminMipmapLevelClamp : float
        Returned mipmap min level clamp
    pmaxMipmapLevelClamp : float
        Returned mipmap max level clamp

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef float pminMipmapLevelClamp = 0
    cdef float pmaxMipmapLevelClamp = 0
    with nogil:
        err = cydriver.cuTexRefGetMipmapLevelClamp(&pminMipmapLevelClamp, &pmaxMipmapLevelClamp, cyhTexRef)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], pminMipmapLevelClamp, pmaxMipmapLevelClamp)
{{endif}}

{{if 'cuTexRefGetMaxAnisotropy' in found_functions}}

@cython.embedsignature(True)
def cuTexRefGetMaxAnisotropy(hTexRef):
    """ Gets the maximum anisotropy for a texture reference.

    [Deprecated]

    Returns the maximum anisotropy in `pmaxAniso` that's used when reading
    memory through the texture reference `hTexRef`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pmaxAniso : int
        Returned maximum anisotropy

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef int pmaxAniso = 0
    with nogil:
        err = cydriver.cuTexRefGetMaxAnisotropy(&pmaxAniso, cyhTexRef)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pmaxAniso)
{{endif}}

{{if 'cuTexRefGetBorderColor' in found_functions}}

@cython.embedsignature(True)
def cuTexRefGetBorderColor(hTexRef):
    """ Gets the border color used by a texture reference.

    [Deprecated]

    Returns in `pBorderColor`, values of the RGBA color used by the texture
    reference `hTexRef`. The color value is of type float and holds color
    components in the following sequence: pBorderColor[0] holds 'R'
    component pBorderColor[1] holds 'G' component pBorderColor[2] holds 'B'
    component pBorderColor[3] holds 'A' component

    Parameters
    ----------
    pBorderColor : :py:obj:`~.CUtexref`
        Returned Type and Value of RGBA color

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    hTexRef : float
        Texture reference

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetBorderColor`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef float pBorderColor = 0
    with nogil:
        err = cydriver.cuTexRefGetBorderColor(&pBorderColor, cyhTexRef)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pBorderColor)
{{endif}}

{{if 'cuTexRefGetFlags' in found_functions}}

@cython.embedsignature(True)
def cuTexRefGetFlags(hTexRef):
    """ Gets the flags used by a texture reference.

    [Deprecated]

    Returns in `*pFlags` the flags of the texture reference `hTexRef`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pFlags : unsigned int
        Returned flags

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    cdef unsigned int pFlags = 0
    with nogil:
        err = cydriver.cuTexRefGetFlags(&pFlags, cyhTexRef)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pFlags)
{{endif}}

{{if 'cuTexRefCreate' in found_functions}}

@cython.embedsignature(True)
def cuTexRefCreate():
    """ Creates a texture reference.

    [Deprecated]

    Creates a texture reference and returns its handle in `*pTexRef`. Once
    created, the application must call :py:obj:`~.cuTexRefSetArray()` or
    :py:obj:`~.cuTexRefSetAddress()` to associate the reference with
    allocated memory. Other texture reference functions are used to specify
    the format and interpretation (addressing, filtering, etc.) to be used
    when the memory is read through this texture reference.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pTexRef : :py:obj:`~.CUtexref`
        Returned texture reference

    See Also
    --------
    :py:obj:`~.cuTexRefDestroy`
    """
    cdef CUtexref pTexRef = CUtexref()
    with nogil:
        err = cydriver.cuTexRefCreate(<cydriver.CUtexref*>pTexRef._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pTexRef)
{{endif}}

{{if 'cuTexRefDestroy' in found_functions}}

@cython.embedsignature(True)
def cuTexRefDestroy(hTexRef):
    """ Destroys a texture reference.

    [Deprecated]

    Destroys the texture reference specified by `hTexRef`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefCreate`
    """
    cdef cydriver.CUtexref cyhTexRef
    if hTexRef is None:
        phTexRef = 0
    elif isinstance(hTexRef, (CUtexref,)):
        phTexRef = int(hTexRef)
    else:
        phTexRef = int(CUtexref(hTexRef))
    cyhTexRef = <cydriver.CUtexref><void_ptr>phTexRef
    with nogil:
        err = cydriver.cuTexRefDestroy(cyhTexRef)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuSurfRefSetArray' in found_functions}}

@cython.embedsignature(True)
def cuSurfRefSetArray(hSurfRef, hArray, unsigned int Flags):
    """ Sets the CUDA array for a surface reference.

    [Deprecated]

    Sets the CUDA array `hArray` to be read and written by the surface
    reference `hSurfRef`. Any previous CUDA array state associated with the
    surface reference is superseded by this function. `Flags` must be set
    to 0. The :py:obj:`~.CUDA_ARRAY3D_SURFACE_LDST` flag must have been set
    for the CUDA array. Any CUDA array previously bound to `hSurfRef` is
    unbound.

    Parameters
    ----------
    hSurfRef : :py:obj:`~.CUsurfref`
        Surface reference handle
    hArray : :py:obj:`~.CUarray`
        CUDA array handle
    Flags : unsigned int
        set to 0

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuModuleGetSurfRef`, :py:obj:`~.cuSurfRefGetArray`
    """
    cdef cydriver.CUarray cyhArray
    if hArray is None:
        phArray = 0
    elif isinstance(hArray, (CUarray,)):
        phArray = int(hArray)
    else:
        phArray = int(CUarray(hArray))
    cyhArray = <cydriver.CUarray><void_ptr>phArray
    cdef cydriver.CUsurfref cyhSurfRef
    if hSurfRef is None:
        phSurfRef = 0
    elif isinstance(hSurfRef, (CUsurfref,)):
        phSurfRef = int(hSurfRef)
    else:
        phSurfRef = int(CUsurfref(hSurfRef))
    cyhSurfRef = <cydriver.CUsurfref><void_ptr>phSurfRef
    with nogil:
        err = cydriver.cuSurfRefSetArray(cyhSurfRef, cyhArray, Flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuSurfRefGetArray' in found_functions}}

@cython.embedsignature(True)
def cuSurfRefGetArray(hSurfRef):
    """ Passes back the CUDA array bound to a surface reference.

    [Deprecated]

    Returns in `*phArray` the CUDA array bound to the surface reference
    `hSurfRef`, or returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if the
    surface reference is not bound to any CUDA array.

    Parameters
    ----------
    hSurfRef : :py:obj:`~.CUsurfref`
        Surface reference handle

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phArray : :py:obj:`~.CUarray`
        Surface reference handle

    See Also
    --------
    :py:obj:`~.cuModuleGetSurfRef`, :py:obj:`~.cuSurfRefSetArray`
    """
    cdef cydriver.CUsurfref cyhSurfRef
    if hSurfRef is None:
        phSurfRef = 0
    elif isinstance(hSurfRef, (CUsurfref,)):
        phSurfRef = int(hSurfRef)
    else:
        phSurfRef = int(CUsurfref(hSurfRef))
    cyhSurfRef = <cydriver.CUsurfref><void_ptr>phSurfRef
    cdef CUarray phArray = CUarray()
    with nogil:
        err = cydriver.cuSurfRefGetArray(<cydriver.CUarray*>phArray._pvt_ptr, cyhSurfRef)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phArray)
{{endif}}

{{if 'cuTexObjectCreate' in found_functions}}

@cython.embedsignature(True)
def cuTexObjectCreate(pResDesc : Optional[CUDA_RESOURCE_DESC], pTexDesc : Optional[CUDA_TEXTURE_DESC], pResViewDesc : Optional[CUDA_RESOURCE_VIEW_DESC]):
    """ Creates a texture object.

    Creates a texture object and returns it in `pTexObject`. `pResDesc`
    describes the data to texture from. `pTexDesc` describes how the data
    should be sampled. `pResViewDesc` is an optional argument that
    specifies an alternate format for the data described by `pResDesc`, and
    also describes the subresource region to restrict access to when
    texturing. `pResViewDesc` can only be specified if the type of resource
    is a CUDA array or a CUDA mipmapped array not in a block compressed
    format.

    Texture objects are only supported on devices of compute capability 3.0
    or higher. Additionally, a texture object is an opaque value, and, as
    such, should only be accessed through CUDA API calls.

    The :py:obj:`~.CUDA_RESOURCE_DESC` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.CUDA_RESOURCE_DESC.resType` specifies the type of resource
      to texture from. CUresourceType is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.CUDA_RESOURCE_DESC.resType` is set to
    :py:obj:`~.CU_RESOURCE_TYPE_ARRAY`,
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::array::hArray must be set to a
    valid CUDA array handle.

    If :py:obj:`~.CUDA_RESOURCE_DESC.resType` is set to
    :py:obj:`~.CU_RESOURCE_TYPE_MIPMAPPED_ARRAY`,
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::mipmap::hMipmappedArray must be
    set to a valid CUDA mipmapped array handle.

    If :py:obj:`~.CUDA_RESOURCE_DESC.resType` is set to
    :py:obj:`~.CU_RESOURCE_TYPE_LINEAR`,
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::linear::devPtr must be set to a
    valid device pointer, that is aligned to
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT`.
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::linear::format and
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::linear::numChannels describe the
    format of each component and the number of components per array
    element. :py:obj:`~.CUDA_RESOURCE_DESC`::res::linear::sizeInBytes
    specifies the size of the array in bytes. The total number of elements
    in the linear address range cannot exceed
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH`. The
    number of elements is computed as (sizeInBytes / (sizeof(format) *
    numChannels)).

    If :py:obj:`~.CUDA_RESOURCE_DESC.resType` is set to
    :py:obj:`~.CU_RESOURCE_TYPE_PITCH2D`,
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::devPtr must be set to a
    valid device pointer, that is aligned to
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT`.
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::format and
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::numChannels describe the
    format of each component and the number of components per array
    element. :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::width and
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::height specify the width
    and height of the array in elements, and cannot exceed
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH` and
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT`
    respectively.
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::pitchInBytes specifies
    the pitch between two rows in bytes and has to be aligned to
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT`. Pitch cannot
    exceed :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH`.

    - :py:obj:`~.flags` must be set to zero.

    The :py:obj:`~.CUDA_TEXTURE_DESC` struct is defined as

    **View CUDA Toolkit Documentation for a C++ code example**

    where

    - :py:obj:`~.CUDA_TEXTURE_DESC.addressMode` specifies the addressing
      mode for each dimension of the texture data.
      :py:obj:`~.CUaddress_mode` is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - This is ignored if :py:obj:`~.CUDA_RESOURCE_DESC.resType` is
      :py:obj:`~.CU_RESOURCE_TYPE_LINEAR`. Also, if the flag,
      :py:obj:`~.CU_TRSF_NORMALIZED_COORDINATES` is not set, the only
      supported address mode is :py:obj:`~.CU_TR_ADDRESS_MODE_CLAMP`.

    - :py:obj:`~.CUDA_TEXTURE_DESC.filterMode` specifies the filtering mode
      to be used when fetching from the texture. CUfilter_mode is defined
      as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - This is ignored if :py:obj:`~.CUDA_RESOURCE_DESC.resType` is
      :py:obj:`~.CU_RESOURCE_TYPE_LINEAR`.

    - :py:obj:`~.CUDA_TEXTURE_DESC.flags` can be any combination of the
      following:

      - :py:obj:`~.CU_TRSF_READ_AS_INTEGER`, which suppresses the default
        behavior of having the texture promote integer data to floating
        point data in the range [0, 1]. Note that texture with 32-bit
        integer format would not be promoted, regardless of whether or not
        this flag is specified.

      - :py:obj:`~.CU_TRSF_NORMALIZED_COORDINATES`, which suppresses the
        default behavior of having the texture coordinates range from [0,
        Dim) where Dim is the width or height of the CUDA array. Instead,
        the texture coordinates [0, 1.0) reference the entire breadth of
        the array dimension; Note that for CUDA mipmapped arrays, this flag
        has to be set.

      - :py:obj:`~.CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION`, which disables
        any trilinear filtering optimizations. Trilinear optimizations
        improve texture filtering performance by allowing bilinear
        filtering on textures in scenarios where it can closely approximate
        the expected results.

      - :py:obj:`~.CU_TRSF_SEAMLESS_CUBEMAP`, which enables seamless cube
        map filtering. This flag can only be specified if the underlying
        resource is a CUDA array or a CUDA mipmapped array that was created
        with the flag :py:obj:`~.CUDA_ARRAY3D_CUBEMAP`. When seamless cube
        map filtering is enabled, texture address modes specified by
        :py:obj:`~.CUDA_TEXTURE_DESC.addressMode` are ignored. Instead, if
        the :py:obj:`~.CUDA_TEXTURE_DESC.filterMode` is set to
        :py:obj:`~.CU_TR_FILTER_MODE_POINT` the address mode
        :py:obj:`~.CU_TR_ADDRESS_MODE_CLAMP` will be applied for all
        dimensions. If the :py:obj:`~.CUDA_TEXTURE_DESC.filterMode` is set
        to :py:obj:`~.CU_TR_FILTER_MODE_LINEAR` seamless cube map filtering
        will be performed when sampling along the cube face borders.

    - :py:obj:`~.CUDA_TEXTURE_DESC.maxAnisotropy` specifies the maximum
      anisotropy ratio to be used when doing anisotropic filtering. This
      value will be clamped to the range [1,16].

    - :py:obj:`~.CUDA_TEXTURE_DESC.mipmapFilterMode` specifies the filter
      mode when the calculated mipmap level lies between two defined mipmap
      levels.

    - :py:obj:`~.CUDA_TEXTURE_DESC.mipmapLevelBias` specifies the offset to
      be applied to the calculated mipmap level.

    - :py:obj:`~.CUDA_TEXTURE_DESC.minMipmapLevelClamp` specifies the lower
      end of the mipmap level range to clamp access to.

    - :py:obj:`~.CUDA_TEXTURE_DESC.maxMipmapLevelClamp` specifies the upper
      end of the mipmap level range to clamp access to.

    The :py:obj:`~.CUDA_RESOURCE_VIEW_DESC` struct is defined as

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.format` specifies how the data
      contained in the CUDA array or CUDA mipmapped array should be
      interpreted. Note that this can incur a change in size of the texture
      data. If the resource view format is a block compressed format, then
      the underlying CUDA array or CUDA mipmapped array has to have a base
      of format :py:obj:`~.CU_AD_FORMAT_UNSIGNED_INT32`. with 2 or 4
      channels, depending on the block compressed format. For ex., BC1 and
      BC4 require the underlying CUDA array to have a format of
      :py:obj:`~.CU_AD_FORMAT_UNSIGNED_INT32` with 2 channels. The other BC
      formats require the underlying resource to have the same base format
      but with 4 channels.

    - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.width` specifies the new width of
      the texture data. If the resource view format is a block compressed
      format, this value has to be 4 times the original width of the
      resource. For non block compressed formats, this value has to be
      equal to that of the original resource.

    - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.height` specifies the new height
      of the texture data. If the resource view format is a block
      compressed format, this value has to be 4 times the original height
      of the resource. For non block compressed formats, this value has to
      be equal to that of the original resource.

    - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.depth` specifies the new depth of
      the texture data. This value has to be equal to that of the original
      resource.

    - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.firstMipmapLevel` specifies the
      most detailed mipmap level. This will be the new mipmap level zero.
      For non-mipmapped resources, this value has to be
      zero.:py:obj:`~.CUDA_TEXTURE_DESC.minMipmapLevelClamp` and
      :py:obj:`~.CUDA_TEXTURE_DESC.maxMipmapLevelClamp` will be relative to
      this value. For ex., if the firstMipmapLevel is set to 2, and a
      minMipmapLevelClamp of 1.2 is specified, then the actual minimum
      mipmap level clamp will be 3.2.

    - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.lastMipmapLevel` specifies the
      least detailed mipmap level. For non-mipmapped resources, this value
      has to be zero.

    - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.firstLayer` specifies the first
      layer index for layered textures. This will be the new layer zero.
      For non-layered resources, this value has to be zero.

    - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.lastLayer` specifies the last
      layer index for layered textures. For non-layered resources, this
      value has to be zero.

    Parameters
    ----------
    pResDesc : :py:obj:`~.CUDA_RESOURCE_DESC`
        Resource descriptor
    pTexDesc : :py:obj:`~.CUDA_TEXTURE_DESC`
        Texture descriptor
    pResViewDesc : :py:obj:`~.CUDA_RESOURCE_VIEW_DESC`
        Resource view descriptor

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pTexObject : :py:obj:`~.CUtexObject`
        Texture object to create

    See Also
    --------
    :py:obj:`~.cuTexObjectDestroy`, :py:obj:`~.cudaCreateTextureObject`
    """
    cdef CUtexObject pTexObject = CUtexObject()
    cdef cydriver.CUDA_RESOURCE_DESC* cypResDesc_ptr = pResDesc._pvt_ptr if pResDesc is not None else NULL
    cdef cydriver.CUDA_TEXTURE_DESC* cypTexDesc_ptr = pTexDesc._pvt_ptr if pTexDesc is not None else NULL
    cdef cydriver.CUDA_RESOURCE_VIEW_DESC* cypResViewDesc_ptr = pResViewDesc._pvt_ptr if pResViewDesc is not None else NULL
    with nogil:
        err = cydriver.cuTexObjectCreate(<cydriver.CUtexObject*>pTexObject._pvt_ptr, cypResDesc_ptr, cypTexDesc_ptr, cypResViewDesc_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pTexObject)
{{endif}}

{{if 'cuTexObjectDestroy' in found_functions}}

@cython.embedsignature(True)
def cuTexObjectDestroy(texObject):
    """ Destroys a texture object.

    Destroys the texture object specified by `texObject`.

    Parameters
    ----------
    texObject : :py:obj:`~.CUtexObject`
        Texture object to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexObjectCreate`, :py:obj:`~.cudaDestroyTextureObject`
    """
    cdef cydriver.CUtexObject cytexObject
    if texObject is None:
        ptexObject = 0
    elif isinstance(texObject, (CUtexObject,)):
        ptexObject = int(texObject)
    else:
        ptexObject = int(CUtexObject(texObject))
    cytexObject = <cydriver.CUtexObject><void_ptr>ptexObject
    with nogil:
        err = cydriver.cuTexObjectDestroy(cytexObject)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuTexObjectGetResourceDesc' in found_functions}}

@cython.embedsignature(True)
def cuTexObjectGetResourceDesc(texObject):
    """ Returns a texture object's resource descriptor.

    Returns the resource descriptor for the texture object specified by
    `texObject`.

    Parameters
    ----------
    texObject : :py:obj:`~.CUtexObject`
        Texture object

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pResDesc : :py:obj:`~.CUDA_RESOURCE_DESC`
        Resource descriptor

    See Also
    --------
    :py:obj:`~.cuTexObjectCreate`, :py:obj:`~.cudaGetTextureObjectResourceDesc`,
    """
    cdef cydriver.CUtexObject cytexObject
    if texObject is None:
        ptexObject = 0
    elif isinstance(texObject, (CUtexObject,)):
        ptexObject = int(texObject)
    else:
        ptexObject = int(CUtexObject(texObject))
    cytexObject = <cydriver.CUtexObject><void_ptr>ptexObject
    cdef CUDA_RESOURCE_DESC pResDesc = CUDA_RESOURCE_DESC()
    with nogil:
        err = cydriver.cuTexObjectGetResourceDesc(<cydriver.CUDA_RESOURCE_DESC*>pResDesc._pvt_ptr, cytexObject)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pResDesc)
{{endif}}

{{if 'cuTexObjectGetTextureDesc' in found_functions}}

@cython.embedsignature(True)
def cuTexObjectGetTextureDesc(texObject):
    """ Returns a texture object's texture descriptor.

    Returns the texture descriptor for the texture object specified by
    `texObject`.

    Parameters
    ----------
    texObject : :py:obj:`~.CUtexObject`
        Texture object

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pTexDesc : :py:obj:`~.CUDA_TEXTURE_DESC`
        Texture descriptor

    See Also
    --------
    :py:obj:`~.cuTexObjectCreate`, :py:obj:`~.cudaGetTextureObjectTextureDesc`
    """
    cdef cydriver.CUtexObject cytexObject
    if texObject is None:
        ptexObject = 0
    elif isinstance(texObject, (CUtexObject,)):
        ptexObject = int(texObject)
    else:
        ptexObject = int(CUtexObject(texObject))
    cytexObject = <cydriver.CUtexObject><void_ptr>ptexObject
    cdef CUDA_TEXTURE_DESC pTexDesc = CUDA_TEXTURE_DESC()
    with nogil:
        err = cydriver.cuTexObjectGetTextureDesc(<cydriver.CUDA_TEXTURE_DESC*>pTexDesc._pvt_ptr, cytexObject)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pTexDesc)
{{endif}}

{{if 'cuTexObjectGetResourceViewDesc' in found_functions}}

@cython.embedsignature(True)
def cuTexObjectGetResourceViewDesc(texObject):
    """ Returns a texture object's resource view descriptor.

    Returns the resource view descriptor for the texture object specified
    by `texObject`. If no resource view was set for `texObject`, the
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

    Parameters
    ----------
    texObject : :py:obj:`~.CUtexObject`
        Texture object

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pResViewDesc : :py:obj:`~.CUDA_RESOURCE_VIEW_DESC`
        Resource view descriptor

    See Also
    --------
    :py:obj:`~.cuTexObjectCreate`, :py:obj:`~.cudaGetTextureObjectResourceViewDesc`
    """
    cdef cydriver.CUtexObject cytexObject
    if texObject is None:
        ptexObject = 0
    elif isinstance(texObject, (CUtexObject,)):
        ptexObject = int(texObject)
    else:
        ptexObject = int(CUtexObject(texObject))
    cytexObject = <cydriver.CUtexObject><void_ptr>ptexObject
    cdef CUDA_RESOURCE_VIEW_DESC pResViewDesc = CUDA_RESOURCE_VIEW_DESC()
    with nogil:
        err = cydriver.cuTexObjectGetResourceViewDesc(<cydriver.CUDA_RESOURCE_VIEW_DESC*>pResViewDesc._pvt_ptr, cytexObject)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pResViewDesc)
{{endif}}

{{if 'cuSurfObjectCreate' in found_functions}}

@cython.embedsignature(True)
def cuSurfObjectCreate(pResDesc : Optional[CUDA_RESOURCE_DESC]):
    """ Creates a surface object.

    Creates a surface object and returns it in `pSurfObject`. `pResDesc`
    describes the data to perform surface load/stores on.
    :py:obj:`~.CUDA_RESOURCE_DESC.resType` must be
    :py:obj:`~.CU_RESOURCE_TYPE_ARRAY` and
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::array::hArray must be set to a
    valid CUDA array handle. :py:obj:`~.CUDA_RESOURCE_DESC.flags` must be
    set to zero.

    Surface objects are only supported on devices of compute capability 3.0
    or higher. Additionally, a surface object is an opaque value, and, as
    such, should only be accessed through CUDA API calls.

    Parameters
    ----------
    pResDesc : :py:obj:`~.CUDA_RESOURCE_DESC`
        Resource descriptor

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pSurfObject : :py:obj:`~.CUsurfObject`
        Surface object to create

    See Also
    --------
    :py:obj:`~.cuSurfObjectDestroy`, :py:obj:`~.cudaCreateSurfaceObject`
    """
    cdef CUsurfObject pSurfObject = CUsurfObject()
    cdef cydriver.CUDA_RESOURCE_DESC* cypResDesc_ptr = pResDesc._pvt_ptr if pResDesc is not None else NULL
    with nogil:
        err = cydriver.cuSurfObjectCreate(<cydriver.CUsurfObject*>pSurfObject._pvt_ptr, cypResDesc_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pSurfObject)
{{endif}}

{{if 'cuSurfObjectDestroy' in found_functions}}

@cython.embedsignature(True)
def cuSurfObjectDestroy(surfObject):
    """ Destroys a surface object.

    Destroys the surface object specified by `surfObject`.

    Parameters
    ----------
    surfObject : :py:obj:`~.CUsurfObject`
        Surface object to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuSurfObjectCreate`, :py:obj:`~.cudaDestroySurfaceObject`
    """
    cdef cydriver.CUsurfObject cysurfObject
    if surfObject is None:
        psurfObject = 0
    elif isinstance(surfObject, (CUsurfObject,)):
        psurfObject = int(surfObject)
    else:
        psurfObject = int(CUsurfObject(surfObject))
    cysurfObject = <cydriver.CUsurfObject><void_ptr>psurfObject
    with nogil:
        err = cydriver.cuSurfObjectDestroy(cysurfObject)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuSurfObjectGetResourceDesc' in found_functions}}

@cython.embedsignature(True)
def cuSurfObjectGetResourceDesc(surfObject):
    """ Returns a surface object's resource descriptor.

    Returns the resource descriptor for the surface object specified by
    `surfObject`.

    Parameters
    ----------
    surfObject : :py:obj:`~.CUsurfObject`
        Surface object

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pResDesc : :py:obj:`~.CUDA_RESOURCE_DESC`
        Resource descriptor

    See Also
    --------
    :py:obj:`~.cuSurfObjectCreate`, :py:obj:`~.cudaGetSurfaceObjectResourceDesc`
    """
    cdef cydriver.CUsurfObject cysurfObject
    if surfObject is None:
        psurfObject = 0
    elif isinstance(surfObject, (CUsurfObject,)):
        psurfObject = int(surfObject)
    else:
        psurfObject = int(CUsurfObject(surfObject))
    cysurfObject = <cydriver.CUsurfObject><void_ptr>psurfObject
    cdef CUDA_RESOURCE_DESC pResDesc = CUDA_RESOURCE_DESC()
    with nogil:
        err = cydriver.cuSurfObjectGetResourceDesc(<cydriver.CUDA_RESOURCE_DESC*>pResDesc._pvt_ptr, cysurfObject)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pResDesc)
{{endif}}

{{if 'cuTensorMapEncodeTiled' in found_functions}}

@cython.embedsignature(True)
def cuTensorMapEncodeTiled(tensorDataType not None : CUtensorMapDataType, tensorRank, globalAddress, globalDim : Optional[tuple[cuuint64_t] | list[cuuint64_t]], globalStrides : Optional[tuple[cuuint64_t] | list[cuuint64_t]], boxDim : Optional[tuple[cuuint32_t] | list[cuuint32_t]], elementStrides : Optional[tuple[cuuint32_t] | list[cuuint32_t]], interleave not None : CUtensorMapInterleave, swizzle not None : CUtensorMapSwizzle, l2Promotion not None : CUtensorMapL2promotion, oobFill not None : CUtensorMapFloatOOBfill):
    """ Create a tensor map descriptor object representing tiled memory region.

    Creates a descriptor for Tensor Memory Access (TMA) object specified by
    the parameters describing a tiled region and returns it in `tensorMap`.

    Tensor map objects are only supported on devices of compute capability
    9.0 or higher. Additionally, a tensor map object is an opaque value,
    and, as such, should only be accessed through CUDA APIs and PTX.

    The parameters passed are bound to the following requirements:

    - `tensorMap` address must be aligned to 64 bytes.

    - `tensorDataType` has to be an enum from
      :py:obj:`~.CUtensorMapDataType` which is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B` copies '16 x U4'
      packed values to memory aligned as 8 bytes. There are no gaps between
      packed values. :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`
      copies '16 x U4' packed values to memory aligned as 16 bytes. There
      are 8 byte gaps between every 8 byte chunk of packed values.
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` copies '16 x U6'
      packed values to memory aligned as 16 bytes. There are 4 byte gaps
      between every 12 byte chunk of packed values.

    - `tensorRank` must be non-zero and less than or equal to the maximum
      supported dimensionality of 5. If `interleave` is not
      :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`, then `tensorRank` must
      additionally be greater than or equal to 3.

    - `globalAddress`, which specifies the starting address of the memory
      region described, must be 16 byte aligned. The following requirements
      need to also be met:

      - When `interleave` is :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_32B`,
        `globalAddress` must be 32 byte aligned.

      - When `tensorDataType` is
        :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
        :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, `globalAddress`
        must be 32 byte aligned.

    `globalDim` array, which specifies tensor size of each of the
    `tensorRank` dimensions, must be non-zero and less than or equal to
    2^32. Additionally, the following requirements need to be met for the
    packed data types:

    - When `tensorDataType` is
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, globalDim[0] must
      be a multiple of 128.

    - When `tensorDataType` is
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B`, `globalDim`[0] must
      be a multiple of 2.

    - Dimension for the packed data types must reflect the number of
      individual U# values.

    `globalStrides` array, which specifies tensor stride of each of the
    lower `tensorRank` - 1 dimensions in bytes, must be a multiple of 16
    and less than 2^40. Additionally, the following requirements need to be
    met:

    - When `interleave` is :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_32B`, the
      strides must be a multiple of 32.

    - When `tensorDataType` is
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, the strides must
      be a multiple of 32. Each following dimension specified includes
      previous dimension stride:

    - **View CUDA Toolkit Documentation for a C++ code example**

    `boxDim` array, which specifies number of elements to be traversed
    along each of the `tensorRank` dimensions, must be non-zero and less
    than or equal to 256. Additionally, the following requirements need to
    be met:

    - When `interleave` is :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`, {
      `boxDim`[0] * elementSizeInBytes( `tensorDataType` ) } must be a
      multiple of 16 bytes.

    - When `tensorDataType` is
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, boxDim[0] must be
      128.

    `elementStrides` array, which specifies the iteration step along each
    of the `tensorRank` dimensions, must be non-zero and less than or equal
    to 8. Note that when `interleave` is
    :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`, the first element of this
    array is ignored since TMA doesnt support the stride for dimension
    zero. When all elements of `elementStrides` array is one, `boxDim`
    specifies the number of elements to load. However, if the
    `elementStrides`[i] is not equal to one, then TMA loads ceil(
    `boxDim`[i] / `elementStrides`[i]) number of elements along i-th
    dimension. To load N elements along i-th dimension, `boxDim`[i] must be
    set to N * `elementStrides`[i].

    - `interleave` specifies the interleaved layout of type
      :py:obj:`~.CUtensorMapInterleave`, which is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - TMA supports interleaved layouts like NC/8HWC8 where C8 utilizes 16
      bytes in memory assuming 2 byte per channel or NC/16HWC16 where C16
      uses 32 bytes. When `interleave` is
      :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE` and `swizzle` is not
      :py:obj:`~.CU_TENSOR_MAP_SWIZZLE_NONE`, the bounding box inner
      dimension (computed as `boxDim`[0] multiplied by element size derived
      from `tensorDataType`) must be less than or equal to the swizzle
      size.

      - CU_TENSOR_MAP_SWIZZLE_32B requires the bounding box inner dimension
        to be <= 32.

      - CU_TENSOR_MAP_SWIZZLE_64B requires the bounding box inner dimension
        to be <= 64.

      - CU_TENSOR_MAP_SWIZZLE_128B* require the bounding box inner
        dimension to be <= 128. Additionally, `tensorDataType` of
        :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` requires
        `interleave` to be :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`.

    - `swizzle`, which specifies the shared memory bank swizzling pattern,
      has to be of type :py:obj:`~.CUtensorMapSwizzle` which is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - Data are organized in a specific order in global memory; however,
      this may not match the order in which the application accesses data
      in shared memory. This difference in data organization may cause bank
      conflicts when shared memory is accessed. In order to avoid this
      problem, data can be loaded to shared memory with shuffling across
      shared memory banks. When `interleave` is
      :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_32B`, `swizzle` must be
      :py:obj:`~.CU_TENSOR_MAP_SWIZZLE_32B`. Other interleave modes can
      have any swizzling pattern. When the `tensorDataType` is
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B`, only the following
      swizzle modes are supported:

      - CU_TENSOR_MAP_SWIZZLE_NONE (Load & Store)

      - CU_TENSOR_MAP_SWIZZLE_128B (Load & Store)

      - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load & Store)

      - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B (Store only) When the
        `tensorDataType` is
        :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, only the
        following swizzle modes are supported:

      - CU_TENSOR_MAP_SWIZZLE_NONE (Load only)

      - CU_TENSOR_MAP_SWIZZLE_128B (Load only)

      - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load only)

    - `l2Promotion` specifies L2 fetch size which indicates the byte
      granurality at which L2 requests is filled from DRAM. It must be of
      type :py:obj:`~.CUtensorMapL2promotion`, which is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - `oobFill`, which indicates whether zero or a special NaN constant
      should be used to fill out-of-bound elements, must be of type
      :py:obj:`~.CUtensorMapFloatOOBfill` which is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - Note that
      :py:obj:`~.CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA` can
      only be used when `tensorDataType` represents a floating-point data
      type, and when `tensorDataType` is not
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B`,
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, and
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B`.

    Parameters
    ----------
    tensorDataType : :py:obj:`~.CUtensorMapDataType`
        Tensor data type
    tensorRank : Any
        Dimensionality of tensor
    globalAddress : Any
        Starting address of memory region described by tensor
    globalDim : list[:py:obj:`~.cuuint64_t`]
        Array containing tensor size (number of elements) along each of the
        `tensorRank` dimensions
    globalStrides : list[:py:obj:`~.cuuint64_t`]
        Array containing stride size (in bytes) along each of the
        `tensorRank` - 1 dimensions
    boxDim : list[:py:obj:`~.cuuint32_t`]
        Array containing traversal box size (number of elments) along each
        of the `tensorRank` dimensions. Specifies how many elements to be
        traversed along each tensor dimension.
    elementStrides : list[:py:obj:`~.cuuint32_t`]
        Array containing traversal stride in each of the `tensorRank`
        dimensions
    interleave : :py:obj:`~.CUtensorMapInterleave`
        Type of interleaved layout the tensor addresses
    swizzle : :py:obj:`~.CUtensorMapSwizzle`
        Bank swizzling pattern inside shared memory
    l2Promotion : :py:obj:`~.CUtensorMapL2promotion`
        L2 promotion size
    oobFill : :py:obj:`~.CUtensorMapFloatOOBfill`
        Indicate whether zero or special NaN constant must be used to fill
        out-of-bound elements

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    tensorMap : :py:obj:`~.CUtensorMap`
        Tensor map object to create

    See Also
    --------
    :py:obj:`~.cuTensorMapEncodeIm2col`, :py:obj:`~.cuTensorMapEncodeIm2colWide`, :py:obj:`~.cuTensorMapReplaceAddress`
    """
    elementStrides = [] if elementStrides is None else elementStrides
    if not all(isinstance(_x, (cuuint32_t,)) for _x in elementStrides):
        raise TypeError("Argument 'elementStrides' is not instance of type (expected tuple[cydriver.cuuint32_t,] or list[cydriver.cuuint32_t,]")
    boxDim = [] if boxDim is None else boxDim
    if not all(isinstance(_x, (cuuint32_t,)) for _x in boxDim):
        raise TypeError("Argument 'boxDim' is not instance of type (expected tuple[cydriver.cuuint32_t,] or list[cydriver.cuuint32_t,]")
    globalStrides = [] if globalStrides is None else globalStrides
    if not all(isinstance(_x, (cuuint64_t,)) for _x in globalStrides):
        raise TypeError("Argument 'globalStrides' is not instance of type (expected tuple[cydriver.cuuint64_t,] or list[cydriver.cuuint64_t,]")
    globalDim = [] if globalDim is None else globalDim
    if not all(isinstance(_x, (cuuint64_t,)) for _x in globalDim):
        raise TypeError("Argument 'globalDim' is not instance of type (expected tuple[cydriver.cuuint64_t,] or list[cydriver.cuuint64_t,]")
    cdef cydriver.cuuint32_t cytensorRank
    if tensorRank is None:
        ptensorRank = 0
    elif isinstance(tensorRank, (cuuint32_t,)):
        ptensorRank = int(tensorRank)
    else:
        ptensorRank = int(cuuint32_t(tensorRank))
    cytensorRank = <cydriver.cuuint32_t><void_ptr>ptensorRank
    cdef CUtensorMap tensorMap = CUtensorMap()
    cdef cydriver.CUtensorMapDataType cytensorDataType = tensorDataType.value
    cyglobalAddress = _HelperInputVoidPtr(globalAddress)
    cdef void* cyglobalAddress_ptr = <void*><void_ptr>cyglobalAddress.cptr
    cdef cydriver.cuuint64_t* cyglobalDim = NULL
    if len(globalDim) > 1:
        cyglobalDim = <cydriver.cuuint64_t*> calloc(len(globalDim), sizeof(cydriver.cuuint64_t))
        if cyglobalDim is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(globalDim)) + 'x' + str(sizeof(cydriver.cuuint64_t)))
        else:
            for idx in range(len(globalDim)):
                cyglobalDim[idx] = <cydriver.cuuint64_t>(<cuuint64_t>globalDim[idx])._pvt_ptr[0]
    elif len(globalDim) == 1:
        cyglobalDim = <cydriver.cuuint64_t*>(<cuuint64_t>globalDim[0])._pvt_ptr
    cdef cydriver.cuuint64_t* cyglobalStrides = NULL
    if len(globalStrides) > 1:
        cyglobalStrides = <cydriver.cuuint64_t*> calloc(len(globalStrides), sizeof(cydriver.cuuint64_t))
        if cyglobalStrides is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(globalStrides)) + 'x' + str(sizeof(cydriver.cuuint64_t)))
        else:
            for idx in range(len(globalStrides)):
                cyglobalStrides[idx] = <cydriver.cuuint64_t>(<cuuint64_t>globalStrides[idx])._pvt_ptr[0]
    elif len(globalStrides) == 1:
        cyglobalStrides = <cydriver.cuuint64_t*>(<cuuint64_t>globalStrides[0])._pvt_ptr
    cdef cydriver.cuuint32_t* cyboxDim = NULL
    if len(boxDim) > 1:
        cyboxDim = <cydriver.cuuint32_t*> calloc(len(boxDim), sizeof(cydriver.cuuint32_t))
        if cyboxDim is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(boxDim)) + 'x' + str(sizeof(cydriver.cuuint32_t)))
        else:
            for idx in range(len(boxDim)):
                cyboxDim[idx] = <cydriver.cuuint32_t>(<cuuint32_t>boxDim[idx])._pvt_ptr[0]
    elif len(boxDim) == 1:
        cyboxDim = <cydriver.cuuint32_t*>(<cuuint32_t>boxDim[0])._pvt_ptr
    cdef cydriver.cuuint32_t* cyelementStrides = NULL
    if len(elementStrides) > 1:
        cyelementStrides = <cydriver.cuuint32_t*> calloc(len(elementStrides), sizeof(cydriver.cuuint32_t))
        if cyelementStrides is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(elementStrides)) + 'x' + str(sizeof(cydriver.cuuint32_t)))
        else:
            for idx in range(len(elementStrides)):
                cyelementStrides[idx] = <cydriver.cuuint32_t>(<cuuint32_t>elementStrides[idx])._pvt_ptr[0]
    elif len(elementStrides) == 1:
        cyelementStrides = <cydriver.cuuint32_t*>(<cuuint32_t>elementStrides[0])._pvt_ptr
    cdef cydriver.CUtensorMapInterleave cyinterleave = interleave.value
    cdef cydriver.CUtensorMapSwizzle cyswizzle = swizzle.value
    cdef cydriver.CUtensorMapL2promotion cyl2Promotion = l2Promotion.value
    cdef cydriver.CUtensorMapFloatOOBfill cyoobFill = oobFill.value
    with nogil:
        err = cydriver.cuTensorMapEncodeTiled(<cydriver.CUtensorMap*>tensorMap._pvt_ptr, cytensorDataType, cytensorRank, cyglobalAddress_ptr, cyglobalDim, cyglobalStrides, cyboxDim, cyelementStrides, cyinterleave, cyswizzle, cyl2Promotion, cyoobFill)
    if len(globalDim) > 1 and cyglobalDim is not NULL:
        free(cyglobalDim)
    if len(globalStrides) > 1 and cyglobalStrides is not NULL:
        free(cyglobalStrides)
    if len(boxDim) > 1 and cyboxDim is not NULL:
        free(cyboxDim)
    if len(elementStrides) > 1 and cyelementStrides is not NULL:
        free(cyelementStrides)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], tensorMap)
{{endif}}

{{if 'cuTensorMapEncodeIm2col' in found_functions}}

@cython.embedsignature(True)
def cuTensorMapEncodeIm2col(tensorDataType not None : CUtensorMapDataType, tensorRank, globalAddress, globalDim : Optional[tuple[cuuint64_t] | list[cuuint64_t]], globalStrides : Optional[tuple[cuuint64_t] | list[cuuint64_t]], pixelBoxLowerCorner : Optional[tuple[int] | list[int]], pixelBoxUpperCorner : Optional[tuple[int] | list[int]], channelsPerPixel, pixelsPerColumn, elementStrides : Optional[tuple[cuuint32_t] | list[cuuint32_t]], interleave not None : CUtensorMapInterleave, swizzle not None : CUtensorMapSwizzle, l2Promotion not None : CUtensorMapL2promotion, oobFill not None : CUtensorMapFloatOOBfill):
    """ Create a tensor map descriptor object representing im2col memory region.

    Creates a descriptor for Tensor Memory Access (TMA) object specified by
    the parameters describing a im2col memory layout and returns it in
    `tensorMap`.

    Tensor map objects are only supported on devices of compute capability
    9.0 or higher. Additionally, a tensor map object is an opaque value,
    and, as such, should only be accessed through CUDA APIs and PTX.

    The parameters passed are bound to the following requirements:

    - `tensorMap` address must be aligned to 64 bytes.

    - `tensorDataType` has to be an enum from
      :py:obj:`~.CUtensorMapDataType` which is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B` copies '16 x U4'
      packed values to memory aligned as 8 bytes. There are no gaps between
      packed values. :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`
      copies '16 x U4' packed values to memory aligned as 16 bytes. There
      are 8 byte gaps between every 8 byte chunk of packed values.
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` copies '16 x U6'
      packed values to memory aligned as 16 bytes. There are 4 byte gaps
      between every 12 byte chunk of packed values.

    - `tensorRank`, which specifies the number of tensor dimensions, must
      be 3, 4, or 5.

    - `globalAddress`, which specifies the starting address of the memory
      region described, must be 16 byte aligned. The following requirements
      need to also be met:

      - When `interleave` is :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_32B`,
        `globalAddress` must be 32 byte aligned.

      - When `tensorDataType` is
        :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
        :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, `globalAddress`
        must be 32 byte aligned.

    - `globalDim` array, which specifies tensor size of each of the
      `tensorRank` dimensions, must be non-zero and less than or equal to
      2^32. Additionally, the following requirements need to be met for the
      packed data types:

      - When `tensorDataType` is
        :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
        :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, globalDim[0]
        must be a multiple of 128.

      - When `tensorDataType` is
        :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B`, `globalDim`[0]
        must be a multiple of 2.

      - Dimension for the packed data types must reflect the number of
        individual U# values.

    - `globalStrides` array, which specifies tensor stride of each of the
      lower `tensorRank` - 1 dimensions in bytes, must be a multiple of 16
      and less than 2^40. Additionally, the following requirements need to
      be met:

      - When `interleave` is :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_32B`, the
        strides must be a multiple of 32.

      - When `tensorDataType` is
        :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
        :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, the strides must
        be a multiple of 32. Each following dimension specified includes
        previous dimension stride:

      - **View CUDA Toolkit Documentation for a C++ code example**

    - `pixelBoxLowerCorner` array specifies the coordinate offsets {D, H,
      W} of the bounding box from top/left/front corner. The number of
      offsets and their precision depend on the tensor dimensionality:

      - When `tensorRank` is 3, one signed offset within range [-32768,
        32767] is supported.

      - When `tensorRank` is 4, two signed offsets each within range [-128,
        127] are supported.

      - When `tensorRank` is 5, three offsets each within range [-16, 15]
        are supported.

    - `pixelBoxUpperCorner` array specifies the coordinate offsets {D, H,
      W} of the bounding box from bottom/right/back corner. The number of
      offsets and their precision depend on the tensor dimensionality:

      - When `tensorRank` is 3, one signed offset within range [-32768,
        32767] is supported.

      - When `tensorRank` is 4, two signed offsets each within range [-128,
        127] are supported.

      - When `tensorRank` is 5, three offsets each within range [-16, 15]
        are supported. The bounding box specified by `pixelBoxLowerCorner`
        and `pixelBoxUpperCorner` must have non-zero area.

    - `channelsPerPixel`, which specifies the number of elements which must
      be accessed along C dimension, must be less than or equal to 256.
      Additionally, when `tensorDataType` is
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, `channelsPerPixel`
      must be 128.

    - `pixelsPerColumn`, which specifies the number of elements that must
      be accessed along the {N, D, H, W} dimensions, must be less than or
      equal to 1024.

    - `elementStrides` array, which specifies the iteration step along each
      of the `tensorRank` dimensions, must be non-zero and less than or
      equal to 8. Note that when `interleave` is
      :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`, the first element of this
      array is ignored since TMA doesnt support the stride for dimension
      zero. When all elements of the `elementStrides` array are one,
      `boxDim` specifies the number of elements to load. However, if
      `elementStrides`[i] is not equal to one for some `i`, then TMA loads
      ceil( `boxDim`[i] / `elementStrides`[i]) number of elements along
      i-th dimension. To load N elements along i-th dimension, `boxDim`[i]
      must be set to N * `elementStrides`[i].

    - `interleave` specifies the interleaved layout of type
      :py:obj:`~.CUtensorMapInterleave`, which is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - TMA supports interleaved layouts like NC/8HWC8 where C8 utilizes 16
      bytes in memory assuming 2 byte per channel or NC/16HWC16 where C16
      uses 32 bytes. When `interleave` is
      :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE` and `swizzle` is not
      :py:obj:`~.CU_TENSOR_MAP_SWIZZLE_NONE`, the bounding box inner
      dimension (computed as `channelsPerPixel` multiplied by element size
      in bytes derived from `tensorDataType`) must be less than or equal to
      the swizzle size.

      - CU_TENSOR_MAP_SWIZZLE_32B requires the bounding box inner dimension
        to be <= 32.

      - CU_TENSOR_MAP_SWIZZLE_64B requires the bounding box inner dimension
        to be <= 64.

      - CU_TENSOR_MAP_SWIZZLE_128B* require the bounding box inner
        dimension to be <= 128. Additionally, `tensorDataType` of
        :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` requires
        `interleave` to be :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`.

    - `swizzle`, which specifies the shared memory bank swizzling pattern,
      has to be of type :py:obj:`~.CUtensorMapSwizzle` which is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - Data are organized in a specific order in global memory; however,
      this may not match the order in which the application accesses data
      in shared memory. This difference in data organization may cause bank
      conflicts when shared memory is accessed. In order to avoid this
      problem, data can be loaded to shared memory with shuffling across
      shared memory banks. When `interleave` is
      :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_32B`, `swizzle` must be
      :py:obj:`~.CU_TENSOR_MAP_SWIZZLE_32B`. Other interleave modes can
      have any swizzling pattern. When the `tensorDataType` is
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B`, only the following
      swizzle modes are supported:

      - CU_TENSOR_MAP_SWIZZLE_NONE (Load & Store)

      - CU_TENSOR_MAP_SWIZZLE_128B (Load & Store)

      - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load & Store)

      - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B (Store only) When the
        `tensorDataType` is
        :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, only the
        following swizzle modes are supported:

      - CU_TENSOR_MAP_SWIZZLE_NONE (Load only)

      - CU_TENSOR_MAP_SWIZZLE_128B (Load only)

      - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load only)

    - `l2Promotion` specifies L2 fetch size which indicates the byte
      granularity at which L2 requests are filled from DRAM. It must be of
      type :py:obj:`~.CUtensorMapL2promotion`, which is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - `oobFill`, which indicates whether zero or a special NaN constant
      should be used to fill out-of-bound elements, must be of type
      :py:obj:`~.CUtensorMapFloatOOBfill` which is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - Note that
      :py:obj:`~.CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA` can
      only be used when `tensorDataType` represents a floating-point data
      type, and when `tensorDataType` is not
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B`,
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, and
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B`.

    Parameters
    ----------
    tensorDataType : :py:obj:`~.CUtensorMapDataType`
        Tensor data type
    tensorRank : Any
        Dimensionality of tensor; must be at least 3
    globalAddress : Any
        Starting address of memory region described by tensor
    globalDim : list[:py:obj:`~.cuuint64_t`]
        Array containing tensor size (number of elements) along each of the
        `tensorRank` dimensions
    globalStrides : list[:py:obj:`~.cuuint64_t`]
        Array containing stride size (in bytes) along each of the
        `tensorRank` - 1 dimensions
    pixelBoxLowerCorner : list[int]
        Array containing DHW dimensions of lower box corner
    pixelBoxUpperCorner : list[int]
        Array containing DHW dimensions of upper box corner
    channelsPerPixel : Any
        Number of channels per pixel
    pixelsPerColumn : Any
        Number of pixels per column
    elementStrides : list[:py:obj:`~.cuuint32_t`]
        Array containing traversal stride in each of the `tensorRank`
        dimensions
    interleave : :py:obj:`~.CUtensorMapInterleave`
        Type of interleaved layout the tensor addresses
    swizzle : :py:obj:`~.CUtensorMapSwizzle`
        Bank swizzling pattern inside shared memory
    l2Promotion : :py:obj:`~.CUtensorMapL2promotion`
        L2 promotion size
    oobFill : :py:obj:`~.CUtensorMapFloatOOBfill`
        Indicate whether zero or special NaN constant will be used to fill
        out-of-bound elements

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    tensorMap : :py:obj:`~.CUtensorMap`
        Tensor map object to create

    See Also
    --------
    :py:obj:`~.cuTensorMapEncodeTiled`, :py:obj:`~.cuTensorMapEncodeIm2colWide`, :py:obj:`~.cuTensorMapReplaceAddress`
    """
    elementStrides = [] if elementStrides is None else elementStrides
    if not all(isinstance(_x, (cuuint32_t,)) for _x in elementStrides):
        raise TypeError("Argument 'elementStrides' is not instance of type (expected tuple[cydriver.cuuint32_t,] or list[cydriver.cuuint32_t,]")
    cdef cydriver.cuuint32_t cypixelsPerColumn
    if pixelsPerColumn is None:
        ppixelsPerColumn = 0
    elif isinstance(pixelsPerColumn, (cuuint32_t,)):
        ppixelsPerColumn = int(pixelsPerColumn)
    else:
        ppixelsPerColumn = int(cuuint32_t(pixelsPerColumn))
    cypixelsPerColumn = <cydriver.cuuint32_t><void_ptr>ppixelsPerColumn
    cdef cydriver.cuuint32_t cychannelsPerPixel
    if channelsPerPixel is None:
        pchannelsPerPixel = 0
    elif isinstance(channelsPerPixel, (cuuint32_t,)):
        pchannelsPerPixel = int(channelsPerPixel)
    else:
        pchannelsPerPixel = int(cuuint32_t(channelsPerPixel))
    cychannelsPerPixel = <cydriver.cuuint32_t><void_ptr>pchannelsPerPixel
    pixelBoxUpperCorner = [] if pixelBoxUpperCorner is None else pixelBoxUpperCorner
    if not all(isinstance(_x, (int)) for _x in pixelBoxUpperCorner):
        raise TypeError("Argument 'pixelBoxUpperCorner' is not instance of type (expected tuple[int] or list[int]")
    pixelBoxLowerCorner = [] if pixelBoxLowerCorner is None else pixelBoxLowerCorner
    if not all(isinstance(_x, (int)) for _x in pixelBoxLowerCorner):
        raise TypeError("Argument 'pixelBoxLowerCorner' is not instance of type (expected tuple[int] or list[int]")
    globalStrides = [] if globalStrides is None else globalStrides
    if not all(isinstance(_x, (cuuint64_t,)) for _x in globalStrides):
        raise TypeError("Argument 'globalStrides' is not instance of type (expected tuple[cydriver.cuuint64_t,] or list[cydriver.cuuint64_t,]")
    globalDim = [] if globalDim is None else globalDim
    if not all(isinstance(_x, (cuuint64_t,)) for _x in globalDim):
        raise TypeError("Argument 'globalDim' is not instance of type (expected tuple[cydriver.cuuint64_t,] or list[cydriver.cuuint64_t,]")
    cdef cydriver.cuuint32_t cytensorRank
    if tensorRank is None:
        ptensorRank = 0
    elif isinstance(tensorRank, (cuuint32_t,)):
        ptensorRank = int(tensorRank)
    else:
        ptensorRank = int(cuuint32_t(tensorRank))
    cytensorRank = <cydriver.cuuint32_t><void_ptr>ptensorRank
    cdef CUtensorMap tensorMap = CUtensorMap()
    cdef cydriver.CUtensorMapDataType cytensorDataType = tensorDataType.value
    cyglobalAddress = _HelperInputVoidPtr(globalAddress)
    cdef void* cyglobalAddress_ptr = <void*><void_ptr>cyglobalAddress.cptr
    cdef cydriver.cuuint64_t* cyglobalDim = NULL
    if len(globalDim) > 1:
        cyglobalDim = <cydriver.cuuint64_t*> calloc(len(globalDim), sizeof(cydriver.cuuint64_t))
        if cyglobalDim is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(globalDim)) + 'x' + str(sizeof(cydriver.cuuint64_t)))
        else:
            for idx in range(len(globalDim)):
                cyglobalDim[idx] = <cydriver.cuuint64_t>(<cuuint64_t>globalDim[idx])._pvt_ptr[0]
    elif len(globalDim) == 1:
        cyglobalDim = <cydriver.cuuint64_t*>(<cuuint64_t>globalDim[0])._pvt_ptr
    cdef cydriver.cuuint64_t* cyglobalStrides = NULL
    if len(globalStrides) > 1:
        cyglobalStrides = <cydriver.cuuint64_t*> calloc(len(globalStrides), sizeof(cydriver.cuuint64_t))
        if cyglobalStrides is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(globalStrides)) + 'x' + str(sizeof(cydriver.cuuint64_t)))
        else:
            for idx in range(len(globalStrides)):
                cyglobalStrides[idx] = <cydriver.cuuint64_t>(<cuuint64_t>globalStrides[idx])._pvt_ptr[0]
    elif len(globalStrides) == 1:
        cyglobalStrides = <cydriver.cuuint64_t*>(<cuuint64_t>globalStrides[0])._pvt_ptr
    cdef vector[int] cypixelBoxLowerCorner = pixelBoxLowerCorner
    cdef vector[int] cypixelBoxUpperCorner = pixelBoxUpperCorner
    cdef cydriver.cuuint32_t* cyelementStrides = NULL
    if len(elementStrides) > 1:
        cyelementStrides = <cydriver.cuuint32_t*> calloc(len(elementStrides), sizeof(cydriver.cuuint32_t))
        if cyelementStrides is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(elementStrides)) + 'x' + str(sizeof(cydriver.cuuint32_t)))
        else:
            for idx in range(len(elementStrides)):
                cyelementStrides[idx] = <cydriver.cuuint32_t>(<cuuint32_t>elementStrides[idx])._pvt_ptr[0]
    elif len(elementStrides) == 1:
        cyelementStrides = <cydriver.cuuint32_t*>(<cuuint32_t>elementStrides[0])._pvt_ptr
    cdef cydriver.CUtensorMapInterleave cyinterleave = interleave.value
    cdef cydriver.CUtensorMapSwizzle cyswizzle = swizzle.value
    cdef cydriver.CUtensorMapL2promotion cyl2Promotion = l2Promotion.value
    cdef cydriver.CUtensorMapFloatOOBfill cyoobFill = oobFill.value
    with nogil:
        err = cydriver.cuTensorMapEncodeIm2col(<cydriver.CUtensorMap*>tensorMap._pvt_ptr, cytensorDataType, cytensorRank, cyglobalAddress_ptr, cyglobalDim, cyglobalStrides, cypixelBoxLowerCorner.data(), cypixelBoxUpperCorner.data(), cychannelsPerPixel, cypixelsPerColumn, cyelementStrides, cyinterleave, cyswizzle, cyl2Promotion, cyoobFill)
    if len(globalDim) > 1 and cyglobalDim is not NULL:
        free(cyglobalDim)
    if len(globalStrides) > 1 and cyglobalStrides is not NULL:
        free(cyglobalStrides)
    if len(elementStrides) > 1 and cyelementStrides is not NULL:
        free(cyelementStrides)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], tensorMap)
{{endif}}

{{if 'cuTensorMapEncodeIm2colWide' in found_functions}}

@cython.embedsignature(True)
def cuTensorMapEncodeIm2colWide(tensorDataType not None : CUtensorMapDataType, tensorRank, globalAddress, globalDim : Optional[tuple[cuuint64_t] | list[cuuint64_t]], globalStrides : Optional[tuple[cuuint64_t] | list[cuuint64_t]], int pixelBoxLowerCornerWidth, int pixelBoxUpperCornerWidth, channelsPerPixel, pixelsPerColumn, elementStrides : Optional[tuple[cuuint32_t] | list[cuuint32_t]], interleave not None : CUtensorMapInterleave, mode not None : CUtensorMapIm2ColWideMode, swizzle not None : CUtensorMapSwizzle, l2Promotion not None : CUtensorMapL2promotion, oobFill not None : CUtensorMapFloatOOBfill):
    """ Create a tensor map descriptor object representing im2col memory region, but where the elements are exclusively loaded along the W dimension.

    Creates a descriptor for Tensor Memory Access (TMA) object specified by
    the parameters describing a im2col memory layout and where the row is
    always loaded along the W dimensuin and returns it in `tensorMap`. This
    assumes the tensor layout in memory is either NDHWC, NHWC, or NWC.

    This API is only supported on devices of compute capability 10.0 or
    higher. Additionally, a tensor map object is an opaque value, and, as
    such, should only be accessed through CUDA APIs and PTX.

    The parameters passed are bound to the following requirements:

    - `tensorMap` address must be aligned to 64 bytes.

    - `tensorDataType` has to be an enum from
      :py:obj:`~.CUtensorMapDataType` which is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B` copies '16 x U4'
      packed values to memory aligned as 8 bytes. There are no gaps between
      packed values. :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`
      copies '16 x U4' packed values to memory aligned as 16 bytes. There
      are 8 byte gaps between every 8 byte chunk of packed values.
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` copies '16 x U6'
      packed values to memory aligned as 16 bytes. There are 4 byte gaps
      between every 12 byte chunk of packed values.

    - `tensorRank`, which specifies the number of tensor dimensions, must
      be 3, 4, or 5.

    - `globalAddress`, which specifies the starting address of the memory
      region described, must be 16 byte aligned. The following requirements
      need to also be met:

      - When `interleave` is :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_32B`,
        `globalAddress` must be 32 byte aligned.

      - When `tensorDataType` is
        :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
        :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, `globalAddress`
        must be 32 byte aligned.

    `globalDim` array, which specifies tensor size of each of the
    `tensorRank` dimensions, must be non-zero and less than or equal to
    2^32. Additionally, the following requirements need to be met for the
    packed data types:

    - When `tensorDataType` is
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, globalDim[0] must
      be a multiple of 128.

    - When `tensorDataType` is
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B`, `globalDim`[0] must
      be a multiple of 2.

    - Dimension for the packed data types must reflect the number of
      individual U# values.

    `globalStrides` array, which specifies tensor stride of each of the
    lower `tensorRank` - 1 dimensions in bytes, must be a multiple of 16
    and less than 2^40. Additionally, the following requirements need to be
    met:

    - When `interleave` is :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_32B`, the
      strides must be a multiple of 32.

    - When `tensorDataType` is
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, the strides must
      be a multiple of 32. Each following dimension specified includes
      previous dimension stride:

    - **View CUDA Toolkit Documentation for a C++ code example**

    `pixelBoxLowerCornerWidth` specifies the coordinate offset W of the
    bounding box from left corner. The offset must be within range [-32768,
    32767].

    - `pixelBoxUpperCornerWidth` specifies the coordinate offset W of the
      bounding box from right corner. The offset must be within range
      [-32768, 32767].

    The bounding box specified by `pixelBoxLowerCornerWidth` and
    `pixelBoxUpperCornerWidth` must have non-zero area. Note that the size
    of the box along D and H dimensions is always equal to one.

    - `channelsPerPixel`, which specifies the number of elements which must
      be accessed along C dimension, must be less than or equal to 256.
      Additionally, when `tensorDataType` is
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` or
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, `channelsPerPixel`
      must be 128.

    - `pixelsPerColumn`, which specifies the number of elements that must
      be accessed along the W dimension, must be less than or equal to
      1024. This field is ignored when `mode` is
      :py:obj:`~.CU_TENSOR_MAP_IM2COL_WIDE_MODE_W128`.

    - `elementStrides` array, which specifies the iteration step along each
      of the `tensorRank` dimensions, must be non-zero and less than or
      equal to 8. Note that when `interleave` is
      :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`, the first element of this
      array is ignored since TMA doesnt support the stride for dimension
      zero. When all elements of the `elementStrides` array are one,
      `boxDim` specifies the number of elements to load. However, if
      `elementStrides`[i] is not equal to one for some `i`, then TMA loads
      ceil( `boxDim`[i] / `elementStrides`[i]) number of elements along
      i-th dimension. To load N elements along i-th dimension, `boxDim`[i]
      must be set to N * `elementStrides`[i].

    - `interleave` specifies the interleaved layout of type
      :py:obj:`~.CUtensorMapInterleave`, which is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - TMA supports interleaved layouts like NC/8HWC8 where C8 utilizes 16
      bytes in memory assuming 2 byte per channel or NC/16HWC16 where C16
      uses 32 bytes. When `interleave` is
      :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`, the bounding box inner
      dimension (computed as `channelsPerPixel` multiplied by element size
      in bytes derived from `tensorDataType`) must be less than or equal to
      the swizzle size.

      - CU_TENSOR_MAP_SWIZZLE_64B requires the bounding box inner dimension
        to be <= 64.

      - CU_TENSOR_MAP_SWIZZLE_128B* require the bounding box inner
        dimension to be <= 128. Additionally, `tensorDataType` of
        :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B` requires
        `interleave` to be :py:obj:`~.CU_TENSOR_MAP_INTERLEAVE_NONE`.

    - `mode`, which describes loading of elements loaded along the W
      dimension, has to be one of the following
      :py:obj:`~.CUtensorMapIm2ColWideMode` types:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - :py:obj:`~.CU_TENSOR_MAP_IM2COL_WIDE_MODE_W` allows the number of
      elements loaded along the W dimension to be specified via the
      `pixelsPerColumn` field.

    - `swizzle`, which specifies the shared memory bank swizzling pattern,
      must be one of the following :py:obj:`~.CUtensorMapSwizzle` modes
      (other swizzle modes are not supported):

    - **View CUDA Toolkit Documentation for a C++ code example**

    - Data are organized in a specific order in global memory; however,
      this may not match the order in which the application accesses data
      in shared memory. This difference in data organization may cause bank
      conflicts when shared memory is accessed. In order to avoid this
      problem, data can be loaded to shared memory with shuffling across
      shared memory banks. When the `tensorDataType` is
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B`, only the following
      swizzle modes are supported:

      - CU_TENSOR_MAP_SWIZZLE_128B (Load & Store)

      - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load & Store) When the
        `tensorDataType` is
        :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, only the
        following swizzle modes are supported:

      - CU_TENSOR_MAP_SWIZZLE_128B (Load only)

      - CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load only)

    - `l2Promotion` specifies L2 fetch size which indicates the byte
      granularity at which L2 requests are filled from DRAM. It must be of
      type :py:obj:`~.CUtensorMapL2promotion`, which is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - `oobFill`, which indicates whether zero or a special NaN constant
      should be used to fill out-of-bound elements, must be of type
      :py:obj:`~.CUtensorMapFloatOOBfill` which is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - Note that
      :py:obj:`~.CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA` can
      only be used when `tensorDataType` represents a floating-point data
      type, and when `tensorDataType` is not
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B`,
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B`, and
      :py:obj:`~.CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B`.

    Parameters
    ----------
    tensorDataType : :py:obj:`~.CUtensorMapDataType`
        Tensor data type
    tensorRank : Any
        Dimensionality of tensor; must be at least 3
    globalAddress : Any
        Starting address of memory region described by tensor
    globalDim : list[:py:obj:`~.cuuint64_t`]
        Array containing tensor size (number of elements) along each of the
        `tensorRank` dimensions
    globalStrides : list[:py:obj:`~.cuuint64_t`]
        Array containing stride size (in bytes) along each of the
        `tensorRank` - 1 dimensions
    pixelBoxLowerCornerWidth : int
        Width offset of left box corner
    pixelBoxUpperCornerWidth : int
        Width offset of right box corner
    channelsPerPixel : Any
        Number of channels per pixel
    pixelsPerColumn : Any
        Number of pixels per column
    elementStrides : list[:py:obj:`~.cuuint32_t`]
        Array containing traversal stride in each of the `tensorRank`
        dimensions
    interleave : :py:obj:`~.CUtensorMapInterleave`
        Type of interleaved layout the tensor addresses
    mode : :py:obj:`~.CUtensorMapIm2ColWideMode`
        W or W128 mode
    swizzle : :py:obj:`~.CUtensorMapSwizzle`
        Bank swizzling pattern inside shared memory
    l2Promotion : :py:obj:`~.CUtensorMapL2promotion`
        L2 promotion size
    oobFill : :py:obj:`~.CUtensorMapFloatOOBfill`
        Indicate whether zero or special NaN constant will be used to fill
        out-of-bound elements

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    tensorMap : :py:obj:`~.CUtensorMap`
        Tensor map object to create

    See Also
    --------
    :py:obj:`~.cuTensorMapEncodeTiled`, :py:obj:`~.cuTensorMapEncodeIm2col`, :py:obj:`~.cuTensorMapReplaceAddress`
    """
    elementStrides = [] if elementStrides is None else elementStrides
    if not all(isinstance(_x, (cuuint32_t,)) for _x in elementStrides):
        raise TypeError("Argument 'elementStrides' is not instance of type (expected tuple[cydriver.cuuint32_t,] or list[cydriver.cuuint32_t,]")
    cdef cydriver.cuuint32_t cypixelsPerColumn
    if pixelsPerColumn is None:
        ppixelsPerColumn = 0
    elif isinstance(pixelsPerColumn, (cuuint32_t,)):
        ppixelsPerColumn = int(pixelsPerColumn)
    else:
        ppixelsPerColumn = int(cuuint32_t(pixelsPerColumn))
    cypixelsPerColumn = <cydriver.cuuint32_t><void_ptr>ppixelsPerColumn
    cdef cydriver.cuuint32_t cychannelsPerPixel
    if channelsPerPixel is None:
        pchannelsPerPixel = 0
    elif isinstance(channelsPerPixel, (cuuint32_t,)):
        pchannelsPerPixel = int(channelsPerPixel)
    else:
        pchannelsPerPixel = int(cuuint32_t(channelsPerPixel))
    cychannelsPerPixel = <cydriver.cuuint32_t><void_ptr>pchannelsPerPixel
    globalStrides = [] if globalStrides is None else globalStrides
    if not all(isinstance(_x, (cuuint64_t,)) for _x in globalStrides):
        raise TypeError("Argument 'globalStrides' is not instance of type (expected tuple[cydriver.cuuint64_t,] or list[cydriver.cuuint64_t,]")
    globalDim = [] if globalDim is None else globalDim
    if not all(isinstance(_x, (cuuint64_t,)) for _x in globalDim):
        raise TypeError("Argument 'globalDim' is not instance of type (expected tuple[cydriver.cuuint64_t,] or list[cydriver.cuuint64_t,]")
    cdef cydriver.cuuint32_t cytensorRank
    if tensorRank is None:
        ptensorRank = 0
    elif isinstance(tensorRank, (cuuint32_t,)):
        ptensorRank = int(tensorRank)
    else:
        ptensorRank = int(cuuint32_t(tensorRank))
    cytensorRank = <cydriver.cuuint32_t><void_ptr>ptensorRank
    cdef CUtensorMap tensorMap = CUtensorMap()
    cdef cydriver.CUtensorMapDataType cytensorDataType = tensorDataType.value
    cyglobalAddress = _HelperInputVoidPtr(globalAddress)
    cdef void* cyglobalAddress_ptr = <void*><void_ptr>cyglobalAddress.cptr
    cdef cydriver.cuuint64_t* cyglobalDim = NULL
    if len(globalDim) > 1:
        cyglobalDim = <cydriver.cuuint64_t*> calloc(len(globalDim), sizeof(cydriver.cuuint64_t))
        if cyglobalDim is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(globalDim)) + 'x' + str(sizeof(cydriver.cuuint64_t)))
        else:
            for idx in range(len(globalDim)):
                cyglobalDim[idx] = <cydriver.cuuint64_t>(<cuuint64_t>globalDim[idx])._pvt_ptr[0]
    elif len(globalDim) == 1:
        cyglobalDim = <cydriver.cuuint64_t*>(<cuuint64_t>globalDim[0])._pvt_ptr
    cdef cydriver.cuuint64_t* cyglobalStrides = NULL
    if len(globalStrides) > 1:
        cyglobalStrides = <cydriver.cuuint64_t*> calloc(len(globalStrides), sizeof(cydriver.cuuint64_t))
        if cyglobalStrides is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(globalStrides)) + 'x' + str(sizeof(cydriver.cuuint64_t)))
        else:
            for idx in range(len(globalStrides)):
                cyglobalStrides[idx] = <cydriver.cuuint64_t>(<cuuint64_t>globalStrides[idx])._pvt_ptr[0]
    elif len(globalStrides) == 1:
        cyglobalStrides = <cydriver.cuuint64_t*>(<cuuint64_t>globalStrides[0])._pvt_ptr
    cdef cydriver.cuuint32_t* cyelementStrides = NULL
    if len(elementStrides) > 1:
        cyelementStrides = <cydriver.cuuint32_t*> calloc(len(elementStrides), sizeof(cydriver.cuuint32_t))
        if cyelementStrides is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(elementStrides)) + 'x' + str(sizeof(cydriver.cuuint32_t)))
        else:
            for idx in range(len(elementStrides)):
                cyelementStrides[idx] = <cydriver.cuuint32_t>(<cuuint32_t>elementStrides[idx])._pvt_ptr[0]
    elif len(elementStrides) == 1:
        cyelementStrides = <cydriver.cuuint32_t*>(<cuuint32_t>elementStrides[0])._pvt_ptr
    cdef cydriver.CUtensorMapInterleave cyinterleave = interleave.value
    cdef cydriver.CUtensorMapIm2ColWideMode cymode = mode.value
    cdef cydriver.CUtensorMapSwizzle cyswizzle = swizzle.value
    cdef cydriver.CUtensorMapL2promotion cyl2Promotion = l2Promotion.value
    cdef cydriver.CUtensorMapFloatOOBfill cyoobFill = oobFill.value
    with nogil:
        err = cydriver.cuTensorMapEncodeIm2colWide(<cydriver.CUtensorMap*>tensorMap._pvt_ptr, cytensorDataType, cytensorRank, cyglobalAddress_ptr, cyglobalDim, cyglobalStrides, pixelBoxLowerCornerWidth, pixelBoxUpperCornerWidth, cychannelsPerPixel, cypixelsPerColumn, cyelementStrides, cyinterleave, cymode, cyswizzle, cyl2Promotion, cyoobFill)
    if len(globalDim) > 1 and cyglobalDim is not NULL:
        free(cyglobalDim)
    if len(globalStrides) > 1 and cyglobalStrides is not NULL:
        free(cyglobalStrides)
    if len(elementStrides) > 1 and cyelementStrides is not NULL:
        free(cyelementStrides)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], tensorMap)
{{endif}}

{{if 'cuTensorMapReplaceAddress' in found_functions}}

@cython.embedsignature(True)
def cuTensorMapReplaceAddress(tensorMap : Optional[CUtensorMap], globalAddress):
    """ Modify an existing tensor map descriptor with an updated global address.

    Modifies the descriptor for Tensor Memory Access (TMA) object passed in
    `tensorMap` with an updated `globalAddress`.

    Tensor map objects are only supported on devices of compute capability
    9.0 or higher. Additionally, a tensor map object is an opaque value,
    and, as such, should only be accessed through CUDA API calls.

    Parameters
    ----------
    tensorMap : :py:obj:`~.CUtensorMap`
        Tensor map object to modify
    globalAddress : Any
        Starting address of memory region described by tensor, must follow
        previous alignment requirements

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTensorMapEncodeTiled`, :py:obj:`~.cuTensorMapEncodeIm2col`, :py:obj:`~.cuTensorMapEncodeIm2colWide`
    """
    cdef cydriver.CUtensorMap* cytensorMap_ptr = tensorMap._pvt_ptr if tensorMap is not None else NULL
    cyglobalAddress = _HelperInputVoidPtr(globalAddress)
    cdef void* cyglobalAddress_ptr = <void*><void_ptr>cyglobalAddress.cptr
    with nogil:
        err = cydriver.cuTensorMapReplaceAddress(cytensorMap_ptr, cyglobalAddress_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuDeviceCanAccessPeer' in found_functions}}

@cython.embedsignature(True)
def cuDeviceCanAccessPeer(dev, peerDev):
    """ Queries if a device may directly access a peer device's memory.

    Returns in `*canAccessPeer` a value of 1 if contexts on `dev` are
    capable of directly accessing memory from contexts on `peerDev` and 0
    otherwise. If direct access of `peerDev` from `dev` is possible, then
    access may be enabled on two specific contexts by calling
    :py:obj:`~.cuCtxEnablePeerAccess()`.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device from which allocations on `peerDev` are to be directly
        accessed.
    peerDev : :py:obj:`~.CUdevice`
        Device on which the allocations to be directly accessed by `dev`
        reside.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    canAccessPeer : int
        Returned access capability

    See Also
    --------
    :py:obj:`~.cuCtxEnablePeerAccess`, :py:obj:`~.cuCtxDisablePeerAccess`, :py:obj:`~.cudaDeviceCanAccessPeer`
    """
    cdef cydriver.CUdevice cypeerDev
    if peerDev is None:
        ppeerDev = 0
    elif isinstance(peerDev, (CUdevice,)):
        ppeerDev = int(peerDev)
    else:
        ppeerDev = int(CUdevice(peerDev))
    cypeerDev = <cydriver.CUdevice>ppeerDev
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef int canAccessPeer = 0
    with nogil:
        err = cydriver.cuDeviceCanAccessPeer(&canAccessPeer, cydev, cypeerDev)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], canAccessPeer)
{{endif}}

{{if 'cuCtxEnablePeerAccess' in found_functions}}

@cython.embedsignature(True)
def cuCtxEnablePeerAccess(peerContext, unsigned int Flags):
    """ Enables direct access to memory allocations in a peer context.

    If both the current context and `peerContext` are on devices which
    support unified addressing (as may be queried using
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING`) and same major
    compute capability, then on success all allocations from `peerContext`
    will immediately be accessible by the current context. See
    :py:obj:`~.Unified Addressing` for additional details.

    Note that access granted by this call is unidirectional and that in
    order to access memory from the current context in `peerContext`, a
    separate symmetric call to :py:obj:`~.cuCtxEnablePeerAccess()` is
    required.

    Note that there are both device-wide and system-wide limitations per
    system configuration, as noted in the CUDA Programming Guide under the
    section "Peer-to-Peer Memory Access".

    Returns :py:obj:`~.CUDA_ERROR_PEER_ACCESS_UNSUPPORTED` if
    :py:obj:`~.cuDeviceCanAccessPeer()` indicates that the
    :py:obj:`~.CUdevice` of the current context cannot directly access
    memory from the :py:obj:`~.CUdevice` of `peerContext`.

    Returns :py:obj:`~.CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED` if direct
    access of `peerContext` from the current context has already been
    enabled.

    Returns :py:obj:`~.CUDA_ERROR_TOO_MANY_PEERS` if direct peer access is
    not possible because hardware resources required for peer access have
    been exhausted.

    Returns :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` if there is no current
    context, `peerContext` is not a valid context, or if the current
    context is `peerContext`.

    Returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if `Flags` is not 0.

    Parameters
    ----------
    peerContext : :py:obj:`~.CUcontext`
        Peer context to enable direct access to from the current context
    Flags : unsigned int
        Reserved for future use and must be set to 0

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED`, :py:obj:`~.CUDA_ERROR_TOO_MANY_PEERS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_PEER_ACCESS_UNSUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuDeviceCanAccessPeer`, :py:obj:`~.cuCtxDisablePeerAccess`, :py:obj:`~.cudaDeviceEnablePeerAccess`
    """
    cdef cydriver.CUcontext cypeerContext
    if peerContext is None:
        ppeerContext = 0
    elif isinstance(peerContext, (CUcontext,)):
        ppeerContext = int(peerContext)
    else:
        ppeerContext = int(CUcontext(peerContext))
    cypeerContext = <cydriver.CUcontext><void_ptr>ppeerContext
    with nogil:
        err = cydriver.cuCtxEnablePeerAccess(cypeerContext, Flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCtxDisablePeerAccess' in found_functions}}

@cython.embedsignature(True)
def cuCtxDisablePeerAccess(peerContext):
    """ Disables direct access to memory allocations in a peer context and unregisters any registered allocations.

    Returns :py:obj:`~.CUDA_ERROR_PEER_ACCESS_NOT_ENABLED` if direct peer
    access has not yet been enabled from `peerContext` to the current
    context.

    Returns :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` if there is no current
    context, or if `peerContext` is not a valid context.

    Parameters
    ----------
    peerContext : :py:obj:`~.CUcontext`
        Peer context to disable direct access to

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_PEER_ACCESS_NOT_ENABLED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,

    See Also
    --------
    :py:obj:`~.cuDeviceCanAccessPeer`, :py:obj:`~.cuCtxEnablePeerAccess`, :py:obj:`~.cudaDeviceDisablePeerAccess`
    """
    cdef cydriver.CUcontext cypeerContext
    if peerContext is None:
        ppeerContext = 0
    elif isinstance(peerContext, (CUcontext,)):
        ppeerContext = int(peerContext)
    else:
        ppeerContext = int(CUcontext(peerContext))
    cypeerContext = <cydriver.CUcontext><void_ptr>ppeerContext
    with nogil:
        err = cydriver.cuCtxDisablePeerAccess(cypeerContext)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuDeviceGetP2PAttribute' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetP2PAttribute(attrib not None : CUdevice_P2PAttribute, srcDevice, dstDevice):
    """ Queries attributes of the link between two devices.

    Returns in `*value` the value of the requested attribute `attrib` of
    the link between `srcDevice` and `dstDevice`. The supported attributes
    are:

    - :py:obj:`~.CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK`: A relative
      value indicating the performance of the link between two devices.

    - :py:obj:`~.CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED` P2P: 1 if P2P
      Access is enable.

    - :py:obj:`~.CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED`: 1 if all
      CUDA-valid atomic operations over the link are supported.

    - :py:obj:`~.CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED`: 1 if
      cudaArray can be accessed over the link.

    - :py:obj:`~.CU_DEVICE_P2P_ATTRIBUTE_ONLY_PARTIAL_NATIVE_ATOMIC_SUPPORTED`:
      1 if some CUDA-valid atomic operations over the link are supported.
      Information about specific operations can be retrieved with
      :py:obj:`~.cuDeviceGetP2PAtomicCapabilities`.

    Returns :py:obj:`~.CUDA_ERROR_INVALID_DEVICE` if `srcDevice` or
    `dstDevice` are not valid or if they represent the same device.

    Returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if `attrib` is not valid
    or if `value` is a null pointer.

    Parameters
    ----------
    attrib : :py:obj:`~.CUdevice_P2PAttribute`
        The requested attribute of the link between `srcDevice` and
        `dstDevice`.
    srcDevice : :py:obj:`~.CUdevice`
        The source device of the target link.
    dstDevice : :py:obj:`~.CUdevice`
        The destination device of the target link.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    value : int
        Returned value of the requested attribute

    See Also
    --------
    :py:obj:`~.cuCtxEnablePeerAccess`, :py:obj:`~.cuCtxDisablePeerAccess`, :py:obj:`~.cuDeviceCanAccessPeer`, :py:obj:`~.cuDeviceGetP2PAtomicCapabilities`, :py:obj:`~.cudaDeviceGetP2PAttribute`
    """
    cdef cydriver.CUdevice cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdevice,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdevice(dstDevice))
    cydstDevice = <cydriver.CUdevice>pdstDevice
    cdef cydriver.CUdevice cysrcDevice
    if srcDevice is None:
        psrcDevice = 0
    elif isinstance(srcDevice, (CUdevice,)):
        psrcDevice = int(srcDevice)
    else:
        psrcDevice = int(CUdevice(srcDevice))
    cysrcDevice = <cydriver.CUdevice>psrcDevice
    cdef int value = 0
    cdef cydriver.CUdevice_P2PAttribute cyattrib = attrib.value
    with nogil:
        err = cydriver.cuDeviceGetP2PAttribute(&value, cyattrib, cysrcDevice, cydstDevice)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], value)
{{endif}}

{{if 'cuDeviceGetP2PAtomicCapabilities' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetP2PAtomicCapabilities(operations : Optional[tuple[CUatomicOperation] | list[CUatomicOperation]], unsigned int count, srcDevice, dstDevice):
    """ Queries details about atomic operations supported between two devices.

    Returns in `*capabilities` the details about requested atomic
    `*operations` over the the link between `srcDevice` and `dstDevice`.
    The allocated size of `*operations` and `*capabilities` must be
    `count`.

    For each :py:obj:`~.CUatomicOperation` in `*operations`, the
    corresponding result in `*capabilities` will be a bitmask indicating
    which of :py:obj:`~.CUatomicOperationCapability` the link supports
    natively.

    Returns :py:obj:`~.CUDA_ERROR_INVALID_DEVICE` if `srcDevice` or
    `dstDevice` are not valid or if they represent the same device.

    Returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if `*capabilities` or
    `*operations` is NULL, if `count` is 0, or if any of `*operations` is
    not valid.

    Parameters
    ----------
    operations : list[:py:obj:`~.CUatomicOperation`]
        Requested operations
    count : unsigned int
        Count of requested operations and size of capabilities
    srcDevice : :py:obj:`~.CUdevice`
        The source device of the target link
    dstDevice : :py:obj:`~.CUdevice`
        The destination device of the target link

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    capabilities : list[unsigned int]
        Returned capability details of each requested operation

    See Also
    --------
    :py:obj:`~.cuDeviceGetP2PAttribute`, :py:obj:`~.cudaDeviceGetP2PAttribute`, :py:obj:`~.cudaDeviceGetP2PAtomicCapabilities`
    """
    cdef cydriver.CUdevice cydstDevice
    if dstDevice is None:
        pdstDevice = 0
    elif isinstance(dstDevice, (CUdevice,)):
        pdstDevice = int(dstDevice)
    else:
        pdstDevice = int(CUdevice(dstDevice))
    cydstDevice = <cydriver.CUdevice>pdstDevice
    cdef cydriver.CUdevice cysrcDevice
    if srcDevice is None:
        psrcDevice = 0
    elif isinstance(srcDevice, (CUdevice,)):
        psrcDevice = int(srcDevice)
    else:
        psrcDevice = int(CUdevice(srcDevice))
    cysrcDevice = <cydriver.CUdevice>psrcDevice
    operations = [] if operations is None else operations
    if not all(isinstance(_x, (CUatomicOperation)) for _x in operations):
        raise TypeError("Argument 'operations' is not instance of type (expected tuple[cydriver.CUatomicOperation] or list[cydriver.CUatomicOperation]")
    cdef unsigned int* cycapabilities = NULL
    pycapabilities = []
    if count != 0:
        cycapabilities = <unsigned int*>calloc(count, sizeof(unsigned int))
        if cycapabilities is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(count) + 'x' + str(sizeof(unsigned int)))
    cdef vector[cydriver.CUatomicOperation] cyoperations = [pyoperations.value for pyoperations in (operations)]
    if count > len(operations): raise RuntimeError("List is too small: " + str(len(operations)) + " < " + str(count))
    with nogil:
        err = cydriver.cuDeviceGetP2PAtomicCapabilities(cycapabilities, cyoperations.data(), count, cysrcDevice, cydstDevice)
    if CUresult(err) == CUresult(0):
        pycapabilities = [<unsigned int>cycapabilities[idx] for idx in range(count)]
    if cycapabilities is not NULL:
        free(cycapabilities)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pycapabilities)
{{endif}}

{{if 'cuGraphicsUnregisterResource' in found_functions}}

@cython.embedsignature(True)
def cuGraphicsUnregisterResource(resource):
    """ Unregisters a graphics resource for access by CUDA.

    Unregisters the graphics resource `resource` so it is not accessible by
    CUDA unless registered again.

    If `resource` is invalid then :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is
    returned.

    Parameters
    ----------
    resource : :py:obj:`~.CUgraphicsResource`
        Resource to unregister

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`

    See Also
    --------
    :py:obj:`~.cuGraphicsD3D9RegisterResource`, :py:obj:`~.cuGraphicsD3D10RegisterResource`, :py:obj:`~.cuGraphicsD3D11RegisterResource`, :py:obj:`~.cuGraphicsGLRegisterBuffer`, :py:obj:`~.cuGraphicsGLRegisterImage`, :py:obj:`~.cudaGraphicsUnregisterResource`
    """
    cdef cydriver.CUgraphicsResource cyresource
    if resource is None:
        presource = 0
    elif isinstance(resource, (CUgraphicsResource,)):
        presource = int(resource)
    else:
        presource = int(CUgraphicsResource(resource))
    cyresource = <cydriver.CUgraphicsResource><void_ptr>presource
    with nogil:
        err = cydriver.cuGraphicsUnregisterResource(cyresource)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphicsSubResourceGetMappedArray' in found_functions}}

@cython.embedsignature(True)
def cuGraphicsSubResourceGetMappedArray(resource, unsigned int arrayIndex, unsigned int mipLevel):
    """ Get an array through which to access a subresource of a mapped graphics resource.

    Returns in `*pArray` an array through which the subresource of the
    mapped graphics resource `resource` which corresponds to array index
    `arrayIndex` and mipmap level `mipLevel` may be accessed. The value set
    in `*pArray` may change every time that `resource` is mapped.

    If `resource` is not a texture then it cannot be accessed via an array
    and :py:obj:`~.CUDA_ERROR_NOT_MAPPED_AS_ARRAY` is returned. If
    `arrayIndex` is not a valid array index for `resource` then
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned. If `mipLevel` is not
    a valid mipmap level for `resource` then
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned. If `resource` is not
    mapped then :py:obj:`~.CUDA_ERROR_NOT_MAPPED` is returned.

    Parameters
    ----------
    resource : :py:obj:`~.CUgraphicsResource`
        Mapped resource to access
    arrayIndex : unsigned int
        Array index for array textures or cubemap face index as defined by
        :py:obj:`~.CUarray_cubemap_face` for cubemap textures for the
        subresource to access
    mipLevel : unsigned int
        Mipmap level for the subresource to access

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_MAPPED`, :py:obj:`~.CUDA_ERROR_NOT_MAPPED_AS_ARRAY`
    pArray : :py:obj:`~.CUarray`
        Returned array through which a subresource of `resource` may be
        accessed

    See Also
    --------
    :py:obj:`~.cuGraphicsResourceGetMappedPointer`, :py:obj:`~.cudaGraphicsSubResourceGetMappedArray`
    """
    cdef cydriver.CUgraphicsResource cyresource
    if resource is None:
        presource = 0
    elif isinstance(resource, (CUgraphicsResource,)):
        presource = int(resource)
    else:
        presource = int(CUgraphicsResource(resource))
    cyresource = <cydriver.CUgraphicsResource><void_ptr>presource
    cdef CUarray pArray = CUarray()
    with nogil:
        err = cydriver.cuGraphicsSubResourceGetMappedArray(<cydriver.CUarray*>pArray._pvt_ptr, cyresource, arrayIndex, mipLevel)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pArray)
{{endif}}

{{if 'cuGraphicsResourceGetMappedMipmappedArray' in found_functions}}

@cython.embedsignature(True)
def cuGraphicsResourceGetMappedMipmappedArray(resource):
    """ Get a mipmapped array through which to access a mapped graphics resource.

    Returns in `*pMipmappedArray` a mipmapped array through which the
    mapped graphics resource `resource`. The value set in
    `*pMipmappedArray` may change every time that `resource` is mapped.

    If `resource` is not a texture then it cannot be accessed via a
    mipmapped array and :py:obj:`~.CUDA_ERROR_NOT_MAPPED_AS_ARRAY` is
    returned. If `resource` is not mapped then
    :py:obj:`~.CUDA_ERROR_NOT_MAPPED` is returned.

    Parameters
    ----------
    resource : :py:obj:`~.CUgraphicsResource`
        Mapped resource to access

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_MAPPED`, :py:obj:`~.CUDA_ERROR_NOT_MAPPED_AS_ARRAY`
    pMipmappedArray : :py:obj:`~.CUmipmappedArray`
        Returned mipmapped array through which `resource` may be accessed

    See Also
    --------
    :py:obj:`~.cuGraphicsResourceGetMappedPointer`, :py:obj:`~.cudaGraphicsResourceGetMappedMipmappedArray`
    """
    cdef cydriver.CUgraphicsResource cyresource
    if resource is None:
        presource = 0
    elif isinstance(resource, (CUgraphicsResource,)):
        presource = int(resource)
    else:
        presource = int(CUgraphicsResource(resource))
    cyresource = <cydriver.CUgraphicsResource><void_ptr>presource
    cdef CUmipmappedArray pMipmappedArray = CUmipmappedArray()
    with nogil:
        err = cydriver.cuGraphicsResourceGetMappedMipmappedArray(<cydriver.CUmipmappedArray*>pMipmappedArray._pvt_ptr, cyresource)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pMipmappedArray)
{{endif}}

{{if 'cuGraphicsResourceGetMappedPointer_v2' in found_functions}}

@cython.embedsignature(True)
def cuGraphicsResourceGetMappedPointer(resource):
    """ Get a device pointer through which to access a mapped graphics resource.

    Returns in `*pDevPtr` a pointer through which the mapped graphics
    resource `resource` may be accessed. Returns in `pSize` the size of the
    memory in bytes which may be accessed from that pointer. The value set
    in `pPointer` may change every time that `resource` is mapped.

    If `resource` is not a buffer then it cannot be accessed via a pointer
    and :py:obj:`~.CUDA_ERROR_NOT_MAPPED_AS_POINTER` is returned. If
    `resource` is not mapped then :py:obj:`~.CUDA_ERROR_NOT_MAPPED` is
    returned.

    Parameters
    ----------
    resource : :py:obj:`~.CUgraphicsResource`
        None

    Returns
    -------
    CUresult

    pDevPtr : :py:obj:`~.CUdeviceptr`
        None
    pSize : int
        None
    """
    cdef cydriver.CUgraphicsResource cyresource
    if resource is None:
        presource = 0
    elif isinstance(resource, (CUgraphicsResource,)):
        presource = int(resource)
    else:
        presource = int(CUgraphicsResource(resource))
    cyresource = <cydriver.CUgraphicsResource><void_ptr>presource
    cdef CUdeviceptr pDevPtr = CUdeviceptr()
    cdef size_t pSize = 0
    with nogil:
        err = cydriver.cuGraphicsResourceGetMappedPointer(<cydriver.CUdeviceptr*>pDevPtr._pvt_ptr, &pSize, cyresource)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], pDevPtr, pSize)
{{endif}}

{{if 'cuGraphicsResourceSetMapFlags_v2' in found_functions}}

@cython.embedsignature(True)
def cuGraphicsResourceSetMapFlags(resource, unsigned int flags):
    """ Set usage flags for mapping a graphics resource.

    Set `flags` for mapping the graphics resource `resource`.

    Changes to `flags` will take effect the next time `resource` is mapped.
    The `flags` argument may be any of the following:

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE`: Specifies no hints
      about how this resource will be used. It is therefore assumed that
      this resource will be read from and written to by CUDA kernels. This
      is the default value.

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_READONLY`: Specifies that
      CUDA kernels which access this resource will not write to this
      resource.

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITEDISCARD`: Specifies
      that CUDA kernels which access this resource will not read from this
      resource and will write over the entire contents of the resource, so
      none of the data previously stored in the resource will be preserved.

    If `resource` is presently mapped for access by CUDA then
    :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED` is returned. If `flags` is not
    one of the above values then :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is
    returned.

    Parameters
    ----------
    resource : :py:obj:`~.CUgraphicsResource`
        Registered resource to set flags for
    flags : unsigned int
        Parameters for resource mapping

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`

    See Also
    --------
    :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cudaGraphicsResourceSetMapFlags`
    """
    cdef cydriver.CUgraphicsResource cyresource
    if resource is None:
        presource = 0
    elif isinstance(resource, (CUgraphicsResource,)):
        presource = int(resource)
    else:
        presource = int(CUgraphicsResource(resource))
    cyresource = <cydriver.CUgraphicsResource><void_ptr>presource
    with nogil:
        err = cydriver.cuGraphicsResourceSetMapFlags(cyresource, flags)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphicsMapResources' in found_functions}}

@cython.embedsignature(True)
def cuGraphicsMapResources(unsigned int count, resources, hStream):
    """ Map graphics resources for access by CUDA.

    Maps the `count` graphics resources in `resources` for access by CUDA.

    The resources in `resources` may be accessed by CUDA until they are
    unmapped. The graphics API from which `resources` were registered
    should not access any resources while they are mapped by CUDA. If an
    application does so, the results are undefined.

    This function provides the synchronization guarantee that any graphics
    calls issued before :py:obj:`~.cuGraphicsMapResources()` will complete
    before any subsequent CUDA work issued in `stream` begins.

    If `resources` includes any duplicate entries then
    :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is returned. If any of
    `resources` are presently mapped for access by CUDA then
    :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED` is returned.

    Parameters
    ----------
    count : unsigned int
        Number of resources to map
    resources : :py:obj:`~.CUgraphicsResource`
        Resources to map for CUDA usage
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream with which to synchronize

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_UNKNOWN`

    See Also
    --------
    :py:obj:`~.cuGraphicsResourceGetMappedPointer`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cudaGraphicsMapResources`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUgraphicsResource *cyresources
    if resources is None:
        cyresources = <cydriver.CUgraphicsResource*><void_ptr>NULL
    elif isinstance(resources, (CUgraphicsResource,)):
        presources = resources.getPtr()
        cyresources = <cydriver.CUgraphicsResource*><void_ptr>presources
    elif isinstance(resources, (int)):
        cyresources = <cydriver.CUgraphicsResource*><void_ptr>resources
    else:
        raise TypeError("Argument 'resources' is not instance of type (expected <class 'int, driver.CUgraphicsResource'>, found " + str(type(resources)))
    with nogil:
        err = cydriver.cuGraphicsMapResources(count, cyresources, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGraphicsUnmapResources' in found_functions}}

@cython.embedsignature(True)
def cuGraphicsUnmapResources(unsigned int count, resources, hStream):
    """ Unmap graphics resources.

    Unmaps the `count` graphics resources in `resources`.

    Once unmapped, the resources in `resources` may not be accessed by CUDA
    until they are mapped again.

    This function provides the synchronization guarantee that any CUDA work
    issued in `stream` before :py:obj:`~.cuGraphicsUnmapResources()` will
    complete before any subsequently issued graphics work begins.

    If `resources` includes any duplicate entries then
    :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is returned. If any of
    `resources` are not presently mapped for access by CUDA then
    :py:obj:`~.CUDA_ERROR_NOT_MAPPED` is returned.

    Parameters
    ----------
    count : unsigned int
        Number of resources to unmap
    resources : :py:obj:`~.CUgraphicsResource`
        Resources to unmap
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream with which to synchronize

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_MAPPED`, :py:obj:`~.CUDA_ERROR_UNKNOWN`

    See Also
    --------
    :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cudaGraphicsUnmapResources`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef cydriver.CUgraphicsResource *cyresources
    if resources is None:
        cyresources = <cydriver.CUgraphicsResource*><void_ptr>NULL
    elif isinstance(resources, (CUgraphicsResource,)):
        presources = resources.getPtr()
        cyresources = <cydriver.CUgraphicsResource*><void_ptr>presources
    elif isinstance(resources, (int)):
        cyresources = <cydriver.CUgraphicsResource*><void_ptr>resources
    else:
        raise TypeError("Argument 'resources' is not instance of type (expected <class 'int, driver.CUgraphicsResource'>, found " + str(type(resources)))
    with nogil:
        err = cydriver.cuGraphicsUnmapResources(count, cyresources, cyhStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGetProcAddress_v2' in found_functions}}

@cython.embedsignature(True)
def cuGetProcAddress(char* symbol, int cudaVersion, flags):
    """ Returns the requested driver API function pointer.

    Returns in `**pfn` the address of the CUDA driver function for the
    requested CUDA version and flags.

    The CUDA version is specified as (1000 * major + 10 * minor), so CUDA
    11.2 should be specified as 11020. For a requested driver symbol, if
    the specified CUDA version is greater than or equal to the CUDA version
    in which the driver symbol was introduced, this API will return the
    function pointer to the corresponding versioned function. If the
    specified CUDA version is greater than the driver version, the API will
    return :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

    The pointer returned by the API should be cast to a function pointer
    matching the requested driver function's definition in the API header
    file. The function pointer typedef can be picked up from the
    corresponding typedefs header file. For example, cudaTypedefs.h
    consists of function pointer typedefs for driver APIs defined in
    :py:obj:`~.cuda.h`.

    The API will return :py:obj:`~.CUDA_SUCCESS` and set the returned `pfn`
    to NULL if the requested driver function is not supported on the
    platform, no ABI compatible driver function exists for the specified
    `cudaVersion` or if the driver symbol is invalid.

    It will also set the optional `symbolStatus` to one of the values in
    :py:obj:`~.CUdriverProcAddressQueryResult` with the following meanings:

    - :py:obj:`~.CU_GET_PROC_ADDRESS_SUCCESS` - The requested symbol was
      succesfully found based on input arguments and `pfn` is valid

    - :py:obj:`~.CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND` - The requested
      symbol was not found

    - :py:obj:`~.CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT` - The
      requested symbol was found but is not supported by cudaVersion
      specified

    The requested flags can be:

    - :py:obj:`~.CU_GET_PROC_ADDRESS_DEFAULT`: This is the default mode.
      This is equivalent to
      :py:obj:`~.CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM` if the code
      is compiled with --default-stream per-thread compilation flag or the
      macro CUDA_API_PER_THREAD_DEFAULT_STREAM is defined;
      :py:obj:`~.CU_GET_PROC_ADDRESS_LEGACY_STREAM` otherwise.

    - :py:obj:`~.CU_GET_PROC_ADDRESS_LEGACY_STREAM`: This will enable the
      search for all driver symbols that match the requested driver symbol
      name except the corresponding per-thread versions.

    - :py:obj:`~.CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM`: This will
      enable the search for all driver symbols that match the requested
      driver symbol name including the per-thread versions. If a per-thread
      version is not found, the API will return the legacy version of the
      driver function.

    Parameters
    ----------
    symbol : bytes
        The base name of the driver API function to look for. As an
        example, for the driver API :py:obj:`~.cuMemAlloc_v2`, `symbol`
        would be cuMemAlloc and `cudaVersion` would be the ABI compatible
        CUDA version for the _v2 variant.
    cudaVersion : int
        The CUDA version to look for the requested driver symbol
    flags : Any
        Flags to specify search options.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    pfn : Any
        Location to return the function pointer to the requested driver
        function
    symbolStatus : :py:obj:`~.CUdriverProcAddressQueryResult`
        Optional location to store the status of the search for `symbol`
        based on `cudaVersion`. See
        :py:obj:`~.CUdriverProcAddressQueryResult` for possible values.

    See Also
    --------
    :py:obj:`~.cudaGetDriverEntryPointByVersion`
    """
    cdef cydriver.cuuint64_t cyflags
    if flags is None:
        pflags = 0
    elif isinstance(flags, (cuuint64_t,)):
        pflags = int(flags)
    else:
        pflags = int(cuuint64_t(flags))
    cyflags = <cydriver.cuuint64_t><void_ptr>pflags
    cdef void_ptr pfn = 0
    cdef cydriver.CUdriverProcAddressQueryResult symbolStatus
    with nogil:
        err = cydriver.cuGetProcAddress(symbol, <void**>&pfn, cudaVersion, cyflags, &symbolStatus)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], pfn, CUdriverProcAddressQueryResult(symbolStatus))
{{endif}}

{{if 'cuCoredumpGetAttribute' in found_functions}}

@cython.embedsignature(True)
def cuCoredumpGetAttribute(attrib not None : CUcoredumpSettings):
    """ Allows caller to fetch a coredump attribute value for the current context.

    Returns in `*value` the requested value specified by `attrib`. It is up
    to the caller to ensure that the data type and size of `*value` matches
    the request.

    If the caller calls this function with `*value` equal to NULL, the size
    of the memory region (in bytes) expected for `attrib` will be placed in
    `size`.

    The supported attributes are:

    - :py:obj:`~.CU_COREDUMP_ENABLE_ON_EXCEPTION`: Bool where
      :py:obj:`~.true` means that GPU exceptions from this context will
      create a coredump at the location specified by
      :py:obj:`~.CU_COREDUMP_FILE`. The default value is :py:obj:`~.false`
      unless set to :py:obj:`~.true` globally or locally, or the
      CU_CTX_USER_COREDUMP_ENABLE flag was set during context creation.

    - :py:obj:`~.CU_COREDUMP_TRIGGER_HOST`: Bool where :py:obj:`~.true`
      means that the host CPU will also create a coredump. The default
      value is :py:obj:`~.true` unless set to :py:obj:`~.false` globally or
      or locally. This value is deprecated as of CUDA 12.5 - raise the
      :py:obj:`~.CU_COREDUMP_SKIP_ABORT` flag to disable host device
      abort() if needed.

    - :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT`: Bool where :py:obj:`~.true`
      means that any resulting coredumps will not have a dump of GPU memory
      or non-reloc ELF images. The default value is :py:obj:`~.false`
      unless set to :py:obj:`~.true` globally or locally. This attribute is
      deprecated as of CUDA 12.5, please use
      :py:obj:`~.CU_COREDUMP_GENERATION_FLAGS` instead.

    - :py:obj:`~.CU_COREDUMP_ENABLE_USER_TRIGGER`: Bool where
      :py:obj:`~.true` means that a coredump can be created by writing to
      the system pipe specified by :py:obj:`~.CU_COREDUMP_PIPE`. The
      default value is :py:obj:`~.false` unless set to :py:obj:`~.true`
      globally or locally.

    - :py:obj:`~.CU_COREDUMP_FILE`: String of up to 1023 characters that
      defines the location where any coredumps generated by this context
      will be written. The default value is
      :py:obj:`~.core`.cuda.HOSTNAME.PID where :py:obj:`~.HOSTNAME` is the
      host name of the machine running the CUDA applications and
      :py:obj:`~.PID` is the process ID of the CUDA application.

    - :py:obj:`~.CU_COREDUMP_PIPE`: String of up to 1023 characters that
      defines the name of the pipe that will be monitored if user-triggered
      coredumps are enabled. The default value is
      :py:obj:`~.corepipe`.cuda.HOSTNAME.PID where :py:obj:`~.HOSTNAME` is
      the host name of the machine running the CUDA application and
      :py:obj:`~.PID` is the process ID of the CUDA application.

    - :py:obj:`~.CU_COREDUMP_GENERATION_FLAGS`: An integer with values to
      allow granular control the data contained in a coredump specified as
      a bitwise OR combination of the following values:

      - :py:obj:`~.CU_COREDUMP_DEFAULT_FLAGS` - if set by itself, coredump
        generation returns to its default settings of including all memory
        regions that it is able to access

      - :py:obj:`~.CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES` - Coredump
        will not include the data from CUDA source modules that are not
        relocated at runtime.

      - :py:obj:`~.CU_COREDUMP_SKIP_GLOBAL_MEMORY` - Coredump will not
        include device-side global data that does not belong to any
        context.

      - :py:obj:`~.CU_COREDUMP_SKIP_SHARED_MEMORY` - Coredump will not
        include grid-scale shared memory for the warp that the dumped
        kernel belonged to.

      - :py:obj:`~.CU_COREDUMP_SKIP_LOCAL_MEMORY` - Coredump will not
        include local memory from the kernel.

      - :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT_FLAGS` - Enables all of the
        above options. Equiavlent to setting the
        :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT` attribute to :py:obj:`~.true`.

      - :py:obj:`~.CU_COREDUMP_SKIP_ABORT` - If set, GPU exceptions will
        not raise an abort() in the host CPU process. Same functional goal
        as :py:obj:`~.CU_COREDUMP_TRIGGER_HOST` but better reflects the
        default behavior.

    Parameters
    ----------
    attrib : :py:obj:`~.CUcoredumpSettings`
        The enum defining which value to fetch.
    size : int
        The size of the memory region `value` points to.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`
    value : Any
        void* containing the requested data.
    size : int
        The size of the memory region `value` points to.

    See Also
    --------
    :py:obj:`~.cuCoredumpGetAttributeGlobal`, :py:obj:`~.cuCoredumpSetAttribute`, :py:obj:`~.cuCoredumpSetAttributeGlobal`
    """
    cdef cydriver.CUcoredumpSettings cyattrib = attrib.value
    cdef _HelperCUcoredumpSettings cyvalue = _HelperCUcoredumpSettings(attrib, 0, is_getter=True)
    cdef void* cyvalue_ptr = <void*><void_ptr>cyvalue.cptr
    cdef size_t size = cyvalue.size()
    with nogil:
        err = cydriver.cuCoredumpGetAttribute(cyattrib, cyvalue_ptr, &size)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], cyvalue.pyObj())
{{endif}}

{{if 'cuCoredumpGetAttributeGlobal' in found_functions}}

@cython.embedsignature(True)
def cuCoredumpGetAttributeGlobal(attrib not None : CUcoredumpSettings):
    """ Allows caller to fetch a coredump attribute value for the entire application.

    Returns in `*value` the requested value specified by `attrib`. It is up
    to the caller to ensure that the data type and size of `*value` matches
    the request.

    If the caller calls this function with `*value` equal to NULL, the size
    of the memory region (in bytes) expected for `attrib` will be placed in
    `size`.

    The supported attributes are:

    - :py:obj:`~.CU_COREDUMP_ENABLE_ON_EXCEPTION`: Bool where
      :py:obj:`~.true` means that GPU exceptions from this context will
      create a coredump at the location specified by
      :py:obj:`~.CU_COREDUMP_FILE`. The default value is :py:obj:`~.false`.

    - :py:obj:`~.CU_COREDUMP_TRIGGER_HOST`: Bool where :py:obj:`~.true`
      means that the host CPU will also create a coredump. The default
      value is :py:obj:`~.true` unless set to :py:obj:`~.false` globally or
      or locally. This value is deprecated as of CUDA 12.5 - raise the
      :py:obj:`~.CU_COREDUMP_SKIP_ABORT` flag to disable host device
      abort() if needed.

    - :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT`: Bool where :py:obj:`~.true`
      means that any resulting coredumps will not have a dump of GPU memory
      or non-reloc ELF images. The default value is :py:obj:`~.false`. This
      attribute is deprecated as of CUDA 12.5, please use
      :py:obj:`~.CU_COREDUMP_GENERATION_FLAGS` instead.

    - :py:obj:`~.CU_COREDUMP_ENABLE_USER_TRIGGER`: Bool where
      :py:obj:`~.true` means that a coredump can be created by writing to
      the system pipe specified by :py:obj:`~.CU_COREDUMP_PIPE`. The
      default value is :py:obj:`~.false`.

    - :py:obj:`~.CU_COREDUMP_FILE`: String of up to 1023 characters that
      defines the location where any coredumps generated by this context
      will be written. The default value is
      :py:obj:`~.core`.cuda.HOSTNAME.PID where :py:obj:`~.HOSTNAME` is the
      host name of the machine running the CUDA applications and
      :py:obj:`~.PID` is the process ID of the CUDA application.

    - :py:obj:`~.CU_COREDUMP_PIPE`: String of up to 1023 characters that
      defines the name of the pipe that will be monitored if user-triggered
      coredumps are enabled. The default value is
      :py:obj:`~.corepipe`.cuda.HOSTNAME.PID where :py:obj:`~.HOSTNAME` is
      the host name of the machine running the CUDA application and
      :py:obj:`~.PID` is the process ID of the CUDA application.

    - :py:obj:`~.CU_COREDUMP_GENERATION_FLAGS`: An integer with values to
      allow granular control the data contained in a coredump specified as
      a bitwise OR combination of the following values:

      - :py:obj:`~.CU_COREDUMP_DEFAULT_FLAGS` - if set by itself, coredump
        generation returns to its default settings of including all memory
        regions that it is able to access

      - :py:obj:`~.CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES` - Coredump
        will not include the data from CUDA source modules that are not
        relocated at runtime.

      - :py:obj:`~.CU_COREDUMP_SKIP_GLOBAL_MEMORY` - Coredump will not
        include device-side global data that does not belong to any
        context.

      - :py:obj:`~.CU_COREDUMP_SKIP_SHARED_MEMORY` - Coredump will not
        include grid-scale shared memory for the warp that the dumped
        kernel belonged to.

      - :py:obj:`~.CU_COREDUMP_SKIP_LOCAL_MEMORY` - Coredump will not
        include local memory from the kernel.

      - :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT_FLAGS` - Enables all of the
        above options. Equiavlent to setting the
        :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT` attribute to :py:obj:`~.true`.

      - :py:obj:`~.CU_COREDUMP_SKIP_ABORT` - If set, GPU exceptions will
        not raise an abort() in the host CPU process. Same functional goal
        as :py:obj:`~.CU_COREDUMP_TRIGGER_HOST` but better reflects the
        default behavior.

    Parameters
    ----------
    attrib : :py:obj:`~.CUcoredumpSettings`
        The enum defining which value to fetch.
    size : int
        The size of the memory region `value` points to.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    value : Any
        void* containing the requested data.
    size : int
        The size of the memory region `value` points to.

    See Also
    --------
    :py:obj:`~.cuCoredumpGetAttribute`, :py:obj:`~.cuCoredumpSetAttribute`, :py:obj:`~.cuCoredumpSetAttributeGlobal`
    """
    cdef cydriver.CUcoredumpSettings cyattrib = attrib.value
    cdef _HelperCUcoredumpSettings cyvalue = _HelperCUcoredumpSettings(attrib, 0, is_getter=True)
    cdef void* cyvalue_ptr = <void*><void_ptr>cyvalue.cptr
    cdef size_t size = cyvalue.size()
    with nogil:
        err = cydriver.cuCoredumpGetAttributeGlobal(cyattrib, cyvalue_ptr, &size)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], cyvalue.pyObj())
{{endif}}

{{if 'cuCoredumpSetAttribute' in found_functions}}

@cython.embedsignature(True)
def cuCoredumpSetAttribute(attrib not None : CUcoredumpSettings, value):
    """ Allows caller to set a coredump attribute value for the current context.

    This function should be considered an alternate interface to the CUDA-
    GDB environment variables defined in this document:
    https://docs.nvidia.com/cuda/cuda-gdb/index.html#gpu-coredump

    An important design decision to note is that any coredump environment
    variable values set before CUDA initializes will take permanent
    precedence over any values set with this function. This decision was
    made to ensure no change in behavior for any users that may be
    currently using these variables to get coredumps.

    `*value` shall contain the requested value specified by `set`. It is up
    to the caller to ensure that the data type and size of `*value` matches
    the request.

    If the caller calls this function with `*value` equal to NULL, the size
    of the memory region (in bytes) expected for `set` will be placed in
    `size`.

    /note This function will return :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED` if
    the caller attempts to set :py:obj:`~.CU_COREDUMP_ENABLE_ON_EXCEPTION`
    on a GPU of with Compute Capability < 6.0.
    :py:obj:`~.cuCoredumpSetAttributeGlobal` works on those platforms as an
    alternative.

    /note :py:obj:`~.CU_COREDUMP_ENABLE_USER_TRIGGER` and
    :py:obj:`~.CU_COREDUMP_PIPE` cannot be set on a per-context basis.

    The supported attributes are:

    - :py:obj:`~.CU_COREDUMP_ENABLE_ON_EXCEPTION`: Bool where
      :py:obj:`~.true` means that GPU exceptions from this context will
      create a coredump at the location specified by
      :py:obj:`~.CU_COREDUMP_FILE`. The default value is :py:obj:`~.false`.

    - :py:obj:`~.CU_COREDUMP_TRIGGER_HOST`: Bool where :py:obj:`~.true`
      means that the host CPU will also create a coredump. The default
      value is :py:obj:`~.true` unless set to :py:obj:`~.false` globally or
      or locally. This value is deprecated as of CUDA 12.5 - raise the
      :py:obj:`~.CU_COREDUMP_SKIP_ABORT` flag to disable host device
      abort() if needed.

    - :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT`: Bool where :py:obj:`~.true`
      means that any resulting coredumps will not have a dump of GPU memory
      or non-reloc ELF images. The default value is :py:obj:`~.false`. This
      attribute is deprecated as of CUDA 12.5, please use
      :py:obj:`~.CU_COREDUMP_GENERATION_FLAGS` instead.

    - :py:obj:`~.CU_COREDUMP_FILE`: String of up to 1023 characters that
      defines the location where any coredumps generated by this context
      will be written. The default value is
      :py:obj:`~.core`.cuda.HOSTNAME.PID where :py:obj:`~.HOSTNAME` is the
      host name of the machine running the CUDA applications and
      :py:obj:`~.PID` is the process ID of the CUDA application.

    - :py:obj:`~.CU_COREDUMP_GENERATION_FLAGS`: An integer with values to
      allow granular control the data contained in a coredump specified as
      a bitwise OR combination of the following values:

      - :py:obj:`~.CU_COREDUMP_DEFAULT_FLAGS` - if set by itself, coredump
        generation returns to its default settings of including all memory
        regions that it is able to access

      - :py:obj:`~.CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES` - Coredump
        will not include the data from CUDA source modules that are not
        relocated at runtime.

      - :py:obj:`~.CU_COREDUMP_SKIP_GLOBAL_MEMORY` - Coredump will not
        include device-side global data that does not belong to any
        context.

      - :py:obj:`~.CU_COREDUMP_SKIP_SHARED_MEMORY` - Coredump will not
        include grid-scale shared memory for the warp that the dumped
        kernel belonged to.

      - :py:obj:`~.CU_COREDUMP_SKIP_LOCAL_MEMORY` - Coredump will not
        include local memory from the kernel.

      - :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT_FLAGS` - Enables all of the
        above options. Equiavlent to setting the
        :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT` attribute to :py:obj:`~.true`.

      - :py:obj:`~.CU_COREDUMP_SKIP_ABORT` - If set, GPU exceptions will
        not raise an abort() in the host CPU process. Same functional goal
        as :py:obj:`~.CU_COREDUMP_TRIGGER_HOST` but better reflects the
        default behavior.

    Parameters
    ----------
    attrib : :py:obj:`~.CUcoredumpSettings`
        The enum defining which value to set.
    value : Any
        void* containing the requested data.
    size : int
        The size of the memory region `value` points to.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    size : int
        The size of the memory region `value` points to.

    See Also
    --------
    :py:obj:`~.cuCoredumpGetAttributeGlobal`, :py:obj:`~.cuCoredumpGetAttribute`, :py:obj:`~.cuCoredumpSetAttributeGlobal`
    """
    cdef cydriver.CUcoredumpSettings cyattrib = attrib.value
    cdef _HelperCUcoredumpSettings cyvalue = _HelperCUcoredumpSettings(attrib, value, is_getter=False)
    cdef void* cyvalue_ptr = <void*><void_ptr>cyvalue.cptr
    cdef size_t size = cyvalue.size()
    with nogil:
        err = cydriver.cuCoredumpSetAttribute(cyattrib, cyvalue_ptr, &size)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCoredumpSetAttributeGlobal' in found_functions}}

@cython.embedsignature(True)
def cuCoredumpSetAttributeGlobal(attrib not None : CUcoredumpSettings, value):
    """ Allows caller to set a coredump attribute value globally.

    This function should be considered an alternate interface to the CUDA-
    GDB environment variables defined in this document:
    https://docs.nvidia.com/cuda/cuda-gdb/index.html#gpu-coredump

    An important design decision to note is that any coredump environment
    variable values set before CUDA initializes will take permanent
    precedence over any values set with this function. This decision was
    made to ensure no change in behavior for any users that may be
    currently using these variables to get coredumps.

    `*value` shall contain the requested value specified by `set`. It is up
    to the caller to ensure that the data type and size of `*value` matches
    the request.

    If the caller calls this function with `*value` equal to NULL, the size
    of the memory region (in bytes) expected for `set` will be placed in
    `size`.

    The supported attributes are:

    - :py:obj:`~.CU_COREDUMP_ENABLE_ON_EXCEPTION`: Bool where
      :py:obj:`~.true` means that GPU exceptions from this context will
      create a coredump at the location specified by
      :py:obj:`~.CU_COREDUMP_FILE`. The default value is :py:obj:`~.false`.

    - :py:obj:`~.CU_COREDUMP_TRIGGER_HOST`: Bool where :py:obj:`~.true`
      means that the host CPU will also create a coredump. The default
      value is :py:obj:`~.true` unless set to :py:obj:`~.false` globally or
      or locally. This value is deprecated as of CUDA 12.5 - raise the
      :py:obj:`~.CU_COREDUMP_SKIP_ABORT` flag to disable host device
      abort() if needed.

    - :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT`: Bool where :py:obj:`~.true`
      means that any resulting coredumps will not have a dump of GPU memory
      or non-reloc ELF images. The default value is :py:obj:`~.false`. This
      attribute is deprecated as of CUDA 12.5, please use
      :py:obj:`~.CU_COREDUMP_GENERATION_FLAGS` instead.

    - :py:obj:`~.CU_COREDUMP_ENABLE_USER_TRIGGER`: Bool where
      :py:obj:`~.true` means that a coredump can be created by writing to
      the system pipe specified by :py:obj:`~.CU_COREDUMP_PIPE`. The
      default value is :py:obj:`~.false`.

    - :py:obj:`~.CU_COREDUMP_FILE`: String of up to 1023 characters that
      defines the location where any coredumps generated by this context
      will be written. The default value is
      :py:obj:`~.core`.cuda.HOSTNAME.PID where :py:obj:`~.HOSTNAME` is the
      host name of the machine running the CUDA applications and
      :py:obj:`~.PID` is the process ID of the CUDA application.

    - :py:obj:`~.CU_COREDUMP_PIPE`: String of up to 1023 characters that
      defines the name of the pipe that will be monitored if user-triggered
      coredumps are enabled. This value may not be changed after
      :py:obj:`~.CU_COREDUMP_ENABLE_USER_TRIGGER` is set to
      :py:obj:`~.true`. The default value is
      :py:obj:`~.corepipe`.cuda.HOSTNAME.PID where :py:obj:`~.HOSTNAME` is
      the host name of the machine running the CUDA application and
      :py:obj:`~.PID` is the process ID of the CUDA application.

    - :py:obj:`~.CU_COREDUMP_GENERATION_FLAGS`: An integer with values to
      allow granular control the data contained in a coredump specified as
      a bitwise OR combination of the following values:

      - :py:obj:`~.CU_COREDUMP_DEFAULT_FLAGS` - if set by itself, coredump
        generation returns to its default settings of including all memory
        regions that it is able to access

      - :py:obj:`~.CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES` - Coredump
        will not include the data from CUDA source modules that are not
        relocated at runtime.

      - :py:obj:`~.CU_COREDUMP_SKIP_GLOBAL_MEMORY` - Coredump will not
        include device-side global data that does not belong to any
        context.

      - :py:obj:`~.CU_COREDUMP_SKIP_SHARED_MEMORY` - Coredump will not
        include grid-scale shared memory for the warp that the dumped
        kernel belonged to.

      - :py:obj:`~.CU_COREDUMP_SKIP_LOCAL_MEMORY` - Coredump will not
        include local memory from the kernel.

      - :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT_FLAGS` - Enables all of the
        above options. Equiavlent to setting the
        :py:obj:`~.CU_COREDUMP_LIGHTWEIGHT` attribute to :py:obj:`~.true`.

      - :py:obj:`~.CU_COREDUMP_SKIP_ABORT` - If set, GPU exceptions will
        not raise an abort() in the host CPU process. Same functional goal
        as :py:obj:`~.CU_COREDUMP_TRIGGER_HOST` but better reflects the
        default behavior.

    Parameters
    ----------
    attrib : :py:obj:`~.CUcoredumpSettings`
        The enum defining which value to set.
    value : Any
        void* containing the requested data.
    size : int
        The size of the memory region `value` points to.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`
    size : int
        The size of the memory region `value` points to.

    See Also
    --------
    :py:obj:`~.cuCoredumpGetAttribute`, :py:obj:`~.cuCoredumpGetAttributeGlobal`, :py:obj:`~.cuCoredumpSetAttribute`
    """
    cdef cydriver.CUcoredumpSettings cyattrib = attrib.value
    cdef _HelperCUcoredumpSettings cyvalue = _HelperCUcoredumpSettings(attrib, value, is_getter=False)
    cdef void* cyvalue_ptr = <void*><void_ptr>cyvalue.cptr
    cdef size_t size = cyvalue.size()
    with nogil:
        err = cydriver.cuCoredumpSetAttributeGlobal(cyattrib, cyvalue_ptr, &size)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGetExportTable' in found_functions}}

@cython.embedsignature(True)
def cuGetExportTable(pExportTableId : Optional[CUuuid]):
    """ 

    Parameters
    ----------
    pExportTableId : :py:obj:`~.CUuuid`
        None

    Returns
    -------
    CUresult

    ppExportTable : Any
        None
    """
    cdef void_ptr ppExportTable = 0
    cdef cydriver.CUuuid* cypExportTableId_ptr = pExportTableId._pvt_ptr if pExportTableId is not None else NULL
    with nogil:
        err = cydriver.cuGetExportTable(<const void**>&ppExportTable, cypExportTableId_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], ppExportTable)
{{endif}}

{{if 'cuGreenCtxCreate' in found_functions}}

@cython.embedsignature(True)
def cuGreenCtxCreate(desc, dev, unsigned int flags):
    """ Creates a green context with a specified set of resources.

    This API creates a green context with the resources specified in the
    descriptor `desc` and returns it in the handle represented by `phCtx`.
    This API will retain the primary context on device `dev`, which will is
    released when the green context is destroyed. It is advised to have the
    primary context active before calling this API to avoid the heavy cost
    of triggering primary context initialization and deinitialization
    multiple times.

    The API does not set the green context current. In order to set it
    current, you need to explicitly set it current by first converting the
    green context to a CUcontext using :py:obj:`~.cuCtxFromGreenCtx` and
    subsequently calling :py:obj:`~.cuCtxSetCurrent` /
    :py:obj:`~.cuCtxPushCurrent`. It should be noted that a green context
    can be current to only one thread at a time. There is no internal
    synchronization to make API calls accessing the same green context from
    multiple threads work.

    Note: The API is not supported on 32-bit platforms.

    The supported flags are:

    - `CU_GREEN_CTX_DEFAULT_STREAM` : Creates a default stream to use
      inside the green context. Required.

    Parameters
    ----------
    desc : :py:obj:`~.CUdevResourceDesc`
        Descriptor generated via :py:obj:`~.cuDevResourceGenerateDesc`
        which contains the set of resources to be used
    dev : :py:obj:`~.CUdevice`
        Device on which to create the green context.
    flags : unsigned int
        One of the supported green context creation flags.
        `CU_GREEN_CTX_DEFAULT_STREAM` is required.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    phCtx : :py:obj:`~.CUgreenCtx`
        Pointer for the output handle to the green context

    See Also
    --------
    :py:obj:`~.cuGreenCtxDestroy`, :py:obj:`~.cuCtxFromGreenCtx`, :py:obj:`~.cuCtxSetCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuDevResourceGenerateDesc`, :py:obj:`~.cuDevicePrimaryCtxRetain`, :py:obj:`~.cuCtxCreate`
    """
    cdef cydriver.CUdevice cydev
    if dev is None:
        pdev = 0
    elif isinstance(dev, (CUdevice,)):
        pdev = int(dev)
    else:
        pdev = int(CUdevice(dev))
    cydev = <cydriver.CUdevice>pdev
    cdef cydriver.CUdevResourceDesc cydesc
    if desc is None:
        pdesc = 0
    elif isinstance(desc, (CUdevResourceDesc,)):
        pdesc = int(desc)
    else:
        pdesc = int(CUdevResourceDesc(desc))
    cydesc = <cydriver.CUdevResourceDesc><void_ptr>pdesc
    cdef CUgreenCtx phCtx = CUgreenCtx()
    with nogil:
        err = cydriver.cuGreenCtxCreate(<cydriver.CUgreenCtx*>phCtx._pvt_ptr, cydesc, cydev, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phCtx)
{{endif}}

{{if 'cuGreenCtxDestroy' in found_functions}}

@cython.embedsignature(True)
def cuGreenCtxDestroy(hCtx):
    """ Destroys a green context.

    Destroys the green context, releasing the primary context of the device
    that this green context was created for. Any resources provisioned for
    this green context (that were initially available via the resource
    descriptor) are released as well. The API does not destroy streams
    created via :py:obj:`~.cuGreenCtxStreamCreate`,
    :py:obj:`~.cuStreamCreate`, or :py:obj:`~.cuStreamCreateWithPriority`.
    Once the green context is destroyed, any subsequent API calls involving
    these streams (including :py:obj:`~.cuStreamDestroy`) will return
    :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`. Users must explicitly
    destroy all such streams before invoking :py:obj:`~.cuGreenCtxDestroy`.
    Failure to do so will result in a memory leak.

    Parameters
    ----------
    hCtx : :py:obj:`~.CUgreenCtx`
        Green context to be destroyed

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`

    See Also
    --------
    :py:obj:`~.cuGreenCtxCreate`, :py:obj:`~.cuCtxDestroy`
    """
    cdef cydriver.CUgreenCtx cyhCtx
    if hCtx is None:
        phCtx = 0
    elif isinstance(hCtx, (CUgreenCtx,)):
        phCtx = int(hCtx)
    else:
        phCtx = int(CUgreenCtx(hCtx))
    cyhCtx = <cydriver.CUgreenCtx><void_ptr>phCtx
    with nogil:
        err = cydriver.cuGreenCtxDestroy(cyhCtx)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCtxFromGreenCtx' in found_functions}}

@cython.embedsignature(True)
def cuCtxFromGreenCtx(hCtx):
    """ Converts a green context into the primary context.

    The API converts a green context into the primary context returned in
    `pContext`. It is important to note that the converted context
    `pContext` is a normal primary context but with the resources of the
    specified green context `hCtx`. Once converted, it can then be used to
    set the context current with :py:obj:`~.cuCtxSetCurrent` or with any of
    the CUDA APIs that accept a CUcontext parameter.

    Users are expected to call this API before calling any CUDA APIs that
    accept a CUcontext. Failing to do so will result in the APIs returning
    :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`.

    Parameters
    ----------
    hCtx : :py:obj:`~.CUgreenCtx`
        Green context to convert

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pContext : :py:obj:`~.CUcontext`
        Returned primary context with green context resources

    See Also
    --------
    :py:obj:`~.cuGreenCtxCreate`
    """
    cdef cydriver.CUgreenCtx cyhCtx
    if hCtx is None:
        phCtx = 0
    elif isinstance(hCtx, (CUgreenCtx,)):
        phCtx = int(hCtx)
    else:
        phCtx = int(CUgreenCtx(hCtx))
    cyhCtx = <cydriver.CUgreenCtx><void_ptr>phCtx
    cdef CUcontext pContext = CUcontext()
    with nogil:
        err = cydriver.cuCtxFromGreenCtx(<cydriver.CUcontext*>pContext._pvt_ptr, cyhCtx)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pContext)
{{endif}}

{{if 'cuDeviceGetDevResource' in found_functions}}

@cython.embedsignature(True)
def cuDeviceGetDevResource(device, typename not None : CUdevResourceType):
    """ Get device resources.

    Get the `typename` resources available to the `device`. This may often
    be the starting point for further partitioning or configuring of
    resources.

    Note: The API is not supported on 32-bit platforms.

    Parameters
    ----------
    device : :py:obj:`~.CUdevice`
        Device to get resource for
    typename : :py:obj:`~.CUdevResourceType`
        Type of resource to retrieve

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_RESOURCE_TYPE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    resource : :py:obj:`~.CUdevResource`
        Output pointer to a :py:obj:`~.CUdevResource` structure

    See Also
    --------
    :py:obj:`~.cuDevResourceGenerateDesc`
    """
    cdef cydriver.CUdevice cydevice
    if device is None:
        pdevice = 0
    elif isinstance(device, (CUdevice,)):
        pdevice = int(device)
    else:
        pdevice = int(CUdevice(device))
    cydevice = <cydriver.CUdevice>pdevice
    cdef CUdevResource resource = CUdevResource()
    cdef cydriver.CUdevResourceType cytypename = typename.value
    with nogil:
        err = cydriver.cuDeviceGetDevResource(cydevice, <cydriver.CUdevResource*>resource._pvt_ptr, cytypename)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], resource)
{{endif}}

{{if 'cuCtxGetDevResource' in found_functions}}

@cython.embedsignature(True)
def cuCtxGetDevResource(hCtx, typename not None : CUdevResourceType):
    """ Get context resources.

    Get the `typename` resources available to the context represented by
    `hCtx`  Note: The API is not supported on 32-bit platforms.

    Parameters
    ----------
    hCtx : :py:obj:`~.CUcontext`
        Context to get resource for
    typename : :py:obj:`~.CUdevResourceType`
        Type of resource to retrieve

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_RESOURCE_TYPE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`
    resource : :py:obj:`~.CUdevResource`
        Output pointer to a :py:obj:`~.CUdevResource` structure

    See Also
    --------
    :py:obj:`~.cuDevResourceGenerateDesc`
    """
    cdef cydriver.CUcontext cyhCtx
    if hCtx is None:
        phCtx = 0
    elif isinstance(hCtx, (CUcontext,)):
        phCtx = int(hCtx)
    else:
        phCtx = int(CUcontext(hCtx))
    cyhCtx = <cydriver.CUcontext><void_ptr>phCtx
    cdef CUdevResource resource = CUdevResource()
    cdef cydriver.CUdevResourceType cytypename = typename.value
    with nogil:
        err = cydriver.cuCtxGetDevResource(cyhCtx, <cydriver.CUdevResource*>resource._pvt_ptr, cytypename)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], resource)
{{endif}}

{{if 'cuGreenCtxGetDevResource' in found_functions}}

@cython.embedsignature(True)
def cuGreenCtxGetDevResource(hCtx, typename not None : CUdevResourceType):
    """ Get green context resources.

    Get the `typename` resources available to the green context represented
    by `hCtx`

    Parameters
    ----------
    hCtx : :py:obj:`~.CUgreenCtx`
        Green context to get resource for
    typename : :py:obj:`~.CUdevResourceType`
        Type of resource to retrieve

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_RESOURCE_TYPE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    resource : :py:obj:`~.CUdevResource`
        Output pointer to a :py:obj:`~.CUdevResource` structure

    See Also
    --------
    :py:obj:`~.cuDevResourceGenerateDesc`
    """
    cdef cydriver.CUgreenCtx cyhCtx
    if hCtx is None:
        phCtx = 0
    elif isinstance(hCtx, (CUgreenCtx,)):
        phCtx = int(hCtx)
    else:
        phCtx = int(CUgreenCtx(hCtx))
    cyhCtx = <cydriver.CUgreenCtx><void_ptr>phCtx
    cdef CUdevResource resource = CUdevResource()
    cdef cydriver.CUdevResourceType cytypename = typename.value
    with nogil:
        err = cydriver.cuGreenCtxGetDevResource(cyhCtx, <cydriver.CUdevResource*>resource._pvt_ptr, cytypename)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], resource)
{{endif}}

{{if 'cuDevSmResourceSplitByCount' in found_functions}}

@cython.embedsignature(True)
def cuDevSmResourceSplitByCount(unsigned int nbGroups, input_ : Optional[CUdevResource], unsigned int useFlags, unsigned int minCount):
    """ Splits `CU_DEV_RESOURCE_TYPE_SM` resources.

    Splits `CU_DEV_RESOURCE_TYPE_SM` resources into `nbGroups`, adhering to
    the minimum SM count specified in `minCount` and the usage flags in
    `useFlags`. If `result` is NULL, the API simulates a split and provides
    the amount of groups that would be created in `nbGroups`. Otherwise,
    `nbGroups` must point to the amount of elements in `result` and on
    return, the API will overwrite `nbGroups` with the amount actually
    created. The groups are written to the array in `result`. `nbGroups`
    can be less than the total amount if a smaller number of groups is
    needed.

    This API is used to spatially partition the input resource. The input
    resource needs to come from one of :py:obj:`~.cuDeviceGetDevResource`,
    :py:obj:`~.cuCtxGetDevResource`, or
    :py:obj:`~.cuGreenCtxGetDevResource`. A limitation of the API is that
    the output results cannot be split again without first creating a
    descriptor and a green context with that descriptor.

    When creating the groups, the API will take into account the
    performance and functional characteristics of the input resource, and
    guarantee a split that will create a disjoint set of symmetrical
    partitions. This may lead to fewer groups created than purely dividing
    the total SM count by the `minCount` due to cluster requirements or
    alignment and granularity requirements for the minCount. These
    requirements can be queried with :py:obj:`~.cuDeviceGetDevResource`,
    :py:obj:`~.cuCtxGetDevResource`, and
    :py:obj:`~.cuGreenCtxGetDevResource` for
    :py:obj:`~.CU_DEV_RESOURCE_TYPE_SM`, using the `minSmPartitionSize` and
    `smCoscheduledAlignment` fields to determine minimum partition size and
    alignment granularity, respectively.

    The `remainder` set does not have the same functional or performance
    guarantees as the groups in `result`. Its use should be carefully
    planned and future partitions of the `remainder` set are discouraged.

    The following flags are supported:

    - `CU_DEV_SM_RESOURCE_SPLIT_IGNORE_SM_COSCHEDULING` : Lower the minimum
      SM count and alignment, and treat each SM independent of its
      hierarchy. This allows more fine grained partitions but at the cost
      of advanced features (such as large clusters on compute capability
      9.0+).

    - `CU_DEV_SM_RESOURCE_SPLIT_MAX_POTENTIAL_CLUSTER_SIZE` : Compute
      Capability 9.0+ only. Attempt to create groups that may allow for
      maximally sized thread clusters. This can be queried post green
      context creation using
      :py:obj:`~.cuOccupancyMaxPotentialClusterSize`.

    A successful API call must either have:

    - A valid array of `result` pointers of size passed in `nbGroups`, with
      `input` of type `CU_DEV_RESOURCE_TYPE_SM`. Value of `minCount` must
      be between 0 and the SM count specified in `input`. `remaining` may
      be NULL.

    - NULL passed in for `result`, with a valid integer pointer in
      `nbGroups` and `input` of type `CU_DEV_RESOURCE_TYPE_SM`. Value of
      `minCount` must be between 0 and the SM count specified in `input`.
      `remaining` may be NULL. This queries the number of groups that would
      be created by the API.

    Note: The API is not supported on 32-bit platforms.

    Parameters
    ----------
    nbGroups : unsigned int
        This is a pointer, specifying the number of groups that would be or
        should be created as described below.
    input : :py:obj:`~.CUdevResource`
        Input SM resource to be split. Must be a valid
        `CU_DEV_RESOURCE_TYPE_SM` resource.
    useFlags : unsigned int
        Flags specifying how these partitions are used or which constraints
        to abide by when splitting the input. Zero is valid for default
        behavior.
    minCount : unsigned int
        Minimum number of SMs required

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_RESOURCE_TYPE`, :py:obj:`~.CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION`
    result : list[:py:obj:`~.CUdevResource`]
        Output array of `None` resources. Can be NULL to query the number
        of groups.
    nbGroups : unsigned int
        This is a pointer, specifying the number of groups that would be or
        should be created as described below.
    remaining : :py:obj:`~.CUdevResource`
        If the input resource cannot be cleanly split among `nbGroups`, the
        remaining is placed in here. Can be ommitted (NULL) if the user
        does not need the remaining set.

    See Also
    --------
    :py:obj:`~.cuGreenCtxGetDevResource`, :py:obj:`~.cuCtxGetDevResource`, :py:obj:`~.cuDeviceGetDevResource`
    """
    cdef cydriver.CUdevResource* cyresult = NULL
    pyresult = [CUdevResource() for idx in range(nbGroups)]
    if nbGroups != 0:
        cyresult = <cydriver.CUdevResource*>calloc(nbGroups, sizeof(cydriver.CUdevResource))
        if cyresult is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(nbGroups) + 'x' + str(sizeof(cydriver.CUdevResource)))
    cdef unsigned int cynbGroups = nbGroups
    cdef cydriver.CUdevResource* cyinput__ptr = input_._pvt_ptr if input_ is not None else NULL
    cdef CUdevResource remaining = CUdevResource()
    with nogil:
        err = cydriver.cuDevSmResourceSplitByCount(cyresult, &cynbGroups, cyinput__ptr, <cydriver.CUdevResource*>remaining._pvt_ptr, useFlags, minCount)
    if CUresult(err) == CUresult(0):
        for idx in range(nbGroups):
            string.memcpy((<CUdevResource>pyresult[idx])._pvt_ptr, &cyresult[idx], sizeof(cydriver.CUdevResource))
    if cyresult is not NULL:
        free(cyresult)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None, None)
    return (_dict_CUresult[err], pyresult, cynbGroups, remaining)
{{endif}}

{{if 'cuDevResourceGenerateDesc' in found_functions}}

@cython.embedsignature(True)
def cuDevResourceGenerateDesc(resources : Optional[tuple[CUdevResource] | list[CUdevResource]], unsigned int nbResources):
    """ Generate a resource descriptor.

    Generates a single resource descriptor with the set of resources
    specified in `resources`. The generated resource descriptor is
    necessary for the creation of green contexts via the
    :py:obj:`~.cuGreenCtxCreate` API. Resources of the same type can be
    passed in, provided they meet the requirements as noted below.

    A successful API call must have:

    - A valid output pointer for the `phDesc` descriptor as well as a valid
      array of `resources` pointers, with the array size passed in
      `nbResources`. If multiple resources are provided in `resources`, the
      device they came from must be the same, otherwise
      CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION is returned. If multiple
      resources are provided in `resources` and they are of type
      :py:obj:`~.CU_DEV_RESOURCE_TYPE_SM`, they must be outputs (whether
      `result` or `remaining`) from the same split API instance, otherwise
      CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION is returned.

    Note: The API is not supported on 32-bit platforms.

    Parameters
    ----------
    resources : list[:py:obj:`~.CUdevResource`]
        Array of resources to be included in the descriptor
    nbResources : unsigned int
        Number of resources passed in `resources`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_RESOURCE_TYPE`, :py:obj:`~.CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION`
    phDesc : :py:obj:`~.CUdevResourceDesc`
        Output descriptor

    See Also
    --------
    :py:obj:`~.cuDevSmResourceSplitByCount`
    """
    resources = [] if resources is None else resources
    if not all(isinstance(_x, (CUdevResource,)) for _x in resources):
        raise TypeError("Argument 'resources' is not instance of type (expected tuple[cydriver.CUdevResource,] or list[cydriver.CUdevResource,]")
    cdef CUdevResourceDesc phDesc = CUdevResourceDesc()
    cdef cydriver.CUdevResource* cyresources = NULL
    if len(resources) > 1:
        cyresources = <cydriver.CUdevResource*> calloc(len(resources), sizeof(cydriver.CUdevResource))
        if cyresources is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(resources)) + 'x' + str(sizeof(cydriver.CUdevResource)))
        for idx in range(len(resources)):
            string.memcpy(&cyresources[idx], (<CUdevResource>resources[idx])._pvt_ptr, sizeof(cydriver.CUdevResource))
    elif len(resources) == 1:
        cyresources = (<CUdevResource>resources[0])._pvt_ptr
    if nbResources > len(resources): raise RuntimeError("List is too small: " + str(len(resources)) + " < " + str(nbResources))
    with nogil:
        err = cydriver.cuDevResourceGenerateDesc(<cydriver.CUdevResourceDesc*>phDesc._pvt_ptr, cyresources, nbResources)
    if len(resources) > 1 and cyresources is not NULL:
        free(cyresources)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phDesc)
{{endif}}

{{if 'cuGreenCtxRecordEvent' in found_functions}}

@cython.embedsignature(True)
def cuGreenCtxRecordEvent(hCtx, hEvent):
    """ Records an event.

    Captures in `hEvent` all the activities of the green context of `hCtx`
    at the time of this call. `hEvent` and `hCtx` must be from the same
    primary context otherwise :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is
    returned. Calls such as :py:obj:`~.cuEventQuery()` or
    :py:obj:`~.cuGreenCtxWaitEvent()` will then examine or wait for
    completion of the work that was captured. Uses of `hCtx` after this
    call do not modify `hEvent`.

    Parameters
    ----------
    hCtx : :py:obj:`~.CUgreenCtx`
        Green context to record event for
    hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to record

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED`

    See Also
    --------
    :py:obj:`~.cuGreenCtxWaitEvent`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuCtxRecordEvent`, :py:obj:`~.cuCtxWaitEvent`

    Notes
    -----
    The API will return :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED` if the specified green context `hCtx` has a stream in the capture mode. In such a case, the call will invalidate all the conflicting captures.
    """
    cdef cydriver.CUevent cyhEvent
    if hEvent is None:
        phEvent = 0
    elif isinstance(hEvent, (CUevent,)):
        phEvent = int(hEvent)
    else:
        phEvent = int(CUevent(hEvent))
    cyhEvent = <cydriver.CUevent><void_ptr>phEvent
    cdef cydriver.CUgreenCtx cyhCtx
    if hCtx is None:
        phCtx = 0
    elif isinstance(hCtx, (CUgreenCtx,)):
        phCtx = int(hCtx)
    else:
        phCtx = int(CUgreenCtx(hCtx))
    cyhCtx = <cydriver.CUgreenCtx><void_ptr>phCtx
    with nogil:
        err = cydriver.cuGreenCtxRecordEvent(cyhCtx, cyhEvent)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuGreenCtxWaitEvent' in found_functions}}

@cython.embedsignature(True)
def cuGreenCtxWaitEvent(hCtx, hEvent):
    """ Make a green context wait on an event.

    Makes all future work submitted to green context `hCtx` wait for all
    work captured in `hEvent`. The synchronization will be performed on the
    device and will not block the calling CPU thread. See
    :py:obj:`~.cuGreenCtxRecordEvent()` or :py:obj:`~.cuEventRecord()`, for
    details on what is captured by an event.

    Parameters
    ----------
    hCtx : :py:obj:`~.CUgreenCtx`
        Green context to wait
    hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to wait on

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED`

    See Also
    --------
    :py:obj:`~.cuGreenCtxRecordEvent`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuCtxRecordEvent`, :py:obj:`~.cuCtxWaitEvent`

    Notes
    -----
    `hEvent` may be from a different context or device than `hCtx`.

    The API will return :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED` and invalidate the capture if the specified event `hEvent` is part of an ongoing capture sequence or if the specified green context `hCtx` has a stream in the capture mode.
    """
    cdef cydriver.CUevent cyhEvent
    if hEvent is None:
        phEvent = 0
    elif isinstance(hEvent, (CUevent,)):
        phEvent = int(hEvent)
    else:
        phEvent = int(CUevent(hEvent))
    cyhEvent = <cydriver.CUevent><void_ptr>phEvent
    cdef cydriver.CUgreenCtx cyhCtx
    if hCtx is None:
        phCtx = 0
    elif isinstance(hCtx, (CUgreenCtx,)):
        phCtx = int(hCtx)
    else:
        phCtx = int(CUgreenCtx(hCtx))
    cyhCtx = <cydriver.CUgreenCtx><void_ptr>phCtx
    with nogil:
        err = cydriver.cuGreenCtxWaitEvent(cyhCtx, cyhEvent)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuStreamGetGreenCtx' in found_functions}}

@cython.embedsignature(True)
def cuStreamGetGreenCtx(hStream):
    """ Query the green context associated with a stream.

    Returns the CUDA green context that the stream is associated with, or
    NULL if the stream is not associated with any green context.

    The stream handle `hStream` can refer to any of the following:

    - a stream created via any of the CUDA driver APIs such as
      :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamCreateWithPriority`
      and :py:obj:`~.cuGreenCtxStreamCreate`, or their runtime API
      equivalents such as :py:obj:`~.cudaStreamCreate`,
      :py:obj:`~.cudaStreamCreateWithFlags` and
      :py:obj:`~.cudaStreamCreateWithPriority`. If during stream creation
      the context that was active in the calling thread was obtained with
      cuCtxFromGreenCtx, that green context is returned in `phCtx`.
      Otherwise, `*phCtx` is set to NULL instead.

    - special stream such as the NULL stream or
      :py:obj:`~.CU_STREAM_LEGACY`. In that case if context that is active
      in the calling thread was obtained with cuCtxFromGreenCtx, that green
      context is returned. Otherwise, `*phCtx` is set to NULL instead.

    Passing an invalid handle will result in undefined behavior.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Handle to the stream to be queried

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`,
    phCtx : :py:obj:`~.CUgreenCtx`
        Returned green context associated with the stream

    See Also
    --------
    :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamCreateWithPriority`, :py:obj:`~.cuStreamGetCtx`, :py:obj:`~.cuGreenCtxStreamCreate`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cuStreamGetDevice`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithFlags`
    """
    cdef cydriver.CUstream cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (CUstream,)):
        phStream = int(hStream)
    else:
        phStream = int(CUstream(hStream))
    cyhStream = <cydriver.CUstream><void_ptr>phStream
    cdef CUgreenCtx phCtx = CUgreenCtx()
    with nogil:
        err = cydriver.cuStreamGetGreenCtx(cyhStream, <cydriver.CUgreenCtx*>phCtx._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phCtx)
{{endif}}

{{if 'cuGreenCtxStreamCreate' in found_functions}}

@cython.embedsignature(True)
def cuGreenCtxStreamCreate(greenCtx, unsigned int flags, int priority):
    """ Create a stream for use in the green context.

    Creates a stream for use in the specified green context `greenCtx` and
    returns a handle in `phStream`. The stream can be destroyed by calling
    :py:obj:`~.cuStreamDestroy()`. Note that the API ignores the context
    that is current to the calling thread and creates a stream in the
    specified green context `greenCtx`.

    The supported values for `flags` are:

    - :py:obj:`~.CU_STREAM_NON_BLOCKING`: This must be specified. It
      indicates that work running in the created stream may run
      concurrently with work in the default stream, and that the created
      stream should perform no implicit synchronization with the default
      stream.

    Specifying `priority` affects the scheduling priority of work in the
    stream. Priorities provide a hint to preferentially run work with
    higher priority when possible, but do not preempt already-running work
    or provide any other functional guarantee on execution order.
    `priority` follows a convention where lower numbers represent higher
    priorities. '0' represents default priority. The range of meaningful
    numerical priorities can be queried using
    :py:obj:`~.cuCtxGetStreamPriorityRange`. If the specified priority is
    outside the numerical range returned by
    :py:obj:`~.cuCtxGetStreamPriorityRange`, it will automatically be
    clamped to the lowest or the highest number in the range.

    Parameters
    ----------
    greenCtx : :py:obj:`~.CUgreenCtx`
        Green context for which to create the stream for
    flags : unsigned int
        Flags for stream creation. `CU_STREAM_NON_BLOCKING` must be
        specified.
    priority : int
        Stream priority. Lower numbers represent higher priorities. See
        :py:obj:`~.cuCtxGetStreamPriorityRange` for more information about
        meaningful stream priorities that can be passed.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    phStream : :py:obj:`~.CUstream`
        Returned newly created stream

    See Also
    --------
    :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuGreenCtxCreate` :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuCtxGetStreamPriorityRange`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cuStreamGetDevice`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamCreateWithPriority`

    Notes
    -----
    In the current implementation, only compute kernels launched in priority streams are affected by the stream's priority. Stream priorities have no effect on host-to-device and device-to-host memory operations.
    """
    cdef cydriver.CUgreenCtx cygreenCtx
    if greenCtx is None:
        pgreenCtx = 0
    elif isinstance(greenCtx, (CUgreenCtx,)):
        pgreenCtx = int(greenCtx)
    else:
        pgreenCtx = int(CUgreenCtx(greenCtx))
    cygreenCtx = <cydriver.CUgreenCtx><void_ptr>pgreenCtx
    cdef CUstream phStream = CUstream()
    with nogil:
        err = cydriver.cuGreenCtxStreamCreate(<cydriver.CUstream*>phStream._pvt_ptr, cygreenCtx, flags, priority)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phStream)
{{endif}}

{{if 'cuGreenCtxGetId' in found_functions}}

@cython.embedsignature(True)
def cuGreenCtxGetId(greenCtx):
    """ Returns the unique Id associated with the green context supplied.

    Returns in `greenCtxId` the unique Id which is associated with a given
    green context. The Id is unique for the life of the program for this
    instance of CUDA. If green context is supplied as NULL and the current
    context is set to a green context, the Id of the current green context
    is returned.

    Parameters
    ----------
    greenCtx : :py:obj:`~.CUgreenCtx`
        Green context for which to obtain the Id

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    greenCtxId : unsigned long long
        Pointer to store the Id of the green context

    See Also
    --------
    :py:obj:`~.cuGreenCtxCreate`, :py:obj:`~.cuGreenCtxDestroy`, :py:obj:`~.cuCtxGetId`
    """
    cdef cydriver.CUgreenCtx cygreenCtx
    if greenCtx is None:
        pgreenCtx = 0
    elif isinstance(greenCtx, (CUgreenCtx,)):
        pgreenCtx = int(greenCtx)
    else:
        pgreenCtx = int(CUgreenCtx(greenCtx))
    cygreenCtx = <cydriver.CUgreenCtx><void_ptr>pgreenCtx
    cdef unsigned long long greenCtxId = 0
    with nogil:
        err = cydriver.cuGreenCtxGetId(cygreenCtx, &greenCtxId)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], greenCtxId)
{{endif}}

{{if 'cuLogsRegisterCallback' in found_functions}}

ctypedef struct cuLogsCallbackData_st:
    cydriver.CUlogsCallback callback
    void *userData

ctypedef cuLogsCallbackData_st cuLogsCallbackData

@cython.show_performance_hints(False)
cdef void cuLogsCallbackWrapper(void *data, cydriver.CUlogLevel logLevel, char *message, size_t length) nogil:
    cdef cuLogsCallbackData *cbData = <cuLogsCallbackData *>data
    with gil:
        cbData.callback(cbData.userData, logLevel, message, length)

@cython.embedsignature(True)
def cuLogsRegisterCallback(callbackFunc, userData):
    """ Register a callback function to receive error log messages.

    Parameters
    ----------
    callbackFunc : :py:obj:`~.CUlogsCallback`
        The function to register as a callback
    userData : Any
        A generic pointer to user data. This is passed into the callback
        function.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    callback_out : :py:obj:`~.CUlogsCallbackHandle`
        Optional location to store the callback handle after it is
        registered
    """
    cdef cydriver.CUlogsCallback cycallbackFunc
    if callbackFunc is None:
        pcallbackFunc = 0
    elif isinstance(callbackFunc, (CUlogsCallback,)):
        pcallbackFunc = int(callbackFunc)
    else:
        pcallbackFunc = int(CUlogsCallback(callbackFunc))
    cycallbackFunc = <cydriver.CUlogsCallback><void_ptr>pcallbackFunc
    cyuserData = _HelperInputVoidPtr(userData)
    cdef void* cyuserData_ptr = <void*><void_ptr>cyuserData.cptr

    cdef cuLogsCallbackData *cbData = NULL
    cbData = <cuLogsCallbackData *>malloc(sizeof(cbData[0]))
    if cbData == NULL:
        return (CUresult.CUDA_ERROR_OUT_OF_MEMORY, None)
    cbData.callback = cycallbackFunc
    cbData.userData = cyuserData_ptr

    cdef CUlogsCallbackHandle callback_out = CUlogsCallbackHandle()
    with nogil:
        err = cydriver.cuLogsRegisterCallback(<cydriver.CUlogsCallback>cuLogsCallbackWrapper, <void *>cbData, <cydriver.CUlogsCallbackHandle*>callback_out._pvt_ptr)
    if err != cydriver.CUDA_SUCCESS:
        free(cbData)
    else:
        m_global._allocated[int(callback_out)] = cbData
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], callback_out)
{{endif}}

{{if 'cuLogsUnregisterCallback' in found_functions}}

@cython.embedsignature(True)
def cuLogsUnregisterCallback(callback):
    """ Unregister a log message callback.

    Parameters
    ----------
    callback : :py:obj:`~.CUlogsCallbackHandle`
        The callback instance to unregister from receiving log messages

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    """
    cdef cydriver.CUlogsCallbackHandle cycallback
    if callback is None:
        pcallback = 0
    elif isinstance(callback, (CUlogsCallbackHandle,)):
        pcallback = int(callback)
    else:
        pcallback = int(CUlogsCallbackHandle(callback))
    cycallback = <cydriver.CUlogsCallbackHandle><void_ptr>pcallback
    with nogil:
        err = cydriver.cuLogsUnregisterCallback(cycallback)
    if err == cydriver.CUDA_SUCCESS:
        free(m_global._allocated[pcallback])
        m_global._allocated.erase(<void_ptr>pcallback)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuLogsCurrent' in found_functions}}

@cython.embedsignature(True)
def cuLogsCurrent(unsigned int flags):
    """ Sets log iterator to point to the end of log buffer, where the next message would be written.

    Parameters
    ----------
    flags : unsigned int
        Reserved for future use, must be 0

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    iterator_out : :py:obj:`~.CUlogIterator`
        Location to store an iterator to the current tail of the logs
    """
    cdef CUlogIterator iterator_out = CUlogIterator()
    with nogil:
        err = cydriver.cuLogsCurrent(<cydriver.CUlogIterator*>iterator_out._pvt_ptr, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], iterator_out)
{{endif}}

{{if 'cuLogsDumpToFile' in found_functions}}

@cython.embedsignature(True)
def cuLogsDumpToFile(iterator : Optional[CUlogIterator], char* pathToFile, unsigned int flags):
    """ Dump accumulated driver logs into a file.

    Logs generated by the driver are stored in an internal buffer and can
    be copied out using this API. This API dumps all driver logs starting
    from `iterator` into `pathToFile` provided.

    Parameters
    ----------
    iterator : :py:obj:`~.CUlogIterator`
        Optional auto-advancing iterator specifying the starting log to
        read. NULL value dumps all logs.
    pathToFile : bytes
        Path to output file for dumping logs
    flags : unsigned int
        Reserved for future use, must be 0

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    iterator : :py:obj:`~.CUlogIterator`
        Optional auto-advancing iterator specifying the starting log to
        read. NULL value dumps all logs.

    Notes
    -----
    `iterator` is auto-advancing. Dumping logs will update the value of `iterator` to receive the next generated log.

    The driver reserves limited memory for storing logs. The oldest logs may be overwritten and become unrecoverable. An indication will appear in the destination outupt if the logs have been truncated. Call dump after each failed API to mitigate this risk.
    """
    cdef cydriver.CUlogIterator* cyiterator = NULL
    if iterator is not None:
        cyiterator = iterator._pvt_ptr
    with nogil:
        err = cydriver.cuLogsDumpToFile(cyiterator, pathToFile, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], iterator)
{{endif}}

{{if 'cuLogsDumpToMemory' in found_functions}}

@cython.embedsignature(True)
def cuLogsDumpToMemory(iterator : Optional[CUlogIterator], char* buffer, size_t size, unsigned int flags):
    """ Dump accumulated driver logs into a buffer.

    Logs generated by the driver are stored in an internal buffer and can
    be copied out using this API. This API dumps driver logs from
    `iterator` into `buffer` up to the size specified in `*size`. The
    driver will always null terminate the buffer but there will not be a
    null character between log entries, only a newline \n. The driver will
    then return the actual number of bytes written in `*size`, excluding
    the null terminator. If there are no messages to dump, `*size` will be
    set to 0 and the function will return :py:obj:`~.CUDA_SUCCESS`. If the
    provided `buffer` is not large enough to hold any messages, `*size`
    will be set to 0 and the function will return
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

    Parameters
    ----------
    iterator : :py:obj:`~.CUlogIterator`
        Optional auto-advancing iterator specifying the starting log to
        read. NULL value dumps all logs.
    buffer : bytes
        Pointer to dump logs
    size : int
        See description
    flags : unsigned int
        Reserved for future use, must be 0

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    iterator : :py:obj:`~.CUlogIterator`
        Optional auto-advancing iterator specifying the starting log to
        read. NULL value dumps all logs.
    size : int
        See description

    Notes
    -----
    `iterator` is auto-advancing. Dumping logs will update the value of `iterator` to receive the next generated log.

    The driver reserves limited memory for storing logs. The maximum size of the buffer is 25600 bytes. The oldest logs may be overwritten and become unrecoverable. An indication will appear in the destination outupt if the logs have been truncated. Call dump after each failed API to mitigate this risk.

    If the provided value in `*size` is not large enough to hold all buffered messages, a message will be added at the head of the buffer indicating this. The driver then computes the number of messages it is able to store in `buffer` and writes it out. The final message in `buffer` will always be the most recent log message as of when the API is called.
    """
    cdef cydriver.CUlogIterator* cyiterator = NULL
    if iterator is not None:
        cyiterator = iterator._pvt_ptr
    with nogil:
        err = cydriver.cuLogsDumpToMemory(cyiterator, buffer, &size, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], iterator, size)
{{endif}}

{{if 'cuCheckpointProcessGetRestoreThreadId' in found_functions}}

@cython.embedsignature(True)
def cuCheckpointProcessGetRestoreThreadId(int pid):
    """ Returns the restore thread ID for a CUDA process.

    Returns in `*tid` the thread ID of the CUDA restore thread for the
    process specified by `pid`.

    Parameters
    ----------
    pid : int
        The process ID of the CUDA process

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED` :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    tid : int
        Returned restore thread ID
    """
    cdef int tid = 0
    with nogil:
        err = cydriver.cuCheckpointProcessGetRestoreThreadId(pid, &tid)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], tid)
{{endif}}

{{if 'cuCheckpointProcessGetState' in found_functions}}

@cython.embedsignature(True)
def cuCheckpointProcessGetState(int pid):
    """ Returns the process state of a CUDA process.

    Returns in `*state` the current state of the CUDA process specified by
    `pid`.

    Parameters
    ----------
    pid : int
        The process ID of the CUDA process

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED` :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    state : :py:obj:`~.CUprocessState`
        Returned CUDA process state
    """
    cdef cydriver.CUprocessState state
    with nogil:
        err = cydriver.cuCheckpointProcessGetState(pid, &state)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], CUprocessState(state))
{{endif}}

{{if 'cuCheckpointProcessLock' in found_functions}}

@cython.embedsignature(True)
def cuCheckpointProcessLock(int pid, args : Optional[CUcheckpointLockArgs]):
    """ Lock a running CUDA process.

    Lock the CUDA process specified by `pid` which will block further CUDA
    API calls. Process must be in the RUNNING state in order to lock.

    Upon successful return the process will be in the LOCKED state.

    If timeoutMs is specified and the timeout is reached the process will
    be left in the RUNNING state upon return.

    Parameters
    ----------
    pid : int
        The process ID of the CUDA process
    args : :py:obj:`~.CUcheckpointLockArgs`
        Optional lock operation arguments

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED` :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE` :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED` :py:obj:`~.CUDA_ERROR_NOT_READY`
    """
    cdef cydriver.CUcheckpointLockArgs* cyargs_ptr = args._pvt_ptr if args is not None else NULL
    with nogil:
        err = cydriver.cuCheckpointProcessLock(pid, cyargs_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCheckpointProcessCheckpoint' in found_functions}}

@cython.embedsignature(True)
def cuCheckpointProcessCheckpoint(int pid, args : Optional[CUcheckpointCheckpointArgs]):
    """ Checkpoint a CUDA process's GPU memory contents.

    Checkpoints a CUDA process specified by `pid` that is in the LOCKED
    state. The GPU memory contents will be brought into host memory and all
    underlying references will be released. Process must be in the LOCKED
    state to checkpoint.

    Upon successful return the process will be in the CHECKPOINTED state.

    Parameters
    ----------
    pid : int
        The process ID of the CUDA process
    args : :py:obj:`~.CUcheckpointCheckpointArgs`
        Optional checkpoint operation arguments

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED` :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE` :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    """
    cdef cydriver.CUcheckpointCheckpointArgs* cyargs_ptr = args._pvt_ptr if args is not None else NULL
    with nogil:
        err = cydriver.cuCheckpointProcessCheckpoint(pid, cyargs_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCheckpointProcessRestore' in found_functions}}

@cython.embedsignature(True)
def cuCheckpointProcessRestore(int pid, args : Optional[CUcheckpointRestoreArgs]):
    """ Restore a CUDA process's GPU memory contents from its last checkpoint.

    Restores a CUDA process specified by `pid` from its last checkpoint.
    Process must be in the CHECKPOINTED state to restore.

    GPU UUID pairs can be specified in `args` to remap the process old GPUs
    onto new GPUs. The GPU to restore onto needs to have enough memory and
    be of the same chip type as the old GPU. If an array of GPU UUID pairs
    is specified, it must contain every checkpointed GPU.

    Upon successful return the process will be in the LOCKED state.

    CUDA process restore requires persistence mode to be enabled or
    :py:obj:`~.cuInit` to have been called before execution.

    Parameters
    ----------
    pid : int
        The process ID of the CUDA process
    args : :py:obj:`~.CUcheckpointRestoreArgs`
        Optional restore operation arguments

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED` :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE` :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuInit`
    """
    cdef cydriver.CUcheckpointRestoreArgs* cyargs_ptr = args._pvt_ptr if args is not None else NULL
    with nogil:
        err = cydriver.cuCheckpointProcessRestore(pid, cyargs_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuCheckpointProcessUnlock' in found_functions}}

@cython.embedsignature(True)
def cuCheckpointProcessUnlock(int pid, args : Optional[CUcheckpointUnlockArgs]):
    """ Unlock a CUDA process to allow CUDA API calls.

    Unlocks a process specified by `pid` allowing it to resume making CUDA
    API calls. Process must be in the LOCKED state.

    Upon successful return the process will be in the RUNNING state.

    Parameters
    ----------
    pid : int
        The process ID of the CUDA process
    args : :py:obj:`~.CUcheckpointUnlockArgs`
        Optional unlock operation arguments

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED` :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE` :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    """
    cdef cydriver.CUcheckpointUnlockArgs* cyargs_ptr = args._pvt_ptr if args is not None else NULL
    with nogil:
        err = cydriver.cuCheckpointProcessUnlock(pid, cyargs_ptr)
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuProfilerStart' in found_functions}}

@cython.embedsignature(True)
def cuProfilerStart():
    """ Enable profiling.

    Enables profile collection by the active profiling tool for the current
    context. If profiling is already enabled, then
    :py:obj:`~.cuProfilerStart()` has no effect.

    cuProfilerStart and cuProfilerStop APIs are used to programmatically
    control the profiling granularity by allowing profiling to be done only
    on selective pieces of code.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuProfilerInitialize`, :py:obj:`~.cuProfilerStop`, :py:obj:`~.cudaProfilerStart`
    """
    with nogil:
        err = cydriver.cuProfilerStart()
    return (_dict_CUresult[err],)
{{endif}}

{{if 'cuProfilerStop' in found_functions}}

@cython.embedsignature(True)
def cuProfilerStop():
    """ Disable profiling.

    Disables profile collection by the active profiling tool for the
    current context. If profiling is already disabled, then
    :py:obj:`~.cuProfilerStop()` has no effect.

    cuProfilerStart and cuProfilerStop APIs are used to programmatically
    control the profiling granularity by allowing profiling to be done only
    on selective pieces of code.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuProfilerInitialize`, :py:obj:`~.cuProfilerStart`, :py:obj:`~.cudaProfilerStop`
    """
    with nogil:
        err = cydriver.cuProfilerStop()
    return (_dict_CUresult[err],)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuGraphicsEGLRegisterImage(image, unsigned int flags):
    """ Registers an EGL image.

    Registers the EGLImageKHR specified by `image` for access by CUDA. A
    handle to the registered object is returned as `pCudaResource`.
    Additional Mapping/Unmapping is not required for the registered
    resource and :py:obj:`~.cuGraphicsResourceGetMappedEglFrame` can be
    directly called on the `pCudaResource`.

    The application will be responsible for synchronizing access to shared
    objects. The application must ensure that any pending operation which
    access the objects have completed before passing control to CUDA. This
    may be accomplished by issuing and waiting for glFinish command on all
    GLcontexts (for OpenGL and likewise for other APIs). The application
    will be also responsible for ensuring that any pending operation on the
    registered CUDA resource has completed prior to executing subsequent
    commands in other APIs accesing the same memory objects. This can be
    accomplished by calling cuCtxSynchronize or cuEventSynchronize
    (preferably).

    The surface's intended usage is specified using `flags`, as follows:

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE`: Specifies no hints
      about how this resource will be used. It is therefore assumed that
      this resource will be read from and written to by CUDA. This is the
      default value.

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY`: Specifies that
      CUDA will not write to this resource.

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD`: Specifies
      that CUDA will not read from this resource and will write over the
      entire contents of the resource, so none of the data previously
      stored in the resource will be preserved.

    The EGLImageKHR is an object which can be used to create EGLImage
    target resource. It is defined as a void pointer. typedef void*
    EGLImageKHR

    Parameters
    ----------
    image : :py:obj:`~.EGLImageKHR`
        An EGLImageKHR image which can be used to create target resource.
    flags : unsigned int
        Map flags

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
    pCudaResource : :py:obj:`~.CUgraphicsResource`
        Pointer to the returned object handle

    See Also
    --------
    :py:obj:`~.cuGraphicsEGLRegisterImage`, :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsResourceSetMapFlags`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cudaGraphicsEGLRegisterImage`
    """
    cdef cydriver.EGLImageKHR cyimage
    if image is None:
        pimage = 0
    elif isinstance(image, (EGLImageKHR,)):
        pimage = int(image)
    else:
        pimage = int(EGLImageKHR(image))
    cyimage = <cydriver.EGLImageKHR><void_ptr>pimage
    cdef CUgraphicsResource pCudaResource = CUgraphicsResource()
    with nogil:
        err = cydriver.cuGraphicsEGLRegisterImage(<cydriver.CUgraphicsResource*>pCudaResource._pvt_ptr, cyimage, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pCudaResource)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuEGLStreamConsumerConnect(stream):
    """ Connect CUDA to EGLStream as a consumer.

    Connect CUDA as a consumer to EGLStreamKHR specified by `stream`.

    The EGLStreamKHR is an EGL object that transfers a sequence of image
    frames from one API to another.

    Parameters
    ----------
    stream : :py:obj:`~.EGLStreamKHR`
        EGLStreamKHR handle

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
    conn : :py:obj:`~.CUeglStreamConnection`
        Pointer to the returned connection handle

    See Also
    --------
    :py:obj:`~.cuEGLStreamConsumerConnect`, :py:obj:`~.cuEGLStreamConsumerDisconnect`, :py:obj:`~.cuEGLStreamConsumerAcquireFrame`, :py:obj:`~.cuEGLStreamConsumerReleaseFrame`, :py:obj:`~.cudaEGLStreamConsumerConnect`
    """
    cdef cydriver.EGLStreamKHR cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (EGLStreamKHR,)):
        pstream = int(stream)
    else:
        pstream = int(EGLStreamKHR(stream))
    cystream = <cydriver.EGLStreamKHR><void_ptr>pstream
    cdef CUeglStreamConnection conn = CUeglStreamConnection()
    with nogil:
        err = cydriver.cuEGLStreamConsumerConnect(<cydriver.CUeglStreamConnection*>conn._pvt_ptr, cystream)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], conn)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuEGLStreamConsumerConnectWithFlags(stream, unsigned int flags):
    """ Connect CUDA to EGLStream as a consumer with given flags.

    Connect CUDA as a consumer to EGLStreamKHR specified by `stream` with
    specified `flags` defined by CUeglResourceLocationFlags.

    The flags specify whether the consumer wants to access frames from
    system memory or video memory. Default is
    :py:obj:`~.CU_EGL_RESOURCE_LOCATION_VIDMEM`.

    Parameters
    ----------
    stream : :py:obj:`~.EGLStreamKHR`
        EGLStreamKHR handle
    flags : unsigned int
        Flags denote intended location - system or video.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
    conn : :py:obj:`~.CUeglStreamConnection`
        Pointer to the returned connection handle

    See Also
    --------
    :py:obj:`~.cuEGLStreamConsumerConnect`, :py:obj:`~.cuEGLStreamConsumerDisconnect`, :py:obj:`~.cuEGLStreamConsumerAcquireFrame`, :py:obj:`~.cuEGLStreamConsumerReleaseFrame`, :py:obj:`~.cudaEGLStreamConsumerConnectWithFlags`
    """
    cdef cydriver.EGLStreamKHR cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (EGLStreamKHR,)):
        pstream = int(stream)
    else:
        pstream = int(EGLStreamKHR(stream))
    cystream = <cydriver.EGLStreamKHR><void_ptr>pstream
    cdef CUeglStreamConnection conn = CUeglStreamConnection()
    with nogil:
        err = cydriver.cuEGLStreamConsumerConnectWithFlags(<cydriver.CUeglStreamConnection*>conn._pvt_ptr, cystream, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], conn)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuEGLStreamConsumerDisconnect(conn):
    """ Disconnect CUDA as a consumer to EGLStream .

    Disconnect CUDA as a consumer to EGLStreamKHR.

    Parameters
    ----------
    conn : :py:obj:`~.CUeglStreamConnection`
        Conection to disconnect.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,

    See Also
    --------
    :py:obj:`~.cuEGLStreamConsumerConnect`, :py:obj:`~.cuEGLStreamConsumerDisconnect`, :py:obj:`~.cuEGLStreamConsumerAcquireFrame`, :py:obj:`~.cuEGLStreamConsumerReleaseFrame`, :py:obj:`~.cudaEGLStreamConsumerDisconnect`
    """
    cdef cydriver.CUeglStreamConnection *cyconn
    if conn is None:
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (CUeglStreamConnection,)):
        pconn = conn.getPtr()
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, driver.CUeglStreamConnection'>, found " + str(type(conn)))
    with nogil:
        err = cydriver.cuEGLStreamConsumerDisconnect(cyconn)
    return (_dict_CUresult[err],)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuEGLStreamConsumerAcquireFrame(conn, pCudaResource, pStream, unsigned int timeout):
    """ Acquire an image frame from the EGLStream with CUDA as a consumer.

    Acquire an image frame from EGLStreamKHR. This API can also acquire an
    old frame presented by the producer unless explicitly disabled by
    setting EGL_SUPPORT_REUSE_NV flag to EGL_FALSE during stream
    initialization. By default, EGLStream is created with this flag set to
    EGL_TRUE. :py:obj:`~.cuGraphicsResourceGetMappedEglFrame` can be called
    on `pCudaResource` to get :py:obj:`~.CUeglFrame`.

    Parameters
    ----------
    conn : :py:obj:`~.CUeglStreamConnection`
        Connection on which to acquire
    pCudaResource : :py:obj:`~.CUgraphicsResource`
        CUDA resource on which the stream frame will be mapped for use.
    pStream : :py:obj:`~.CUstream`
        CUDA stream for synchronization and any data migrations implied by
        :py:obj:`~.CUeglResourceLocationFlags`.
    timeout : unsigned int
        Desired timeout in usec for a new frame to be acquired. If set as
        :py:obj:`~.CUDA_EGL_INFINITE_TIMEOUT`, acquire waits infinitely.
        After timeout occurs CUDA consumer tries to acquire an old frame if
        available and EGL_SUPPORT_REUSE_NV flag is set.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`,

    See Also
    --------
    :py:obj:`~.cuEGLStreamConsumerConnect`, :py:obj:`~.cuEGLStreamConsumerDisconnect`, :py:obj:`~.cuEGLStreamConsumerAcquireFrame`, :py:obj:`~.cuEGLStreamConsumerReleaseFrame`, :py:obj:`~.cudaEGLStreamConsumerAcquireFrame`
    """
    cdef cydriver.CUstream *cypStream
    if pStream is None:
        cypStream = <cydriver.CUstream*><void_ptr>NULL
    elif isinstance(pStream, (CUstream,)):
        ppStream = pStream.getPtr()
        cypStream = <cydriver.CUstream*><void_ptr>ppStream
    elif isinstance(pStream, (int)):
        cypStream = <cydriver.CUstream*><void_ptr>pStream
    else:
        raise TypeError("Argument 'pStream' is not instance of type (expected <class 'int, driver.CUstream'>, found " + str(type(pStream)))
    cdef cydriver.CUgraphicsResource *cypCudaResource
    if pCudaResource is None:
        cypCudaResource = <cydriver.CUgraphicsResource*><void_ptr>NULL
    elif isinstance(pCudaResource, (CUgraphicsResource,)):
        ppCudaResource = pCudaResource.getPtr()
        cypCudaResource = <cydriver.CUgraphicsResource*><void_ptr>ppCudaResource
    elif isinstance(pCudaResource, (int)):
        cypCudaResource = <cydriver.CUgraphicsResource*><void_ptr>pCudaResource
    else:
        raise TypeError("Argument 'pCudaResource' is not instance of type (expected <class 'int, driver.CUgraphicsResource'>, found " + str(type(pCudaResource)))
    cdef cydriver.CUeglStreamConnection *cyconn
    if conn is None:
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (CUeglStreamConnection,)):
        pconn = conn.getPtr()
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, driver.CUeglStreamConnection'>, found " + str(type(conn)))
    with nogil:
        err = cydriver.cuEGLStreamConsumerAcquireFrame(cyconn, cypCudaResource, cypStream, timeout)
    return (_dict_CUresult[err],)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuEGLStreamConsumerReleaseFrame(conn, pCudaResource, pStream):
    """ Releases the last frame acquired from the EGLStream.

    Release the acquired image frame specified by `pCudaResource` to
    EGLStreamKHR. If EGL_SUPPORT_REUSE_NV flag is set to EGL_TRUE, at the
    time of EGL creation this API doesn't release the last frame acquired
    on the EGLStream. By default, EGLStream is created with this flag set
    to EGL_TRUE.

    Parameters
    ----------
    conn : :py:obj:`~.CUeglStreamConnection`
        Connection on which to release
    pCudaResource : :py:obj:`~.CUgraphicsResource`
        CUDA resource whose corresponding frame is to be released
    pStream : :py:obj:`~.CUstream`
        CUDA stream on which release will be done.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`,

    See Also
    --------
    :py:obj:`~.cuEGLStreamConsumerConnect`, :py:obj:`~.cuEGLStreamConsumerDisconnect`, :py:obj:`~.cuEGLStreamConsumerAcquireFrame`, :py:obj:`~.cuEGLStreamConsumerReleaseFrame`, :py:obj:`~.cudaEGLStreamConsumerReleaseFrame`
    """
    cdef cydriver.CUstream *cypStream
    if pStream is None:
        cypStream = <cydriver.CUstream*><void_ptr>NULL
    elif isinstance(pStream, (CUstream,)):
        ppStream = pStream.getPtr()
        cypStream = <cydriver.CUstream*><void_ptr>ppStream
    elif isinstance(pStream, (int)):
        cypStream = <cydriver.CUstream*><void_ptr>pStream
    else:
        raise TypeError("Argument 'pStream' is not instance of type (expected <class 'int, driver.CUstream'>, found " + str(type(pStream)))
    cdef cydriver.CUgraphicsResource cypCudaResource
    if pCudaResource is None:
        ppCudaResource = 0
    elif isinstance(pCudaResource, (CUgraphicsResource,)):
        ppCudaResource = int(pCudaResource)
    else:
        ppCudaResource = int(CUgraphicsResource(pCudaResource))
    cypCudaResource = <cydriver.CUgraphicsResource><void_ptr>ppCudaResource
    cdef cydriver.CUeglStreamConnection *cyconn
    if conn is None:
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (CUeglStreamConnection,)):
        pconn = conn.getPtr()
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, driver.CUeglStreamConnection'>, found " + str(type(conn)))
    with nogil:
        err = cydriver.cuEGLStreamConsumerReleaseFrame(cyconn, cypCudaResource, cypStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuEGLStreamProducerConnect(stream, width, height):
    """ Connect CUDA to EGLStream as a producer.

    Connect CUDA as a producer to EGLStreamKHR specified by `stream`.

    The EGLStreamKHR is an EGL object that transfers a sequence of image
    frames from one API to another.

    Parameters
    ----------
    stream : :py:obj:`~.EGLStreamKHR`
        EGLStreamKHR handle
    width : :py:obj:`~.EGLint`
        width of the image to be submitted to the stream
    height : :py:obj:`~.EGLint`
        height of the image to be submitted to the stream

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
    conn : :py:obj:`~.CUeglStreamConnection`
        Pointer to the returned connection handle

    See Also
    --------
    :py:obj:`~.cuEGLStreamProducerConnect`, :py:obj:`~.cuEGLStreamProducerDisconnect`, :py:obj:`~.cuEGLStreamProducerPresentFrame`, :py:obj:`~.cudaEGLStreamProducerConnect`
    """
    cdef cydriver.EGLint cyheight
    if height is None:
        pheight = 0
    elif isinstance(height, (EGLint,)):
        pheight = int(height)
    else:
        pheight = int(EGLint(height))
    cyheight = <cydriver.EGLint><void_ptr>pheight
    cdef cydriver.EGLint cywidth
    if width is None:
        pwidth = 0
    elif isinstance(width, (EGLint,)):
        pwidth = int(width)
    else:
        pwidth = int(EGLint(width))
    cywidth = <cydriver.EGLint><void_ptr>pwidth
    cdef cydriver.EGLStreamKHR cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (EGLStreamKHR,)):
        pstream = int(stream)
    else:
        pstream = int(EGLStreamKHR(stream))
    cystream = <cydriver.EGLStreamKHR><void_ptr>pstream
    cdef CUeglStreamConnection conn = CUeglStreamConnection()
    with nogil:
        err = cydriver.cuEGLStreamProducerConnect(<cydriver.CUeglStreamConnection*>conn._pvt_ptr, cystream, cywidth, cyheight)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], conn)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuEGLStreamProducerDisconnect(conn):
    """ Disconnect CUDA as a producer to EGLStream .

    Disconnect CUDA as a producer to EGLStreamKHR.

    Parameters
    ----------
    conn : :py:obj:`~.CUeglStreamConnection`
        Conection to disconnect.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,

    See Also
    --------
    :py:obj:`~.cuEGLStreamProducerConnect`, :py:obj:`~.cuEGLStreamProducerDisconnect`, :py:obj:`~.cuEGLStreamProducerPresentFrame`, :py:obj:`~.cudaEGLStreamProducerDisconnect`
    """
    cdef cydriver.CUeglStreamConnection *cyconn
    if conn is None:
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (CUeglStreamConnection,)):
        pconn = conn.getPtr()
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, driver.CUeglStreamConnection'>, found " + str(type(conn)))
    with nogil:
        err = cydriver.cuEGLStreamProducerDisconnect(cyconn)
    return (_dict_CUresult[err],)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuEGLStreamProducerPresentFrame(conn, eglframe not None : CUeglFrame, pStream):
    """ Present a CUDA eglFrame to the EGLStream with CUDA as a producer.

    When a frame is presented by the producer, it gets associated with the
    EGLStream and thus it is illegal to free the frame before the producer
    is disconnected. If a frame is freed and reused it may lead to
    undefined behavior.

    If producer and consumer are on different GPUs (iGPU and dGPU) then
    frametype :py:obj:`~.CU_EGL_FRAME_TYPE_ARRAY` is not supported.
    :py:obj:`~.CU_EGL_FRAME_TYPE_PITCH` can be used for such cross-device
    applications.

    The :py:obj:`~.CUeglFrame` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    For :py:obj:`~.CUeglFrame` of type :py:obj:`~.CU_EGL_FRAME_TYPE_PITCH`,
    the application may present sub-region of a memory allocation. In that
    case, the pitched pointer will specify the start address of the sub-
    region in the allocation and corresponding :py:obj:`~.CUeglFrame`
    fields will specify the dimensions of the sub-region.

    Parameters
    ----------
    conn : :py:obj:`~.CUeglStreamConnection`
        Connection on which to present the CUDA array
    eglframe : :py:obj:`~.CUeglFrame`
        CUDA Eglstream Proucer Frame handle to be sent to the consumer over
        EglStream.
    pStream : :py:obj:`~.CUstream`
        CUDA stream on which to present the frame.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`,

    See Also
    --------
    :py:obj:`~.cuEGLStreamProducerConnect`, :py:obj:`~.cuEGLStreamProducerDisconnect`, :py:obj:`~.cuEGLStreamProducerReturnFrame`, :py:obj:`~.cudaEGLStreamProducerPresentFrame`
    """
    cdef cydriver.CUstream *cypStream
    if pStream is None:
        cypStream = <cydriver.CUstream*><void_ptr>NULL
    elif isinstance(pStream, (CUstream,)):
        ppStream = pStream.getPtr()
        cypStream = <cydriver.CUstream*><void_ptr>ppStream
    elif isinstance(pStream, (int)):
        cypStream = <cydriver.CUstream*><void_ptr>pStream
    else:
        raise TypeError("Argument 'pStream' is not instance of type (expected <class 'int, driver.CUstream'>, found " + str(type(pStream)))
    cdef cydriver.CUeglStreamConnection *cyconn
    if conn is None:
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (CUeglStreamConnection,)):
        pconn = conn.getPtr()
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, driver.CUeglStreamConnection'>, found " + str(type(conn)))
    with nogil:
        err = cydriver.cuEGLStreamProducerPresentFrame(cyconn, eglframe._pvt_ptr[0], cypStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuEGLStreamProducerReturnFrame(conn, eglframe : Optional[CUeglFrame], pStream):
    """ Return the CUDA eglFrame to the EGLStream released by the consumer.

    This API can potentially return CUDA_ERROR_LAUNCH_TIMEOUT if the
    consumer has not returned a frame to EGL stream. If timeout is returned
    the application can retry.

    Parameters
    ----------
    conn : :py:obj:`~.CUeglStreamConnection`
        Connection on which to return
    eglframe : :py:obj:`~.CUeglFrame`
        CUDA Eglstream Proucer Frame handle returned from the consumer over
        EglStream.
    pStream : :py:obj:`~.CUstream`
        CUDA stream on which to return the frame.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`

    See Also
    --------
    :py:obj:`~.cuEGLStreamProducerConnect`, :py:obj:`~.cuEGLStreamProducerDisconnect`, :py:obj:`~.cuEGLStreamProducerPresentFrame`, :py:obj:`~.cudaEGLStreamProducerReturnFrame`
    """
    cdef cydriver.CUstream *cypStream
    if pStream is None:
        cypStream = <cydriver.CUstream*><void_ptr>NULL
    elif isinstance(pStream, (CUstream,)):
        ppStream = pStream.getPtr()
        cypStream = <cydriver.CUstream*><void_ptr>ppStream
    elif isinstance(pStream, (int)):
        cypStream = <cydriver.CUstream*><void_ptr>pStream
    else:
        raise TypeError("Argument 'pStream' is not instance of type (expected <class 'int, driver.CUstream'>, found " + str(type(pStream)))
    cdef cydriver.CUeglStreamConnection *cyconn
    if conn is None:
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (CUeglStreamConnection,)):
        pconn = conn.getPtr()
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cyconn = <cydriver.CUeglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, driver.CUeglStreamConnection'>, found " + str(type(conn)))
    cdef cydriver.CUeglFrame* cyeglframe_ptr = eglframe._pvt_ptr if eglframe is not None else NULL
    with nogil:
        err = cydriver.cuEGLStreamProducerReturnFrame(cyconn, cyeglframe_ptr, cypStream)
    return (_dict_CUresult[err],)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuGraphicsResourceGetMappedEglFrame(resource, unsigned int index, unsigned int mipLevel):
    """ Get an eglFrame through which to access a registered EGL graphics resource.

    Returns in `*eglFrame` an eglFrame pointer through which the registered
    graphics resource `resource` may be accessed. This API can only be
    called for registered EGL graphics resources.

    The :py:obj:`~.CUeglFrame` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If `resource` is not registered then :py:obj:`~.CUDA_ERROR_NOT_MAPPED`
    is returned.

    Parameters
    ----------
    resource : :py:obj:`~.CUgraphicsResource`
        None
    index : unsigned int
        None
    mipLevel : unsigned int
        None

    Returns
    -------
    CUresult

    eglFrame : :py:obj:`~.CUeglFrame`
        None
    """
    cdef cydriver.CUgraphicsResource cyresource
    if resource is None:
        presource = 0
    elif isinstance(resource, (CUgraphicsResource,)):
        presource = int(resource)
    else:
        presource = int(CUgraphicsResource(resource))
    cyresource = <cydriver.CUgraphicsResource><void_ptr>presource
    cdef CUeglFrame eglFrame = CUeglFrame()
    with nogil:
        err = cydriver.cuGraphicsResourceGetMappedEglFrame(<cydriver.CUeglFrame*>eglFrame._pvt_ptr, cyresource, index, mipLevel)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], eglFrame)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuEventCreateFromEGLSync(eglSync, unsigned int flags):
    """ Creates an event from EGLSync object.

    Creates an event *phEvent from an EGLSyncKHR eglSync with the flags
    specified via `flags`. Valid flags include:

    - :py:obj:`~.CU_EVENT_DEFAULT`: Default event creation flag.

    - :py:obj:`~.CU_EVENT_BLOCKING_SYNC`: Specifies that the created event
      should use blocking synchronization. A CPU thread that uses
      :py:obj:`~.cuEventSynchronize()` to wait on an event created with
      this flag will block until the event has actually been completed.

    Once the `eglSync` gets destroyed, :py:obj:`~.cuEventDestroy` is the
    only API that can be invoked on the event.

    :py:obj:`~.cuEventRecord` and TimingData are not supported for events
    created from EGLSync.

    The EGLSyncKHR is an opaque handle to an EGL sync object. typedef void*
    EGLSyncKHR

    Parameters
    ----------
    eglSync : :py:obj:`~.EGLSyncKHR`
        Opaque handle to EGLSync object
    flags : unsigned int
        Event creation flags

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    phEvent : :py:obj:`~.CUevent`
        Returns newly created event

    See Also
    --------
    :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventDestroy`
    """
    cdef cydriver.EGLSyncKHR cyeglSync
    if eglSync is None:
        peglSync = 0
    elif isinstance(eglSync, (EGLSyncKHR,)):
        peglSync = int(eglSync)
    else:
        peglSync = int(EGLSyncKHR(eglSync))
    cyeglSync = <cydriver.EGLSyncKHR><void_ptr>peglSync
    cdef CUevent phEvent = CUevent()
    with nogil:
        err = cydriver.cuEventCreateFromEGLSync(<cydriver.CUevent*>phEvent._pvt_ptr, cyeglSync, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], phEvent)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuGraphicsGLRegisterBuffer(buffer, unsigned int Flags):
    """ Registers an OpenGL buffer object.

    Registers the buffer object specified by `buffer` for access by CUDA. A
    handle to the registered object is returned as `pCudaResource`. The
    register flags `Flags` specify the intended usage, as follows:

    - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_NONE`: Specifies no hints about
      how this resource will be used. It is therefore assumed that this
      resource will be read from and written to by CUDA. This is the
      default value.

    - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY`: Specifies that CUDA
      will not write to this resource.

    - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD`: Specifies that
      CUDA will not read from this resource and will write over the entire
      contents of the resource, so none of the data previously stored in
      the resource will be preserved.

    Parameters
    ----------
    buffer : :py:obj:`~.GLuint`
        name of buffer object to be registered
    Flags : unsigned int
        Register flags

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_OPERATING_SYSTEM`
    pCudaResource : :py:obj:`~.CUgraphicsResource`
        Pointer to the returned object handle

    See Also
    --------
    :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsResourceGetMappedPointer`, :py:obj:`~.cudaGraphicsGLRegisterBuffer`
    """
    cdef cydriver.GLuint cybuffer
    if buffer is None:
        pbuffer = 0
    elif isinstance(buffer, (GLuint,)):
        pbuffer = int(buffer)
    else:
        pbuffer = int(GLuint(buffer))
    cybuffer = <cydriver.GLuint><void_ptr>pbuffer
    cdef CUgraphicsResource pCudaResource = CUgraphicsResource()
    with nogil:
        err = cydriver.cuGraphicsGLRegisterBuffer(<cydriver.CUgraphicsResource*>pCudaResource._pvt_ptr, cybuffer, Flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pCudaResource)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuGraphicsGLRegisterImage(image, target, unsigned int Flags):
    """ Register an OpenGL texture or renderbuffer object.

    Registers the texture or renderbuffer object specified by `image` for
    access by CUDA.   A handle to the registered object is returned as
    `pCudaResource`.

    `target` must match the type of the object, and must be one of
    :py:obj:`~.GL_TEXTURE_2D`, :py:obj:`~.GL_TEXTURE_RECTANGLE`,
    :py:obj:`~.GL_TEXTURE_CUBE_MAP`, :py:obj:`~.GL_TEXTURE_3D`,
    :py:obj:`~.GL_TEXTURE_2D_ARRAY`, or :py:obj:`~.GL_RENDERBUFFER`.

    The register flags `Flags` specify the intended usage, as follows:

    - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_NONE`: Specifies no hints about
      how this resource will be used. It is therefore assumed that this
      resource will be read from and written to by CUDA. This is the
      default value.

    - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY`: Specifies that CUDA
      will not write to this resource.

    - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD`: Specifies that
      CUDA will not read from this resource and will write over the entire
      contents of the resource, so none of the data previously stored in
      the resource will be preserved.

    - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST`: Specifies that
      CUDA will bind this resource to a surface reference.

    - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER`: Specifies that
      CUDA will perform texture gather operations on this resource.

    The following image formats are supported. For brevity's sake, the list
    is abbreviated. For ex., {GL_R, GL_RG} X {8, 16} would expand to the
    following 4 formats {GL_R8, GL_R16, GL_RG8, GL_RG16} :

    - GL_RED, GL_RG, GL_RGBA, GL_LUMINANCE, GL_ALPHA, GL_LUMINANCE_ALPHA,
      GL_INTENSITY

    - {GL_R, GL_RG, GL_RGBA} X {8, 16, 16F, 32F, 8UI, 16UI, 32UI, 8I, 16I,
      32I}

    - {GL_LUMINANCE, GL_ALPHA, GL_LUMINANCE_ALPHA, GL_INTENSITY} X {8, 16,
      16F_ARB, 32F_ARB, 8UI_EXT, 16UI_EXT, 32UI_EXT, 8I_EXT, 16I_EXT,
      32I_EXT}

    The following image classes are currently disallowed:

    - Textures with borders

    - Multisampled renderbuffers

    Parameters
    ----------
    image : :py:obj:`~.GLuint`
        name of texture or renderbuffer object to be registered
    target : :py:obj:`~.GLenum`
        Identifies the type of object specified by `image`
    Flags : unsigned int
        Register flags

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_OPERATING_SYSTEM`
    pCudaResource : :py:obj:`~.CUgraphicsResource`
        Pointer to the returned object handle

    See Also
    --------
    :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cudaGraphicsGLRegisterImage`
    """
    cdef cydriver.GLenum cytarget
    if target is None:
        ptarget = 0
    elif isinstance(target, (GLenum,)):
        ptarget = int(target)
    else:
        ptarget = int(GLenum(target))
    cytarget = <cydriver.GLenum><void_ptr>ptarget
    cdef cydriver.GLuint cyimage
    if image is None:
        pimage = 0
    elif isinstance(image, (GLuint,)):
        pimage = int(image)
    else:
        pimage = int(GLuint(image))
    cyimage = <cydriver.GLuint><void_ptr>pimage
    cdef CUgraphicsResource pCudaResource = CUgraphicsResource()
    with nogil:
        err = cydriver.cuGraphicsGLRegisterImage(<cydriver.CUgraphicsResource*>pCudaResource._pvt_ptr, cyimage, cytarget, Flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pCudaResource)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuGLGetDevices(unsigned int cudaDeviceCount, deviceList not None : CUGLDeviceList):
    """ Gets the CUDA devices associated with the current OpenGL context.

    Returns in `*pCudaDeviceCount` the number of CUDA-compatible devices
    corresponding to the current OpenGL context. Also returns in
    `*pCudaDevices` at most cudaDeviceCount of the CUDA-compatible devices
    corresponding to the current OpenGL context. If any of the GPUs being
    used by the current OpenGL context are not CUDA capable then the call
    will return CUDA_ERROR_NO_DEVICE.

    The `deviceList` argument may be any of the following:
    CU_GL_DEVICE_LIST_ALL: Query all devices used by the current OpenGL
    context. CU_GL_DEVICE_LIST_CURRENT_FRAME: Query the devices used by the
    current OpenGL context to render the current frame (in SLI).
    CU_GL_DEVICE_LIST_NEXT_FRAME: Query the devices used by the current
    OpenGL context to render the next frame (in SLI). Note that this is a
    prediction, it can't be guaranteed that this is correct in all cases.

    Parameters
    ----------
    cudaDeviceCount : unsigned int
        The size of the output device array pCudaDevices.
    deviceList : CUGLDeviceList
        The set of devices to return.

    Returns
    -------
    CUresult
        CUDA_SUCCESS
        CUDA_ERROR_NO_DEVICE
        CUDA_ERROR_INVALID_VALUE
        CUDA_ERROR_INVALID_CONTEXT
        CUDA_ERROR_INVALID_GRAPHICS_CONTEXT
    pCudaDeviceCount : unsigned int
        Returned number of CUDA devices.
    pCudaDevices : list[CUdevice]
        Returned CUDA devices.

    See Also
    --------
    ~.cudaGLGetDevices

    Notes
    -----
    This function is not supported on Mac OS X.

    """
    cdef unsigned int pCudaDeviceCount = 0
    cdef cydriver.CUdevice* cypCudaDevices = NULL
    pypCudaDevices = []
    if cudaDeviceCount != 0:
        cypCudaDevices = <cydriver.CUdevice*>calloc(cudaDeviceCount, sizeof(cydriver.CUdevice))
        if cypCudaDevices is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(cudaDeviceCount) + 'x' + str(sizeof(cydriver.CUdevice)))
    cdef cydriver.CUGLDeviceList cydeviceList = deviceList.value
    with nogil:
        err = cydriver.cuGLGetDevices(&pCudaDeviceCount, cypCudaDevices, cudaDeviceCount, cydeviceList)
    if CUresult(err) == CUresult(0):
        pypCudaDevices = [CUdevice(init_value=<void_ptr>cypCudaDevices[idx]) for idx in range(cudaDeviceCount)]
    if cypCudaDevices is not NULL:
        free(cypCudaDevices)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None, None)
    return (_dict_CUresult[err], pCudaDeviceCount, pypCudaDevices)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuVDPAUGetDevice(vdpDevice, vdpGetProcAddress):
    """ Gets the CUDA device associated with a VDPAU device.

    Returns in `*pDevice` the CUDA device associated with a `vdpDevice`, if
    applicable.

    Parameters
    ----------
    vdpDevice : :py:obj:`~.VdpDevice`
        A VdpDevice handle
    vdpGetProcAddress : :py:obj:`~.VdpGetProcAddress`
        VDPAU's VdpGetProcAddress function pointer

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pDevice : :py:obj:`~.CUdevice`
        Device associated with vdpDevice

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuVDPAUCtxCreate`, :py:obj:`~.cuGraphicsVDPAURegisterVideoSurface`, :py:obj:`~.cuGraphicsVDPAURegisterOutputSurface`, :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsResourceSetMapFlags`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cudaVDPAUGetDevice`
    """
    cdef cydriver.VdpGetProcAddress *cyvdpGetProcAddress
    if vdpGetProcAddress is None:
        cyvdpGetProcAddress = <cydriver.VdpGetProcAddress*><void_ptr>NULL
    elif isinstance(vdpGetProcAddress, (VdpGetProcAddress,)):
        pvdpGetProcAddress = vdpGetProcAddress.getPtr()
        cyvdpGetProcAddress = <cydriver.VdpGetProcAddress*><void_ptr>pvdpGetProcAddress
    elif isinstance(vdpGetProcAddress, (int)):
        cyvdpGetProcAddress = <cydriver.VdpGetProcAddress*><void_ptr>vdpGetProcAddress
    else:
        raise TypeError("Argument 'vdpGetProcAddress' is not instance of type (expected <class 'int, driver.VdpGetProcAddress'>, found " + str(type(vdpGetProcAddress)))
    cdef cydriver.VdpDevice cyvdpDevice
    if vdpDevice is None:
        pvdpDevice = 0
    elif isinstance(vdpDevice, (VdpDevice,)):
        pvdpDevice = int(vdpDevice)
    else:
        pvdpDevice = int(VdpDevice(vdpDevice))
    cyvdpDevice = <cydriver.VdpDevice><void_ptr>pvdpDevice
    cdef CUdevice pDevice = CUdevice()
    with nogil:
        err = cydriver.cuVDPAUGetDevice(<cydriver.CUdevice*>pDevice._pvt_ptr, cyvdpDevice, cyvdpGetProcAddress)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pDevice)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuVDPAUCtxCreate(unsigned int flags, device, vdpDevice, vdpGetProcAddress):
    """ Create a CUDA context for interoperability with VDPAU.

    Creates a new CUDA context, initializes VDPAU interoperability, and
    associates the CUDA context with the calling thread. It must be called
    before performing any other VDPAU interoperability operations. It may
    fail if the needed VDPAU driver facilities are not available. For usage
    of the `flags` parameter, see :py:obj:`~.cuCtxCreate()`.

    Parameters
    ----------
    flags : unsigned int
        Options for CUDA context creation
    device : :py:obj:`~.CUdevice`
        Device on which to create the context
    vdpDevice : :py:obj:`~.VdpDevice`
        The VdpDevice to interop with
    vdpGetProcAddress : :py:obj:`~.VdpGetProcAddress`
        VDPAU's VdpGetProcAddress function pointer

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    pCtx : :py:obj:`~.CUcontext`
        Returned CUDA context

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuGraphicsVDPAURegisterVideoSurface`, :py:obj:`~.cuGraphicsVDPAURegisterOutputSurface`, :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsResourceSetMapFlags`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cuVDPAUGetDevice`
    """
    cdef cydriver.VdpGetProcAddress *cyvdpGetProcAddress
    if vdpGetProcAddress is None:
        cyvdpGetProcAddress = <cydriver.VdpGetProcAddress*><void_ptr>NULL
    elif isinstance(vdpGetProcAddress, (VdpGetProcAddress,)):
        pvdpGetProcAddress = vdpGetProcAddress.getPtr()
        cyvdpGetProcAddress = <cydriver.VdpGetProcAddress*><void_ptr>pvdpGetProcAddress
    elif isinstance(vdpGetProcAddress, (int)):
        cyvdpGetProcAddress = <cydriver.VdpGetProcAddress*><void_ptr>vdpGetProcAddress
    else:
        raise TypeError("Argument 'vdpGetProcAddress' is not instance of type (expected <class 'int, driver.VdpGetProcAddress'>, found " + str(type(vdpGetProcAddress)))
    cdef cydriver.VdpDevice cyvdpDevice
    if vdpDevice is None:
        pvdpDevice = 0
    elif isinstance(vdpDevice, (VdpDevice,)):
        pvdpDevice = int(vdpDevice)
    else:
        pvdpDevice = int(VdpDevice(vdpDevice))
    cyvdpDevice = <cydriver.VdpDevice><void_ptr>pvdpDevice
    cdef cydriver.CUdevice cydevice
    if device is None:
        pdevice = 0
    elif isinstance(device, (CUdevice,)):
        pdevice = int(device)
    else:
        pdevice = int(CUdevice(device))
    cydevice = <cydriver.CUdevice>pdevice
    cdef CUcontext pCtx = CUcontext()
    with nogil:
        err = cydriver.cuVDPAUCtxCreate(<cydriver.CUcontext*>pCtx._pvt_ptr, flags, cydevice, cyvdpDevice, cyvdpGetProcAddress)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pCtx)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuGraphicsVDPAURegisterVideoSurface(vdpSurface, unsigned int flags):
    """ Registers a VDPAU VdpVideoSurface object.

    Registers the VdpVideoSurface specified by `vdpSurface` for access by
    CUDA. A handle to the registered object is returned as `pCudaResource`.
    The surface's intended usage is specified using `flags`, as follows:

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE`: Specifies no hints
      about how this resource will be used. It is therefore assumed that
      this resource will be read from and written to by CUDA. This is the
      default value.

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY`: Specifies that
      CUDA will not write to this resource.

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD`: Specifies
      that CUDA will not read from this resource and will write over the
      entire contents of the resource, so none of the data previously
      stored in the resource will be preserved.

    The VdpVideoSurface is presented as an array of subresources that may
    be accessed using pointers returned by
    :py:obj:`~.cuGraphicsSubResourceGetMappedArray`. The exact number of
    valid `arrayIndex` values depends on the VDPAU surface format. The
    mapping is shown in the table below. `mipLevel` must be 0.

    Parameters
    ----------
    vdpSurface : :py:obj:`~.VdpVideoSurface`
        The VdpVideoSurface to be registered
    flags : unsigned int
        Map flags

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
    pCudaResource : :py:obj:`~.CUgraphicsResource`
        Pointer to the returned object handle

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuVDPAUCtxCreate`, :py:obj:`~.cuGraphicsVDPAURegisterOutputSurface`, :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsResourceSetMapFlags`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cuVDPAUGetDevice`, :py:obj:`~.cudaGraphicsVDPAURegisterVideoSurface`
    """
    cdef cydriver.VdpVideoSurface cyvdpSurface
    if vdpSurface is None:
        pvdpSurface = 0
    elif isinstance(vdpSurface, (VdpVideoSurface,)):
        pvdpSurface = int(vdpSurface)
    else:
        pvdpSurface = int(VdpVideoSurface(vdpSurface))
    cyvdpSurface = <cydriver.VdpVideoSurface><void_ptr>pvdpSurface
    cdef CUgraphicsResource pCudaResource = CUgraphicsResource()
    with nogil:
        err = cydriver.cuGraphicsVDPAURegisterVideoSurface(<cydriver.CUgraphicsResource*>pCudaResource._pvt_ptr, cyvdpSurface, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pCudaResource)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cuGraphicsVDPAURegisterOutputSurface(vdpSurface, unsigned int flags):
    """ Registers a VDPAU VdpOutputSurface object.

    Registers the VdpOutputSurface specified by `vdpSurface` for access by
    CUDA. A handle to the registered object is returned as `pCudaResource`.
    The surface's intended usage is specified using `flags`, as follows:

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE`: Specifies no hints
      about how this resource will be used. It is therefore assumed that
      this resource will be read from and written to by CUDA. This is the
      default value.

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY`: Specifies that
      CUDA will not write to this resource.

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD`: Specifies
      that CUDA will not read from this resource and will write over the
      entire contents of the resource, so none of the data previously
      stored in the resource will be preserved.

    The VdpOutputSurface is presented as an array of subresources that may
    be accessed using pointers returned by
    :py:obj:`~.cuGraphicsSubResourceGetMappedArray`. The exact number of
    valid `arrayIndex` values depends on the VDPAU surface format. The
    mapping is shown in the table below. `mipLevel` must be 0.

    Parameters
    ----------
    vdpSurface : :py:obj:`~.VdpOutputSurface`
        The VdpOutputSurface to be registered
    flags : unsigned int
        Map flags

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
    pCudaResource : :py:obj:`~.CUgraphicsResource`
        Pointer to the returned object handle

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuVDPAUCtxCreate`, :py:obj:`~.cuGraphicsVDPAURegisterVideoSurface`, :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsResourceSetMapFlags`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cuVDPAUGetDevice`, :py:obj:`~.cudaGraphicsVDPAURegisterOutputSurface`
    """
    cdef cydriver.VdpOutputSurface cyvdpSurface
    if vdpSurface is None:
        pvdpSurface = 0
    elif isinstance(vdpSurface, (VdpOutputSurface,)):
        pvdpSurface = int(vdpSurface)
    else:
        pvdpSurface = int(VdpOutputSurface(vdpSurface))
    cyvdpSurface = <cydriver.VdpOutputSurface><void_ptr>pvdpSurface
    cdef CUgraphicsResource pCudaResource = CUgraphicsResource()
    with nogil:
        err = cydriver.cuGraphicsVDPAURegisterOutputSurface(<cydriver.CUgraphicsResource*>pCudaResource._pvt_ptr, cyvdpSurface, flags)
    if err != cydriver.CUDA_SUCCESS:
        return (_dict_CUresult[err], None)
    return (_dict_CUresult[err], pCudaResource)
{{endif}}


cdef class cudaBindingsDriverGlobal:
    cdef map[void_ptr, void*] _allocated

    def __dealloc__(self):
        for item in self._allocated:
            free(item.second)
        self._allocated.clear()

cdef cudaBindingsDriverGlobal m_global = cudaBindingsDriverGlobal()


@cython.embedsignature(True)
def sizeof(objType):
    """ Returns the size of provided CUDA Python structure in bytes

    Parameters
    ----------
    objType : Any
        CUDA Python object

    Returns
    -------
    lowered_name : int
        The size of `objType` in bytes
    """
    {{if 'cuuint32_t' in found_types}}
    if objType == cuuint32_t:
        return sizeof(cydriver.cuuint32_t){{endif}}
    {{if 'cuuint64_t' in found_types}}
    if objType == cuuint64_t:
        return sizeof(cydriver.cuuint64_t){{endif}}
    {{if 'CUdeviceptr_v2' in found_types}}
    if objType == CUdeviceptr_v2:
        return sizeof(cydriver.CUdeviceptr_v2){{endif}}
    {{if 'CUdeviceptr' in found_types}}
    if objType == CUdeviceptr:
        return sizeof(cydriver.CUdeviceptr){{endif}}
    {{if 'CUdevice_v1' in found_types}}
    if objType == CUdevice_v1:
        return sizeof(cydriver.CUdevice_v1){{endif}}
    {{if 'CUdevice' in found_types}}
    if objType == CUdevice:
        return sizeof(cydriver.CUdevice){{endif}}
    {{if 'CUcontext' in found_types}}
    if objType == CUcontext:
        return sizeof(cydriver.CUcontext){{endif}}
    {{if 'CUmodule' in found_types}}
    if objType == CUmodule:
        return sizeof(cydriver.CUmodule){{endif}}
    {{if 'CUfunction' in found_types}}
    if objType == CUfunction:
        return sizeof(cydriver.CUfunction){{endif}}
    {{if 'CUlibrary' in found_types}}
    if objType == CUlibrary:
        return sizeof(cydriver.CUlibrary){{endif}}
    {{if 'CUkernel' in found_types}}
    if objType == CUkernel:
        return sizeof(cydriver.CUkernel){{endif}}
    {{if 'CUarray' in found_types}}
    if objType == CUarray:
        return sizeof(cydriver.CUarray){{endif}}
    {{if 'CUmipmappedArray' in found_types}}
    if objType == CUmipmappedArray:
        return sizeof(cydriver.CUmipmappedArray){{endif}}
    {{if 'CUtexref' in found_types}}
    if objType == CUtexref:
        return sizeof(cydriver.CUtexref){{endif}}
    {{if 'CUsurfref' in found_types}}
    if objType == CUsurfref:
        return sizeof(cydriver.CUsurfref){{endif}}
    {{if 'CUevent' in found_types}}
    if objType == CUevent:
        return sizeof(cydriver.CUevent){{endif}}
    {{if 'CUstream' in found_types}}
    if objType == CUstream:
        return sizeof(cydriver.CUstream){{endif}}
    {{if 'CUgraphicsResource' in found_types}}
    if objType == CUgraphicsResource:
        return sizeof(cydriver.CUgraphicsResource){{endif}}
    {{if 'CUtexObject_v1' in found_types}}
    if objType == CUtexObject_v1:
        return sizeof(cydriver.CUtexObject_v1){{endif}}
    {{if 'CUtexObject' in found_types}}
    if objType == CUtexObject:
        return sizeof(cydriver.CUtexObject){{endif}}
    {{if 'CUsurfObject_v1' in found_types}}
    if objType == CUsurfObject_v1:
        return sizeof(cydriver.CUsurfObject_v1){{endif}}
    {{if 'CUsurfObject' in found_types}}
    if objType == CUsurfObject:
        return sizeof(cydriver.CUsurfObject){{endif}}
    {{if 'CUexternalMemory' in found_types}}
    if objType == CUexternalMemory:
        return sizeof(cydriver.CUexternalMemory){{endif}}
    {{if 'CUexternalSemaphore' in found_types}}
    if objType == CUexternalSemaphore:
        return sizeof(cydriver.CUexternalSemaphore){{endif}}
    {{if 'CUgraph' in found_types}}
    if objType == CUgraph:
        return sizeof(cydriver.CUgraph){{endif}}
    {{if 'CUgraphNode' in found_types}}
    if objType == CUgraphNode:
        return sizeof(cydriver.CUgraphNode){{endif}}
    {{if 'CUgraphExec' in found_types}}
    if objType == CUgraphExec:
        return sizeof(cydriver.CUgraphExec){{endif}}
    {{if 'CUmemoryPool' in found_types}}
    if objType == CUmemoryPool:
        return sizeof(cydriver.CUmemoryPool){{endif}}
    {{if 'CUuserObject' in found_types}}
    if objType == CUuserObject:
        return sizeof(cydriver.CUuserObject){{endif}}
    {{if 'CUgraphConditionalHandle' in found_types}}
    if objType == CUgraphConditionalHandle:
        return sizeof(cydriver.CUgraphConditionalHandle){{endif}}
    {{if 'CUgraphDeviceNode' in found_types}}
    if objType == CUgraphDeviceNode:
        return sizeof(cydriver.CUgraphDeviceNode){{endif}}
    {{if 'CUasyncCallbackHandle' in found_types}}
    if objType == CUasyncCallbackHandle:
        return sizeof(cydriver.CUasyncCallbackHandle){{endif}}
    {{if 'CUgreenCtx' in found_types}}
    if objType == CUgreenCtx:
        return sizeof(cydriver.CUgreenCtx){{endif}}
    {{if 'CUuuid_st' in found_struct}}
    if objType == CUuuid_st:
        return sizeof(cydriver.CUuuid_st){{endif}}
    {{if 'CUuuid' in found_types}}
    if objType == CUuuid:
        return sizeof(cydriver.CUuuid){{endif}}
    {{if 'CUmemFabricHandle_st' in found_struct}}
    if objType == CUmemFabricHandle_st:
        return sizeof(cydriver.CUmemFabricHandle_st){{endif}}
    {{if 'CUmemFabricHandle_v1' in found_types}}
    if objType == CUmemFabricHandle_v1:
        return sizeof(cydriver.CUmemFabricHandle_v1){{endif}}
    {{if 'CUmemFabricHandle' in found_types}}
    if objType == CUmemFabricHandle:
        return sizeof(cydriver.CUmemFabricHandle){{endif}}
    {{if 'CUipcEventHandle_st' in found_struct}}
    if objType == CUipcEventHandle_st:
        return sizeof(cydriver.CUipcEventHandle_st){{endif}}
    {{if 'CUipcEventHandle_v1' in found_types}}
    if objType == CUipcEventHandle_v1:
        return sizeof(cydriver.CUipcEventHandle_v1){{endif}}
    {{if 'CUipcEventHandle' in found_types}}
    if objType == CUipcEventHandle:
        return sizeof(cydriver.CUipcEventHandle){{endif}}
    {{if 'CUipcMemHandle_st' in found_struct}}
    if objType == CUipcMemHandle_st:
        return sizeof(cydriver.CUipcMemHandle_st){{endif}}
    {{if 'CUipcMemHandle_v1' in found_types}}
    if objType == CUipcMemHandle_v1:
        return sizeof(cydriver.CUipcMemHandle_v1){{endif}}
    {{if 'CUipcMemHandle' in found_types}}
    if objType == CUipcMemHandle:
        return sizeof(cydriver.CUipcMemHandle){{endif}}
    {{if 'CUstreamBatchMemOpParams_union' in found_struct}}
    if objType == CUstreamBatchMemOpParams_union:
        return sizeof(cydriver.CUstreamBatchMemOpParams_union){{endif}}
    {{if 'CUstreamBatchMemOpParams_v1' in found_types}}
    if objType == CUstreamBatchMemOpParams_v1:
        return sizeof(cydriver.CUstreamBatchMemOpParams_v1){{endif}}
    {{if 'CUstreamBatchMemOpParams' in found_types}}
    if objType == CUstreamBatchMemOpParams:
        return sizeof(cydriver.CUstreamBatchMemOpParams){{endif}}
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st' in found_struct}}
    if objType == CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st:
        return sizeof(cydriver.CUDA_BATCH_MEM_OP_NODE_PARAMS_v1_st){{endif}}
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v1' in found_types}}
    if objType == CUDA_BATCH_MEM_OP_NODE_PARAMS_v1:
        return sizeof(cydriver.CUDA_BATCH_MEM_OP_NODE_PARAMS_v1){{endif}}
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS' in found_types}}
    if objType == CUDA_BATCH_MEM_OP_NODE_PARAMS:
        return sizeof(cydriver.CUDA_BATCH_MEM_OP_NODE_PARAMS){{endif}}
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st' in found_struct}}
    if objType == CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st:
        return sizeof(cydriver.CUDA_BATCH_MEM_OP_NODE_PARAMS_v2_st){{endif}}
    {{if 'CUDA_BATCH_MEM_OP_NODE_PARAMS_v2' in found_types}}
    if objType == CUDA_BATCH_MEM_OP_NODE_PARAMS_v2:
        return sizeof(cydriver.CUDA_BATCH_MEM_OP_NODE_PARAMS_v2){{endif}}
    {{if 'CUasyncNotificationInfo_st' in found_struct}}
    if objType == CUasyncNotificationInfo_st:
        return sizeof(cydriver.CUasyncNotificationInfo_st){{endif}}
    {{if 'CUasyncNotificationInfo' in found_types}}
    if objType == CUasyncNotificationInfo:
        return sizeof(cydriver.CUasyncNotificationInfo){{endif}}
    {{if 'CUasyncCallback' in found_types}}
    if objType == CUasyncCallback:
        return sizeof(cydriver.CUasyncCallback){{endif}}
    {{if 'CUdevprop_st' in found_struct}}
    if objType == CUdevprop_st:
        return sizeof(cydriver.CUdevprop_st){{endif}}
    {{if 'CUdevprop_v1' in found_types}}
    if objType == CUdevprop_v1:
        return sizeof(cydriver.CUdevprop_v1){{endif}}
    {{if 'CUdevprop' in found_types}}
    if objType == CUdevprop:
        return sizeof(cydriver.CUdevprop){{endif}}
    {{if 'CUlinkState' in found_types}}
    if objType == CUlinkState:
        return sizeof(cydriver.CUlinkState){{endif}}
    {{if 'CUhostFn' in found_types}}
    if objType == CUhostFn:
        return sizeof(cydriver.CUhostFn){{endif}}
    {{if 'CUaccessPolicyWindow_st' in found_struct}}
    if objType == CUaccessPolicyWindow_st:
        return sizeof(cydriver.CUaccessPolicyWindow_st){{endif}}
    {{if 'CUaccessPolicyWindow_v1' in found_types}}
    if objType == CUaccessPolicyWindow_v1:
        return sizeof(cydriver.CUaccessPolicyWindow_v1){{endif}}
    {{if 'CUaccessPolicyWindow' in found_types}}
    if objType == CUaccessPolicyWindow:
        return sizeof(cydriver.CUaccessPolicyWindow){{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_st' in found_struct}}
    if objType == CUDA_KERNEL_NODE_PARAMS_st:
        return sizeof(cydriver.CUDA_KERNEL_NODE_PARAMS_st){{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v1' in found_types}}
    if objType == CUDA_KERNEL_NODE_PARAMS_v1:
        return sizeof(cydriver.CUDA_KERNEL_NODE_PARAMS_v1){{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2_st' in found_struct}}
    if objType == CUDA_KERNEL_NODE_PARAMS_v2_st:
        return sizeof(cydriver.CUDA_KERNEL_NODE_PARAMS_v2_st){{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v2' in found_types}}
    if objType == CUDA_KERNEL_NODE_PARAMS_v2:
        return sizeof(cydriver.CUDA_KERNEL_NODE_PARAMS_v2){{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS' in found_types}}
    if objType == CUDA_KERNEL_NODE_PARAMS:
        return sizeof(cydriver.CUDA_KERNEL_NODE_PARAMS){{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3_st' in found_struct}}
    if objType == CUDA_KERNEL_NODE_PARAMS_v3_st:
        return sizeof(cydriver.CUDA_KERNEL_NODE_PARAMS_v3_st){{endif}}
    {{if 'CUDA_KERNEL_NODE_PARAMS_v3' in found_types}}
    if objType == CUDA_KERNEL_NODE_PARAMS_v3:
        return sizeof(cydriver.CUDA_KERNEL_NODE_PARAMS_v3){{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_st' in found_struct}}
    if objType == CUDA_MEMSET_NODE_PARAMS_st:
        return sizeof(cydriver.CUDA_MEMSET_NODE_PARAMS_st){{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_v1' in found_types}}
    if objType == CUDA_MEMSET_NODE_PARAMS_v1:
        return sizeof(cydriver.CUDA_MEMSET_NODE_PARAMS_v1){{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS' in found_types}}
    if objType == CUDA_MEMSET_NODE_PARAMS:
        return sizeof(cydriver.CUDA_MEMSET_NODE_PARAMS){{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_v2_st' in found_struct}}
    if objType == CUDA_MEMSET_NODE_PARAMS_v2_st:
        return sizeof(cydriver.CUDA_MEMSET_NODE_PARAMS_v2_st){{endif}}
    {{if 'CUDA_MEMSET_NODE_PARAMS_v2' in found_types}}
    if objType == CUDA_MEMSET_NODE_PARAMS_v2:
        return sizeof(cydriver.CUDA_MEMSET_NODE_PARAMS_v2){{endif}}
    {{if 'CUDA_HOST_NODE_PARAMS_st' in found_struct}}
    if objType == CUDA_HOST_NODE_PARAMS_st:
        return sizeof(cydriver.CUDA_HOST_NODE_PARAMS_st){{endif}}
    {{if 'CUDA_HOST_NODE_PARAMS_v1' in found_types}}
    if objType == CUDA_HOST_NODE_PARAMS_v1:
        return sizeof(cydriver.CUDA_HOST_NODE_PARAMS_v1){{endif}}
    {{if 'CUDA_HOST_NODE_PARAMS' in found_types}}
    if objType == CUDA_HOST_NODE_PARAMS:
        return sizeof(cydriver.CUDA_HOST_NODE_PARAMS){{endif}}
    {{if 'CUDA_HOST_NODE_PARAMS_v2_st' in found_struct}}
    if objType == CUDA_HOST_NODE_PARAMS_v2_st:
        return sizeof(cydriver.CUDA_HOST_NODE_PARAMS_v2_st){{endif}}
    {{if 'CUDA_HOST_NODE_PARAMS_v2' in found_types}}
    if objType == CUDA_HOST_NODE_PARAMS_v2:
        return sizeof(cydriver.CUDA_HOST_NODE_PARAMS_v2){{endif}}
    {{if 'CUDA_CONDITIONAL_NODE_PARAMS' in found_struct}}
    if objType == CUDA_CONDITIONAL_NODE_PARAMS:
        return sizeof(cydriver.CUDA_CONDITIONAL_NODE_PARAMS){{endif}}
    {{if 'CUgraphEdgeData_st' in found_struct}}
    if objType == CUgraphEdgeData_st:
        return sizeof(cydriver.CUgraphEdgeData_st){{endif}}
    {{if 'CUgraphEdgeData' in found_types}}
    if objType == CUgraphEdgeData:
        return sizeof(cydriver.CUgraphEdgeData){{endif}}
    {{if 'CUDA_GRAPH_INSTANTIATE_PARAMS_st' in found_struct}}
    if objType == CUDA_GRAPH_INSTANTIATE_PARAMS_st:
        return sizeof(cydriver.CUDA_GRAPH_INSTANTIATE_PARAMS_st){{endif}}
    {{if 'CUDA_GRAPH_INSTANTIATE_PARAMS' in found_types}}
    if objType == CUDA_GRAPH_INSTANTIATE_PARAMS:
        return sizeof(cydriver.CUDA_GRAPH_INSTANTIATE_PARAMS){{endif}}
    {{if 'CUlaunchMemSyncDomainMap_st' in found_struct}}
    if objType == CUlaunchMemSyncDomainMap_st:
        return sizeof(cydriver.CUlaunchMemSyncDomainMap_st){{endif}}
    {{if 'CUlaunchMemSyncDomainMap' in found_types}}
    if objType == CUlaunchMemSyncDomainMap:
        return sizeof(cydriver.CUlaunchMemSyncDomainMap){{endif}}
    {{if 'CUlaunchAttributeValue_union' in found_struct}}
    if objType == CUlaunchAttributeValue_union:
        return sizeof(cydriver.CUlaunchAttributeValue_union){{endif}}
    {{if 'CUlaunchAttributeValue' in found_types}}
    if objType == CUlaunchAttributeValue:
        return sizeof(cydriver.CUlaunchAttributeValue){{endif}}
    {{if 'CUlaunchAttribute_st' in found_struct}}
    if objType == CUlaunchAttribute_st:
        return sizeof(cydriver.CUlaunchAttribute_st){{endif}}
    {{if 'CUlaunchAttribute' in found_types}}
    if objType == CUlaunchAttribute:
        return sizeof(cydriver.CUlaunchAttribute){{endif}}
    {{if 'CUlaunchConfig_st' in found_struct}}
    if objType == CUlaunchConfig_st:
        return sizeof(cydriver.CUlaunchConfig_st){{endif}}
    {{if 'CUlaunchConfig' in found_types}}
    if objType == CUlaunchConfig:
        return sizeof(cydriver.CUlaunchConfig){{endif}}
    {{if 'CUkernelNodeAttrValue_v1' in found_types}}
    if objType == CUkernelNodeAttrValue_v1:
        return sizeof(cydriver.CUkernelNodeAttrValue_v1){{endif}}
    {{if 'CUkernelNodeAttrValue' in found_types}}
    if objType == CUkernelNodeAttrValue:
        return sizeof(cydriver.CUkernelNodeAttrValue){{endif}}
    {{if 'CUstreamAttrValue_v1' in found_types}}
    if objType == CUstreamAttrValue_v1:
        return sizeof(cydriver.CUstreamAttrValue_v1){{endif}}
    {{if 'CUstreamAttrValue' in found_types}}
    if objType == CUstreamAttrValue:
        return sizeof(cydriver.CUstreamAttrValue){{endif}}
    {{if 'CUexecAffinitySmCount_st' in found_struct}}
    if objType == CUexecAffinitySmCount_st:
        return sizeof(cydriver.CUexecAffinitySmCount_st){{endif}}
    {{if 'CUexecAffinitySmCount_v1' in found_types}}
    if objType == CUexecAffinitySmCount_v1:
        return sizeof(cydriver.CUexecAffinitySmCount_v1){{endif}}
    {{if 'CUexecAffinitySmCount' in found_types}}
    if objType == CUexecAffinitySmCount:
        return sizeof(cydriver.CUexecAffinitySmCount){{endif}}
    {{if 'CUexecAffinityParam_st' in found_struct}}
    if objType == CUexecAffinityParam_st:
        return sizeof(cydriver.CUexecAffinityParam_st){{endif}}
    {{if 'CUexecAffinityParam_v1' in found_types}}
    if objType == CUexecAffinityParam_v1:
        return sizeof(cydriver.CUexecAffinityParam_v1){{endif}}
    {{if 'CUexecAffinityParam' in found_types}}
    if objType == CUexecAffinityParam:
        return sizeof(cydriver.CUexecAffinityParam){{endif}}
    {{if 'CUctxCigParam_st' in found_struct}}
    if objType == CUctxCigParam_st:
        return sizeof(cydriver.CUctxCigParam_st){{endif}}
    {{if 'CUctxCigParam' in found_types}}
    if objType == CUctxCigParam:
        return sizeof(cydriver.CUctxCigParam){{endif}}
    {{if 'CUctxCreateParams_st' in found_struct}}
    if objType == CUctxCreateParams_st:
        return sizeof(cydriver.CUctxCreateParams_st){{endif}}
    {{if 'CUctxCreateParams' in found_types}}
    if objType == CUctxCreateParams:
        return sizeof(cydriver.CUctxCreateParams){{endif}}
    {{if 'CUlibraryHostUniversalFunctionAndDataTable_st' in found_struct}}
    if objType == CUlibraryHostUniversalFunctionAndDataTable_st:
        return sizeof(cydriver.CUlibraryHostUniversalFunctionAndDataTable_st){{endif}}
    {{if 'CUlibraryHostUniversalFunctionAndDataTable' in found_types}}
    if objType == CUlibraryHostUniversalFunctionAndDataTable:
        return sizeof(cydriver.CUlibraryHostUniversalFunctionAndDataTable){{endif}}
    {{if 'CUstreamCallback' in found_types}}
    if objType == CUstreamCallback:
        return sizeof(cydriver.CUstreamCallback){{endif}}
    {{if 'CUoccupancyB2DSize' in found_types}}
    if objType == CUoccupancyB2DSize:
        return sizeof(cydriver.CUoccupancyB2DSize){{endif}}
    {{if 'CUDA_MEMCPY2D_st' in found_struct}}
    if objType == CUDA_MEMCPY2D_st:
        return sizeof(cydriver.CUDA_MEMCPY2D_st){{endif}}
    {{if 'CUDA_MEMCPY2D_v2' in found_types}}
    if objType == CUDA_MEMCPY2D_v2:
        return sizeof(cydriver.CUDA_MEMCPY2D_v2){{endif}}
    {{if 'CUDA_MEMCPY2D' in found_types}}
    if objType == CUDA_MEMCPY2D:
        return sizeof(cydriver.CUDA_MEMCPY2D){{endif}}
    {{if 'CUDA_MEMCPY3D_st' in found_struct}}
    if objType == CUDA_MEMCPY3D_st:
        return sizeof(cydriver.CUDA_MEMCPY3D_st){{endif}}
    {{if 'CUDA_MEMCPY3D_v2' in found_types}}
    if objType == CUDA_MEMCPY3D_v2:
        return sizeof(cydriver.CUDA_MEMCPY3D_v2){{endif}}
    {{if 'CUDA_MEMCPY3D' in found_types}}
    if objType == CUDA_MEMCPY3D:
        return sizeof(cydriver.CUDA_MEMCPY3D){{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_st' in found_struct}}
    if objType == CUDA_MEMCPY3D_PEER_st:
        return sizeof(cydriver.CUDA_MEMCPY3D_PEER_st){{endif}}
    {{if 'CUDA_MEMCPY3D_PEER_v1' in found_types}}
    if objType == CUDA_MEMCPY3D_PEER_v1:
        return sizeof(cydriver.CUDA_MEMCPY3D_PEER_v1){{endif}}
    {{if 'CUDA_MEMCPY3D_PEER' in found_types}}
    if objType == CUDA_MEMCPY3D_PEER:
        return sizeof(cydriver.CUDA_MEMCPY3D_PEER){{endif}}
    {{if 'CUDA_MEMCPY_NODE_PARAMS_st' in found_struct}}
    if objType == CUDA_MEMCPY_NODE_PARAMS_st:
        return sizeof(cydriver.CUDA_MEMCPY_NODE_PARAMS_st){{endif}}
    {{if 'CUDA_MEMCPY_NODE_PARAMS' in found_types}}
    if objType == CUDA_MEMCPY_NODE_PARAMS:
        return sizeof(cydriver.CUDA_MEMCPY_NODE_PARAMS){{endif}}
    {{if 'CUDA_ARRAY_DESCRIPTOR_st' in found_struct}}
    if objType == CUDA_ARRAY_DESCRIPTOR_st:
        return sizeof(cydriver.CUDA_ARRAY_DESCRIPTOR_st){{endif}}
    {{if 'CUDA_ARRAY_DESCRIPTOR_v2' in found_types}}
    if objType == CUDA_ARRAY_DESCRIPTOR_v2:
        return sizeof(cydriver.CUDA_ARRAY_DESCRIPTOR_v2){{endif}}
    {{if 'CUDA_ARRAY_DESCRIPTOR' in found_types}}
    if objType == CUDA_ARRAY_DESCRIPTOR:
        return sizeof(cydriver.CUDA_ARRAY_DESCRIPTOR){{endif}}
    {{if 'CUDA_ARRAY3D_DESCRIPTOR_st' in found_struct}}
    if objType == CUDA_ARRAY3D_DESCRIPTOR_st:
        return sizeof(cydriver.CUDA_ARRAY3D_DESCRIPTOR_st){{endif}}
    {{if 'CUDA_ARRAY3D_DESCRIPTOR_v2' in found_types}}
    if objType == CUDA_ARRAY3D_DESCRIPTOR_v2:
        return sizeof(cydriver.CUDA_ARRAY3D_DESCRIPTOR_v2){{endif}}
    {{if 'CUDA_ARRAY3D_DESCRIPTOR' in found_types}}
    if objType == CUDA_ARRAY3D_DESCRIPTOR:
        return sizeof(cydriver.CUDA_ARRAY3D_DESCRIPTOR){{endif}}
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_st' in found_struct}}
    if objType == CUDA_ARRAY_SPARSE_PROPERTIES_st:
        return sizeof(cydriver.CUDA_ARRAY_SPARSE_PROPERTIES_st){{endif}}
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES_v1' in found_types}}
    if objType == CUDA_ARRAY_SPARSE_PROPERTIES_v1:
        return sizeof(cydriver.CUDA_ARRAY_SPARSE_PROPERTIES_v1){{endif}}
    {{if 'CUDA_ARRAY_SPARSE_PROPERTIES' in found_types}}
    if objType == CUDA_ARRAY_SPARSE_PROPERTIES:
        return sizeof(cydriver.CUDA_ARRAY_SPARSE_PROPERTIES){{endif}}
    {{if 'CUDA_ARRAY_MEMORY_REQUIREMENTS_st' in found_struct}}
    if objType == CUDA_ARRAY_MEMORY_REQUIREMENTS_st:
        return sizeof(cydriver.CUDA_ARRAY_MEMORY_REQUIREMENTS_st){{endif}}
    {{if 'CUDA_ARRAY_MEMORY_REQUIREMENTS_v1' in found_types}}
    if objType == CUDA_ARRAY_MEMORY_REQUIREMENTS_v1:
        return sizeof(cydriver.CUDA_ARRAY_MEMORY_REQUIREMENTS_v1){{endif}}
    {{if 'CUDA_ARRAY_MEMORY_REQUIREMENTS' in found_types}}
    if objType == CUDA_ARRAY_MEMORY_REQUIREMENTS:
        return sizeof(cydriver.CUDA_ARRAY_MEMORY_REQUIREMENTS){{endif}}
    {{if 'CUDA_RESOURCE_DESC_st' in found_struct}}
    if objType == CUDA_RESOURCE_DESC_st:
        return sizeof(cydriver.CUDA_RESOURCE_DESC_st){{endif}}
    {{if 'CUDA_RESOURCE_DESC_v1' in found_types}}
    if objType == CUDA_RESOURCE_DESC_v1:
        return sizeof(cydriver.CUDA_RESOURCE_DESC_v1){{endif}}
    {{if 'CUDA_RESOURCE_DESC' in found_types}}
    if objType == CUDA_RESOURCE_DESC:
        return sizeof(cydriver.CUDA_RESOURCE_DESC){{endif}}
    {{if 'CUDA_TEXTURE_DESC_st' in found_struct}}
    if objType == CUDA_TEXTURE_DESC_st:
        return sizeof(cydriver.CUDA_TEXTURE_DESC_st){{endif}}
    {{if 'CUDA_TEXTURE_DESC_v1' in found_types}}
    if objType == CUDA_TEXTURE_DESC_v1:
        return sizeof(cydriver.CUDA_TEXTURE_DESC_v1){{endif}}
    {{if 'CUDA_TEXTURE_DESC' in found_types}}
    if objType == CUDA_TEXTURE_DESC:
        return sizeof(cydriver.CUDA_TEXTURE_DESC){{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_st' in found_struct}}
    if objType == CUDA_RESOURCE_VIEW_DESC_st:
        return sizeof(cydriver.CUDA_RESOURCE_VIEW_DESC_st){{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC_v1' in found_types}}
    if objType == CUDA_RESOURCE_VIEW_DESC_v1:
        return sizeof(cydriver.CUDA_RESOURCE_VIEW_DESC_v1){{endif}}
    {{if 'CUDA_RESOURCE_VIEW_DESC' in found_types}}
    if objType == CUDA_RESOURCE_VIEW_DESC:
        return sizeof(cydriver.CUDA_RESOURCE_VIEW_DESC){{endif}}
    {{if 'CUtensorMap_st' in found_struct}}
    if objType == CUtensorMap_st:
        return sizeof(cydriver.CUtensorMap_st){{endif}}
    {{if 'CUtensorMap' in found_types}}
    if objType == CUtensorMap:
        return sizeof(cydriver.CUtensorMap){{endif}}
    {{if 'CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st' in found_struct}}
    if objType == CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st:
        return sizeof(cydriver.CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st){{endif}}
    {{if 'CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1' in found_types}}
    if objType == CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1:
        return sizeof(cydriver.CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1){{endif}}
    {{if 'CUDA_POINTER_ATTRIBUTE_P2P_TOKENS' in found_types}}
    if objType == CUDA_POINTER_ATTRIBUTE_P2P_TOKENS:
        return sizeof(cydriver.CUDA_POINTER_ATTRIBUTE_P2P_TOKENS){{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_st' in found_struct}}
    if objType == CUDA_LAUNCH_PARAMS_st:
        return sizeof(cydriver.CUDA_LAUNCH_PARAMS_st){{endif}}
    {{if 'CUDA_LAUNCH_PARAMS_v1' in found_types}}
    if objType == CUDA_LAUNCH_PARAMS_v1:
        return sizeof(cydriver.CUDA_LAUNCH_PARAMS_v1){{endif}}
    {{if 'CUDA_LAUNCH_PARAMS' in found_types}}
    if objType == CUDA_LAUNCH_PARAMS:
        return sizeof(cydriver.CUDA_LAUNCH_PARAMS){{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st' in found_struct}}
    if objType == CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st:
        return sizeof(cydriver.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st){{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1' in found_types}}
    if objType == CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1:
        return sizeof(cydriver.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1){{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_HANDLE_DESC' in found_types}}
    if objType == CUDA_EXTERNAL_MEMORY_HANDLE_DESC:
        return sizeof(cydriver.CUDA_EXTERNAL_MEMORY_HANDLE_DESC){{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st' in found_struct}}
    if objType == CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st:
        return sizeof(cydriver.CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st){{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1' in found_types}}
    if objType == CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1:
        return sizeof(cydriver.CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1){{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_BUFFER_DESC' in found_types}}
    if objType == CUDA_EXTERNAL_MEMORY_BUFFER_DESC:
        return sizeof(cydriver.CUDA_EXTERNAL_MEMORY_BUFFER_DESC){{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st' in found_struct}}
    if objType == CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st:
        return sizeof(cydriver.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st){{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1' in found_types}}
    if objType == CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1:
        return sizeof(cydriver.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1){{endif}}
    {{if 'CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC' in found_types}}
    if objType == CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC:
        return sizeof(cydriver.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC){{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st' in found_struct}}
    if objType == CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st:
        return sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st){{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1' in found_types}}
    if objType == CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1:
        return sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1){{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC' in found_types}}
    if objType == CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC:
        return sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC){{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st' in found_struct}}
    if objType == CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st:
        return sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st){{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1' in found_types}}
    if objType == CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1:
        return sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1){{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS' in found_types}}
    if objType == CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS:
        return sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS){{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st' in found_struct}}
    if objType == CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st:
        return sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st){{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1' in found_types}}
    if objType == CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1:
        return sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1){{endif}}
    {{if 'CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS' in found_types}}
    if objType == CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS:
        return sizeof(cydriver.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS){{endif}}
    {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st' in found_struct}}
    if objType == CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st:
        return sizeof(cydriver.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st){{endif}}
    {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1' in found_types}}
    if objType == CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1:
        return sizeof(cydriver.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1){{endif}}
    {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS' in found_types}}
    if objType == CUDA_EXT_SEM_SIGNAL_NODE_PARAMS:
        return sizeof(cydriver.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS){{endif}}
    {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st' in found_struct}}
    if objType == CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st:
        return sizeof(cydriver.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2_st){{endif}}
    {{if 'CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2' in found_types}}
    if objType == CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2:
        return sizeof(cydriver.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2){{endif}}
    {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_st' in found_struct}}
    if objType == CUDA_EXT_SEM_WAIT_NODE_PARAMS_st:
        return sizeof(cydriver.CUDA_EXT_SEM_WAIT_NODE_PARAMS_st){{endif}}
    {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1' in found_types}}
    if objType == CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1:
        return sizeof(cydriver.CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1){{endif}}
    {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS' in found_types}}
    if objType == CUDA_EXT_SEM_WAIT_NODE_PARAMS:
        return sizeof(cydriver.CUDA_EXT_SEM_WAIT_NODE_PARAMS){{endif}}
    {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st' in found_struct}}
    if objType == CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st:
        return sizeof(cydriver.CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2_st){{endif}}
    {{if 'CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2' in found_types}}
    if objType == CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2:
        return sizeof(cydriver.CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2){{endif}}
    {{if 'CUmemGenericAllocationHandle_v1' in found_types}}
    if objType == CUmemGenericAllocationHandle_v1:
        return sizeof(cydriver.CUmemGenericAllocationHandle_v1){{endif}}
    {{if 'CUmemGenericAllocationHandle' in found_types}}
    if objType == CUmemGenericAllocationHandle:
        return sizeof(cydriver.CUmemGenericAllocationHandle){{endif}}
    {{if 'CUarrayMapInfo_st' in found_struct}}
    if objType == CUarrayMapInfo_st:
        return sizeof(cydriver.CUarrayMapInfo_st){{endif}}
    {{if 'CUarrayMapInfo_v1' in found_types}}
    if objType == CUarrayMapInfo_v1:
        return sizeof(cydriver.CUarrayMapInfo_v1){{endif}}
    {{if 'CUarrayMapInfo' in found_types}}
    if objType == CUarrayMapInfo:
        return sizeof(cydriver.CUarrayMapInfo){{endif}}
    {{if 'CUmemLocation_st' in found_struct}}
    if objType == CUmemLocation_st:
        return sizeof(cydriver.CUmemLocation_st){{endif}}
    {{if 'CUmemLocation_v1' in found_types}}
    if objType == CUmemLocation_v1:
        return sizeof(cydriver.CUmemLocation_v1){{endif}}
    {{if 'CUmemLocation' in found_types}}
    if objType == CUmemLocation:
        return sizeof(cydriver.CUmemLocation){{endif}}
    {{if 'CUmemAllocationProp_st' in found_struct}}
    if objType == CUmemAllocationProp_st:
        return sizeof(cydriver.CUmemAllocationProp_st){{endif}}
    {{if 'CUmemAllocationProp_v1' in found_types}}
    if objType == CUmemAllocationProp_v1:
        return sizeof(cydriver.CUmemAllocationProp_v1){{endif}}
    {{if 'CUmemAllocationProp' in found_types}}
    if objType == CUmemAllocationProp:
        return sizeof(cydriver.CUmemAllocationProp){{endif}}
    {{if 'CUmulticastObjectProp_st' in found_struct}}
    if objType == CUmulticastObjectProp_st:
        return sizeof(cydriver.CUmulticastObjectProp_st){{endif}}
    {{if 'CUmulticastObjectProp_v1' in found_types}}
    if objType == CUmulticastObjectProp_v1:
        return sizeof(cydriver.CUmulticastObjectProp_v1){{endif}}
    {{if 'CUmulticastObjectProp' in found_types}}
    if objType == CUmulticastObjectProp:
        return sizeof(cydriver.CUmulticastObjectProp){{endif}}
    {{if 'CUmemAccessDesc_st' in found_struct}}
    if objType == CUmemAccessDesc_st:
        return sizeof(cydriver.CUmemAccessDesc_st){{endif}}
    {{if 'CUmemAccessDesc_v1' in found_types}}
    if objType == CUmemAccessDesc_v1:
        return sizeof(cydriver.CUmemAccessDesc_v1){{endif}}
    {{if 'CUmemAccessDesc' in found_types}}
    if objType == CUmemAccessDesc:
        return sizeof(cydriver.CUmemAccessDesc){{endif}}
    {{if 'CUgraphExecUpdateResultInfo_st' in found_struct}}
    if objType == CUgraphExecUpdateResultInfo_st:
        return sizeof(cydriver.CUgraphExecUpdateResultInfo_st){{endif}}
    {{if 'CUgraphExecUpdateResultInfo_v1' in found_types}}
    if objType == CUgraphExecUpdateResultInfo_v1:
        return sizeof(cydriver.CUgraphExecUpdateResultInfo_v1){{endif}}
    {{if 'CUgraphExecUpdateResultInfo' in found_types}}
    if objType == CUgraphExecUpdateResultInfo:
        return sizeof(cydriver.CUgraphExecUpdateResultInfo){{endif}}
    {{if 'CUmemPoolProps_st' in found_struct}}
    if objType == CUmemPoolProps_st:
        return sizeof(cydriver.CUmemPoolProps_st){{endif}}
    {{if 'CUmemPoolProps_v1' in found_types}}
    if objType == CUmemPoolProps_v1:
        return sizeof(cydriver.CUmemPoolProps_v1){{endif}}
    {{if 'CUmemPoolProps' in found_types}}
    if objType == CUmemPoolProps:
        return sizeof(cydriver.CUmemPoolProps){{endif}}
    {{if 'CUmemPoolPtrExportData_st' in found_struct}}
    if objType == CUmemPoolPtrExportData_st:
        return sizeof(cydriver.CUmemPoolPtrExportData_st){{endif}}
    {{if 'CUmemPoolPtrExportData_v1' in found_types}}
    if objType == CUmemPoolPtrExportData_v1:
        return sizeof(cydriver.CUmemPoolPtrExportData_v1){{endif}}
    {{if 'CUmemPoolPtrExportData' in found_types}}
    if objType == CUmemPoolPtrExportData:
        return sizeof(cydriver.CUmemPoolPtrExportData){{endif}}
    {{if 'CUmemcpyAttributes_st' in found_struct}}
    if objType == CUmemcpyAttributes_st:
        return sizeof(cydriver.CUmemcpyAttributes_st){{endif}}
    {{if 'CUmemcpyAttributes_v1' in found_types}}
    if objType == CUmemcpyAttributes_v1:
        return sizeof(cydriver.CUmemcpyAttributes_v1){{endif}}
    {{if 'CUmemcpyAttributes' in found_types}}
    if objType == CUmemcpyAttributes:
        return sizeof(cydriver.CUmemcpyAttributes){{endif}}
    {{if 'CUoffset3D_st' in found_struct}}
    if objType == CUoffset3D_st:
        return sizeof(cydriver.CUoffset3D_st){{endif}}
    {{if 'CUoffset3D_v1' in found_types}}
    if objType == CUoffset3D_v1:
        return sizeof(cydriver.CUoffset3D_v1){{endif}}
    {{if 'CUoffset3D' in found_types}}
    if objType == CUoffset3D:
        return sizeof(cydriver.CUoffset3D){{endif}}
    {{if 'CUextent3D_st' in found_struct}}
    if objType == CUextent3D_st:
        return sizeof(cydriver.CUextent3D_st){{endif}}
    {{if 'CUextent3D_v1' in found_types}}
    if objType == CUextent3D_v1:
        return sizeof(cydriver.CUextent3D_v1){{endif}}
    {{if 'CUextent3D' in found_types}}
    if objType == CUextent3D:
        return sizeof(cydriver.CUextent3D){{endif}}
    {{if 'CUmemcpy3DOperand_st' in found_struct}}
    if objType == CUmemcpy3DOperand_st:
        return sizeof(cydriver.CUmemcpy3DOperand_st){{endif}}
    {{if 'CUmemcpy3DOperand_v1' in found_types}}
    if objType == CUmemcpy3DOperand_v1:
        return sizeof(cydriver.CUmemcpy3DOperand_v1){{endif}}
    {{if 'CUmemcpy3DOperand' in found_types}}
    if objType == CUmemcpy3DOperand:
        return sizeof(cydriver.CUmemcpy3DOperand){{endif}}
    {{if 'CUDA_MEMCPY3D_BATCH_OP_st' in found_struct}}
    if objType == CUDA_MEMCPY3D_BATCH_OP_st:
        return sizeof(cydriver.CUDA_MEMCPY3D_BATCH_OP_st){{endif}}
    {{if 'CUDA_MEMCPY3D_BATCH_OP_v1' in found_types}}
    if objType == CUDA_MEMCPY3D_BATCH_OP_v1:
        return sizeof(cydriver.CUDA_MEMCPY3D_BATCH_OP_v1){{endif}}
    {{if 'CUDA_MEMCPY3D_BATCH_OP' in found_types}}
    if objType == CUDA_MEMCPY3D_BATCH_OP:
        return sizeof(cydriver.CUDA_MEMCPY3D_BATCH_OP){{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1_st' in found_struct}}
    if objType == CUDA_MEM_ALLOC_NODE_PARAMS_v1_st:
        return sizeof(cydriver.CUDA_MEM_ALLOC_NODE_PARAMS_v1_st){{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v1' in found_types}}
    if objType == CUDA_MEM_ALLOC_NODE_PARAMS_v1:
        return sizeof(cydriver.CUDA_MEM_ALLOC_NODE_PARAMS_v1){{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS' in found_types}}
    if objType == CUDA_MEM_ALLOC_NODE_PARAMS:
        return sizeof(cydriver.CUDA_MEM_ALLOC_NODE_PARAMS){{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2_st' in found_struct}}
    if objType == CUDA_MEM_ALLOC_NODE_PARAMS_v2_st:
        return sizeof(cydriver.CUDA_MEM_ALLOC_NODE_PARAMS_v2_st){{endif}}
    {{if 'CUDA_MEM_ALLOC_NODE_PARAMS_v2' in found_types}}
    if objType == CUDA_MEM_ALLOC_NODE_PARAMS_v2:
        return sizeof(cydriver.CUDA_MEM_ALLOC_NODE_PARAMS_v2){{endif}}
    {{if 'CUDA_MEM_FREE_NODE_PARAMS_st' in found_struct}}
    if objType == CUDA_MEM_FREE_NODE_PARAMS_st:
        return sizeof(cydriver.CUDA_MEM_FREE_NODE_PARAMS_st){{endif}}
    {{if 'CUDA_MEM_FREE_NODE_PARAMS' in found_types}}
    if objType == CUDA_MEM_FREE_NODE_PARAMS:
        return sizeof(cydriver.CUDA_MEM_FREE_NODE_PARAMS){{endif}}
    {{if 'CUDA_CHILD_GRAPH_NODE_PARAMS_st' in found_struct}}
    if objType == CUDA_CHILD_GRAPH_NODE_PARAMS_st:
        return sizeof(cydriver.CUDA_CHILD_GRAPH_NODE_PARAMS_st){{endif}}
    {{if 'CUDA_CHILD_GRAPH_NODE_PARAMS' in found_types}}
    if objType == CUDA_CHILD_GRAPH_NODE_PARAMS:
        return sizeof(cydriver.CUDA_CHILD_GRAPH_NODE_PARAMS){{endif}}
    {{if 'CUDA_EVENT_RECORD_NODE_PARAMS_st' in found_struct}}
    if objType == CUDA_EVENT_RECORD_NODE_PARAMS_st:
        return sizeof(cydriver.CUDA_EVENT_RECORD_NODE_PARAMS_st){{endif}}
    {{if 'CUDA_EVENT_RECORD_NODE_PARAMS' in found_types}}
    if objType == CUDA_EVENT_RECORD_NODE_PARAMS:
        return sizeof(cydriver.CUDA_EVENT_RECORD_NODE_PARAMS){{endif}}
    {{if 'CUDA_EVENT_WAIT_NODE_PARAMS_st' in found_struct}}
    if objType == CUDA_EVENT_WAIT_NODE_PARAMS_st:
        return sizeof(cydriver.CUDA_EVENT_WAIT_NODE_PARAMS_st){{endif}}
    {{if 'CUDA_EVENT_WAIT_NODE_PARAMS' in found_types}}
    if objType == CUDA_EVENT_WAIT_NODE_PARAMS:
        return sizeof(cydriver.CUDA_EVENT_WAIT_NODE_PARAMS){{endif}}
    {{if 'CUgraphNodeParams_st' in found_struct}}
    if objType == CUgraphNodeParams_st:
        return sizeof(cydriver.CUgraphNodeParams_st){{endif}}
    {{if 'CUgraphNodeParams' in found_types}}
    if objType == CUgraphNodeParams:
        return sizeof(cydriver.CUgraphNodeParams){{endif}}
    {{if 'CUcheckpointLockArgs_st' in found_struct}}
    if objType == CUcheckpointLockArgs_st:
        return sizeof(cydriver.CUcheckpointLockArgs_st){{endif}}
    {{if 'CUcheckpointLockArgs' in found_types}}
    if objType == CUcheckpointLockArgs:
        return sizeof(cydriver.CUcheckpointLockArgs){{endif}}
    {{if 'CUcheckpointCheckpointArgs_st' in found_struct}}
    if objType == CUcheckpointCheckpointArgs_st:
        return sizeof(cydriver.CUcheckpointCheckpointArgs_st){{endif}}
    {{if 'CUcheckpointCheckpointArgs' in found_types}}
    if objType == CUcheckpointCheckpointArgs:
        return sizeof(cydriver.CUcheckpointCheckpointArgs){{endif}}
    {{if 'CUcheckpointGpuPair_st' in found_struct}}
    if objType == CUcheckpointGpuPair_st:
        return sizeof(cydriver.CUcheckpointGpuPair_st){{endif}}
    {{if 'CUcheckpointGpuPair' in found_types}}
    if objType == CUcheckpointGpuPair:
        return sizeof(cydriver.CUcheckpointGpuPair){{endif}}
    {{if 'CUcheckpointRestoreArgs_st' in found_struct}}
    if objType == CUcheckpointRestoreArgs_st:
        return sizeof(cydriver.CUcheckpointRestoreArgs_st){{endif}}
    {{if 'CUcheckpointRestoreArgs' in found_types}}
    if objType == CUcheckpointRestoreArgs:
        return sizeof(cydriver.CUcheckpointRestoreArgs){{endif}}
    {{if 'CUcheckpointUnlockArgs_st' in found_struct}}
    if objType == CUcheckpointUnlockArgs_st:
        return sizeof(cydriver.CUcheckpointUnlockArgs_st){{endif}}
    {{if 'CUcheckpointUnlockArgs' in found_types}}
    if objType == CUcheckpointUnlockArgs:
        return sizeof(cydriver.CUcheckpointUnlockArgs){{endif}}
    {{if 'CUmemDecompressParams_st' in found_struct}}
    if objType == CUmemDecompressParams_st:
        return sizeof(cydriver.CUmemDecompressParams_st){{endif}}
    {{if 'CUmemDecompressParams' in found_types}}
    if objType == CUmemDecompressParams:
        return sizeof(cydriver.CUmemDecompressParams){{endif}}
    {{if 'CUdevResourceDesc' in found_types}}
    if objType == CUdevResourceDesc:
        return sizeof(cydriver.CUdevResourceDesc){{endif}}
    {{if 'CUdevSmResource_st' in found_struct}}
    if objType == CUdevSmResource_st:
        return sizeof(cydriver.CUdevSmResource_st){{endif}}
    {{if 'CUdevSmResource' in found_types}}
    if objType == CUdevSmResource:
        return sizeof(cydriver.CUdevSmResource){{endif}}
    {{if 'CUdevResource_st' in found_struct}}
    if objType == CUdevResource_st:
        return sizeof(cydriver.CUdevResource_st){{endif}}
    {{if 'struct CUdevResource_st' in found_types}}
    if objType == CUdevResource_v1:
        return sizeof(cydriver.CUdevResource_v1){{endif}}
    {{if 'struct CUdevResource_st' in found_types}}
    if objType == CUdevResource:
        return sizeof(cydriver.CUdevResource){{endif}}
    {{if 'CUlogsCallbackHandle' in found_types}}
    if objType == CUlogsCallbackHandle:
        return sizeof(cydriver.CUlogsCallbackHandle){{endif}}
    {{if 'CUlogsCallback' in found_types}}
    if objType == CUlogsCallback:
        return sizeof(cydriver.CUlogsCallback){{endif}}
    {{if 'CUlogIterator' in found_types}}
    if objType == CUlogIterator:
        return sizeof(cydriver.CUlogIterator){{endif}}
    {{if True}}
    if objType == CUeglFrame_st:
        return sizeof(cydriver.CUeglFrame_st){{endif}}
    {{if True}}
    if objType == CUeglFrame_v1:
        return sizeof(cydriver.CUeglFrame_v1){{endif}}
    {{if True}}
    if objType == CUeglFrame:
        return sizeof(cydriver.CUeglFrame){{endif}}
    {{if True}}
    if objType == CUeglStreamConnection:
        return sizeof(cydriver.CUeglStreamConnection){{endif}}
    {{if True}}
    if objType == GLenum:
        return sizeof(cydriver.GLenum){{endif}}
    {{if True}}
    if objType == GLuint:
        return sizeof(cydriver.GLuint){{endif}}
    {{if True}}
    if objType == EGLImageKHR:
        return sizeof(cydriver.EGLImageKHR){{endif}}
    {{if True}}
    if objType == EGLStreamKHR:
        return sizeof(cydriver.EGLStreamKHR){{endif}}
    {{if True}}
    if objType == EGLint:
        return sizeof(cydriver.EGLint){{endif}}
    {{if True}}
    if objType == EGLSyncKHR:
        return sizeof(cydriver.EGLSyncKHR){{endif}}
    {{if True}}
    if objType == VdpDevice:
        return sizeof(cydriver.VdpDevice){{endif}}
    {{if True}}
    if objType == VdpGetProcAddress:
        return sizeof(cydriver.VdpGetProcAddress){{endif}}
    {{if True}}
    if objType == VdpVideoSurface:
        return sizeof(cydriver.VdpVideoSurface){{endif}}
    {{if True}}
    if objType == VdpOutputSurface:
        return sizeof(cydriver.VdpOutputSurface){{endif}}
    raise TypeError("Unknown type: " + str(objType))

cdef int _add_native_handle_getters() except?-1:
    from cuda.bindings.utils import _add_cuda_native_handle_getter
    {{if 'CUcontext' in found_types}}
    def CUcontext_getter(CUcontext x): return <uintptr_t><void*><cydriver.CUcontext>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUcontext, CUcontext_getter)
    {{endif}}
    {{if 'CUmodule' in found_types}}
    def CUmodule_getter(CUmodule x): return <uintptr_t><void*><cydriver.CUmodule>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUmodule, CUmodule_getter)
    {{endif}}
    {{if 'CUfunction' in found_types}}
    def CUfunction_getter(CUfunction x): return <uintptr_t><void*><cydriver.CUfunction>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUfunction, CUfunction_getter)
    {{endif}}
    {{if 'CUlibrary' in found_types}}
    def CUlibrary_getter(CUlibrary x): return <uintptr_t><void*><cydriver.CUlibrary>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUlibrary, CUlibrary_getter)
    {{endif}}
    {{if 'CUkernel' in found_types}}
    def CUkernel_getter(CUkernel x): return <uintptr_t><void*><cydriver.CUkernel>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUkernel, CUkernel_getter)
    {{endif}}
    {{if 'CUarray' in found_types}}
    def CUarray_getter(CUarray x): return <uintptr_t><void*><cydriver.CUarray>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUarray, CUarray_getter)
    {{endif}}
    {{if 'CUmipmappedArray' in found_types}}
    def CUmipmappedArray_getter(CUmipmappedArray x): return <uintptr_t><void*><cydriver.CUmipmappedArray>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUmipmappedArray, CUmipmappedArray_getter)
    {{endif}}
    {{if 'CUtexref' in found_types}}
    def CUtexref_getter(CUtexref x): return <uintptr_t><void*><cydriver.CUtexref>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUtexref, CUtexref_getter)
    {{endif}}
    {{if 'CUsurfref' in found_types}}
    def CUsurfref_getter(CUsurfref x): return <uintptr_t><void*><cydriver.CUsurfref>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUsurfref, CUsurfref_getter)
    {{endif}}
    {{if 'CUevent' in found_types}}
    def CUevent_getter(CUevent x): return <uintptr_t><void*><cydriver.CUevent>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUevent, CUevent_getter)
    {{endif}}
    {{if 'CUstream' in found_types}}
    def CUstream_getter(CUstream x): return <uintptr_t><void*><cydriver.CUstream>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUstream, CUstream_getter)
    {{endif}}
    {{if 'CUgraphicsResource' in found_types}}
    def CUgraphicsResource_getter(CUgraphicsResource x): return <uintptr_t><void*><cydriver.CUgraphicsResource>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUgraphicsResource, CUgraphicsResource_getter)
    {{endif}}
    {{if 'CUexternalMemory' in found_types}}
    def CUexternalMemory_getter(CUexternalMemory x): return <uintptr_t><void*><cydriver.CUexternalMemory>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUexternalMemory, CUexternalMemory_getter)
    {{endif}}
    {{if 'CUexternalSemaphore' in found_types}}
    def CUexternalSemaphore_getter(CUexternalSemaphore x): return <uintptr_t><void*><cydriver.CUexternalSemaphore>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUexternalSemaphore, CUexternalSemaphore_getter)
    {{endif}}
    {{if 'CUgraph' in found_types}}
    def CUgraph_getter(CUgraph x): return <uintptr_t><void*><cydriver.CUgraph>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUgraph, CUgraph_getter)
    {{endif}}
    {{if 'CUgraphNode' in found_types}}
    def CUgraphNode_getter(CUgraphNode x): return <uintptr_t><void*><cydriver.CUgraphNode>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUgraphNode, CUgraphNode_getter)
    {{endif}}
    {{if 'CUgraphExec' in found_types}}
    def CUgraphExec_getter(CUgraphExec x): return <uintptr_t><void*><cydriver.CUgraphExec>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUgraphExec, CUgraphExec_getter)
    {{endif}}
    {{if 'CUmemoryPool' in found_types}}
    def CUmemoryPool_getter(CUmemoryPool x): return <uintptr_t><void*><cydriver.CUmemoryPool>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUmemoryPool, CUmemoryPool_getter)
    {{endif}}
    {{if 'CUuserObject' in found_types}}
    def CUuserObject_getter(CUuserObject x): return <uintptr_t><void*><cydriver.CUuserObject>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUuserObject, CUuserObject_getter)
    {{endif}}
    {{if 'CUgraphDeviceNode' in found_types}}
    def CUgraphDeviceNode_getter(CUgraphDeviceNode x): return <uintptr_t><void*><cydriver.CUgraphDeviceNode>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUgraphDeviceNode, CUgraphDeviceNode_getter)
    {{endif}}
    {{if 'CUasyncCallbackHandle' in found_types}}
    def CUasyncCallbackHandle_getter(CUasyncCallbackHandle x): return <uintptr_t><void*><cydriver.CUasyncCallbackHandle>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUasyncCallbackHandle, CUasyncCallbackHandle_getter)
    {{endif}}
    {{if 'CUgreenCtx' in found_types}}
    def CUgreenCtx_getter(CUgreenCtx x): return <uintptr_t><void*><cydriver.CUgreenCtx>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUgreenCtx, CUgreenCtx_getter)
    {{endif}}
    {{if 'CUlinkState' in found_types}}
    def CUlinkState_getter(CUlinkState x): return <uintptr_t><void*><cydriver.CUlinkState>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUlinkState, CUlinkState_getter)
    {{endif}}
    {{if 'CUdevResourceDesc' in found_types}}
    def CUdevResourceDesc_getter(CUdevResourceDesc x): return <uintptr_t><void*><cydriver.CUdevResourceDesc>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUdevResourceDesc, CUdevResourceDesc_getter)
    {{endif}}
    {{if 'CUlogsCallbackHandle' in found_types}}
    def CUlogsCallbackHandle_getter(CUlogsCallbackHandle x): return <uintptr_t><void*><cydriver.CUlogsCallbackHandle>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUlogsCallbackHandle, CUlogsCallbackHandle_getter)
    {{endif}}
    {{if True}}
    def CUeglStreamConnection_getter(CUeglStreamConnection x): return <uintptr_t><void*><cydriver.CUeglStreamConnection>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(CUeglStreamConnection, CUeglStreamConnection_getter)
    {{endif}}
    {{if True}}
    def EGLImageKHR_getter(EGLImageKHR x): return <uintptr_t><void*><cydriver.EGLImageKHR>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(EGLImageKHR, EGLImageKHR_getter)
    {{endif}}
    {{if True}}
    def EGLStreamKHR_getter(EGLStreamKHR x): return <uintptr_t><void*><cydriver.EGLStreamKHR>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(EGLStreamKHR, EGLStreamKHR_getter)
    {{endif}}
    {{if True}}
    def EGLSyncKHR_getter(EGLSyncKHR x): return <uintptr_t><void*><cydriver.EGLSyncKHR>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(EGLSyncKHR, EGLSyncKHR_getter)
    {{endif}}
    return 0
_add_native_handle_getters()

