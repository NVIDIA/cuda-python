# SPDX-FileCopyrightText: Copyright (c) 2021-2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: LicenseRef-NVIDIA-SOFTWARE-LICENSE

# This code was automatically generated with version 13.1.0. Do not modify it directly.
from typing import Any, Optional
import cython
import ctypes
from libc.stdlib cimport calloc, malloc, free
from libc cimport string
from libc.stdint cimport int32_t, uint32_t, int64_t, uint64_t, uintptr_t
from libc.stddef cimport wchar_t
from libc.limits cimport CHAR_MIN
from libcpp.vector cimport vector
from cpython.buffer cimport PyObject_CheckBuffer, PyObject_GetBuffer, PyBuffer_Release, PyBUF_SIMPLE, PyBUF_ANY_CONTIGUOUS
from cpython.bytes cimport PyBytes_FromStringAndSize
from ._internal._fast_enum import FastEnum as _FastEnum
import cuda.bindings.driver
from libcpp.map cimport map

import cuda.bindings.driver as _driver
_driver = _driver.__dict__
include "_lib/utils.pxi"

ctypedef unsigned long long signed_char_ptr
ctypedef unsigned long long unsigned_char_ptr
ctypedef unsigned long long char_ptr
ctypedef unsigned long long short_ptr
ctypedef unsigned long long unsigned_short_ptr
ctypedef unsigned long long int_ptr
ctypedef unsigned long long long_int_ptr
ctypedef unsigned long long long_long_int_ptr
ctypedef unsigned long long unsigned_int_ptr
ctypedef unsigned long long unsigned_long_int_ptr
ctypedef unsigned long long unsigned_long_long_int_ptr
ctypedef unsigned long long uint32_t_ptr
ctypedef unsigned long long uint64_t_ptr
ctypedef unsigned long long int32_t_ptr
ctypedef unsigned long long int64_t_ptr
ctypedef unsigned long long unsigned_ptr
ctypedef unsigned long long unsigned_long_long_ptr
ctypedef unsigned long long long_long_ptr
ctypedef unsigned long long size_t_ptr
ctypedef unsigned long long long_ptr
ctypedef unsigned long long float_ptr
ctypedef unsigned long long double_ptr
ctypedef unsigned long long void_ptr

#: Default page-locked allocation flag
cudaHostAllocDefault = cyruntime.cudaHostAllocDefault

#: Pinned memory accessible by all CUDA contexts
cudaHostAllocPortable = cyruntime.cudaHostAllocPortable

#: Map allocation into device space
cudaHostAllocMapped = cyruntime.cudaHostAllocMapped

#: Write-combined memory
cudaHostAllocWriteCombined = cyruntime.cudaHostAllocWriteCombined

#: Default host memory registration flag
cudaHostRegisterDefault = cyruntime.cudaHostRegisterDefault

#: Pinned memory accessible by all CUDA contexts
cudaHostRegisterPortable = cyruntime.cudaHostRegisterPortable

#: Map registered memory into device space
cudaHostRegisterMapped = cyruntime.cudaHostRegisterMapped

#: Memory-mapped I/O space
cudaHostRegisterIoMemory = cyruntime.cudaHostRegisterIoMemory

#: Memory-mapped read-only
cudaHostRegisterReadOnly = cyruntime.cudaHostRegisterReadOnly

#: Default peer addressing enable flag
cudaPeerAccessDefault = cyruntime.cudaPeerAccessDefault

#: Default stream flag
cudaStreamDefault = cyruntime.cudaStreamDefault

#: Stream does not synchronize with stream 0 (the NULL stream)
cudaStreamNonBlocking = cyruntime.cudaStreamNonBlocking

#: Legacy stream handle
#:
#: Stream handle that can be passed as a cudaStream_t to use an implicit
#: stream with legacy synchronization behavior.
#:
#: See details of the \link_sync_behavior
cudaStreamLegacy = cyruntime.cudaStreamLegacy

#: Per-thread stream handle
#:
#: Stream handle that can be passed as a cudaStream_t to use an implicit
#: stream with per-thread synchronization behavior.
#:
#: See details of the \link_sync_behavior
cudaStreamPerThread = cyruntime.cudaStreamPerThread

#: Default event flag
cudaEventDefault = cyruntime.cudaEventDefault

#: Event uses blocking synchronization
cudaEventBlockingSync = cyruntime.cudaEventBlockingSync

#: Event will not record timing data
cudaEventDisableTiming = cyruntime.cudaEventDisableTiming

#: Event is suitable for interprocess use. cudaEventDisableTiming must be
#: set
cudaEventInterprocess = cyruntime.cudaEventInterprocess

#: Default event record flag
cudaEventRecordDefault = cyruntime.cudaEventRecordDefault

#: Event is captured in the graph as an external event node when performing
#: stream capture
cudaEventRecordExternal = cyruntime.cudaEventRecordExternal

#: Default event wait flag
cudaEventWaitDefault = cyruntime.cudaEventWaitDefault

#: Event is captured in the graph as an external event node when performing
#: stream capture
cudaEventWaitExternal = cyruntime.cudaEventWaitExternal

#: Device flag - Automatic scheduling
cudaDeviceScheduleAuto = cyruntime.cudaDeviceScheduleAuto

#: Device flag - Spin default scheduling
cudaDeviceScheduleSpin = cyruntime.cudaDeviceScheduleSpin

#: Device flag - Yield default scheduling
cudaDeviceScheduleYield = cyruntime.cudaDeviceScheduleYield

#: Device flag - Use blocking synchronization
cudaDeviceScheduleBlockingSync = cyruntime.cudaDeviceScheduleBlockingSync

#: Device flag - Use blocking synchronization [Deprecated]
cudaDeviceBlockingSync = cyruntime.cudaDeviceBlockingSync

#: Device schedule flags mask
cudaDeviceScheduleMask = cyruntime.cudaDeviceScheduleMask

#: Device flag - Support mapped pinned allocations
cudaDeviceMapHost = cyruntime.cudaDeviceMapHost

#: Device flag - Keep local memory allocation after launch
cudaDeviceLmemResizeToMax = cyruntime.cudaDeviceLmemResizeToMax

#: Device flag - Ensure synchronous memory operations on this context will
#: synchronize
cudaDeviceSyncMemops = cyruntime.cudaDeviceSyncMemops

#: Device flags mask
cudaDeviceMask = cyruntime.cudaDeviceMask

#: Default CUDA array allocation flag
cudaArrayDefault = cyruntime.cudaArrayDefault

#: Must be set in cudaMalloc3DArray to create a layered CUDA array
cudaArrayLayered = cyruntime.cudaArrayLayered

#: Must be set in cudaMallocArray or cudaMalloc3DArray in order to bind
#: surfaces to the CUDA array
cudaArraySurfaceLoadStore = cyruntime.cudaArraySurfaceLoadStore

#: Must be set in cudaMalloc3DArray to create a cubemap CUDA array
cudaArrayCubemap = cyruntime.cudaArrayCubemap

#: Must be set in cudaMallocArray or cudaMalloc3DArray in order to perform
#: texture gather operations on the CUDA array
cudaArrayTextureGather = cyruntime.cudaArrayTextureGather

#: Must be set in cudaExternalMemoryGetMappedMipmappedArray if the
#: mipmapped array is used as a color target in a graphics API
cudaArrayColorAttachment = cyruntime.cudaArrayColorAttachment

#: Must be set in cudaMallocArray, cudaMalloc3DArray or
#: cudaMallocMipmappedArray in order to create a sparse CUDA array or CUDA
#: mipmapped array
cudaArraySparse = cyruntime.cudaArraySparse

#: Must be set in cudaMallocArray, cudaMalloc3DArray or
#: cudaMallocMipmappedArray in order to create a deferred mapping CUDA
#: array or CUDA mipmapped array
cudaArrayDeferredMapping = cyruntime.cudaArrayDeferredMapping

#: Automatically enable peer access between remote devices as needed
cudaIpcMemLazyEnablePeerAccess = cyruntime.cudaIpcMemLazyEnablePeerAccess

#: Memory can be accessed by any stream on any device
cudaMemAttachGlobal = cyruntime.cudaMemAttachGlobal

#: Memory cannot be accessed by any stream on any device
cudaMemAttachHost = cyruntime.cudaMemAttachHost

#: Memory can only be accessed by a single stream on the associated device
cudaMemAttachSingle = cyruntime.cudaMemAttachSingle

#: Default behavior
cudaOccupancyDefault = cyruntime.cudaOccupancyDefault

#: Assume global caching is enabled and cannot be automatically turned off
cudaOccupancyDisableCachingOverride = cyruntime.cudaOccupancyDisableCachingOverride

#: Device id that represents the CPU
cudaCpuDeviceId = cyruntime.cudaCpuDeviceId

#: Device id that represents an invalid device
cudaInvalidDeviceId = cyruntime.cudaInvalidDeviceId

#: Tell the CUDA runtime that DeviceFlags is being set in cudaInitDevice
#: call
cudaInitDeviceFlagsAreValid = cyruntime.cudaInitDeviceFlagsAreValid

#: Indicates that the layered sparse CUDA array or CUDA mipmapped array has
#: a single mip tail region for all layers
cudaArraySparsePropertiesSingleMipTail = cyruntime.cudaArraySparsePropertiesSingleMipTail

#: This flag, if set, indicates that the memory will be used as a buffer
#: for hardware accelerated decompression.
cudaMemPoolCreateUsageHwDecompress = cyruntime.cudaMemPoolCreateUsageHwDecompress

#: CUDA IPC Handle Size
CUDA_IPC_HANDLE_SIZE = cyruntime.CUDA_IPC_HANDLE_SIZE

#: Indicates that the external memory object is a dedicated resource
cudaExternalMemoryDedicated = cyruntime.cudaExternalMemoryDedicated

#: When the /p flags parameter of
#: :py:obj:`~.cudaExternalSemaphoreSignalParams` contains this flag, it
#: indicates that signaling an external semaphore object should skip
#: performing appropriate memory synchronization operations over all the
#: external memory objects that are imported as
#: :py:obj:`~.cudaExternalMemoryHandleTypeNvSciBuf`, which otherwise are
#: performed by default to ensure data coherency with other importers of
#: the same NvSciBuf memory objects.
cudaExternalSemaphoreSignalSkipNvSciBufMemSync = cyruntime.cudaExternalSemaphoreSignalSkipNvSciBufMemSync

#: When the /p flags parameter of
#: :py:obj:`~.cudaExternalSemaphoreWaitParams` contains this flag, it
#: indicates that waiting an external semaphore object should skip
#: performing appropriate memory synchronization operations over all the
#: external memory objects that are imported as
#: :py:obj:`~.cudaExternalMemoryHandleTypeNvSciBuf`, which otherwise are
#: performed by default to ensure data coherency with other importers of
#: the same NvSciBuf memory objects.
cudaExternalSemaphoreWaitSkipNvSciBufMemSync = cyruntime.cudaExternalSemaphoreWaitSkipNvSciBufMemSync

#: When /p flags of :py:obj:`~.cudaDeviceGetNvSciSyncAttributes` is set to
#: this, it indicates that application need signaler specific NvSciSyncAttr
#: to be filled by :py:obj:`~.cudaDeviceGetNvSciSyncAttributes`.
cudaNvSciSyncAttrSignal = cyruntime.cudaNvSciSyncAttrSignal

#: When /p flags of :py:obj:`~.cudaDeviceGetNvSciSyncAttributes` is set to
#: this, it indicates that application need waiter specific NvSciSyncAttr
#: to be filled by :py:obj:`~.cudaDeviceGetNvSciSyncAttributes`.
cudaNvSciSyncAttrWait = cyruntime.cudaNvSciSyncAttrWait

#: This port activates when the kernel has finished executing.
cudaGraphKernelNodePortDefault = cyruntime.cudaGraphKernelNodePortDefault

#: This port activates when all blocks of the kernel have performed
#: cudaTriggerProgrammaticLaunchCompletion() or have terminated. It must be
#: used with edge type :py:obj:`~.cudaGraphDependencyTypeProgrammatic`. See
#: also :py:obj:`~.cudaLaunchAttributeProgrammaticEvent`.
cudaGraphKernelNodePortProgrammatic = cyruntime.cudaGraphKernelNodePortProgrammatic

#: This port activates when all blocks of the kernel have begun execution.
#: See also :py:obj:`~.cudaLaunchAttributeLaunchCompletionEvent`.
cudaGraphKernelNodePortLaunchCompletion = cyruntime.cudaGraphKernelNodePortLaunchCompletion

cudaStreamAttributeAccessPolicyWindow = cyruntime.cudaStreamAttributeAccessPolicyWindow

cudaStreamAttributeSynchronizationPolicy = cyruntime.cudaStreamAttributeSynchronizationPolicy

cudaStreamAttributeMemSyncDomainMap = cyruntime.cudaStreamAttributeMemSyncDomainMap

cudaStreamAttributeMemSyncDomain = cyruntime.cudaStreamAttributeMemSyncDomain

cudaStreamAttributePriority = cyruntime.cudaStreamAttributePriority

cudaKernelNodeAttributeAccessPolicyWindow = cyruntime.cudaKernelNodeAttributeAccessPolicyWindow

cudaKernelNodeAttributeCooperative = cyruntime.cudaKernelNodeAttributeCooperative

cudaKernelNodeAttributePriority = cyruntime.cudaKernelNodeAttributePriority

cudaKernelNodeAttributeClusterDimension = cyruntime.cudaKernelNodeAttributeClusterDimension

cudaKernelNodeAttributeClusterSchedulingPolicyPreference = cyruntime.cudaKernelNodeAttributeClusterSchedulingPolicyPreference

cudaKernelNodeAttributeMemSyncDomainMap = cyruntime.cudaKernelNodeAttributeMemSyncDomainMap

cudaKernelNodeAttributeMemSyncDomain = cyruntime.cudaKernelNodeAttributeMemSyncDomain

cudaKernelNodeAttributePreferredSharedMemoryCarveout = cyruntime.cudaKernelNodeAttributePreferredSharedMemoryCarveout

cudaKernelNodeAttributeDeviceUpdatableKernelNode = cyruntime.cudaKernelNodeAttributeDeviceUpdatableKernelNode

cudaKernelNodeAttributeNvlinkUtilCentricScheduling = cyruntime.cudaKernelNodeAttributeNvlinkUtilCentricScheduling

cudaSurfaceType1D = cyruntime.cudaSurfaceType1D

cudaSurfaceType2D = cyruntime.cudaSurfaceType2D

cudaSurfaceType3D = cyruntime.cudaSurfaceType3D

cudaSurfaceTypeCubemap = cyruntime.cudaSurfaceTypeCubemap

cudaSurfaceType1DLayered = cyruntime.cudaSurfaceType1DLayered

cudaSurfaceType2DLayered = cyruntime.cudaSurfaceType2DLayered

cudaSurfaceTypeCubemapLayered = cyruntime.cudaSurfaceTypeCubemapLayered

cudaTextureType1D = cyruntime.cudaTextureType1D

cudaTextureType2D = cyruntime.cudaTextureType2D

cudaTextureType3D = cyruntime.cudaTextureType3D

cudaTextureTypeCubemap = cyruntime.cudaTextureTypeCubemap

cudaTextureType1DLayered = cyruntime.cudaTextureType1DLayered

cudaTextureType2DLayered = cyruntime.cudaTextureType2DLayered

cudaTextureTypeCubemapLayered = cyruntime.cudaTextureTypeCubemapLayered

#: CUDA Runtime API Version
CUDART_VERSION = cyruntime.CUDART_VERSION

__CUDART_API_VERSION = cyruntime.__CUDART_API_VERSION

#: Maximum number of planes per frame
CUDA_EGL_MAX_PLANES = cyruntime.CUDA_EGL_MAX_PLANES

{{if 'cudaError' in found_types}}

class cudaError_t(_FastEnum):
    """
    impl_private CUDA error types
    """
    {{if 'cudaSuccess' in found_values}}

    cudaSuccess = (
        cyruntime.cudaError.cudaSuccess,
        'The API call returned with no errors. In the case of query calls, this also\n'
        'means that the operation being queried is complete (see\n'
        ':py:obj:`~.cudaEventQuery()` and :py:obj:`~.cudaStreamQuery()`).\n'
    ){{endif}}
    {{if 'cudaErrorInvalidValue' in found_values}}

    cudaErrorInvalidValue = (
        cyruntime.cudaError.cudaErrorInvalidValue,
        'This indicates that one or more of the parameters passed to the API call is\n'
        'not within an acceptable range of values.\n'
    ){{endif}}
    {{if 'cudaErrorMemoryAllocation' in found_values}}

    cudaErrorMemoryAllocation = (
        cyruntime.cudaError.cudaErrorMemoryAllocation,
        'The API call failed because it was unable to allocate enough memory or\n'
        'other resources to perform the requested operation.\n'
    ){{endif}}
    {{if 'cudaErrorInitializationError' in found_values}}

    cudaErrorInitializationError = (
        cyruntime.cudaError.cudaErrorInitializationError,
        'The API call failed because the CUDA driver and runtime could not be\n'
        'initialized.\n'
    ){{endif}}
    {{if 'cudaErrorCudartUnloading' in found_values}}

    cudaErrorCudartUnloading = (
        cyruntime.cudaError.cudaErrorCudartUnloading,
        'This indicates that a CUDA Runtime API call cannot be executed because it\n'
        'is being called during process shut down, at a point in time after CUDA\n'
        'driver has been unloaded.\n'
    ){{endif}}
    {{if 'cudaErrorProfilerDisabled' in found_values}}

    cudaErrorProfilerDisabled = (
        cyruntime.cudaError.cudaErrorProfilerDisabled,
        'This indicates profiler is not initialized for this run. This can happen\n'
        'when the application is running with external profiling tools like visual\n'
        'profiler.\n'
    ){{endif}}
    {{if 'cudaErrorProfilerNotInitialized' in found_values}}

    cudaErrorProfilerNotInitialized = (
        cyruntime.cudaError.cudaErrorProfilerNotInitialized,
        '[Deprecated]\n'
    ){{endif}}
    {{if 'cudaErrorProfilerAlreadyStarted' in found_values}}

    cudaErrorProfilerAlreadyStarted = (
        cyruntime.cudaError.cudaErrorProfilerAlreadyStarted,
        '[Deprecated]\n'
    ){{endif}}
    {{if 'cudaErrorProfilerAlreadyStopped' in found_values}}

    cudaErrorProfilerAlreadyStopped = (
        cyruntime.cudaError.cudaErrorProfilerAlreadyStopped,
        '[Deprecated]\n'
    ){{endif}}
    {{if 'cudaErrorInvalidConfiguration' in found_values}}

    cudaErrorInvalidConfiguration = (
        cyruntime.cudaError.cudaErrorInvalidConfiguration,
        'This indicates that a kernel launch is requesting resources that can never\n'
        'be satisfied by the current device. Requesting more shared memory per block\n'
        'than the device supports will trigger this error, as will requesting too\n'
        'many threads or blocks. See :py:obj:`~.cudaDeviceProp` for more device\n'
        'limitations.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidPitchValue' in found_values}}

    cudaErrorInvalidPitchValue = (
        cyruntime.cudaError.cudaErrorInvalidPitchValue,
        'This indicates that one or more of the pitch-related parameters passed to\n'
        'the API call is not within the acceptable range for pitch.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidSymbol' in found_values}}

    cudaErrorInvalidSymbol = (
        cyruntime.cudaError.cudaErrorInvalidSymbol,
        'This indicates that the symbol name/identifier passed to the API call is\n'
        'not a valid name or identifier.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidHostPointer' in found_values}}

    cudaErrorInvalidHostPointer = (
        cyruntime.cudaError.cudaErrorInvalidHostPointer,
        'This indicates that at least one host pointer passed to the API call is not\n'
        'a valid host pointer. [Deprecated]\n'
    ){{endif}}
    {{if 'cudaErrorInvalidDevicePointer' in found_values}}

    cudaErrorInvalidDevicePointer = (
        cyruntime.cudaError.cudaErrorInvalidDevicePointer,
        'This indicates that at least one device pointer passed to the API call is\n'
        'not a valid device pointer. [Deprecated]\n'
    ){{endif}}
    {{if 'cudaErrorInvalidTexture' in found_values}}

    cudaErrorInvalidTexture = (
        cyruntime.cudaError.cudaErrorInvalidTexture,
        'This indicates that the texture passed to the API call is not a valid\n'
        'texture.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidTextureBinding' in found_values}}

    cudaErrorInvalidTextureBinding = (
        cyruntime.cudaError.cudaErrorInvalidTextureBinding,
        'This indicates that the texture binding is not valid. This occurs if you\n'
        'call :py:obj:`~.cudaGetTextureAlignmentOffset()` with an unbound texture.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidChannelDescriptor' in found_values}}

    cudaErrorInvalidChannelDescriptor = (
        cyruntime.cudaError.cudaErrorInvalidChannelDescriptor,
        'This indicates that the channel descriptor passed to the API call is not\n'
        'valid. This occurs if the format is not one of the formats specified by\n'
        ':py:obj:`~.cudaChannelFormatKind`, or if one of the dimensions is invalid.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidMemcpyDirection' in found_values}}

    cudaErrorInvalidMemcpyDirection = (
        cyruntime.cudaError.cudaErrorInvalidMemcpyDirection,
        'This indicates that the direction of the memcpy passed to the API call is\n'
        'not one of the types specified by :py:obj:`~.cudaMemcpyKind`.\n'
    ){{endif}}
    {{if 'cudaErrorAddressOfConstant' in found_values}}

    cudaErrorAddressOfConstant = (
        cyruntime.cudaError.cudaErrorAddressOfConstant,
        'This indicated that the user has taken the address of a constant variable,\n'
        'which was forbidden up until the CUDA 3.1 release. [Deprecated]\n'
    ){{endif}}
    {{if 'cudaErrorTextureFetchFailed' in found_values}}

    cudaErrorTextureFetchFailed = (
        cyruntime.cudaError.cudaErrorTextureFetchFailed,
        'This indicated that a texture fetch was not able to be performed. This was\n'
        'previously used for device emulation of texture operations. [Deprecated]\n'
    ){{endif}}
    {{if 'cudaErrorTextureNotBound' in found_values}}

    cudaErrorTextureNotBound = (
        cyruntime.cudaError.cudaErrorTextureNotBound,
        'This indicated that a texture was not bound for access. This was previously\n'
        'used for device emulation of texture operations. [Deprecated]\n'
    ){{endif}}
    {{if 'cudaErrorSynchronizationError' in found_values}}

    cudaErrorSynchronizationError = (
        cyruntime.cudaError.cudaErrorSynchronizationError,
        'This indicated that a synchronization operation had failed. This was\n'
        'previously used for some device emulation functions. [Deprecated]\n'
    ){{endif}}
    {{if 'cudaErrorInvalidFilterSetting' in found_values}}

    cudaErrorInvalidFilterSetting = (
        cyruntime.cudaError.cudaErrorInvalidFilterSetting,
        'This indicates that a non-float texture was being accessed with linear\n'
        'filtering. This is not supported by CUDA.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidNormSetting' in found_values}}

    cudaErrorInvalidNormSetting = (
        cyruntime.cudaError.cudaErrorInvalidNormSetting,
        'This indicates that an attempt was made to read an unsupported data type as\n'
        'a normalized float. This is not supported by CUDA.\n'
    ){{endif}}
    {{if 'cudaErrorMixedDeviceExecution' in found_values}}

    cudaErrorMixedDeviceExecution = (
        cyruntime.cudaError.cudaErrorMixedDeviceExecution,
        'Mixing of device and device emulation code was not allowed. [Deprecated]\n'
    ){{endif}}
    {{if 'cudaErrorNotYetImplemented' in found_values}}

    cudaErrorNotYetImplemented = (
        cyruntime.cudaError.cudaErrorNotYetImplemented,
        'This indicates that the API call is not yet implemented. Production\n'
        'releases of CUDA will never return this error. [Deprecated]\n'
    ){{endif}}
    {{if 'cudaErrorMemoryValueTooLarge' in found_values}}

    cudaErrorMemoryValueTooLarge = (
        cyruntime.cudaError.cudaErrorMemoryValueTooLarge,
        'This indicated that an emulated device pointer exceeded the 32-bit address\n'
        'range. [Deprecated]\n'
    ){{endif}}
    {{if 'cudaErrorStubLibrary' in found_values}}

    cudaErrorStubLibrary = (
        cyruntime.cudaError.cudaErrorStubLibrary,
        'This indicates that the CUDA driver that the application has loaded is a\n'
        'stub library. Applications that run with the stub rather than a real driver\n'
        'loaded will result in CUDA API returning this error.\n'
    ){{endif}}
    {{if 'cudaErrorInsufficientDriver' in found_values}}

    cudaErrorInsufficientDriver = (
        cyruntime.cudaError.cudaErrorInsufficientDriver,
        'This indicates that the installed NVIDIA CUDA driver is older than the CUDA\n'
        'runtime library. This is not a supported configuration. Users should\n'
        'install an updated NVIDIA display driver to allow the application to run.\n'
    ){{endif}}
    {{if 'cudaErrorCallRequiresNewerDriver' in found_values}}

    cudaErrorCallRequiresNewerDriver = (
        cyruntime.cudaError.cudaErrorCallRequiresNewerDriver,
        'This indicates that the API call requires a newer CUDA driver than the one\n'
        'currently installed. Users should install an updated NVIDIA CUDA driver to\n'
        'allow the API call to succeed.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidSurface' in found_values}}

    cudaErrorInvalidSurface = (
        cyruntime.cudaError.cudaErrorInvalidSurface,
        'This indicates that the surface passed to the API call is not a valid\n'
        'surface.\n'
    ){{endif}}
    {{if 'cudaErrorDuplicateVariableName' in found_values}}

    cudaErrorDuplicateVariableName = (
        cyruntime.cudaError.cudaErrorDuplicateVariableName,
        'This indicates that multiple global or constant variables (across separate\n'
        'CUDA source files in the application) share the same string name.\n'
    ){{endif}}
    {{if 'cudaErrorDuplicateTextureName' in found_values}}

    cudaErrorDuplicateTextureName = (
        cyruntime.cudaError.cudaErrorDuplicateTextureName,
        'This indicates that multiple textures (across separate CUDA source files in\n'
        'the application) share the same string name.\n'
    ){{endif}}
    {{if 'cudaErrorDuplicateSurfaceName' in found_values}}

    cudaErrorDuplicateSurfaceName = (
        cyruntime.cudaError.cudaErrorDuplicateSurfaceName,
        'This indicates that multiple surfaces (across separate CUDA source files in\n'
        'the application) share the same string name.\n'
    ){{endif}}
    {{if 'cudaErrorDevicesUnavailable' in found_values}}

    cudaErrorDevicesUnavailable = (
        cyruntime.cudaError.cudaErrorDevicesUnavailable,
        'This indicates that all CUDA devices are busy or unavailable at the current\n'
        'time. Devices are often busy/unavailable due to use of\n'
        ':py:obj:`~.cudaComputeModeProhibited`,\n'
        ':py:obj:`~.cudaComputeModeExclusiveProcess`, or when long running CUDA\n'
        'kernels have filled up the GPU and are blocking new work from starting.\n'
        'They can also be unavailable due to memory constraints on a device that\n'
        'already has active CUDA work being performed.\n'
    ){{endif}}
    {{if 'cudaErrorIncompatibleDriverContext' in found_values}}

    cudaErrorIncompatibleDriverContext = (
        cyruntime.cudaError.cudaErrorIncompatibleDriverContext,
        'This indicates that the current context is not compatible with this the\n'
        'CUDA Runtime. This can only occur if you are using CUDA Runtime/Driver\n'
        'interoperability and have created an existing Driver context using the\n'
        'driver API. The Driver context may be incompatible either because the\n'
        'Driver context was created using an older version of the API, because the\n'
        'Runtime API call expects a primary driver context and the Driver context is\n'
        'not primary, or because the Driver context has been destroyed. Please see\n'
        ':py:obj:`~.Interactions`with the CUDA Driver API" for more information.\n'
    ){{endif}}
    {{if 'cudaErrorMissingConfiguration' in found_values}}

    cudaErrorMissingConfiguration = (
        cyruntime.cudaError.cudaErrorMissingConfiguration,
        'The device function being invoked (usually via\n'
        ':py:obj:`~.cudaLaunchKernel()`) was not previously configured via the\n'
        ':py:obj:`~.cudaConfigureCall()` function.\n'
    ){{endif}}
    {{if 'cudaErrorPriorLaunchFailure' in found_values}}

    cudaErrorPriorLaunchFailure = (
        cyruntime.cudaError.cudaErrorPriorLaunchFailure,
        'This indicated that a previous kernel launch failed. This was previously\n'
        'used for device emulation of kernel launches. [Deprecated]\n'
    ){{endif}}
    {{if 'cudaErrorLaunchMaxDepthExceeded' in found_values}}

    cudaErrorLaunchMaxDepthExceeded = (
        cyruntime.cudaError.cudaErrorLaunchMaxDepthExceeded,
        'This error indicates that a device runtime grid launch did not occur\n'
        'because the depth of the child grid would exceed the maximum supported\n'
        'number of nested grid launches.\n'
    ){{endif}}
    {{if 'cudaErrorLaunchFileScopedTex' in found_values}}

    cudaErrorLaunchFileScopedTex = (
        cyruntime.cudaError.cudaErrorLaunchFileScopedTex,
        'This error indicates that a grid launch did not occur because the kernel\n'
        'uses file-scoped textures which are unsupported by the device runtime.\n'
        'Kernels launched via the device runtime only support textures created with\n'
        "the Texture Object API's.\n"
    ){{endif}}
    {{if 'cudaErrorLaunchFileScopedSurf' in found_values}}

    cudaErrorLaunchFileScopedSurf = (
        cyruntime.cudaError.cudaErrorLaunchFileScopedSurf,
        'This error indicates that a grid launch did not occur because the kernel\n'
        'uses file-scoped surfaces which are unsupported by the device runtime.\n'
        'Kernels launched via the device runtime only support surfaces created with\n'
        "the Surface Object API's.\n"
    ){{endif}}
    {{if 'cudaErrorSyncDepthExceeded' in found_values}}

    cudaErrorSyncDepthExceeded = (
        cyruntime.cudaError.cudaErrorSyncDepthExceeded,
        'This error indicates that a call to :py:obj:`~.cudaDeviceSynchronize` made\n'
        'from the device runtime failed because the call was made at grid depth\n'
        'greater than than either the default (2 levels of grids) or user specified\n'
        'device limit :py:obj:`~.cudaLimitDevRuntimeSyncDepth`. To be able to\n'
        'synchronize on launched grids at a greater depth successfully, the maximum\n'
        'nested depth at which :py:obj:`~.cudaDeviceSynchronize` will be called must\n'
        'be specified with the :py:obj:`~.cudaLimitDevRuntimeSyncDepth` limit to the\n'
        ':py:obj:`~.cudaDeviceSetLimit` api before the host-side launch of a kernel\n'
        'using the device runtime. Keep in mind that additional levels of sync depth\n'
        'require the runtime to reserve large amounts of device memory that cannot\n'
        'be used for user allocations. Note that :py:obj:`~.cudaDeviceSynchronize`\n'
        'made from device runtime is only supported on devices of compute capability\n'
        '< 9.0.\n'
    ){{endif}}
    {{if 'cudaErrorLaunchPendingCountExceeded' in found_values}}

    cudaErrorLaunchPendingCountExceeded = (
        cyruntime.cudaError.cudaErrorLaunchPendingCountExceeded,
        'This error indicates that a device runtime grid launch failed because the\n'
        'launch would exceed the limit\n'
        ':py:obj:`~.cudaLimitDevRuntimePendingLaunchCount`. For this launch to\n'
        'proceed successfully, :py:obj:`~.cudaDeviceSetLimit` must be called to set\n'
        'the :py:obj:`~.cudaLimitDevRuntimePendingLaunchCount` to be higher than the\n'
        'upper bound of outstanding launches that can be issued to the device\n'
        'runtime. Keep in mind that raising the limit of pending device runtime\n'
        'launches will require the runtime to reserve device memory that cannot be\n'
        'used for user allocations.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidDeviceFunction' in found_values}}

    cudaErrorInvalidDeviceFunction = (
        cyruntime.cudaError.cudaErrorInvalidDeviceFunction,
        'The requested device function does not exist or is not compiled for the\n'
        'proper device architecture.\n'
    ){{endif}}
    {{if 'cudaErrorNoDevice' in found_values}}

    cudaErrorNoDevice = (
        cyruntime.cudaError.cudaErrorNoDevice,
        'This indicates that no CUDA-capable devices were detected by the installed\n'
        'CUDA driver.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidDevice' in found_values}}

    cudaErrorInvalidDevice = (
        cyruntime.cudaError.cudaErrorInvalidDevice,
        'This indicates that the device ordinal supplied by the user does not\n'
        'correspond to a valid CUDA device or that the action requested is invalid\n'
        'for the specified device.\n'
    ){{endif}}
    {{if 'cudaErrorDeviceNotLicensed' in found_values}}

    cudaErrorDeviceNotLicensed = (
        cyruntime.cudaError.cudaErrorDeviceNotLicensed,
        "This indicates that the device doesn't have a valid Grid License.\n"
    ){{endif}}
    {{if 'cudaErrorSoftwareValidityNotEstablished' in found_values}}

    cudaErrorSoftwareValidityNotEstablished = (
        cyruntime.cudaError.cudaErrorSoftwareValidityNotEstablished,
        'By default, the CUDA runtime may perform a minimal set of self-tests, as\n'
        'well as CUDA driver tests, to establish the validity of both. Introduced in\n'
        'CUDA 11.2, this error return indicates that at least one of these tests has\n'
        'failed and the validity of either the runtime or the driver could not be\n'
        'established.\n'
    ){{endif}}
    {{if 'cudaErrorStartupFailure' in found_values}}

    cudaErrorStartupFailure = (
        cyruntime.cudaError.cudaErrorStartupFailure,
        'This indicates an internal startup failure in the CUDA runtime.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidKernelImage' in found_values}}

    cudaErrorInvalidKernelImage = (
        cyruntime.cudaError.cudaErrorInvalidKernelImage,
        'This indicates that the device kernel image is invalid.\n'
    ){{endif}}
    {{if 'cudaErrorDeviceUninitialized' in found_values}}

    cudaErrorDeviceUninitialized = (
        cyruntime.cudaError.cudaErrorDeviceUninitialized,
        'This most frequently indicates that there is no context bound to the\n'
        'current thread. This can also be returned if the context passed to an API\n'
        'call is not a valid handle (such as a context that has had\n'
        ':py:obj:`~.cuCtxDestroy()` invoked on it). This can also be returned if a\n'
        'user mixes different API versions (i.e. 3010 context with 3020 API calls).\n'
        'See :py:obj:`~.cuCtxGetApiVersion()` for more details.\n'
    ){{endif}}
    {{if 'cudaErrorMapBufferObjectFailed' in found_values}}

    cudaErrorMapBufferObjectFailed = (
        cyruntime.cudaError.cudaErrorMapBufferObjectFailed,
        'This indicates that the buffer object could not be mapped.\n'
    ){{endif}}
    {{if 'cudaErrorUnmapBufferObjectFailed' in found_values}}

    cudaErrorUnmapBufferObjectFailed = (
        cyruntime.cudaError.cudaErrorUnmapBufferObjectFailed,
        'This indicates that the buffer object could not be unmapped.\n'
    ){{endif}}
    {{if 'cudaErrorArrayIsMapped' in found_values}}

    cudaErrorArrayIsMapped = (
        cyruntime.cudaError.cudaErrorArrayIsMapped,
        'This indicates that the specified array is currently mapped and thus cannot\n'
        'be destroyed.\n'
    ){{endif}}
    {{if 'cudaErrorAlreadyMapped' in found_values}}

    cudaErrorAlreadyMapped = (
        cyruntime.cudaError.cudaErrorAlreadyMapped,
        'This indicates that the resource is already mapped.\n'
    ){{endif}}
    {{if 'cudaErrorNoKernelImageForDevice' in found_values}}

    cudaErrorNoKernelImageForDevice = (
        cyruntime.cudaError.cudaErrorNoKernelImageForDevice,
        'This indicates that there is no kernel image available that is suitable for\n'
        'the device. This can occur when a user specifies code generation options\n'
        'for a particular CUDA source file that do not include the corresponding\n'
        'device configuration.\n'
    ){{endif}}
    {{if 'cudaErrorAlreadyAcquired' in found_values}}

    cudaErrorAlreadyAcquired = (
        cyruntime.cudaError.cudaErrorAlreadyAcquired,
        'This indicates that a resource has already been acquired.\n'
    ){{endif}}
    {{if 'cudaErrorNotMapped' in found_values}}

    cudaErrorNotMapped = (
        cyruntime.cudaError.cudaErrorNotMapped,
        'This indicates that a resource is not mapped.\n'
    ){{endif}}
    {{if 'cudaErrorNotMappedAsArray' in found_values}}

    cudaErrorNotMappedAsArray = (
        cyruntime.cudaError.cudaErrorNotMappedAsArray,
        'This indicates that a mapped resource is not available for access as an\n'
        'array.\n'
    ){{endif}}
    {{if 'cudaErrorNotMappedAsPointer' in found_values}}

    cudaErrorNotMappedAsPointer = (
        cyruntime.cudaError.cudaErrorNotMappedAsPointer,
        'This indicates that a mapped resource is not available for access as a\n'
        'pointer.\n'
    ){{endif}}
    {{if 'cudaErrorECCUncorrectable' in found_values}}

    cudaErrorECCUncorrectable = (
        cyruntime.cudaError.cudaErrorECCUncorrectable,
        'This indicates that an uncorrectable ECC error was detected during\n'
        'execution.\n'
    ){{endif}}
    {{if 'cudaErrorUnsupportedLimit' in found_values}}

    cudaErrorUnsupportedLimit = (
        cyruntime.cudaError.cudaErrorUnsupportedLimit,
        'This indicates that the :py:obj:`~.cudaLimit` passed to the API call is not\n'
        'supported by the active device.\n'
    ){{endif}}
    {{if 'cudaErrorDeviceAlreadyInUse' in found_values}}

    cudaErrorDeviceAlreadyInUse = (
        cyruntime.cudaError.cudaErrorDeviceAlreadyInUse,
        'This indicates that a call tried to access an exclusive-thread device that\n'
        'is already in use by a different thread.\n'
    ){{endif}}
    {{if 'cudaErrorPeerAccessUnsupported' in found_values}}

    cudaErrorPeerAccessUnsupported = (
        cyruntime.cudaError.cudaErrorPeerAccessUnsupported,
        'This error indicates that P2P access is not supported across the given\n'
        'devices.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidPtx' in found_values}}

    cudaErrorInvalidPtx = (
        cyruntime.cudaError.cudaErrorInvalidPtx,
        'A PTX compilation failed. The runtime may fall back to compiling PTX if an\n'
        'application does not contain a suitable binary for the current device.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidGraphicsContext' in found_values}}

    cudaErrorInvalidGraphicsContext = (
        cyruntime.cudaError.cudaErrorInvalidGraphicsContext,
        'This indicates an error with the OpenGL or DirectX context.\n'
    ){{endif}}
    {{if 'cudaErrorNvlinkUncorrectable' in found_values}}

    cudaErrorNvlinkUncorrectable = (
        cyruntime.cudaError.cudaErrorNvlinkUncorrectable,
        'This indicates that an uncorrectable NVLink error was detected during the\n'
        'execution.\n'
    ){{endif}}
    {{if 'cudaErrorJitCompilerNotFound' in found_values}}

    cudaErrorJitCompilerNotFound = (
        cyruntime.cudaError.cudaErrorJitCompilerNotFound,
        'This indicates that the PTX JIT compiler library was not found. The JIT\n'
        'Compiler library is used for PTX compilation. The runtime may fall back to\n'
        'compiling PTX if an application does not contain a suitable binary for the\n'
        'current device.\n'
    ){{endif}}
    {{if 'cudaErrorUnsupportedPtxVersion' in found_values}}

    cudaErrorUnsupportedPtxVersion = (
        cyruntime.cudaError.cudaErrorUnsupportedPtxVersion,
        'This indicates that the provided PTX was compiled with an unsupported\n'
        'toolchain. The most common reason for this, is the PTX was generated by a\n'
        'compiler newer than what is supported by the CUDA driver and PTX JIT\n'
        'compiler.\n'
    ){{endif}}
    {{if 'cudaErrorJitCompilationDisabled' in found_values}}

    cudaErrorJitCompilationDisabled = (
        cyruntime.cudaError.cudaErrorJitCompilationDisabled,
        'This indicates that the JIT compilation was disabled. The JIT compilation\n'
        'compiles PTX. The runtime may fall back to compiling PTX if an application\n'
        'does not contain a suitable binary for the current device.\n'
    ){{endif}}
    {{if 'cudaErrorUnsupportedExecAffinity' in found_values}}

    cudaErrorUnsupportedExecAffinity = (
        cyruntime.cudaError.cudaErrorUnsupportedExecAffinity,
        'This indicates that the provided execution affinity is not supported by the\n'
        'device.\n'
    ){{endif}}
    {{if 'cudaErrorUnsupportedDevSideSync' in found_values}}

    cudaErrorUnsupportedDevSideSync = (
        cyruntime.cudaError.cudaErrorUnsupportedDevSideSync,
        'This indicates that the code to be compiled by the PTX JIT contains\n'
        'unsupported call to cudaDeviceSynchronize.\n'
    ){{endif}}
    {{if 'cudaErrorContained' in found_values}}

    cudaErrorContained = (
        cyruntime.cudaError.cudaErrorContained,
        'This indicates that an exception occurred on the device that is now\n'
        "contained by the GPU's error containment capability. Common causes are - a.\n"
        'Certain types of invalid accesses of peer GPU memory over nvlink b. Certain\n'
        'classes of hardware errors This leaves the process in an inconsistent state\n'
        'and any further CUDA work will return the same error. To continue using\n'
        'CUDA, the process must be terminated and relaunched.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidSource' in found_values}}

    cudaErrorInvalidSource = (
        cyruntime.cudaError.cudaErrorInvalidSource,
        'This indicates that the device kernel source is invalid.\n'
    ){{endif}}
    {{if 'cudaErrorFileNotFound' in found_values}}

    cudaErrorFileNotFound = (
        cyruntime.cudaError.cudaErrorFileNotFound,
        'This indicates that the file specified was not found.\n'
    ){{endif}}
    {{if 'cudaErrorSharedObjectSymbolNotFound' in found_values}}

    cudaErrorSharedObjectSymbolNotFound = (
        cyruntime.cudaError.cudaErrorSharedObjectSymbolNotFound,
        'This indicates that a link to a shared object failed to resolve.\n'
    ){{endif}}
    {{if 'cudaErrorSharedObjectInitFailed' in found_values}}

    cudaErrorSharedObjectInitFailed = (
        cyruntime.cudaError.cudaErrorSharedObjectInitFailed,
        'This indicates that initialization of a shared object failed.\n'
    ){{endif}}
    {{if 'cudaErrorOperatingSystem' in found_values}}

    cudaErrorOperatingSystem = (
        cyruntime.cudaError.cudaErrorOperatingSystem,
        'This error indicates that an OS call failed.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidResourceHandle' in found_values}}

    cudaErrorInvalidResourceHandle = (
        cyruntime.cudaError.cudaErrorInvalidResourceHandle,
        'This indicates that a resource handle passed to the API call was not valid.\n'
        'Resource handles are opaque types like :py:obj:`~.cudaStream_t` and\n'
        ':py:obj:`~.cudaEvent_t`.\n'
    ){{endif}}
    {{if 'cudaErrorIllegalState' in found_values}}

    cudaErrorIllegalState = (
        cyruntime.cudaError.cudaErrorIllegalState,
        'This indicates that a resource required by the API call is not in a valid\n'
        'state to perform the requested operation.\n'
    ){{endif}}
    {{if 'cudaErrorLossyQuery' in found_values}}

    cudaErrorLossyQuery = (
        cyruntime.cudaError.cudaErrorLossyQuery,
        'This indicates an attempt was made to introspect an object in a way that\n'
        'would discard semantically important information. This is either due to the\n'
        'object using funtionality newer than the API version used to introspect it\n'
        'or omission of optional return arguments.\n'
    ){{endif}}
    {{if 'cudaErrorSymbolNotFound' in found_values}}

    cudaErrorSymbolNotFound = (
        cyruntime.cudaError.cudaErrorSymbolNotFound,
        'This indicates that a named symbol was not found. Examples of symbols are\n'
        'global/constant variable names, driver function names, texture names, and\n'
        'surface names.\n'
    ){{endif}}
    {{if 'cudaErrorNotReady' in found_values}}

    cudaErrorNotReady = (
        cyruntime.cudaError.cudaErrorNotReady,
        'This indicates that asynchronous operations issued previously have not\n'
        'completed yet. This result is not actually an error, but must be indicated\n'
        'differently than :py:obj:`~.cudaSuccess` (which indicates completion).\n'
        'Calls that may return this value include :py:obj:`~.cudaEventQuery()` and\n'
        ':py:obj:`~.cudaStreamQuery()`.\n'
    ){{endif}}
    {{if 'cudaErrorIllegalAddress' in found_values}}

    cudaErrorIllegalAddress = (
        cyruntime.cudaError.cudaErrorIllegalAddress,
        'The device encountered a load or store instruction on an invalid memory\n'
        'address. This leaves the process in an inconsistent state and any further\n'
        'CUDA work will return the same error. To continue using CUDA, the process\n'
        'must be terminated and relaunched.\n'
    ){{endif}}
    {{if 'cudaErrorLaunchOutOfResources' in found_values}}

    cudaErrorLaunchOutOfResources = (
        cyruntime.cudaError.cudaErrorLaunchOutOfResources,
        'This indicates that a launch did not occur because it did not have\n'
        'appropriate resources. Although this error is similar to\n'
        ':py:obj:`~.cudaErrorInvalidConfiguration`, this error usually indicates\n'
        'that the user has attempted to pass too many arguments to the device\n'
        "kernel, or the kernel launch specifies too many threads for the kernel's\n"
        'register count.\n'
    ){{endif}}
    {{if 'cudaErrorLaunchTimeout' in found_values}}

    cudaErrorLaunchTimeout = (
        cyruntime.cudaError.cudaErrorLaunchTimeout,
        'This indicates that the device kernel took too long to execute. This can\n'
        'only occur if timeouts are enabled - see the device attribute\n'
        ':py:obj:`~.cudaDevAttrKernelExecTimeout` for more information. This leaves\n'
        'the process in an inconsistent state and any further CUDA work will return\n'
        'the same error. To continue using CUDA, the process must be terminated and\n'
        'relaunched.\n'
    ){{endif}}
    {{if 'cudaErrorLaunchIncompatibleTexturing' in found_values}}

    cudaErrorLaunchIncompatibleTexturing = (
        cyruntime.cudaError.cudaErrorLaunchIncompatibleTexturing,
        'This error indicates a kernel launch that uses an incompatible texturing\n'
        'mode.\n'
    ){{endif}}
    {{if 'cudaErrorPeerAccessAlreadyEnabled' in found_values}}

    cudaErrorPeerAccessAlreadyEnabled = (
        cyruntime.cudaError.cudaErrorPeerAccessAlreadyEnabled,
        'This error indicates that a call to\n'
        ':py:obj:`~.cudaDeviceEnablePeerAccess()` is trying to re-enable peer\n'
        'addressing on from a context which has already had peer addressing enabled.\n'
    ){{endif}}
    {{if 'cudaErrorPeerAccessNotEnabled' in found_values}}

    cudaErrorPeerAccessNotEnabled = (
        cyruntime.cudaError.cudaErrorPeerAccessNotEnabled,
        'This error indicates that :py:obj:`~.cudaDeviceDisablePeerAccess()` is\n'
        'trying to disable peer addressing which has not been enabled yet via\n'
        ':py:obj:`~.cudaDeviceEnablePeerAccess()`.\n'
    ){{endif}}
    {{if 'cudaErrorSetOnActiveProcess' in found_values}}

    cudaErrorSetOnActiveProcess = (
        cyruntime.cudaError.cudaErrorSetOnActiveProcess,
        'This indicates that the user has called :py:obj:`~.cudaSetValidDevices()`,\n'
        ':py:obj:`~.cudaSetDeviceFlags()`, :py:obj:`~.cudaD3D9SetDirect3DDevice()`,\n'
        ':py:obj:`~.cudaD3D10SetDirect3DDevice`,\n'
        ':py:obj:`~.cudaD3D11SetDirect3DDevice()`, or\n'
        ':py:obj:`~.cudaVDPAUSetVDPAUDevice()` after initializing the CUDA runtime\n'
        'by calling non-device management operations (allocating memory and\n'
        'launching kernels are examples of non-device management operations). This\n'
        'error can also be returned if using runtime/driver interoperability and\n'
        'there is an existing :py:obj:`~.CUcontext` active on the host thread.\n'
    ){{endif}}
    {{if 'cudaErrorContextIsDestroyed' in found_values}}

    cudaErrorContextIsDestroyed = (
        cyruntime.cudaError.cudaErrorContextIsDestroyed,
        'This error indicates that the context current to the calling thread has\n'
        'been destroyed using :py:obj:`~.cuCtxDestroy`, or is a primary context\n'
        'which has not yet been initialized.\n'
    ){{endif}}
    {{if 'cudaErrorAssert' in found_values}}

    cudaErrorAssert = (
        cyruntime.cudaError.cudaErrorAssert,
        'An assert triggered in device code during kernel execution. The device\n'
        'cannot be used again. All existing allocations are invalid. To continue\n'
        'using CUDA, the process must be terminated and relaunched.\n'
    ){{endif}}
    {{if 'cudaErrorTooManyPeers' in found_values}}

    cudaErrorTooManyPeers = (
        cyruntime.cudaError.cudaErrorTooManyPeers,
        'This error indicates that the hardware resources required to enable peer\n'
        'access have been exhausted for one or more of the devices passed to\n'
        ':py:obj:`~.cudaEnablePeerAccess()`.\n'
    ){{endif}}
    {{if 'cudaErrorHostMemoryAlreadyRegistered' in found_values}}

    cudaErrorHostMemoryAlreadyRegistered = (
        cyruntime.cudaError.cudaErrorHostMemoryAlreadyRegistered,
        'This error indicates that the memory range passed to\n'
        ':py:obj:`~.cudaHostRegister()` has already been registered.\n'
    ){{endif}}
    {{if 'cudaErrorHostMemoryNotRegistered' in found_values}}

    cudaErrorHostMemoryNotRegistered = (
        cyruntime.cudaError.cudaErrorHostMemoryNotRegistered,
        'This error indicates that the pointer passed to\n'
        ':py:obj:`~.cudaHostUnregister()` does not correspond to any currently\n'
        'registered memory region.\n'
    ){{endif}}
    {{if 'cudaErrorHardwareStackError' in found_values}}

    cudaErrorHardwareStackError = (
        cyruntime.cudaError.cudaErrorHardwareStackError,
        'Device encountered an error in the call stack during kernel execution,\n'
        'possibly due to stack corruption or exceeding the stack size limit. This\n'
        'leaves the process in an inconsistent state and any further CUDA work will\n'
        'return the same error. To continue using CUDA, the process must be\n'
        'terminated and relaunched.\n'
    ){{endif}}
    {{if 'cudaErrorIllegalInstruction' in found_values}}

    cudaErrorIllegalInstruction = (
        cyruntime.cudaError.cudaErrorIllegalInstruction,
        'The device encountered an illegal instruction during kernel execution This\n'
        'leaves the process in an inconsistent state and any further CUDA work will\n'
        'return the same error. To continue using CUDA, the process must be\n'
        'terminated and relaunched.\n'
    ){{endif}}
    {{if 'cudaErrorMisalignedAddress' in found_values}}

    cudaErrorMisalignedAddress = (
        cyruntime.cudaError.cudaErrorMisalignedAddress,
        'The device encountered a load or store instruction on a memory address\n'
        'which is not aligned. This leaves the process in an inconsistent state and\n'
        'any further CUDA work will return the same error. To continue using CUDA,\n'
        'the process must be terminated and relaunched.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidAddressSpace' in found_values}}

    cudaErrorInvalidAddressSpace = (
        cyruntime.cudaError.cudaErrorInvalidAddressSpace,
        'While executing a kernel, the device encountered an instruction which can\n'
        'only operate on memory locations in certain address spaces (global, shared,\n'
        'or local), but was supplied a memory address not belonging to an allowed\n'
        'address space. This leaves the process in an inconsistent state and any\n'
        'further CUDA work will return the same error. To continue using CUDA, the\n'
        'process must be terminated and relaunched.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidPc' in found_values}}

    cudaErrorInvalidPc = (
        cyruntime.cudaError.cudaErrorInvalidPc,
        'The device encountered an invalid program counter. This leaves the process\n'
        'in an inconsistent state and any further CUDA work will return the same\n'
        'error. To continue using CUDA, the process must be terminated and\n'
        'relaunched.\n'
    ){{endif}}
    {{if 'cudaErrorLaunchFailure' in found_values}}

    cudaErrorLaunchFailure = (
        cyruntime.cudaError.cudaErrorLaunchFailure,
        'An exception occurred on the device while executing a kernel. Common causes\n'
        'include dereferencing an invalid device pointer and accessing out of bounds\n'
        'shared memory. Less common cases can be system specific - more information\n'
        'about these cases can be found in the system specific user guide. This\n'
        'leaves the process in an inconsistent state and any further CUDA work will\n'
        'return the same error. To continue using CUDA, the process must be\n'
        'terminated and relaunched.\n'
    ){{endif}}
    {{if 'cudaErrorCooperativeLaunchTooLarge' in found_values}}

    cudaErrorCooperativeLaunchTooLarge = (
        cyruntime.cudaError.cudaErrorCooperativeLaunchTooLarge,
        'This error indicates that the number of blocks launched per grid for a\n'
        'kernel that was launched via either :py:obj:`~.cudaLaunchCooperativeKernel`\n'
        'exceeds the maximum number of blocks as allowed by\n'
        ':py:obj:`~.cudaOccupancyMaxActiveBlocksPerMultiprocessor` or\n'
        ':py:obj:`~.cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags` times\n'
        'the number of multiprocessors as specified by the device attribute\n'
        ':py:obj:`~.cudaDevAttrMultiProcessorCount`.\n'
    ){{endif}}
    {{if 'cudaErrorTensorMemoryLeak' in found_values}}

    cudaErrorTensorMemoryLeak = (
        cyruntime.cudaError.cudaErrorTensorMemoryLeak,
        'An exception occurred on the device while exiting a kernel using tensor\n'
        'memory: the tensor memory was not completely deallocated. This leaves the\n'
        'process in an inconsistent state and any further CUDA work will return the\n'
        'same error. To continue using CUDA, the process must be terminated and\n'
        'relaunched.\n'
    ){{endif}}
    {{if 'cudaErrorNotPermitted' in found_values}}

    cudaErrorNotPermitted = (
        cyruntime.cudaError.cudaErrorNotPermitted,
        'This error indicates the attempted operation is not permitted.\n'
    ){{endif}}
    {{if 'cudaErrorNotSupported' in found_values}}

    cudaErrorNotSupported = (
        cyruntime.cudaError.cudaErrorNotSupported,
        'This error indicates the attempted operation is not supported on the\n'
        'current system or device.\n'
    ){{endif}}
    {{if 'cudaErrorSystemNotReady' in found_values}}

    cudaErrorSystemNotReady = (
        cyruntime.cudaError.cudaErrorSystemNotReady,
        'This error indicates that the system is not yet ready to start any CUDA\n'
        'work. To continue using CUDA, verify the system configuration is in a valid\n'
        'state and all required driver daemons are actively running. More\n'
        'information about this error can be found in the system specific user\n'
        'guide.\n'
    ){{endif}}
    {{if 'cudaErrorSystemDriverMismatch' in found_values}}

    cudaErrorSystemDriverMismatch = (
        cyruntime.cudaError.cudaErrorSystemDriverMismatch,
        'This error indicates that there is a mismatch between the versions of the\n'
        'display driver and the CUDA driver. Refer to the compatibility\n'
        'documentation for supported versions.\n'
    ){{endif}}
    {{if 'cudaErrorCompatNotSupportedOnDevice' in found_values}}

    cudaErrorCompatNotSupportedOnDevice = (
        cyruntime.cudaError.cudaErrorCompatNotSupportedOnDevice,
        'This error indicates that the system was upgraded to run with forward\n'
        'compatibility but the visible hardware detected by CUDA does not support\n'
        'this configuration. Refer to the compatibility documentation for the\n'
        'supported hardware matrix or ensure that only supported hardware is visible\n'
        'during initialization via the CUDA_VISIBLE_DEVICES environment variable.\n'
    ){{endif}}
    {{if 'cudaErrorMpsConnectionFailed' in found_values}}

    cudaErrorMpsConnectionFailed = (
        cyruntime.cudaError.cudaErrorMpsConnectionFailed,
        'This error indicates that the MPS client failed to connect to the MPS\n'
        'control daemon or the MPS server.\n'
    ){{endif}}
    {{if 'cudaErrorMpsRpcFailure' in found_values}}

    cudaErrorMpsRpcFailure = (
        cyruntime.cudaError.cudaErrorMpsRpcFailure,
        'This error indicates that the remote procedural call between the MPS server\n'
        'and the MPS client failed.\n'
    ){{endif}}
    {{if 'cudaErrorMpsServerNotReady' in found_values}}

    cudaErrorMpsServerNotReady = (
        cyruntime.cudaError.cudaErrorMpsServerNotReady,
        'This error indicates that the MPS server is not ready to accept new MPS\n'
        'client requests. This error can be returned when the MPS server is in the\n'
        'process of recovering from a fatal failure.\n'
    ){{endif}}
    {{if 'cudaErrorMpsMaxClientsReached' in found_values}}

    cudaErrorMpsMaxClientsReached = (
        cyruntime.cudaError.cudaErrorMpsMaxClientsReached,
        'This error indicates that the hardware resources required to create MPS\n'
        'client have been exhausted.\n'
    ){{endif}}
    {{if 'cudaErrorMpsMaxConnectionsReached' in found_values}}

    cudaErrorMpsMaxConnectionsReached = (
        cyruntime.cudaError.cudaErrorMpsMaxConnectionsReached,
        'This error indicates the the hardware resources required to device\n'
        'connections have been exhausted.\n'
    ){{endif}}
    {{if 'cudaErrorMpsClientTerminated' in found_values}}

    cudaErrorMpsClientTerminated = (
        cyruntime.cudaError.cudaErrorMpsClientTerminated,
        'This error indicates that the MPS client has been terminated by the server.\n'
        'To continue using CUDA, the process must be terminated and relaunched.\n'
    ){{endif}}
    {{if 'cudaErrorCdpNotSupported' in found_values}}

    cudaErrorCdpNotSupported = (
        cyruntime.cudaError.cudaErrorCdpNotSupported,
        'This error indicates, that the program is using CUDA Dynamic Parallelism,\n'
        'but the current configuration, like MPS, does not support it.\n'
    ){{endif}}
    {{if 'cudaErrorCdpVersionMismatch' in found_values}}

    cudaErrorCdpVersionMismatch = (
        cyruntime.cudaError.cudaErrorCdpVersionMismatch,
        'This error indicates, that the program contains an unsupported interaction\n'
        'between different versions of CUDA Dynamic Parallelism.\n'
    ){{endif}}
    {{if 'cudaErrorStreamCaptureUnsupported' in found_values}}

    cudaErrorStreamCaptureUnsupported = (
        cyruntime.cudaError.cudaErrorStreamCaptureUnsupported,
        'The operation is not permitted when the stream is capturing.\n'
    ){{endif}}
    {{if 'cudaErrorStreamCaptureInvalidated' in found_values}}

    cudaErrorStreamCaptureInvalidated = (
        cyruntime.cudaError.cudaErrorStreamCaptureInvalidated,
        'The current capture sequence on the stream has been invalidated due to a\n'
        'previous error.\n'
    ){{endif}}
    {{if 'cudaErrorStreamCaptureMerge' in found_values}}

    cudaErrorStreamCaptureMerge = (
        cyruntime.cudaError.cudaErrorStreamCaptureMerge,
        'The operation would have resulted in a merge of two independent capture\n'
        'sequences.\n'
    ){{endif}}
    {{if 'cudaErrorStreamCaptureUnmatched' in found_values}}

    cudaErrorStreamCaptureUnmatched = (
        cyruntime.cudaError.cudaErrorStreamCaptureUnmatched,
        'The capture was not initiated in this stream.\n'
    ){{endif}}
    {{if 'cudaErrorStreamCaptureUnjoined' in found_values}}

    cudaErrorStreamCaptureUnjoined = (
        cyruntime.cudaError.cudaErrorStreamCaptureUnjoined,
        'The capture sequence contains a fork that was not joined to the primary\n'
        'stream.\n'
    ){{endif}}
    {{if 'cudaErrorStreamCaptureIsolation' in found_values}}

    cudaErrorStreamCaptureIsolation = (
        cyruntime.cudaError.cudaErrorStreamCaptureIsolation,
        'A dependency would have been created which crosses the capture sequence\n'
        'boundary. Only implicit in-stream ordering dependencies are allowed to\n'
        'cross the boundary.\n'
    ){{endif}}
    {{if 'cudaErrorStreamCaptureImplicit' in found_values}}

    cudaErrorStreamCaptureImplicit = (
        cyruntime.cudaError.cudaErrorStreamCaptureImplicit,
        'The operation would have resulted in a disallowed implicit dependency on a\n'
        'current capture sequence from cudaStreamLegacy.\n'
    ){{endif}}
    {{if 'cudaErrorCapturedEvent' in found_values}}

    cudaErrorCapturedEvent = (
        cyruntime.cudaError.cudaErrorCapturedEvent,
        'The operation is not permitted on an event which was last recorded in a\n'
        'capturing stream.\n'
    ){{endif}}
    {{if 'cudaErrorStreamCaptureWrongThread' in found_values}}

    cudaErrorStreamCaptureWrongThread = (
        cyruntime.cudaError.cudaErrorStreamCaptureWrongThread,
        'A stream capture sequence not initiated with the\n'
        ':py:obj:`~.cudaStreamCaptureModeRelaxed` argument to\n'
        ':py:obj:`~.cudaStreamBeginCapture` was passed to\n'
        ':py:obj:`~.cudaStreamEndCapture` in a different thread.\n'
    ){{endif}}
    {{if 'cudaErrorTimeout' in found_values}}

    cudaErrorTimeout = (
        cyruntime.cudaError.cudaErrorTimeout,
        'This indicates that the wait operation has timed out.\n'
    ){{endif}}
    {{if 'cudaErrorGraphExecUpdateFailure' in found_values}}

    cudaErrorGraphExecUpdateFailure = (
        cyruntime.cudaError.cudaErrorGraphExecUpdateFailure,
        'This error indicates that the graph update was not performed because it\n'
        'included changes which violated constraints specific to instantiated graph\n'
        'update.\n'
    ){{endif}}
    {{if 'cudaErrorExternalDevice' in found_values}}

    cudaErrorExternalDevice = (
        cyruntime.cudaError.cudaErrorExternalDevice,
        'This indicates that an async error has occurred in a device outside of\n'
        "CUDA. If CUDA was waiting for an external device's signal before consuming\n"
        'shared data, the external device signaled an error indicating that the data\n'
        'is not valid for consumption. This leaves the process in an inconsistent\n'
        'state and any further CUDA work will return the same error. To continue\n'
        'using CUDA, the process must be terminated and relaunched.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidClusterSize' in found_values}}

    cudaErrorInvalidClusterSize = (
        cyruntime.cudaError.cudaErrorInvalidClusterSize,
        'This indicates that a kernel launch error has occurred due to cluster\n'
        'misconfiguration.\n'
    ){{endif}}
    {{if 'cudaErrorFunctionNotLoaded' in found_values}}

    cudaErrorFunctionNotLoaded = (
        cyruntime.cudaError.cudaErrorFunctionNotLoaded,
        'Indiciates a function handle is not loaded when calling an API that\n'
        'requires a loaded function.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidResourceType' in found_values}}

    cudaErrorInvalidResourceType = (
        cyruntime.cudaError.cudaErrorInvalidResourceType,
        'This error indicates one or more resources passed in are not valid resource\n'
        'types for the operation.\n'
    ){{endif}}
    {{if 'cudaErrorInvalidResourceConfiguration' in found_values}}

    cudaErrorInvalidResourceConfiguration = (
        cyruntime.cudaError.cudaErrorInvalidResourceConfiguration,
        'This error indicates one or more resources are insufficient or non-\n'
        'applicable for the operation.\n'
    ){{endif}}
    {{if 'cudaErrorStreamDetached' in found_values}}

    cudaErrorStreamDetached = (
        cyruntime.cudaError.cudaErrorStreamDetached,
        'This error indicates that the requested operation is not permitted because\n'
        'the stream is in a detached state. This can occur if the green context\n'
        "associated with the stream has been destroyed, limiting the stream's\n"
        'operational capabilities.\n'
    ){{endif}}
    {{if 'cudaErrorUnknown' in found_values}}

    cudaErrorUnknown = (
        cyruntime.cudaError.cudaErrorUnknown,
        'This indicates that an unknown internal error has occurred.\n'
    ){{endif}}
    {{if 'cudaErrorApiFailureBase' in found_values}}
    cudaErrorApiFailureBase = cyruntime.cudaError.cudaErrorApiFailureBase{{endif}}

{{endif}}
{{if 'cudaGraphDependencyType_enum' in found_types}}

class cudaGraphDependencyType(_FastEnum):
    """
    Type annotations that can be applied to graph edges as part of
    :py:obj:`~.cudaGraphEdgeData`.
    """
    {{if 'cudaGraphDependencyTypeDefault' in found_values}}

    cudaGraphDependencyTypeDefault = (
        cyruntime.cudaGraphDependencyType_enum.cudaGraphDependencyTypeDefault,
        'This is an ordinary dependency.\n'
    ){{endif}}
    {{if 'cudaGraphDependencyTypeProgrammatic' in found_values}}

    cudaGraphDependencyTypeProgrammatic = (
        cyruntime.cudaGraphDependencyType_enum.cudaGraphDependencyTypeProgrammatic,
        'This dependency type allows the downstream node to use\n'
        '`cudaGridDependencySynchronize()`. It may only be used between kernel\n'
        'nodes, and must be used with either the\n'
        ':py:obj:`~.cudaGraphKernelNodePortProgrammatic` or\n'
        ':py:obj:`~.cudaGraphKernelNodePortLaunchCompletion` outgoing port.\n'
    ){{endif}}

{{endif}}
{{if 'cudaGraphInstantiateResult' in found_types}}

class cudaGraphInstantiateResult(_FastEnum):
    """
    Graph instantiation results
    """
    {{if 'cudaGraphInstantiateSuccess' in found_values}}

    cudaGraphInstantiateSuccess = (
        cyruntime.cudaGraphInstantiateResult.cudaGraphInstantiateSuccess,
        'Instantiation succeeded\n'
    ){{endif}}
    {{if 'cudaGraphInstantiateError' in found_values}}

    cudaGraphInstantiateError = (
        cyruntime.cudaGraphInstantiateResult.cudaGraphInstantiateError,
        'Instantiation failed for an unexpected reason which is described in the\n'
        'return value of the function\n'
    ){{endif}}
    {{if 'cudaGraphInstantiateInvalidStructure' in found_values}}

    cudaGraphInstantiateInvalidStructure = (
        cyruntime.cudaGraphInstantiateResult.cudaGraphInstantiateInvalidStructure,
        'Instantiation failed due to invalid structure, such as cycles\n'
    ){{endif}}
    {{if 'cudaGraphInstantiateNodeOperationNotSupported' in found_values}}

    cudaGraphInstantiateNodeOperationNotSupported = (
        cyruntime.cudaGraphInstantiateResult.cudaGraphInstantiateNodeOperationNotSupported,
        'Instantiation for device launch failed because the graph contained an\n'
        'unsupported operation\n'
    ){{endif}}
    {{if 'cudaGraphInstantiateMultipleDevicesNotSupported' in found_values}}

    cudaGraphInstantiateMultipleDevicesNotSupported = (
        cyruntime.cudaGraphInstantiateResult.cudaGraphInstantiateMultipleDevicesNotSupported,
        'Instantiation for device launch failed due to the nodes belonging to\n'
        'different contexts\n'
    ){{endif}}
    {{if 'cudaGraphInstantiateConditionalHandleUnused' in found_values}}

    cudaGraphInstantiateConditionalHandleUnused = (
        cyruntime.cudaGraphInstantiateResult.cudaGraphInstantiateConditionalHandleUnused,
        'One or more conditional handles are not associated with conditional nodes\n'
    ){{endif}}

{{endif}}
{{if 'cudaLaunchMemSyncDomain' in found_types}}

class cudaLaunchMemSyncDomain(_FastEnum):
    """
    Memory Synchronization Domain  A kernel can be launched in a
    specified memory synchronization domain that affects all memory
    operations issued by that kernel. A memory barrier issued in one
    domain will only order memory operations in that domain, thus
    eliminating latency increase from memory barriers ordering
    unrelated traffic.  By default, kernels are launched in domain 0.
    Kernel launched with :py:obj:`~.cudaLaunchMemSyncDomainRemote` will
    have a different domain ID. User may also alter the domain ID with
    :py:obj:`~.cudaLaunchMemSyncDomainMap` for a specific stream /
    graph node / kernel launch. See
    :py:obj:`~.cudaLaunchAttributeMemSyncDomain`,
    :py:obj:`~.cudaStreamSetAttribute`, :py:obj:`~.cudaLaunchKernelEx`,
    :py:obj:`~.cudaGraphKernelNodeSetAttribute`.  Memory operations
    done in kernels launched in different domains are considered
    system-scope distanced. In other words, a GPU scoped memory
    synchronization is not sufficient for memory order to be observed
    by kernels in another memory synchronization domain even if they
    are on the same GPU.
    """
    {{if 'cudaLaunchMemSyncDomainDefault' in found_values}}

    cudaLaunchMemSyncDomainDefault = (
        cyruntime.cudaLaunchMemSyncDomain.cudaLaunchMemSyncDomainDefault,
        'Launch kernels in the default domain\n'
    ){{endif}}
    {{if 'cudaLaunchMemSyncDomainRemote' in found_values}}

    cudaLaunchMemSyncDomainRemote = (
        cyruntime.cudaLaunchMemSyncDomain.cudaLaunchMemSyncDomainRemote,
        'Launch kernels in the remote domain\n'
    ){{endif}}

{{endif}}
{{if 'cudaLaunchAttributeID' in found_types}}

class cudaLaunchAttributeID(_FastEnum):
    """
    Launch attributes enum; used as id field of
    :py:obj:`~.cudaLaunchAttribute`
    """
    {{if 'cudaLaunchAttributeIgnore' in found_values}}

    cudaLaunchAttributeIgnore = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeIgnore,
        'Ignored entry, for convenient composition\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeAccessPolicyWindow' in found_values}}

    cudaLaunchAttributeAccessPolicyWindow = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeAccessPolicyWindow,
        'Valid for streams, graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.accessPolicyWindow`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeCooperative' in found_values}}

    cudaLaunchAttributeCooperative = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeCooperative,
        'Valid for graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.cooperative`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeSynchronizationPolicy' in found_values}}

    cudaLaunchAttributeSynchronizationPolicy = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeSynchronizationPolicy,
        'Valid for streams. See :py:obj:`~.cudaLaunchAttributeValue.syncPolicy`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeClusterDimension' in found_values}}

    cudaLaunchAttributeClusterDimension = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeClusterDimension,
        'Valid for graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.clusterDim`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeClusterSchedulingPolicyPreference' in found_values}}

    cudaLaunchAttributeClusterSchedulingPolicyPreference = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeClusterSchedulingPolicyPreference,
        'Valid for graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.clusterSchedulingPolicyPreference`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeProgrammaticStreamSerialization' in found_values}}

    cudaLaunchAttributeProgrammaticStreamSerialization = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeProgrammaticStreamSerialization,
        'Valid for launches. Setting\n'
        ':py:obj:`~.cudaLaunchAttributeValue.programmaticStreamSerializationAllowed`\n'
        'to non-0 signals that the kernel will use programmatic means to resolve its\n'
        'stream dependency, so that the CUDA runtime should opportunistically allow\n'
        "the grid's execution to overlap with the previous kernel in the stream, if\n"
        'that kernel requests the overlap. The dependent launches can choose to wait\n'
        'on the dependency using the programmatic sync\n'
        '(cudaGridDependencySynchronize() or equivalent PTX instructions).\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeProgrammaticEvent' in found_values}}

    cudaLaunchAttributeProgrammaticEvent = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeProgrammaticEvent,
        'Valid for launches. Set\n'
        ':py:obj:`~.cudaLaunchAttributeValue.programmaticEvent` to record the event.\n'
        'Event recorded through this launch attribute is guaranteed to only trigger\n'
        'after all block in the associated kernel trigger the event. A block can\n'
        'trigger the event programmatically in a future CUDA release. A trigger can\n'
        "also be inserted at the beginning of each block's execution if\n"
        'triggerAtBlockStart is set to non-0. The dependent launches can choose to\n'
        'wait on the dependency using the programmatic sync\n'
        '(cudaGridDependencySynchronize() or equivalent PTX instructions). Note that\n'
        'dependents (including the CPU thread calling\n'
        ':py:obj:`~.cudaEventSynchronize()`) are not guaranteed to observe the\n'
        'release precisely when it is released. For example,\n'
        ':py:obj:`~.cudaEventSynchronize()` may only observe the event trigger long\n'
        'after the associated kernel has completed. This recording type is primarily\n'
        'meant for establishing programmatic dependency between device tasks. Note\n'
        'also this type of dependency allows, but does not guarantee, concurrent\n'
        'execution of tasks.\n'
        ' The event supplied must not be an interprocess or interop event. The event\n'
        'must disable timing (i.e. must be created with the\n'
        ':py:obj:`~.cudaEventDisableTiming` flag set).\n'
    ){{endif}}
    {{if 'cudaLaunchAttributePriority' in found_values}}

    cudaLaunchAttributePriority = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributePriority,
        'Valid for streams, graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.priority`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeMemSyncDomainMap' in found_values}}

    cudaLaunchAttributeMemSyncDomainMap = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeMemSyncDomainMap,
        'Valid for streams, graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.memSyncDomainMap`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeMemSyncDomain' in found_values}}

    cudaLaunchAttributeMemSyncDomain = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeMemSyncDomain,
        'Valid for streams, graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.memSyncDomain`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributePreferredClusterDimension' in found_values}}

    cudaLaunchAttributePreferredClusterDimension = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributePreferredClusterDimension,
        'Valid for graph nodes and launches. Set\n'
        ':py:obj:`~.cudaLaunchAttributeValue.preferredClusterDim` to allow the\n'
        'kernel launch to specify a preferred substitute cluster dimension. Blocks\n'
        'may be grouped according to either the dimensions specified with this\n'
        'attribute (grouped into a "preferred substitute cluster"), or the one\n'
        'specified with :py:obj:`~.cudaLaunchAttributeClusterDimension` attribute\n'
        '(grouped into a "regular cluster"). The cluster dimensions of a "preferred\n'
        'substitute cluster" shall be an integer multiple greater than zero of the\n'
        'regular cluster dimensions. The device will attempt - on a best-effort\n'
        'basis - to group thread blocks into preferred clusters over grouping them\n'
        'into regular clusters. When it deems necessary (primarily when the device\n'
        'temporarily runs out of physical resources to launch the larger preferred\n'
        'clusters), the device may switch to launch the regular clusters instead to\n'
        'attempt to utilize as much of the physical device resources as possible.\n'
        ' Each type of cluster will have its enumeration / coordinate setup as if\n'
        'the grid consists solely of its type of cluster. For example, if the\n'
        'preferred substitute cluster dimensions double the regular cluster\n'
        'dimensions, there might be simultaneously a regular cluster indexed at\n'
        '(1,0,0), and a preferred cluster indexed at (1,0,0). In this example, the\n'
        'preferred substitute cluster (1,0,0) replaces regular clusters (2,0,0) and\n'
        '(3,0,0) and groups their blocks.\n'
        ' This attribute will only take effect when a regular cluster dimension has\n'
        'been specified. The preferred substitute cluster dimension must be an\n'
        'integer multiple greater than zero of the regular cluster dimension and\n'
        'must divide the grid. It must also be no more than `maxBlocksPerCluster`,\n'
        "if it is set in the kernel's `__launch_bounds__`. Otherwise it must be less\n"
        'than the maximum value the driver can support. Otherwise, setting this\n'
        'attribute to a value physically unable to fit on any particular device is\n'
        'permitted.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeLaunchCompletionEvent' in found_values}}

    cudaLaunchAttributeLaunchCompletionEvent = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeLaunchCompletionEvent,
        'Valid for launches. Set\n'
        ':py:obj:`~.cudaLaunchAttributeValue.launchCompletionEvent` to record the\n'
        'event.\n'
        ' Nominally, the event is triggered once all blocks of the kernel have begun\n'
        'execution. Currently this is a best effort. If a kernel B has a launch\n'
        'completion dependency on a kernel A, B may wait until A is complete.\n'
        'Alternatively, blocks of B may begin before all blocks of A have begun, for\n'
        'example if B can claim execution resources unavailable to A (e.g. they run\n'
        'on different GPUs) or if B is a higher priority than A. Exercise caution if\n'
        'such an ordering inversion could lead to deadlock.\n'
        ' A launch completion event is nominally similar to a programmatic event\n'
        'with `triggerAtBlockStart` set except that it is not visible to\n'
        '`cudaGridDependencySynchronize()` and can be used with compute capability\n'
        'less than 9.0.\n'
        ' The event supplied must not be an interprocess or interop event. The event\n'
        'must disable timing (i.e. must be created with the\n'
        ':py:obj:`~.cudaEventDisableTiming` flag set).\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeDeviceUpdatableKernelNode' in found_values}}

    cudaLaunchAttributeDeviceUpdatableKernelNode = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeDeviceUpdatableKernelNode,
        'Valid for graph nodes, launches. This attribute is graphs-only, and passing\n'
        'it to a launch in a non-capturing stream will result in an error.\n'
        ' :cudaLaunchAttributeValue::deviceUpdatableKernelNode::deviceUpdatable can\n'
        'only be set to 0 or 1. Setting the field to 1 indicates that the\n'
        'corresponding kernel node should be device-updatable. On success, a handle\n'
        'will be returned via\n'
        ':py:obj:`~.cudaLaunchAttributeValue`::deviceUpdatableKernelNode::devNode\n'
        'which can be passed to the various device-side update functions to update\n'
        "the node's kernel parameters from within another kernel. For more\n"
        'information on the types of device updates that can be made, as well as the\n'
        'relevant limitations thereof, see\n'
        ':py:obj:`~.cudaGraphKernelNodeUpdatesApply`.\n'
        ' Nodes which are device-updatable have additional restrictions compared to\n'
        'regular kernel nodes. Firstly, device-updatable nodes cannot be removed\n'
        'from their graph via :py:obj:`~.cudaGraphDestroyNode`. Additionally, once\n'
        'opted-in to this functionality, a node cannot opt out, and any attempt to\n'
        'set the deviceUpdatable attribute to 0 will result in an error. Device-\n'
        'updatable kernel nodes also cannot have their attributes copied to/from\n'
        'another kernel node via :py:obj:`~.cudaGraphKernelNodeCopyAttributes`.\n'
        'Graphs containing one or more device-updatable nodes also do not allow\n'
        'multiple instantiation, and neither the graph nor its instantiated version\n'
        'can be passed to :py:obj:`~.cudaGraphExecUpdate`.\n'
        ' If a graph contains device-updatable nodes and updates those nodes from\n'
        'the device from within the graph, the graph must be uploaded with\n'
        ':py:obj:`~.cuGraphUpload` before it is launched. For such a graph, if host-\n'
        'side executable graph updates are made to the device-updatable nodes, the\n'
        'graph must be uploaded before it is launched again.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributePreferredSharedMemoryCarveout' in found_values}}

    cudaLaunchAttributePreferredSharedMemoryCarveout = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributePreferredSharedMemoryCarveout,
        'Valid for launches. On devices where the L1 cache and shared memory use the\n'
        'same hardware resources, setting\n'
        ':py:obj:`~.cudaLaunchAttributeValue.sharedMemCarveout` to a percentage\n'
        'between 0-100 signals sets the shared memory carveout preference in percent\n'
        'of the total shared memory for that kernel launch. This attribute takes\n'
        'precedence over :py:obj:`~.cudaFuncAttributePreferredSharedMemoryCarveout`.\n'
        'This is only a hint, and the driver can choose a different configuration if\n'
        'required for the launch.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeNvlinkUtilCentricScheduling' in found_values}}

    cudaLaunchAttributeNvlinkUtilCentricScheduling = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeNvlinkUtilCentricScheduling,
        'Valid for streams, graph nodes, launches. This attribute is a hint to the\n'
        'CUDA runtime that the launch should attempt to make the kernel maximize its\n'
        'NVLINK utilization.\n'
        ' When possible to honor this hint, CUDA will assume each block in the grid\n'
        'launch will carry out an even amount of NVLINK traffic, and make a best-\n'
        'effort attempt to adjust the kernel launch based on that assumption.\n'
        ' This attribute is a hint only. CUDA makes no functional or performance\n'
        'guarantee. Its applicability can be affected by many different factors,\n'
        "including driver version (i.e. CUDA doesn't guarantee the performance\n"
        'characteristics will be maintained between driver versions or a driver\n'
        'update could alter or regress previously observed perf characteristics.) It\n'
        "also doesn't guarantee a successful result, i.e. applying the attribute may\n"
        'not improve the performance of either the targeted kernel or the\n'
        'encapsulating application.\n'
        ' Valid values for\n'
        ':py:obj:`~.cudaLaunchAttributeValue.nvlinkUtilCentricScheduling` are 0\n'
        '(disabled) and 1 (enabled).\n'
    ){{endif}}

{{endif}}
{{if 'cudaAsyncNotificationType_enum' in found_types}}

class cudaAsyncNotificationType(_FastEnum):
    """
    Types of async notification that can occur
    """
    {{if 'cudaAsyncNotificationTypeOverBudget' in found_values}}

    cudaAsyncNotificationTypeOverBudget = (
        cyruntime.cudaAsyncNotificationType_enum.cudaAsyncNotificationTypeOverBudget,
        'Sent when the process has exceeded its device memory budget\n'
    ){{endif}}

{{endif}}
{{if 'CUDAlogLevel_enum' in found_types}}

class cudaLogLevel(_FastEnum):
    """

    """
    {{if 'cudaLogLevelError' in found_values}}
    cudaLogLevelError = cyruntime.CUDAlogLevel_enum.cudaLogLevelError{{endif}}
    {{if 'cudaLogLevelWarning' in found_values}}
    cudaLogLevelWarning = cyruntime.CUDAlogLevel_enum.cudaLogLevelWarning{{endif}}

{{endif}}
{{if 'cudaDataType_t' in found_types}}

class cudaDataType(_FastEnum):
    """"""
    {{if 'CUDA_R_32F' in found_values}}
    CUDA_R_32F = cyruntime.cudaDataType_t.CUDA_R_32F{{endif}}
    {{if 'CUDA_R_64F' in found_values}}
    CUDA_R_64F = cyruntime.cudaDataType_t.CUDA_R_64F{{endif}}
    {{if 'CUDA_R_16F' in found_values}}
    CUDA_R_16F = cyruntime.cudaDataType_t.CUDA_R_16F{{endif}}
    {{if 'CUDA_R_8I' in found_values}}
    CUDA_R_8I = cyruntime.cudaDataType_t.CUDA_R_8I{{endif}}
    {{if 'CUDA_C_32F' in found_values}}
    CUDA_C_32F = cyruntime.cudaDataType_t.CUDA_C_32F{{endif}}
    {{if 'CUDA_C_64F' in found_values}}
    CUDA_C_64F = cyruntime.cudaDataType_t.CUDA_C_64F{{endif}}
    {{if 'CUDA_C_16F' in found_values}}
    CUDA_C_16F = cyruntime.cudaDataType_t.CUDA_C_16F{{endif}}
    {{if 'CUDA_C_8I' in found_values}}
    CUDA_C_8I = cyruntime.cudaDataType_t.CUDA_C_8I{{endif}}
    {{if 'CUDA_R_8U' in found_values}}
    CUDA_R_8U = cyruntime.cudaDataType_t.CUDA_R_8U{{endif}}
    {{if 'CUDA_C_8U' in found_values}}
    CUDA_C_8U = cyruntime.cudaDataType_t.CUDA_C_8U{{endif}}
    {{if 'CUDA_R_32I' in found_values}}
    CUDA_R_32I = cyruntime.cudaDataType_t.CUDA_R_32I{{endif}}
    {{if 'CUDA_C_32I' in found_values}}
    CUDA_C_32I = cyruntime.cudaDataType_t.CUDA_C_32I{{endif}}
    {{if 'CUDA_R_32U' in found_values}}
    CUDA_R_32U = cyruntime.cudaDataType_t.CUDA_R_32U{{endif}}
    {{if 'CUDA_C_32U' in found_values}}
    CUDA_C_32U = cyruntime.cudaDataType_t.CUDA_C_32U{{endif}}
    {{if 'CUDA_R_16BF' in found_values}}
    CUDA_R_16BF = cyruntime.cudaDataType_t.CUDA_R_16BF{{endif}}
    {{if 'CUDA_C_16BF' in found_values}}
    CUDA_C_16BF = cyruntime.cudaDataType_t.CUDA_C_16BF{{endif}}
    {{if 'CUDA_R_4I' in found_values}}
    CUDA_R_4I = cyruntime.cudaDataType_t.CUDA_R_4I{{endif}}
    {{if 'CUDA_C_4I' in found_values}}
    CUDA_C_4I = cyruntime.cudaDataType_t.CUDA_C_4I{{endif}}
    {{if 'CUDA_R_4U' in found_values}}
    CUDA_R_4U = cyruntime.cudaDataType_t.CUDA_R_4U{{endif}}
    {{if 'CUDA_C_4U' in found_values}}
    CUDA_C_4U = cyruntime.cudaDataType_t.CUDA_C_4U{{endif}}
    {{if 'CUDA_R_16I' in found_values}}
    CUDA_R_16I = cyruntime.cudaDataType_t.CUDA_R_16I{{endif}}
    {{if 'CUDA_C_16I' in found_values}}
    CUDA_C_16I = cyruntime.cudaDataType_t.CUDA_C_16I{{endif}}
    {{if 'CUDA_R_16U' in found_values}}
    CUDA_R_16U = cyruntime.cudaDataType_t.CUDA_R_16U{{endif}}
    {{if 'CUDA_C_16U' in found_values}}
    CUDA_C_16U = cyruntime.cudaDataType_t.CUDA_C_16U{{endif}}
    {{if 'CUDA_R_64I' in found_values}}
    CUDA_R_64I = cyruntime.cudaDataType_t.CUDA_R_64I{{endif}}
    {{if 'CUDA_C_64I' in found_values}}
    CUDA_C_64I = cyruntime.cudaDataType_t.CUDA_C_64I{{endif}}
    {{if 'CUDA_R_64U' in found_values}}
    CUDA_R_64U = cyruntime.cudaDataType_t.CUDA_R_64U{{endif}}
    {{if 'CUDA_C_64U' in found_values}}
    CUDA_C_64U = cyruntime.cudaDataType_t.CUDA_C_64U{{endif}}
    {{if 'CUDA_R_8F_E4M3' in found_values}}
    CUDA_R_8F_E4M3 = cyruntime.cudaDataType_t.CUDA_R_8F_E4M3{{endif}}
    {{if 'CUDA_R_8F_UE4M3' in found_values}}
    CUDA_R_8F_UE4M3 = cyruntime.cudaDataType_t.CUDA_R_8F_UE4M3{{endif}}
    {{if 'CUDA_R_8F_E5M2' in found_values}}
    CUDA_R_8F_E5M2 = cyruntime.cudaDataType_t.CUDA_R_8F_E5M2{{endif}}
    {{if 'CUDA_R_8F_UE8M0' in found_values}}
    CUDA_R_8F_UE8M0 = cyruntime.cudaDataType_t.CUDA_R_8F_UE8M0{{endif}}
    {{if 'CUDA_R_6F_E2M3' in found_values}}
    CUDA_R_6F_E2M3 = cyruntime.cudaDataType_t.CUDA_R_6F_E2M3{{endif}}
    {{if 'CUDA_R_6F_E3M2' in found_values}}
    CUDA_R_6F_E3M2 = cyruntime.cudaDataType_t.CUDA_R_6F_E3M2{{endif}}
    {{if 'CUDA_R_4F_E2M1' in found_values}}
    CUDA_R_4F_E2M1 = cyruntime.cudaDataType_t.CUDA_R_4F_E2M1{{endif}}

{{endif}}
{{if 'cudaEmulationStrategy_t' in found_types}}

class cudaEmulationStrategy(_FastEnum):
    """"""
    {{if 'CUDA_EMULATION_STRATEGY_DEFAULT' in found_values}}
    CUDA_EMULATION_STRATEGY_DEFAULT = cyruntime.cudaEmulationStrategy_t.CUDA_EMULATION_STRATEGY_DEFAULT{{endif}}
    {{if 'CUDA_EMULATION_STRATEGY_PERFORMANT' in found_values}}
    CUDA_EMULATION_STRATEGY_PERFORMANT = cyruntime.cudaEmulationStrategy_t.CUDA_EMULATION_STRATEGY_PERFORMANT{{endif}}
    {{if 'CUDA_EMULATION_STRATEGY_EAGER' in found_values}}
    CUDA_EMULATION_STRATEGY_EAGER = cyruntime.cudaEmulationStrategy_t.CUDA_EMULATION_STRATEGY_EAGER{{endif}}

{{endif}}
{{if 'cudaEmulationMantissaControl_t' in found_types}}

class cudaEmulationMantissaControl(_FastEnum):
    """"""
    {{if 'CUDA_EMULATION_MANTISSA_CONTROL_DYNAMIC' in found_values}}
    CUDA_EMULATION_MANTISSA_CONTROL_DYNAMIC = cyruntime.cudaEmulationMantissaControl_t.CUDA_EMULATION_MANTISSA_CONTROL_DYNAMIC{{endif}}
    {{if 'CUDA_EMULATION_MANTISSA_CONTROL_FIXED' in found_values}}
    CUDA_EMULATION_MANTISSA_CONTROL_FIXED = cyruntime.cudaEmulationMantissaControl_t.CUDA_EMULATION_MANTISSA_CONTROL_FIXED{{endif}}

{{endif}}
{{if 'cudaEmulationSpecialValuesSupport_t' in found_types}}

class cudaEmulationSpecialValuesSupport(_FastEnum):
    """"""
    {{if 'CUDA_EMULATION_SPECIAL_VALUES_SUPPORT_NONE' in found_values}}
    CUDA_EMULATION_SPECIAL_VALUES_SUPPORT_NONE = cyruntime.cudaEmulationSpecialValuesSupport_t.CUDA_EMULATION_SPECIAL_VALUES_SUPPORT_NONE{{endif}}
    {{if 'CUDA_EMULATION_SPECIAL_VALUES_SUPPORT_INFINITY' in found_values}}
    CUDA_EMULATION_SPECIAL_VALUES_SUPPORT_INFINITY = cyruntime.cudaEmulationSpecialValuesSupport_t.CUDA_EMULATION_SPECIAL_VALUES_SUPPORT_INFINITY{{endif}}
    {{if 'CUDA_EMULATION_SPECIAL_VALUES_SUPPORT_NAN' in found_values}}
    CUDA_EMULATION_SPECIAL_VALUES_SUPPORT_NAN = cyruntime.cudaEmulationSpecialValuesSupport_t.CUDA_EMULATION_SPECIAL_VALUES_SUPPORT_NAN{{endif}}
    {{if 'CUDA_EMULATION_SPECIAL_VALUES_SUPPORT_DEFAULT' in found_values}}
    CUDA_EMULATION_SPECIAL_VALUES_SUPPORT_DEFAULT = cyruntime.cudaEmulationSpecialValuesSupport_t.CUDA_EMULATION_SPECIAL_VALUES_SUPPORT_DEFAULT{{endif}}

{{endif}}
{{if 'libraryPropertyType_t' in found_types}}

class libraryPropertyType(_FastEnum):
    """"""
    {{if 'MAJOR_VERSION' in found_values}}
    MAJOR_VERSION = cyruntime.libraryPropertyType_t.MAJOR_VERSION{{endif}}
    {{if 'MINOR_VERSION' in found_values}}
    MINOR_VERSION = cyruntime.libraryPropertyType_t.MINOR_VERSION{{endif}}
    {{if 'PATCH_LEVEL' in found_values}}
    PATCH_LEVEL = cyruntime.libraryPropertyType_t.PATCH_LEVEL{{endif}}

{{endif}}
{{if True}}

class cudaEglFrameType(_FastEnum):
    """
    CUDA EglFrame type - array or pointer
    """
    {{if True}}

    cudaEglFrameTypeArray = (
        cyruntime.cudaEglFrameType_enum.cudaEglFrameTypeArray,
        'Frame type CUDA array\n'
    ){{endif}}
    {{if True}}

    cudaEglFrameTypePitch = (
        cyruntime.cudaEglFrameType_enum.cudaEglFrameTypePitch,
        'Frame type CUDA pointer\n'
    ){{endif}}

{{endif}}
{{if True}}

class cudaEglResourceLocationFlags(_FastEnum):
    """
    Resource location flags- sysmem or vidmem  For CUDA context on
    iGPU, since video and system memory are equivalent - these flags
    will not have an effect on the execution.  For CUDA context on
    dGPU, applications can use the flag
    :py:obj:`~.cudaEglResourceLocationFlags` to give a hint about the
    desired location.  :py:obj:`~.cudaEglResourceLocationSysmem` - the
    frame data is made resident on the system memory to be accessed by
    CUDA.  :py:obj:`~.cudaEglResourceLocationVidmem` - the frame data
    is made resident on the dedicated video memory to be accessed by
    CUDA.  There may be an additional latency due to new allocation and
    data migration, if the frame is produced on a different memory.
    """
    {{if True}}

    cudaEglResourceLocationSysmem = (
        cyruntime.cudaEglResourceLocationFlags_enum.cudaEglResourceLocationSysmem,
        'Resource location sysmem\n'
    ){{endif}}
    {{if True}}

    cudaEglResourceLocationVidmem = (
        cyruntime.cudaEglResourceLocationFlags_enum.cudaEglResourceLocationVidmem,
        'Resource location vidmem\n'
    ){{endif}}

{{endif}}
{{if True}}

class cudaEglColorFormat(_FastEnum):
    """
    CUDA EGL Color Format - The different planar and multiplanar
    formats currently supported for CUDA_EGL interops.
    """
    {{if True}}

    cudaEglColorFormatYUV420Planar = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUV420Planar,
        'Y, U, V in three surfaces, each in a separate surface, U/V width = 1/2 Y\n'
        'width, U/V height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUV420SemiPlanar = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUV420SemiPlanar,
        'Y, UV in two surfaces (UV as one surface) with VU byte ordering, width,\n'
        'height ratio same as YUV420Planar.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUV422Planar = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUV422Planar,
        'Y, U, V each in a separate surface, U/V width = 1/2 Y width, U/V height = Y\n'
        'height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUV422SemiPlanar = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUV422SemiPlanar,
        'Y, UV in two surfaces with VU byte ordering, width, height ratio same as\n'
        'YUV422Planar.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatARGB = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatARGB,
        'R/G/B/A four channels in one surface with BGRA byte ordering.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatRGBA = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatRGBA,
        'R/G/B/A four channels in one surface with ABGR byte ordering.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatL = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatL,
        'single luminance channel in one surface.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatR = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatR,
        'single color channel in one surface.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUV444Planar = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUV444Planar,
        'Y, U, V in three surfaces, each in a separate surface, U/V width = Y width,\n'
        'U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUV444SemiPlanar = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUV444SemiPlanar,
        'Y, UV in two surfaces (UV as one surface) with VU byte ordering, width,\n'
        'height ratio same as YUV444Planar.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUYV422 = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUYV422,
        'Y, U, V in one surface, interleaved as UYVY in one channel.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatUYVY422 = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatUYVY422,
        'Y, U, V in one surface, interleaved as YUYV in one channel.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatABGR = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatABGR,
        'R/G/B/A four channels in one surface with RGBA byte ordering.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBGRA = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBGRA,
        'R/G/B/A four channels in one surface with ARGB byte ordering.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatA = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatA,
        'Alpha color format - one channel in one surface.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatRG = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatRG,
        'R/G color format - two channels in one surface with GR byte ordering\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatAYUV = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatAYUV,
        'Y, U, V, A four channels in one surface, interleaved as VUYA.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVU444SemiPlanar = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVU444SemiPlanar,
        'Y, VU in two surfaces (VU as one surface) with UV byte ordering, U/V width\n'
        '= Y width, U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVU422SemiPlanar = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVU422SemiPlanar,
        'Y, VU in two surfaces (VU as one surface) with UV byte ordering, U/V width\n'
        '= 1/2 Y width, U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVU420SemiPlanar = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVU420SemiPlanar,
        'Y, VU in two surfaces (VU as one surface) with UV byte ordering, U/V width\n'
        '= 1/2 Y width, U/V height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY10V10U10_444SemiPlanar = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY10V10U10_444SemiPlanar,
        'Y10, V10U10 in two surfaces (VU as one surface) with UV byte ordering, U/V\n'
        'width = Y width, U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY10V10U10_420SemiPlanar = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY10V10U10_420SemiPlanar,
        'Y10, V10U10 in two surfaces (VU as one surface) with UV byte ordering, U/V\n'
        'width = 1/2 Y width, U/V height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY12V12U12_444SemiPlanar = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY12V12U12_444SemiPlanar,
        'Y12, V12U12 in two surfaces (VU as one surface) with UV byte ordering, U/V\n'
        'width = Y width, U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY12V12U12_420SemiPlanar = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY12V12U12_420SemiPlanar,
        'Y12, V12U12 in two surfaces (VU as one surface) with UV byte ordering, U/V\n'
        'width = 1/2 Y width, U/V height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatVYUY_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatVYUY_ER,
        'Extended Range Y, U, V in one surface, interleaved as YVYU in one channel.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatUYVY_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatUYVY_ER,
        'Extended Range Y, U, V in one surface, interleaved as YUYV in one channel.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUYV_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUYV_ER,
        'Extended Range Y, U, V in one surface, interleaved as UYVY in one channel.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVYU_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVYU_ER,
        'Extended Range Y, U, V in one surface, interleaved as VYUY in one channel.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUVA_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUVA_ER,
        'Extended Range Y, U, V, A four channels in one surface, interleaved as\n'
        'AVUY.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatAYUV_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatAYUV_ER,
        'Extended Range Y, U, V, A four channels in one surface, interleaved as\n'
        'VUYA.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUV444Planar_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUV444Planar_ER,
        'Extended Range Y, U, V in three surfaces, U/V width = Y width, U/V height =\n'
        'Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUV422Planar_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUV422Planar_ER,
        'Extended Range Y, U, V in three surfaces, U/V width = 1/2 Y width, U/V\n'
        'height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUV420Planar_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUV420Planar_ER,
        'Extended Range Y, U, V in three surfaces, U/V width = 1/2 Y width, U/V\n'
        'height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUV444SemiPlanar_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUV444SemiPlanar_ER,
        'Extended Range Y, UV in two surfaces (UV as one surface) with VU byte\n'
        'ordering, U/V width = Y width, U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUV422SemiPlanar_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUV422SemiPlanar_ER,
        'Extended Range Y, UV in two surfaces (UV as one surface) with VU byte\n'
        'ordering, U/V width = 1/2 Y width, U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUV420SemiPlanar_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUV420SemiPlanar_ER,
        'Extended Range Y, UV in two surfaces (UV as one surface) with VU byte\n'
        'ordering, U/V width = 1/2 Y width, U/V height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVU444Planar_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVU444Planar_ER,
        'Extended Range Y, V, U in three surfaces, U/V width = Y width, U/V height =\n'
        'Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVU422Planar_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVU422Planar_ER,
        'Extended Range Y, V, U in three surfaces, U/V width = 1/2 Y width, U/V\n'
        'height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVU420Planar_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVU420Planar_ER,
        'Extended Range Y, V, U in three surfaces, U/V width = 1/2 Y width, U/V\n'
        'height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVU444SemiPlanar_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVU444SemiPlanar_ER,
        'Extended Range Y, VU in two surfaces (VU as one surface) with UV byte\n'
        'ordering, U/V width = Y width, U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVU422SemiPlanar_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVU422SemiPlanar_ER,
        'Extended Range Y, VU in two surfaces (VU as one surface) with UV byte\n'
        'ordering, U/V width = 1/2 Y width, U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVU420SemiPlanar_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVU420SemiPlanar_ER,
        'Extended Range Y, VU in two surfaces (VU as one surface) with UV byte\n'
        'ordering, U/V width = 1/2 Y width, U/V height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayerRGGB = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayerRGGB,
        'Bayer format - one channel in one surface with interleaved RGGB ordering.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayerBGGR = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayerBGGR,
        'Bayer format - one channel in one surface with interleaved BGGR ordering.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayerGRBG = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayerGRBG,
        'Bayer format - one channel in one surface with interleaved GRBG ordering.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayerGBRG = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayerGBRG,
        'Bayer format - one channel in one surface with interleaved GBRG ordering.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer10RGGB = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer10RGGB,
        'Bayer10 format - one channel in one surface with interleaved RGGB ordering.\n'
        'Out of 16 bits, 10 bits used 6 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer10BGGR = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer10BGGR,
        'Bayer10 format - one channel in one surface with interleaved BGGR ordering.\n'
        'Out of 16 bits, 10 bits used 6 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer10GRBG = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer10GRBG,
        'Bayer10 format - one channel in one surface with interleaved GRBG ordering.\n'
        'Out of 16 bits, 10 bits used 6 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer10GBRG = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer10GBRG,
        'Bayer10 format - one channel in one surface with interleaved GBRG ordering.\n'
        'Out of 16 bits, 10 bits used 6 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer12RGGB = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer12RGGB,
        'Bayer12 format - one channel in one surface with interleaved RGGB ordering.\n'
        'Out of 16 bits, 12 bits used 4 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer12BGGR = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer12BGGR,
        'Bayer12 format - one channel in one surface with interleaved BGGR ordering.\n'
        'Out of 16 bits, 12 bits used 4 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer12GRBG = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer12GRBG,
        'Bayer12 format - one channel in one surface with interleaved GRBG ordering.\n'
        'Out of 16 bits, 12 bits used 4 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer12GBRG = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer12GBRG,
        'Bayer12 format - one channel in one surface with interleaved GBRG ordering.\n'
        'Out of 16 bits, 12 bits used 4 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer14RGGB = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer14RGGB,
        'Bayer14 format - one channel in one surface with interleaved RGGB ordering.\n'
        'Out of 16 bits, 14 bits used 2 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer14BGGR = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer14BGGR,
        'Bayer14 format - one channel in one surface with interleaved BGGR ordering.\n'
        'Out of 16 bits, 14 bits used 2 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer14GRBG = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer14GRBG,
        'Bayer14 format - one channel in one surface with interleaved GRBG ordering.\n'
        'Out of 16 bits, 14 bits used 2 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer14GBRG = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer14GBRG,
        'Bayer14 format - one channel in one surface with interleaved GBRG ordering.\n'
        'Out of 16 bits, 14 bits used 2 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer20RGGB = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer20RGGB,
        'Bayer20 format - one channel in one surface with interleaved RGGB ordering.\n'
        'Out of 32 bits, 20 bits used 12 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer20BGGR = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer20BGGR,
        'Bayer20 format - one channel in one surface with interleaved BGGR ordering.\n'
        'Out of 32 bits, 20 bits used 12 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer20GRBG = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer20GRBG,
        'Bayer20 format - one channel in one surface with interleaved GRBG ordering.\n'
        'Out of 32 bits, 20 bits used 12 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer20GBRG = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer20GBRG,
        'Bayer20 format - one channel in one surface with interleaved GBRG ordering.\n'
        'Out of 32 bits, 20 bits used 12 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVU444Planar = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVU444Planar,
        'Y, V, U in three surfaces, each in a separate surface, U/V width = Y width,\n'
        'U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVU422Planar = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVU422Planar,
        'Y, V, U in three surfaces, each in a separate surface, U/V width = 1/2 Y\n'
        'width, U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVU420Planar = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVU420Planar,
        'Y, V, U in three surfaces, each in a separate surface, U/V width = 1/2 Y\n'
        'width, U/V height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayerIspRGGB = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayerIspRGGB,
        'Nvidia proprietary Bayer ISP format - one channel in one surface with\n'
        'interleaved RGGB ordering and mapped to opaque integer datatype.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayerIspBGGR = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayerIspBGGR,
        'Nvidia proprietary Bayer ISP format - one channel in one surface with\n'
        'interleaved BGGR ordering and mapped to opaque integer datatype.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayerIspGRBG = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayerIspGRBG,
        'Nvidia proprietary Bayer ISP format - one channel in one surface with\n'
        'interleaved GRBG ordering and mapped to opaque integer datatype.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayerIspGBRG = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayerIspGBRG,
        'Nvidia proprietary Bayer ISP format - one channel in one surface with\n'
        'interleaved GBRG ordering and mapped to opaque integer datatype.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayerBCCR = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayerBCCR,
        'Bayer format - one channel in one surface with interleaved BCCR ordering.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayerRCCB = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayerRCCB,
        'Bayer format - one channel in one surface with interleaved RCCB ordering.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayerCRBC = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayerCRBC,
        'Bayer format - one channel in one surface with interleaved CRBC ordering.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayerCBRC = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayerCBRC,
        'Bayer format - one channel in one surface with interleaved CBRC ordering.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer10CCCC = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer10CCCC,
        'Bayer10 format - one channel in one surface with interleaved CCCC ordering.\n'
        'Out of 16 bits, 10 bits used 6 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer12BCCR = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer12BCCR,
        'Bayer12 format - one channel in one surface with interleaved BCCR ordering.\n'
        'Out of 16 bits, 12 bits used 4 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer12RCCB = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer12RCCB,
        'Bayer12 format - one channel in one surface with interleaved RCCB ordering.\n'
        'Out of 16 bits, 12 bits used 4 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer12CRBC = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer12CRBC,
        'Bayer12 format - one channel in one surface with interleaved CRBC ordering.\n'
        'Out of 16 bits, 12 bits used 4 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer12CBRC = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer12CBRC,
        'Bayer12 format - one channel in one surface with interleaved CBRC ordering.\n'
        'Out of 16 bits, 12 bits used 4 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatBayer12CCCC = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatBayer12CCCC,
        'Bayer12 format - one channel in one surface with interleaved CCCC ordering.\n'
        'Out of 16 bits, 12 bits used 4 bits No-op.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY,
        'Color format for single Y plane.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUV420SemiPlanar_2020 = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUV420SemiPlanar_2020,
        'Y, UV in two surfaces (UV as one surface) U/V width = 1/2 Y width, U/V\n'
        'height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVU420SemiPlanar_2020 = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVU420SemiPlanar_2020,
        'Y, VU in two surfaces (VU as one surface) U/V width = 1/2 Y width, U/V\n'
        'height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUV420Planar_2020 = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUV420Planar_2020,
        'Y, U, V in three surfaces, each in a separate surface, U/V width = 1/2 Y\n'
        'width, U/V height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVU420Planar_2020 = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVU420Planar_2020,
        'Y, V, U in three surfaces, each in a separate surface, U/V width = 1/2 Y\n'
        'width, U/V height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUV420SemiPlanar_709 = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUV420SemiPlanar_709,
        'Y, UV in two surfaces (UV as one surface) U/V width = 1/2 Y width, U/V\n'
        'height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVU420SemiPlanar_709 = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVU420SemiPlanar_709,
        'Y, VU in two surfaces (VU as one surface) U/V width = 1/2 Y width, U/V\n'
        'height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUV420Planar_709 = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUV420Planar_709,
        'Y, U, V in three surfaces, each in a separate surface, U/V width = 1/2 Y\n'
        'width, U/V height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVU420Planar_709 = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVU420Planar_709,
        'Y, V, U in three surfaces, each in a separate surface, U/V width = 1/2 Y\n'
        'width, U/V height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY10V10U10_420SemiPlanar_709 = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY10V10U10_420SemiPlanar_709,
        'Y10, V10U10 in two surfaces (VU as one surface) U/V width = 1/2 Y width,\n'
        'U/V height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY10V10U10_420SemiPlanar_2020 = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY10V10U10_420SemiPlanar_2020,
        'Y10, V10U10 in two surfaces (VU as one surface) U/V width = 1/2 Y width,\n'
        'U/V height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY10V10U10_422SemiPlanar_2020 = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY10V10U10_422SemiPlanar_2020,
        'Y10, V10U10 in two surfaces (VU as one surface) U/V width = 1/2 Y width,\n'
        'U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY10V10U10_422SemiPlanar = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY10V10U10_422SemiPlanar,
        'Y10, V10U10 in two surfaces (VU as one surface) U/V width = 1/2 Y width,\n'
        'U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY10V10U10_422SemiPlanar_709 = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY10V10U10_422SemiPlanar_709,
        'Y10, V10U10 in two surfaces (VU as one surface) U/V width = 1/2 Y width,\n'
        'U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY_ER,
        'Extended Range Color format for single Y plane.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY_709_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY_709_ER,
        'Extended Range Color format for single Y plane.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY10_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY10_ER,
        'Extended Range Color format for single Y10 plane.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY10_709_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY10_709_ER,
        'Extended Range Color format for single Y10 plane.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY12_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY12_ER,
        'Extended Range Color format for single Y12 plane.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY12_709_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY12_709_ER,
        'Extended Range Color format for single Y12 plane.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYUVA = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYUVA,
        'Y, U, V, A four channels in one surface, interleaved as AVUY.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatYVYU = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatYVYU,
        'Y, U, V in one surface, interleaved as YVYU in one channel.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatVYUY = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatVYUY,
        'Y, U, V in one surface, interleaved as VYUY in one channel.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY10V10U10_420SemiPlanar_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY10V10U10_420SemiPlanar_ER,
        'Extended Range Y10, V10U10 in two surfaces (VU as one surface) U/V width =\n'
        '1/2 Y width, U/V height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY10V10U10_420SemiPlanar_709_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY10V10U10_420SemiPlanar_709_ER,
        'Extended Range Y10, V10U10 in two surfaces (VU as one surface) U/V width =\n'
        '1/2 Y width, U/V height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY10V10U10_444SemiPlanar_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY10V10U10_444SemiPlanar_ER,
        'Extended Range Y10, V10U10 in two surfaces (VU as one surface) U/V width =\n'
        'Y width, U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY10V10U10_444SemiPlanar_709_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY10V10U10_444SemiPlanar_709_ER,
        'Extended Range Y10, V10U10 in two surfaces (VU as one surface) U/V width =\n'
        'Y width, U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY12V12U12_420SemiPlanar_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY12V12U12_420SemiPlanar_ER,
        'Extended Range Y12, V12U12 in two surfaces (VU as one surface) U/V width =\n'
        '1/2 Y width, U/V height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY12V12U12_420SemiPlanar_709_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY12V12U12_420SemiPlanar_709_ER,
        'Extended Range Y12, V12U12 in two surfaces (VU as one surface) U/V width =\n'
        '1/2 Y width, U/V height = 1/2 Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY12V12U12_444SemiPlanar_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY12V12U12_444SemiPlanar_ER,
        'Extended Range Y12, V12U12 in two surfaces (VU as one surface) U/V width =\n'
        'Y width, U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatY12V12U12_444SemiPlanar_709_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatY12V12U12_444SemiPlanar_709_ER,
        'Extended Range Y12, V12U12 in two surfaces (VU as one surface) U/V width =\n'
        'Y width, U/V height = Y height.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatUYVY709 = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatUYVY709,
        'Y, U, V in one surface, interleaved as UYVY in one channel.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatUYVY709_ER = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatUYVY709_ER,
        'Extended Range Y, U, V in one surface, interleaved as UYVY in one channel.\n'
    ){{endif}}
    {{if True}}

    cudaEglColorFormatUYVY2020 = (
        cyruntime.cudaEglColorFormat_enum.cudaEglColorFormatUYVY2020,
        'Y, U, V in one surface, interleaved as UYVY in one channel.\n'
    ){{endif}}

{{endif}}
{{if 'cudaChannelFormatKind' in found_types}}

class cudaChannelFormatKind(_FastEnum):
    """
    Channel format kind
    """
    {{if 'cudaChannelFormatKindSigned' in found_values}}

    cudaChannelFormatKindSigned = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindSigned,
        'Signed channel format\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsigned' in found_values}}

    cudaChannelFormatKindUnsigned = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsigned,
        'Unsigned channel format\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindFloat' in found_values}}

    cudaChannelFormatKindFloat = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindFloat,
        'Float channel format\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindNone' in found_values}}

    cudaChannelFormatKindNone = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindNone,
        'No channel format\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindNV12' in found_values}}

    cudaChannelFormatKindNV12 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindNV12,
        'Unsigned 8-bit integers, planar 4:2:0 YUV format\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedNormalized8X1' in found_values}}

    cudaChannelFormatKindUnsignedNormalized8X1 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedNormalized8X1,
        '1 channel unsigned 8-bit normalized integer\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedNormalized8X2' in found_values}}

    cudaChannelFormatKindUnsignedNormalized8X2 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedNormalized8X2,
        '2 channel unsigned 8-bit normalized integer\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedNormalized8X4' in found_values}}

    cudaChannelFormatKindUnsignedNormalized8X4 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedNormalized8X4,
        '4 channel unsigned 8-bit normalized integer\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedNormalized16X1' in found_values}}

    cudaChannelFormatKindUnsignedNormalized16X1 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedNormalized16X1,
        '1 channel unsigned 16-bit normalized integer\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedNormalized16X2' in found_values}}

    cudaChannelFormatKindUnsignedNormalized16X2 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedNormalized16X2,
        '2 channel unsigned 16-bit normalized integer\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedNormalized16X4' in found_values}}

    cudaChannelFormatKindUnsignedNormalized16X4 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedNormalized16X4,
        '4 channel unsigned 16-bit normalized integer\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindSignedNormalized8X1' in found_values}}

    cudaChannelFormatKindSignedNormalized8X1 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindSignedNormalized8X1,
        '1 channel signed 8-bit normalized integer\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindSignedNormalized8X2' in found_values}}

    cudaChannelFormatKindSignedNormalized8X2 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindSignedNormalized8X2,
        '2 channel signed 8-bit normalized integer\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindSignedNormalized8X4' in found_values}}

    cudaChannelFormatKindSignedNormalized8X4 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindSignedNormalized8X4,
        '4 channel signed 8-bit normalized integer\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindSignedNormalized16X1' in found_values}}

    cudaChannelFormatKindSignedNormalized16X1 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindSignedNormalized16X1,
        '1 channel signed 16-bit normalized integer\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindSignedNormalized16X2' in found_values}}

    cudaChannelFormatKindSignedNormalized16X2 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindSignedNormalized16X2,
        '2 channel signed 16-bit normalized integer\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindSignedNormalized16X4' in found_values}}

    cudaChannelFormatKindSignedNormalized16X4 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindSignedNormalized16X4,
        '4 channel signed 16-bit normalized integer\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedBlockCompressed1' in found_values}}

    cudaChannelFormatKindUnsignedBlockCompressed1 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedBlockCompressed1,
        '4 channel unsigned normalized block-compressed (BC1 compression) format\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedBlockCompressed1SRGB' in found_values}}

    cudaChannelFormatKindUnsignedBlockCompressed1SRGB = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedBlockCompressed1SRGB,
        '4 channel unsigned normalized block-compressed (BC1 compression) format\n'
        'with sRGB encoding\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedBlockCompressed2' in found_values}}

    cudaChannelFormatKindUnsignedBlockCompressed2 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedBlockCompressed2,
        '4 channel unsigned normalized block-compressed (BC2 compression) format\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedBlockCompressed2SRGB' in found_values}}

    cudaChannelFormatKindUnsignedBlockCompressed2SRGB = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedBlockCompressed2SRGB,
        '4 channel unsigned normalized block-compressed (BC2 compression) format\n'
        'with sRGB encoding\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedBlockCompressed3' in found_values}}

    cudaChannelFormatKindUnsignedBlockCompressed3 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedBlockCompressed3,
        '4 channel unsigned normalized block-compressed (BC3 compression) format\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedBlockCompressed3SRGB' in found_values}}

    cudaChannelFormatKindUnsignedBlockCompressed3SRGB = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedBlockCompressed3SRGB,
        '4 channel unsigned normalized block-compressed (BC3 compression) format\n'
        'with sRGB encoding\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedBlockCompressed4' in found_values}}

    cudaChannelFormatKindUnsignedBlockCompressed4 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedBlockCompressed4,
        '1 channel unsigned normalized block-compressed (BC4 compression) format\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindSignedBlockCompressed4' in found_values}}

    cudaChannelFormatKindSignedBlockCompressed4 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindSignedBlockCompressed4,
        '1 channel signed normalized block-compressed (BC4 compression) format\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedBlockCompressed5' in found_values}}

    cudaChannelFormatKindUnsignedBlockCompressed5 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedBlockCompressed5,
        '2 channel unsigned normalized block-compressed (BC5 compression) format\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindSignedBlockCompressed5' in found_values}}

    cudaChannelFormatKindSignedBlockCompressed5 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindSignedBlockCompressed5,
        '2 channel signed normalized block-compressed (BC5 compression) format\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedBlockCompressed6H' in found_values}}

    cudaChannelFormatKindUnsignedBlockCompressed6H = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedBlockCompressed6H,
        '3 channel unsigned half-float block-compressed (BC6H compression) format\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindSignedBlockCompressed6H' in found_values}}

    cudaChannelFormatKindSignedBlockCompressed6H = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindSignedBlockCompressed6H,
        '3 channel signed half-float block-compressed (BC6H compression) format\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedBlockCompressed7' in found_values}}

    cudaChannelFormatKindUnsignedBlockCompressed7 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedBlockCompressed7,
        '4 channel unsigned normalized block-compressed (BC7 compression) format\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedBlockCompressed7SRGB' in found_values}}

    cudaChannelFormatKindUnsignedBlockCompressed7SRGB = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedBlockCompressed7SRGB,
        '4 channel unsigned normalized block-compressed (BC7 compression) format\n'
        'with sRGB encoding\n'
    ){{endif}}
    {{if 'cudaChannelFormatKindUnsignedNormalized1010102' in found_values}}

    cudaChannelFormatKindUnsignedNormalized1010102 = (
        cyruntime.cudaChannelFormatKind.cudaChannelFormatKindUnsignedNormalized1010102,
        '4 channel unsigned normalized (10-bit, 10-bit, 10-bit, 2-bit) format\n'
    ){{endif}}

{{endif}}
{{if 'cudaMemoryType' in found_types}}

class cudaMemoryType(_FastEnum):
    """
    CUDA memory types
    """
    {{if 'cudaMemoryTypeUnregistered' in found_values}}

    cudaMemoryTypeUnregistered = (
        cyruntime.cudaMemoryType.cudaMemoryTypeUnregistered,
        'Unregistered memory\n'
    ){{endif}}
    {{if 'cudaMemoryTypeHost' in found_values}}

    cudaMemoryTypeHost = (
        cyruntime.cudaMemoryType.cudaMemoryTypeHost,
        'Host memory\n'
    ){{endif}}
    {{if 'cudaMemoryTypeDevice' in found_values}}

    cudaMemoryTypeDevice = (
        cyruntime.cudaMemoryType.cudaMemoryTypeDevice,
        'Device memory\n'
    ){{endif}}
    {{if 'cudaMemoryTypeManaged' in found_values}}

    cudaMemoryTypeManaged = (
        cyruntime.cudaMemoryType.cudaMemoryTypeManaged,
        'Managed memory\n'
    ){{endif}}

{{endif}}
{{if 'cudaMemcpyKind' in found_types}}

class cudaMemcpyKind(_FastEnum):
    """
    CUDA memory copy types
    """
    {{if 'cudaMemcpyHostToHost' in found_values}}

    cudaMemcpyHostToHost = (
        cyruntime.cudaMemcpyKind.cudaMemcpyHostToHost,
        'Host -> Host\n'
    ){{endif}}
    {{if 'cudaMemcpyHostToDevice' in found_values}}

    cudaMemcpyHostToDevice = (
        cyruntime.cudaMemcpyKind.cudaMemcpyHostToDevice,
        'Host -> Device\n'
    ){{endif}}
    {{if 'cudaMemcpyDeviceToHost' in found_values}}

    cudaMemcpyDeviceToHost = (
        cyruntime.cudaMemcpyKind.cudaMemcpyDeviceToHost,
        'Device -> Host\n'
    ){{endif}}
    {{if 'cudaMemcpyDeviceToDevice' in found_values}}

    cudaMemcpyDeviceToDevice = (
        cyruntime.cudaMemcpyKind.cudaMemcpyDeviceToDevice,
        'Device -> Device\n'
    ){{endif}}
    {{if 'cudaMemcpyDefault' in found_values}}

    cudaMemcpyDefault = (
        cyruntime.cudaMemcpyKind.cudaMemcpyDefault,
        'Direction of the transfer is inferred from the pointer values. Requires\n'
        'unified virtual addressing\n'
    ){{endif}}

{{endif}}
{{if 'cudaAccessProperty' in found_types}}

class cudaAccessProperty(_FastEnum):
    """
    Specifies performance hint with :py:obj:`~.cudaAccessPolicyWindow`
    for hitProp and missProp members.
    """
    {{if 'cudaAccessPropertyNormal' in found_values}}

    cudaAccessPropertyNormal = (
        cyruntime.cudaAccessProperty.cudaAccessPropertyNormal,
        'Normal cache persistence.\n'
    ){{endif}}
    {{if 'cudaAccessPropertyStreaming' in found_values}}

    cudaAccessPropertyStreaming = (
        cyruntime.cudaAccessProperty.cudaAccessPropertyStreaming,
        'Streaming access is less likely to persit from cache.\n'
    ){{endif}}
    {{if 'cudaAccessPropertyPersisting' in found_values}}

    cudaAccessPropertyPersisting = (
        cyruntime.cudaAccessProperty.cudaAccessPropertyPersisting,
        'Persisting access is more likely to persist in cache.\n'
    ){{endif}}

{{endif}}
{{if 'cudaStreamCaptureStatus' in found_types}}

class cudaStreamCaptureStatus(_FastEnum):
    """
    Possible stream capture statuses returned by
    :py:obj:`~.cudaStreamIsCapturing`
    """
    {{if 'cudaStreamCaptureStatusNone' in found_values}}

    cudaStreamCaptureStatusNone = (
        cyruntime.cudaStreamCaptureStatus.cudaStreamCaptureStatusNone,
        'Stream is not capturing\n'
    ){{endif}}
    {{if 'cudaStreamCaptureStatusActive' in found_values}}

    cudaStreamCaptureStatusActive = (
        cyruntime.cudaStreamCaptureStatus.cudaStreamCaptureStatusActive,
        'Stream is actively capturing\n'
    ){{endif}}
    {{if 'cudaStreamCaptureStatusInvalidated' in found_values}}

    cudaStreamCaptureStatusInvalidated = (
        cyruntime.cudaStreamCaptureStatus.cudaStreamCaptureStatusInvalidated,
        'Stream is part of a capture sequence that has been invalidated, but not\n'
        'terminated\n'
    ){{endif}}

{{endif}}
{{if 'cudaStreamCaptureMode' in found_types}}

class cudaStreamCaptureMode(_FastEnum):
    """
    Possible modes for stream capture thread interactions. For more
    details see :py:obj:`~.cudaStreamBeginCapture` and
    :py:obj:`~.cudaThreadExchangeStreamCaptureMode`
    """
    {{if 'cudaStreamCaptureModeGlobal' in found_values}}
    cudaStreamCaptureModeGlobal = cyruntime.cudaStreamCaptureMode.cudaStreamCaptureModeGlobal{{endif}}
    {{if 'cudaStreamCaptureModeThreadLocal' in found_values}}
    cudaStreamCaptureModeThreadLocal = cyruntime.cudaStreamCaptureMode.cudaStreamCaptureModeThreadLocal{{endif}}
    {{if 'cudaStreamCaptureModeRelaxed' in found_values}}
    cudaStreamCaptureModeRelaxed = cyruntime.cudaStreamCaptureMode.cudaStreamCaptureModeRelaxed{{endif}}

{{endif}}
{{if 'cudaSynchronizationPolicy' in found_types}}

class cudaSynchronizationPolicy(_FastEnum):
    """

    """
    {{if 'cudaSyncPolicyAuto' in found_values}}
    cudaSyncPolicyAuto = cyruntime.cudaSynchronizationPolicy.cudaSyncPolicyAuto{{endif}}
    {{if 'cudaSyncPolicySpin' in found_values}}
    cudaSyncPolicySpin = cyruntime.cudaSynchronizationPolicy.cudaSyncPolicySpin{{endif}}
    {{if 'cudaSyncPolicyYield' in found_values}}
    cudaSyncPolicyYield = cyruntime.cudaSynchronizationPolicy.cudaSyncPolicyYield{{endif}}
    {{if 'cudaSyncPolicyBlockingSync' in found_values}}
    cudaSyncPolicyBlockingSync = cyruntime.cudaSynchronizationPolicy.cudaSyncPolicyBlockingSync{{endif}}

{{endif}}
{{if 'cudaClusterSchedulingPolicy' in found_types}}

class cudaClusterSchedulingPolicy(_FastEnum):
    """
    Cluster scheduling policies. These may be passed to
    :py:obj:`~.cudaFuncSetAttribute`
    """
    {{if 'cudaClusterSchedulingPolicyDefault' in found_values}}

    cudaClusterSchedulingPolicyDefault = (
        cyruntime.cudaClusterSchedulingPolicy.cudaClusterSchedulingPolicyDefault,
        'the default policy\n'
    ){{endif}}
    {{if 'cudaClusterSchedulingPolicySpread' in found_values}}

    cudaClusterSchedulingPolicySpread = (
        cyruntime.cudaClusterSchedulingPolicy.cudaClusterSchedulingPolicySpread,
        'spread the blocks within a cluster to the SMs\n'
    ){{endif}}
    {{if 'cudaClusterSchedulingPolicyLoadBalancing' in found_values}}

    cudaClusterSchedulingPolicyLoadBalancing = (
        cyruntime.cudaClusterSchedulingPolicy.cudaClusterSchedulingPolicyLoadBalancing,
        'allow the hardware to load-balance the blocks in a cluster to the SMs\n'
    ){{endif}}

{{endif}}
{{if 'cudaStreamUpdateCaptureDependenciesFlags' in found_types}}

class cudaStreamUpdateCaptureDependenciesFlags(_FastEnum):
    """
    Flags for :py:obj:`~.cudaStreamUpdateCaptureDependencies`
    """
    {{if 'cudaStreamAddCaptureDependencies' in found_values}}

    cudaStreamAddCaptureDependencies = (
        cyruntime.cudaStreamUpdateCaptureDependenciesFlags.cudaStreamAddCaptureDependencies,
        'Add new nodes to the dependency set\n'
    ){{endif}}
    {{if 'cudaStreamSetCaptureDependencies' in found_values}}

    cudaStreamSetCaptureDependencies = (
        cyruntime.cudaStreamUpdateCaptureDependenciesFlags.cudaStreamSetCaptureDependencies,
        'Replace the dependency set with the new nodes\n'
    ){{endif}}

{{endif}}
{{if 'cudaUserObjectFlags' in found_types}}

class cudaUserObjectFlags(_FastEnum):
    """
    Flags for user objects for graphs
    """
    {{if 'cudaUserObjectNoDestructorSync' in found_values}}

    cudaUserObjectNoDestructorSync = (
        cyruntime.cudaUserObjectFlags.cudaUserObjectNoDestructorSync,
        'Indicates the destructor execution is not synchronized by any CUDA handle.\n'
    ){{endif}}

{{endif}}
{{if 'cudaUserObjectRetainFlags' in found_types}}

class cudaUserObjectRetainFlags(_FastEnum):
    """
    Flags for retaining user object references for graphs
    """
    {{if 'cudaGraphUserObjectMove' in found_values}}

    cudaGraphUserObjectMove = (
        cyruntime.cudaUserObjectRetainFlags.cudaGraphUserObjectMove,
        'Transfer references from the caller rather than creating new references.\n'
    ){{endif}}

{{endif}}
{{if 'cudaGraphicsRegisterFlags' in found_types}}

class cudaGraphicsRegisterFlags(_FastEnum):
    """
    CUDA graphics interop register flags
    """
    {{if 'cudaGraphicsRegisterFlagsNone' in found_values}}

    cudaGraphicsRegisterFlagsNone = (
        cyruntime.cudaGraphicsRegisterFlags.cudaGraphicsRegisterFlagsNone,
        'Default\n'
    ){{endif}}
    {{if 'cudaGraphicsRegisterFlagsReadOnly' in found_values}}

    cudaGraphicsRegisterFlagsReadOnly = (
        cyruntime.cudaGraphicsRegisterFlags.cudaGraphicsRegisterFlagsReadOnly,
        'CUDA will not write to this resource\n'
    ){{endif}}
    {{if 'cudaGraphicsRegisterFlagsWriteDiscard' in found_values}}

    cudaGraphicsRegisterFlagsWriteDiscard = (
        cyruntime.cudaGraphicsRegisterFlags.cudaGraphicsRegisterFlagsWriteDiscard,
        'CUDA will only write to and will not read from this resource\n'
    ){{endif}}
    {{if 'cudaGraphicsRegisterFlagsSurfaceLoadStore' in found_values}}

    cudaGraphicsRegisterFlagsSurfaceLoadStore = (
        cyruntime.cudaGraphicsRegisterFlags.cudaGraphicsRegisterFlagsSurfaceLoadStore,
        'CUDA will bind this resource to a surface reference\n'
    ){{endif}}
    {{if 'cudaGraphicsRegisterFlagsTextureGather' in found_values}}

    cudaGraphicsRegisterFlagsTextureGather = (
        cyruntime.cudaGraphicsRegisterFlags.cudaGraphicsRegisterFlagsTextureGather,
        'CUDA will perform texture gather operations on this resource\n'
    ){{endif}}

{{endif}}
{{if 'cudaGraphicsMapFlags' in found_types}}

class cudaGraphicsMapFlags(_FastEnum):
    """
    CUDA graphics interop map flags
    """
    {{if 'cudaGraphicsMapFlagsNone' in found_values}}

    cudaGraphicsMapFlagsNone = (
        cyruntime.cudaGraphicsMapFlags.cudaGraphicsMapFlagsNone,
        'Default; Assume resource can be read/written\n'
    ){{endif}}
    {{if 'cudaGraphicsMapFlagsReadOnly' in found_values}}

    cudaGraphicsMapFlagsReadOnly = (
        cyruntime.cudaGraphicsMapFlags.cudaGraphicsMapFlagsReadOnly,
        'CUDA will not write to this resource\n'
    ){{endif}}
    {{if 'cudaGraphicsMapFlagsWriteDiscard' in found_values}}

    cudaGraphicsMapFlagsWriteDiscard = (
        cyruntime.cudaGraphicsMapFlags.cudaGraphicsMapFlagsWriteDiscard,
        'CUDA will only write to and will not read from this resource\n'
    ){{endif}}

{{endif}}
{{if 'cudaGraphicsCubeFace' in found_types}}

class cudaGraphicsCubeFace(_FastEnum):
    """
    CUDA graphics interop array indices for cube maps
    """
    {{if 'cudaGraphicsCubeFacePositiveX' in found_values}}

    cudaGraphicsCubeFacePositiveX = (
        cyruntime.cudaGraphicsCubeFace.cudaGraphicsCubeFacePositiveX,
        'Positive X face of cubemap\n'
    ){{endif}}
    {{if 'cudaGraphicsCubeFaceNegativeX' in found_values}}

    cudaGraphicsCubeFaceNegativeX = (
        cyruntime.cudaGraphicsCubeFace.cudaGraphicsCubeFaceNegativeX,
        'Negative X face of cubemap\n'
    ){{endif}}
    {{if 'cudaGraphicsCubeFacePositiveY' in found_values}}

    cudaGraphicsCubeFacePositiveY = (
        cyruntime.cudaGraphicsCubeFace.cudaGraphicsCubeFacePositiveY,
        'Positive Y face of cubemap\n'
    ){{endif}}
    {{if 'cudaGraphicsCubeFaceNegativeY' in found_values}}

    cudaGraphicsCubeFaceNegativeY = (
        cyruntime.cudaGraphicsCubeFace.cudaGraphicsCubeFaceNegativeY,
        'Negative Y face of cubemap\n'
    ){{endif}}
    {{if 'cudaGraphicsCubeFacePositiveZ' in found_values}}

    cudaGraphicsCubeFacePositiveZ = (
        cyruntime.cudaGraphicsCubeFace.cudaGraphicsCubeFacePositiveZ,
        'Positive Z face of cubemap\n'
    ){{endif}}
    {{if 'cudaGraphicsCubeFaceNegativeZ' in found_values}}

    cudaGraphicsCubeFaceNegativeZ = (
        cyruntime.cudaGraphicsCubeFace.cudaGraphicsCubeFaceNegativeZ,
        'Negative Z face of cubemap\n'
    ){{endif}}

{{endif}}
{{if 'cudaResourceType' in found_types}}

class cudaResourceType(_FastEnum):
    """
    CUDA resource types
    """
    {{if 'cudaResourceTypeArray' in found_values}}

    cudaResourceTypeArray = (
        cyruntime.cudaResourceType.cudaResourceTypeArray,
        'Array resource\n'
    ){{endif}}
    {{if 'cudaResourceTypeMipmappedArray' in found_values}}

    cudaResourceTypeMipmappedArray = (
        cyruntime.cudaResourceType.cudaResourceTypeMipmappedArray,
        'Mipmapped array resource\n'
    ){{endif}}
    {{if 'cudaResourceTypeLinear' in found_values}}

    cudaResourceTypeLinear = (
        cyruntime.cudaResourceType.cudaResourceTypeLinear,
        'Linear resource\n'
    ){{endif}}
    {{if 'cudaResourceTypePitch2D' in found_values}}

    cudaResourceTypePitch2D = (
        cyruntime.cudaResourceType.cudaResourceTypePitch2D,
        'Pitch 2D resource\n'
    ){{endif}}

{{endif}}
{{if 'cudaResourceViewFormat' in found_types}}

class cudaResourceViewFormat(_FastEnum):
    """
    CUDA texture resource view formats
    """
    {{if 'cudaResViewFormatNone' in found_values}}

    cudaResViewFormatNone = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatNone,
        'No resource view format (use underlying resource format)\n'
    ){{endif}}
    {{if 'cudaResViewFormatUnsignedChar1' in found_values}}

    cudaResViewFormatUnsignedChar1 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatUnsignedChar1,
        '1 channel unsigned 8-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatUnsignedChar2' in found_values}}

    cudaResViewFormatUnsignedChar2 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatUnsignedChar2,
        '2 channel unsigned 8-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatUnsignedChar4' in found_values}}

    cudaResViewFormatUnsignedChar4 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatUnsignedChar4,
        '4 channel unsigned 8-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatSignedChar1' in found_values}}

    cudaResViewFormatSignedChar1 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatSignedChar1,
        '1 channel signed 8-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatSignedChar2' in found_values}}

    cudaResViewFormatSignedChar2 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatSignedChar2,
        '2 channel signed 8-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatSignedChar4' in found_values}}

    cudaResViewFormatSignedChar4 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatSignedChar4,
        '4 channel signed 8-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatUnsignedShort1' in found_values}}

    cudaResViewFormatUnsignedShort1 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatUnsignedShort1,
        '1 channel unsigned 16-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatUnsignedShort2' in found_values}}

    cudaResViewFormatUnsignedShort2 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatUnsignedShort2,
        '2 channel unsigned 16-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatUnsignedShort4' in found_values}}

    cudaResViewFormatUnsignedShort4 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatUnsignedShort4,
        '4 channel unsigned 16-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatSignedShort1' in found_values}}

    cudaResViewFormatSignedShort1 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatSignedShort1,
        '1 channel signed 16-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatSignedShort2' in found_values}}

    cudaResViewFormatSignedShort2 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatSignedShort2,
        '2 channel signed 16-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatSignedShort4' in found_values}}

    cudaResViewFormatSignedShort4 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatSignedShort4,
        '4 channel signed 16-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatUnsignedInt1' in found_values}}

    cudaResViewFormatUnsignedInt1 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatUnsignedInt1,
        '1 channel unsigned 32-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatUnsignedInt2' in found_values}}

    cudaResViewFormatUnsignedInt2 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatUnsignedInt2,
        '2 channel unsigned 32-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatUnsignedInt4' in found_values}}

    cudaResViewFormatUnsignedInt4 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatUnsignedInt4,
        '4 channel unsigned 32-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatSignedInt1' in found_values}}

    cudaResViewFormatSignedInt1 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatSignedInt1,
        '1 channel signed 32-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatSignedInt2' in found_values}}

    cudaResViewFormatSignedInt2 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatSignedInt2,
        '2 channel signed 32-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatSignedInt4' in found_values}}

    cudaResViewFormatSignedInt4 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatSignedInt4,
        '4 channel signed 32-bit integers\n'
    ){{endif}}
    {{if 'cudaResViewFormatHalf1' in found_values}}

    cudaResViewFormatHalf1 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatHalf1,
        '1 channel 16-bit floating point\n'
    ){{endif}}
    {{if 'cudaResViewFormatHalf2' in found_values}}

    cudaResViewFormatHalf2 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatHalf2,
        '2 channel 16-bit floating point\n'
    ){{endif}}
    {{if 'cudaResViewFormatHalf4' in found_values}}

    cudaResViewFormatHalf4 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatHalf4,
        '4 channel 16-bit floating point\n'
    ){{endif}}
    {{if 'cudaResViewFormatFloat1' in found_values}}

    cudaResViewFormatFloat1 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatFloat1,
        '1 channel 32-bit floating point\n'
    ){{endif}}
    {{if 'cudaResViewFormatFloat2' in found_values}}

    cudaResViewFormatFloat2 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatFloat2,
        '2 channel 32-bit floating point\n'
    ){{endif}}
    {{if 'cudaResViewFormatFloat4' in found_values}}

    cudaResViewFormatFloat4 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatFloat4,
        '4 channel 32-bit floating point\n'
    ){{endif}}
    {{if 'cudaResViewFormatUnsignedBlockCompressed1' in found_values}}

    cudaResViewFormatUnsignedBlockCompressed1 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatUnsignedBlockCompressed1,
        'Block compressed 1\n'
    ){{endif}}
    {{if 'cudaResViewFormatUnsignedBlockCompressed2' in found_values}}

    cudaResViewFormatUnsignedBlockCompressed2 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatUnsignedBlockCompressed2,
        'Block compressed 2\n'
    ){{endif}}
    {{if 'cudaResViewFormatUnsignedBlockCompressed3' in found_values}}

    cudaResViewFormatUnsignedBlockCompressed3 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatUnsignedBlockCompressed3,
        'Block compressed 3\n'
    ){{endif}}
    {{if 'cudaResViewFormatUnsignedBlockCompressed4' in found_values}}

    cudaResViewFormatUnsignedBlockCompressed4 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatUnsignedBlockCompressed4,
        'Block compressed 4 unsigned\n'
    ){{endif}}
    {{if 'cudaResViewFormatSignedBlockCompressed4' in found_values}}

    cudaResViewFormatSignedBlockCompressed4 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatSignedBlockCompressed4,
        'Block compressed 4 signed\n'
    ){{endif}}
    {{if 'cudaResViewFormatUnsignedBlockCompressed5' in found_values}}

    cudaResViewFormatUnsignedBlockCompressed5 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatUnsignedBlockCompressed5,
        'Block compressed 5 unsigned\n'
    ){{endif}}
    {{if 'cudaResViewFormatSignedBlockCompressed5' in found_values}}

    cudaResViewFormatSignedBlockCompressed5 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatSignedBlockCompressed5,
        'Block compressed 5 signed\n'
    ){{endif}}
    {{if 'cudaResViewFormatUnsignedBlockCompressed6H' in found_values}}

    cudaResViewFormatUnsignedBlockCompressed6H = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatUnsignedBlockCompressed6H,
        'Block compressed 6 unsigned half-float\n'
    ){{endif}}
    {{if 'cudaResViewFormatSignedBlockCompressed6H' in found_values}}

    cudaResViewFormatSignedBlockCompressed6H = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatSignedBlockCompressed6H,
        'Block compressed 6 signed half-float\n'
    ){{endif}}
    {{if 'cudaResViewFormatUnsignedBlockCompressed7' in found_values}}

    cudaResViewFormatUnsignedBlockCompressed7 = (
        cyruntime.cudaResourceViewFormat.cudaResViewFormatUnsignedBlockCompressed7,
        'Block compressed 7\n'
    ){{endif}}

{{endif}}
{{if 'cudaFuncAttribute' in found_types}}

class cudaFuncAttribute(_FastEnum):
    """
    CUDA function attributes that can be set using
    :py:obj:`~.cudaFuncSetAttribute`
    """
    {{if 'cudaFuncAttributeMaxDynamicSharedMemorySize' in found_values}}

    cudaFuncAttributeMaxDynamicSharedMemorySize = (
        cyruntime.cudaFuncAttribute.cudaFuncAttributeMaxDynamicSharedMemorySize,
        'Maximum dynamic shared memory size\n'
    ){{endif}}
    {{if 'cudaFuncAttributePreferredSharedMemoryCarveout' in found_values}}

    cudaFuncAttributePreferredSharedMemoryCarveout = (
        cyruntime.cudaFuncAttribute.cudaFuncAttributePreferredSharedMemoryCarveout,
        'Preferred shared memory-L1 cache split\n'
    ){{endif}}
    {{if 'cudaFuncAttributeClusterDimMustBeSet' in found_values}}

    cudaFuncAttributeClusterDimMustBeSet = (
        cyruntime.cudaFuncAttribute.cudaFuncAttributeClusterDimMustBeSet,
        'Indicator to enforce valid cluster dimension specification on kernel launch\n'
    ){{endif}}
    {{if 'cudaFuncAttributeRequiredClusterWidth' in found_values}}

    cudaFuncAttributeRequiredClusterWidth = (
        cyruntime.cudaFuncAttribute.cudaFuncAttributeRequiredClusterWidth,
        'Required cluster width\n'
    ){{endif}}
    {{if 'cudaFuncAttributeRequiredClusterHeight' in found_values}}

    cudaFuncAttributeRequiredClusterHeight = (
        cyruntime.cudaFuncAttribute.cudaFuncAttributeRequiredClusterHeight,
        'Required cluster height\n'
    ){{endif}}
    {{if 'cudaFuncAttributeRequiredClusterDepth' in found_values}}

    cudaFuncAttributeRequiredClusterDepth = (
        cyruntime.cudaFuncAttribute.cudaFuncAttributeRequiredClusterDepth,
        'Required cluster depth\n'
    ){{endif}}
    {{if 'cudaFuncAttributeNonPortableClusterSizeAllowed' in found_values}}

    cudaFuncAttributeNonPortableClusterSizeAllowed = (
        cyruntime.cudaFuncAttribute.cudaFuncAttributeNonPortableClusterSizeAllowed,
        'Whether non-portable cluster scheduling policy is supported\n'
    ){{endif}}
    {{if 'cudaFuncAttributeClusterSchedulingPolicyPreference' in found_values}}

    cudaFuncAttributeClusterSchedulingPolicyPreference = (
        cyruntime.cudaFuncAttribute.cudaFuncAttributeClusterSchedulingPolicyPreference,
        'Required cluster scheduling policy preference\n'
    ){{endif}}
    {{if 'cudaFuncAttributeMax' in found_values}}
    cudaFuncAttributeMax = cyruntime.cudaFuncAttribute.cudaFuncAttributeMax{{endif}}

{{endif}}
{{if 'cudaFuncCache' in found_types}}

class cudaFuncCache(_FastEnum):
    """
    CUDA function cache configurations
    """
    {{if 'cudaFuncCachePreferNone' in found_values}}

    cudaFuncCachePreferNone = (
        cyruntime.cudaFuncCache.cudaFuncCachePreferNone,
        'Default function cache configuration, no preference\n'
    ){{endif}}
    {{if 'cudaFuncCachePreferShared' in found_values}}

    cudaFuncCachePreferShared = (
        cyruntime.cudaFuncCache.cudaFuncCachePreferShared,
        'Prefer larger shared memory and smaller L1 cache\n'
    ){{endif}}
    {{if 'cudaFuncCachePreferL1' in found_values}}

    cudaFuncCachePreferL1 = (
        cyruntime.cudaFuncCache.cudaFuncCachePreferL1,
        'Prefer larger L1 cache and smaller shared memory\n'
    ){{endif}}
    {{if 'cudaFuncCachePreferEqual' in found_values}}

    cudaFuncCachePreferEqual = (
        cyruntime.cudaFuncCache.cudaFuncCachePreferEqual,
        'Prefer equal size L1 cache and shared memory\n'
    ){{endif}}

{{endif}}
{{if 'cudaSharedMemConfig' in found_types}}

class cudaSharedMemConfig(_FastEnum):
    """
    CUDA shared memory configuration [Deprecated]
    """
    {{if 'cudaSharedMemBankSizeDefault' in found_values}}
    cudaSharedMemBankSizeDefault = cyruntime.cudaSharedMemConfig.cudaSharedMemBankSizeDefault{{endif}}
    {{if 'cudaSharedMemBankSizeFourByte' in found_values}}
    cudaSharedMemBankSizeFourByte = cyruntime.cudaSharedMemConfig.cudaSharedMemBankSizeFourByte{{endif}}
    {{if 'cudaSharedMemBankSizeEightByte' in found_values}}
    cudaSharedMemBankSizeEightByte = cyruntime.cudaSharedMemConfig.cudaSharedMemBankSizeEightByte{{endif}}

{{endif}}
{{if 'cudaSharedCarveout' in found_types}}

class cudaSharedCarveout(_FastEnum):
    """
    Shared memory carveout configurations. These may be passed to
    cudaFuncSetAttribute
    """
    {{if 'cudaSharedmemCarveoutDefault' in found_values}}

    cudaSharedmemCarveoutDefault = (
        cyruntime.cudaSharedCarveout.cudaSharedmemCarveoutDefault,
        'No preference for shared memory or L1 (default)\n'
    ){{endif}}
    {{if 'cudaSharedmemCarveoutMaxL1' in found_values}}

    cudaSharedmemCarveoutMaxL1 = (
        cyruntime.cudaSharedCarveout.cudaSharedmemCarveoutMaxL1,
        'Prefer maximum available L1 cache, minimum shared memory\n'
    ){{endif}}
    {{if 'cudaSharedmemCarveoutMaxShared' in found_values}}

    cudaSharedmemCarveoutMaxShared = (
        cyruntime.cudaSharedCarveout.cudaSharedmemCarveoutMaxShared,
        'Prefer maximum available shared memory, minimum L1 cache\n'
    ){{endif}}

{{endif}}
{{if 'cudaComputeMode' in found_types}}

class cudaComputeMode(_FastEnum):
    """
    CUDA device compute modes
    """
    {{if 'cudaComputeModeDefault' in found_values}}

    cudaComputeModeDefault = (
        cyruntime.cudaComputeMode.cudaComputeModeDefault,
        'Default compute mode (Multiple threads can use :py:obj:`~.cudaSetDevice()`\n'
        'with this device)\n'
    ){{endif}}
    {{if 'cudaComputeModeExclusive' in found_values}}

    cudaComputeModeExclusive = (
        cyruntime.cudaComputeMode.cudaComputeModeExclusive,
        'Compute-exclusive-thread mode (Only one thread in one process will be able\n'
        'to use :py:obj:`~.cudaSetDevice()` with this device)\n'
    ){{endif}}
    {{if 'cudaComputeModeProhibited' in found_values}}

    cudaComputeModeProhibited = (
        cyruntime.cudaComputeMode.cudaComputeModeProhibited,
        'Compute-prohibited mode (No threads can use :py:obj:`~.cudaSetDevice()`\n'
        'with this device)\n'
    ){{endif}}
    {{if 'cudaComputeModeExclusiveProcess' in found_values}}

    cudaComputeModeExclusiveProcess = (
        cyruntime.cudaComputeMode.cudaComputeModeExclusiveProcess,
        'Compute-exclusive-process mode (Many threads in one process will be able to\n'
        'use :py:obj:`~.cudaSetDevice()` with this device)\n'
    ){{endif}}

{{endif}}
{{if 'cudaLimit' in found_types}}

class cudaLimit(_FastEnum):
    """
    CUDA Limits
    """
    {{if 'cudaLimitStackSize' in found_values}}

    cudaLimitStackSize = (
        cyruntime.cudaLimit.cudaLimitStackSize,
        'GPU thread stack size\n'
    ){{endif}}
    {{if 'cudaLimitPrintfFifoSize' in found_values}}

    cudaLimitPrintfFifoSize = (
        cyruntime.cudaLimit.cudaLimitPrintfFifoSize,
        'GPU printf FIFO size\n'
    ){{endif}}
    {{if 'cudaLimitMallocHeapSize' in found_values}}

    cudaLimitMallocHeapSize = (
        cyruntime.cudaLimit.cudaLimitMallocHeapSize,
        'GPU malloc heap size\n'
    ){{endif}}
    {{if 'cudaLimitDevRuntimeSyncDepth' in found_values}}

    cudaLimitDevRuntimeSyncDepth = (
        cyruntime.cudaLimit.cudaLimitDevRuntimeSyncDepth,
        'GPU device runtime synchronize depth\n'
    ){{endif}}
    {{if 'cudaLimitDevRuntimePendingLaunchCount' in found_values}}

    cudaLimitDevRuntimePendingLaunchCount = (
        cyruntime.cudaLimit.cudaLimitDevRuntimePendingLaunchCount,
        'GPU device runtime pending launch count\n'
    ){{endif}}
    {{if 'cudaLimitMaxL2FetchGranularity' in found_values}}

    cudaLimitMaxL2FetchGranularity = (
        cyruntime.cudaLimit.cudaLimitMaxL2FetchGranularity,
        'A value between 0 and 128 that indicates the maximum fetch granularity of\n'
        'L2 (in Bytes). This is a hint\n'
    ){{endif}}
    {{if 'cudaLimitPersistingL2CacheSize' in found_values}}

    cudaLimitPersistingL2CacheSize = (
        cyruntime.cudaLimit.cudaLimitPersistingL2CacheSize,
        'A size in bytes for L2 persisting lines cache size\n'
    ){{endif}}

{{endif}}
{{if 'cudaMemoryAdvise' in found_types}}

class cudaMemoryAdvise(_FastEnum):
    """
    CUDA Memory Advise values
    """
    {{if 'cudaMemAdviseSetReadMostly' in found_values}}

    cudaMemAdviseSetReadMostly = (
        cyruntime.cudaMemoryAdvise.cudaMemAdviseSetReadMostly,
        'Data will mostly be read and only occassionally be written to\n'
    ){{endif}}
    {{if 'cudaMemAdviseUnsetReadMostly' in found_values}}

    cudaMemAdviseUnsetReadMostly = (
        cyruntime.cudaMemoryAdvise.cudaMemAdviseUnsetReadMostly,
        'Undo the effect of :py:obj:`~.cudaMemAdviseSetReadMostly`\n'
    ){{endif}}
    {{if 'cudaMemAdviseSetPreferredLocation' in found_values}}

    cudaMemAdviseSetPreferredLocation = (
        cyruntime.cudaMemoryAdvise.cudaMemAdviseSetPreferredLocation,
        'Set the preferred location for the data as the specified device\n'
    ){{endif}}
    {{if 'cudaMemAdviseUnsetPreferredLocation' in found_values}}

    cudaMemAdviseUnsetPreferredLocation = (
        cyruntime.cudaMemoryAdvise.cudaMemAdviseUnsetPreferredLocation,
        'Clear the preferred location for the data\n'
    ){{endif}}
    {{if 'cudaMemAdviseSetAccessedBy' in found_values}}

    cudaMemAdviseSetAccessedBy = (
        cyruntime.cudaMemoryAdvise.cudaMemAdviseSetAccessedBy,
        'Data will be accessed by the specified device, so prevent page faults as\n'
        'much as possible\n'
    ){{endif}}
    {{if 'cudaMemAdviseUnsetAccessedBy' in found_values}}

    cudaMemAdviseUnsetAccessedBy = (
        cyruntime.cudaMemoryAdvise.cudaMemAdviseUnsetAccessedBy,
        'Let the Unified Memory subsystem decide on the page faulting policy for the\n'
        'specified device\n'
    ){{endif}}

{{endif}}
{{if 'cudaMemRangeAttribute' in found_types}}

class cudaMemRangeAttribute(_FastEnum):
    """
    CUDA range attributes
    """
    {{if 'cudaMemRangeAttributeReadMostly' in found_values}}

    cudaMemRangeAttributeReadMostly = (
        cyruntime.cudaMemRangeAttribute.cudaMemRangeAttributeReadMostly,
        'Whether the range will mostly be read and only occassionally be written to\n'
    ){{endif}}
    {{if 'cudaMemRangeAttributePreferredLocation' in found_values}}

    cudaMemRangeAttributePreferredLocation = (
        cyruntime.cudaMemRangeAttribute.cudaMemRangeAttributePreferredLocation,
        'The preferred location of the range\n'
    ){{endif}}
    {{if 'cudaMemRangeAttributeAccessedBy' in found_values}}

    cudaMemRangeAttributeAccessedBy = (
        cyruntime.cudaMemRangeAttribute.cudaMemRangeAttributeAccessedBy,
        'Memory range has :py:obj:`~.cudaMemAdviseSetAccessedBy` set for specified\n'
        'device\n'
    ){{endif}}
    {{if 'cudaMemRangeAttributeLastPrefetchLocation' in found_values}}

    cudaMemRangeAttributeLastPrefetchLocation = (
        cyruntime.cudaMemRangeAttribute.cudaMemRangeAttributeLastPrefetchLocation,
        'The last location to which the range was prefetched\n'
    ){{endif}}
    {{if 'cudaMemRangeAttributePreferredLocationType' in found_values}}

    cudaMemRangeAttributePreferredLocationType = (
        cyruntime.cudaMemRangeAttribute.cudaMemRangeAttributePreferredLocationType,
        'The preferred location type of the range\n'
    ){{endif}}
    {{if 'cudaMemRangeAttributePreferredLocationId' in found_values}}

    cudaMemRangeAttributePreferredLocationId = (
        cyruntime.cudaMemRangeAttribute.cudaMemRangeAttributePreferredLocationId,
        'The preferred location id of the range\n'
    ){{endif}}
    {{if 'cudaMemRangeAttributeLastPrefetchLocationType' in found_values}}

    cudaMemRangeAttributeLastPrefetchLocationType = (
        cyruntime.cudaMemRangeAttribute.cudaMemRangeAttributeLastPrefetchLocationType,
        'The last location type to which the range was prefetched\n'
    ){{endif}}
    {{if 'cudaMemRangeAttributeLastPrefetchLocationId' in found_values}}

    cudaMemRangeAttributeLastPrefetchLocationId = (
        cyruntime.cudaMemRangeAttribute.cudaMemRangeAttributeLastPrefetchLocationId,
        'The last location id to which the range was prefetched\n'
    ){{endif}}

{{endif}}
{{if 'cudaFlushGPUDirectRDMAWritesOptions' in found_types}}

class cudaFlushGPUDirectRDMAWritesOptions(_FastEnum):
    """
    CUDA GPUDirect RDMA flush writes APIs supported on the device
    """
    {{if 'cudaFlushGPUDirectRDMAWritesOptionHost' in found_values}}

    cudaFlushGPUDirectRDMAWritesOptionHost = (
        cyruntime.cudaFlushGPUDirectRDMAWritesOptions.cudaFlushGPUDirectRDMAWritesOptionHost,
        ':py:obj:`~.cudaDeviceFlushGPUDirectRDMAWrites()` and its CUDA Driver API\n'
        'counterpart are supported on the device.\n'
    ){{endif}}
    {{if 'cudaFlushGPUDirectRDMAWritesOptionMemOps' in found_values}}

    cudaFlushGPUDirectRDMAWritesOptionMemOps = (
        cyruntime.cudaFlushGPUDirectRDMAWritesOptions.cudaFlushGPUDirectRDMAWritesOptionMemOps,
        'The :py:obj:`~.CU_STREAM_WAIT_VALUE_FLUSH` flag and the\n'
        ':py:obj:`~.CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES` MemOp are supported on the\n'
        'CUDA device.\n'
    ){{endif}}

{{endif}}
{{if 'cudaGPUDirectRDMAWritesOrdering' in found_types}}

class cudaGPUDirectRDMAWritesOrdering(_FastEnum):
    """
    CUDA GPUDirect RDMA flush writes ordering features of the device
    """
    {{if 'cudaGPUDirectRDMAWritesOrderingNone' in found_values}}

    cudaGPUDirectRDMAWritesOrderingNone = (
        cyruntime.cudaGPUDirectRDMAWritesOrdering.cudaGPUDirectRDMAWritesOrderingNone,
        'The device does not natively support ordering of GPUDirect RDMA writes.\n'
        ':py:obj:`~.cudaFlushGPUDirectRDMAWrites()` can be leveraged if supported.\n'
    ){{endif}}
    {{if 'cudaGPUDirectRDMAWritesOrderingOwner' in found_values}}

    cudaGPUDirectRDMAWritesOrderingOwner = (
        cyruntime.cudaGPUDirectRDMAWritesOrdering.cudaGPUDirectRDMAWritesOrderingOwner,
        'Natively, the device can consistently consume GPUDirect RDMA writes,\n'
        'although other CUDA devices may not.\n'
    ){{endif}}
    {{if 'cudaGPUDirectRDMAWritesOrderingAllDevices' in found_values}}

    cudaGPUDirectRDMAWritesOrderingAllDevices = (
        cyruntime.cudaGPUDirectRDMAWritesOrdering.cudaGPUDirectRDMAWritesOrderingAllDevices,
        'Any CUDA device in the system can consistently consume GPUDirect RDMA\n'
        'writes to this device.\n'
    ){{endif}}

{{endif}}
{{if 'cudaFlushGPUDirectRDMAWritesScope' in found_types}}

class cudaFlushGPUDirectRDMAWritesScope(_FastEnum):
    """
    CUDA GPUDirect RDMA flush writes scopes
    """
    {{if 'cudaFlushGPUDirectRDMAWritesToOwner' in found_values}}

    cudaFlushGPUDirectRDMAWritesToOwner = (
        cyruntime.cudaFlushGPUDirectRDMAWritesScope.cudaFlushGPUDirectRDMAWritesToOwner,
        'Blocks until remote writes are visible to the CUDA device context owning\n'
        'the data.\n'
    ){{endif}}
    {{if 'cudaFlushGPUDirectRDMAWritesToAllDevices' in found_values}}

    cudaFlushGPUDirectRDMAWritesToAllDevices = (
        cyruntime.cudaFlushGPUDirectRDMAWritesScope.cudaFlushGPUDirectRDMAWritesToAllDevices,
        'Blocks until remote writes are visible to all CUDA device contexts.\n'
    ){{endif}}

{{endif}}
{{if 'cudaFlushGPUDirectRDMAWritesTarget' in found_types}}

class cudaFlushGPUDirectRDMAWritesTarget(_FastEnum):
    """
    CUDA GPUDirect RDMA flush writes targets
    """
    {{if 'cudaFlushGPUDirectRDMAWritesTargetCurrentDevice' in found_values}}

    cudaFlushGPUDirectRDMAWritesTargetCurrentDevice = (
        cyruntime.cudaFlushGPUDirectRDMAWritesTarget.cudaFlushGPUDirectRDMAWritesTargetCurrentDevice,
        'Sets the target for :py:obj:`~.cudaDeviceFlushGPUDirectRDMAWrites()` to the\n'
        'currently active CUDA device context.\n'
    ){{endif}}

{{endif}}
{{if 'cudaDeviceAttr' in found_types}}

class cudaDeviceAttr(_FastEnum):
    """
    CUDA device attributes
    """
    {{if 'cudaDevAttrMaxThreadsPerBlock' in found_values}}

    cudaDevAttrMaxThreadsPerBlock = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxThreadsPerBlock,
        'Maximum number of threads per block\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxBlockDimX' in found_values}}

    cudaDevAttrMaxBlockDimX = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxBlockDimX,
        'Maximum block dimension X\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxBlockDimY' in found_values}}

    cudaDevAttrMaxBlockDimY = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxBlockDimY,
        'Maximum block dimension Y\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxBlockDimZ' in found_values}}

    cudaDevAttrMaxBlockDimZ = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxBlockDimZ,
        'Maximum block dimension Z\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxGridDimX' in found_values}}

    cudaDevAttrMaxGridDimX = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxGridDimX,
        'Maximum grid dimension X\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxGridDimY' in found_values}}

    cudaDevAttrMaxGridDimY = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxGridDimY,
        'Maximum grid dimension Y\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxGridDimZ' in found_values}}

    cudaDevAttrMaxGridDimZ = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxGridDimZ,
        'Maximum grid dimension Z\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxSharedMemoryPerBlock' in found_values}}

    cudaDevAttrMaxSharedMemoryPerBlock = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxSharedMemoryPerBlock,
        'Maximum shared memory available per block in bytes\n'
    ){{endif}}
    {{if 'cudaDevAttrTotalConstantMemory' in found_values}}

    cudaDevAttrTotalConstantMemory = (
        cyruntime.cudaDeviceAttr.cudaDevAttrTotalConstantMemory,
        'Memory available on device for constant variables in a CUDA C kernel in\n'
        'bytes\n'
    ){{endif}}
    {{if 'cudaDevAttrWarpSize' in found_values}}

    cudaDevAttrWarpSize = (
        cyruntime.cudaDeviceAttr.cudaDevAttrWarpSize,
        'Warp size in threads\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxPitch' in found_values}}

    cudaDevAttrMaxPitch = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxPitch,
        'Maximum pitch in bytes allowed by memory copies\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxRegistersPerBlock' in found_values}}

    cudaDevAttrMaxRegistersPerBlock = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxRegistersPerBlock,
        'Maximum number of 32-bit registers available per block\n'
    ){{endif}}
    {{if 'cudaDevAttrClockRate' in found_values}}

    cudaDevAttrClockRate = (
        cyruntime.cudaDeviceAttr.cudaDevAttrClockRate,
        'Peak clock frequency in kilohertz\n'
    ){{endif}}
    {{if 'cudaDevAttrTextureAlignment' in found_values}}

    cudaDevAttrTextureAlignment = (
        cyruntime.cudaDeviceAttr.cudaDevAttrTextureAlignment,
        'Alignment requirement for textures\n'
    ){{endif}}
    {{if 'cudaDevAttrGpuOverlap' in found_values}}

    cudaDevAttrGpuOverlap = (
        cyruntime.cudaDeviceAttr.cudaDevAttrGpuOverlap,
        'Device can possibly copy memory and execute a kernel concurrently\n'
    ){{endif}}
    {{if 'cudaDevAttrMultiProcessorCount' in found_values}}

    cudaDevAttrMultiProcessorCount = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMultiProcessorCount,
        'Number of multiprocessors on device\n'
    ){{endif}}
    {{if 'cudaDevAttrKernelExecTimeout' in found_values}}

    cudaDevAttrKernelExecTimeout = (
        cyruntime.cudaDeviceAttr.cudaDevAttrKernelExecTimeout,
        'Specifies whether there is a run time limit on kernels\n'
    ){{endif}}
    {{if 'cudaDevAttrIntegrated' in found_values}}

    cudaDevAttrIntegrated = (
        cyruntime.cudaDeviceAttr.cudaDevAttrIntegrated,
        'Device is integrated with host memory\n'
    ){{endif}}
    {{if 'cudaDevAttrCanMapHostMemory' in found_values}}

    cudaDevAttrCanMapHostMemory = (
        cyruntime.cudaDeviceAttr.cudaDevAttrCanMapHostMemory,
        'Device can map host memory into CUDA address space\n'
    ){{endif}}
    {{if 'cudaDevAttrComputeMode' in found_values}}

    cudaDevAttrComputeMode = (
        cyruntime.cudaDeviceAttr.cudaDevAttrComputeMode,
        'Compute mode (See :py:obj:`~.cudaComputeMode` for details)\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture1DWidth' in found_values}}

    cudaDevAttrMaxTexture1DWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture1DWidth,
        'Maximum 1D texture width\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture2DWidth' in found_values}}

    cudaDevAttrMaxTexture2DWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture2DWidth,
        'Maximum 2D texture width\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture2DHeight' in found_values}}

    cudaDevAttrMaxTexture2DHeight = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture2DHeight,
        'Maximum 2D texture height\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture3DWidth' in found_values}}

    cudaDevAttrMaxTexture3DWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture3DWidth,
        'Maximum 3D texture width\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture3DHeight' in found_values}}

    cudaDevAttrMaxTexture3DHeight = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture3DHeight,
        'Maximum 3D texture height\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture3DDepth' in found_values}}

    cudaDevAttrMaxTexture3DDepth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture3DDepth,
        'Maximum 3D texture depth\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture2DLayeredWidth' in found_values}}

    cudaDevAttrMaxTexture2DLayeredWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture2DLayeredWidth,
        'Maximum 2D layered texture width\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture2DLayeredHeight' in found_values}}

    cudaDevAttrMaxTexture2DLayeredHeight = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture2DLayeredHeight,
        'Maximum 2D layered texture height\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture2DLayeredLayers' in found_values}}

    cudaDevAttrMaxTexture2DLayeredLayers = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture2DLayeredLayers,
        'Maximum layers in a 2D layered texture\n'
    ){{endif}}
    {{if 'cudaDevAttrSurfaceAlignment' in found_values}}

    cudaDevAttrSurfaceAlignment = (
        cyruntime.cudaDeviceAttr.cudaDevAttrSurfaceAlignment,
        'Alignment requirement for surfaces\n'
    ){{endif}}
    {{if 'cudaDevAttrConcurrentKernels' in found_values}}

    cudaDevAttrConcurrentKernels = (
        cyruntime.cudaDeviceAttr.cudaDevAttrConcurrentKernels,
        'Device can possibly execute multiple kernels concurrently\n'
    ){{endif}}
    {{if 'cudaDevAttrEccEnabled' in found_values}}

    cudaDevAttrEccEnabled = (
        cyruntime.cudaDeviceAttr.cudaDevAttrEccEnabled,
        'Device has ECC support enabled\n'
    ){{endif}}
    {{if 'cudaDevAttrPciBusId' in found_values}}

    cudaDevAttrPciBusId = (
        cyruntime.cudaDeviceAttr.cudaDevAttrPciBusId,
        'PCI bus ID of the device\n'
    ){{endif}}
    {{if 'cudaDevAttrPciDeviceId' in found_values}}

    cudaDevAttrPciDeviceId = (
        cyruntime.cudaDeviceAttr.cudaDevAttrPciDeviceId,
        'PCI device ID of the device\n'
    ){{endif}}
    {{if 'cudaDevAttrTccDriver' in found_values}}

    cudaDevAttrTccDriver = (
        cyruntime.cudaDeviceAttr.cudaDevAttrTccDriver,
        'Device is using TCC driver model\n'
    ){{endif}}
    {{if 'cudaDevAttrMemoryClockRate' in found_values}}

    cudaDevAttrMemoryClockRate = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMemoryClockRate,
        'Peak memory clock frequency in kilohertz\n'
    ){{endif}}
    {{if 'cudaDevAttrGlobalMemoryBusWidth' in found_values}}

    cudaDevAttrGlobalMemoryBusWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrGlobalMemoryBusWidth,
        'Global memory bus width in bits\n'
    ){{endif}}
    {{if 'cudaDevAttrL2CacheSize' in found_values}}

    cudaDevAttrL2CacheSize = (
        cyruntime.cudaDeviceAttr.cudaDevAttrL2CacheSize,
        'Size of L2 cache in bytes\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxThreadsPerMultiProcessor' in found_values}}

    cudaDevAttrMaxThreadsPerMultiProcessor = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxThreadsPerMultiProcessor,
        'Maximum resident threads per multiprocessor\n'
    ){{endif}}
    {{if 'cudaDevAttrAsyncEngineCount' in found_values}}

    cudaDevAttrAsyncEngineCount = (
        cyruntime.cudaDeviceAttr.cudaDevAttrAsyncEngineCount,
        'Number of asynchronous engines\n'
    ){{endif}}
    {{if 'cudaDevAttrUnifiedAddressing' in found_values}}

    cudaDevAttrUnifiedAddressing = (
        cyruntime.cudaDeviceAttr.cudaDevAttrUnifiedAddressing,
        'Device shares a unified address space with the host\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture1DLayeredWidth' in found_values}}

    cudaDevAttrMaxTexture1DLayeredWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture1DLayeredWidth,
        'Maximum 1D layered texture width\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture1DLayeredLayers' in found_values}}

    cudaDevAttrMaxTexture1DLayeredLayers = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture1DLayeredLayers,
        'Maximum layers in a 1D layered texture\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture2DGatherWidth' in found_values}}

    cudaDevAttrMaxTexture2DGatherWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture2DGatherWidth,
        'Maximum 2D texture width if cudaArrayTextureGather is set\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture2DGatherHeight' in found_values}}

    cudaDevAttrMaxTexture2DGatherHeight = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture2DGatherHeight,
        'Maximum 2D texture height if cudaArrayTextureGather is set\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture3DWidthAlt' in found_values}}

    cudaDevAttrMaxTexture3DWidthAlt = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture3DWidthAlt,
        'Alternate maximum 3D texture width\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture3DHeightAlt' in found_values}}

    cudaDevAttrMaxTexture3DHeightAlt = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture3DHeightAlt,
        'Alternate maximum 3D texture height\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture3DDepthAlt' in found_values}}

    cudaDevAttrMaxTexture3DDepthAlt = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture3DDepthAlt,
        'Alternate maximum 3D texture depth\n'
    ){{endif}}
    {{if 'cudaDevAttrPciDomainId' in found_values}}

    cudaDevAttrPciDomainId = (
        cyruntime.cudaDeviceAttr.cudaDevAttrPciDomainId,
        'PCI domain ID of the device\n'
    ){{endif}}
    {{if 'cudaDevAttrTexturePitchAlignment' in found_values}}

    cudaDevAttrTexturePitchAlignment = (
        cyruntime.cudaDeviceAttr.cudaDevAttrTexturePitchAlignment,
        'Pitch alignment requirement for textures\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTextureCubemapWidth' in found_values}}

    cudaDevAttrMaxTextureCubemapWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTextureCubemapWidth,
        'Maximum cubemap texture width/height\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTextureCubemapLayeredWidth' in found_values}}

    cudaDevAttrMaxTextureCubemapLayeredWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTextureCubemapLayeredWidth,
        'Maximum cubemap layered texture width/height\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTextureCubemapLayeredLayers' in found_values}}

    cudaDevAttrMaxTextureCubemapLayeredLayers = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTextureCubemapLayeredLayers,
        'Maximum layers in a cubemap layered texture\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxSurface1DWidth' in found_values}}

    cudaDevAttrMaxSurface1DWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxSurface1DWidth,
        'Maximum 1D surface width\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxSurface2DWidth' in found_values}}

    cudaDevAttrMaxSurface2DWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxSurface2DWidth,
        'Maximum 2D surface width\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxSurface2DHeight' in found_values}}

    cudaDevAttrMaxSurface2DHeight = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxSurface2DHeight,
        'Maximum 2D surface height\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxSurface3DWidth' in found_values}}

    cudaDevAttrMaxSurface3DWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxSurface3DWidth,
        'Maximum 3D surface width\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxSurface3DHeight' in found_values}}

    cudaDevAttrMaxSurface3DHeight = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxSurface3DHeight,
        'Maximum 3D surface height\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxSurface3DDepth' in found_values}}

    cudaDevAttrMaxSurface3DDepth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxSurface3DDepth,
        'Maximum 3D surface depth\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxSurface1DLayeredWidth' in found_values}}

    cudaDevAttrMaxSurface1DLayeredWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxSurface1DLayeredWidth,
        'Maximum 1D layered surface width\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxSurface1DLayeredLayers' in found_values}}

    cudaDevAttrMaxSurface1DLayeredLayers = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxSurface1DLayeredLayers,
        'Maximum layers in a 1D layered surface\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxSurface2DLayeredWidth' in found_values}}

    cudaDevAttrMaxSurface2DLayeredWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxSurface2DLayeredWidth,
        'Maximum 2D layered surface width\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxSurface2DLayeredHeight' in found_values}}

    cudaDevAttrMaxSurface2DLayeredHeight = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxSurface2DLayeredHeight,
        'Maximum 2D layered surface height\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxSurface2DLayeredLayers' in found_values}}

    cudaDevAttrMaxSurface2DLayeredLayers = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxSurface2DLayeredLayers,
        'Maximum layers in a 2D layered surface\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxSurfaceCubemapWidth' in found_values}}

    cudaDevAttrMaxSurfaceCubemapWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxSurfaceCubemapWidth,
        'Maximum cubemap surface width\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxSurfaceCubemapLayeredWidth' in found_values}}

    cudaDevAttrMaxSurfaceCubemapLayeredWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxSurfaceCubemapLayeredWidth,
        'Maximum cubemap layered surface width\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxSurfaceCubemapLayeredLayers' in found_values}}

    cudaDevAttrMaxSurfaceCubemapLayeredLayers = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxSurfaceCubemapLayeredLayers,
        'Maximum layers in a cubemap layered surface\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture1DLinearWidth' in found_values}}

    cudaDevAttrMaxTexture1DLinearWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture1DLinearWidth,
        'Maximum 1D linear texture width\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture2DLinearWidth' in found_values}}

    cudaDevAttrMaxTexture2DLinearWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture2DLinearWidth,
        'Maximum 2D linear texture width\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture2DLinearHeight' in found_values}}

    cudaDevAttrMaxTexture2DLinearHeight = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture2DLinearHeight,
        'Maximum 2D linear texture height\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture2DLinearPitch' in found_values}}

    cudaDevAttrMaxTexture2DLinearPitch = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture2DLinearPitch,
        'Maximum 2D linear texture pitch in bytes\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture2DMipmappedWidth' in found_values}}

    cudaDevAttrMaxTexture2DMipmappedWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture2DMipmappedWidth,
        'Maximum mipmapped 2D texture width\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture2DMipmappedHeight' in found_values}}

    cudaDevAttrMaxTexture2DMipmappedHeight = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture2DMipmappedHeight,
        'Maximum mipmapped 2D texture height\n'
    ){{endif}}
    {{if 'cudaDevAttrComputeCapabilityMajor' in found_values}}

    cudaDevAttrComputeCapabilityMajor = (
        cyruntime.cudaDeviceAttr.cudaDevAttrComputeCapabilityMajor,
        'Major compute capability version number\n'
    ){{endif}}
    {{if 'cudaDevAttrComputeCapabilityMinor' in found_values}}

    cudaDevAttrComputeCapabilityMinor = (
        cyruntime.cudaDeviceAttr.cudaDevAttrComputeCapabilityMinor,
        'Minor compute capability version number\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxTexture1DMipmappedWidth' in found_values}}

    cudaDevAttrMaxTexture1DMipmappedWidth = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxTexture1DMipmappedWidth,
        'Maximum mipmapped 1D texture width\n'
    ){{endif}}
    {{if 'cudaDevAttrStreamPrioritiesSupported' in found_values}}

    cudaDevAttrStreamPrioritiesSupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrStreamPrioritiesSupported,
        'Device supports stream priorities\n'
    ){{endif}}
    {{if 'cudaDevAttrGlobalL1CacheSupported' in found_values}}

    cudaDevAttrGlobalL1CacheSupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrGlobalL1CacheSupported,
        'Device supports caching globals in L1\n'
    ){{endif}}
    {{if 'cudaDevAttrLocalL1CacheSupported' in found_values}}

    cudaDevAttrLocalL1CacheSupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrLocalL1CacheSupported,
        'Device supports caching locals in L1\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxSharedMemoryPerMultiprocessor' in found_values}}

    cudaDevAttrMaxSharedMemoryPerMultiprocessor = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxSharedMemoryPerMultiprocessor,
        'Maximum shared memory available per multiprocessor in bytes\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxRegistersPerMultiprocessor' in found_values}}

    cudaDevAttrMaxRegistersPerMultiprocessor = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxRegistersPerMultiprocessor,
        'Maximum number of 32-bit registers available per multiprocessor\n'
    ){{endif}}
    {{if 'cudaDevAttrManagedMemory' in found_values}}

    cudaDevAttrManagedMemory = (
        cyruntime.cudaDeviceAttr.cudaDevAttrManagedMemory,
        'Device can allocate managed memory on this system\n'
    ){{endif}}
    {{if 'cudaDevAttrIsMultiGpuBoard' in found_values}}

    cudaDevAttrIsMultiGpuBoard = (
        cyruntime.cudaDeviceAttr.cudaDevAttrIsMultiGpuBoard,
        'Device is on a multi-GPU board\n'
    ){{endif}}
    {{if 'cudaDevAttrMultiGpuBoardGroupID' in found_values}}

    cudaDevAttrMultiGpuBoardGroupID = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMultiGpuBoardGroupID,
        'Unique identifier for a group of devices on the same multi-GPU board\n'
    ){{endif}}
    {{if 'cudaDevAttrHostNativeAtomicSupported' in found_values}}

    cudaDevAttrHostNativeAtomicSupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrHostNativeAtomicSupported,
        'Link between the device and the host supports native atomic operations\n'
    ){{endif}}
    {{if 'cudaDevAttrSingleToDoublePrecisionPerfRatio' in found_values}}

    cudaDevAttrSingleToDoublePrecisionPerfRatio = (
        cyruntime.cudaDeviceAttr.cudaDevAttrSingleToDoublePrecisionPerfRatio,
        'Ratio of single precision performance (in floating-point operations per\n'
        'second) to double precision performance\n'
    ){{endif}}
    {{if 'cudaDevAttrPageableMemoryAccess' in found_values}}

    cudaDevAttrPageableMemoryAccess = (
        cyruntime.cudaDeviceAttr.cudaDevAttrPageableMemoryAccess,
        'Device supports coherently accessing pageable memory without calling\n'
        'cudaHostRegister on it\n'
    ){{endif}}
    {{if 'cudaDevAttrConcurrentManagedAccess' in found_values}}

    cudaDevAttrConcurrentManagedAccess = (
        cyruntime.cudaDeviceAttr.cudaDevAttrConcurrentManagedAccess,
        'Device can coherently access managed memory concurrently with the CPU\n'
    ){{endif}}
    {{if 'cudaDevAttrComputePreemptionSupported' in found_values}}

    cudaDevAttrComputePreemptionSupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrComputePreemptionSupported,
        'Device supports Compute Preemption\n'
    ){{endif}}
    {{if 'cudaDevAttrCanUseHostPointerForRegisteredMem' in found_values}}

    cudaDevAttrCanUseHostPointerForRegisteredMem = (
        cyruntime.cudaDeviceAttr.cudaDevAttrCanUseHostPointerForRegisteredMem,
        'Device can access host registered memory at the same virtual address as the\n'
        'CPU\n'
    ){{endif}}
    {{if 'cudaDevAttrReserved92' in found_values}}
    cudaDevAttrReserved92 = cyruntime.cudaDeviceAttr.cudaDevAttrReserved92{{endif}}
    {{if 'cudaDevAttrReserved93' in found_values}}
    cudaDevAttrReserved93 = cyruntime.cudaDeviceAttr.cudaDevAttrReserved93{{endif}}
    {{if 'cudaDevAttrReserved94' in found_values}}
    cudaDevAttrReserved94 = cyruntime.cudaDeviceAttr.cudaDevAttrReserved94{{endif}}
    {{if 'cudaDevAttrCooperativeLaunch' in found_values}}

    cudaDevAttrCooperativeLaunch = (
        cyruntime.cudaDeviceAttr.cudaDevAttrCooperativeLaunch,
        'Device supports launching cooperative kernels via\n'
        ':py:obj:`~.cudaLaunchCooperativeKernel`\n'
    ){{endif}}
    {{if 'cudaDevAttrReserved96' in found_values}}
    cudaDevAttrReserved96 = cyruntime.cudaDeviceAttr.cudaDevAttrReserved96{{endif}}
    {{if 'cudaDevAttrMaxSharedMemoryPerBlockOptin' in found_values}}

    cudaDevAttrMaxSharedMemoryPerBlockOptin = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxSharedMemoryPerBlockOptin,
        'The maximum optin shared memory per block. This value may vary by chip. See\n'
        ':py:obj:`~.cudaFuncSetAttribute`\n'
    ){{endif}}
    {{if 'cudaDevAttrCanFlushRemoteWrites' in found_values}}

    cudaDevAttrCanFlushRemoteWrites = (
        cyruntime.cudaDeviceAttr.cudaDevAttrCanFlushRemoteWrites,
        'Device supports flushing of outstanding remote writes.\n'
    ){{endif}}
    {{if 'cudaDevAttrHostRegisterSupported' in found_values}}

    cudaDevAttrHostRegisterSupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrHostRegisterSupported,
        'Device supports host memory registration via :py:obj:`~.cudaHostRegister`.\n'
    ){{endif}}
    {{if 'cudaDevAttrPageableMemoryAccessUsesHostPageTables' in found_values}}

    cudaDevAttrPageableMemoryAccessUsesHostPageTables = (
        cyruntime.cudaDeviceAttr.cudaDevAttrPageableMemoryAccessUsesHostPageTables,
        "Device accesses pageable memory via the host's page tables.\n"
    ){{endif}}
    {{if 'cudaDevAttrDirectManagedMemAccessFromHost' in found_values}}

    cudaDevAttrDirectManagedMemAccessFromHost = (
        cyruntime.cudaDeviceAttr.cudaDevAttrDirectManagedMemAccessFromHost,
        'Host can directly access managed memory on the device without migration.\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxBlocksPerMultiprocessor' in found_values}}

    cudaDevAttrMaxBlocksPerMultiprocessor = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxBlocksPerMultiprocessor,
        'Maximum number of blocks per multiprocessor\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxPersistingL2CacheSize' in found_values}}

    cudaDevAttrMaxPersistingL2CacheSize = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxPersistingL2CacheSize,
        'Maximum L2 persisting lines capacity setting in bytes.\n'
    ){{endif}}
    {{if 'cudaDevAttrMaxAccessPolicyWindowSize' in found_values}}

    cudaDevAttrMaxAccessPolicyWindowSize = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMaxAccessPolicyWindowSize,
        'Maximum value of :py:obj:`~.cudaAccessPolicyWindow.num_bytes`.\n'
    ){{endif}}
    {{if 'cudaDevAttrReservedSharedMemoryPerBlock' in found_values}}

    cudaDevAttrReservedSharedMemoryPerBlock = (
        cyruntime.cudaDeviceAttr.cudaDevAttrReservedSharedMemoryPerBlock,
        'Shared memory reserved by CUDA driver per block in bytes\n'
    ){{endif}}
    {{if 'cudaDevAttrSparseCudaArraySupported' in found_values}}

    cudaDevAttrSparseCudaArraySupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrSparseCudaArraySupported,
        'Device supports sparse CUDA arrays and sparse CUDA mipmapped arrays\n'
    ){{endif}}
    {{if 'cudaDevAttrHostRegisterReadOnlySupported' in found_values}}

    cudaDevAttrHostRegisterReadOnlySupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrHostRegisterReadOnlySupported,
        'Device supports using the :py:obj:`~.cudaHostRegister` flag\n'
        'cudaHostRegisterReadOnly to register memory that must be mapped as read-\n'
        'only to the GPU\n'
    ){{endif}}
    {{if 'cudaDevAttrTimelineSemaphoreInteropSupported' in found_values}}

    cudaDevAttrTimelineSemaphoreInteropSupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrTimelineSemaphoreInteropSupported,
        'External timeline semaphore interop is supported on the device\n'
    ){{endif}}
    {{if 'cudaDevAttrMemoryPoolsSupported' in found_values}}

    cudaDevAttrMemoryPoolsSupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMemoryPoolsSupported,
        'Device supports using the :py:obj:`~.cudaMallocAsync` and\n'
        ':py:obj:`~.cudaMemPool` family of APIs\n'
    ){{endif}}
    {{if 'cudaDevAttrGPUDirectRDMASupported' in found_values}}

    cudaDevAttrGPUDirectRDMASupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrGPUDirectRDMASupported,
        'Device supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see\n'
        'https://docs.nvidia.com/cuda/gpudirect-rdma for more information)\n'
    ){{endif}}
    {{if 'cudaDevAttrGPUDirectRDMAFlushWritesOptions' in found_values}}

    cudaDevAttrGPUDirectRDMAFlushWritesOptions = (
        cyruntime.cudaDeviceAttr.cudaDevAttrGPUDirectRDMAFlushWritesOptions,
        'The returned attribute shall be interpreted as a bitmask, where the\n'
        'individual bits are listed in the\n'
        ':py:obj:`~.cudaFlushGPUDirectRDMAWritesOptions` enum\n'
    ){{endif}}
    {{if 'cudaDevAttrGPUDirectRDMAWritesOrdering' in found_values}}

    cudaDevAttrGPUDirectRDMAWritesOrdering = (
        cyruntime.cudaDeviceAttr.cudaDevAttrGPUDirectRDMAWritesOrdering,
        'GPUDirect RDMA writes to the device do not need to be flushed for consumers\n'
        'within the scope indicated by the returned attribute. See\n'
        ':py:obj:`~.cudaGPUDirectRDMAWritesOrdering` for the numerical values\n'
        'returned here.\n'
    ){{endif}}
    {{if 'cudaDevAttrMemoryPoolSupportedHandleTypes' in found_values}}

    cudaDevAttrMemoryPoolSupportedHandleTypes = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMemoryPoolSupportedHandleTypes,
        'Handle types supported with mempool based IPC\n'
    ){{endif}}
    {{if 'cudaDevAttrClusterLaunch' in found_values}}

    cudaDevAttrClusterLaunch = (
        cyruntime.cudaDeviceAttr.cudaDevAttrClusterLaunch,
        'Indicates device supports cluster launch\n'
    ){{endif}}
    {{if 'cudaDevAttrDeferredMappingCudaArraySupported' in found_values}}

    cudaDevAttrDeferredMappingCudaArraySupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrDeferredMappingCudaArraySupported,
        'Device supports deferred mapping CUDA arrays and CUDA mipmapped arrays\n'
    ){{endif}}
    {{if 'cudaDevAttrReserved122' in found_values}}
    cudaDevAttrReserved122 = cyruntime.cudaDeviceAttr.cudaDevAttrReserved122{{endif}}
    {{if 'cudaDevAttrReserved123' in found_values}}
    cudaDevAttrReserved123 = cyruntime.cudaDeviceAttr.cudaDevAttrReserved123{{endif}}
    {{if 'cudaDevAttrReserved124' in found_values}}
    cudaDevAttrReserved124 = cyruntime.cudaDeviceAttr.cudaDevAttrReserved124{{endif}}
    {{if 'cudaDevAttrIpcEventSupport' in found_values}}

    cudaDevAttrIpcEventSupport = (
        cyruntime.cudaDeviceAttr.cudaDevAttrIpcEventSupport,
        'Device supports IPC Events.\n'
    ){{endif}}
    {{if 'cudaDevAttrMemSyncDomainCount' in found_values}}

    cudaDevAttrMemSyncDomainCount = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMemSyncDomainCount,
        'Number of memory synchronization domains the device supports.\n'
    ){{endif}}
    {{if 'cudaDevAttrReserved127' in found_values}}
    cudaDevAttrReserved127 = cyruntime.cudaDeviceAttr.cudaDevAttrReserved127{{endif}}
    {{if 'cudaDevAttrReserved128' in found_values}}
    cudaDevAttrReserved128 = cyruntime.cudaDeviceAttr.cudaDevAttrReserved128{{endif}}
    {{if 'cudaDevAttrReserved129' in found_values}}
    cudaDevAttrReserved129 = cyruntime.cudaDeviceAttr.cudaDevAttrReserved129{{endif}}
    {{if 'cudaDevAttrNumaConfig' in found_values}}

    cudaDevAttrNumaConfig = (
        cyruntime.cudaDeviceAttr.cudaDevAttrNumaConfig,
        'NUMA configuration of a device: value is of type\n'
        ':py:obj:`~.cudaDeviceNumaConfig` enum\n'
    ){{endif}}
    {{if 'cudaDevAttrNumaId' in found_values}}

    cudaDevAttrNumaId = (
        cyruntime.cudaDeviceAttr.cudaDevAttrNumaId,
        'NUMA node ID of the GPU memory\n'
    ){{endif}}
    {{if 'cudaDevAttrReserved132' in found_values}}
    cudaDevAttrReserved132 = cyruntime.cudaDeviceAttr.cudaDevAttrReserved132{{endif}}
    {{if 'cudaDevAttrMpsEnabled' in found_values}}

    cudaDevAttrMpsEnabled = (
        cyruntime.cudaDeviceAttr.cudaDevAttrMpsEnabled,
        'Contexts created on this device will be shared via MPS\n'
    ){{endif}}
    {{if 'cudaDevAttrHostNumaId' in found_values}}

    cudaDevAttrHostNumaId = (
        cyruntime.cudaDeviceAttr.cudaDevAttrHostNumaId,
        'NUMA ID of the host node closest to the device or -1 when system does not\n'
        'support NUMA\n'
    ){{endif}}
    {{if 'cudaDevAttrD3D12CigSupported' in found_values}}

    cudaDevAttrD3D12CigSupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrD3D12CigSupported,
        'Device supports CIG with D3D12.\n'
    ){{endif}}
    {{if 'cudaDevAttrVulkanCigSupported' in found_values}}

    cudaDevAttrVulkanCigSupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrVulkanCigSupported,
        'Device supports CIG with Vulkan.\n'
    ){{endif}}
    {{if 'cudaDevAttrGpuPciDeviceId' in found_values}}

    cudaDevAttrGpuPciDeviceId = (
        cyruntime.cudaDeviceAttr.cudaDevAttrGpuPciDeviceId,
        'The combined 16-bit PCI device ID and 16-bit PCI vendor ID.\n'
    ){{endif}}
    {{if 'cudaDevAttrGpuPciSubsystemId' in found_values}}

    cudaDevAttrGpuPciSubsystemId = (
        cyruntime.cudaDeviceAttr.cudaDevAttrGpuPciSubsystemId,
        'The combined 16-bit PCI subsystem ID and 16-bit PCI subsystem vendor ID.\n'
    ){{endif}}
    {{if 'cudaDevAttrReserved141' in found_values}}
    cudaDevAttrReserved141 = cyruntime.cudaDeviceAttr.cudaDevAttrReserved141{{endif}}
    {{if 'cudaDevAttrHostNumaMemoryPoolsSupported' in found_values}}

    cudaDevAttrHostNumaMemoryPoolsSupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrHostNumaMemoryPoolsSupported,
        'Device supports HOST_NUMA location with the :py:obj:`~.cudaMallocAsync` and\n'
        ':py:obj:`~.cudaMemPool` family of APIs\n'
    ){{endif}}
    {{if 'cudaDevAttrHostNumaMultinodeIpcSupported' in found_values}}

    cudaDevAttrHostNumaMultinodeIpcSupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrHostNumaMultinodeIpcSupported,
        'Device supports HostNuma location IPC between nodes in a multi-node system.\n'
    ){{endif}}
    {{if 'cudaDevAttrHostMemoryPoolsSupported' in found_values}}

    cudaDevAttrHostMemoryPoolsSupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrHostMemoryPoolsSupported,
        'Device suports HOST location with the :py:obj:`~.cuMemAllocAsync` and\n'
        ':py:obj:`~.cuMemPool` family of APIs\n'
    ){{endif}}
    {{if 'cudaDevAttrReserved145' in found_values}}
    cudaDevAttrReserved145 = cyruntime.cudaDeviceAttr.cudaDevAttrReserved145{{endif}}
    {{if 'cudaDevAttrOnlyPartialHostNativeAtomicSupported' in found_values}}

    cudaDevAttrOnlyPartialHostNativeAtomicSupported = (
        cyruntime.cudaDeviceAttr.cudaDevAttrOnlyPartialHostNativeAtomicSupported,
        'Link between the device and the host supports only some native atomic\n'
        'operations\n'
    ){{endif}}
    {{if 'cudaDevAttrMax' in found_values}}
    cudaDevAttrMax = cyruntime.cudaDeviceAttr.cudaDevAttrMax{{endif}}

{{endif}}
{{if 'cudaMemPoolAttr' in found_types}}

class cudaMemPoolAttr(_FastEnum):
    """
    CUDA memory pool attributes
    """
    {{if 'cudaMemPoolReuseFollowEventDependencies' in found_values}}

    cudaMemPoolReuseFollowEventDependencies = (
        cyruntime.cudaMemPoolAttr.cudaMemPoolReuseFollowEventDependencies,
        '(value type = int) Allow cuMemAllocAsync to use memory asynchronously freed\n'
        'in another streams as long as a stream ordering dependency of the\n'
        'allocating stream on the free action exists. Cuda events and null stream\n'
        'interactions can create the required stream ordered dependencies. (default\n'
        'enabled)\n'
    ){{endif}}
    {{if 'cudaMemPoolReuseAllowOpportunistic' in found_values}}

    cudaMemPoolReuseAllowOpportunistic = (
        cyruntime.cudaMemPoolAttr.cudaMemPoolReuseAllowOpportunistic,
        '(value type = int) Allow reuse of already completed frees when there is no\n'
        'dependency between the free and allocation. (default enabled)\n'
    ){{endif}}
    {{if 'cudaMemPoolReuseAllowInternalDependencies' in found_values}}

    cudaMemPoolReuseAllowInternalDependencies = (
        cyruntime.cudaMemPoolAttr.cudaMemPoolReuseAllowInternalDependencies,
        '(value type = int) Allow cuMemAllocAsync to insert new stream dependencies\n'
        'in order to establish the stream ordering required to reuse a piece of\n'
        'memory released by cuFreeAsync (default enabled).\n'
    ){{endif}}
    {{if 'cudaMemPoolAttrReleaseThreshold' in found_values}}

    cudaMemPoolAttrReleaseThreshold = (
        cyruntime.cudaMemPoolAttr.cudaMemPoolAttrReleaseThreshold,
        '(value type = cuuint64_t) Amount of reserved memory in bytes to hold onto\n'
        'before trying to release memory back to the OS. When more than the release\n'
        'threshold bytes of memory are held by the memory pool, the allocator will\n'
        'try to release memory back to the OS on the next call to stream, event or\n'
        'context synchronize. (default 0)\n'
    ){{endif}}
    {{if 'cudaMemPoolAttrReservedMemCurrent' in found_values}}

    cudaMemPoolAttrReservedMemCurrent = (
        cyruntime.cudaMemPoolAttr.cudaMemPoolAttrReservedMemCurrent,
        '(value type = cuuint64_t) Amount of backing memory currently allocated for\n'
        'the mempool.\n'
    ){{endif}}
    {{if 'cudaMemPoolAttrReservedMemHigh' in found_values}}

    cudaMemPoolAttrReservedMemHigh = (
        cyruntime.cudaMemPoolAttr.cudaMemPoolAttrReservedMemHigh,
        '(value type = cuuint64_t) High watermark of backing memory allocated for\n'
        'the mempool since the last time it was reset. High watermark can only be\n'
        'reset to zero.\n'
    ){{endif}}
    {{if 'cudaMemPoolAttrUsedMemCurrent' in found_values}}

    cudaMemPoolAttrUsedMemCurrent = (
        cyruntime.cudaMemPoolAttr.cudaMemPoolAttrUsedMemCurrent,
        '(value type = cuuint64_t) Amount of memory from the pool that is currently\n'
        'in use by the application.\n'
    ){{endif}}
    {{if 'cudaMemPoolAttrUsedMemHigh' in found_values}}

    cudaMemPoolAttrUsedMemHigh = (
        cyruntime.cudaMemPoolAttr.cudaMemPoolAttrUsedMemHigh,
        '(value type = cuuint64_t) High watermark of the amount of memory from the\n'
        'pool that was in use by the application since the last time it was reset.\n'
        'High watermark can only be reset to zero.\n'
    ){{endif}}

{{endif}}
{{if 'cudaMemLocationType' in found_types}}

class cudaMemLocationType(_FastEnum):
    """
    Specifies the type of location
    """
    {{if 'cudaMemLocationTypeInvalid' in found_values}}
    cudaMemLocationTypeInvalid = cyruntime.cudaMemLocationType.cudaMemLocationTypeInvalid{{endif}}
    {{if 'cudaMemLocationTypeNone' in found_values}}

    cudaMemLocationTypeNone = (
        cyruntime.cudaMemLocationType.cudaMemLocationTypeNone,
        'Location is unspecified. This is used when creating a managed memory pool\n'
        'to indicate no preferred location for the pool\n'
    ){{endif}}
    {{if 'cudaMemLocationTypeDevice' in found_values}}

    cudaMemLocationTypeDevice = (
        cyruntime.cudaMemLocationType.cudaMemLocationTypeDevice,
        'Location is a device location, thus id is a device ordinal\n'
    ){{endif}}
    {{if 'cudaMemLocationTypeHost' in found_values}}

    cudaMemLocationTypeHost = (
        cyruntime.cudaMemLocationType.cudaMemLocationTypeHost,
        'Location is host, id is ignored\n'
    ){{endif}}
    {{if 'cudaMemLocationTypeHostNuma' in found_values}}

    cudaMemLocationTypeHostNuma = (
        cyruntime.cudaMemLocationType.cudaMemLocationTypeHostNuma,
        'Location is a host NUMA node, thus id is a host NUMA node id\n'
    ){{endif}}
    {{if 'cudaMemLocationTypeHostNumaCurrent' in found_values}}

    cudaMemLocationTypeHostNumaCurrent = (
        cyruntime.cudaMemLocationType.cudaMemLocationTypeHostNumaCurrent,
        "Location is the host NUMA node closest to the current thread's CPU, id is\n"
        'ignored\n'
    ){{endif}}

{{endif}}
{{if 'cudaMemAccessFlags' in found_types}}

class cudaMemAccessFlags(_FastEnum):
    """
    Specifies the memory protection flags for mapping.
    """
    {{if 'cudaMemAccessFlagsProtNone' in found_values}}

    cudaMemAccessFlagsProtNone = (
        cyruntime.cudaMemAccessFlags.cudaMemAccessFlagsProtNone,
        'Default, make the address range not accessible\n'
    ){{endif}}
    {{if 'cudaMemAccessFlagsProtRead' in found_values}}

    cudaMemAccessFlagsProtRead = (
        cyruntime.cudaMemAccessFlags.cudaMemAccessFlagsProtRead,
        'Make the address range read accessible\n'
    ){{endif}}
    {{if 'cudaMemAccessFlagsProtReadWrite' in found_values}}

    cudaMemAccessFlagsProtReadWrite = (
        cyruntime.cudaMemAccessFlags.cudaMemAccessFlagsProtReadWrite,
        'Make the address range read-write accessible\n'
    ){{endif}}

{{endif}}
{{if 'cudaMemAllocationType' in found_types}}

class cudaMemAllocationType(_FastEnum):
    """
    Defines the allocation types available
    """
    {{if 'cudaMemAllocationTypeInvalid' in found_values}}
    cudaMemAllocationTypeInvalid = cyruntime.cudaMemAllocationType.cudaMemAllocationTypeInvalid{{endif}}
    {{if 'cudaMemAllocationTypePinned' in found_values}}

    cudaMemAllocationTypePinned = (
        cyruntime.cudaMemAllocationType.cudaMemAllocationTypePinned,
        "This allocation type is 'pinned', i.e. cannot migrate from its current\n"
        'location while the application is actively using it\n'
    ){{endif}}
    {{if 'cudaMemAllocationTypeManaged' in found_values}}

    cudaMemAllocationTypeManaged = (
        cyruntime.cudaMemAllocationType.cudaMemAllocationTypeManaged,
        'This allocation type is managed memory\n'
    ){{endif}}
    {{if 'cudaMemAllocationTypeMax' in found_values}}
    cudaMemAllocationTypeMax = cyruntime.cudaMemAllocationType.cudaMemAllocationTypeMax{{endif}}

{{endif}}
{{if 'cudaMemAllocationHandleType' in found_types}}

class cudaMemAllocationHandleType(_FastEnum):
    """
    Flags for specifying particular handle types
    """
    {{if 'cudaMemHandleTypeNone' in found_values}}

    cudaMemHandleTypeNone = (
        cyruntime.cudaMemAllocationHandleType.cudaMemHandleTypeNone,
        'Does not allow any export mechanism. >\n'
    ){{endif}}
    {{if 'cudaMemHandleTypePosixFileDescriptor' in found_values}}

    cudaMemHandleTypePosixFileDescriptor = (
        cyruntime.cudaMemAllocationHandleType.cudaMemHandleTypePosixFileDescriptor,
        'Allows a file descriptor to be used for exporting. Permitted only on POSIX\n'
        'systems. (int)\n'
    ){{endif}}
    {{if 'cudaMemHandleTypeWin32' in found_values}}

    cudaMemHandleTypeWin32 = (
        cyruntime.cudaMemAllocationHandleType.cudaMemHandleTypeWin32,
        'Allows a Win32 NT handle to be used for exporting. (HANDLE)\n'
    ){{endif}}
    {{if 'cudaMemHandleTypeWin32Kmt' in found_values}}

    cudaMemHandleTypeWin32Kmt = (
        cyruntime.cudaMemAllocationHandleType.cudaMemHandleTypeWin32Kmt,
        'Allows a Win32 KMT handle to be used for exporting. (D3DKMT_HANDLE)\n'
    ){{endif}}
    {{if 'cudaMemHandleTypeFabric' in found_values}}

    cudaMemHandleTypeFabric = (
        cyruntime.cudaMemAllocationHandleType.cudaMemHandleTypeFabric,
        'Allows a fabric handle to be used for exporting. (cudaMemFabricHandle_t)\n'
    ){{endif}}

{{endif}}
{{if 'cudaGraphMemAttributeType' in found_types}}

class cudaGraphMemAttributeType(_FastEnum):
    """
    Graph memory attributes
    """
    {{if 'cudaGraphMemAttrUsedMemCurrent' in found_values}}

    cudaGraphMemAttrUsedMemCurrent = (
        cyruntime.cudaGraphMemAttributeType.cudaGraphMemAttrUsedMemCurrent,
        '(value type = cuuint64_t) Amount of memory, in bytes, currently associated\n'
        'with graphs.\n'
    ){{endif}}
    {{if 'cudaGraphMemAttrUsedMemHigh' in found_values}}

    cudaGraphMemAttrUsedMemHigh = (
        cyruntime.cudaGraphMemAttributeType.cudaGraphMemAttrUsedMemHigh,
        '(value type = cuuint64_t) High watermark of memory, in bytes, associated\n'
        'with graphs since the last time it was reset. High watermark can only be\n'
        'reset to zero.\n'
    ){{endif}}
    {{if 'cudaGraphMemAttrReservedMemCurrent' in found_values}}

    cudaGraphMemAttrReservedMemCurrent = (
        cyruntime.cudaGraphMemAttributeType.cudaGraphMemAttrReservedMemCurrent,
        '(value type = cuuint64_t) Amount of memory, in bytes, currently allocated\n'
        'for use by the CUDA graphs asynchronous allocator.\n'
    ){{endif}}
    {{if 'cudaGraphMemAttrReservedMemHigh' in found_values}}

    cudaGraphMemAttrReservedMemHigh = (
        cyruntime.cudaGraphMemAttributeType.cudaGraphMemAttrReservedMemHigh,
        '(value type = cuuint64_t) High watermark of memory, in bytes, currently\n'
        'allocated for use by the CUDA graphs asynchronous allocator.\n'
    ){{endif}}

{{endif}}
{{if 'cudaMemcpyFlags' in found_types}}

class cudaMemcpyFlags(_FastEnum):
    """
    Flags to specify for copies within a batch. For more details see
    :py:obj:`~.cudaMemcpyBatchAsync`.
    """
    {{if 'cudaMemcpyFlagDefault' in found_values}}
    cudaMemcpyFlagDefault = cyruntime.cudaMemcpyFlags.cudaMemcpyFlagDefault{{endif}}
    {{if 'cudaMemcpyFlagPreferOverlapWithCompute' in found_values}}

    cudaMemcpyFlagPreferOverlapWithCompute = (
        cyruntime.cudaMemcpyFlags.cudaMemcpyFlagPreferOverlapWithCompute,
        'Hint to the driver to try and overlap the copy with compute work on the\n'
        'SMs.\n'
    ){{endif}}

{{endif}}
{{if 'cudaMemcpySrcAccessOrder' in found_types}}

class cudaMemcpySrcAccessOrder(_FastEnum):
    """

    """
    {{if 'cudaMemcpySrcAccessOrderInvalid' in found_values}}

    cudaMemcpySrcAccessOrderInvalid = (
        cyruntime.cudaMemcpySrcAccessOrder.cudaMemcpySrcAccessOrderInvalid,
        'Default invalid.\n'
    ){{endif}}
    {{if 'cudaMemcpySrcAccessOrderStream' in found_values}}

    cudaMemcpySrcAccessOrderStream = (
        cyruntime.cudaMemcpySrcAccessOrder.cudaMemcpySrcAccessOrderStream,
        'Indicates that access to the source pointer must be in stream order.\n'
    ){{endif}}
    {{if 'cudaMemcpySrcAccessOrderDuringApiCall' in found_values}}

    cudaMemcpySrcAccessOrderDuringApiCall = (
        cyruntime.cudaMemcpySrcAccessOrder.cudaMemcpySrcAccessOrderDuringApiCall,
        'Indicates that access to the source pointer can be out of stream order and\n'
        'all accesses must be complete before the API call returns. This flag is\n'
        "suited for ephemeral sources (ex., stack variables) when it's known that no\n"
        'prior operations in the stream can be accessing the memory and also that\n'
        'the lifetime of the memory is limited to the scope that the source variable\n'
        'was declared in. Specifying this flag allows the driver to optimize the\n'
        'copy and removes the need for the user to synchronize the stream after the\n'
        'API call.\n'
    ){{endif}}
    {{if 'cudaMemcpySrcAccessOrderAny' in found_values}}

    cudaMemcpySrcAccessOrderAny = (
        cyruntime.cudaMemcpySrcAccessOrder.cudaMemcpySrcAccessOrderAny,
        'Indicates that access to the source pointer can be out of stream order and\n'
        'the accesses can happen even after the API call returns. This flag is\n'
        "suited for host pointers allocated outside CUDA (ex., via malloc) when it's\n"
        'known that no prior operations in the stream can be accessing the memory.\n'
        'Specifying this flag allows the driver to optimize the copy on certain\n'
        'platforms.\n'
    ){{endif}}
    {{if 'cudaMemcpySrcAccessOrderMax' in found_values}}
    cudaMemcpySrcAccessOrderMax = cyruntime.cudaMemcpySrcAccessOrder.cudaMemcpySrcAccessOrderMax{{endif}}

{{endif}}
{{if 'cudaMemcpy3DOperandType' in found_types}}

class cudaMemcpy3DOperandType(_FastEnum):
    """
    These flags allow applications to convey the operand type for
    individual copies specified in :py:obj:`~.cudaMemcpy3DBatchAsync`.
    """
    {{if 'cudaMemcpyOperandTypePointer' in found_values}}

    cudaMemcpyOperandTypePointer = (
        cyruntime.cudaMemcpy3DOperandType.cudaMemcpyOperandTypePointer,
        'Memcpy operand is a valid pointer.\n'
    ){{endif}}
    {{if 'cudaMemcpyOperandTypeArray' in found_values}}

    cudaMemcpyOperandTypeArray = (
        cyruntime.cudaMemcpy3DOperandType.cudaMemcpyOperandTypeArray,
        'Memcpy operand is a CUarray.\n'
    ){{endif}}
    {{if 'cudaMemcpyOperandTypeMax' in found_values}}
    cudaMemcpyOperandTypeMax = cyruntime.cudaMemcpy3DOperandType.cudaMemcpyOperandTypeMax{{endif}}

{{endif}}
{{if 'cudaDeviceP2PAttr' in found_types}}

class cudaDeviceP2PAttr(_FastEnum):
    """
    CUDA device P2P attributes
    """
    {{if 'cudaDevP2PAttrPerformanceRank' in found_values}}

    cudaDevP2PAttrPerformanceRank = (
        cyruntime.cudaDeviceP2PAttr.cudaDevP2PAttrPerformanceRank,
        'A relative value indicating the performance of the link between two devices\n'
    ){{endif}}
    {{if 'cudaDevP2PAttrAccessSupported' in found_values}}

    cudaDevP2PAttrAccessSupported = (
        cyruntime.cudaDeviceP2PAttr.cudaDevP2PAttrAccessSupported,
        'Peer access is enabled\n'
    ){{endif}}
    {{if 'cudaDevP2PAttrNativeAtomicSupported' in found_values}}

    cudaDevP2PAttrNativeAtomicSupported = (
        cyruntime.cudaDeviceP2PAttr.cudaDevP2PAttrNativeAtomicSupported,
        'Native atomic operation over the link supported\n'
    ){{endif}}
    {{if 'cudaDevP2PAttrCudaArrayAccessSupported' in found_values}}

    cudaDevP2PAttrCudaArrayAccessSupported = (
        cyruntime.cudaDeviceP2PAttr.cudaDevP2PAttrCudaArrayAccessSupported,
        'Accessing CUDA arrays over the link supported\n'
    ){{endif}}
    {{if 'cudaDevP2PAttrOnlyPartialNativeAtomicSupported' in found_values}}

    cudaDevP2PAttrOnlyPartialNativeAtomicSupported = (
        cyruntime.cudaDeviceP2PAttr.cudaDevP2PAttrOnlyPartialNativeAtomicSupported,
        'Only some CUDA-valid atomic operations over the link are supported.\n'
    ){{endif}}

{{endif}}
{{if 'cudaAtomicOperation' in found_types}}

class cudaAtomicOperation(_FastEnum):
    """
    CUDA-valid Atomic Operations
    """
    {{if 'cudaAtomicOperationIntegerAdd' in found_values}}
    cudaAtomicOperationIntegerAdd = cyruntime.cudaAtomicOperation.cudaAtomicOperationIntegerAdd{{endif}}
    {{if 'cudaAtomicOperationIntegerMin' in found_values}}
    cudaAtomicOperationIntegerMin = cyruntime.cudaAtomicOperation.cudaAtomicOperationIntegerMin{{endif}}
    {{if 'cudaAtomicOperationIntegerMax' in found_values}}
    cudaAtomicOperationIntegerMax = cyruntime.cudaAtomicOperation.cudaAtomicOperationIntegerMax{{endif}}
    {{if 'cudaAtomicOperationIntegerIncrement' in found_values}}
    cudaAtomicOperationIntegerIncrement = cyruntime.cudaAtomicOperation.cudaAtomicOperationIntegerIncrement{{endif}}
    {{if 'cudaAtomicOperationIntegerDecrement' in found_values}}
    cudaAtomicOperationIntegerDecrement = cyruntime.cudaAtomicOperation.cudaAtomicOperationIntegerDecrement{{endif}}
    {{if 'cudaAtomicOperationAnd' in found_values}}
    cudaAtomicOperationAnd = cyruntime.cudaAtomicOperation.cudaAtomicOperationAnd{{endif}}
    {{if 'cudaAtomicOperationOr' in found_values}}
    cudaAtomicOperationOr = cyruntime.cudaAtomicOperation.cudaAtomicOperationOr{{endif}}
    {{if 'cudaAtomicOperationXOR' in found_values}}
    cudaAtomicOperationXOR = cyruntime.cudaAtomicOperation.cudaAtomicOperationXOR{{endif}}
    {{if 'cudaAtomicOperationExchange' in found_values}}
    cudaAtomicOperationExchange = cyruntime.cudaAtomicOperation.cudaAtomicOperationExchange{{endif}}
    {{if 'cudaAtomicOperationCAS' in found_values}}
    cudaAtomicOperationCAS = cyruntime.cudaAtomicOperation.cudaAtomicOperationCAS{{endif}}
    {{if 'cudaAtomicOperationFloatAdd' in found_values}}
    cudaAtomicOperationFloatAdd = cyruntime.cudaAtomicOperation.cudaAtomicOperationFloatAdd{{endif}}
    {{if 'cudaAtomicOperationFloatMin' in found_values}}
    cudaAtomicOperationFloatMin = cyruntime.cudaAtomicOperation.cudaAtomicOperationFloatMin{{endif}}
    {{if 'cudaAtomicOperationFloatMax' in found_values}}
    cudaAtomicOperationFloatMax = cyruntime.cudaAtomicOperation.cudaAtomicOperationFloatMax{{endif}}

{{endif}}
{{if 'cudaAtomicOperationCapability' in found_types}}

class cudaAtomicOperationCapability(_FastEnum):
    """
    CUDA-valid Atomic Operation capabilities
    """
    {{if 'cudaAtomicCapabilitySigned' in found_values}}
    cudaAtomicCapabilitySigned = cyruntime.cudaAtomicOperationCapability.cudaAtomicCapabilitySigned{{endif}}
    {{if 'cudaAtomicCapabilityUnsigned' in found_values}}
    cudaAtomicCapabilityUnsigned = cyruntime.cudaAtomicOperationCapability.cudaAtomicCapabilityUnsigned{{endif}}
    {{if 'cudaAtomicCapabilityReduction' in found_values}}
    cudaAtomicCapabilityReduction = cyruntime.cudaAtomicOperationCapability.cudaAtomicCapabilityReduction{{endif}}
    {{if 'cudaAtomicCapabilityScalar32' in found_values}}
    cudaAtomicCapabilityScalar32 = cyruntime.cudaAtomicOperationCapability.cudaAtomicCapabilityScalar32{{endif}}
    {{if 'cudaAtomicCapabilityScalar64' in found_values}}
    cudaAtomicCapabilityScalar64 = cyruntime.cudaAtomicOperationCapability.cudaAtomicCapabilityScalar64{{endif}}
    {{if 'cudaAtomicCapabilityScalar128' in found_values}}
    cudaAtomicCapabilityScalar128 = cyruntime.cudaAtomicOperationCapability.cudaAtomicCapabilityScalar128{{endif}}
    {{if 'cudaAtomicCapabilityVector32x4' in found_values}}
    cudaAtomicCapabilityVector32x4 = cyruntime.cudaAtomicOperationCapability.cudaAtomicCapabilityVector32x4{{endif}}

{{endif}}
{{if 'cudaExternalMemoryHandleType' in found_types}}

class cudaExternalMemoryHandleType(_FastEnum):
    """
    External memory handle types
    """
    {{if 'cudaExternalMemoryHandleTypeOpaqueFd' in found_values}}

    cudaExternalMemoryHandleTypeOpaqueFd = (
        cyruntime.cudaExternalMemoryHandleType.cudaExternalMemoryHandleTypeOpaqueFd,
        'Handle is an opaque file descriptor\n'
    ){{endif}}
    {{if 'cudaExternalMemoryHandleTypeOpaqueWin32' in found_values}}

    cudaExternalMemoryHandleTypeOpaqueWin32 = (
        cyruntime.cudaExternalMemoryHandleType.cudaExternalMemoryHandleTypeOpaqueWin32,
        'Handle is an opaque shared NT handle\n'
    ){{endif}}
    {{if 'cudaExternalMemoryHandleTypeOpaqueWin32Kmt' in found_values}}

    cudaExternalMemoryHandleTypeOpaqueWin32Kmt = (
        cyruntime.cudaExternalMemoryHandleType.cudaExternalMemoryHandleTypeOpaqueWin32Kmt,
        'Handle is an opaque, globally shared handle\n'
    ){{endif}}
    {{if 'cudaExternalMemoryHandleTypeD3D12Heap' in found_values}}

    cudaExternalMemoryHandleTypeD3D12Heap = (
        cyruntime.cudaExternalMemoryHandleType.cudaExternalMemoryHandleTypeD3D12Heap,
        'Handle is a D3D12 heap object\n'
    ){{endif}}
    {{if 'cudaExternalMemoryHandleTypeD3D12Resource' in found_values}}

    cudaExternalMemoryHandleTypeD3D12Resource = (
        cyruntime.cudaExternalMemoryHandleType.cudaExternalMemoryHandleTypeD3D12Resource,
        'Handle is a D3D12 committed resource\n'
    ){{endif}}
    {{if 'cudaExternalMemoryHandleTypeD3D11Resource' in found_values}}

    cudaExternalMemoryHandleTypeD3D11Resource = (
        cyruntime.cudaExternalMemoryHandleType.cudaExternalMemoryHandleTypeD3D11Resource,
        'Handle is a shared NT handle to a D3D11 resource\n'
    ){{endif}}
    {{if 'cudaExternalMemoryHandleTypeD3D11ResourceKmt' in found_values}}

    cudaExternalMemoryHandleTypeD3D11ResourceKmt = (
        cyruntime.cudaExternalMemoryHandleType.cudaExternalMemoryHandleTypeD3D11ResourceKmt,
        'Handle is a globally shared handle to a D3D11 resource\n'
    ){{endif}}
    {{if 'cudaExternalMemoryHandleTypeNvSciBuf' in found_values}}

    cudaExternalMemoryHandleTypeNvSciBuf = (
        cyruntime.cudaExternalMemoryHandleType.cudaExternalMemoryHandleTypeNvSciBuf,
        'Handle is an NvSciBuf object\n'
    ){{endif}}

{{endif}}
{{if 'cudaExternalSemaphoreHandleType' in found_types}}

class cudaExternalSemaphoreHandleType(_FastEnum):
    """
    External semaphore handle types
    """
    {{if 'cudaExternalSemaphoreHandleTypeOpaqueFd' in found_values}}

    cudaExternalSemaphoreHandleTypeOpaqueFd = (
        cyruntime.cudaExternalSemaphoreHandleType.cudaExternalSemaphoreHandleTypeOpaqueFd,
        'Handle is an opaque file descriptor\n'
    ){{endif}}
    {{if 'cudaExternalSemaphoreHandleTypeOpaqueWin32' in found_values}}

    cudaExternalSemaphoreHandleTypeOpaqueWin32 = (
        cyruntime.cudaExternalSemaphoreHandleType.cudaExternalSemaphoreHandleTypeOpaqueWin32,
        'Handle is an opaque shared NT handle\n'
    ){{endif}}
    {{if 'cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt' in found_values}}

    cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt = (
        cyruntime.cudaExternalSemaphoreHandleType.cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt,
        'Handle is an opaque, globally shared handle\n'
    ){{endif}}
    {{if 'cudaExternalSemaphoreHandleTypeD3D12Fence' in found_values}}

    cudaExternalSemaphoreHandleTypeD3D12Fence = (
        cyruntime.cudaExternalSemaphoreHandleType.cudaExternalSemaphoreHandleTypeD3D12Fence,
        'Handle is a shared NT handle referencing a D3D12 fence object\n'
    ){{endif}}
    {{if 'cudaExternalSemaphoreHandleTypeD3D11Fence' in found_values}}

    cudaExternalSemaphoreHandleTypeD3D11Fence = (
        cyruntime.cudaExternalSemaphoreHandleType.cudaExternalSemaphoreHandleTypeD3D11Fence,
        'Handle is a shared NT handle referencing a D3D11 fence object\n'
    ){{endif}}
    {{if 'cudaExternalSemaphoreHandleTypeNvSciSync' in found_values}}

    cudaExternalSemaphoreHandleTypeNvSciSync = (
        cyruntime.cudaExternalSemaphoreHandleType.cudaExternalSemaphoreHandleTypeNvSciSync,
        'Opaque handle to NvSciSync Object\n'
    ){{endif}}
    {{if 'cudaExternalSemaphoreHandleTypeKeyedMutex' in found_values}}

    cudaExternalSemaphoreHandleTypeKeyedMutex = (
        cyruntime.cudaExternalSemaphoreHandleType.cudaExternalSemaphoreHandleTypeKeyedMutex,
        'Handle is a shared NT handle referencing a D3D11 keyed mutex object\n'
    ){{endif}}
    {{if 'cudaExternalSemaphoreHandleTypeKeyedMutexKmt' in found_values}}

    cudaExternalSemaphoreHandleTypeKeyedMutexKmt = (
        cyruntime.cudaExternalSemaphoreHandleType.cudaExternalSemaphoreHandleTypeKeyedMutexKmt,
        'Handle is a shared KMT handle referencing a D3D11 keyed mutex object\n'
    ){{endif}}
    {{if 'cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd' in found_values}}

    cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd = (
        cyruntime.cudaExternalSemaphoreHandleType.cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd,
        'Handle is an opaque handle file descriptor referencing a timeline semaphore\n'
    ){{endif}}
    {{if 'cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32' in found_values}}

    cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32 = (
        cyruntime.cudaExternalSemaphoreHandleType.cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32,
        'Handle is an opaque handle file descriptor referencing a timeline semaphore\n'
    ){{endif}}

{{endif}}
{{if 'cudaDevSmResourceGroup_flags' in found_types}}

class cudaDevSmResourceGroup_flags(_FastEnum):
    """

    """
    {{if 'cudaDevSmResourceGroupDefault' in found_values}}
    cudaDevSmResourceGroupDefault = cyruntime.cudaDevSmResourceGroup_flags.cudaDevSmResourceGroupDefault{{endif}}
    {{if 'cudaDevSmResourceGroupBackfill' in found_values}}
    cudaDevSmResourceGroupBackfill = cyruntime.cudaDevSmResourceGroup_flags.cudaDevSmResourceGroupBackfill{{endif}}

{{endif}}
{{if 'cudaDevSmResourceSplitByCount_flags' in found_types}}

class cudaDevSmResourceSplitByCount_flags(_FastEnum):
    """

    """
    {{if 'cudaDevSmResourceSplitIgnoreSmCoscheduling' in found_values}}
    cudaDevSmResourceSplitIgnoreSmCoscheduling = cyruntime.cudaDevSmResourceSplitByCount_flags.cudaDevSmResourceSplitIgnoreSmCoscheduling{{endif}}
    {{if 'cudaDevSmResourceSplitMaxPotentialClusterSize' in found_values}}
    cudaDevSmResourceSplitMaxPotentialClusterSize = cyruntime.cudaDevSmResourceSplitByCount_flags.cudaDevSmResourceSplitMaxPotentialClusterSize{{endif}}

{{endif}}
{{if 'cudaDevResourceType' in found_types}}

class cudaDevResourceType(_FastEnum):
    """
    Type of resource
    """
    {{if 'cudaDevResourceTypeInvalid' in found_values}}
    cudaDevResourceTypeInvalid = cyruntime.cudaDevResourceType.cudaDevResourceTypeInvalid{{endif}}
    {{if 'cudaDevResourceTypeSm' in found_values}}

    cudaDevResourceTypeSm = (
        cyruntime.cudaDevResourceType.cudaDevResourceTypeSm,
        'Streaming multiprocessors related information\n'
    ){{endif}}
    {{if 'cudaDevResourceTypeWorkqueueConfig' in found_values}}

    cudaDevResourceTypeWorkqueueConfig = (
        cyruntime.cudaDevResourceType.cudaDevResourceTypeWorkqueueConfig,
        'Workqueue configuration related information\n'
    ){{endif}}
    {{if 'cudaDevResourceTypeWorkqueue' in found_values}}

    cudaDevResourceTypeWorkqueue = (
        cyruntime.cudaDevResourceType.cudaDevResourceTypeWorkqueue,
        'Pre-existing workqueue related information\n'
    ){{endif}}

{{endif}}
{{if 'cudaDevWorkqueueConfigScope' in found_types}}

class cudaDevWorkqueueConfigScope(_FastEnum):
    """
    Sharing scope for workqueues
    """
    {{if 'cudaDevWorkqueueConfigScopeDeviceCtx' in found_values}}

    cudaDevWorkqueueConfigScopeDeviceCtx = (
        cyruntime.cudaDevWorkqueueConfigScope.cudaDevWorkqueueConfigScopeDeviceCtx,
        'Use all shared workqueue resources on the device. Default driver behaviour.\n'
    ){{endif}}
    {{if 'cudaDevWorkqueueConfigScopeGreenCtxBalanced' in found_values}}

    cudaDevWorkqueueConfigScopeGreenCtxBalanced = (
        cyruntime.cudaDevWorkqueueConfigScope.cudaDevWorkqueueConfigScopeGreenCtxBalanced,
        'When possible, use non-overlapping workqueue resources with other balanced\n'
        'green contexts.\n'
    ){{endif}}

{{endif}}
{{if 'cudaJitOption' in found_types}}

class cudaJitOption(_FastEnum):
    """
    Online compiler and linker options
    """
    {{if 'cudaJitMaxRegisters' in found_values}}

    cudaJitMaxRegisters = (
        cyruntime.cudaJitOption.cudaJitMaxRegisters,
        'Max number of registers that a thread may use.\n'
        'Option type: unsigned int\n'
        'Applies to: compiler only\n'
    ){{endif}}
    {{if 'cudaJitThreadsPerBlock' in found_values}}

    cudaJitThreadsPerBlock = (
        cyruntime.cudaJitOption.cudaJitThreadsPerBlock,
        'IN: Specifies minimum number of threads per block to target compilation for\n'
        'OUT: Returns the number of threads the compiler actually targeted. This\n'
        'restricts the resource utilization of the compiler (e.g. max registers)\n'
        'such that a block with the given number of threads should be able to launch\n'
        'based on register limitations. Note, this option does not currently take\n'
        'into account any other resource limitations, such as shared memory\n'
        'utilization.\n'
        'Option type: unsigned int\n'
        'Applies to: compiler only\n'
    ){{endif}}
    {{if 'cudaJitWallTime' in found_values}}

    cudaJitWallTime = (
        cyruntime.cudaJitOption.cudaJitWallTime,
        'Overwrites the option value with the total wall clock time, in\n'
        'milliseconds, spent in the compiler and linker\n'
        'Option type: float\n'
        'Applies to: compiler and linker\n'
    ){{endif}}
    {{if 'cudaJitInfoLogBuffer' in found_values}}

    cudaJitInfoLogBuffer = (
        cyruntime.cudaJitOption.cudaJitInfoLogBuffer,
        'Pointer to a buffer in which to print any log messages that are\n'
        'informational in nature (the buffer size is specified via option\n'
        ':py:obj:`~.cudaJitInfoLogBufferSizeBytes`)\n'
        'Option type: char *\n'
        'Applies to: compiler and linker\n'
    ){{endif}}
    {{if 'cudaJitInfoLogBufferSizeBytes' in found_values}}

    cudaJitInfoLogBufferSizeBytes = (
        cyruntime.cudaJitOption.cudaJitInfoLogBufferSizeBytes,
        'IN: Log buffer size in bytes. Log messages will be capped at this size\n'
        '(including null terminator)\n'
        'OUT: Amount of log buffer filled with messages\n'
        'Option type: unsigned int\n'
        'Applies to: compiler and linker\n'
    ){{endif}}
    {{if 'cudaJitErrorLogBuffer' in found_values}}

    cudaJitErrorLogBuffer = (
        cyruntime.cudaJitOption.cudaJitErrorLogBuffer,
        'Pointer to a buffer in which to print any log messages that reflect errors\n'
        '(the buffer size is specified via option\n'
        ':py:obj:`~.cudaJitErrorLogBufferSizeBytes`)\n'
        'Option type: char *\n'
        'Applies to: compiler and linker\n'
    ){{endif}}
    {{if 'cudaJitErrorLogBufferSizeBytes' in found_values}}

    cudaJitErrorLogBufferSizeBytes = (
        cyruntime.cudaJitOption.cudaJitErrorLogBufferSizeBytes,
        'IN: Log buffer size in bytes. Log messages will be capped at this size\n'
        '(including null terminator)\n'
        'OUT: Amount of log buffer filled with messages\n'
        'Option type: unsigned int\n'
        'Applies to: compiler and linker\n'
    ){{endif}}
    {{if 'cudaJitOptimizationLevel' in found_values}}

    cudaJitOptimizationLevel = (
        cyruntime.cudaJitOption.cudaJitOptimizationLevel,
        'Level of optimizations to apply to generated code (0 - 4), with 4 being the\n'
        'default and highest level of optimizations.\n'
        'Option type: unsigned int\n'
        'Applies to: compiler only\n'
    ){{endif}}
    {{if 'cudaJitFallbackStrategy' in found_values}}

    cudaJitFallbackStrategy = (
        cyruntime.cudaJitOption.cudaJitFallbackStrategy,
        'Specifies choice of fallback strategy if matching cubin is not found.\n'
        'Choice is based on supplied :py:obj:`~.cudaJit_Fallback`. Option type:\n'
        'unsigned int for enumerated type :py:obj:`~.cudaJit_Fallback`\n'
        'Applies to: compiler only\n'
    ){{endif}}
    {{if 'cudaJitGenerateDebugInfo' in found_values}}

    cudaJitGenerateDebugInfo = (
        cyruntime.cudaJitOption.cudaJitGenerateDebugInfo,
        'Specifies whether to create debug information in output (-g) (0: false,\n'
        'default)\n'
        'Option type: int\n'
        'Applies to: compiler and linker\n'
    ){{endif}}
    {{if 'cudaJitLogVerbose' in found_values}}

    cudaJitLogVerbose = (
        cyruntime.cudaJitOption.cudaJitLogVerbose,
        'Generate verbose log messages (0: false, default)\n'
        'Option type: int\n'
        'Applies to: compiler and linker\n'
    ){{endif}}
    {{if 'cudaJitGenerateLineInfo' in found_values}}

    cudaJitGenerateLineInfo = (
        cyruntime.cudaJitOption.cudaJitGenerateLineInfo,
        'Generate line number information (-lineinfo) (0: false, default)\n'
        'Option type: int\n'
        'Applies to: compiler only\n'
    ){{endif}}
    {{if 'cudaJitCacheMode' in found_values}}

    cudaJitCacheMode = (
        cyruntime.cudaJitOption.cudaJitCacheMode,
        'Specifies whether to enable caching explicitly (-dlcm)\n'
        'Choice is based on supplied :py:obj:`~.cudaJit_CacheMode`.\n'
        'Option type: unsigned int for enumerated type :py:obj:`~.cudaJit_CacheMode`\n'
        'Applies to: compiler only\n'
    ){{endif}}
    {{if 'cudaJitPositionIndependentCode' in found_values}}

    cudaJitPositionIndependentCode = (
        cyruntime.cudaJitOption.cudaJitPositionIndependentCode,
        'Generate position independent code (0: false)\n'
        'Option type: int\n'
        'Applies to: compiler only\n'
    ){{endif}}
    {{if 'cudaJitMinCtaPerSm' in found_values}}

    cudaJitMinCtaPerSm = (
        cyruntime.cudaJitOption.cudaJitMinCtaPerSm,
        'This option hints to the JIT compiler the minimum number of CTAs from the\n'
        'kernels grid to be mapped to a SM. This option is ignored when used\n'
        'together with :py:obj:`~.cudaJitMaxRegisters` or\n'
        ':py:obj:`~.cudaJitThreadsPerBlock`. Optimizations based on this option need\n'
        ':py:obj:`~.cudaJitMaxThreadsPerBlock` to be specified as well. For kernels\n'
        'already using PTX directive .minnctapersm, this option will be ignored by\n'
        'default. Use :py:obj:`~.cudaJitOverrideDirectiveValues` to let this option\n'
        'take precedence over the PTX directive. Option type: unsigned int\n'
        'Applies to: compiler only\n'
    ){{endif}}
    {{if 'cudaJitMaxThreadsPerBlock' in found_values}}

    cudaJitMaxThreadsPerBlock = (
        cyruntime.cudaJitOption.cudaJitMaxThreadsPerBlock,
        'Maximum number threads in a thread block, computed as the product of the\n'
        'maximum extent specifed for each dimension of the block. This limit is\n'
        'guaranteed not to be exeeded in any invocation of the kernel. Exceeding the\n'
        'the maximum number of threads results in runtime error or kernel launch\n'
        'failure. For kernels already using PTX directive .maxntid, this option will\n'
        'be ignored by default. Use :py:obj:`~.cudaJitOverrideDirectiveValues` to\n'
        'let this option take precedence over the PTX directive. Option type: int\n'
        'Applies to: compiler only\n'
    ){{endif}}
    {{if 'cudaJitOverrideDirectiveValues' in found_values}}

    cudaJitOverrideDirectiveValues = (
        cyruntime.cudaJitOption.cudaJitOverrideDirectiveValues,
        'This option lets the values specified using\n'
        ':py:obj:`~.cudaJitMaxRegisters`, :py:obj:`~.cudaJitThreadsPerBlock`,\n'
        ':py:obj:`~.cudaJitMaxThreadsPerBlock` and :py:obj:`~.cudaJitMinCtaPerSm`\n'
        'take precedence over any PTX directives. (0: Disable, default; 1: Enable)\n'
        'Option type: int\n'
        'Applies to: compiler only\n'
    ){{endif}}

{{endif}}
{{if 'cudaLibraryOption' in found_types}}

class cudaLibraryOption(_FastEnum):
    """
    Library options to be specified with
    :py:obj:`~.cudaLibraryLoadData()` or
    :py:obj:`~.cudaLibraryLoadFromFile()`
    """
    {{if 'cudaLibraryHostUniversalFunctionAndDataTable' in found_values}}
    cudaLibraryHostUniversalFunctionAndDataTable = cyruntime.cudaLibraryOption.cudaLibraryHostUniversalFunctionAndDataTable{{endif}}
    {{if 'cudaLibraryBinaryIsPreserved' in found_values}}

    cudaLibraryBinaryIsPreserved = (
        cyruntime.cudaLibraryOption.cudaLibraryBinaryIsPreserved,
        'Specifes that the argument `code` passed to\n'
        ':py:obj:`~.cudaLibraryLoadData()` will be preserved. Specifying this option\n'
        'will let the driver know that `code` can be accessed at any point until\n'
        ':py:obj:`~.cudaLibraryUnload()`. The default behavior is for the driver to\n'
        'allocate and maintain its own copy of `code`. Note that this is only a\n'
        'memory usage optimization hint and the driver can choose to ignore it if\n'
        'required. Specifying this option with :py:obj:`~.cudaLibraryLoadFromFile()`\n'
        'is invalid and will return :py:obj:`~.cudaErrorInvalidValue`.\n'
    ){{endif}}

{{endif}}
{{if 'cudaJit_CacheMode' in found_types}}

class cudaJit_CacheMode(_FastEnum):
    """
    Caching modes for dlcm
    """
    {{if 'cudaJitCacheOptionNone' in found_values}}

    cudaJitCacheOptionNone = (
        cyruntime.cudaJit_CacheMode.cudaJitCacheOptionNone,
        'Compile with no -dlcm flag specified\n'
    ){{endif}}
    {{if 'cudaJitCacheOptionCG' in found_values}}

    cudaJitCacheOptionCG = (
        cyruntime.cudaJit_CacheMode.cudaJitCacheOptionCG,
        'Compile with L1 cache disabled\n'
    ){{endif}}
    {{if 'cudaJitCacheOptionCA' in found_values}}

    cudaJitCacheOptionCA = (
        cyruntime.cudaJit_CacheMode.cudaJitCacheOptionCA,
        'Compile with L1 cache enabled\n'
    ){{endif}}

{{endif}}
{{if 'cudaJit_Fallback' in found_types}}

class cudaJit_Fallback(_FastEnum):
    """
    Cubin matching fallback strategies
    """
    {{if 'cudaPreferPtx' in found_values}}

    cudaPreferPtx = (
        cyruntime.cudaJit_Fallback.cudaPreferPtx,
        'Prefer to compile ptx if exact binary match not found\n'
    ){{endif}}
    {{if 'cudaPreferBinary' in found_values}}

    cudaPreferBinary = (
        cyruntime.cudaJit_Fallback.cudaPreferBinary,
        'Prefer to fall back to compatible binary code if exact match not found\n'
    ){{endif}}

{{endif}}
{{if 'cudaCGScope' in found_types}}

class cudaCGScope(_FastEnum):
    """
    CUDA cooperative group scope
    """
    {{if 'cudaCGScopeInvalid' in found_values}}

    cudaCGScopeInvalid = (
        cyruntime.cudaCGScope.cudaCGScopeInvalid,
        'Invalid cooperative group scope\n'
    ){{endif}}
    {{if 'cudaCGScopeGrid' in found_values}}

    cudaCGScopeGrid = (
        cyruntime.cudaCGScope.cudaCGScopeGrid,
        'Scope represented by a grid_group\n'
    ){{endif}}
    {{if 'cudaCGScopeReserved' in found_values}}

    cudaCGScopeReserved = (
        cyruntime.cudaCGScope.cudaCGScopeReserved,
        'Reserved\n'
    ){{endif}}

{{endif}}
{{if 'cudaGraphConditionalHandleFlags' in found_types}}

class cudaGraphConditionalHandleFlags(_FastEnum):
    """

    """
    {{if 'cudaGraphCondAssignDefault' in found_values}}

    cudaGraphCondAssignDefault = (
        cyruntime.cudaGraphConditionalHandleFlags.cudaGraphCondAssignDefault,
        'Apply default handle value when graph is launched.\n'
    ){{endif}}

{{endif}}
{{if 'cudaGraphConditionalNodeType' in found_types}}

class cudaGraphConditionalNodeType(_FastEnum):
    """
    CUDA conditional node types
    """
    {{if 'cudaGraphCondTypeIf' in found_values}}

    cudaGraphCondTypeIf = (
        cyruntime.cudaGraphConditionalNodeType.cudaGraphCondTypeIf,
        "Conditional 'if/else' Node. Body[0] executed if condition is non-zero. If\n"
        '`size` == 2, an optional ELSE graph is created and this is executed if the\n'
        'condition is zero.\n'
    ){{endif}}
    {{if 'cudaGraphCondTypeWhile' in found_values}}

    cudaGraphCondTypeWhile = (
        cyruntime.cudaGraphConditionalNodeType.cudaGraphCondTypeWhile,
        "Conditional 'while' Node. Body executed repeatedly while condition value is\n"
        'non-zero.\n'
    ){{endif}}
    {{if 'cudaGraphCondTypeSwitch' in found_values}}

    cudaGraphCondTypeSwitch = (
        cyruntime.cudaGraphConditionalNodeType.cudaGraphCondTypeSwitch,
        "Conditional 'switch' Node. Body[n] is executed once, where 'n' is the value\n"
        'of the condition. If the condition does not match a body index, no body is\n'
        'launched.\n'
    ){{endif}}

{{endif}}
{{if 'cudaGraphNodeType' in found_types}}

class cudaGraphNodeType(_FastEnum):
    """
    CUDA Graph node types
    """
    {{if 'cudaGraphNodeTypeKernel' in found_values}}

    cudaGraphNodeTypeKernel = (
        cyruntime.cudaGraphNodeType.cudaGraphNodeTypeKernel,
        'GPU kernel node\n'
    ){{endif}}
    {{if 'cudaGraphNodeTypeMemcpy' in found_values}}

    cudaGraphNodeTypeMemcpy = (
        cyruntime.cudaGraphNodeType.cudaGraphNodeTypeMemcpy,
        'Memcpy node\n'
    ){{endif}}
    {{if 'cudaGraphNodeTypeMemset' in found_values}}

    cudaGraphNodeTypeMemset = (
        cyruntime.cudaGraphNodeType.cudaGraphNodeTypeMemset,
        'Memset node\n'
    ){{endif}}
    {{if 'cudaGraphNodeTypeHost' in found_values}}

    cudaGraphNodeTypeHost = (
        cyruntime.cudaGraphNodeType.cudaGraphNodeTypeHost,
        'Host (executable) node\n'
    ){{endif}}
    {{if 'cudaGraphNodeTypeGraph' in found_values}}

    cudaGraphNodeTypeGraph = (
        cyruntime.cudaGraphNodeType.cudaGraphNodeTypeGraph,
        'Node which executes an embedded graph\n'
    ){{endif}}
    {{if 'cudaGraphNodeTypeEmpty' in found_values}}

    cudaGraphNodeTypeEmpty = (
        cyruntime.cudaGraphNodeType.cudaGraphNodeTypeEmpty,
        'Empty (no-op) node\n'
    ){{endif}}
    {{if 'cudaGraphNodeTypeWaitEvent' in found_values}}

    cudaGraphNodeTypeWaitEvent = (
        cyruntime.cudaGraphNodeType.cudaGraphNodeTypeWaitEvent,
        'External event wait node\n'
    ){{endif}}
    {{if 'cudaGraphNodeTypeEventRecord' in found_values}}

    cudaGraphNodeTypeEventRecord = (
        cyruntime.cudaGraphNodeType.cudaGraphNodeTypeEventRecord,
        'External event record node\n'
    ){{endif}}
    {{if 'cudaGraphNodeTypeExtSemaphoreSignal' in found_values}}

    cudaGraphNodeTypeExtSemaphoreSignal = (
        cyruntime.cudaGraphNodeType.cudaGraphNodeTypeExtSemaphoreSignal,
        'External semaphore signal node\n'
    ){{endif}}
    {{if 'cudaGraphNodeTypeExtSemaphoreWait' in found_values}}

    cudaGraphNodeTypeExtSemaphoreWait = (
        cyruntime.cudaGraphNodeType.cudaGraphNodeTypeExtSemaphoreWait,
        'External semaphore wait node\n'
    ){{endif}}
    {{if 'cudaGraphNodeTypeMemAlloc' in found_values}}

    cudaGraphNodeTypeMemAlloc = (
        cyruntime.cudaGraphNodeType.cudaGraphNodeTypeMemAlloc,
        'Memory allocation node\n'
    ){{endif}}
    {{if 'cudaGraphNodeTypeMemFree' in found_values}}

    cudaGraphNodeTypeMemFree = (
        cyruntime.cudaGraphNodeType.cudaGraphNodeTypeMemFree,
        'Memory free node\n'
    ){{endif}}
    {{if 'cudaGraphNodeTypeConditional' in found_values}}

    cudaGraphNodeTypeConditional = (
        cyruntime.cudaGraphNodeType.cudaGraphNodeTypeConditional,
        'Conditional node                                    May be used to\n'
        'implement a conditional execution path or loop\n'
        '                                   inside of a graph. The graph(s)\n'
        'contained within the body of the conditional node\n'
        '                                   can be selectively executed or iterated\n'
        'upon based on the value of a conditional\n'
        '                                   variable.\n'
        '                                   Handles must be created in advance of\n'
        'creating the node\n'
        '                                   using\n'
        ':py:obj:`~.cudaGraphConditionalHandleCreate`.\n'
        '                                   The following restrictions apply to\n'
        'graphs which contain conditional nodes:\n'
        '                                     The graph cannot be used in a child\n'
        'node.\n'
        '                                     Only one instantiation of the graph\n'
        'may exist at any point in time.\n'
        '                                     The graph cannot be cloned.\n'
        '                                   To set the control value, supply a\n'
        'default value when creating the handle and/or\n'
        '                                   call :py:obj:`~.cudaGraphSetConditional`\n'
        'from device code.\n'
    ){{endif}}
    {{if 'cudaGraphNodeTypeCount' in found_values}}
    cudaGraphNodeTypeCount = cyruntime.cudaGraphNodeType.cudaGraphNodeTypeCount{{endif}}

{{endif}}
{{if 'cudaGraphChildGraphNodeOwnership' in found_types}}

class cudaGraphChildGraphNodeOwnership(_FastEnum):
    """
    Child graph node ownership
    """
    {{if 'cudaGraphChildGraphOwnershipClone' in found_values}}

    cudaGraphChildGraphOwnershipClone = (
        cyruntime.cudaGraphChildGraphNodeOwnership.cudaGraphChildGraphOwnershipClone,
        'Default behavior for a child graph node. Child graph is cloned into the\n'
        "parent and memory allocation/free nodes can't be present in the child\n"
        'graph.\n'
    ){{endif}}
    {{if 'cudaGraphChildGraphOwnershipMove' in found_values}}

    cudaGraphChildGraphOwnershipMove = (
        cyruntime.cudaGraphChildGraphNodeOwnership.cudaGraphChildGraphOwnershipMove,
        'The child graph is moved to the parent. The handle to the child graph is\n'
        'owned by the parent and will be destroyed when the parent is destroyed.\n'
        'The following restrictions apply to child graphs after they have been\n'
        'moved: Cannot be independently instantiated or destroyed; Cannot be added\n'
        'as a child graph of a separate parent graph; Cannot be used as an argument\n'
        'to cudaGraphExecUpdate; Cannot have additional memory allocation or free\n'
        'nodes added.\n'
    ){{endif}}

{{endif}}
{{if 'cudaGraphExecUpdateResult' in found_types}}

class cudaGraphExecUpdateResult(_FastEnum):
    """
    CUDA Graph Update error types
    """
    {{if 'cudaGraphExecUpdateSuccess' in found_values}}

    cudaGraphExecUpdateSuccess = (
        cyruntime.cudaGraphExecUpdateResult.cudaGraphExecUpdateSuccess,
        'The update succeeded\n'
    ){{endif}}
    {{if 'cudaGraphExecUpdateError' in found_values}}

    cudaGraphExecUpdateError = (
        cyruntime.cudaGraphExecUpdateResult.cudaGraphExecUpdateError,
        'The update failed for an unexpected reason which is described in the return\n'
        'value of the function\n'
    ){{endif}}
    {{if 'cudaGraphExecUpdateErrorTopologyChanged' in found_values}}

    cudaGraphExecUpdateErrorTopologyChanged = (
        cyruntime.cudaGraphExecUpdateResult.cudaGraphExecUpdateErrorTopologyChanged,
        'The update failed because the topology changed\n'
    ){{endif}}
    {{if 'cudaGraphExecUpdateErrorNodeTypeChanged' in found_values}}

    cudaGraphExecUpdateErrorNodeTypeChanged = (
        cyruntime.cudaGraphExecUpdateResult.cudaGraphExecUpdateErrorNodeTypeChanged,
        'The update failed because a node type changed\n'
    ){{endif}}
    {{if 'cudaGraphExecUpdateErrorFunctionChanged' in found_values}}

    cudaGraphExecUpdateErrorFunctionChanged = (
        cyruntime.cudaGraphExecUpdateResult.cudaGraphExecUpdateErrorFunctionChanged,
        'The update failed because the function of a kernel node changed (CUDA\n'
        'driver < 11.2)\n'
    ){{endif}}
    {{if 'cudaGraphExecUpdateErrorParametersChanged' in found_values}}

    cudaGraphExecUpdateErrorParametersChanged = (
        cyruntime.cudaGraphExecUpdateResult.cudaGraphExecUpdateErrorParametersChanged,
        'The update failed because the parameters changed in a way that is not\n'
        'supported\n'
    ){{endif}}
    {{if 'cudaGraphExecUpdateErrorNotSupported' in found_values}}

    cudaGraphExecUpdateErrorNotSupported = (
        cyruntime.cudaGraphExecUpdateResult.cudaGraphExecUpdateErrorNotSupported,
        'The update failed because something about the node is not supported\n'
    ){{endif}}
    {{if 'cudaGraphExecUpdateErrorUnsupportedFunctionChange' in found_values}}

    cudaGraphExecUpdateErrorUnsupportedFunctionChange = (
        cyruntime.cudaGraphExecUpdateResult.cudaGraphExecUpdateErrorUnsupportedFunctionChange,
        'The update failed because the function of a kernel node changed in an\n'
        'unsupported way\n'
    ){{endif}}
    {{if 'cudaGraphExecUpdateErrorAttributesChanged' in found_values}}

    cudaGraphExecUpdateErrorAttributesChanged = (
        cyruntime.cudaGraphExecUpdateResult.cudaGraphExecUpdateErrorAttributesChanged,
        'The update failed because the node attributes changed in a way that is not\n'
        'supported\n'
    ){{endif}}

{{endif}}
{{if 'cudaGraphKernelNodeField' in found_types}}

class cudaGraphKernelNodeField(_FastEnum):
    """
    Specifies the field to update when performing multiple node updates
    from the device
    """
    {{if 'cudaGraphKernelNodeFieldInvalid' in found_values}}

    cudaGraphKernelNodeFieldInvalid = (
        cyruntime.cudaGraphKernelNodeField.cudaGraphKernelNodeFieldInvalid,
        'Invalid field\n'
    ){{endif}}
    {{if 'cudaGraphKernelNodeFieldGridDim' in found_values}}

    cudaGraphKernelNodeFieldGridDim = (
        cyruntime.cudaGraphKernelNodeField.cudaGraphKernelNodeFieldGridDim,
        'Grid dimension update\n'
    ){{endif}}
    {{if 'cudaGraphKernelNodeFieldParam' in found_values}}

    cudaGraphKernelNodeFieldParam = (
        cyruntime.cudaGraphKernelNodeField.cudaGraphKernelNodeFieldParam,
        'Kernel parameter update\n'
    ){{endif}}
    {{if 'cudaGraphKernelNodeFieldEnabled' in found_values}}

    cudaGraphKernelNodeFieldEnabled = (
        cyruntime.cudaGraphKernelNodeField.cudaGraphKernelNodeFieldEnabled,
        'Node enable/disable\n'
    ){{endif}}

{{endif}}
{{if 'cudaGetDriverEntryPointFlags' in found_types}}

class cudaGetDriverEntryPointFlags(_FastEnum):
    """
    Flags to specify search options to be used with
    :py:obj:`~.cudaGetDriverEntryPoint` For more details see
    :py:obj:`~.cuGetProcAddress`
    """
    {{if 'cudaEnableDefault' in found_values}}

    cudaEnableDefault = (
        cyruntime.cudaGetDriverEntryPointFlags.cudaEnableDefault,
        'Default search mode for driver symbols.\n'
    ){{endif}}
    {{if 'cudaEnableLegacyStream' in found_values}}

    cudaEnableLegacyStream = (
        cyruntime.cudaGetDriverEntryPointFlags.cudaEnableLegacyStream,
        'Search for legacy versions of driver symbols.\n'
    ){{endif}}
    {{if 'cudaEnablePerThreadDefaultStream' in found_values}}

    cudaEnablePerThreadDefaultStream = (
        cyruntime.cudaGetDriverEntryPointFlags.cudaEnablePerThreadDefaultStream,
        'Search for per-thread versions of driver symbols.\n'
    ){{endif}}

{{endif}}
{{if 'cudaDriverEntryPointQueryResult' in found_types}}

class cudaDriverEntryPointQueryResult(_FastEnum):
    """
    Enum for status from obtaining driver entry points, used with
    :py:obj:`~.cudaApiGetDriverEntryPoint`
    """
    {{if 'cudaDriverEntryPointSuccess' in found_values}}

    cudaDriverEntryPointSuccess = (
        cyruntime.cudaDriverEntryPointQueryResult.cudaDriverEntryPointSuccess,
        'Search for symbol found a match\n'
    ){{endif}}
    {{if 'cudaDriverEntryPointSymbolNotFound' in found_values}}

    cudaDriverEntryPointSymbolNotFound = (
        cyruntime.cudaDriverEntryPointQueryResult.cudaDriverEntryPointSymbolNotFound,
        'Search for symbol was not found\n'
    ){{endif}}
    {{if 'cudaDriverEntryPointVersionNotSufficent' in found_values}}

    cudaDriverEntryPointVersionNotSufficent = (
        cyruntime.cudaDriverEntryPointQueryResult.cudaDriverEntryPointVersionNotSufficent,
        "Search for symbol was found but version wasn't great enough\n"
    ){{endif}}

{{endif}}
{{if 'cudaGraphDebugDotFlags' in found_types}}

class cudaGraphDebugDotFlags(_FastEnum):
    """
    CUDA Graph debug write options
    """
    {{if 'cudaGraphDebugDotFlagsVerbose' in found_values}}

    cudaGraphDebugDotFlagsVerbose = (
        cyruntime.cudaGraphDebugDotFlags.cudaGraphDebugDotFlagsVerbose,
        'Output all debug data as if every debug flag is enabled\n'
    ){{endif}}
    {{if 'cudaGraphDebugDotFlagsKernelNodeParams' in found_values}}

    cudaGraphDebugDotFlagsKernelNodeParams = (
        cyruntime.cudaGraphDebugDotFlags.cudaGraphDebugDotFlagsKernelNodeParams,
        'Adds :py:obj:`~.cudaKernelNodeParams` to output\n'
    ){{endif}}
    {{if 'cudaGraphDebugDotFlagsMemcpyNodeParams' in found_values}}

    cudaGraphDebugDotFlagsMemcpyNodeParams = (
        cyruntime.cudaGraphDebugDotFlags.cudaGraphDebugDotFlagsMemcpyNodeParams,
        'Adds :py:obj:`~.cudaMemcpy3DParms` to output\n'
    ){{endif}}
    {{if 'cudaGraphDebugDotFlagsMemsetNodeParams' in found_values}}

    cudaGraphDebugDotFlagsMemsetNodeParams = (
        cyruntime.cudaGraphDebugDotFlags.cudaGraphDebugDotFlagsMemsetNodeParams,
        'Adds :py:obj:`~.cudaMemsetParams` to output\n'
    ){{endif}}
    {{if 'cudaGraphDebugDotFlagsHostNodeParams' in found_values}}

    cudaGraphDebugDotFlagsHostNodeParams = (
        cyruntime.cudaGraphDebugDotFlags.cudaGraphDebugDotFlagsHostNodeParams,
        'Adds :py:obj:`~.cudaHostNodeParams` to output\n'
    ){{endif}}
    {{if 'cudaGraphDebugDotFlagsEventNodeParams' in found_values}}

    cudaGraphDebugDotFlagsEventNodeParams = (
        cyruntime.cudaGraphDebugDotFlags.cudaGraphDebugDotFlagsEventNodeParams,
        'Adds cudaEvent_t handle from record and wait nodes to output\n'
    ){{endif}}
    {{if 'cudaGraphDebugDotFlagsExtSemasSignalNodeParams' in found_values}}

    cudaGraphDebugDotFlagsExtSemasSignalNodeParams = (
        cyruntime.cudaGraphDebugDotFlags.cudaGraphDebugDotFlagsExtSemasSignalNodeParams,
        'Adds :py:obj:`~.cudaExternalSemaphoreSignalNodeParams` values to output\n'
    ){{endif}}
    {{if 'cudaGraphDebugDotFlagsExtSemasWaitNodeParams' in found_values}}

    cudaGraphDebugDotFlagsExtSemasWaitNodeParams = (
        cyruntime.cudaGraphDebugDotFlags.cudaGraphDebugDotFlagsExtSemasWaitNodeParams,
        'Adds :py:obj:`~.cudaExternalSemaphoreWaitNodeParams` to output\n'
    ){{endif}}
    {{if 'cudaGraphDebugDotFlagsKernelNodeAttributes' in found_values}}

    cudaGraphDebugDotFlagsKernelNodeAttributes = (
        cyruntime.cudaGraphDebugDotFlags.cudaGraphDebugDotFlagsKernelNodeAttributes,
        'Adds cudaKernelNodeAttrID values to output\n'
    ){{endif}}
    {{if 'cudaGraphDebugDotFlagsHandles' in found_values}}

    cudaGraphDebugDotFlagsHandles = (
        cyruntime.cudaGraphDebugDotFlags.cudaGraphDebugDotFlagsHandles,
        'Adds node handles and every kernel function handle to output\n'
    ){{endif}}
    {{if 'cudaGraphDebugDotFlagsConditionalNodeParams' in found_values}}

    cudaGraphDebugDotFlagsConditionalNodeParams = (
        cyruntime.cudaGraphDebugDotFlags.cudaGraphDebugDotFlagsConditionalNodeParams,
        'Adds :py:obj:`~.cudaConditionalNodeParams` to output\n'
    ){{endif}}

{{endif}}
{{if 'cudaGraphInstantiateFlags' in found_types}}

class cudaGraphInstantiateFlags(_FastEnum):
    """
    Flags for instantiating a graph
    """
    {{if 'cudaGraphInstantiateFlagAutoFreeOnLaunch' in found_values}}

    cudaGraphInstantiateFlagAutoFreeOnLaunch = (
        cyruntime.cudaGraphInstantiateFlags.cudaGraphInstantiateFlagAutoFreeOnLaunch,
        'Automatically free memory allocated in a graph before relaunching.\n'
    ){{endif}}
    {{if 'cudaGraphInstantiateFlagUpload' in found_values}}

    cudaGraphInstantiateFlagUpload = (
        cyruntime.cudaGraphInstantiateFlags.cudaGraphInstantiateFlagUpload,
        'Automatically upload the graph after instantiation. Only supported by\n'
        ' :py:obj:`~.cudaGraphInstantiateWithParams`. The upload will be performed\n'
        'using the\n'
        ' stream provided in `instantiateParams`.\n'
    ){{endif}}
    {{if 'cudaGraphInstantiateFlagDeviceLaunch' in found_values}}

    cudaGraphInstantiateFlagDeviceLaunch = (
        cyruntime.cudaGraphInstantiateFlags.cudaGraphInstantiateFlagDeviceLaunch,
        'Instantiate the graph to be launchable from the device. This flag can only\n'
        ' be used on platforms which support unified addressing. This flag cannot be\n'
        ' used in conjunction with cudaGraphInstantiateFlagAutoFreeOnLaunch.\n'
    ){{endif}}
    {{if 'cudaGraphInstantiateFlagUseNodePriority' in found_values}}

    cudaGraphInstantiateFlagUseNodePriority = (
        cyruntime.cudaGraphInstantiateFlags.cudaGraphInstantiateFlagUseNodePriority,
        'Run the graph using the per-node priority attributes rather than the\n'
        'priority of the stream it is launched into.\n'
    ){{endif}}

{{endif}}
{{if 'cudaDeviceNumaConfig' in found_types}}

class cudaDeviceNumaConfig(_FastEnum):
    """
    CUDA device NUMA config
    """
    {{if 'cudaDeviceNumaConfigNone' in found_values}}

    cudaDeviceNumaConfigNone = (
        cyruntime.cudaDeviceNumaConfig.cudaDeviceNumaConfigNone,
        'The GPU is not a NUMA node\n'
    ){{endif}}
    {{if 'cudaDeviceNumaConfigNumaNode' in found_values}}

    cudaDeviceNumaConfigNumaNode = (
        cyruntime.cudaDeviceNumaConfig.cudaDeviceNumaConfigNumaNode,
        'The GPU is a NUMA node, cudaDevAttrNumaId contains its NUMA ID\n'
    ){{endif}}

{{endif}}
{{if 'cudaSurfaceBoundaryMode' in found_types}}

class cudaSurfaceBoundaryMode(_FastEnum):
    """
    CUDA Surface boundary modes
    """
    {{if 'cudaBoundaryModeZero' in found_values}}

    cudaBoundaryModeZero = (
        cyruntime.cudaSurfaceBoundaryMode.cudaBoundaryModeZero,
        'Zero boundary mode\n'
    ){{endif}}
    {{if 'cudaBoundaryModeClamp' in found_values}}

    cudaBoundaryModeClamp = (
        cyruntime.cudaSurfaceBoundaryMode.cudaBoundaryModeClamp,
        'Clamp boundary mode\n'
    ){{endif}}
    {{if 'cudaBoundaryModeTrap' in found_values}}

    cudaBoundaryModeTrap = (
        cyruntime.cudaSurfaceBoundaryMode.cudaBoundaryModeTrap,
        'Trap boundary mode\n'
    ){{endif}}

{{endif}}
{{if 'cudaSurfaceFormatMode' in found_types}}

class cudaSurfaceFormatMode(_FastEnum):
    """
    CUDA Surface format modes
    """
    {{if 'cudaFormatModeForced' in found_values}}

    cudaFormatModeForced = (
        cyruntime.cudaSurfaceFormatMode.cudaFormatModeForced,
        'Forced format mode\n'
    ){{endif}}
    {{if 'cudaFormatModeAuto' in found_values}}

    cudaFormatModeAuto = (
        cyruntime.cudaSurfaceFormatMode.cudaFormatModeAuto,
        'Auto format mode\n'
    ){{endif}}

{{endif}}
{{if 'cudaTextureAddressMode' in found_types}}

class cudaTextureAddressMode(_FastEnum):
    """
    CUDA texture address modes
    """
    {{if 'cudaAddressModeWrap' in found_values}}

    cudaAddressModeWrap = (
        cyruntime.cudaTextureAddressMode.cudaAddressModeWrap,
        'Wrapping address mode\n'
    ){{endif}}
    {{if 'cudaAddressModeClamp' in found_values}}

    cudaAddressModeClamp = (
        cyruntime.cudaTextureAddressMode.cudaAddressModeClamp,
        'Clamp to edge address mode\n'
    ){{endif}}
    {{if 'cudaAddressModeMirror' in found_values}}

    cudaAddressModeMirror = (
        cyruntime.cudaTextureAddressMode.cudaAddressModeMirror,
        'Mirror address mode\n'
    ){{endif}}
    {{if 'cudaAddressModeBorder' in found_values}}

    cudaAddressModeBorder = (
        cyruntime.cudaTextureAddressMode.cudaAddressModeBorder,
        'Border address mode\n'
    ){{endif}}

{{endif}}
{{if 'cudaTextureFilterMode' in found_types}}

class cudaTextureFilterMode(_FastEnum):
    """
    CUDA texture filter modes
    """
    {{if 'cudaFilterModePoint' in found_values}}

    cudaFilterModePoint = (
        cyruntime.cudaTextureFilterMode.cudaFilterModePoint,
        'Point filter mode\n'
    ){{endif}}
    {{if 'cudaFilterModeLinear' in found_values}}

    cudaFilterModeLinear = (
        cyruntime.cudaTextureFilterMode.cudaFilterModeLinear,
        'Linear filter mode\n'
    ){{endif}}

{{endif}}
{{if 'cudaTextureReadMode' in found_types}}

class cudaTextureReadMode(_FastEnum):
    """
    CUDA texture read modes
    """
    {{if 'cudaReadModeElementType' in found_values}}

    cudaReadModeElementType = (
        cyruntime.cudaTextureReadMode.cudaReadModeElementType,
        'Read texture as specified element type\n'
    ){{endif}}
    {{if 'cudaReadModeNormalizedFloat' in found_values}}

    cudaReadModeNormalizedFloat = (
        cyruntime.cudaTextureReadMode.cudaReadModeNormalizedFloat,
        'Read texture as normalized float\n'
    ){{endif}}

{{endif}}
{{if 'cudaRoundMode' in found_types}}

class cudaRoundMode(_FastEnum):
    """"""
    {{if 'cudaRoundNearest' in found_values}}
    cudaRoundNearest = cyruntime.cudaRoundMode.cudaRoundNearest{{endif}}
    {{if 'cudaRoundZero' in found_values}}
    cudaRoundZero = cyruntime.cudaRoundMode.cudaRoundZero{{endif}}
    {{if 'cudaRoundPosInf' in found_values}}
    cudaRoundPosInf = cyruntime.cudaRoundMode.cudaRoundPosInf{{endif}}
    {{if 'cudaRoundMinInf' in found_values}}
    cudaRoundMinInf = cyruntime.cudaRoundMode.cudaRoundMinInf{{endif}}

{{endif}}
{{if True}}

class cudaGLDeviceList(_FastEnum):
    """
    CUDA devices corresponding to the current OpenGL context
    """
    {{if True}}

    cudaGLDeviceListAll = (
        cyruntime.cudaGLDeviceList.cudaGLDeviceListAll,
        'The CUDA devices for all GPUs used by the current OpenGL context\n'
    ){{endif}}
    {{if True}}

    cudaGLDeviceListCurrentFrame = (
        cyruntime.cudaGLDeviceList.cudaGLDeviceListCurrentFrame,
        'The CUDA devices for the GPUs used by the current OpenGL context in its\n'
        'currently rendering frame\n'
    ){{endif}}
    {{if True}}

    cudaGLDeviceListNextFrame = (
        cyruntime.cudaGLDeviceList.cudaGLDeviceListNextFrame,
        'The CUDA devices for the GPUs to be used by the current OpenGL context in\n'
        'the next frame\n'
    ){{endif}}

{{endif}}
{{if True}}

class cudaGLMapFlags(_FastEnum):
    """
    CUDA GL Map Flags
    """
    {{if True}}

    cudaGLMapFlagsNone = (
        cyruntime.cudaGLMapFlags.cudaGLMapFlagsNone,
        'Default; Assume resource can be read/written\n'
    ){{endif}}
    {{if True}}

    cudaGLMapFlagsReadOnly = (
        cyruntime.cudaGLMapFlags.cudaGLMapFlagsReadOnly,
        'CUDA kernels will not write to this resource\n'
    ){{endif}}
    {{if True}}

    cudaGLMapFlagsWriteDiscard = (
        cyruntime.cudaGLMapFlags.cudaGLMapFlagsWriteDiscard,
        'CUDA kernels will only write to and will not read from this resource\n'
    ){{endif}}

{{endif}}
{{if 'cudaLaunchAttributeID' in found_types}}

class cudaStreamAttrID(_FastEnum):
    """
    Launch attributes enum; used as id field of
    :py:obj:`~.cudaLaunchAttribute`
    """
    {{if 'cudaLaunchAttributeIgnore' in found_values}}

    cudaLaunchAttributeIgnore = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeIgnore,
        'Ignored entry, for convenient composition\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeAccessPolicyWindow' in found_values}}

    cudaLaunchAttributeAccessPolicyWindow = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeAccessPolicyWindow,
        'Valid for streams, graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.accessPolicyWindow`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeCooperative' in found_values}}

    cudaLaunchAttributeCooperative = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeCooperative,
        'Valid for graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.cooperative`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeSynchronizationPolicy' in found_values}}

    cudaLaunchAttributeSynchronizationPolicy = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeSynchronizationPolicy,
        'Valid for streams. See :py:obj:`~.cudaLaunchAttributeValue.syncPolicy`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeClusterDimension' in found_values}}

    cudaLaunchAttributeClusterDimension = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeClusterDimension,
        'Valid for graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.clusterDim`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeClusterSchedulingPolicyPreference' in found_values}}

    cudaLaunchAttributeClusterSchedulingPolicyPreference = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeClusterSchedulingPolicyPreference,
        'Valid for graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.clusterSchedulingPolicyPreference`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeProgrammaticStreamSerialization' in found_values}}

    cudaLaunchAttributeProgrammaticStreamSerialization = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeProgrammaticStreamSerialization,
        'Valid for launches. Setting\n'
        ':py:obj:`~.cudaLaunchAttributeValue.programmaticStreamSerializationAllowed`\n'
        'to non-0 signals that the kernel will use programmatic means to resolve its\n'
        'stream dependency, so that the CUDA runtime should opportunistically allow\n'
        "the grid's execution to overlap with the previous kernel in the stream, if\n"
        'that kernel requests the overlap. The dependent launches can choose to wait\n'
        'on the dependency using the programmatic sync\n'
        '(cudaGridDependencySynchronize() or equivalent PTX instructions).\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeProgrammaticEvent' in found_values}}

    cudaLaunchAttributeProgrammaticEvent = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeProgrammaticEvent,
        'Valid for launches. Set\n'
        ':py:obj:`~.cudaLaunchAttributeValue.programmaticEvent` to record the event.\n'
        'Event recorded through this launch attribute is guaranteed to only trigger\n'
        'after all block in the associated kernel trigger the event. A block can\n'
        'trigger the event programmatically in a future CUDA release. A trigger can\n'
        "also be inserted at the beginning of each block's execution if\n"
        'triggerAtBlockStart is set to non-0. The dependent launches can choose to\n'
        'wait on the dependency using the programmatic sync\n'
        '(cudaGridDependencySynchronize() or equivalent PTX instructions). Note that\n'
        'dependents (including the CPU thread calling\n'
        ':py:obj:`~.cudaEventSynchronize()`) are not guaranteed to observe the\n'
        'release precisely when it is released. For example,\n'
        ':py:obj:`~.cudaEventSynchronize()` may only observe the event trigger long\n'
        'after the associated kernel has completed. This recording type is primarily\n'
        'meant for establishing programmatic dependency between device tasks. Note\n'
        'also this type of dependency allows, but does not guarantee, concurrent\n'
        'execution of tasks.\n'
        ' The event supplied must not be an interprocess or interop event. The event\n'
        'must disable timing (i.e. must be created with the\n'
        ':py:obj:`~.cudaEventDisableTiming` flag set).\n'
    ){{endif}}
    {{if 'cudaLaunchAttributePriority' in found_values}}

    cudaLaunchAttributePriority = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributePriority,
        'Valid for streams, graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.priority`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeMemSyncDomainMap' in found_values}}

    cudaLaunchAttributeMemSyncDomainMap = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeMemSyncDomainMap,
        'Valid for streams, graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.memSyncDomainMap`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeMemSyncDomain' in found_values}}

    cudaLaunchAttributeMemSyncDomain = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeMemSyncDomain,
        'Valid for streams, graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.memSyncDomain`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributePreferredClusterDimension' in found_values}}

    cudaLaunchAttributePreferredClusterDimension = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributePreferredClusterDimension,
        'Valid for graph nodes and launches. Set\n'
        ':py:obj:`~.cudaLaunchAttributeValue.preferredClusterDim` to allow the\n'
        'kernel launch to specify a preferred substitute cluster dimension. Blocks\n'
        'may be grouped according to either the dimensions specified with this\n'
        'attribute (grouped into a "preferred substitute cluster"), or the one\n'
        'specified with :py:obj:`~.cudaLaunchAttributeClusterDimension` attribute\n'
        '(grouped into a "regular cluster"). The cluster dimensions of a "preferred\n'
        'substitute cluster" shall be an integer multiple greater than zero of the\n'
        'regular cluster dimensions. The device will attempt - on a best-effort\n'
        'basis - to group thread blocks into preferred clusters over grouping them\n'
        'into regular clusters. When it deems necessary (primarily when the device\n'
        'temporarily runs out of physical resources to launch the larger preferred\n'
        'clusters), the device may switch to launch the regular clusters instead to\n'
        'attempt to utilize as much of the physical device resources as possible.\n'
        ' Each type of cluster will have its enumeration / coordinate setup as if\n'
        'the grid consists solely of its type of cluster. For example, if the\n'
        'preferred substitute cluster dimensions double the regular cluster\n'
        'dimensions, there might be simultaneously a regular cluster indexed at\n'
        '(1,0,0), and a preferred cluster indexed at (1,0,0). In this example, the\n'
        'preferred substitute cluster (1,0,0) replaces regular clusters (2,0,0) and\n'
        '(3,0,0) and groups their blocks.\n'
        ' This attribute will only take effect when a regular cluster dimension has\n'
        'been specified. The preferred substitute cluster dimension must be an\n'
        'integer multiple greater than zero of the regular cluster dimension and\n'
        'must divide the grid. It must also be no more than `maxBlocksPerCluster`,\n'
        "if it is set in the kernel's `__launch_bounds__`. Otherwise it must be less\n"
        'than the maximum value the driver can support. Otherwise, setting this\n'
        'attribute to a value physically unable to fit on any particular device is\n'
        'permitted.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeLaunchCompletionEvent' in found_values}}

    cudaLaunchAttributeLaunchCompletionEvent = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeLaunchCompletionEvent,
        'Valid for launches. Set\n'
        ':py:obj:`~.cudaLaunchAttributeValue.launchCompletionEvent` to record the\n'
        'event.\n'
        ' Nominally, the event is triggered once all blocks of the kernel have begun\n'
        'execution. Currently this is a best effort. If a kernel B has a launch\n'
        'completion dependency on a kernel A, B may wait until A is complete.\n'
        'Alternatively, blocks of B may begin before all blocks of A have begun, for\n'
        'example if B can claim execution resources unavailable to A (e.g. they run\n'
        'on different GPUs) or if B is a higher priority than A. Exercise caution if\n'
        'such an ordering inversion could lead to deadlock.\n'
        ' A launch completion event is nominally similar to a programmatic event\n'
        'with `triggerAtBlockStart` set except that it is not visible to\n'
        '`cudaGridDependencySynchronize()` and can be used with compute capability\n'
        'less than 9.0.\n'
        ' The event supplied must not be an interprocess or interop event. The event\n'
        'must disable timing (i.e. must be created with the\n'
        ':py:obj:`~.cudaEventDisableTiming` flag set).\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeDeviceUpdatableKernelNode' in found_values}}

    cudaLaunchAttributeDeviceUpdatableKernelNode = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeDeviceUpdatableKernelNode,
        'Valid for graph nodes, launches. This attribute is graphs-only, and passing\n'
        'it to a launch in a non-capturing stream will result in an error.\n'
        ' :cudaLaunchAttributeValue::deviceUpdatableKernelNode::deviceUpdatable can\n'
        'only be set to 0 or 1. Setting the field to 1 indicates that the\n'
        'corresponding kernel node should be device-updatable. On success, a handle\n'
        'will be returned via\n'
        ':py:obj:`~.cudaLaunchAttributeValue`::deviceUpdatableKernelNode::devNode\n'
        'which can be passed to the various device-side update functions to update\n'
        "the node's kernel parameters from within another kernel. For more\n"
        'information on the types of device updates that can be made, as well as the\n'
        'relevant limitations thereof, see\n'
        ':py:obj:`~.cudaGraphKernelNodeUpdatesApply`.\n'
        ' Nodes which are device-updatable have additional restrictions compared to\n'
        'regular kernel nodes. Firstly, device-updatable nodes cannot be removed\n'
        'from their graph via :py:obj:`~.cudaGraphDestroyNode`. Additionally, once\n'
        'opted-in to this functionality, a node cannot opt out, and any attempt to\n'
        'set the deviceUpdatable attribute to 0 will result in an error. Device-\n'
        'updatable kernel nodes also cannot have their attributes copied to/from\n'
        'another kernel node via :py:obj:`~.cudaGraphKernelNodeCopyAttributes`.\n'
        'Graphs containing one or more device-updatable nodes also do not allow\n'
        'multiple instantiation, and neither the graph nor its instantiated version\n'
        'can be passed to :py:obj:`~.cudaGraphExecUpdate`.\n'
        ' If a graph contains device-updatable nodes and updates those nodes from\n'
        'the device from within the graph, the graph must be uploaded with\n'
        ':py:obj:`~.cuGraphUpload` before it is launched. For such a graph, if host-\n'
        'side executable graph updates are made to the device-updatable nodes, the\n'
        'graph must be uploaded before it is launched again.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributePreferredSharedMemoryCarveout' in found_values}}

    cudaLaunchAttributePreferredSharedMemoryCarveout = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributePreferredSharedMemoryCarveout,
        'Valid for launches. On devices where the L1 cache and shared memory use the\n'
        'same hardware resources, setting\n'
        ':py:obj:`~.cudaLaunchAttributeValue.sharedMemCarveout` to a percentage\n'
        'between 0-100 signals sets the shared memory carveout preference in percent\n'
        'of the total shared memory for that kernel launch. This attribute takes\n'
        'precedence over :py:obj:`~.cudaFuncAttributePreferredSharedMemoryCarveout`.\n'
        'This is only a hint, and the driver can choose a different configuration if\n'
        'required for the launch.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeNvlinkUtilCentricScheduling' in found_values}}

    cudaLaunchAttributeNvlinkUtilCentricScheduling = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeNvlinkUtilCentricScheduling,
        'Valid for streams, graph nodes, launches. This attribute is a hint to the\n'
        'CUDA runtime that the launch should attempt to make the kernel maximize its\n'
        'NVLINK utilization.\n'
        ' When possible to honor this hint, CUDA will assume each block in the grid\n'
        'launch will carry out an even amount of NVLINK traffic, and make a best-\n'
        'effort attempt to adjust the kernel launch based on that assumption.\n'
        ' This attribute is a hint only. CUDA makes no functional or performance\n'
        'guarantee. Its applicability can be affected by many different factors,\n'
        "including driver version (i.e. CUDA doesn't guarantee the performance\n"
        'characteristics will be maintained between driver versions or a driver\n'
        'update could alter or regress previously observed perf characteristics.) It\n'
        "also doesn't guarantee a successful result, i.e. applying the attribute may\n"
        'not improve the performance of either the targeted kernel or the\n'
        'encapsulating application.\n'
        ' Valid values for\n'
        ':py:obj:`~.cudaLaunchAttributeValue.nvlinkUtilCentricScheduling` are 0\n'
        '(disabled) and 1 (enabled).\n'
    ){{endif}}

{{endif}}
{{if 'cudaLaunchAttributeID' in found_types}}

class cudaKernelNodeAttrID(_FastEnum):
    """
    Launch attributes enum; used as id field of
    :py:obj:`~.cudaLaunchAttribute`
    """
    {{if 'cudaLaunchAttributeIgnore' in found_values}}

    cudaLaunchAttributeIgnore = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeIgnore,
        'Ignored entry, for convenient composition\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeAccessPolicyWindow' in found_values}}

    cudaLaunchAttributeAccessPolicyWindow = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeAccessPolicyWindow,
        'Valid for streams, graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.accessPolicyWindow`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeCooperative' in found_values}}

    cudaLaunchAttributeCooperative = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeCooperative,
        'Valid for graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.cooperative`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeSynchronizationPolicy' in found_values}}

    cudaLaunchAttributeSynchronizationPolicy = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeSynchronizationPolicy,
        'Valid for streams. See :py:obj:`~.cudaLaunchAttributeValue.syncPolicy`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeClusterDimension' in found_values}}

    cudaLaunchAttributeClusterDimension = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeClusterDimension,
        'Valid for graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.clusterDim`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeClusterSchedulingPolicyPreference' in found_values}}

    cudaLaunchAttributeClusterSchedulingPolicyPreference = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeClusterSchedulingPolicyPreference,
        'Valid for graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.clusterSchedulingPolicyPreference`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeProgrammaticStreamSerialization' in found_values}}

    cudaLaunchAttributeProgrammaticStreamSerialization = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeProgrammaticStreamSerialization,
        'Valid for launches. Setting\n'
        ':py:obj:`~.cudaLaunchAttributeValue.programmaticStreamSerializationAllowed`\n'
        'to non-0 signals that the kernel will use programmatic means to resolve its\n'
        'stream dependency, so that the CUDA runtime should opportunistically allow\n'
        "the grid's execution to overlap with the previous kernel in the stream, if\n"
        'that kernel requests the overlap. The dependent launches can choose to wait\n'
        'on the dependency using the programmatic sync\n'
        '(cudaGridDependencySynchronize() or equivalent PTX instructions).\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeProgrammaticEvent' in found_values}}

    cudaLaunchAttributeProgrammaticEvent = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeProgrammaticEvent,
        'Valid for launches. Set\n'
        ':py:obj:`~.cudaLaunchAttributeValue.programmaticEvent` to record the event.\n'
        'Event recorded through this launch attribute is guaranteed to only trigger\n'
        'after all block in the associated kernel trigger the event. A block can\n'
        'trigger the event programmatically in a future CUDA release. A trigger can\n'
        "also be inserted at the beginning of each block's execution if\n"
        'triggerAtBlockStart is set to non-0. The dependent launches can choose to\n'
        'wait on the dependency using the programmatic sync\n'
        '(cudaGridDependencySynchronize() or equivalent PTX instructions). Note that\n'
        'dependents (including the CPU thread calling\n'
        ':py:obj:`~.cudaEventSynchronize()`) are not guaranteed to observe the\n'
        'release precisely when it is released. For example,\n'
        ':py:obj:`~.cudaEventSynchronize()` may only observe the event trigger long\n'
        'after the associated kernel has completed. This recording type is primarily\n'
        'meant for establishing programmatic dependency between device tasks. Note\n'
        'also this type of dependency allows, but does not guarantee, concurrent\n'
        'execution of tasks.\n'
        ' The event supplied must not be an interprocess or interop event. The event\n'
        'must disable timing (i.e. must be created with the\n'
        ':py:obj:`~.cudaEventDisableTiming` flag set).\n'
    ){{endif}}
    {{if 'cudaLaunchAttributePriority' in found_values}}

    cudaLaunchAttributePriority = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributePriority,
        'Valid for streams, graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.priority`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeMemSyncDomainMap' in found_values}}

    cudaLaunchAttributeMemSyncDomainMap = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeMemSyncDomainMap,
        'Valid for streams, graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.memSyncDomainMap`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeMemSyncDomain' in found_values}}

    cudaLaunchAttributeMemSyncDomain = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeMemSyncDomain,
        'Valid for streams, graph nodes, launches. See\n'
        ':py:obj:`~.cudaLaunchAttributeValue.memSyncDomain`.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributePreferredClusterDimension' in found_values}}

    cudaLaunchAttributePreferredClusterDimension = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributePreferredClusterDimension,
        'Valid for graph nodes and launches. Set\n'
        ':py:obj:`~.cudaLaunchAttributeValue.preferredClusterDim` to allow the\n'
        'kernel launch to specify a preferred substitute cluster dimension. Blocks\n'
        'may be grouped according to either the dimensions specified with this\n'
        'attribute (grouped into a "preferred substitute cluster"), or the one\n'
        'specified with :py:obj:`~.cudaLaunchAttributeClusterDimension` attribute\n'
        '(grouped into a "regular cluster"). The cluster dimensions of a "preferred\n'
        'substitute cluster" shall be an integer multiple greater than zero of the\n'
        'regular cluster dimensions. The device will attempt - on a best-effort\n'
        'basis - to group thread blocks into preferred clusters over grouping them\n'
        'into regular clusters. When it deems necessary (primarily when the device\n'
        'temporarily runs out of physical resources to launch the larger preferred\n'
        'clusters), the device may switch to launch the regular clusters instead to\n'
        'attempt to utilize as much of the physical device resources as possible.\n'
        ' Each type of cluster will have its enumeration / coordinate setup as if\n'
        'the grid consists solely of its type of cluster. For example, if the\n'
        'preferred substitute cluster dimensions double the regular cluster\n'
        'dimensions, there might be simultaneously a regular cluster indexed at\n'
        '(1,0,0), and a preferred cluster indexed at (1,0,0). In this example, the\n'
        'preferred substitute cluster (1,0,0) replaces regular clusters (2,0,0) and\n'
        '(3,0,0) and groups their blocks.\n'
        ' This attribute will only take effect when a regular cluster dimension has\n'
        'been specified. The preferred substitute cluster dimension must be an\n'
        'integer multiple greater than zero of the regular cluster dimension and\n'
        'must divide the grid. It must also be no more than `maxBlocksPerCluster`,\n'
        "if it is set in the kernel's `__launch_bounds__`. Otherwise it must be less\n"
        'than the maximum value the driver can support. Otherwise, setting this\n'
        'attribute to a value physically unable to fit on any particular device is\n'
        'permitted.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeLaunchCompletionEvent' in found_values}}

    cudaLaunchAttributeLaunchCompletionEvent = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeLaunchCompletionEvent,
        'Valid for launches. Set\n'
        ':py:obj:`~.cudaLaunchAttributeValue.launchCompletionEvent` to record the\n'
        'event.\n'
        ' Nominally, the event is triggered once all blocks of the kernel have begun\n'
        'execution. Currently this is a best effort. If a kernel B has a launch\n'
        'completion dependency on a kernel A, B may wait until A is complete.\n'
        'Alternatively, blocks of B may begin before all blocks of A have begun, for\n'
        'example if B can claim execution resources unavailable to A (e.g. they run\n'
        'on different GPUs) or if B is a higher priority than A. Exercise caution if\n'
        'such an ordering inversion could lead to deadlock.\n'
        ' A launch completion event is nominally similar to a programmatic event\n'
        'with `triggerAtBlockStart` set except that it is not visible to\n'
        '`cudaGridDependencySynchronize()` and can be used with compute capability\n'
        'less than 9.0.\n'
        ' The event supplied must not be an interprocess or interop event. The event\n'
        'must disable timing (i.e. must be created with the\n'
        ':py:obj:`~.cudaEventDisableTiming` flag set).\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeDeviceUpdatableKernelNode' in found_values}}

    cudaLaunchAttributeDeviceUpdatableKernelNode = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeDeviceUpdatableKernelNode,
        'Valid for graph nodes, launches. This attribute is graphs-only, and passing\n'
        'it to a launch in a non-capturing stream will result in an error.\n'
        ' :cudaLaunchAttributeValue::deviceUpdatableKernelNode::deviceUpdatable can\n'
        'only be set to 0 or 1. Setting the field to 1 indicates that the\n'
        'corresponding kernel node should be device-updatable. On success, a handle\n'
        'will be returned via\n'
        ':py:obj:`~.cudaLaunchAttributeValue`::deviceUpdatableKernelNode::devNode\n'
        'which can be passed to the various device-side update functions to update\n'
        "the node's kernel parameters from within another kernel. For more\n"
        'information on the types of device updates that can be made, as well as the\n'
        'relevant limitations thereof, see\n'
        ':py:obj:`~.cudaGraphKernelNodeUpdatesApply`.\n'
        ' Nodes which are device-updatable have additional restrictions compared to\n'
        'regular kernel nodes. Firstly, device-updatable nodes cannot be removed\n'
        'from their graph via :py:obj:`~.cudaGraphDestroyNode`. Additionally, once\n'
        'opted-in to this functionality, a node cannot opt out, and any attempt to\n'
        'set the deviceUpdatable attribute to 0 will result in an error. Device-\n'
        'updatable kernel nodes also cannot have their attributes copied to/from\n'
        'another kernel node via :py:obj:`~.cudaGraphKernelNodeCopyAttributes`.\n'
        'Graphs containing one or more device-updatable nodes also do not allow\n'
        'multiple instantiation, and neither the graph nor its instantiated version\n'
        'can be passed to :py:obj:`~.cudaGraphExecUpdate`.\n'
        ' If a graph contains device-updatable nodes and updates those nodes from\n'
        'the device from within the graph, the graph must be uploaded with\n'
        ':py:obj:`~.cuGraphUpload` before it is launched. For such a graph, if host-\n'
        'side executable graph updates are made to the device-updatable nodes, the\n'
        'graph must be uploaded before it is launched again.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributePreferredSharedMemoryCarveout' in found_values}}

    cudaLaunchAttributePreferredSharedMemoryCarveout = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributePreferredSharedMemoryCarveout,
        'Valid for launches. On devices where the L1 cache and shared memory use the\n'
        'same hardware resources, setting\n'
        ':py:obj:`~.cudaLaunchAttributeValue.sharedMemCarveout` to a percentage\n'
        'between 0-100 signals sets the shared memory carveout preference in percent\n'
        'of the total shared memory for that kernel launch. This attribute takes\n'
        'precedence over :py:obj:`~.cudaFuncAttributePreferredSharedMemoryCarveout`.\n'
        'This is only a hint, and the driver can choose a different configuration if\n'
        'required for the launch.\n'
    ){{endif}}
    {{if 'cudaLaunchAttributeNvlinkUtilCentricScheduling' in found_values}}

    cudaLaunchAttributeNvlinkUtilCentricScheduling = (
        cyruntime.cudaLaunchAttributeID.cudaLaunchAttributeNvlinkUtilCentricScheduling,
        'Valid for streams, graph nodes, launches. This attribute is a hint to the\n'
        'CUDA runtime that the launch should attempt to make the kernel maximize its\n'
        'NVLINK utilization.\n'
        ' When possible to honor this hint, CUDA will assume each block in the grid\n'
        'launch will carry out an even amount of NVLINK traffic, and make a best-\n'
        'effort attempt to adjust the kernel launch based on that assumption.\n'
        ' This attribute is a hint only. CUDA makes no functional or performance\n'
        'guarantee. Its applicability can be affected by many different factors,\n'
        "including driver version (i.e. CUDA doesn't guarantee the performance\n"
        'characteristics will be maintained between driver versions or a driver\n'
        'update could alter or regress previously observed perf characteristics.) It\n'
        "also doesn't guarantee a successful result, i.e. applying the attribute may\n"
        'not improve the performance of either the targeted kernel or the\n'
        'encapsulating application.\n'
        ' Valid values for\n'
        ':py:obj:`~.cudaLaunchAttributeValue.nvlinkUtilCentricScheduling` are 0\n'
        '(disabled) and 1 (enabled).\n'
    ){{endif}}

{{endif}}
{{if 'cudaDevResourceDesc_t' in found_types}}

cdef class cudaDevResourceDesc_t:
    """

    An opaque descriptor handle. The descriptor encapsulates multiple created and configured resources. Created via ::cudaDeviceResourceGenerateDesc

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaDevResourceDesc_t>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaDevResourceDesc_t *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaDevResourceDesc_t ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, cudaDevResourceDesc_t):
            return False
        return self._pvt_ptr[0] == (<cudaDevResourceDesc_t>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaExecutionContext_t' in found_types}}

cdef class cudaExecutionContext_t:
    """

    An opaque handle to a CUDA execution context. It represents an execution context created via CUDA Runtime APIs such as cudaGreenCtxCreate.

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaExecutionContext_t>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaExecutionContext_t *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaExecutionContext_t ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, cudaExecutionContext_t):
            return False
        return self._pvt_ptr[0] == (<cudaExecutionContext_t>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaArray_t' in found_types}}

cdef class cudaArray_t:
    """

    CUDA array

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaArray_t>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaArray_t *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaArray_t ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, cudaArray_t):
            return False
        return self._pvt_ptr[0] == (<cudaArray_t>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaArray_const_t' in found_types}}

cdef class cudaArray_const_t:
    """

    CUDA array (as source copy argument)

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaArray_const_t>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaArray_const_t *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaArray_const_t ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, cudaArray_const_t):
            return False
        return self._pvt_ptr[0] == (<cudaArray_const_t>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaMipmappedArray_t' in found_types}}

cdef class cudaMipmappedArray_t:
    """

    CUDA mipmapped array

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaMipmappedArray_t>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaMipmappedArray_t *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaMipmappedArray_t ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, cudaMipmappedArray_t):
            return False
        return self._pvt_ptr[0] == (<cudaMipmappedArray_t>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaMipmappedArray_const_t' in found_types}}

cdef class cudaMipmappedArray_const_t:
    """

    CUDA mipmapped array (as source argument)

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaMipmappedArray_const_t>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaMipmappedArray_const_t *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaMipmappedArray_const_t ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, cudaMipmappedArray_const_t):
            return False
        return self._pvt_ptr[0] == (<cudaMipmappedArray_const_t>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaGraphicsResource_t' in found_types}}

cdef class cudaGraphicsResource_t:
    """

    CUDA graphics resource types

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaGraphicsResource_t>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaGraphicsResource_t *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaGraphicsResource_t ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, cudaGraphicsResource_t):
            return False
        return self._pvt_ptr[0] == (<cudaGraphicsResource_t>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaExternalMemory_t' in found_types}}

cdef class cudaExternalMemory_t:
    """

    CUDA external memory

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaExternalMemory_t>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaExternalMemory_t *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaExternalMemory_t ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, cudaExternalMemory_t):
            return False
        return self._pvt_ptr[0] == (<cudaExternalMemory_t>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaExternalSemaphore_t' in found_types}}

cdef class cudaExternalSemaphore_t:
    """

    CUDA external semaphore

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaExternalSemaphore_t>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaExternalSemaphore_t *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaExternalSemaphore_t ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, cudaExternalSemaphore_t):
            return False
        return self._pvt_ptr[0] == (<cudaExternalSemaphore_t>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaKernel_t' in found_types}}

cdef class cudaKernel_t:
    """

    CUDA kernel

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaKernel_t>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaKernel_t *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaKernel_t ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, cudaKernel_t):
            return False
        return self._pvt_ptr[0] == (<cudaKernel_t>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaLibrary_t' in found_types}}

cdef class cudaLibrary_t:
    """

    CUDA library

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaLibrary_t>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaLibrary_t *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaLibrary_t ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, cudaLibrary_t):
            return False
        return self._pvt_ptr[0] == (<cudaLibrary_t>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaGraphDeviceNode_t' in found_types}}

cdef class cudaGraphDeviceNode_t:
    """

    CUDA device node handle for device-side node update

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaGraphDeviceNode_t>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaGraphDeviceNode_t *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaGraphDeviceNode_t ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, cudaGraphDeviceNode_t):
            return False
        return self._pvt_ptr[0] == (<cudaGraphDeviceNode_t>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaAsyncCallbackHandle_t' in found_types}}

cdef class cudaAsyncCallbackHandle_t:
    """

    CUDA async callback handle

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaAsyncCallbackHandle_t>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaAsyncCallbackHandle_t *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaAsyncCallbackHandle_t ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, cudaAsyncCallbackHandle_t):
            return False
        return self._pvt_ptr[0] == (<cudaAsyncCallbackHandle_t>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaLogsCallbackHandle' in found_types}}

cdef class cudaLogsCallbackHandle:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaLogsCallbackHandle>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaLogsCallbackHandle *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaLogsCallbackHandle ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, cudaLogsCallbackHandle):
            return False
        return self._pvt_ptr[0] == (<cudaLogsCallbackHandle>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class EGLImageKHR:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.EGLImageKHR>init_value
        else:
            self._pvt_ptr = <cyruntime.EGLImageKHR *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<EGLImageKHR ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, EGLImageKHR):
            return False
        return self._pvt_ptr[0] == (<EGLImageKHR>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class EGLStreamKHR:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.EGLStreamKHR>init_value
        else:
            self._pvt_ptr = <cyruntime.EGLStreamKHR *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<EGLStreamKHR ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, EGLStreamKHR):
            return False
        return self._pvt_ptr[0] == (<EGLStreamKHR>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class EGLSyncKHR:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.EGLSyncKHR>init_value
        else:
            self._pvt_ptr = <cyruntime.EGLSyncKHR *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<EGLSyncKHR ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __eq__(self, other):
        if not isinstance(other, EGLSyncKHR):
            return False
        return self._pvt_ptr[0] == (<EGLSyncKHR>other)._pvt_ptr[0]
    def __hash__(self):
        return hash(<uintptr_t><void*>(self._pvt_ptr[0]))
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaHostFn_t' in found_types}}

cdef class cudaHostFn_t:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaHostFn_t>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaHostFn_t *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaHostFn_t ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaAsyncCallback' in found_types}}

cdef class cudaAsyncCallback:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaAsyncCallback>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaAsyncCallback *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaAsyncCallback ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaStreamCallback_t' in found_types}}

cdef class cudaStreamCallback_t:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaStreamCallback_t>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaStreamCallback_t *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaStreamCallback_t ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaLogsCallback_t' in found_types}}

cdef class cudaLogsCallback_t:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
            self._pvt_ptr[0] = <cyruntime.cudaLogsCallback_t>init_value
        else:
            self._pvt_ptr = <cyruntime.cudaLogsCallback_t *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<cudaLogsCallback_t ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'dim3' in found_struct}}

cdef class dim3:
    """
    Attributes
    ----------
    {{if 'dim3.x' in found_struct}}
    x : unsigned int

    {{endif}}
    {{if 'dim3.y' in found_struct}}
    y : unsigned int

    {{endif}}
    {{if 'dim3.z' in found_struct}}
    z : unsigned int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.dim3 *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'dim3.x' in found_struct}}
            try:
                str_list += ['x : ' + str(self.x)]
            except ValueError:
                str_list += ['x : <ValueError>']
            {{endif}}
            {{if 'dim3.y' in found_struct}}
            try:
                str_list += ['y : ' + str(self.y)]
            except ValueError:
                str_list += ['y : <ValueError>']
            {{endif}}
            {{if 'dim3.z' in found_struct}}
            try:
                str_list += ['z : ' + str(self.z)]
            except ValueError:
                str_list += ['z : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'dim3.x' in found_struct}}
    @property
    def x(self):
        return self._pvt_ptr[0].x
    @x.setter
    def x(self, unsigned int x):
        self._pvt_ptr[0].x = x
    {{endif}}
    {{if 'dim3.y' in found_struct}}
    @property
    def y(self):
        return self._pvt_ptr[0].y
    @y.setter
    def y(self, unsigned int y):
        self._pvt_ptr[0].y = y
    {{endif}}
    {{if 'dim3.z' in found_struct}}
    @property
    def z(self):
        return self._pvt_ptr[0].z
    @z.setter
    def z(self, unsigned int z):
        self._pvt_ptr[0].z = z
    {{endif}}
{{endif}}
{{if 'cudaChannelFormatDesc' in found_struct}}

cdef class cudaChannelFormatDesc:
    """
    CUDA Channel format descriptor

    Attributes
    ----------
    {{if 'cudaChannelFormatDesc.x' in found_struct}}
    x : int
        x
    {{endif}}
    {{if 'cudaChannelFormatDesc.y' in found_struct}}
    y : int
        y
    {{endif}}
    {{if 'cudaChannelFormatDesc.z' in found_struct}}
    z : int
        z
    {{endif}}
    {{if 'cudaChannelFormatDesc.w' in found_struct}}
    w : int
        w
    {{endif}}
    {{if 'cudaChannelFormatDesc.f' in found_struct}}
    f : cudaChannelFormatKind
        Channel format kind
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaChannelFormatDesc *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaChannelFormatDesc.x' in found_struct}}
            try:
                str_list += ['x : ' + str(self.x)]
            except ValueError:
                str_list += ['x : <ValueError>']
            {{endif}}
            {{if 'cudaChannelFormatDesc.y' in found_struct}}
            try:
                str_list += ['y : ' + str(self.y)]
            except ValueError:
                str_list += ['y : <ValueError>']
            {{endif}}
            {{if 'cudaChannelFormatDesc.z' in found_struct}}
            try:
                str_list += ['z : ' + str(self.z)]
            except ValueError:
                str_list += ['z : <ValueError>']
            {{endif}}
            {{if 'cudaChannelFormatDesc.w' in found_struct}}
            try:
                str_list += ['w : ' + str(self.w)]
            except ValueError:
                str_list += ['w : <ValueError>']
            {{endif}}
            {{if 'cudaChannelFormatDesc.f' in found_struct}}
            try:
                str_list += ['f : ' + str(self.f)]
            except ValueError:
                str_list += ['f : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaChannelFormatDesc.x' in found_struct}}
    @property
    def x(self):
        return self._pvt_ptr[0].x
    @x.setter
    def x(self, int x):
        self._pvt_ptr[0].x = x
    {{endif}}
    {{if 'cudaChannelFormatDesc.y' in found_struct}}
    @property
    def y(self):
        return self._pvt_ptr[0].y
    @y.setter
    def y(self, int y):
        self._pvt_ptr[0].y = y
    {{endif}}
    {{if 'cudaChannelFormatDesc.z' in found_struct}}
    @property
    def z(self):
        return self._pvt_ptr[0].z
    @z.setter
    def z(self, int z):
        self._pvt_ptr[0].z = z
    {{endif}}
    {{if 'cudaChannelFormatDesc.w' in found_struct}}
    @property
    def w(self):
        return self._pvt_ptr[0].w
    @w.setter
    def w(self, int w):
        self._pvt_ptr[0].w = w
    {{endif}}
    {{if 'cudaChannelFormatDesc.f' in found_struct}}
    @property
    def f(self):
        return cudaChannelFormatKind(self._pvt_ptr[0].f)
    @f.setter
    def f(self, f not None : cudaChannelFormatKind):
        self._pvt_ptr[0].f = int(f)
    {{endif}}
{{endif}}
{{if 'cudaArraySparseProperties.tileExtent' in found_struct}}

cdef class anon_struct0:
    """
    Attributes
    ----------
    {{if 'cudaArraySparseProperties.tileExtent.width' in found_struct}}
    width : unsigned int

    {{endif}}
    {{if 'cudaArraySparseProperties.tileExtent.height' in found_struct}}
    height : unsigned int

    {{endif}}
    {{if 'cudaArraySparseProperties.tileExtent.depth' in found_struct}}
    depth : unsigned int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaArraySparseProperties *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].tileExtent
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaArraySparseProperties.tileExtent.width' in found_struct}}
            try:
                str_list += ['width : ' + str(self.width)]
            except ValueError:
                str_list += ['width : <ValueError>']
            {{endif}}
            {{if 'cudaArraySparseProperties.tileExtent.height' in found_struct}}
            try:
                str_list += ['height : ' + str(self.height)]
            except ValueError:
                str_list += ['height : <ValueError>']
            {{endif}}
            {{if 'cudaArraySparseProperties.tileExtent.depth' in found_struct}}
            try:
                str_list += ['depth : ' + str(self.depth)]
            except ValueError:
                str_list += ['depth : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaArraySparseProperties.tileExtent.width' in found_struct}}
    @property
    def width(self):
        return self._pvt_ptr[0].tileExtent.width
    @width.setter
    def width(self, unsigned int width):
        self._pvt_ptr[0].tileExtent.width = width
    {{endif}}
    {{if 'cudaArraySparseProperties.tileExtent.height' in found_struct}}
    @property
    def height(self):
        return self._pvt_ptr[0].tileExtent.height
    @height.setter
    def height(self, unsigned int height):
        self._pvt_ptr[0].tileExtent.height = height
    {{endif}}
    {{if 'cudaArraySparseProperties.tileExtent.depth' in found_struct}}
    @property
    def depth(self):
        return self._pvt_ptr[0].tileExtent.depth
    @depth.setter
    def depth(self, unsigned int depth):
        self._pvt_ptr[0].tileExtent.depth = depth
    {{endif}}
{{endif}}
{{if 'cudaArraySparseProperties' in found_struct}}

cdef class cudaArraySparseProperties:
    """
    Sparse CUDA array and CUDA mipmapped array properties

    Attributes
    ----------
    {{if 'cudaArraySparseProperties.tileExtent' in found_struct}}
    tileExtent : anon_struct0

    {{endif}}
    {{if 'cudaArraySparseProperties.miptailFirstLevel' in found_struct}}
    miptailFirstLevel : unsigned int
        First mip level at which the mip tail begins
    {{endif}}
    {{if 'cudaArraySparseProperties.miptailSize' in found_struct}}
    miptailSize : unsigned long long
        Total size of the mip tail.
    {{endif}}
    {{if 'cudaArraySparseProperties.flags' in found_struct}}
    flags : unsigned int
        Flags will either be zero or cudaArraySparsePropertiesSingleMipTail
    {{endif}}
    {{if 'cudaArraySparseProperties.reserved' in found_struct}}
    reserved : list[unsigned int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaArraySparseProperties *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaArraySparseProperties.tileExtent' in found_struct}}
        self._tileExtent = anon_struct0(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaArraySparseProperties.tileExtent' in found_struct}}
            try:
                str_list += ['tileExtent :\n' + '\n'.join(['    ' + line for line in str(self.tileExtent).splitlines()])]
            except ValueError:
                str_list += ['tileExtent : <ValueError>']
            {{endif}}
            {{if 'cudaArraySparseProperties.miptailFirstLevel' in found_struct}}
            try:
                str_list += ['miptailFirstLevel : ' + str(self.miptailFirstLevel)]
            except ValueError:
                str_list += ['miptailFirstLevel : <ValueError>']
            {{endif}}
            {{if 'cudaArraySparseProperties.miptailSize' in found_struct}}
            try:
                str_list += ['miptailSize : ' + str(self.miptailSize)]
            except ValueError:
                str_list += ['miptailSize : <ValueError>']
            {{endif}}
            {{if 'cudaArraySparseProperties.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'cudaArraySparseProperties.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaArraySparseProperties.tileExtent' in found_struct}}
    @property
    def tileExtent(self):
        return self._tileExtent
    @tileExtent.setter
    def tileExtent(self, tileExtent not None : anon_struct0):
        string.memcpy(&self._pvt_ptr[0].tileExtent, <cyruntime.anon_struct0*><void_ptr>tileExtent.getPtr(), sizeof(self._pvt_ptr[0].tileExtent))
    {{endif}}
    {{if 'cudaArraySparseProperties.miptailFirstLevel' in found_struct}}
    @property
    def miptailFirstLevel(self):
        return self._pvt_ptr[0].miptailFirstLevel
    @miptailFirstLevel.setter
    def miptailFirstLevel(self, unsigned int miptailFirstLevel):
        self._pvt_ptr[0].miptailFirstLevel = miptailFirstLevel
    {{endif}}
    {{if 'cudaArraySparseProperties.miptailSize' in found_struct}}
    @property
    def miptailSize(self):
        return self._pvt_ptr[0].miptailSize
    @miptailSize.setter
    def miptailSize(self, unsigned long long miptailSize):
        self._pvt_ptr[0].miptailSize = miptailSize
    {{endif}}
    {{if 'cudaArraySparseProperties.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'cudaArraySparseProperties.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaArrayMemoryRequirements' in found_struct}}

cdef class cudaArrayMemoryRequirements:
    """
    CUDA array and CUDA mipmapped array memory requirements

    Attributes
    ----------
    {{if 'cudaArrayMemoryRequirements.size' in found_struct}}
    size : size_t
        Total size of the array.
    {{endif}}
    {{if 'cudaArrayMemoryRequirements.alignment' in found_struct}}
    alignment : size_t
        Alignment necessary for mapping the array.
    {{endif}}
    {{if 'cudaArrayMemoryRequirements.reserved' in found_struct}}
    reserved : list[unsigned int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaArrayMemoryRequirements *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaArrayMemoryRequirements.size' in found_struct}}
            try:
                str_list += ['size : ' + str(self.size)]
            except ValueError:
                str_list += ['size : <ValueError>']
            {{endif}}
            {{if 'cudaArrayMemoryRequirements.alignment' in found_struct}}
            try:
                str_list += ['alignment : ' + str(self.alignment)]
            except ValueError:
                str_list += ['alignment : <ValueError>']
            {{endif}}
            {{if 'cudaArrayMemoryRequirements.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaArrayMemoryRequirements.size' in found_struct}}
    @property
    def size(self):
        return self._pvt_ptr[0].size
    @size.setter
    def size(self, size_t size):
        self._pvt_ptr[0].size = size
    {{endif}}
    {{if 'cudaArrayMemoryRequirements.alignment' in found_struct}}
    @property
    def alignment(self):
        return self._pvt_ptr[0].alignment
    @alignment.setter
    def alignment(self, size_t alignment):
        self._pvt_ptr[0].alignment = alignment
    {{endif}}
    {{if 'cudaArrayMemoryRequirements.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaPitchedPtr' in found_struct}}

cdef class cudaPitchedPtr:
    """
    CUDA Pitched memory pointer  ::make_cudaPitchedPtr

    Attributes
    ----------
    {{if 'cudaPitchedPtr.ptr' in found_struct}}
    ptr : Any
        Pointer to allocated memory
    {{endif}}
    {{if 'cudaPitchedPtr.pitch' in found_struct}}
    pitch : size_t
        Pitch of allocated memory in bytes
    {{endif}}
    {{if 'cudaPitchedPtr.xsize' in found_struct}}
    xsize : size_t
        Logical width of allocation in elements
    {{endif}}
    {{if 'cudaPitchedPtr.ysize' in found_struct}}
    ysize : size_t
        Logical height of allocation in elements
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaPitchedPtr *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaPitchedPtr.ptr' in found_struct}}
            try:
                str_list += ['ptr : ' + hex(self.ptr)]
            except ValueError:
                str_list += ['ptr : <ValueError>']
            {{endif}}
            {{if 'cudaPitchedPtr.pitch' in found_struct}}
            try:
                str_list += ['pitch : ' + str(self.pitch)]
            except ValueError:
                str_list += ['pitch : <ValueError>']
            {{endif}}
            {{if 'cudaPitchedPtr.xsize' in found_struct}}
            try:
                str_list += ['xsize : ' + str(self.xsize)]
            except ValueError:
                str_list += ['xsize : <ValueError>']
            {{endif}}
            {{if 'cudaPitchedPtr.ysize' in found_struct}}
            try:
                str_list += ['ysize : ' + str(self.ysize)]
            except ValueError:
                str_list += ['ysize : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaPitchedPtr.ptr' in found_struct}}
    @property
    def ptr(self):
        return <void_ptr>self._pvt_ptr[0].ptr
    @ptr.setter
    def ptr(self, ptr):
        _cptr = _HelperInputVoidPtr(ptr)
        self._pvt_ptr[0].ptr = <void*><void_ptr>_cptr.cptr
    {{endif}}
    {{if 'cudaPitchedPtr.pitch' in found_struct}}
    @property
    def pitch(self):
        return self._pvt_ptr[0].pitch
    @pitch.setter
    def pitch(self, size_t pitch):
        self._pvt_ptr[0].pitch = pitch
    {{endif}}
    {{if 'cudaPitchedPtr.xsize' in found_struct}}
    @property
    def xsize(self):
        return self._pvt_ptr[0].xsize
    @xsize.setter
    def xsize(self, size_t xsize):
        self._pvt_ptr[0].xsize = xsize
    {{endif}}
    {{if 'cudaPitchedPtr.ysize' in found_struct}}
    @property
    def ysize(self):
        return self._pvt_ptr[0].ysize
    @ysize.setter
    def ysize(self, size_t ysize):
        self._pvt_ptr[0].ysize = ysize
    {{endif}}
{{endif}}
{{if 'cudaExtent' in found_struct}}

cdef class cudaExtent:
    """
    CUDA extent  ::make_cudaExtent

    Attributes
    ----------
    {{if 'cudaExtent.width' in found_struct}}
    width : size_t
        Width in elements when referring to array memory, in bytes when
        referring to linear memory
    {{endif}}
    {{if 'cudaExtent.height' in found_struct}}
    height : size_t
        Height in elements
    {{endif}}
    {{if 'cudaExtent.depth' in found_struct}}
    depth : size_t
        Depth in elements
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaExtent *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExtent.width' in found_struct}}
            try:
                str_list += ['width : ' + str(self.width)]
            except ValueError:
                str_list += ['width : <ValueError>']
            {{endif}}
            {{if 'cudaExtent.height' in found_struct}}
            try:
                str_list += ['height : ' + str(self.height)]
            except ValueError:
                str_list += ['height : <ValueError>']
            {{endif}}
            {{if 'cudaExtent.depth' in found_struct}}
            try:
                str_list += ['depth : ' + str(self.depth)]
            except ValueError:
                str_list += ['depth : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExtent.width' in found_struct}}
    @property
    def width(self):
        return self._pvt_ptr[0].width
    @width.setter
    def width(self, size_t width):
        self._pvt_ptr[0].width = width
    {{endif}}
    {{if 'cudaExtent.height' in found_struct}}
    @property
    def height(self):
        return self._pvt_ptr[0].height
    @height.setter
    def height(self, size_t height):
        self._pvt_ptr[0].height = height
    {{endif}}
    {{if 'cudaExtent.depth' in found_struct}}
    @property
    def depth(self):
        return self._pvt_ptr[0].depth
    @depth.setter
    def depth(self, size_t depth):
        self._pvt_ptr[0].depth = depth
    {{endif}}
{{endif}}
{{if 'cudaPos' in found_struct}}

cdef class cudaPos:
    """
    CUDA 3D position  ::make_cudaPos

    Attributes
    ----------
    {{if 'cudaPos.x' in found_struct}}
    x : size_t
        x
    {{endif}}
    {{if 'cudaPos.y' in found_struct}}
    y : size_t
        y
    {{endif}}
    {{if 'cudaPos.z' in found_struct}}
    z : size_t
        z
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaPos *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaPos.x' in found_struct}}
            try:
                str_list += ['x : ' + str(self.x)]
            except ValueError:
                str_list += ['x : <ValueError>']
            {{endif}}
            {{if 'cudaPos.y' in found_struct}}
            try:
                str_list += ['y : ' + str(self.y)]
            except ValueError:
                str_list += ['y : <ValueError>']
            {{endif}}
            {{if 'cudaPos.z' in found_struct}}
            try:
                str_list += ['z : ' + str(self.z)]
            except ValueError:
                str_list += ['z : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaPos.x' in found_struct}}
    @property
    def x(self):
        return self._pvt_ptr[0].x
    @x.setter
    def x(self, size_t x):
        self._pvt_ptr[0].x = x
    {{endif}}
    {{if 'cudaPos.y' in found_struct}}
    @property
    def y(self):
        return self._pvt_ptr[0].y
    @y.setter
    def y(self, size_t y):
        self._pvt_ptr[0].y = y
    {{endif}}
    {{if 'cudaPos.z' in found_struct}}
    @property
    def z(self):
        return self._pvt_ptr[0].z
    @z.setter
    def z(self, size_t z):
        self._pvt_ptr[0].z = z
    {{endif}}
{{endif}}
{{if 'cudaMemcpy3DParms' in found_struct}}

cdef class cudaMemcpy3DParms:
    """
    CUDA 3D memory copying parameters

    Attributes
    ----------
    {{if 'cudaMemcpy3DParms.srcArray' in found_struct}}
    srcArray : cudaArray_t
        Source memory address
    {{endif}}
    {{if 'cudaMemcpy3DParms.srcPos' in found_struct}}
    srcPos : cudaPos
        Source position offset
    {{endif}}
    {{if 'cudaMemcpy3DParms.srcPtr' in found_struct}}
    srcPtr : cudaPitchedPtr
        Pitched source memory address
    {{endif}}
    {{if 'cudaMemcpy3DParms.dstArray' in found_struct}}
    dstArray : cudaArray_t
        Destination memory address
    {{endif}}
    {{if 'cudaMemcpy3DParms.dstPos' in found_struct}}
    dstPos : cudaPos
        Destination position offset
    {{endif}}
    {{if 'cudaMemcpy3DParms.dstPtr' in found_struct}}
    dstPtr : cudaPitchedPtr
        Pitched destination memory address
    {{endif}}
    {{if 'cudaMemcpy3DParms.extent' in found_struct}}
    extent : cudaExtent
        Requested memory copy size
    {{endif}}
    {{if 'cudaMemcpy3DParms.kind' in found_struct}}
    kind : cudaMemcpyKind
        Type of transfer
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaMemcpy3DParms *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaMemcpy3DParms.srcArray' in found_struct}}
        self._srcArray = cudaArray_t(_ptr=<void_ptr>&self._pvt_ptr[0].srcArray)
        {{endif}}
        {{if 'cudaMemcpy3DParms.srcPos' in found_struct}}
        self._srcPos = cudaPos(_ptr=<void_ptr>&self._pvt_ptr[0].srcPos)
        {{endif}}
        {{if 'cudaMemcpy3DParms.srcPtr' in found_struct}}
        self._srcPtr = cudaPitchedPtr(_ptr=<void_ptr>&self._pvt_ptr[0].srcPtr)
        {{endif}}
        {{if 'cudaMemcpy3DParms.dstArray' in found_struct}}
        self._dstArray = cudaArray_t(_ptr=<void_ptr>&self._pvt_ptr[0].dstArray)
        {{endif}}
        {{if 'cudaMemcpy3DParms.dstPos' in found_struct}}
        self._dstPos = cudaPos(_ptr=<void_ptr>&self._pvt_ptr[0].dstPos)
        {{endif}}
        {{if 'cudaMemcpy3DParms.dstPtr' in found_struct}}
        self._dstPtr = cudaPitchedPtr(_ptr=<void_ptr>&self._pvt_ptr[0].dstPtr)
        {{endif}}
        {{if 'cudaMemcpy3DParms.extent' in found_struct}}
        self._extent = cudaExtent(_ptr=<void_ptr>&self._pvt_ptr[0].extent)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemcpy3DParms.srcArray' in found_struct}}
            try:
                str_list += ['srcArray : ' + str(self.srcArray)]
            except ValueError:
                str_list += ['srcArray : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DParms.srcPos' in found_struct}}
            try:
                str_list += ['srcPos :\n' + '\n'.join(['    ' + line for line in str(self.srcPos).splitlines()])]
            except ValueError:
                str_list += ['srcPos : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DParms.srcPtr' in found_struct}}
            try:
                str_list += ['srcPtr :\n' + '\n'.join(['    ' + line for line in str(self.srcPtr).splitlines()])]
            except ValueError:
                str_list += ['srcPtr : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DParms.dstArray' in found_struct}}
            try:
                str_list += ['dstArray : ' + str(self.dstArray)]
            except ValueError:
                str_list += ['dstArray : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DParms.dstPos' in found_struct}}
            try:
                str_list += ['dstPos :\n' + '\n'.join(['    ' + line for line in str(self.dstPos).splitlines()])]
            except ValueError:
                str_list += ['dstPos : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DParms.dstPtr' in found_struct}}
            try:
                str_list += ['dstPtr :\n' + '\n'.join(['    ' + line for line in str(self.dstPtr).splitlines()])]
            except ValueError:
                str_list += ['dstPtr : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DParms.extent' in found_struct}}
            try:
                str_list += ['extent :\n' + '\n'.join(['    ' + line for line in str(self.extent).splitlines()])]
            except ValueError:
                str_list += ['extent : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DParms.kind' in found_struct}}
            try:
                str_list += ['kind : ' + str(self.kind)]
            except ValueError:
                str_list += ['kind : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemcpy3DParms.srcArray' in found_struct}}
    @property
    def srcArray(self):
        return self._srcArray
    @srcArray.setter
    def srcArray(self, srcArray):
        cdef cyruntime.cudaArray_t cysrcArray
        if srcArray is None:
            cysrcArray = <cyruntime.cudaArray_t><void_ptr>0
        elif isinstance(srcArray, (cudaArray_t,)):
            psrcArray = int(srcArray)
            cysrcArray = <cyruntime.cudaArray_t><void_ptr>psrcArray
        else:
            psrcArray = int(cudaArray_t(srcArray))
            cysrcArray = <cyruntime.cudaArray_t><void_ptr>psrcArray
        self._srcArray._pvt_ptr[0] = cysrcArray
    {{endif}}
    {{if 'cudaMemcpy3DParms.srcPos' in found_struct}}
    @property
    def srcPos(self):
        return self._srcPos
    @srcPos.setter
    def srcPos(self, srcPos not None : cudaPos):
        string.memcpy(&self._pvt_ptr[0].srcPos, <cyruntime.cudaPos*><void_ptr>srcPos.getPtr(), sizeof(self._pvt_ptr[0].srcPos))
    {{endif}}
    {{if 'cudaMemcpy3DParms.srcPtr' in found_struct}}
    @property
    def srcPtr(self):
        return self._srcPtr
    @srcPtr.setter
    def srcPtr(self, srcPtr not None : cudaPitchedPtr):
        string.memcpy(&self._pvt_ptr[0].srcPtr, <cyruntime.cudaPitchedPtr*><void_ptr>srcPtr.getPtr(), sizeof(self._pvt_ptr[0].srcPtr))
    {{endif}}
    {{if 'cudaMemcpy3DParms.dstArray' in found_struct}}
    @property
    def dstArray(self):
        return self._dstArray
    @dstArray.setter
    def dstArray(self, dstArray):
        cdef cyruntime.cudaArray_t cydstArray
        if dstArray is None:
            cydstArray = <cyruntime.cudaArray_t><void_ptr>0
        elif isinstance(dstArray, (cudaArray_t,)):
            pdstArray = int(dstArray)
            cydstArray = <cyruntime.cudaArray_t><void_ptr>pdstArray
        else:
            pdstArray = int(cudaArray_t(dstArray))
            cydstArray = <cyruntime.cudaArray_t><void_ptr>pdstArray
        self._dstArray._pvt_ptr[0] = cydstArray
    {{endif}}
    {{if 'cudaMemcpy3DParms.dstPos' in found_struct}}
    @property
    def dstPos(self):
        return self._dstPos
    @dstPos.setter
    def dstPos(self, dstPos not None : cudaPos):
        string.memcpy(&self._pvt_ptr[0].dstPos, <cyruntime.cudaPos*><void_ptr>dstPos.getPtr(), sizeof(self._pvt_ptr[0].dstPos))
    {{endif}}
    {{if 'cudaMemcpy3DParms.dstPtr' in found_struct}}
    @property
    def dstPtr(self):
        return self._dstPtr
    @dstPtr.setter
    def dstPtr(self, dstPtr not None : cudaPitchedPtr):
        string.memcpy(&self._pvt_ptr[0].dstPtr, <cyruntime.cudaPitchedPtr*><void_ptr>dstPtr.getPtr(), sizeof(self._pvt_ptr[0].dstPtr))
    {{endif}}
    {{if 'cudaMemcpy3DParms.extent' in found_struct}}
    @property
    def extent(self):
        return self._extent
    @extent.setter
    def extent(self, extent not None : cudaExtent):
        string.memcpy(&self._pvt_ptr[0].extent, <cyruntime.cudaExtent*><void_ptr>extent.getPtr(), sizeof(self._pvt_ptr[0].extent))
    {{endif}}
    {{if 'cudaMemcpy3DParms.kind' in found_struct}}
    @property
    def kind(self):
        return cudaMemcpyKind(self._pvt_ptr[0].kind)
    @kind.setter
    def kind(self, kind not None : cudaMemcpyKind):
        self._pvt_ptr[0].kind = int(kind)
    {{endif}}
{{endif}}
{{if 'cudaMemcpyNodeParams' in found_struct}}

cdef class cudaMemcpyNodeParams:
    """
    Memcpy node parameters

    Attributes
    ----------
    {{if 'cudaMemcpyNodeParams.flags' in found_struct}}
    flags : int
        Must be zero
    {{endif}}
    {{if 'cudaMemcpyNodeParams.reserved' in found_struct}}
    reserved : int
        Must be zero
    {{endif}}
    {{if 'cudaMemcpyNodeParams.ctx' in found_struct}}
    ctx : cudaExecutionContext_t
        Context in which to run the memcpy. If NULL will try to use the
        current context.
    {{endif}}
    {{if 'cudaMemcpyNodeParams.copyParams' in found_struct}}
    copyParams : cudaMemcpy3DParms
        Parameters for the memory copy
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaMemcpyNodeParams *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaMemcpyNodeParams.ctx' in found_struct}}
        self._ctx = cudaExecutionContext_t(_ptr=<void_ptr>&self._pvt_ptr[0].ctx)
        {{endif}}
        {{if 'cudaMemcpyNodeParams.copyParams' in found_struct}}
        self._copyParams = cudaMemcpy3DParms(_ptr=<void_ptr>&self._pvt_ptr[0].copyParams)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemcpyNodeParams.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpyNodeParams.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpyNodeParams.ctx' in found_struct}}
            try:
                str_list += ['ctx : ' + str(self.ctx)]
            except ValueError:
                str_list += ['ctx : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpyNodeParams.copyParams' in found_struct}}
            try:
                str_list += ['copyParams :\n' + '\n'.join(['    ' + line for line in str(self.copyParams).splitlines()])]
            except ValueError:
                str_list += ['copyParams : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemcpyNodeParams.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'cudaMemcpyNodeParams.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, int reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
    {{if 'cudaMemcpyNodeParams.ctx' in found_struct}}
    @property
    def ctx(self):
        return self._ctx
    @ctx.setter
    def ctx(self, ctx):
        cdef cyruntime.cudaExecutionContext_t cyctx
        if ctx is None:
            cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>0
        elif isinstance(ctx, (cudaExecutionContext_t,)):
            pctx = int(ctx)
            cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>pctx
        else:
            pctx = int(cudaExecutionContext_t(ctx))
            cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>pctx
        self._ctx._pvt_ptr[0] = cyctx
    {{endif}}
    {{if 'cudaMemcpyNodeParams.copyParams' in found_struct}}
    @property
    def copyParams(self):
        return self._copyParams
    @copyParams.setter
    def copyParams(self, copyParams not None : cudaMemcpy3DParms):
        string.memcpy(&self._pvt_ptr[0].copyParams, <cyruntime.cudaMemcpy3DParms*><void_ptr>copyParams.getPtr(), sizeof(self._pvt_ptr[0].copyParams))
    {{endif}}
{{endif}}
{{if 'cudaMemcpy3DPeerParms' in found_struct}}

cdef class cudaMemcpy3DPeerParms:
    """
    CUDA 3D cross-device memory copying parameters

    Attributes
    ----------
    {{if 'cudaMemcpy3DPeerParms.srcArray' in found_struct}}
    srcArray : cudaArray_t
        Source memory address
    {{endif}}
    {{if 'cudaMemcpy3DPeerParms.srcPos' in found_struct}}
    srcPos : cudaPos
        Source position offset
    {{endif}}
    {{if 'cudaMemcpy3DPeerParms.srcPtr' in found_struct}}
    srcPtr : cudaPitchedPtr
        Pitched source memory address
    {{endif}}
    {{if 'cudaMemcpy3DPeerParms.srcDevice' in found_struct}}
    srcDevice : int
        Source device
    {{endif}}
    {{if 'cudaMemcpy3DPeerParms.dstArray' in found_struct}}
    dstArray : cudaArray_t
        Destination memory address
    {{endif}}
    {{if 'cudaMemcpy3DPeerParms.dstPos' in found_struct}}
    dstPos : cudaPos
        Destination position offset
    {{endif}}
    {{if 'cudaMemcpy3DPeerParms.dstPtr' in found_struct}}
    dstPtr : cudaPitchedPtr
        Pitched destination memory address
    {{endif}}
    {{if 'cudaMemcpy3DPeerParms.dstDevice' in found_struct}}
    dstDevice : int
        Destination device
    {{endif}}
    {{if 'cudaMemcpy3DPeerParms.extent' in found_struct}}
    extent : cudaExtent
        Requested memory copy size
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaMemcpy3DPeerParms *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaMemcpy3DPeerParms.srcArray' in found_struct}}
        self._srcArray = cudaArray_t(_ptr=<void_ptr>&self._pvt_ptr[0].srcArray)
        {{endif}}
        {{if 'cudaMemcpy3DPeerParms.srcPos' in found_struct}}
        self._srcPos = cudaPos(_ptr=<void_ptr>&self._pvt_ptr[0].srcPos)
        {{endif}}
        {{if 'cudaMemcpy3DPeerParms.srcPtr' in found_struct}}
        self._srcPtr = cudaPitchedPtr(_ptr=<void_ptr>&self._pvt_ptr[0].srcPtr)
        {{endif}}
        {{if 'cudaMemcpy3DPeerParms.dstArray' in found_struct}}
        self._dstArray = cudaArray_t(_ptr=<void_ptr>&self._pvt_ptr[0].dstArray)
        {{endif}}
        {{if 'cudaMemcpy3DPeerParms.dstPos' in found_struct}}
        self._dstPos = cudaPos(_ptr=<void_ptr>&self._pvt_ptr[0].dstPos)
        {{endif}}
        {{if 'cudaMemcpy3DPeerParms.dstPtr' in found_struct}}
        self._dstPtr = cudaPitchedPtr(_ptr=<void_ptr>&self._pvt_ptr[0].dstPtr)
        {{endif}}
        {{if 'cudaMemcpy3DPeerParms.extent' in found_struct}}
        self._extent = cudaExtent(_ptr=<void_ptr>&self._pvt_ptr[0].extent)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemcpy3DPeerParms.srcArray' in found_struct}}
            try:
                str_list += ['srcArray : ' + str(self.srcArray)]
            except ValueError:
                str_list += ['srcArray : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DPeerParms.srcPos' in found_struct}}
            try:
                str_list += ['srcPos :\n' + '\n'.join(['    ' + line for line in str(self.srcPos).splitlines()])]
            except ValueError:
                str_list += ['srcPos : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DPeerParms.srcPtr' in found_struct}}
            try:
                str_list += ['srcPtr :\n' + '\n'.join(['    ' + line for line in str(self.srcPtr).splitlines()])]
            except ValueError:
                str_list += ['srcPtr : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DPeerParms.srcDevice' in found_struct}}
            try:
                str_list += ['srcDevice : ' + str(self.srcDevice)]
            except ValueError:
                str_list += ['srcDevice : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DPeerParms.dstArray' in found_struct}}
            try:
                str_list += ['dstArray : ' + str(self.dstArray)]
            except ValueError:
                str_list += ['dstArray : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DPeerParms.dstPos' in found_struct}}
            try:
                str_list += ['dstPos :\n' + '\n'.join(['    ' + line for line in str(self.dstPos).splitlines()])]
            except ValueError:
                str_list += ['dstPos : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DPeerParms.dstPtr' in found_struct}}
            try:
                str_list += ['dstPtr :\n' + '\n'.join(['    ' + line for line in str(self.dstPtr).splitlines()])]
            except ValueError:
                str_list += ['dstPtr : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DPeerParms.dstDevice' in found_struct}}
            try:
                str_list += ['dstDevice : ' + str(self.dstDevice)]
            except ValueError:
                str_list += ['dstDevice : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DPeerParms.extent' in found_struct}}
            try:
                str_list += ['extent :\n' + '\n'.join(['    ' + line for line in str(self.extent).splitlines()])]
            except ValueError:
                str_list += ['extent : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemcpy3DPeerParms.srcArray' in found_struct}}
    @property
    def srcArray(self):
        return self._srcArray
    @srcArray.setter
    def srcArray(self, srcArray):
        cdef cyruntime.cudaArray_t cysrcArray
        if srcArray is None:
            cysrcArray = <cyruntime.cudaArray_t><void_ptr>0
        elif isinstance(srcArray, (cudaArray_t,)):
            psrcArray = int(srcArray)
            cysrcArray = <cyruntime.cudaArray_t><void_ptr>psrcArray
        else:
            psrcArray = int(cudaArray_t(srcArray))
            cysrcArray = <cyruntime.cudaArray_t><void_ptr>psrcArray
        self._srcArray._pvt_ptr[0] = cysrcArray
    {{endif}}
    {{if 'cudaMemcpy3DPeerParms.srcPos' in found_struct}}
    @property
    def srcPos(self):
        return self._srcPos
    @srcPos.setter
    def srcPos(self, srcPos not None : cudaPos):
        string.memcpy(&self._pvt_ptr[0].srcPos, <cyruntime.cudaPos*><void_ptr>srcPos.getPtr(), sizeof(self._pvt_ptr[0].srcPos))
    {{endif}}
    {{if 'cudaMemcpy3DPeerParms.srcPtr' in found_struct}}
    @property
    def srcPtr(self):
        return self._srcPtr
    @srcPtr.setter
    def srcPtr(self, srcPtr not None : cudaPitchedPtr):
        string.memcpy(&self._pvt_ptr[0].srcPtr, <cyruntime.cudaPitchedPtr*><void_ptr>srcPtr.getPtr(), sizeof(self._pvt_ptr[0].srcPtr))
    {{endif}}
    {{if 'cudaMemcpy3DPeerParms.srcDevice' in found_struct}}
    @property
    def srcDevice(self):
        return self._pvt_ptr[0].srcDevice
    @srcDevice.setter
    def srcDevice(self, int srcDevice):
        self._pvt_ptr[0].srcDevice = srcDevice
    {{endif}}
    {{if 'cudaMemcpy3DPeerParms.dstArray' in found_struct}}
    @property
    def dstArray(self):
        return self._dstArray
    @dstArray.setter
    def dstArray(self, dstArray):
        cdef cyruntime.cudaArray_t cydstArray
        if dstArray is None:
            cydstArray = <cyruntime.cudaArray_t><void_ptr>0
        elif isinstance(dstArray, (cudaArray_t,)):
            pdstArray = int(dstArray)
            cydstArray = <cyruntime.cudaArray_t><void_ptr>pdstArray
        else:
            pdstArray = int(cudaArray_t(dstArray))
            cydstArray = <cyruntime.cudaArray_t><void_ptr>pdstArray
        self._dstArray._pvt_ptr[0] = cydstArray
    {{endif}}
    {{if 'cudaMemcpy3DPeerParms.dstPos' in found_struct}}
    @property
    def dstPos(self):
        return self._dstPos
    @dstPos.setter
    def dstPos(self, dstPos not None : cudaPos):
        string.memcpy(&self._pvt_ptr[0].dstPos, <cyruntime.cudaPos*><void_ptr>dstPos.getPtr(), sizeof(self._pvt_ptr[0].dstPos))
    {{endif}}
    {{if 'cudaMemcpy3DPeerParms.dstPtr' in found_struct}}
    @property
    def dstPtr(self):
        return self._dstPtr
    @dstPtr.setter
    def dstPtr(self, dstPtr not None : cudaPitchedPtr):
        string.memcpy(&self._pvt_ptr[0].dstPtr, <cyruntime.cudaPitchedPtr*><void_ptr>dstPtr.getPtr(), sizeof(self._pvt_ptr[0].dstPtr))
    {{endif}}
    {{if 'cudaMemcpy3DPeerParms.dstDevice' in found_struct}}
    @property
    def dstDevice(self):
        return self._pvt_ptr[0].dstDevice
    @dstDevice.setter
    def dstDevice(self, int dstDevice):
        self._pvt_ptr[0].dstDevice = dstDevice
    {{endif}}
    {{if 'cudaMemcpy3DPeerParms.extent' in found_struct}}
    @property
    def extent(self):
        return self._extent
    @extent.setter
    def extent(self, extent not None : cudaExtent):
        string.memcpy(&self._pvt_ptr[0].extent, <cyruntime.cudaExtent*><void_ptr>extent.getPtr(), sizeof(self._pvt_ptr[0].extent))
    {{endif}}
{{endif}}
{{if 'cudaMemsetParams' in found_struct}}

cdef class cudaMemsetParams:
    """
    CUDA Memset node parameters

    Attributes
    ----------
    {{if 'cudaMemsetParams.dst' in found_struct}}
    dst : Any
        Destination device pointer
    {{endif}}
    {{if 'cudaMemsetParams.pitch' in found_struct}}
    pitch : size_t
        Pitch of destination device pointer. Unused if height is 1
    {{endif}}
    {{if 'cudaMemsetParams.value' in found_struct}}
    value : unsigned int
        Value to be set
    {{endif}}
    {{if 'cudaMemsetParams.elementSize' in found_struct}}
    elementSize : unsigned int
        Size of each element in bytes. Must be 1, 2, or 4.
    {{endif}}
    {{if 'cudaMemsetParams.width' in found_struct}}
    width : size_t
        Width of the row in elements
    {{endif}}
    {{if 'cudaMemsetParams.height' in found_struct}}
    height : size_t
        Number of rows
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaMemsetParams *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemsetParams.dst' in found_struct}}
            try:
                str_list += ['dst : ' + hex(self.dst)]
            except ValueError:
                str_list += ['dst : <ValueError>']
            {{endif}}
            {{if 'cudaMemsetParams.pitch' in found_struct}}
            try:
                str_list += ['pitch : ' + str(self.pitch)]
            except ValueError:
                str_list += ['pitch : <ValueError>']
            {{endif}}
            {{if 'cudaMemsetParams.value' in found_struct}}
            try:
                str_list += ['value : ' + str(self.value)]
            except ValueError:
                str_list += ['value : <ValueError>']
            {{endif}}
            {{if 'cudaMemsetParams.elementSize' in found_struct}}
            try:
                str_list += ['elementSize : ' + str(self.elementSize)]
            except ValueError:
                str_list += ['elementSize : <ValueError>']
            {{endif}}
            {{if 'cudaMemsetParams.width' in found_struct}}
            try:
                str_list += ['width : ' + str(self.width)]
            except ValueError:
                str_list += ['width : <ValueError>']
            {{endif}}
            {{if 'cudaMemsetParams.height' in found_struct}}
            try:
                str_list += ['height : ' + str(self.height)]
            except ValueError:
                str_list += ['height : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemsetParams.dst' in found_struct}}
    @property
    def dst(self):
        return <void_ptr>self._pvt_ptr[0].dst
    @dst.setter
    def dst(self, dst):
        _cdst = _HelperInputVoidPtr(dst)
        self._pvt_ptr[0].dst = <void*><void_ptr>_cdst.cptr
    {{endif}}
    {{if 'cudaMemsetParams.pitch' in found_struct}}
    @property
    def pitch(self):
        return self._pvt_ptr[0].pitch
    @pitch.setter
    def pitch(self, size_t pitch):
        self._pvt_ptr[0].pitch = pitch
    {{endif}}
    {{if 'cudaMemsetParams.value' in found_struct}}
    @property
    def value(self):
        return self._pvt_ptr[0].value
    @value.setter
    def value(self, unsigned int value):
        self._pvt_ptr[0].value = value
    {{endif}}
    {{if 'cudaMemsetParams.elementSize' in found_struct}}
    @property
    def elementSize(self):
        return self._pvt_ptr[0].elementSize
    @elementSize.setter
    def elementSize(self, unsigned int elementSize):
        self._pvt_ptr[0].elementSize = elementSize
    {{endif}}
    {{if 'cudaMemsetParams.width' in found_struct}}
    @property
    def width(self):
        return self._pvt_ptr[0].width
    @width.setter
    def width(self, size_t width):
        self._pvt_ptr[0].width = width
    {{endif}}
    {{if 'cudaMemsetParams.height' in found_struct}}
    @property
    def height(self):
        return self._pvt_ptr[0].height
    @height.setter
    def height(self, size_t height):
        self._pvt_ptr[0].height = height
    {{endif}}
{{endif}}
{{if 'cudaMemsetParamsV2' in found_struct}}

cdef class cudaMemsetParamsV2:
    """
    CUDA Memset node parameters

    Attributes
    ----------
    {{if 'cudaMemsetParamsV2.dst' in found_struct}}
    dst : Any
        Destination device pointer
    {{endif}}
    {{if 'cudaMemsetParamsV2.pitch' in found_struct}}
    pitch : size_t
        Pitch of destination device pointer. Unused if height is 1
    {{endif}}
    {{if 'cudaMemsetParamsV2.value' in found_struct}}
    value : unsigned int
        Value to be set
    {{endif}}
    {{if 'cudaMemsetParamsV2.elementSize' in found_struct}}
    elementSize : unsigned int
        Size of each element in bytes. Must be 1, 2, or 4.
    {{endif}}
    {{if 'cudaMemsetParamsV2.width' in found_struct}}
    width : size_t
        Width of the row in elements
    {{endif}}
    {{if 'cudaMemsetParamsV2.height' in found_struct}}
    height : size_t
        Number of rows
    {{endif}}
    {{if 'cudaMemsetParamsV2.ctx' in found_struct}}
    ctx : cudaExecutionContext_t
        Context in which to run the memset. If NULL will try to use the
        current context.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaMemsetParamsV2 *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaMemsetParamsV2.ctx' in found_struct}}
        self._ctx = cudaExecutionContext_t(_ptr=<void_ptr>&self._pvt_ptr[0].ctx)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemsetParamsV2.dst' in found_struct}}
            try:
                str_list += ['dst : ' + hex(self.dst)]
            except ValueError:
                str_list += ['dst : <ValueError>']
            {{endif}}
            {{if 'cudaMemsetParamsV2.pitch' in found_struct}}
            try:
                str_list += ['pitch : ' + str(self.pitch)]
            except ValueError:
                str_list += ['pitch : <ValueError>']
            {{endif}}
            {{if 'cudaMemsetParamsV2.value' in found_struct}}
            try:
                str_list += ['value : ' + str(self.value)]
            except ValueError:
                str_list += ['value : <ValueError>']
            {{endif}}
            {{if 'cudaMemsetParamsV2.elementSize' in found_struct}}
            try:
                str_list += ['elementSize : ' + str(self.elementSize)]
            except ValueError:
                str_list += ['elementSize : <ValueError>']
            {{endif}}
            {{if 'cudaMemsetParamsV2.width' in found_struct}}
            try:
                str_list += ['width : ' + str(self.width)]
            except ValueError:
                str_list += ['width : <ValueError>']
            {{endif}}
            {{if 'cudaMemsetParamsV2.height' in found_struct}}
            try:
                str_list += ['height : ' + str(self.height)]
            except ValueError:
                str_list += ['height : <ValueError>']
            {{endif}}
            {{if 'cudaMemsetParamsV2.ctx' in found_struct}}
            try:
                str_list += ['ctx : ' + str(self.ctx)]
            except ValueError:
                str_list += ['ctx : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemsetParamsV2.dst' in found_struct}}
    @property
    def dst(self):
        return <void_ptr>self._pvt_ptr[0].dst
    @dst.setter
    def dst(self, dst):
        _cdst = _HelperInputVoidPtr(dst)
        self._pvt_ptr[0].dst = <void*><void_ptr>_cdst.cptr
    {{endif}}
    {{if 'cudaMemsetParamsV2.pitch' in found_struct}}
    @property
    def pitch(self):
        return self._pvt_ptr[0].pitch
    @pitch.setter
    def pitch(self, size_t pitch):
        self._pvt_ptr[0].pitch = pitch
    {{endif}}
    {{if 'cudaMemsetParamsV2.value' in found_struct}}
    @property
    def value(self):
        return self._pvt_ptr[0].value
    @value.setter
    def value(self, unsigned int value):
        self._pvt_ptr[0].value = value
    {{endif}}
    {{if 'cudaMemsetParamsV2.elementSize' in found_struct}}
    @property
    def elementSize(self):
        return self._pvt_ptr[0].elementSize
    @elementSize.setter
    def elementSize(self, unsigned int elementSize):
        self._pvt_ptr[0].elementSize = elementSize
    {{endif}}
    {{if 'cudaMemsetParamsV2.width' in found_struct}}
    @property
    def width(self):
        return self._pvt_ptr[0].width
    @width.setter
    def width(self, size_t width):
        self._pvt_ptr[0].width = width
    {{endif}}
    {{if 'cudaMemsetParamsV2.height' in found_struct}}
    @property
    def height(self):
        return self._pvt_ptr[0].height
    @height.setter
    def height(self, size_t height):
        self._pvt_ptr[0].height = height
    {{endif}}
    {{if 'cudaMemsetParamsV2.ctx' in found_struct}}
    @property
    def ctx(self):
        return self._ctx
    @ctx.setter
    def ctx(self, ctx):
        cdef cyruntime.cudaExecutionContext_t cyctx
        if ctx is None:
            cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>0
        elif isinstance(ctx, (cudaExecutionContext_t,)):
            pctx = int(ctx)
            cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>pctx
        else:
            pctx = int(cudaExecutionContext_t(ctx))
            cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>pctx
        self._ctx._pvt_ptr[0] = cyctx
    {{endif}}
{{endif}}
{{if 'cudaAccessPolicyWindow' in found_struct}}

cdef class cudaAccessPolicyWindow:
    """
    Specifies an access policy for a window, a contiguous extent of
    memory beginning at base_ptr and ending at base_ptr + num_bytes.
    Partition into many segments and assign segments such that. sum of
    "hit segments" / window == approx. ratio. sum of "miss segments" /
    window == approx 1-ratio. Segments and ratio specifications are
    fitted to the capabilities of the architecture. Accesses in a hit
    segment apply the hitProp access policy. Accesses in a miss segment
    apply the missProp access policy.

    Attributes
    ----------
    {{if 'cudaAccessPolicyWindow.base_ptr' in found_struct}}
    base_ptr : Any
        Starting address of the access policy window. CUDA driver may align
        it.
    {{endif}}
    {{if 'cudaAccessPolicyWindow.num_bytes' in found_struct}}
    num_bytes : size_t
        Size in bytes of the window policy. CUDA driver may restrict the
        maximum size and alignment.
    {{endif}}
    {{if 'cudaAccessPolicyWindow.hitRatio' in found_struct}}
    hitRatio : float
        hitRatio specifies percentage of lines assigned hitProp, rest are
        assigned missProp.
    {{endif}}
    {{if 'cudaAccessPolicyWindow.hitProp' in found_struct}}
    hitProp : cudaAccessProperty
        ::CUaccessProperty set for hit.
    {{endif}}
    {{if 'cudaAccessPolicyWindow.missProp' in found_struct}}
    missProp : cudaAccessProperty
        ::CUaccessProperty set for miss. Must be either NORMAL or
        STREAMING.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaAccessPolicyWindow *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaAccessPolicyWindow.base_ptr' in found_struct}}
            try:
                str_list += ['base_ptr : ' + hex(self.base_ptr)]
            except ValueError:
                str_list += ['base_ptr : <ValueError>']
            {{endif}}
            {{if 'cudaAccessPolicyWindow.num_bytes' in found_struct}}
            try:
                str_list += ['num_bytes : ' + str(self.num_bytes)]
            except ValueError:
                str_list += ['num_bytes : <ValueError>']
            {{endif}}
            {{if 'cudaAccessPolicyWindow.hitRatio' in found_struct}}
            try:
                str_list += ['hitRatio : ' + str(self.hitRatio)]
            except ValueError:
                str_list += ['hitRatio : <ValueError>']
            {{endif}}
            {{if 'cudaAccessPolicyWindow.hitProp' in found_struct}}
            try:
                str_list += ['hitProp : ' + str(self.hitProp)]
            except ValueError:
                str_list += ['hitProp : <ValueError>']
            {{endif}}
            {{if 'cudaAccessPolicyWindow.missProp' in found_struct}}
            try:
                str_list += ['missProp : ' + str(self.missProp)]
            except ValueError:
                str_list += ['missProp : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaAccessPolicyWindow.base_ptr' in found_struct}}
    @property
    def base_ptr(self):
        return <void_ptr>self._pvt_ptr[0].base_ptr
    @base_ptr.setter
    def base_ptr(self, base_ptr):
        _cbase_ptr = _HelperInputVoidPtr(base_ptr)
        self._pvt_ptr[0].base_ptr = <void*><void_ptr>_cbase_ptr.cptr
    {{endif}}
    {{if 'cudaAccessPolicyWindow.num_bytes' in found_struct}}
    @property
    def num_bytes(self):
        return self._pvt_ptr[0].num_bytes
    @num_bytes.setter
    def num_bytes(self, size_t num_bytes):
        self._pvt_ptr[0].num_bytes = num_bytes
    {{endif}}
    {{if 'cudaAccessPolicyWindow.hitRatio' in found_struct}}
    @property
    def hitRatio(self):
        return self._pvt_ptr[0].hitRatio
    @hitRatio.setter
    def hitRatio(self, float hitRatio):
        self._pvt_ptr[0].hitRatio = hitRatio
    {{endif}}
    {{if 'cudaAccessPolicyWindow.hitProp' in found_struct}}
    @property
    def hitProp(self):
        return cudaAccessProperty(self._pvt_ptr[0].hitProp)
    @hitProp.setter
    def hitProp(self, hitProp not None : cudaAccessProperty):
        self._pvt_ptr[0].hitProp = int(hitProp)
    {{endif}}
    {{if 'cudaAccessPolicyWindow.missProp' in found_struct}}
    @property
    def missProp(self):
        return cudaAccessProperty(self._pvt_ptr[0].missProp)
    @missProp.setter
    def missProp(self, missProp not None : cudaAccessProperty):
        self._pvt_ptr[0].missProp = int(missProp)
    {{endif}}
{{endif}}
{{if 'cudaHostNodeParams' in found_struct}}

cdef class cudaHostNodeParams:
    """
    CUDA host node parameters

    Attributes
    ----------
    {{if 'cudaHostNodeParams.fn' in found_struct}}
    fn : cudaHostFn_t
        The function to call when the node executes
    {{endif}}
    {{if 'cudaHostNodeParams.userData' in found_struct}}
    userData : Any
        Argument to pass to the function
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaHostNodeParams *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaHostNodeParams.fn' in found_struct}}
        self._fn = cudaHostFn_t(_ptr=<void_ptr>&self._pvt_ptr[0].fn)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaHostNodeParams.fn' in found_struct}}
            try:
                str_list += ['fn : ' + str(self.fn)]
            except ValueError:
                str_list += ['fn : <ValueError>']
            {{endif}}
            {{if 'cudaHostNodeParams.userData' in found_struct}}
            try:
                str_list += ['userData : ' + hex(self.userData)]
            except ValueError:
                str_list += ['userData : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaHostNodeParams.fn' in found_struct}}
    @property
    def fn(self):
        return self._fn
    @fn.setter
    def fn(self, fn):
        cdef cyruntime.cudaHostFn_t cyfn
        if fn is None:
            cyfn = <cyruntime.cudaHostFn_t><void_ptr>0
        elif isinstance(fn, (cudaHostFn_t)):
            pfn = int(fn)
            cyfn = <cyruntime.cudaHostFn_t><void_ptr>pfn
        else:
            pfn = int(cudaHostFn_t(fn))
            cyfn = <cyruntime.cudaHostFn_t><void_ptr>pfn
        self._fn._pvt_ptr[0] = cyfn
    {{endif}}
    {{if 'cudaHostNodeParams.userData' in found_struct}}
    @property
    def userData(self):
        return <void_ptr>self._pvt_ptr[0].userData
    @userData.setter
    def userData(self, userData):
        _cuserData = _HelperInputVoidPtr(userData)
        self._pvt_ptr[0].userData = <void*><void_ptr>_cuserData.cptr
    {{endif}}
{{endif}}
{{if 'cudaHostNodeParamsV2' in found_struct}}

cdef class cudaHostNodeParamsV2:
    """
    CUDA host node parameters

    Attributes
    ----------
    {{if 'cudaHostNodeParamsV2.fn' in found_struct}}
    fn : cudaHostFn_t
        The function to call when the node executes
    {{endif}}
    {{if 'cudaHostNodeParamsV2.userData' in found_struct}}
    userData : Any
        Argument to pass to the function
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaHostNodeParamsV2 *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaHostNodeParamsV2.fn' in found_struct}}
        self._fn = cudaHostFn_t(_ptr=<void_ptr>&self._pvt_ptr[0].fn)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaHostNodeParamsV2.fn' in found_struct}}
            try:
                str_list += ['fn : ' + str(self.fn)]
            except ValueError:
                str_list += ['fn : <ValueError>']
            {{endif}}
            {{if 'cudaHostNodeParamsV2.userData' in found_struct}}
            try:
                str_list += ['userData : ' + hex(self.userData)]
            except ValueError:
                str_list += ['userData : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaHostNodeParamsV2.fn' in found_struct}}
    @property
    def fn(self):
        return self._fn
    @fn.setter
    def fn(self, fn):
        cdef cyruntime.cudaHostFn_t cyfn
        if fn is None:
            cyfn = <cyruntime.cudaHostFn_t><void_ptr>0
        elif isinstance(fn, (cudaHostFn_t)):
            pfn = int(fn)
            cyfn = <cyruntime.cudaHostFn_t><void_ptr>pfn
        else:
            pfn = int(cudaHostFn_t(fn))
            cyfn = <cyruntime.cudaHostFn_t><void_ptr>pfn
        self._fn._pvt_ptr[0] = cyfn
    {{endif}}
    {{if 'cudaHostNodeParamsV2.userData' in found_struct}}
    @property
    def userData(self):
        return <void_ptr>self._pvt_ptr[0].userData
    @userData.setter
    def userData(self, userData):
        _cuserData = _HelperInputVoidPtr(userData)
        self._pvt_ptr[0].userData = <void*><void_ptr>_cuserData.cptr
    {{endif}}
{{endif}}
{{if 'cudaResourceDesc.res.array' in found_struct}}

cdef class anon_struct1:
    """
    Attributes
    ----------
    {{if 'cudaResourceDesc.res.array.array' in found_struct}}
    array : cudaArray_t

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaResourceDesc *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'cudaResourceDesc.res.array.array' in found_struct}}
        self._array = cudaArray_t(_ptr=<void_ptr>&self._pvt_ptr[0].res.array.array)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].res.array
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaResourceDesc.res.array.array' in found_struct}}
            try:
                str_list += ['array : ' + str(self.array)]
            except ValueError:
                str_list += ['array : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaResourceDesc.res.array.array' in found_struct}}
    @property
    def array(self):
        return self._array
    @array.setter
    def array(self, array):
        cdef cyruntime.cudaArray_t cyarray
        if array is None:
            cyarray = <cyruntime.cudaArray_t><void_ptr>0
        elif isinstance(array, (cudaArray_t,)):
            parray = int(array)
            cyarray = <cyruntime.cudaArray_t><void_ptr>parray
        else:
            parray = int(cudaArray_t(array))
            cyarray = <cyruntime.cudaArray_t><void_ptr>parray
        self._array._pvt_ptr[0] = cyarray
    {{endif}}
{{endif}}
{{if 'cudaResourceDesc.res.mipmap' in found_struct}}

cdef class anon_struct2:
    """
    Attributes
    ----------
    {{if 'cudaResourceDesc.res.mipmap.mipmap' in found_struct}}
    mipmap : cudaMipmappedArray_t

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaResourceDesc *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'cudaResourceDesc.res.mipmap.mipmap' in found_struct}}
        self._mipmap = cudaMipmappedArray_t(_ptr=<void_ptr>&self._pvt_ptr[0].res.mipmap.mipmap)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].res.mipmap
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaResourceDesc.res.mipmap.mipmap' in found_struct}}
            try:
                str_list += ['mipmap : ' + str(self.mipmap)]
            except ValueError:
                str_list += ['mipmap : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaResourceDesc.res.mipmap.mipmap' in found_struct}}
    @property
    def mipmap(self):
        return self._mipmap
    @mipmap.setter
    def mipmap(self, mipmap):
        cdef cyruntime.cudaMipmappedArray_t cymipmap
        if mipmap is None:
            cymipmap = <cyruntime.cudaMipmappedArray_t><void_ptr>0
        elif isinstance(mipmap, (cudaMipmappedArray_t,)):
            pmipmap = int(mipmap)
            cymipmap = <cyruntime.cudaMipmappedArray_t><void_ptr>pmipmap
        else:
            pmipmap = int(cudaMipmappedArray_t(mipmap))
            cymipmap = <cyruntime.cudaMipmappedArray_t><void_ptr>pmipmap
        self._mipmap._pvt_ptr[0] = cymipmap
    {{endif}}
{{endif}}
{{if 'cudaResourceDesc.res.linear' in found_struct}}

cdef class anon_struct3:
    """
    Attributes
    ----------
    {{if 'cudaResourceDesc.res.linear.devPtr' in found_struct}}
    devPtr : Any

    {{endif}}
    {{if 'cudaResourceDesc.res.linear.desc' in found_struct}}
    desc : cudaChannelFormatDesc

    {{endif}}
    {{if 'cudaResourceDesc.res.linear.sizeInBytes' in found_struct}}
    sizeInBytes : size_t

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaResourceDesc *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'cudaResourceDesc.res.linear.desc' in found_struct}}
        self._desc = cudaChannelFormatDesc(_ptr=<void_ptr>&self._pvt_ptr[0].res.linear.desc)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].res.linear
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaResourceDesc.res.linear.devPtr' in found_struct}}
            try:
                str_list += ['devPtr : ' + hex(self.devPtr)]
            except ValueError:
                str_list += ['devPtr : <ValueError>']
            {{endif}}
            {{if 'cudaResourceDesc.res.linear.desc' in found_struct}}
            try:
                str_list += ['desc :\n' + '\n'.join(['    ' + line for line in str(self.desc).splitlines()])]
            except ValueError:
                str_list += ['desc : <ValueError>']
            {{endif}}
            {{if 'cudaResourceDesc.res.linear.sizeInBytes' in found_struct}}
            try:
                str_list += ['sizeInBytes : ' + str(self.sizeInBytes)]
            except ValueError:
                str_list += ['sizeInBytes : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaResourceDesc.res.linear.devPtr' in found_struct}}
    @property
    def devPtr(self):
        return <void_ptr>self._pvt_ptr[0].res.linear.devPtr
    @devPtr.setter
    def devPtr(self, devPtr):
        _cdevPtr = _HelperInputVoidPtr(devPtr)
        self._pvt_ptr[0].res.linear.devPtr = <void*><void_ptr>_cdevPtr.cptr
    {{endif}}
    {{if 'cudaResourceDesc.res.linear.desc' in found_struct}}
    @property
    def desc(self):
        return self._desc
    @desc.setter
    def desc(self, desc not None : cudaChannelFormatDesc):
        string.memcpy(&self._pvt_ptr[0].res.linear.desc, <cyruntime.cudaChannelFormatDesc*><void_ptr>desc.getPtr(), sizeof(self._pvt_ptr[0].res.linear.desc))
    {{endif}}
    {{if 'cudaResourceDesc.res.linear.sizeInBytes' in found_struct}}
    @property
    def sizeInBytes(self):
        return self._pvt_ptr[0].res.linear.sizeInBytes
    @sizeInBytes.setter
    def sizeInBytes(self, size_t sizeInBytes):
        self._pvt_ptr[0].res.linear.sizeInBytes = sizeInBytes
    {{endif}}
{{endif}}
{{if 'cudaResourceDesc.res.pitch2D' in found_struct}}

cdef class anon_struct4:
    """
    Attributes
    ----------
    {{if 'cudaResourceDesc.res.pitch2D.devPtr' in found_struct}}
    devPtr : Any

    {{endif}}
    {{if 'cudaResourceDesc.res.pitch2D.desc' in found_struct}}
    desc : cudaChannelFormatDesc

    {{endif}}
    {{if 'cudaResourceDesc.res.pitch2D.width' in found_struct}}
    width : size_t

    {{endif}}
    {{if 'cudaResourceDesc.res.pitch2D.height' in found_struct}}
    height : size_t

    {{endif}}
    {{if 'cudaResourceDesc.res.pitch2D.pitchInBytes' in found_struct}}
    pitchInBytes : size_t

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaResourceDesc *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'cudaResourceDesc.res.pitch2D.desc' in found_struct}}
        self._desc = cudaChannelFormatDesc(_ptr=<void_ptr>&self._pvt_ptr[0].res.pitch2D.desc)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].res.pitch2D
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaResourceDesc.res.pitch2D.devPtr' in found_struct}}
            try:
                str_list += ['devPtr : ' + hex(self.devPtr)]
            except ValueError:
                str_list += ['devPtr : <ValueError>']
            {{endif}}
            {{if 'cudaResourceDesc.res.pitch2D.desc' in found_struct}}
            try:
                str_list += ['desc :\n' + '\n'.join(['    ' + line for line in str(self.desc).splitlines()])]
            except ValueError:
                str_list += ['desc : <ValueError>']
            {{endif}}
            {{if 'cudaResourceDesc.res.pitch2D.width' in found_struct}}
            try:
                str_list += ['width : ' + str(self.width)]
            except ValueError:
                str_list += ['width : <ValueError>']
            {{endif}}
            {{if 'cudaResourceDesc.res.pitch2D.height' in found_struct}}
            try:
                str_list += ['height : ' + str(self.height)]
            except ValueError:
                str_list += ['height : <ValueError>']
            {{endif}}
            {{if 'cudaResourceDesc.res.pitch2D.pitchInBytes' in found_struct}}
            try:
                str_list += ['pitchInBytes : ' + str(self.pitchInBytes)]
            except ValueError:
                str_list += ['pitchInBytes : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaResourceDesc.res.pitch2D.devPtr' in found_struct}}
    @property
    def devPtr(self):
        return <void_ptr>self._pvt_ptr[0].res.pitch2D.devPtr
    @devPtr.setter
    def devPtr(self, devPtr):
        _cdevPtr = _HelperInputVoidPtr(devPtr)
        self._pvt_ptr[0].res.pitch2D.devPtr = <void*><void_ptr>_cdevPtr.cptr
    {{endif}}
    {{if 'cudaResourceDesc.res.pitch2D.desc' in found_struct}}
    @property
    def desc(self):
        return self._desc
    @desc.setter
    def desc(self, desc not None : cudaChannelFormatDesc):
        string.memcpy(&self._pvt_ptr[0].res.pitch2D.desc, <cyruntime.cudaChannelFormatDesc*><void_ptr>desc.getPtr(), sizeof(self._pvt_ptr[0].res.pitch2D.desc))
    {{endif}}
    {{if 'cudaResourceDesc.res.pitch2D.width' in found_struct}}
    @property
    def width(self):
        return self._pvt_ptr[0].res.pitch2D.width
    @width.setter
    def width(self, size_t width):
        self._pvt_ptr[0].res.pitch2D.width = width
    {{endif}}
    {{if 'cudaResourceDesc.res.pitch2D.height' in found_struct}}
    @property
    def height(self):
        return self._pvt_ptr[0].res.pitch2D.height
    @height.setter
    def height(self, size_t height):
        self._pvt_ptr[0].res.pitch2D.height = height
    {{endif}}
    {{if 'cudaResourceDesc.res.pitch2D.pitchInBytes' in found_struct}}
    @property
    def pitchInBytes(self):
        return self._pvt_ptr[0].res.pitch2D.pitchInBytes
    @pitchInBytes.setter
    def pitchInBytes(self, size_t pitchInBytes):
        self._pvt_ptr[0].res.pitch2D.pitchInBytes = pitchInBytes
    {{endif}}
{{endif}}
{{if 'cudaResourceDesc.res.reserved' in found_struct}}

cdef class anon_struct5:
    """
    Attributes
    ----------
    {{if 'cudaResourceDesc.res.reserved.reserved' in found_struct}}
    reserved : list[int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaResourceDesc *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].res.reserved
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaResourceDesc.res.reserved.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaResourceDesc.res.reserved.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].res.reserved.reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].res.reserved.reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaResourceDesc.res' in found_struct}}

cdef class anon_union0:
    """
    Attributes
    ----------
    {{if 'cudaResourceDesc.res.array' in found_struct}}
    array : anon_struct1

    {{endif}}
    {{if 'cudaResourceDesc.res.mipmap' in found_struct}}
    mipmap : anon_struct2

    {{endif}}
    {{if 'cudaResourceDesc.res.linear' in found_struct}}
    linear : anon_struct3

    {{endif}}
    {{if 'cudaResourceDesc.res.pitch2D' in found_struct}}
    pitch2D : anon_struct4

    {{endif}}
    {{if 'cudaResourceDesc.res.reserved' in found_struct}}
    reserved : anon_struct5

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaResourceDesc *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'cudaResourceDesc.res.array' in found_struct}}
        self._array = anon_struct1(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'cudaResourceDesc.res.mipmap' in found_struct}}
        self._mipmap = anon_struct2(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'cudaResourceDesc.res.linear' in found_struct}}
        self._linear = anon_struct3(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'cudaResourceDesc.res.pitch2D' in found_struct}}
        self._pitch2D = anon_struct4(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'cudaResourceDesc.res.reserved' in found_struct}}
        self._reserved = anon_struct5(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].res
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaResourceDesc.res.array' in found_struct}}
            try:
                str_list += ['array :\n' + '\n'.join(['    ' + line for line in str(self.array).splitlines()])]
            except ValueError:
                str_list += ['array : <ValueError>']
            {{endif}}
            {{if 'cudaResourceDesc.res.mipmap' in found_struct}}
            try:
                str_list += ['mipmap :\n' + '\n'.join(['    ' + line for line in str(self.mipmap).splitlines()])]
            except ValueError:
                str_list += ['mipmap : <ValueError>']
            {{endif}}
            {{if 'cudaResourceDesc.res.linear' in found_struct}}
            try:
                str_list += ['linear :\n' + '\n'.join(['    ' + line for line in str(self.linear).splitlines()])]
            except ValueError:
                str_list += ['linear : <ValueError>']
            {{endif}}
            {{if 'cudaResourceDesc.res.pitch2D' in found_struct}}
            try:
                str_list += ['pitch2D :\n' + '\n'.join(['    ' + line for line in str(self.pitch2D).splitlines()])]
            except ValueError:
                str_list += ['pitch2D : <ValueError>']
            {{endif}}
            {{if 'cudaResourceDesc.res.reserved' in found_struct}}
            try:
                str_list += ['reserved :\n' + '\n'.join(['    ' + line for line in str(self.reserved).splitlines()])]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaResourceDesc.res.array' in found_struct}}
    @property
    def array(self):
        return self._array
    @array.setter
    def array(self, array not None : anon_struct1):
        string.memcpy(&self._pvt_ptr[0].res.array, <cyruntime.anon_struct1*><void_ptr>array.getPtr(), sizeof(self._pvt_ptr[0].res.array))
    {{endif}}
    {{if 'cudaResourceDesc.res.mipmap' in found_struct}}
    @property
    def mipmap(self):
        return self._mipmap
    @mipmap.setter
    def mipmap(self, mipmap not None : anon_struct2):
        string.memcpy(&self._pvt_ptr[0].res.mipmap, <cyruntime.anon_struct2*><void_ptr>mipmap.getPtr(), sizeof(self._pvt_ptr[0].res.mipmap))
    {{endif}}
    {{if 'cudaResourceDesc.res.linear' in found_struct}}
    @property
    def linear(self):
        return self._linear
    @linear.setter
    def linear(self, linear not None : anon_struct3):
        string.memcpy(&self._pvt_ptr[0].res.linear, <cyruntime.anon_struct3*><void_ptr>linear.getPtr(), sizeof(self._pvt_ptr[0].res.linear))
    {{endif}}
    {{if 'cudaResourceDesc.res.pitch2D' in found_struct}}
    @property
    def pitch2D(self):
        return self._pitch2D
    @pitch2D.setter
    def pitch2D(self, pitch2D not None : anon_struct4):
        string.memcpy(&self._pvt_ptr[0].res.pitch2D, <cyruntime.anon_struct4*><void_ptr>pitch2D.getPtr(), sizeof(self._pvt_ptr[0].res.pitch2D))
    {{endif}}
    {{if 'cudaResourceDesc.res.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._reserved
    @reserved.setter
    def reserved(self, reserved not None : anon_struct5):
        string.memcpy(&self._pvt_ptr[0].res.reserved, <cyruntime.anon_struct5*><void_ptr>reserved.getPtr(), sizeof(self._pvt_ptr[0].res.reserved))
    {{endif}}
{{endif}}
{{if 'cudaResourceDesc' in found_struct}}

cdef class cudaResourceDesc:
    """
    CUDA resource descriptor

    Attributes
    ----------
    {{if 'cudaResourceDesc.resType' in found_struct}}
    resType : cudaResourceType
        Resource type
    {{endif}}
    {{if 'cudaResourceDesc.res' in found_struct}}
    res : anon_union0

    {{endif}}
    {{if 'cudaResourceDesc.flags' in found_struct}}
    flags : unsigned int
        Flags (must be zero)
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cyruntime.cudaResourceDesc *>calloc(1, sizeof(cyruntime.cudaResourceDesc))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cyruntime.cudaResourceDesc *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaResourceDesc.res' in found_struct}}
        self._res = anon_union0(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaResourceDesc.resType' in found_struct}}
            try:
                str_list += ['resType : ' + str(self.resType)]
            except ValueError:
                str_list += ['resType : <ValueError>']
            {{endif}}
            {{if 'cudaResourceDesc.res' in found_struct}}
            try:
                str_list += ['res :\n' + '\n'.join(['    ' + line for line in str(self.res).splitlines()])]
            except ValueError:
                str_list += ['res : <ValueError>']
            {{endif}}
            {{if 'cudaResourceDesc.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaResourceDesc.resType' in found_struct}}
    @property
    def resType(self):
        return cudaResourceType(self._pvt_ptr[0].resType)
    @resType.setter
    def resType(self, resType not None : cudaResourceType):
        self._pvt_ptr[0].resType = int(resType)
    {{endif}}
    {{if 'cudaResourceDesc.res' in found_struct}}
    @property
    def res(self):
        return self._res
    @res.setter
    def res(self, res not None : anon_union0):
        string.memcpy(&self._pvt_ptr[0].res, <cyruntime.anon_union0*><void_ptr>res.getPtr(), sizeof(self._pvt_ptr[0].res))
    {{endif}}
    {{if 'cudaResourceDesc.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
{{endif}}
{{if 'cudaResourceViewDesc' in found_struct}}

cdef class cudaResourceViewDesc:
    """
    CUDA resource view descriptor

    Attributes
    ----------
    {{if 'cudaResourceViewDesc.format' in found_struct}}
    format : cudaResourceViewFormat
        Resource view format
    {{endif}}
    {{if 'cudaResourceViewDesc.width' in found_struct}}
    width : size_t
        Width of the resource view
    {{endif}}
    {{if 'cudaResourceViewDesc.height' in found_struct}}
    height : size_t
        Height of the resource view
    {{endif}}
    {{if 'cudaResourceViewDesc.depth' in found_struct}}
    depth : size_t
        Depth of the resource view
    {{endif}}
    {{if 'cudaResourceViewDesc.firstMipmapLevel' in found_struct}}
    firstMipmapLevel : unsigned int
        First defined mipmap level
    {{endif}}
    {{if 'cudaResourceViewDesc.lastMipmapLevel' in found_struct}}
    lastMipmapLevel : unsigned int
        Last defined mipmap level
    {{endif}}
    {{if 'cudaResourceViewDesc.firstLayer' in found_struct}}
    firstLayer : unsigned int
        First layer index
    {{endif}}
    {{if 'cudaResourceViewDesc.lastLayer' in found_struct}}
    lastLayer : unsigned int
        Last layer index
    {{endif}}
    {{if 'cudaResourceViewDesc.reserved' in found_struct}}
    reserved : list[unsigned int]
        Must be zero
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaResourceViewDesc *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaResourceViewDesc.format' in found_struct}}
            try:
                str_list += ['format : ' + str(self.format)]
            except ValueError:
                str_list += ['format : <ValueError>']
            {{endif}}
            {{if 'cudaResourceViewDesc.width' in found_struct}}
            try:
                str_list += ['width : ' + str(self.width)]
            except ValueError:
                str_list += ['width : <ValueError>']
            {{endif}}
            {{if 'cudaResourceViewDesc.height' in found_struct}}
            try:
                str_list += ['height : ' + str(self.height)]
            except ValueError:
                str_list += ['height : <ValueError>']
            {{endif}}
            {{if 'cudaResourceViewDesc.depth' in found_struct}}
            try:
                str_list += ['depth : ' + str(self.depth)]
            except ValueError:
                str_list += ['depth : <ValueError>']
            {{endif}}
            {{if 'cudaResourceViewDesc.firstMipmapLevel' in found_struct}}
            try:
                str_list += ['firstMipmapLevel : ' + str(self.firstMipmapLevel)]
            except ValueError:
                str_list += ['firstMipmapLevel : <ValueError>']
            {{endif}}
            {{if 'cudaResourceViewDesc.lastMipmapLevel' in found_struct}}
            try:
                str_list += ['lastMipmapLevel : ' + str(self.lastMipmapLevel)]
            except ValueError:
                str_list += ['lastMipmapLevel : <ValueError>']
            {{endif}}
            {{if 'cudaResourceViewDesc.firstLayer' in found_struct}}
            try:
                str_list += ['firstLayer : ' + str(self.firstLayer)]
            except ValueError:
                str_list += ['firstLayer : <ValueError>']
            {{endif}}
            {{if 'cudaResourceViewDesc.lastLayer' in found_struct}}
            try:
                str_list += ['lastLayer : ' + str(self.lastLayer)]
            except ValueError:
                str_list += ['lastLayer : <ValueError>']
            {{endif}}
            {{if 'cudaResourceViewDesc.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaResourceViewDesc.format' in found_struct}}
    @property
    def format(self):
        return cudaResourceViewFormat(self._pvt_ptr[0].format)
    @format.setter
    def format(self, format not None : cudaResourceViewFormat):
        self._pvt_ptr[0].format = int(format)
    {{endif}}
    {{if 'cudaResourceViewDesc.width' in found_struct}}
    @property
    def width(self):
        return self._pvt_ptr[0].width
    @width.setter
    def width(self, size_t width):
        self._pvt_ptr[0].width = width
    {{endif}}
    {{if 'cudaResourceViewDesc.height' in found_struct}}
    @property
    def height(self):
        return self._pvt_ptr[0].height
    @height.setter
    def height(self, size_t height):
        self._pvt_ptr[0].height = height
    {{endif}}
    {{if 'cudaResourceViewDesc.depth' in found_struct}}
    @property
    def depth(self):
        return self._pvt_ptr[0].depth
    @depth.setter
    def depth(self, size_t depth):
        self._pvt_ptr[0].depth = depth
    {{endif}}
    {{if 'cudaResourceViewDesc.firstMipmapLevel' in found_struct}}
    @property
    def firstMipmapLevel(self):
        return self._pvt_ptr[0].firstMipmapLevel
    @firstMipmapLevel.setter
    def firstMipmapLevel(self, unsigned int firstMipmapLevel):
        self._pvt_ptr[0].firstMipmapLevel = firstMipmapLevel
    {{endif}}
    {{if 'cudaResourceViewDesc.lastMipmapLevel' in found_struct}}
    @property
    def lastMipmapLevel(self):
        return self._pvt_ptr[0].lastMipmapLevel
    @lastMipmapLevel.setter
    def lastMipmapLevel(self, unsigned int lastMipmapLevel):
        self._pvt_ptr[0].lastMipmapLevel = lastMipmapLevel
    {{endif}}
    {{if 'cudaResourceViewDesc.firstLayer' in found_struct}}
    @property
    def firstLayer(self):
        return self._pvt_ptr[0].firstLayer
    @firstLayer.setter
    def firstLayer(self, unsigned int firstLayer):
        self._pvt_ptr[0].firstLayer = firstLayer
    {{endif}}
    {{if 'cudaResourceViewDesc.lastLayer' in found_struct}}
    @property
    def lastLayer(self):
        return self._pvt_ptr[0].lastLayer
    @lastLayer.setter
    def lastLayer(self, unsigned int lastLayer):
        self._pvt_ptr[0].lastLayer = lastLayer
    {{endif}}
    {{if 'cudaResourceViewDesc.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaPointerAttributes' in found_struct}}

cdef class cudaPointerAttributes:
    """
    CUDA pointer attributes

    Attributes
    ----------
    {{if 'cudaPointerAttributes.type' in found_struct}}
    type : cudaMemoryType
        The type of memory - cudaMemoryTypeUnregistered,
        cudaMemoryTypeHost, cudaMemoryTypeDevice or cudaMemoryTypeManaged.
    {{endif}}
    {{if 'cudaPointerAttributes.device' in found_struct}}
    device : int
        The device against which the memory was allocated or registered. If
        the memory type is cudaMemoryTypeDevice then this identifies the
        device on which the memory referred physically resides. If the
        memory type is cudaMemoryTypeHost or::cudaMemoryTypeManaged then
        this identifies the device which was current when the memory was
        allocated or registered (and if that device is deinitialized then
        this allocation will vanish with that device's state).
    {{endif}}
    {{if 'cudaPointerAttributes.devicePointer' in found_struct}}
    devicePointer : Any
        The address which may be dereferenced on the current device to
        access the memory or NULL if no such address exists.
    {{endif}}
    {{if 'cudaPointerAttributes.hostPointer' in found_struct}}
    hostPointer : Any
        The address which may be dereferenced on the host to access the
        memory or NULL if no such address exists.  CUDA doesn't check if
        unregistered memory is allocated so this field may contain invalid
        pointer if an invalid pointer has been passed to CUDA.
    {{endif}}
    {{if 'cudaPointerAttributes.reserved' in found_struct}}
    reserved : list[long]
        Must be zero
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaPointerAttributes *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaPointerAttributes.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'cudaPointerAttributes.device' in found_struct}}
            try:
                str_list += ['device : ' + str(self.device)]
            except ValueError:
                str_list += ['device : <ValueError>']
            {{endif}}
            {{if 'cudaPointerAttributes.devicePointer' in found_struct}}
            try:
                str_list += ['devicePointer : ' + hex(self.devicePointer)]
            except ValueError:
                str_list += ['devicePointer : <ValueError>']
            {{endif}}
            {{if 'cudaPointerAttributes.hostPointer' in found_struct}}
            try:
                str_list += ['hostPointer : ' + hex(self.hostPointer)]
            except ValueError:
                str_list += ['hostPointer : <ValueError>']
            {{endif}}
            {{if 'cudaPointerAttributes.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaPointerAttributes.type' in found_struct}}
    @property
    def type(self):
        return cudaMemoryType(self._pvt_ptr[0].type)
    @type.setter
    def type(self, type not None : cudaMemoryType):
        self._pvt_ptr[0].type = int(type)
    {{endif}}
    {{if 'cudaPointerAttributes.device' in found_struct}}
    @property
    def device(self):
        return self._pvt_ptr[0].device
    @device.setter
    def device(self, int device):
        self._pvt_ptr[0].device = device
    {{endif}}
    {{if 'cudaPointerAttributes.devicePointer' in found_struct}}
    @property
    def devicePointer(self):
        return <void_ptr>self._pvt_ptr[0].devicePointer
    @devicePointer.setter
    def devicePointer(self, devicePointer):
        _cdevicePointer = _HelperInputVoidPtr(devicePointer)
        self._pvt_ptr[0].devicePointer = <void*><void_ptr>_cdevicePointer.cptr
    {{endif}}
    {{if 'cudaPointerAttributes.hostPointer' in found_struct}}
    @property
    def hostPointer(self):
        return <void_ptr>self._pvt_ptr[0].hostPointer
    @hostPointer.setter
    def hostPointer(self, hostPointer):
        _chostPointer = _HelperInputVoidPtr(hostPointer)
        self._pvt_ptr[0].hostPointer = <void*><void_ptr>_chostPointer.cptr
    {{endif}}
    {{if 'cudaPointerAttributes.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaFuncAttributes' in found_struct}}

cdef class cudaFuncAttributes:
    """
    CUDA function attributes

    Attributes
    ----------
    {{if 'cudaFuncAttributes.sharedSizeBytes' in found_struct}}
    sharedSizeBytes : size_t
        The size in bytes of statically-allocated shared memory per block
        required by this function. This does not include dynamically-
        allocated shared memory requested by the user at runtime.
    {{endif}}
    {{if 'cudaFuncAttributes.constSizeBytes' in found_struct}}
    constSizeBytes : size_t
        The size in bytes of user-allocated constant memory required by
        this function.
    {{endif}}
    {{if 'cudaFuncAttributes.localSizeBytes' in found_struct}}
    localSizeBytes : size_t
        The size in bytes of local memory used by each thread of this
        function.
    {{endif}}
    {{if 'cudaFuncAttributes.maxThreadsPerBlock' in found_struct}}
    maxThreadsPerBlock : int
        The maximum number of threads per block, beyond which a launch of
        the function would fail. This number depends on both the function
        and the device on which the function is currently loaded.
    {{endif}}
    {{if 'cudaFuncAttributes.numRegs' in found_struct}}
    numRegs : int
        The number of registers used by each thread of this function.
    {{endif}}
    {{if 'cudaFuncAttributes.ptxVersion' in found_struct}}
    ptxVersion : int
        The PTX virtual architecture version for which the function was
        compiled. This value is the major PTX version * 10 + the minor PTX
        version, so a PTX version 1.3 function would return the value 13.
    {{endif}}
    {{if 'cudaFuncAttributes.binaryVersion' in found_struct}}
    binaryVersion : int
        The binary architecture version for which the function was
        compiled. This value is the major binary version * 10 + the minor
        binary version, so a binary version 1.3 function would return the
        value 13.
    {{endif}}
    {{if 'cudaFuncAttributes.cacheModeCA' in found_struct}}
    cacheModeCA : int
        The attribute to indicate whether the function has been compiled
        with user specified option "-Xptxas --dlcm=ca" set.
    {{endif}}
    {{if 'cudaFuncAttributes.maxDynamicSharedSizeBytes' in found_struct}}
    maxDynamicSharedSizeBytes : int
        The maximum size in bytes of dynamic shared memory per block for
        this function. Any launch must have a dynamic shared memory size
        smaller than this value.
    {{endif}}
    {{if 'cudaFuncAttributes.preferredShmemCarveout' in found_struct}}
    preferredShmemCarveout : int
        On devices where the L1 cache and shared memory use the same
        hardware resources, this sets the shared memory carveout
        preference, in percent of the maximum shared memory. Refer to
        cudaDevAttrMaxSharedMemoryPerMultiprocessor. This is only a hint,
        and the driver can choose a different ratio if required to execute
        the function. See cudaFuncSetAttribute
    {{endif}}
    {{if 'cudaFuncAttributes.clusterDimMustBeSet' in found_struct}}
    clusterDimMustBeSet : int
        If this attribute is set, the kernel must launch with a valid
        cluster dimension specified.
    {{endif}}
    {{if 'cudaFuncAttributes.requiredClusterWidth' in found_struct}}
    requiredClusterWidth : int
        The required cluster width/height/depth in blocks. The values must
        either all be 0 or all be positive. The validity of the cluster
        dimensions is otherwise checked at launch time.  If the value is
        set during compile time, it cannot be set at runtime. Setting it at
        runtime should return cudaErrorNotPermitted. See
        cudaFuncSetAttribute
    {{endif}}
    {{if 'cudaFuncAttributes.requiredClusterHeight' in found_struct}}
    requiredClusterHeight : int

    {{endif}}
    {{if 'cudaFuncAttributes.requiredClusterDepth' in found_struct}}
    requiredClusterDepth : int

    {{endif}}
    {{if 'cudaFuncAttributes.clusterSchedulingPolicyPreference' in found_struct}}
    clusterSchedulingPolicyPreference : int
        The block scheduling policy of a function. See cudaFuncSetAttribute
    {{endif}}
    {{if 'cudaFuncAttributes.nonPortableClusterSizeAllowed' in found_struct}}
    nonPortableClusterSizeAllowed : int
        Whether the function can be launched with non-portable cluster
        size. 1 is allowed, 0 is disallowed. A non-portable cluster size
        may only function on the specific SKUs the program is tested on.
        The launch might fail if the program is run on a different hardware
        platform.  CUDA API provides cudaOccupancyMaxActiveClusters to
        assist with checking whether the desired size can be launched on
        the current device.  Portable Cluster Size  A portable cluster size
        is guaranteed to be functional on all compute capabilities higher
        than the target compute capability. The portable cluster size for
        sm_90 is 8 blocks per cluster. This value may increase for future
        compute capabilities.  The specific hardware unit may support
        higher cluster sizes thats not guaranteed to be portable. See
        cudaFuncSetAttribute
    {{endif}}
    {{if 'cudaFuncAttributes.reserved' in found_struct}}
    reserved : list[int]
        Reserved for future use.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaFuncAttributes *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaFuncAttributes.sharedSizeBytes' in found_struct}}
            try:
                str_list += ['sharedSizeBytes : ' + str(self.sharedSizeBytes)]
            except ValueError:
                str_list += ['sharedSizeBytes : <ValueError>']
            {{endif}}
            {{if 'cudaFuncAttributes.constSizeBytes' in found_struct}}
            try:
                str_list += ['constSizeBytes : ' + str(self.constSizeBytes)]
            except ValueError:
                str_list += ['constSizeBytes : <ValueError>']
            {{endif}}
            {{if 'cudaFuncAttributes.localSizeBytes' in found_struct}}
            try:
                str_list += ['localSizeBytes : ' + str(self.localSizeBytes)]
            except ValueError:
                str_list += ['localSizeBytes : <ValueError>']
            {{endif}}
            {{if 'cudaFuncAttributes.maxThreadsPerBlock' in found_struct}}
            try:
                str_list += ['maxThreadsPerBlock : ' + str(self.maxThreadsPerBlock)]
            except ValueError:
                str_list += ['maxThreadsPerBlock : <ValueError>']
            {{endif}}
            {{if 'cudaFuncAttributes.numRegs' in found_struct}}
            try:
                str_list += ['numRegs : ' + str(self.numRegs)]
            except ValueError:
                str_list += ['numRegs : <ValueError>']
            {{endif}}
            {{if 'cudaFuncAttributes.ptxVersion' in found_struct}}
            try:
                str_list += ['ptxVersion : ' + str(self.ptxVersion)]
            except ValueError:
                str_list += ['ptxVersion : <ValueError>']
            {{endif}}
            {{if 'cudaFuncAttributes.binaryVersion' in found_struct}}
            try:
                str_list += ['binaryVersion : ' + str(self.binaryVersion)]
            except ValueError:
                str_list += ['binaryVersion : <ValueError>']
            {{endif}}
            {{if 'cudaFuncAttributes.cacheModeCA' in found_struct}}
            try:
                str_list += ['cacheModeCA : ' + str(self.cacheModeCA)]
            except ValueError:
                str_list += ['cacheModeCA : <ValueError>']
            {{endif}}
            {{if 'cudaFuncAttributes.maxDynamicSharedSizeBytes' in found_struct}}
            try:
                str_list += ['maxDynamicSharedSizeBytes : ' + str(self.maxDynamicSharedSizeBytes)]
            except ValueError:
                str_list += ['maxDynamicSharedSizeBytes : <ValueError>']
            {{endif}}
            {{if 'cudaFuncAttributes.preferredShmemCarveout' in found_struct}}
            try:
                str_list += ['preferredShmemCarveout : ' + str(self.preferredShmemCarveout)]
            except ValueError:
                str_list += ['preferredShmemCarveout : <ValueError>']
            {{endif}}
            {{if 'cudaFuncAttributes.clusterDimMustBeSet' in found_struct}}
            try:
                str_list += ['clusterDimMustBeSet : ' + str(self.clusterDimMustBeSet)]
            except ValueError:
                str_list += ['clusterDimMustBeSet : <ValueError>']
            {{endif}}
            {{if 'cudaFuncAttributes.requiredClusterWidth' in found_struct}}
            try:
                str_list += ['requiredClusterWidth : ' + str(self.requiredClusterWidth)]
            except ValueError:
                str_list += ['requiredClusterWidth : <ValueError>']
            {{endif}}
            {{if 'cudaFuncAttributes.requiredClusterHeight' in found_struct}}
            try:
                str_list += ['requiredClusterHeight : ' + str(self.requiredClusterHeight)]
            except ValueError:
                str_list += ['requiredClusterHeight : <ValueError>']
            {{endif}}
            {{if 'cudaFuncAttributes.requiredClusterDepth' in found_struct}}
            try:
                str_list += ['requiredClusterDepth : ' + str(self.requiredClusterDepth)]
            except ValueError:
                str_list += ['requiredClusterDepth : <ValueError>']
            {{endif}}
            {{if 'cudaFuncAttributes.clusterSchedulingPolicyPreference' in found_struct}}
            try:
                str_list += ['clusterSchedulingPolicyPreference : ' + str(self.clusterSchedulingPolicyPreference)]
            except ValueError:
                str_list += ['clusterSchedulingPolicyPreference : <ValueError>']
            {{endif}}
            {{if 'cudaFuncAttributes.nonPortableClusterSizeAllowed' in found_struct}}
            try:
                str_list += ['nonPortableClusterSizeAllowed : ' + str(self.nonPortableClusterSizeAllowed)]
            except ValueError:
                str_list += ['nonPortableClusterSizeAllowed : <ValueError>']
            {{endif}}
            {{if 'cudaFuncAttributes.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaFuncAttributes.sharedSizeBytes' in found_struct}}
    @property
    def sharedSizeBytes(self):
        return self._pvt_ptr[0].sharedSizeBytes
    @sharedSizeBytes.setter
    def sharedSizeBytes(self, size_t sharedSizeBytes):
        self._pvt_ptr[0].sharedSizeBytes = sharedSizeBytes
    {{endif}}
    {{if 'cudaFuncAttributes.constSizeBytes' in found_struct}}
    @property
    def constSizeBytes(self):
        return self._pvt_ptr[0].constSizeBytes
    @constSizeBytes.setter
    def constSizeBytes(self, size_t constSizeBytes):
        self._pvt_ptr[0].constSizeBytes = constSizeBytes
    {{endif}}
    {{if 'cudaFuncAttributes.localSizeBytes' in found_struct}}
    @property
    def localSizeBytes(self):
        return self._pvt_ptr[0].localSizeBytes
    @localSizeBytes.setter
    def localSizeBytes(self, size_t localSizeBytes):
        self._pvt_ptr[0].localSizeBytes = localSizeBytes
    {{endif}}
    {{if 'cudaFuncAttributes.maxThreadsPerBlock' in found_struct}}
    @property
    def maxThreadsPerBlock(self):
        return self._pvt_ptr[0].maxThreadsPerBlock
    @maxThreadsPerBlock.setter
    def maxThreadsPerBlock(self, int maxThreadsPerBlock):
        self._pvt_ptr[0].maxThreadsPerBlock = maxThreadsPerBlock
    {{endif}}
    {{if 'cudaFuncAttributes.numRegs' in found_struct}}
    @property
    def numRegs(self):
        return self._pvt_ptr[0].numRegs
    @numRegs.setter
    def numRegs(self, int numRegs):
        self._pvt_ptr[0].numRegs = numRegs
    {{endif}}
    {{if 'cudaFuncAttributes.ptxVersion' in found_struct}}
    @property
    def ptxVersion(self):
        return self._pvt_ptr[0].ptxVersion
    @ptxVersion.setter
    def ptxVersion(self, int ptxVersion):
        self._pvt_ptr[0].ptxVersion = ptxVersion
    {{endif}}
    {{if 'cudaFuncAttributes.binaryVersion' in found_struct}}
    @property
    def binaryVersion(self):
        return self._pvt_ptr[0].binaryVersion
    @binaryVersion.setter
    def binaryVersion(self, int binaryVersion):
        self._pvt_ptr[0].binaryVersion = binaryVersion
    {{endif}}
    {{if 'cudaFuncAttributes.cacheModeCA' in found_struct}}
    @property
    def cacheModeCA(self):
        return self._pvt_ptr[0].cacheModeCA
    @cacheModeCA.setter
    def cacheModeCA(self, int cacheModeCA):
        self._pvt_ptr[0].cacheModeCA = cacheModeCA
    {{endif}}
    {{if 'cudaFuncAttributes.maxDynamicSharedSizeBytes' in found_struct}}
    @property
    def maxDynamicSharedSizeBytes(self):
        return self._pvt_ptr[0].maxDynamicSharedSizeBytes
    @maxDynamicSharedSizeBytes.setter
    def maxDynamicSharedSizeBytes(self, int maxDynamicSharedSizeBytes):
        self._pvt_ptr[0].maxDynamicSharedSizeBytes = maxDynamicSharedSizeBytes
    {{endif}}
    {{if 'cudaFuncAttributes.preferredShmemCarveout' in found_struct}}
    @property
    def preferredShmemCarveout(self):
        return self._pvt_ptr[0].preferredShmemCarveout
    @preferredShmemCarveout.setter
    def preferredShmemCarveout(self, int preferredShmemCarveout):
        self._pvt_ptr[0].preferredShmemCarveout = preferredShmemCarveout
    {{endif}}
    {{if 'cudaFuncAttributes.clusterDimMustBeSet' in found_struct}}
    @property
    def clusterDimMustBeSet(self):
        return self._pvt_ptr[0].clusterDimMustBeSet
    @clusterDimMustBeSet.setter
    def clusterDimMustBeSet(self, int clusterDimMustBeSet):
        self._pvt_ptr[0].clusterDimMustBeSet = clusterDimMustBeSet
    {{endif}}
    {{if 'cudaFuncAttributes.requiredClusterWidth' in found_struct}}
    @property
    def requiredClusterWidth(self):
        return self._pvt_ptr[0].requiredClusterWidth
    @requiredClusterWidth.setter
    def requiredClusterWidth(self, int requiredClusterWidth):
        self._pvt_ptr[0].requiredClusterWidth = requiredClusterWidth
    {{endif}}
    {{if 'cudaFuncAttributes.requiredClusterHeight' in found_struct}}
    @property
    def requiredClusterHeight(self):
        return self._pvt_ptr[0].requiredClusterHeight
    @requiredClusterHeight.setter
    def requiredClusterHeight(self, int requiredClusterHeight):
        self._pvt_ptr[0].requiredClusterHeight = requiredClusterHeight
    {{endif}}
    {{if 'cudaFuncAttributes.requiredClusterDepth' in found_struct}}
    @property
    def requiredClusterDepth(self):
        return self._pvt_ptr[0].requiredClusterDepth
    @requiredClusterDepth.setter
    def requiredClusterDepth(self, int requiredClusterDepth):
        self._pvt_ptr[0].requiredClusterDepth = requiredClusterDepth
    {{endif}}
    {{if 'cudaFuncAttributes.clusterSchedulingPolicyPreference' in found_struct}}
    @property
    def clusterSchedulingPolicyPreference(self):
        return self._pvt_ptr[0].clusterSchedulingPolicyPreference
    @clusterSchedulingPolicyPreference.setter
    def clusterSchedulingPolicyPreference(self, int clusterSchedulingPolicyPreference):
        self._pvt_ptr[0].clusterSchedulingPolicyPreference = clusterSchedulingPolicyPreference
    {{endif}}
    {{if 'cudaFuncAttributes.nonPortableClusterSizeAllowed' in found_struct}}
    @property
    def nonPortableClusterSizeAllowed(self):
        return self._pvt_ptr[0].nonPortableClusterSizeAllowed
    @nonPortableClusterSizeAllowed.setter
    def nonPortableClusterSizeAllowed(self, int nonPortableClusterSizeAllowed):
        self._pvt_ptr[0].nonPortableClusterSizeAllowed = nonPortableClusterSizeAllowed
    {{endif}}
    {{if 'cudaFuncAttributes.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaMemLocation' in found_struct}}

cdef class cudaMemLocation:
    """
    Specifies a memory location.  To specify a gpu, set type =
    cudaMemLocationTypeDevice and set id = the gpu's device ordinal. To
    specify a cpu NUMA node, set type = cudaMemLocationTypeHostNuma and
    set id = host NUMA node id.

    Attributes
    ----------
    {{if 'cudaMemLocation.type' in found_struct}}
    type : cudaMemLocationType
        Specifies the location type, which modifies the meaning of id.
    {{endif}}
    {{if 'cudaMemLocation.id' in found_struct}}
    id : int
        identifier for a given this location's ::CUmemLocationType.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaMemLocation *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemLocation.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'cudaMemLocation.id' in found_struct}}
            try:
                str_list += ['id : ' + str(self.id)]
            except ValueError:
                str_list += ['id : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemLocation.type' in found_struct}}
    @property
    def type(self):
        return cudaMemLocationType(self._pvt_ptr[0].type)
    @type.setter
    def type(self, type not None : cudaMemLocationType):
        self._pvt_ptr[0].type = int(type)
    {{endif}}
    {{if 'cudaMemLocation.id' in found_struct}}
    @property
    def id(self):
        return self._pvt_ptr[0].id
    @id.setter
    def id(self, int id):
        self._pvt_ptr[0].id = id
    {{endif}}
{{endif}}
{{if 'cudaMemAccessDesc' in found_struct}}

cdef class cudaMemAccessDesc:
    """
    Memory access descriptor

    Attributes
    ----------
    {{if 'cudaMemAccessDesc.location' in found_struct}}
    location : cudaMemLocation
        Location on which the request is to change it's accessibility
    {{endif}}
    {{if 'cudaMemAccessDesc.flags' in found_struct}}
    flags : cudaMemAccessFlags
        ::CUmemProt accessibility flags to set on the request
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaMemAccessDesc *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaMemAccessDesc.location' in found_struct}}
        self._location = cudaMemLocation(_ptr=<void_ptr>&self._pvt_ptr[0].location)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemAccessDesc.location' in found_struct}}
            try:
                str_list += ['location :\n' + '\n'.join(['    ' + line for line in str(self.location).splitlines()])]
            except ValueError:
                str_list += ['location : <ValueError>']
            {{endif}}
            {{if 'cudaMemAccessDesc.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemAccessDesc.location' in found_struct}}
    @property
    def location(self):
        return self._location
    @location.setter
    def location(self, location not None : cudaMemLocation):
        string.memcpy(&self._pvt_ptr[0].location, <cyruntime.cudaMemLocation*><void_ptr>location.getPtr(), sizeof(self._pvt_ptr[0].location))
    {{endif}}
    {{if 'cudaMemAccessDesc.flags' in found_struct}}
    @property
    def flags(self):
        return cudaMemAccessFlags(self._pvt_ptr[0].flags)
    @flags.setter
    def flags(self, flags not None : cudaMemAccessFlags):
        self._pvt_ptr[0].flags = int(flags)
    {{endif}}
{{endif}}
{{if 'cudaMemPoolProps' in found_struct}}

cdef class cudaMemPoolProps:
    """
    Specifies the properties of allocations made from the pool.

    Attributes
    ----------
    {{if 'cudaMemPoolProps.allocType' in found_struct}}
    allocType : cudaMemAllocationType
        Allocation type. Currently must be specified as
        cudaMemAllocationTypePinned
    {{endif}}
    {{if 'cudaMemPoolProps.handleTypes' in found_struct}}
    handleTypes : cudaMemAllocationHandleType
        Handle types that will be supported by allocations from the pool.
    {{endif}}
    {{if 'cudaMemPoolProps.location' in found_struct}}
    location : cudaMemLocation
        Location allocations should reside.
    {{endif}}
    {{if 'cudaMemPoolProps.win32SecurityAttributes' in found_struct}}
    win32SecurityAttributes : Any
        Windows-specific LPSECURITYATTRIBUTES required when
        cudaMemHandleTypeWin32 is specified. This security attribute
        defines the scope of which exported allocations may be tranferred
        to other processes. In all other cases, this field is required to
        be zero.
    {{endif}}
    {{if 'cudaMemPoolProps.maxSize' in found_struct}}
    maxSize : size_t
        Maximum pool size. When set to 0, defaults to a system dependent
        value.
    {{endif}}
    {{if 'cudaMemPoolProps.usage' in found_struct}}
    usage : unsigned short
        Bitmask indicating intended usage for the pool.
    {{endif}}
    {{if 'cudaMemPoolProps.reserved' in found_struct}}
    reserved : bytes
        reserved for future use, must be 0
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaMemPoolProps *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaMemPoolProps.location' in found_struct}}
        self._location = cudaMemLocation(_ptr=<void_ptr>&self._pvt_ptr[0].location)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemPoolProps.allocType' in found_struct}}
            try:
                str_list += ['allocType : ' + str(self.allocType)]
            except ValueError:
                str_list += ['allocType : <ValueError>']
            {{endif}}
            {{if 'cudaMemPoolProps.handleTypes' in found_struct}}
            try:
                str_list += ['handleTypes : ' + str(self.handleTypes)]
            except ValueError:
                str_list += ['handleTypes : <ValueError>']
            {{endif}}
            {{if 'cudaMemPoolProps.location' in found_struct}}
            try:
                str_list += ['location :\n' + '\n'.join(['    ' + line for line in str(self.location).splitlines()])]
            except ValueError:
                str_list += ['location : <ValueError>']
            {{endif}}
            {{if 'cudaMemPoolProps.win32SecurityAttributes' in found_struct}}
            try:
                str_list += ['win32SecurityAttributes : ' + hex(self.win32SecurityAttributes)]
            except ValueError:
                str_list += ['win32SecurityAttributes : <ValueError>']
            {{endif}}
            {{if 'cudaMemPoolProps.maxSize' in found_struct}}
            try:
                str_list += ['maxSize : ' + str(self.maxSize)]
            except ValueError:
                str_list += ['maxSize : <ValueError>']
            {{endif}}
            {{if 'cudaMemPoolProps.usage' in found_struct}}
            try:
                str_list += ['usage : ' + str(self.usage)]
            except ValueError:
                str_list += ['usage : <ValueError>']
            {{endif}}
            {{if 'cudaMemPoolProps.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemPoolProps.allocType' in found_struct}}
    @property
    def allocType(self):
        return cudaMemAllocationType(self._pvt_ptr[0].allocType)
    @allocType.setter
    def allocType(self, allocType not None : cudaMemAllocationType):
        self._pvt_ptr[0].allocType = int(allocType)
    {{endif}}
    {{if 'cudaMemPoolProps.handleTypes' in found_struct}}
    @property
    def handleTypes(self):
        return cudaMemAllocationHandleType(self._pvt_ptr[0].handleTypes)
    @handleTypes.setter
    def handleTypes(self, handleTypes not None : cudaMemAllocationHandleType):
        self._pvt_ptr[0].handleTypes = int(handleTypes)
    {{endif}}
    {{if 'cudaMemPoolProps.location' in found_struct}}
    @property
    def location(self):
        return self._location
    @location.setter
    def location(self, location not None : cudaMemLocation):
        string.memcpy(&self._pvt_ptr[0].location, <cyruntime.cudaMemLocation*><void_ptr>location.getPtr(), sizeof(self._pvt_ptr[0].location))
    {{endif}}
    {{if 'cudaMemPoolProps.win32SecurityAttributes' in found_struct}}
    @property
    def win32SecurityAttributes(self):
        return <void_ptr>self._pvt_ptr[0].win32SecurityAttributes
    @win32SecurityAttributes.setter
    def win32SecurityAttributes(self, win32SecurityAttributes):
        _cwin32SecurityAttributes = _HelperInputVoidPtr(win32SecurityAttributes)
        self._pvt_ptr[0].win32SecurityAttributes = <void*><void_ptr>_cwin32SecurityAttributes.cptr
    {{endif}}
    {{if 'cudaMemPoolProps.maxSize' in found_struct}}
    @property
    def maxSize(self):
        return self._pvt_ptr[0].maxSize
    @maxSize.setter
    def maxSize(self, size_t maxSize):
        self._pvt_ptr[0].maxSize = maxSize
    {{endif}}
    {{if 'cudaMemPoolProps.usage' in found_struct}}
    @property
    def usage(self):
        return self._pvt_ptr[0].usage
    @usage.setter
    def usage(self, unsigned short usage):
        self._pvt_ptr[0].usage = usage
    {{endif}}
    {{if 'cudaMemPoolProps.reserved' in found_struct}}
    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(<char*>self._pvt_ptr[0].reserved, 54)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 54:
            raise ValueError("reserved length must be 54, is " + str(len(reserved)))
        for i, b in enumerate(reserved):
            self._pvt_ptr[0].reserved[i] = b
    {{endif}}
{{endif}}
{{if 'cudaMemPoolPtrExportData' in found_struct}}

cdef class cudaMemPoolPtrExportData:
    """
    Opaque data for exporting a pool allocation

    Attributes
    ----------
    {{if 'cudaMemPoolPtrExportData.reserved' in found_struct}}
    reserved : bytes

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaMemPoolPtrExportData *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemPoolPtrExportData.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemPoolPtrExportData.reserved' in found_struct}}
    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(<char*>self._pvt_ptr[0].reserved, 64)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 64:
            raise ValueError("reserved length must be 64, is " + str(len(reserved)))
        for i, b in enumerate(reserved):
            self._pvt_ptr[0].reserved[i] = b
    {{endif}}
{{endif}}
{{if 'cudaMemAllocNodeParams' in found_struct}}

cdef class cudaMemAllocNodeParams:
    """
    Memory allocation node parameters

    Attributes
    ----------
    {{if 'cudaMemAllocNodeParams.poolProps' in found_struct}}
    poolProps : cudaMemPoolProps
        in: location where the allocation should reside (specified in
        ::location). ::handleTypes must be cudaMemHandleTypeNone. IPC is
        not supported. in: array of memory access descriptors. Used to
        describe peer GPU access
    {{endif}}
    {{if 'cudaMemAllocNodeParams.accessDescs' in found_struct}}
    accessDescs : cudaMemAccessDesc
        in: number of memory access descriptors. Must not exceed the number
        of GPUs.
    {{endif}}
    {{if 'cudaMemAllocNodeParams.accessDescCount' in found_struct}}
    accessDescCount : size_t
        in: Number of `accessDescs`s
    {{endif}}
    {{if 'cudaMemAllocNodeParams.bytesize' in found_struct}}
    bytesize : size_t
        in: size in bytes of the requested allocation
    {{endif}}
    {{if 'cudaMemAllocNodeParams.dptr' in found_struct}}
    dptr : Any
        out: address of the allocation returned by CUDA
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaMemAllocNodeParams *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaMemAllocNodeParams.poolProps' in found_struct}}
        self._poolProps = cudaMemPoolProps(_ptr=<void_ptr>&self._pvt_ptr[0].poolProps)
        {{endif}}
    def __dealloc__(self):
        pass
        {{if 'cudaMemAllocNodeParams.accessDescs' in found_struct}}
        if self._accessDescs is not NULL:
            free(self._accessDescs)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemAllocNodeParams.poolProps' in found_struct}}
            try:
                str_list += ['poolProps :\n' + '\n'.join(['    ' + line for line in str(self.poolProps).splitlines()])]
            except ValueError:
                str_list += ['poolProps : <ValueError>']
            {{endif}}
            {{if 'cudaMemAllocNodeParams.accessDescs' in found_struct}}
            try:
                str_list += ['accessDescs : ' + str(self.accessDescs)]
            except ValueError:
                str_list += ['accessDescs : <ValueError>']
            {{endif}}
            {{if 'cudaMemAllocNodeParams.accessDescCount' in found_struct}}
            try:
                str_list += ['accessDescCount : ' + str(self.accessDescCount)]
            except ValueError:
                str_list += ['accessDescCount : <ValueError>']
            {{endif}}
            {{if 'cudaMemAllocNodeParams.bytesize' in found_struct}}
            try:
                str_list += ['bytesize : ' + str(self.bytesize)]
            except ValueError:
                str_list += ['bytesize : <ValueError>']
            {{endif}}
            {{if 'cudaMemAllocNodeParams.dptr' in found_struct}}
            try:
                str_list += ['dptr : ' + hex(self.dptr)]
            except ValueError:
                str_list += ['dptr : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemAllocNodeParams.poolProps' in found_struct}}
    @property
    def poolProps(self):
        return self._poolProps
    @poolProps.setter
    def poolProps(self, poolProps not None : cudaMemPoolProps):
        string.memcpy(&self._pvt_ptr[0].poolProps, <cyruntime.cudaMemPoolProps*><void_ptr>poolProps.getPtr(), sizeof(self._pvt_ptr[0].poolProps))
    {{endif}}
    {{if 'cudaMemAllocNodeParams.accessDescs' in found_struct}}
    @property
    def accessDescs(self):
        arrs = [<void_ptr>self._pvt_ptr[0].accessDescs + x*sizeof(cyruntime.cudaMemAccessDesc) for x in range(self._accessDescs_length)]
        return [cudaMemAccessDesc(_ptr=arr) for arr in arrs]
    @accessDescs.setter
    def accessDescs(self, val):
        if len(val) == 0:
            free(self._accessDescs)
            self._accessDescs_length = 0
            self._pvt_ptr[0].accessDescs = NULL
        else:
            if self._accessDescs_length != <size_t>len(val):
                free(self._accessDescs)
                self._accessDescs = <cyruntime.cudaMemAccessDesc*> calloc(len(val), sizeof(cyruntime.cudaMemAccessDesc))
                if self._accessDescs is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cyruntime.cudaMemAccessDesc)))
                self._accessDescs_length = <size_t>len(val)
                self._pvt_ptr[0].accessDescs = self._accessDescs
            for idx in range(len(val)):
                string.memcpy(&self._accessDescs[idx], (<cudaMemAccessDesc>val[idx])._pvt_ptr, sizeof(cyruntime.cudaMemAccessDesc))

    {{endif}}
    {{if 'cudaMemAllocNodeParams.accessDescCount' in found_struct}}
    @property
    def accessDescCount(self):
        return self._pvt_ptr[0].accessDescCount
    @accessDescCount.setter
    def accessDescCount(self, size_t accessDescCount):
        self._pvt_ptr[0].accessDescCount = accessDescCount
    {{endif}}
    {{if 'cudaMemAllocNodeParams.bytesize' in found_struct}}
    @property
    def bytesize(self):
        return self._pvt_ptr[0].bytesize
    @bytesize.setter
    def bytesize(self, size_t bytesize):
        self._pvt_ptr[0].bytesize = bytesize
    {{endif}}
    {{if 'cudaMemAllocNodeParams.dptr' in found_struct}}
    @property
    def dptr(self):
        return <void_ptr>self._pvt_ptr[0].dptr
    @dptr.setter
    def dptr(self, dptr):
        _cdptr = _HelperInputVoidPtr(dptr)
        self._pvt_ptr[0].dptr = <void*><void_ptr>_cdptr.cptr
    {{endif}}
{{endif}}
{{if 'cudaMemAllocNodeParamsV2' in found_struct}}

cdef class cudaMemAllocNodeParamsV2:
    """
    Memory allocation node parameters

    Attributes
    ----------
    {{if 'cudaMemAllocNodeParamsV2.poolProps' in found_struct}}
    poolProps : cudaMemPoolProps
        in: location where the allocation should reside (specified in
        ::location). ::handleTypes must be cudaMemHandleTypeNone. IPC is
        not supported. in: array of memory access descriptors. Used to
        describe peer GPU access
    {{endif}}
    {{if 'cudaMemAllocNodeParamsV2.accessDescs' in found_struct}}
    accessDescs : cudaMemAccessDesc
        in: number of memory access descriptors. Must not exceed the number
        of GPUs.
    {{endif}}
    {{if 'cudaMemAllocNodeParamsV2.accessDescCount' in found_struct}}
    accessDescCount : size_t
        in: Number of `accessDescs`s
    {{endif}}
    {{if 'cudaMemAllocNodeParamsV2.bytesize' in found_struct}}
    bytesize : size_t
        in: size in bytes of the requested allocation
    {{endif}}
    {{if 'cudaMemAllocNodeParamsV2.dptr' in found_struct}}
    dptr : Any
        out: address of the allocation returned by CUDA
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaMemAllocNodeParamsV2 *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaMemAllocNodeParamsV2.poolProps' in found_struct}}
        self._poolProps = cudaMemPoolProps(_ptr=<void_ptr>&self._pvt_ptr[0].poolProps)
        {{endif}}
    def __dealloc__(self):
        pass
        {{if 'cudaMemAllocNodeParamsV2.accessDescs' in found_struct}}
        if self._accessDescs is not NULL:
            free(self._accessDescs)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemAllocNodeParamsV2.poolProps' in found_struct}}
            try:
                str_list += ['poolProps :\n' + '\n'.join(['    ' + line for line in str(self.poolProps).splitlines()])]
            except ValueError:
                str_list += ['poolProps : <ValueError>']
            {{endif}}
            {{if 'cudaMemAllocNodeParamsV2.accessDescs' in found_struct}}
            try:
                str_list += ['accessDescs : ' + str(self.accessDescs)]
            except ValueError:
                str_list += ['accessDescs : <ValueError>']
            {{endif}}
            {{if 'cudaMemAllocNodeParamsV2.accessDescCount' in found_struct}}
            try:
                str_list += ['accessDescCount : ' + str(self.accessDescCount)]
            except ValueError:
                str_list += ['accessDescCount : <ValueError>']
            {{endif}}
            {{if 'cudaMemAllocNodeParamsV2.bytesize' in found_struct}}
            try:
                str_list += ['bytesize : ' + str(self.bytesize)]
            except ValueError:
                str_list += ['bytesize : <ValueError>']
            {{endif}}
            {{if 'cudaMemAllocNodeParamsV2.dptr' in found_struct}}
            try:
                str_list += ['dptr : ' + hex(self.dptr)]
            except ValueError:
                str_list += ['dptr : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemAllocNodeParamsV2.poolProps' in found_struct}}
    @property
    def poolProps(self):
        return self._poolProps
    @poolProps.setter
    def poolProps(self, poolProps not None : cudaMemPoolProps):
        string.memcpy(&self._pvt_ptr[0].poolProps, <cyruntime.cudaMemPoolProps*><void_ptr>poolProps.getPtr(), sizeof(self._pvt_ptr[0].poolProps))
    {{endif}}
    {{if 'cudaMemAllocNodeParamsV2.accessDescs' in found_struct}}
    @property
    def accessDescs(self):
        arrs = [<void_ptr>self._pvt_ptr[0].accessDescs + x*sizeof(cyruntime.cudaMemAccessDesc) for x in range(self._accessDescs_length)]
        return [cudaMemAccessDesc(_ptr=arr) for arr in arrs]
    @accessDescs.setter
    def accessDescs(self, val):
        if len(val) == 0:
            free(self._accessDescs)
            self._accessDescs_length = 0
            self._pvt_ptr[0].accessDescs = NULL
        else:
            if self._accessDescs_length != <size_t>len(val):
                free(self._accessDescs)
                self._accessDescs = <cyruntime.cudaMemAccessDesc*> calloc(len(val), sizeof(cyruntime.cudaMemAccessDesc))
                if self._accessDescs is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cyruntime.cudaMemAccessDesc)))
                self._accessDescs_length = <size_t>len(val)
                self._pvt_ptr[0].accessDescs = self._accessDescs
            for idx in range(len(val)):
                string.memcpy(&self._accessDescs[idx], (<cudaMemAccessDesc>val[idx])._pvt_ptr, sizeof(cyruntime.cudaMemAccessDesc))

    {{endif}}
    {{if 'cudaMemAllocNodeParamsV2.accessDescCount' in found_struct}}
    @property
    def accessDescCount(self):
        return self._pvt_ptr[0].accessDescCount
    @accessDescCount.setter
    def accessDescCount(self, size_t accessDescCount):
        self._pvt_ptr[0].accessDescCount = accessDescCount
    {{endif}}
    {{if 'cudaMemAllocNodeParamsV2.bytesize' in found_struct}}
    @property
    def bytesize(self):
        return self._pvt_ptr[0].bytesize
    @bytesize.setter
    def bytesize(self, size_t bytesize):
        self._pvt_ptr[0].bytesize = bytesize
    {{endif}}
    {{if 'cudaMemAllocNodeParamsV2.dptr' in found_struct}}
    @property
    def dptr(self):
        return <void_ptr>self._pvt_ptr[0].dptr
    @dptr.setter
    def dptr(self, dptr):
        _cdptr = _HelperInputVoidPtr(dptr)
        self._pvt_ptr[0].dptr = <void*><void_ptr>_cdptr.cptr
    {{endif}}
{{endif}}
{{if 'cudaMemFreeNodeParams' in found_struct}}

cdef class cudaMemFreeNodeParams:
    """
    Memory free node parameters

    Attributes
    ----------
    {{if 'cudaMemFreeNodeParams.dptr' in found_struct}}
    dptr : Any
        in: the pointer to free
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaMemFreeNodeParams *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemFreeNodeParams.dptr' in found_struct}}
            try:
                str_list += ['dptr : ' + hex(self.dptr)]
            except ValueError:
                str_list += ['dptr : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemFreeNodeParams.dptr' in found_struct}}
    @property
    def dptr(self):
        return <void_ptr>self._pvt_ptr[0].dptr
    @dptr.setter
    def dptr(self, dptr):
        _cdptr = _HelperInputVoidPtr(dptr)
        self._pvt_ptr[0].dptr = <void*><void_ptr>_cdptr.cptr
    {{endif}}
{{endif}}
{{if 'cudaMemcpyAttributes' in found_struct}}

cdef class cudaMemcpyAttributes:
    """
    Attributes specific to copies within a batch. For more details on
    usage see cudaMemcpyBatchAsync.

    Attributes
    ----------
    {{if 'cudaMemcpyAttributes.srcAccessOrder' in found_struct}}
    srcAccessOrder : cudaMemcpySrcAccessOrder
        Source access ordering to be observed for copies with this
        attribute.
    {{endif}}
    {{if 'cudaMemcpyAttributes.srcLocHint' in found_struct}}
    srcLocHint : cudaMemLocation
        Hint location for the source operand. Ignored when the pointers are
        not managed memory or memory allocated outside CUDA.
    {{endif}}
    {{if 'cudaMemcpyAttributes.dstLocHint' in found_struct}}
    dstLocHint : cudaMemLocation
        Hint location for the destination operand. Ignored when the
        pointers are not managed memory or memory allocated outside CUDA.
    {{endif}}
    {{if 'cudaMemcpyAttributes.flags' in found_struct}}
    flags : unsigned int
        Additional flags for copies with this attribute. See
        cudaMemcpyFlags.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaMemcpyAttributes *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaMemcpyAttributes.srcLocHint' in found_struct}}
        self._srcLocHint = cudaMemLocation(_ptr=<void_ptr>&self._pvt_ptr[0].srcLocHint)
        {{endif}}
        {{if 'cudaMemcpyAttributes.dstLocHint' in found_struct}}
        self._dstLocHint = cudaMemLocation(_ptr=<void_ptr>&self._pvt_ptr[0].dstLocHint)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemcpyAttributes.srcAccessOrder' in found_struct}}
            try:
                str_list += ['srcAccessOrder : ' + str(self.srcAccessOrder)]
            except ValueError:
                str_list += ['srcAccessOrder : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpyAttributes.srcLocHint' in found_struct}}
            try:
                str_list += ['srcLocHint :\n' + '\n'.join(['    ' + line for line in str(self.srcLocHint).splitlines()])]
            except ValueError:
                str_list += ['srcLocHint : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpyAttributes.dstLocHint' in found_struct}}
            try:
                str_list += ['dstLocHint :\n' + '\n'.join(['    ' + line for line in str(self.dstLocHint).splitlines()])]
            except ValueError:
                str_list += ['dstLocHint : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpyAttributes.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemcpyAttributes.srcAccessOrder' in found_struct}}
    @property
    def srcAccessOrder(self):
        return cudaMemcpySrcAccessOrder(self._pvt_ptr[0].srcAccessOrder)
    @srcAccessOrder.setter
    def srcAccessOrder(self, srcAccessOrder not None : cudaMemcpySrcAccessOrder):
        self._pvt_ptr[0].srcAccessOrder = int(srcAccessOrder)
    {{endif}}
    {{if 'cudaMemcpyAttributes.srcLocHint' in found_struct}}
    @property
    def srcLocHint(self):
        return self._srcLocHint
    @srcLocHint.setter
    def srcLocHint(self, srcLocHint not None : cudaMemLocation):
        string.memcpy(&self._pvt_ptr[0].srcLocHint, <cyruntime.cudaMemLocation*><void_ptr>srcLocHint.getPtr(), sizeof(self._pvt_ptr[0].srcLocHint))
    {{endif}}
    {{if 'cudaMemcpyAttributes.dstLocHint' in found_struct}}
    @property
    def dstLocHint(self):
        return self._dstLocHint
    @dstLocHint.setter
    def dstLocHint(self, dstLocHint not None : cudaMemLocation):
        string.memcpy(&self._pvt_ptr[0].dstLocHint, <cyruntime.cudaMemLocation*><void_ptr>dstLocHint.getPtr(), sizeof(self._pvt_ptr[0].dstLocHint))
    {{endif}}
    {{if 'cudaMemcpyAttributes.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
{{endif}}
{{if 'cudaOffset3D' in found_struct}}

cdef class cudaOffset3D:
    """
    Struct representing offset into a cudaArray_t in elements

    Attributes
    ----------
    {{if 'cudaOffset3D.x' in found_struct}}
    x : size_t

    {{endif}}
    {{if 'cudaOffset3D.y' in found_struct}}
    y : size_t

    {{endif}}
    {{if 'cudaOffset3D.z' in found_struct}}
    z : size_t

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaOffset3D *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaOffset3D.x' in found_struct}}
            try:
                str_list += ['x : ' + str(self.x)]
            except ValueError:
                str_list += ['x : <ValueError>']
            {{endif}}
            {{if 'cudaOffset3D.y' in found_struct}}
            try:
                str_list += ['y : ' + str(self.y)]
            except ValueError:
                str_list += ['y : <ValueError>']
            {{endif}}
            {{if 'cudaOffset3D.z' in found_struct}}
            try:
                str_list += ['z : ' + str(self.z)]
            except ValueError:
                str_list += ['z : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaOffset3D.x' in found_struct}}
    @property
    def x(self):
        return self._pvt_ptr[0].x
    @x.setter
    def x(self, size_t x):
        self._pvt_ptr[0].x = x
    {{endif}}
    {{if 'cudaOffset3D.y' in found_struct}}
    @property
    def y(self):
        return self._pvt_ptr[0].y
    @y.setter
    def y(self, size_t y):
        self._pvt_ptr[0].y = y
    {{endif}}
    {{if 'cudaOffset3D.z' in found_struct}}
    @property
    def z(self):
        return self._pvt_ptr[0].z
    @z.setter
    def z(self, size_t z):
        self._pvt_ptr[0].z = z
    {{endif}}
{{endif}}
{{if 'cudaMemcpy3DOperand.op.ptr' in found_struct}}

cdef class anon_struct6:
    """
    Attributes
    ----------
    {{if 'cudaMemcpy3DOperand.op.ptr.ptr' in found_struct}}
    ptr : Any

    {{endif}}
    {{if 'cudaMemcpy3DOperand.op.ptr.rowLength' in found_struct}}
    rowLength : size_t

    {{endif}}
    {{if 'cudaMemcpy3DOperand.op.ptr.layerHeight' in found_struct}}
    layerHeight : size_t

    {{endif}}
    {{if 'cudaMemcpy3DOperand.op.ptr.locHint' in found_struct}}
    locHint : cudaMemLocation

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaMemcpy3DOperand *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'cudaMemcpy3DOperand.op.ptr.locHint' in found_struct}}
        self._locHint = cudaMemLocation(_ptr=<void_ptr>&self._pvt_ptr[0].op.ptr.locHint)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].op.ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemcpy3DOperand.op.ptr.ptr' in found_struct}}
            try:
                str_list += ['ptr : ' + hex(self.ptr)]
            except ValueError:
                str_list += ['ptr : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DOperand.op.ptr.rowLength' in found_struct}}
            try:
                str_list += ['rowLength : ' + str(self.rowLength)]
            except ValueError:
                str_list += ['rowLength : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DOperand.op.ptr.layerHeight' in found_struct}}
            try:
                str_list += ['layerHeight : ' + str(self.layerHeight)]
            except ValueError:
                str_list += ['layerHeight : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DOperand.op.ptr.locHint' in found_struct}}
            try:
                str_list += ['locHint :\n' + '\n'.join(['    ' + line for line in str(self.locHint).splitlines()])]
            except ValueError:
                str_list += ['locHint : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemcpy3DOperand.op.ptr.ptr' in found_struct}}
    @property
    def ptr(self):
        return <void_ptr>self._pvt_ptr[0].op.ptr.ptr
    @ptr.setter
    def ptr(self, ptr):
        _cptr = _HelperInputVoidPtr(ptr)
        self._pvt_ptr[0].op.ptr.ptr = <void*><void_ptr>_cptr.cptr
    {{endif}}
    {{if 'cudaMemcpy3DOperand.op.ptr.rowLength' in found_struct}}
    @property
    def rowLength(self):
        return self._pvt_ptr[0].op.ptr.rowLength
    @rowLength.setter
    def rowLength(self, size_t rowLength):
        self._pvt_ptr[0].op.ptr.rowLength = rowLength
    {{endif}}
    {{if 'cudaMemcpy3DOperand.op.ptr.layerHeight' in found_struct}}
    @property
    def layerHeight(self):
        return self._pvt_ptr[0].op.ptr.layerHeight
    @layerHeight.setter
    def layerHeight(self, size_t layerHeight):
        self._pvt_ptr[0].op.ptr.layerHeight = layerHeight
    {{endif}}
    {{if 'cudaMemcpy3DOperand.op.ptr.locHint' in found_struct}}
    @property
    def locHint(self):
        return self._locHint
    @locHint.setter
    def locHint(self, locHint not None : cudaMemLocation):
        string.memcpy(&self._pvt_ptr[0].op.ptr.locHint, <cyruntime.cudaMemLocation*><void_ptr>locHint.getPtr(), sizeof(self._pvt_ptr[0].op.ptr.locHint))
    {{endif}}
{{endif}}
{{if 'cudaMemcpy3DOperand.op.array' in found_struct}}

cdef class anon_struct7:
    """
    Attributes
    ----------
    {{if 'cudaMemcpy3DOperand.op.array.array' in found_struct}}
    array : cudaArray_t

    {{endif}}
    {{if 'cudaMemcpy3DOperand.op.array.offset' in found_struct}}
    offset : cudaOffset3D

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaMemcpy3DOperand *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'cudaMemcpy3DOperand.op.array.array' in found_struct}}
        self._array = cudaArray_t(_ptr=<void_ptr>&self._pvt_ptr[0].op.array.array)
        {{endif}}
        {{if 'cudaMemcpy3DOperand.op.array.offset' in found_struct}}
        self._offset = cudaOffset3D(_ptr=<void_ptr>&self._pvt_ptr[0].op.array.offset)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].op.array
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemcpy3DOperand.op.array.array' in found_struct}}
            try:
                str_list += ['array : ' + str(self.array)]
            except ValueError:
                str_list += ['array : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DOperand.op.array.offset' in found_struct}}
            try:
                str_list += ['offset :\n' + '\n'.join(['    ' + line for line in str(self.offset).splitlines()])]
            except ValueError:
                str_list += ['offset : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemcpy3DOperand.op.array.array' in found_struct}}
    @property
    def array(self):
        return self._array
    @array.setter
    def array(self, array):
        cdef cyruntime.cudaArray_t cyarray
        if array is None:
            cyarray = <cyruntime.cudaArray_t><void_ptr>0
        elif isinstance(array, (cudaArray_t,)):
            parray = int(array)
            cyarray = <cyruntime.cudaArray_t><void_ptr>parray
        else:
            parray = int(cudaArray_t(array))
            cyarray = <cyruntime.cudaArray_t><void_ptr>parray
        self._array._pvt_ptr[0] = cyarray
    {{endif}}
    {{if 'cudaMemcpy3DOperand.op.array.offset' in found_struct}}
    @property
    def offset(self):
        return self._offset
    @offset.setter
    def offset(self, offset not None : cudaOffset3D):
        string.memcpy(&self._pvt_ptr[0].op.array.offset, <cyruntime.cudaOffset3D*><void_ptr>offset.getPtr(), sizeof(self._pvt_ptr[0].op.array.offset))
    {{endif}}
{{endif}}
{{if 'cudaMemcpy3DOperand.op' in found_struct}}

cdef class anon_union1:
    """
    Attributes
    ----------
    {{if 'cudaMemcpy3DOperand.op.ptr' in found_struct}}
    ptr : anon_struct6

    {{endif}}
    {{if 'cudaMemcpy3DOperand.op.array' in found_struct}}
    array : anon_struct7

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaMemcpy3DOperand *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'cudaMemcpy3DOperand.op.ptr' in found_struct}}
        self._ptr = anon_struct6(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'cudaMemcpy3DOperand.op.array' in found_struct}}
        self._array = anon_struct7(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].op
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemcpy3DOperand.op.ptr' in found_struct}}
            try:
                str_list += ['ptr :\n' + '\n'.join(['    ' + line for line in str(self.ptr).splitlines()])]
            except ValueError:
                str_list += ['ptr : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DOperand.op.array' in found_struct}}
            try:
                str_list += ['array :\n' + '\n'.join(['    ' + line for line in str(self.array).splitlines()])]
            except ValueError:
                str_list += ['array : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemcpy3DOperand.op.ptr' in found_struct}}
    @property
    def ptr(self):
        return self._ptr
    @ptr.setter
    def ptr(self, ptr not None : anon_struct6):
        string.memcpy(&self._pvt_ptr[0].op.ptr, <cyruntime.anon_struct6*><void_ptr>ptr.getPtr(), sizeof(self._pvt_ptr[0].op.ptr))
    {{endif}}
    {{if 'cudaMemcpy3DOperand.op.array' in found_struct}}
    @property
    def array(self):
        return self._array
    @array.setter
    def array(self, array not None : anon_struct7):
        string.memcpy(&self._pvt_ptr[0].op.array, <cyruntime.anon_struct7*><void_ptr>array.getPtr(), sizeof(self._pvt_ptr[0].op.array))
    {{endif}}
{{endif}}
{{if 'cudaMemcpy3DOperand' in found_struct}}

cdef class cudaMemcpy3DOperand:
    """
    Struct representing an operand for copy with cudaMemcpy3DBatchAsync

    Attributes
    ----------
    {{if 'cudaMemcpy3DOperand.type' in found_struct}}
    type : cudaMemcpy3DOperandType

    {{endif}}
    {{if 'cudaMemcpy3DOperand.op' in found_struct}}
    op : anon_union1

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cyruntime.cudaMemcpy3DOperand *>calloc(1, sizeof(cyruntime.cudaMemcpy3DOperand))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cyruntime.cudaMemcpy3DOperand *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaMemcpy3DOperand.op' in found_struct}}
        self._op = anon_union1(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemcpy3DOperand.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DOperand.op' in found_struct}}
            try:
                str_list += ['op :\n' + '\n'.join(['    ' + line for line in str(self.op).splitlines()])]
            except ValueError:
                str_list += ['op : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemcpy3DOperand.type' in found_struct}}
    @property
    def type(self):
        return cudaMemcpy3DOperandType(self._pvt_ptr[0].type)
    @type.setter
    def type(self, type not None : cudaMemcpy3DOperandType):
        self._pvt_ptr[0].type = int(type)
    {{endif}}
    {{if 'cudaMemcpy3DOperand.op' in found_struct}}
    @property
    def op(self):
        return self._op
    @op.setter
    def op(self, op not None : anon_union1):
        string.memcpy(&self._pvt_ptr[0].op, <cyruntime.anon_union1*><void_ptr>op.getPtr(), sizeof(self._pvt_ptr[0].op))
    {{endif}}
{{endif}}
{{if 'cudaMemcpy3DBatchOp' in found_struct}}

cdef class cudaMemcpy3DBatchOp:
    """
    Attributes
    ----------
    {{if 'cudaMemcpy3DBatchOp.src' in found_struct}}
    src : cudaMemcpy3DOperand
        Source memcpy operand.
    {{endif}}
    {{if 'cudaMemcpy3DBatchOp.dst' in found_struct}}
    dst : cudaMemcpy3DOperand
        Destination memcpy operand.
    {{endif}}
    {{if 'cudaMemcpy3DBatchOp.extent' in found_struct}}
    extent : cudaExtent
        Extents of the memcpy between src and dst. The width, height and
        depth components must not be 0.
    {{endif}}
    {{if 'cudaMemcpy3DBatchOp.srcAccessOrder' in found_struct}}
    srcAccessOrder : cudaMemcpySrcAccessOrder
        Source access ordering to be observed for copy from src to dst.
    {{endif}}
    {{if 'cudaMemcpy3DBatchOp.flags' in found_struct}}
    flags : unsigned int
        Additional flags for copy from src to dst. See cudaMemcpyFlags.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaMemcpy3DBatchOp *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaMemcpy3DBatchOp.src' in found_struct}}
        self._src = cudaMemcpy3DOperand(_ptr=<void_ptr>&self._pvt_ptr[0].src)
        {{endif}}
        {{if 'cudaMemcpy3DBatchOp.dst' in found_struct}}
        self._dst = cudaMemcpy3DOperand(_ptr=<void_ptr>&self._pvt_ptr[0].dst)
        {{endif}}
        {{if 'cudaMemcpy3DBatchOp.extent' in found_struct}}
        self._extent = cudaExtent(_ptr=<void_ptr>&self._pvt_ptr[0].extent)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemcpy3DBatchOp.src' in found_struct}}
            try:
                str_list += ['src :\n' + '\n'.join(['    ' + line for line in str(self.src).splitlines()])]
            except ValueError:
                str_list += ['src : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DBatchOp.dst' in found_struct}}
            try:
                str_list += ['dst :\n' + '\n'.join(['    ' + line for line in str(self.dst).splitlines()])]
            except ValueError:
                str_list += ['dst : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DBatchOp.extent' in found_struct}}
            try:
                str_list += ['extent :\n' + '\n'.join(['    ' + line for line in str(self.extent).splitlines()])]
            except ValueError:
                str_list += ['extent : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DBatchOp.srcAccessOrder' in found_struct}}
            try:
                str_list += ['srcAccessOrder : ' + str(self.srcAccessOrder)]
            except ValueError:
                str_list += ['srcAccessOrder : <ValueError>']
            {{endif}}
            {{if 'cudaMemcpy3DBatchOp.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemcpy3DBatchOp.src' in found_struct}}
    @property
    def src(self):
        return self._src
    @src.setter
    def src(self, src not None : cudaMemcpy3DOperand):
        string.memcpy(&self._pvt_ptr[0].src, <cyruntime.cudaMemcpy3DOperand*><void_ptr>src.getPtr(), sizeof(self._pvt_ptr[0].src))
    {{endif}}
    {{if 'cudaMemcpy3DBatchOp.dst' in found_struct}}
    @property
    def dst(self):
        return self._dst
    @dst.setter
    def dst(self, dst not None : cudaMemcpy3DOperand):
        string.memcpy(&self._pvt_ptr[0].dst, <cyruntime.cudaMemcpy3DOperand*><void_ptr>dst.getPtr(), sizeof(self._pvt_ptr[0].dst))
    {{endif}}
    {{if 'cudaMemcpy3DBatchOp.extent' in found_struct}}
    @property
    def extent(self):
        return self._extent
    @extent.setter
    def extent(self, extent not None : cudaExtent):
        string.memcpy(&self._pvt_ptr[0].extent, <cyruntime.cudaExtent*><void_ptr>extent.getPtr(), sizeof(self._pvt_ptr[0].extent))
    {{endif}}
    {{if 'cudaMemcpy3DBatchOp.srcAccessOrder' in found_struct}}
    @property
    def srcAccessOrder(self):
        return cudaMemcpySrcAccessOrder(self._pvt_ptr[0].srcAccessOrder)
    @srcAccessOrder.setter
    def srcAccessOrder(self, srcAccessOrder not None : cudaMemcpySrcAccessOrder):
        self._pvt_ptr[0].srcAccessOrder = int(srcAccessOrder)
    {{endif}}
    {{if 'cudaMemcpy3DBatchOp.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
{{endif}}
{{if 'CUuuid_st' in found_struct}}

cdef class CUuuid_st:
    """
    Attributes
    ----------
    {{if 'CUuuid_st.bytes' in found_struct}}
    bytes : bytes
        < CUDA definition of UUID
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.CUuuid_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'CUuuid_st.bytes' in found_struct}}
            try:
                str_list += ['bytes : ' + str(self.bytes.hex())]
            except ValueError:
                str_list += ['bytes : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'CUuuid_st.bytes' in found_struct}}
    @property
    def bytes(self):
        return PyBytes_FromStringAndSize(self._pvt_ptr[0].bytes, 16)
    {{endif}}
{{endif}}
{{if 'cudaDeviceProp' in found_struct}}

cdef class cudaDeviceProp:
    """
    CUDA device properties

    Attributes
    ----------
    {{if 'cudaDeviceProp.name' in found_struct}}
    name : bytes
        ASCII string identifying device
    {{endif}}
    {{if 'cudaDeviceProp.uuid' in found_struct}}
    uuid : cudaUUID_t
        16-byte unique identifier
    {{endif}}
    {{if 'cudaDeviceProp.luid' in found_struct}}
    luid : bytes
        8-byte locally unique identifier. Value is undefined on TCC and
        non-Windows platforms
    {{endif}}
    {{if 'cudaDeviceProp.luidDeviceNodeMask' in found_struct}}
    luidDeviceNodeMask : unsigned int
        LUID device node mask. Value is undefined on TCC and non-Windows
        platforms
    {{endif}}
    {{if 'cudaDeviceProp.totalGlobalMem' in found_struct}}
    totalGlobalMem : size_t
        Global memory available on device in bytes
    {{endif}}
    {{if 'cudaDeviceProp.sharedMemPerBlock' in found_struct}}
    sharedMemPerBlock : size_t
        Shared memory available per block in bytes
    {{endif}}
    {{if 'cudaDeviceProp.regsPerBlock' in found_struct}}
    regsPerBlock : int
        32-bit registers available per block
    {{endif}}
    {{if 'cudaDeviceProp.warpSize' in found_struct}}
    warpSize : int
        Warp size in threads
    {{endif}}
    {{if 'cudaDeviceProp.memPitch' in found_struct}}
    memPitch : size_t
        Maximum pitch in bytes allowed by memory copies
    {{endif}}
    {{if 'cudaDeviceProp.maxThreadsPerBlock' in found_struct}}
    maxThreadsPerBlock : int
        Maximum number of threads per block
    {{endif}}
    {{if 'cudaDeviceProp.maxThreadsDim' in found_struct}}
    maxThreadsDim : list[int]
        Maximum size of each dimension of a block
    {{endif}}
    {{if 'cudaDeviceProp.maxGridSize' in found_struct}}
    maxGridSize : list[int]
        Maximum size of each dimension of a grid
    {{endif}}
    {{if 'cudaDeviceProp.totalConstMem' in found_struct}}
    totalConstMem : size_t
        Constant memory available on device in bytes
    {{endif}}
    {{if 'cudaDeviceProp.major' in found_struct}}
    major : int
        Major compute capability
    {{endif}}
    {{if 'cudaDeviceProp.minor' in found_struct}}
    minor : int
        Minor compute capability
    {{endif}}
    {{if 'cudaDeviceProp.textureAlignment' in found_struct}}
    textureAlignment : size_t
        Alignment requirement for textures
    {{endif}}
    {{if 'cudaDeviceProp.texturePitchAlignment' in found_struct}}
    texturePitchAlignment : size_t
        Pitch alignment requirement for texture references bound to pitched
        memory
    {{endif}}
    {{if 'cudaDeviceProp.multiProcessorCount' in found_struct}}
    multiProcessorCount : int
        Number of multiprocessors on device
    {{endif}}
    {{if 'cudaDeviceProp.integrated' in found_struct}}
    integrated : int
        Device is integrated as opposed to discrete
    {{endif}}
    {{if 'cudaDeviceProp.canMapHostMemory' in found_struct}}
    canMapHostMemory : int
        Device can map host memory with
        cudaHostAlloc/cudaHostGetDevicePointer
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture1D' in found_struct}}
    maxTexture1D : int
        Maximum 1D texture size
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture1DMipmap' in found_struct}}
    maxTexture1DMipmap : int
        Maximum 1D mipmapped texture size
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture2D' in found_struct}}
    maxTexture2D : list[int]
        Maximum 2D texture dimensions
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture2DMipmap' in found_struct}}
    maxTexture2DMipmap : list[int]
        Maximum 2D mipmapped texture dimensions
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture2DLinear' in found_struct}}
    maxTexture2DLinear : list[int]
        Maximum dimensions (width, height, pitch) for 2D textures bound to
        pitched memory
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture2DGather' in found_struct}}
    maxTexture2DGather : list[int]
        Maximum 2D texture dimensions if texture gather operations have to
        be performed
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture3D' in found_struct}}
    maxTexture3D : list[int]
        Maximum 3D texture dimensions
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture3DAlt' in found_struct}}
    maxTexture3DAlt : list[int]
        Maximum alternate 3D texture dimensions
    {{endif}}
    {{if 'cudaDeviceProp.maxTextureCubemap' in found_struct}}
    maxTextureCubemap : int
        Maximum Cubemap texture dimensions
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture1DLayered' in found_struct}}
    maxTexture1DLayered : list[int]
        Maximum 1D layered texture dimensions
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture2DLayered' in found_struct}}
    maxTexture2DLayered : list[int]
        Maximum 2D layered texture dimensions
    {{endif}}
    {{if 'cudaDeviceProp.maxTextureCubemapLayered' in found_struct}}
    maxTextureCubemapLayered : list[int]
        Maximum Cubemap layered texture dimensions
    {{endif}}
    {{if 'cudaDeviceProp.maxSurface1D' in found_struct}}
    maxSurface1D : int
        Maximum 1D surface size
    {{endif}}
    {{if 'cudaDeviceProp.maxSurface2D' in found_struct}}
    maxSurface2D : list[int]
        Maximum 2D surface dimensions
    {{endif}}
    {{if 'cudaDeviceProp.maxSurface3D' in found_struct}}
    maxSurface3D : list[int]
        Maximum 3D surface dimensions
    {{endif}}
    {{if 'cudaDeviceProp.maxSurface1DLayered' in found_struct}}
    maxSurface1DLayered : list[int]
        Maximum 1D layered surface dimensions
    {{endif}}
    {{if 'cudaDeviceProp.maxSurface2DLayered' in found_struct}}
    maxSurface2DLayered : list[int]
        Maximum 2D layered surface dimensions
    {{endif}}
    {{if 'cudaDeviceProp.maxSurfaceCubemap' in found_struct}}
    maxSurfaceCubemap : int
        Maximum Cubemap surface dimensions
    {{endif}}
    {{if 'cudaDeviceProp.maxSurfaceCubemapLayered' in found_struct}}
    maxSurfaceCubemapLayered : list[int]
        Maximum Cubemap layered surface dimensions
    {{endif}}
    {{if 'cudaDeviceProp.surfaceAlignment' in found_struct}}
    surfaceAlignment : size_t
        Alignment requirements for surfaces
    {{endif}}
    {{if 'cudaDeviceProp.concurrentKernels' in found_struct}}
    concurrentKernels : int
        Device can possibly execute multiple kernels concurrently
    {{endif}}
    {{if 'cudaDeviceProp.ECCEnabled' in found_struct}}
    ECCEnabled : int
        Device has ECC support enabled
    {{endif}}
    {{if 'cudaDeviceProp.pciBusID' in found_struct}}
    pciBusID : int
        PCI bus ID of the device
    {{endif}}
    {{if 'cudaDeviceProp.pciDeviceID' in found_struct}}
    pciDeviceID : int
        PCI device ID of the device
    {{endif}}
    {{if 'cudaDeviceProp.pciDomainID' in found_struct}}
    pciDomainID : int
        PCI domain ID of the device
    {{endif}}
    {{if 'cudaDeviceProp.tccDriver' in found_struct}}
    tccDriver : int
        1 if device is a Tesla device using TCC driver, 0 otherwise
    {{endif}}
    {{if 'cudaDeviceProp.asyncEngineCount' in found_struct}}
    asyncEngineCount : int
        Number of asynchronous engines
    {{endif}}
    {{if 'cudaDeviceProp.unifiedAddressing' in found_struct}}
    unifiedAddressing : int
        Device shares a unified address space with the host
    {{endif}}
    {{if 'cudaDeviceProp.memoryBusWidth' in found_struct}}
    memoryBusWidth : int
        Global memory bus width in bits
    {{endif}}
    {{if 'cudaDeviceProp.l2CacheSize' in found_struct}}
    l2CacheSize : int
        Size of L2 cache in bytes
    {{endif}}
    {{if 'cudaDeviceProp.persistingL2CacheMaxSize' in found_struct}}
    persistingL2CacheMaxSize : int
        Device's maximum l2 persisting lines capacity setting in bytes
    {{endif}}
    {{if 'cudaDeviceProp.maxThreadsPerMultiProcessor' in found_struct}}
    maxThreadsPerMultiProcessor : int
        Maximum resident threads per multiprocessor
    {{endif}}
    {{if 'cudaDeviceProp.streamPrioritiesSupported' in found_struct}}
    streamPrioritiesSupported : int
        Device supports stream priorities
    {{endif}}
    {{if 'cudaDeviceProp.globalL1CacheSupported' in found_struct}}
    globalL1CacheSupported : int
        Device supports caching globals in L1
    {{endif}}
    {{if 'cudaDeviceProp.localL1CacheSupported' in found_struct}}
    localL1CacheSupported : int
        Device supports caching locals in L1
    {{endif}}
    {{if 'cudaDeviceProp.sharedMemPerMultiprocessor' in found_struct}}
    sharedMemPerMultiprocessor : size_t
        Shared memory available per multiprocessor in bytes
    {{endif}}
    {{if 'cudaDeviceProp.regsPerMultiprocessor' in found_struct}}
    regsPerMultiprocessor : int
        32-bit registers available per multiprocessor
    {{endif}}
    {{if 'cudaDeviceProp.managedMemory' in found_struct}}
    managedMemory : int
        Device supports allocating managed memory on this system
    {{endif}}
    {{if 'cudaDeviceProp.isMultiGpuBoard' in found_struct}}
    isMultiGpuBoard : int
        Device is on a multi-GPU board
    {{endif}}
    {{if 'cudaDeviceProp.multiGpuBoardGroupID' in found_struct}}
    multiGpuBoardGroupID : int
        Unique identifier for a group of devices on the same multi-GPU
        board
    {{endif}}
    {{if 'cudaDeviceProp.hostNativeAtomicSupported' in found_struct}}
    hostNativeAtomicSupported : int
        Link between the device and the host supports native atomic
        operations
    {{endif}}
    {{if 'cudaDeviceProp.pageableMemoryAccess' in found_struct}}
    pageableMemoryAccess : int
        Device supports coherently accessing pageable memory without
        calling cudaHostRegister on it
    {{endif}}
    {{if 'cudaDeviceProp.concurrentManagedAccess' in found_struct}}
    concurrentManagedAccess : int
        Device can coherently access managed memory concurrently with the
        CPU
    {{endif}}
    {{if 'cudaDeviceProp.computePreemptionSupported' in found_struct}}
    computePreemptionSupported : int
        Device supports Compute Preemption
    {{endif}}
    {{if 'cudaDeviceProp.canUseHostPointerForRegisteredMem' in found_struct}}
    canUseHostPointerForRegisteredMem : int
        Device can access host registered memory at the same virtual
        address as the CPU
    {{endif}}
    {{if 'cudaDeviceProp.cooperativeLaunch' in found_struct}}
    cooperativeLaunch : int
        Device supports launching cooperative kernels via
        cudaLaunchCooperativeKernel
    {{endif}}
    {{if 'cudaDeviceProp.sharedMemPerBlockOptin' in found_struct}}
    sharedMemPerBlockOptin : size_t
        Per device maximum shared memory per block usable by special opt in
    {{endif}}
    {{if 'cudaDeviceProp.pageableMemoryAccessUsesHostPageTables' in found_struct}}
    pageableMemoryAccessUsesHostPageTables : int
        Device accesses pageable memory via the host's page tables
    {{endif}}
    {{if 'cudaDeviceProp.directManagedMemAccessFromHost' in found_struct}}
    directManagedMemAccessFromHost : int
        Host can directly access managed memory on the device without
        migration.
    {{endif}}
    {{if 'cudaDeviceProp.maxBlocksPerMultiProcessor' in found_struct}}
    maxBlocksPerMultiProcessor : int
        Maximum number of resident blocks per multiprocessor
    {{endif}}
    {{if 'cudaDeviceProp.accessPolicyMaxWindowSize' in found_struct}}
    accessPolicyMaxWindowSize : int
        The maximum value of cudaAccessPolicyWindow::num_bytes.
    {{endif}}
    {{if 'cudaDeviceProp.reservedSharedMemPerBlock' in found_struct}}
    reservedSharedMemPerBlock : size_t
        Shared memory reserved by CUDA driver per block in bytes
    {{endif}}
    {{if 'cudaDeviceProp.hostRegisterSupported' in found_struct}}
    hostRegisterSupported : int
        Device supports host memory registration via cudaHostRegister.
    {{endif}}
    {{if 'cudaDeviceProp.sparseCudaArraySupported' in found_struct}}
    sparseCudaArraySupported : int
        1 if the device supports sparse CUDA arrays and sparse CUDA
        mipmapped arrays, 0 otherwise
    {{endif}}
    {{if 'cudaDeviceProp.hostRegisterReadOnlySupported' in found_struct}}
    hostRegisterReadOnlySupported : int
        Device supports using the cudaHostRegister flag
        cudaHostRegisterReadOnly to register memory that must be mapped as
        read-only to the GPU
    {{endif}}
    {{if 'cudaDeviceProp.timelineSemaphoreInteropSupported' in found_struct}}
    timelineSemaphoreInteropSupported : int
        External timeline semaphore interop is supported on the device
    {{endif}}
    {{if 'cudaDeviceProp.memoryPoolsSupported' in found_struct}}
    memoryPoolsSupported : int
        1 if the device supports using the cudaMallocAsync and cudaMemPool
        family of APIs, 0 otherwise
    {{endif}}
    {{if 'cudaDeviceProp.gpuDirectRDMASupported' in found_struct}}
    gpuDirectRDMASupported : int
        1 if the device supports GPUDirect RDMA APIs, 0 otherwise
    {{endif}}
    {{if 'cudaDeviceProp.gpuDirectRDMAFlushWritesOptions' in found_struct}}
    gpuDirectRDMAFlushWritesOptions : unsigned int
        Bitmask to be interpreted according to the
        cudaFlushGPUDirectRDMAWritesOptions enum
    {{endif}}
    {{if 'cudaDeviceProp.gpuDirectRDMAWritesOrdering' in found_struct}}
    gpuDirectRDMAWritesOrdering : int
        See the cudaGPUDirectRDMAWritesOrdering enum for numerical values
    {{endif}}
    {{if 'cudaDeviceProp.memoryPoolSupportedHandleTypes' in found_struct}}
    memoryPoolSupportedHandleTypes : unsigned int
        Bitmask of handle types supported with mempool-based IPC
    {{endif}}
    {{if 'cudaDeviceProp.deferredMappingCudaArraySupported' in found_struct}}
    deferredMappingCudaArraySupported : int
        1 if the device supports deferred mapping CUDA arrays and CUDA
        mipmapped arrays
    {{endif}}
    {{if 'cudaDeviceProp.ipcEventSupported' in found_struct}}
    ipcEventSupported : int
        Device supports IPC Events.
    {{endif}}
    {{if 'cudaDeviceProp.clusterLaunch' in found_struct}}
    clusterLaunch : int
        Indicates device supports cluster launch
    {{endif}}
    {{if 'cudaDeviceProp.unifiedFunctionPointers' in found_struct}}
    unifiedFunctionPointers : int
        Indicates device supports unified pointers
    {{endif}}
    {{if 'cudaDeviceProp.deviceNumaConfig' in found_struct}}
    deviceNumaConfig : int
        NUMA configuration of a device: value is of type
        cudaDeviceNumaConfig enum
    {{endif}}
    {{if 'cudaDeviceProp.deviceNumaId' in found_struct}}
    deviceNumaId : int
        NUMA node ID of the GPU memory
    {{endif}}
    {{if 'cudaDeviceProp.mpsEnabled' in found_struct}}
    mpsEnabled : int
        Indicates if contexts created on this device will be shared via MPS
    {{endif}}
    {{if 'cudaDeviceProp.hostNumaId' in found_struct}}
    hostNumaId : int
        NUMA ID of the host node closest to the device or -1 when system
        does not support NUMA
    {{endif}}
    {{if 'cudaDeviceProp.gpuPciDeviceID' in found_struct}}
    gpuPciDeviceID : unsigned int
        The combined 16-bit PCI device ID and 16-bit PCI vendor ID
    {{endif}}
    {{if 'cudaDeviceProp.gpuPciSubsystemID' in found_struct}}
    gpuPciSubsystemID : unsigned int
        The combined 16-bit PCI subsystem ID and 16-bit PCI subsystem
        vendor ID
    {{endif}}
    {{if 'cudaDeviceProp.hostNumaMultinodeIpcSupported' in found_struct}}
    hostNumaMultinodeIpcSupported : int
        1 if the device supports HostNuma location IPC between nodes in a
        multi-node system.
    {{endif}}
    {{if 'cudaDeviceProp.reserved' in found_struct}}
    reserved : list[int]
        Reserved for future use
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaDeviceProp *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaDeviceProp.uuid' in found_struct}}
        self._uuid = cudaUUID_t(_ptr=<void_ptr>&self._pvt_ptr[0].uuid)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaDeviceProp.name' in found_struct}}
            try:
                str_list += ['name : ' + self.name.decode('utf-8')]
            except ValueError:
                str_list += ['name : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.uuid' in found_struct}}
            try:
                str_list += ['uuid :\n' + '\n'.join(['    ' + line for line in str(self.uuid).splitlines()])]
            except ValueError:
                str_list += ['uuid : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.luid' in found_struct}}
            try:
                str_list += ['luid : ' + self.luid.hex()]
            except ValueError:
                str_list += ['luid : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.luidDeviceNodeMask' in found_struct}}
            try:
                str_list += ['luidDeviceNodeMask : ' + str(self.luidDeviceNodeMask)]
            except ValueError:
                str_list += ['luidDeviceNodeMask : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.totalGlobalMem' in found_struct}}
            try:
                str_list += ['totalGlobalMem : ' + str(self.totalGlobalMem)]
            except ValueError:
                str_list += ['totalGlobalMem : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.sharedMemPerBlock' in found_struct}}
            try:
                str_list += ['sharedMemPerBlock : ' + str(self.sharedMemPerBlock)]
            except ValueError:
                str_list += ['sharedMemPerBlock : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.regsPerBlock' in found_struct}}
            try:
                str_list += ['regsPerBlock : ' + str(self.regsPerBlock)]
            except ValueError:
                str_list += ['regsPerBlock : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.warpSize' in found_struct}}
            try:
                str_list += ['warpSize : ' + str(self.warpSize)]
            except ValueError:
                str_list += ['warpSize : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.memPitch' in found_struct}}
            try:
                str_list += ['memPitch : ' + str(self.memPitch)]
            except ValueError:
                str_list += ['memPitch : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxThreadsPerBlock' in found_struct}}
            try:
                str_list += ['maxThreadsPerBlock : ' + str(self.maxThreadsPerBlock)]
            except ValueError:
                str_list += ['maxThreadsPerBlock : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxThreadsDim' in found_struct}}
            try:
                str_list += ['maxThreadsDim : ' + str(self.maxThreadsDim)]
            except ValueError:
                str_list += ['maxThreadsDim : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxGridSize' in found_struct}}
            try:
                str_list += ['maxGridSize : ' + str(self.maxGridSize)]
            except ValueError:
                str_list += ['maxGridSize : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.totalConstMem' in found_struct}}
            try:
                str_list += ['totalConstMem : ' + str(self.totalConstMem)]
            except ValueError:
                str_list += ['totalConstMem : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.major' in found_struct}}
            try:
                str_list += ['major : ' + str(self.major)]
            except ValueError:
                str_list += ['major : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.minor' in found_struct}}
            try:
                str_list += ['minor : ' + str(self.minor)]
            except ValueError:
                str_list += ['minor : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.textureAlignment' in found_struct}}
            try:
                str_list += ['textureAlignment : ' + str(self.textureAlignment)]
            except ValueError:
                str_list += ['textureAlignment : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.texturePitchAlignment' in found_struct}}
            try:
                str_list += ['texturePitchAlignment : ' + str(self.texturePitchAlignment)]
            except ValueError:
                str_list += ['texturePitchAlignment : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.multiProcessorCount' in found_struct}}
            try:
                str_list += ['multiProcessorCount : ' + str(self.multiProcessorCount)]
            except ValueError:
                str_list += ['multiProcessorCount : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.integrated' in found_struct}}
            try:
                str_list += ['integrated : ' + str(self.integrated)]
            except ValueError:
                str_list += ['integrated : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.canMapHostMemory' in found_struct}}
            try:
                str_list += ['canMapHostMemory : ' + str(self.canMapHostMemory)]
            except ValueError:
                str_list += ['canMapHostMemory : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxTexture1D' in found_struct}}
            try:
                str_list += ['maxTexture1D : ' + str(self.maxTexture1D)]
            except ValueError:
                str_list += ['maxTexture1D : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxTexture1DMipmap' in found_struct}}
            try:
                str_list += ['maxTexture1DMipmap : ' + str(self.maxTexture1DMipmap)]
            except ValueError:
                str_list += ['maxTexture1DMipmap : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxTexture2D' in found_struct}}
            try:
                str_list += ['maxTexture2D : ' + str(self.maxTexture2D)]
            except ValueError:
                str_list += ['maxTexture2D : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxTexture2DMipmap' in found_struct}}
            try:
                str_list += ['maxTexture2DMipmap : ' + str(self.maxTexture2DMipmap)]
            except ValueError:
                str_list += ['maxTexture2DMipmap : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxTexture2DLinear' in found_struct}}
            try:
                str_list += ['maxTexture2DLinear : ' + str(self.maxTexture2DLinear)]
            except ValueError:
                str_list += ['maxTexture2DLinear : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxTexture2DGather' in found_struct}}
            try:
                str_list += ['maxTexture2DGather : ' + str(self.maxTexture2DGather)]
            except ValueError:
                str_list += ['maxTexture2DGather : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxTexture3D' in found_struct}}
            try:
                str_list += ['maxTexture3D : ' + str(self.maxTexture3D)]
            except ValueError:
                str_list += ['maxTexture3D : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxTexture3DAlt' in found_struct}}
            try:
                str_list += ['maxTexture3DAlt : ' + str(self.maxTexture3DAlt)]
            except ValueError:
                str_list += ['maxTexture3DAlt : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxTextureCubemap' in found_struct}}
            try:
                str_list += ['maxTextureCubemap : ' + str(self.maxTextureCubemap)]
            except ValueError:
                str_list += ['maxTextureCubemap : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxTexture1DLayered' in found_struct}}
            try:
                str_list += ['maxTexture1DLayered : ' + str(self.maxTexture1DLayered)]
            except ValueError:
                str_list += ['maxTexture1DLayered : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxTexture2DLayered' in found_struct}}
            try:
                str_list += ['maxTexture2DLayered : ' + str(self.maxTexture2DLayered)]
            except ValueError:
                str_list += ['maxTexture2DLayered : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxTextureCubemapLayered' in found_struct}}
            try:
                str_list += ['maxTextureCubemapLayered : ' + str(self.maxTextureCubemapLayered)]
            except ValueError:
                str_list += ['maxTextureCubemapLayered : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxSurface1D' in found_struct}}
            try:
                str_list += ['maxSurface1D : ' + str(self.maxSurface1D)]
            except ValueError:
                str_list += ['maxSurface1D : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxSurface2D' in found_struct}}
            try:
                str_list += ['maxSurface2D : ' + str(self.maxSurface2D)]
            except ValueError:
                str_list += ['maxSurface2D : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxSurface3D' in found_struct}}
            try:
                str_list += ['maxSurface3D : ' + str(self.maxSurface3D)]
            except ValueError:
                str_list += ['maxSurface3D : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxSurface1DLayered' in found_struct}}
            try:
                str_list += ['maxSurface1DLayered : ' + str(self.maxSurface1DLayered)]
            except ValueError:
                str_list += ['maxSurface1DLayered : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxSurface2DLayered' in found_struct}}
            try:
                str_list += ['maxSurface2DLayered : ' + str(self.maxSurface2DLayered)]
            except ValueError:
                str_list += ['maxSurface2DLayered : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxSurfaceCubemap' in found_struct}}
            try:
                str_list += ['maxSurfaceCubemap : ' + str(self.maxSurfaceCubemap)]
            except ValueError:
                str_list += ['maxSurfaceCubemap : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxSurfaceCubemapLayered' in found_struct}}
            try:
                str_list += ['maxSurfaceCubemapLayered : ' + str(self.maxSurfaceCubemapLayered)]
            except ValueError:
                str_list += ['maxSurfaceCubemapLayered : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.surfaceAlignment' in found_struct}}
            try:
                str_list += ['surfaceAlignment : ' + str(self.surfaceAlignment)]
            except ValueError:
                str_list += ['surfaceAlignment : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.concurrentKernels' in found_struct}}
            try:
                str_list += ['concurrentKernels : ' + str(self.concurrentKernels)]
            except ValueError:
                str_list += ['concurrentKernels : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.ECCEnabled' in found_struct}}
            try:
                str_list += ['ECCEnabled : ' + str(self.ECCEnabled)]
            except ValueError:
                str_list += ['ECCEnabled : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.pciBusID' in found_struct}}
            try:
                str_list += ['pciBusID : ' + str(self.pciBusID)]
            except ValueError:
                str_list += ['pciBusID : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.pciDeviceID' in found_struct}}
            try:
                str_list += ['pciDeviceID : ' + str(self.pciDeviceID)]
            except ValueError:
                str_list += ['pciDeviceID : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.pciDomainID' in found_struct}}
            try:
                str_list += ['pciDomainID : ' + str(self.pciDomainID)]
            except ValueError:
                str_list += ['pciDomainID : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.tccDriver' in found_struct}}
            try:
                str_list += ['tccDriver : ' + str(self.tccDriver)]
            except ValueError:
                str_list += ['tccDriver : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.asyncEngineCount' in found_struct}}
            try:
                str_list += ['asyncEngineCount : ' + str(self.asyncEngineCount)]
            except ValueError:
                str_list += ['asyncEngineCount : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.unifiedAddressing' in found_struct}}
            try:
                str_list += ['unifiedAddressing : ' + str(self.unifiedAddressing)]
            except ValueError:
                str_list += ['unifiedAddressing : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.memoryBusWidth' in found_struct}}
            try:
                str_list += ['memoryBusWidth : ' + str(self.memoryBusWidth)]
            except ValueError:
                str_list += ['memoryBusWidth : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.l2CacheSize' in found_struct}}
            try:
                str_list += ['l2CacheSize : ' + str(self.l2CacheSize)]
            except ValueError:
                str_list += ['l2CacheSize : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.persistingL2CacheMaxSize' in found_struct}}
            try:
                str_list += ['persistingL2CacheMaxSize : ' + str(self.persistingL2CacheMaxSize)]
            except ValueError:
                str_list += ['persistingL2CacheMaxSize : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxThreadsPerMultiProcessor' in found_struct}}
            try:
                str_list += ['maxThreadsPerMultiProcessor : ' + str(self.maxThreadsPerMultiProcessor)]
            except ValueError:
                str_list += ['maxThreadsPerMultiProcessor : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.streamPrioritiesSupported' in found_struct}}
            try:
                str_list += ['streamPrioritiesSupported : ' + str(self.streamPrioritiesSupported)]
            except ValueError:
                str_list += ['streamPrioritiesSupported : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.globalL1CacheSupported' in found_struct}}
            try:
                str_list += ['globalL1CacheSupported : ' + str(self.globalL1CacheSupported)]
            except ValueError:
                str_list += ['globalL1CacheSupported : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.localL1CacheSupported' in found_struct}}
            try:
                str_list += ['localL1CacheSupported : ' + str(self.localL1CacheSupported)]
            except ValueError:
                str_list += ['localL1CacheSupported : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.sharedMemPerMultiprocessor' in found_struct}}
            try:
                str_list += ['sharedMemPerMultiprocessor : ' + str(self.sharedMemPerMultiprocessor)]
            except ValueError:
                str_list += ['sharedMemPerMultiprocessor : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.regsPerMultiprocessor' in found_struct}}
            try:
                str_list += ['regsPerMultiprocessor : ' + str(self.regsPerMultiprocessor)]
            except ValueError:
                str_list += ['regsPerMultiprocessor : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.managedMemory' in found_struct}}
            try:
                str_list += ['managedMemory : ' + str(self.managedMemory)]
            except ValueError:
                str_list += ['managedMemory : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.isMultiGpuBoard' in found_struct}}
            try:
                str_list += ['isMultiGpuBoard : ' + str(self.isMultiGpuBoard)]
            except ValueError:
                str_list += ['isMultiGpuBoard : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.multiGpuBoardGroupID' in found_struct}}
            try:
                str_list += ['multiGpuBoardGroupID : ' + str(self.multiGpuBoardGroupID)]
            except ValueError:
                str_list += ['multiGpuBoardGroupID : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.hostNativeAtomicSupported' in found_struct}}
            try:
                str_list += ['hostNativeAtomicSupported : ' + str(self.hostNativeAtomicSupported)]
            except ValueError:
                str_list += ['hostNativeAtomicSupported : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.pageableMemoryAccess' in found_struct}}
            try:
                str_list += ['pageableMemoryAccess : ' + str(self.pageableMemoryAccess)]
            except ValueError:
                str_list += ['pageableMemoryAccess : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.concurrentManagedAccess' in found_struct}}
            try:
                str_list += ['concurrentManagedAccess : ' + str(self.concurrentManagedAccess)]
            except ValueError:
                str_list += ['concurrentManagedAccess : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.computePreemptionSupported' in found_struct}}
            try:
                str_list += ['computePreemptionSupported : ' + str(self.computePreemptionSupported)]
            except ValueError:
                str_list += ['computePreemptionSupported : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.canUseHostPointerForRegisteredMem' in found_struct}}
            try:
                str_list += ['canUseHostPointerForRegisteredMem : ' + str(self.canUseHostPointerForRegisteredMem)]
            except ValueError:
                str_list += ['canUseHostPointerForRegisteredMem : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.cooperativeLaunch' in found_struct}}
            try:
                str_list += ['cooperativeLaunch : ' + str(self.cooperativeLaunch)]
            except ValueError:
                str_list += ['cooperativeLaunch : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.sharedMemPerBlockOptin' in found_struct}}
            try:
                str_list += ['sharedMemPerBlockOptin : ' + str(self.sharedMemPerBlockOptin)]
            except ValueError:
                str_list += ['sharedMemPerBlockOptin : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.pageableMemoryAccessUsesHostPageTables' in found_struct}}
            try:
                str_list += ['pageableMemoryAccessUsesHostPageTables : ' + str(self.pageableMemoryAccessUsesHostPageTables)]
            except ValueError:
                str_list += ['pageableMemoryAccessUsesHostPageTables : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.directManagedMemAccessFromHost' in found_struct}}
            try:
                str_list += ['directManagedMemAccessFromHost : ' + str(self.directManagedMemAccessFromHost)]
            except ValueError:
                str_list += ['directManagedMemAccessFromHost : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.maxBlocksPerMultiProcessor' in found_struct}}
            try:
                str_list += ['maxBlocksPerMultiProcessor : ' + str(self.maxBlocksPerMultiProcessor)]
            except ValueError:
                str_list += ['maxBlocksPerMultiProcessor : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.accessPolicyMaxWindowSize' in found_struct}}
            try:
                str_list += ['accessPolicyMaxWindowSize : ' + str(self.accessPolicyMaxWindowSize)]
            except ValueError:
                str_list += ['accessPolicyMaxWindowSize : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.reservedSharedMemPerBlock' in found_struct}}
            try:
                str_list += ['reservedSharedMemPerBlock : ' + str(self.reservedSharedMemPerBlock)]
            except ValueError:
                str_list += ['reservedSharedMemPerBlock : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.hostRegisterSupported' in found_struct}}
            try:
                str_list += ['hostRegisterSupported : ' + str(self.hostRegisterSupported)]
            except ValueError:
                str_list += ['hostRegisterSupported : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.sparseCudaArraySupported' in found_struct}}
            try:
                str_list += ['sparseCudaArraySupported : ' + str(self.sparseCudaArraySupported)]
            except ValueError:
                str_list += ['sparseCudaArraySupported : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.hostRegisterReadOnlySupported' in found_struct}}
            try:
                str_list += ['hostRegisterReadOnlySupported : ' + str(self.hostRegisterReadOnlySupported)]
            except ValueError:
                str_list += ['hostRegisterReadOnlySupported : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.timelineSemaphoreInteropSupported' in found_struct}}
            try:
                str_list += ['timelineSemaphoreInteropSupported : ' + str(self.timelineSemaphoreInteropSupported)]
            except ValueError:
                str_list += ['timelineSemaphoreInteropSupported : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.memoryPoolsSupported' in found_struct}}
            try:
                str_list += ['memoryPoolsSupported : ' + str(self.memoryPoolsSupported)]
            except ValueError:
                str_list += ['memoryPoolsSupported : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.gpuDirectRDMASupported' in found_struct}}
            try:
                str_list += ['gpuDirectRDMASupported : ' + str(self.gpuDirectRDMASupported)]
            except ValueError:
                str_list += ['gpuDirectRDMASupported : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.gpuDirectRDMAFlushWritesOptions' in found_struct}}
            try:
                str_list += ['gpuDirectRDMAFlushWritesOptions : ' + str(self.gpuDirectRDMAFlushWritesOptions)]
            except ValueError:
                str_list += ['gpuDirectRDMAFlushWritesOptions : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.gpuDirectRDMAWritesOrdering' in found_struct}}
            try:
                str_list += ['gpuDirectRDMAWritesOrdering : ' + str(self.gpuDirectRDMAWritesOrdering)]
            except ValueError:
                str_list += ['gpuDirectRDMAWritesOrdering : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.memoryPoolSupportedHandleTypes' in found_struct}}
            try:
                str_list += ['memoryPoolSupportedHandleTypes : ' + str(self.memoryPoolSupportedHandleTypes)]
            except ValueError:
                str_list += ['memoryPoolSupportedHandleTypes : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.deferredMappingCudaArraySupported' in found_struct}}
            try:
                str_list += ['deferredMappingCudaArraySupported : ' + str(self.deferredMappingCudaArraySupported)]
            except ValueError:
                str_list += ['deferredMappingCudaArraySupported : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.ipcEventSupported' in found_struct}}
            try:
                str_list += ['ipcEventSupported : ' + str(self.ipcEventSupported)]
            except ValueError:
                str_list += ['ipcEventSupported : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.clusterLaunch' in found_struct}}
            try:
                str_list += ['clusterLaunch : ' + str(self.clusterLaunch)]
            except ValueError:
                str_list += ['clusterLaunch : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.unifiedFunctionPointers' in found_struct}}
            try:
                str_list += ['unifiedFunctionPointers : ' + str(self.unifiedFunctionPointers)]
            except ValueError:
                str_list += ['unifiedFunctionPointers : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.deviceNumaConfig' in found_struct}}
            try:
                str_list += ['deviceNumaConfig : ' + str(self.deviceNumaConfig)]
            except ValueError:
                str_list += ['deviceNumaConfig : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.deviceNumaId' in found_struct}}
            try:
                str_list += ['deviceNumaId : ' + str(self.deviceNumaId)]
            except ValueError:
                str_list += ['deviceNumaId : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.mpsEnabled' in found_struct}}
            try:
                str_list += ['mpsEnabled : ' + str(self.mpsEnabled)]
            except ValueError:
                str_list += ['mpsEnabled : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.hostNumaId' in found_struct}}
            try:
                str_list += ['hostNumaId : ' + str(self.hostNumaId)]
            except ValueError:
                str_list += ['hostNumaId : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.gpuPciDeviceID' in found_struct}}
            try:
                str_list += ['gpuPciDeviceID : ' + str(self.gpuPciDeviceID)]
            except ValueError:
                str_list += ['gpuPciDeviceID : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.gpuPciSubsystemID' in found_struct}}
            try:
                str_list += ['gpuPciSubsystemID : ' + str(self.gpuPciSubsystemID)]
            except ValueError:
                str_list += ['gpuPciSubsystemID : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.hostNumaMultinodeIpcSupported' in found_struct}}
            try:
                str_list += ['hostNumaMultinodeIpcSupported : ' + str(self.hostNumaMultinodeIpcSupported)]
            except ValueError:
                str_list += ['hostNumaMultinodeIpcSupported : <ValueError>']
            {{endif}}
            {{if 'cudaDeviceProp.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaDeviceProp.name' in found_struct}}
    @property
    def name(self):
        return self._pvt_ptr[0].name
    @name.setter
    def name(self, name):
        pass
        self._pvt_ptr[0].name = name
    {{endif}}
    {{if 'cudaDeviceProp.uuid' in found_struct}}
    @property
    def uuid(self):
        return self._uuid
    @uuid.setter
    def uuid(self, uuid not None : cudaUUID_t):
        string.memcpy(&self._pvt_ptr[0].uuid, <cyruntime.cudaUUID_t*><void_ptr>uuid.getPtr(), sizeof(self._pvt_ptr[0].uuid))
    {{endif}}
    {{if 'cudaDeviceProp.luid' in found_struct}}
    @property
    def luid(self):
        return PyBytes_FromStringAndSize(self._pvt_ptr[0].luid, 8)
    @luid.setter
    def luid(self, luid):
        if len(luid) != 8:
            raise ValueError("luid length must be 8, is " + str(len(luid)))
        if CHAR_MIN == 0:
            for i, b in enumerate(luid):
                if b < 0 and b > -129:
                    b = b + 256
                self._pvt_ptr[0].luid[i] = b
        else:
            for i, b in enumerate(luid):
                if b > 127 and b < 256:
                    b = b - 256
                self._pvt_ptr[0].luid[i] = b
    {{endif}}
    {{if 'cudaDeviceProp.luidDeviceNodeMask' in found_struct}}
    @property
    def luidDeviceNodeMask(self):
        return self._pvt_ptr[0].luidDeviceNodeMask
    @luidDeviceNodeMask.setter
    def luidDeviceNodeMask(self, unsigned int luidDeviceNodeMask):
        self._pvt_ptr[0].luidDeviceNodeMask = luidDeviceNodeMask
    {{endif}}
    {{if 'cudaDeviceProp.totalGlobalMem' in found_struct}}
    @property
    def totalGlobalMem(self):
        return self._pvt_ptr[0].totalGlobalMem
    @totalGlobalMem.setter
    def totalGlobalMem(self, size_t totalGlobalMem):
        self._pvt_ptr[0].totalGlobalMem = totalGlobalMem
    {{endif}}
    {{if 'cudaDeviceProp.sharedMemPerBlock' in found_struct}}
    @property
    def sharedMemPerBlock(self):
        return self._pvt_ptr[0].sharedMemPerBlock
    @sharedMemPerBlock.setter
    def sharedMemPerBlock(self, size_t sharedMemPerBlock):
        self._pvt_ptr[0].sharedMemPerBlock = sharedMemPerBlock
    {{endif}}
    {{if 'cudaDeviceProp.regsPerBlock' in found_struct}}
    @property
    def regsPerBlock(self):
        return self._pvt_ptr[0].regsPerBlock
    @regsPerBlock.setter
    def regsPerBlock(self, int regsPerBlock):
        self._pvt_ptr[0].regsPerBlock = regsPerBlock
    {{endif}}
    {{if 'cudaDeviceProp.warpSize' in found_struct}}
    @property
    def warpSize(self):
        return self._pvt_ptr[0].warpSize
    @warpSize.setter
    def warpSize(self, int warpSize):
        self._pvt_ptr[0].warpSize = warpSize
    {{endif}}
    {{if 'cudaDeviceProp.memPitch' in found_struct}}
    @property
    def memPitch(self):
        return self._pvt_ptr[0].memPitch
    @memPitch.setter
    def memPitch(self, size_t memPitch):
        self._pvt_ptr[0].memPitch = memPitch
    {{endif}}
    {{if 'cudaDeviceProp.maxThreadsPerBlock' in found_struct}}
    @property
    def maxThreadsPerBlock(self):
        return self._pvt_ptr[0].maxThreadsPerBlock
    @maxThreadsPerBlock.setter
    def maxThreadsPerBlock(self, int maxThreadsPerBlock):
        self._pvt_ptr[0].maxThreadsPerBlock = maxThreadsPerBlock
    {{endif}}
    {{if 'cudaDeviceProp.maxThreadsDim' in found_struct}}
    @property
    def maxThreadsDim(self):
        return self._pvt_ptr[0].maxThreadsDim
    @maxThreadsDim.setter
    def maxThreadsDim(self, maxThreadsDim):
        self._pvt_ptr[0].maxThreadsDim = maxThreadsDim
    {{endif}}
    {{if 'cudaDeviceProp.maxGridSize' in found_struct}}
    @property
    def maxGridSize(self):
        return self._pvt_ptr[0].maxGridSize
    @maxGridSize.setter
    def maxGridSize(self, maxGridSize):
        self._pvt_ptr[0].maxGridSize = maxGridSize
    {{endif}}
    {{if 'cudaDeviceProp.totalConstMem' in found_struct}}
    @property
    def totalConstMem(self):
        return self._pvt_ptr[0].totalConstMem
    @totalConstMem.setter
    def totalConstMem(self, size_t totalConstMem):
        self._pvt_ptr[0].totalConstMem = totalConstMem
    {{endif}}
    {{if 'cudaDeviceProp.major' in found_struct}}
    @property
    def major(self):
        return self._pvt_ptr[0].major
    @major.setter
    def major(self, int major):
        self._pvt_ptr[0].major = major
    {{endif}}
    {{if 'cudaDeviceProp.minor' in found_struct}}
    @property
    def minor(self):
        return self._pvt_ptr[0].minor
    @minor.setter
    def minor(self, int minor):
        self._pvt_ptr[0].minor = minor
    {{endif}}
    {{if 'cudaDeviceProp.textureAlignment' in found_struct}}
    @property
    def textureAlignment(self):
        return self._pvt_ptr[0].textureAlignment
    @textureAlignment.setter
    def textureAlignment(self, size_t textureAlignment):
        self._pvt_ptr[0].textureAlignment = textureAlignment
    {{endif}}
    {{if 'cudaDeviceProp.texturePitchAlignment' in found_struct}}
    @property
    def texturePitchAlignment(self):
        return self._pvt_ptr[0].texturePitchAlignment
    @texturePitchAlignment.setter
    def texturePitchAlignment(self, size_t texturePitchAlignment):
        self._pvt_ptr[0].texturePitchAlignment = texturePitchAlignment
    {{endif}}
    {{if 'cudaDeviceProp.multiProcessorCount' in found_struct}}
    @property
    def multiProcessorCount(self):
        return self._pvt_ptr[0].multiProcessorCount
    @multiProcessorCount.setter
    def multiProcessorCount(self, int multiProcessorCount):
        self._pvt_ptr[0].multiProcessorCount = multiProcessorCount
    {{endif}}
    {{if 'cudaDeviceProp.integrated' in found_struct}}
    @property
    def integrated(self):
        return self._pvt_ptr[0].integrated
    @integrated.setter
    def integrated(self, int integrated):
        self._pvt_ptr[0].integrated = integrated
    {{endif}}
    {{if 'cudaDeviceProp.canMapHostMemory' in found_struct}}
    @property
    def canMapHostMemory(self):
        return self._pvt_ptr[0].canMapHostMemory
    @canMapHostMemory.setter
    def canMapHostMemory(self, int canMapHostMemory):
        self._pvt_ptr[0].canMapHostMemory = canMapHostMemory
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture1D' in found_struct}}
    @property
    def maxTexture1D(self):
        return self._pvt_ptr[0].maxTexture1D
    @maxTexture1D.setter
    def maxTexture1D(self, int maxTexture1D):
        self._pvt_ptr[0].maxTexture1D = maxTexture1D
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture1DMipmap' in found_struct}}
    @property
    def maxTexture1DMipmap(self):
        return self._pvt_ptr[0].maxTexture1DMipmap
    @maxTexture1DMipmap.setter
    def maxTexture1DMipmap(self, int maxTexture1DMipmap):
        self._pvt_ptr[0].maxTexture1DMipmap = maxTexture1DMipmap
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture2D' in found_struct}}
    @property
    def maxTexture2D(self):
        return self._pvt_ptr[0].maxTexture2D
    @maxTexture2D.setter
    def maxTexture2D(self, maxTexture2D):
        self._pvt_ptr[0].maxTexture2D = maxTexture2D
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture2DMipmap' in found_struct}}
    @property
    def maxTexture2DMipmap(self):
        return self._pvt_ptr[0].maxTexture2DMipmap
    @maxTexture2DMipmap.setter
    def maxTexture2DMipmap(self, maxTexture2DMipmap):
        self._pvt_ptr[0].maxTexture2DMipmap = maxTexture2DMipmap
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture2DLinear' in found_struct}}
    @property
    def maxTexture2DLinear(self):
        return self._pvt_ptr[0].maxTexture2DLinear
    @maxTexture2DLinear.setter
    def maxTexture2DLinear(self, maxTexture2DLinear):
        self._pvt_ptr[0].maxTexture2DLinear = maxTexture2DLinear
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture2DGather' in found_struct}}
    @property
    def maxTexture2DGather(self):
        return self._pvt_ptr[0].maxTexture2DGather
    @maxTexture2DGather.setter
    def maxTexture2DGather(self, maxTexture2DGather):
        self._pvt_ptr[0].maxTexture2DGather = maxTexture2DGather
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture3D' in found_struct}}
    @property
    def maxTexture3D(self):
        return self._pvt_ptr[0].maxTexture3D
    @maxTexture3D.setter
    def maxTexture3D(self, maxTexture3D):
        self._pvt_ptr[0].maxTexture3D = maxTexture3D
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture3DAlt' in found_struct}}
    @property
    def maxTexture3DAlt(self):
        return self._pvt_ptr[0].maxTexture3DAlt
    @maxTexture3DAlt.setter
    def maxTexture3DAlt(self, maxTexture3DAlt):
        self._pvt_ptr[0].maxTexture3DAlt = maxTexture3DAlt
    {{endif}}
    {{if 'cudaDeviceProp.maxTextureCubemap' in found_struct}}
    @property
    def maxTextureCubemap(self):
        return self._pvt_ptr[0].maxTextureCubemap
    @maxTextureCubemap.setter
    def maxTextureCubemap(self, int maxTextureCubemap):
        self._pvt_ptr[0].maxTextureCubemap = maxTextureCubemap
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture1DLayered' in found_struct}}
    @property
    def maxTexture1DLayered(self):
        return self._pvt_ptr[0].maxTexture1DLayered
    @maxTexture1DLayered.setter
    def maxTexture1DLayered(self, maxTexture1DLayered):
        self._pvt_ptr[0].maxTexture1DLayered = maxTexture1DLayered
    {{endif}}
    {{if 'cudaDeviceProp.maxTexture2DLayered' in found_struct}}
    @property
    def maxTexture2DLayered(self):
        return self._pvt_ptr[0].maxTexture2DLayered
    @maxTexture2DLayered.setter
    def maxTexture2DLayered(self, maxTexture2DLayered):
        self._pvt_ptr[0].maxTexture2DLayered = maxTexture2DLayered
    {{endif}}
    {{if 'cudaDeviceProp.maxTextureCubemapLayered' in found_struct}}
    @property
    def maxTextureCubemapLayered(self):
        return self._pvt_ptr[0].maxTextureCubemapLayered
    @maxTextureCubemapLayered.setter
    def maxTextureCubemapLayered(self, maxTextureCubemapLayered):
        self._pvt_ptr[0].maxTextureCubemapLayered = maxTextureCubemapLayered
    {{endif}}
    {{if 'cudaDeviceProp.maxSurface1D' in found_struct}}
    @property
    def maxSurface1D(self):
        return self._pvt_ptr[0].maxSurface1D
    @maxSurface1D.setter
    def maxSurface1D(self, int maxSurface1D):
        self._pvt_ptr[0].maxSurface1D = maxSurface1D
    {{endif}}
    {{if 'cudaDeviceProp.maxSurface2D' in found_struct}}
    @property
    def maxSurface2D(self):
        return self._pvt_ptr[0].maxSurface2D
    @maxSurface2D.setter
    def maxSurface2D(self, maxSurface2D):
        self._pvt_ptr[0].maxSurface2D = maxSurface2D
    {{endif}}
    {{if 'cudaDeviceProp.maxSurface3D' in found_struct}}
    @property
    def maxSurface3D(self):
        return self._pvt_ptr[0].maxSurface3D
    @maxSurface3D.setter
    def maxSurface3D(self, maxSurface3D):
        self._pvt_ptr[0].maxSurface3D = maxSurface3D
    {{endif}}
    {{if 'cudaDeviceProp.maxSurface1DLayered' in found_struct}}
    @property
    def maxSurface1DLayered(self):
        return self._pvt_ptr[0].maxSurface1DLayered
    @maxSurface1DLayered.setter
    def maxSurface1DLayered(self, maxSurface1DLayered):
        self._pvt_ptr[0].maxSurface1DLayered = maxSurface1DLayered
    {{endif}}
    {{if 'cudaDeviceProp.maxSurface2DLayered' in found_struct}}
    @property
    def maxSurface2DLayered(self):
        return self._pvt_ptr[0].maxSurface2DLayered
    @maxSurface2DLayered.setter
    def maxSurface2DLayered(self, maxSurface2DLayered):
        self._pvt_ptr[0].maxSurface2DLayered = maxSurface2DLayered
    {{endif}}
    {{if 'cudaDeviceProp.maxSurfaceCubemap' in found_struct}}
    @property
    def maxSurfaceCubemap(self):
        return self._pvt_ptr[0].maxSurfaceCubemap
    @maxSurfaceCubemap.setter
    def maxSurfaceCubemap(self, int maxSurfaceCubemap):
        self._pvt_ptr[0].maxSurfaceCubemap = maxSurfaceCubemap
    {{endif}}
    {{if 'cudaDeviceProp.maxSurfaceCubemapLayered' in found_struct}}
    @property
    def maxSurfaceCubemapLayered(self):
        return self._pvt_ptr[0].maxSurfaceCubemapLayered
    @maxSurfaceCubemapLayered.setter
    def maxSurfaceCubemapLayered(self, maxSurfaceCubemapLayered):
        self._pvt_ptr[0].maxSurfaceCubemapLayered = maxSurfaceCubemapLayered
    {{endif}}
    {{if 'cudaDeviceProp.surfaceAlignment' in found_struct}}
    @property
    def surfaceAlignment(self):
        return self._pvt_ptr[0].surfaceAlignment
    @surfaceAlignment.setter
    def surfaceAlignment(self, size_t surfaceAlignment):
        self._pvt_ptr[0].surfaceAlignment = surfaceAlignment
    {{endif}}
    {{if 'cudaDeviceProp.concurrentKernels' in found_struct}}
    @property
    def concurrentKernels(self):
        return self._pvt_ptr[0].concurrentKernels
    @concurrentKernels.setter
    def concurrentKernels(self, int concurrentKernels):
        self._pvt_ptr[0].concurrentKernels = concurrentKernels
    {{endif}}
    {{if 'cudaDeviceProp.ECCEnabled' in found_struct}}
    @property
    def ECCEnabled(self):
        return self._pvt_ptr[0].ECCEnabled
    @ECCEnabled.setter
    def ECCEnabled(self, int ECCEnabled):
        self._pvt_ptr[0].ECCEnabled = ECCEnabled
    {{endif}}
    {{if 'cudaDeviceProp.pciBusID' in found_struct}}
    @property
    def pciBusID(self):
        return self._pvt_ptr[0].pciBusID
    @pciBusID.setter
    def pciBusID(self, int pciBusID):
        self._pvt_ptr[0].pciBusID = pciBusID
    {{endif}}
    {{if 'cudaDeviceProp.pciDeviceID' in found_struct}}
    @property
    def pciDeviceID(self):
        return self._pvt_ptr[0].pciDeviceID
    @pciDeviceID.setter
    def pciDeviceID(self, int pciDeviceID):
        self._pvt_ptr[0].pciDeviceID = pciDeviceID
    {{endif}}
    {{if 'cudaDeviceProp.pciDomainID' in found_struct}}
    @property
    def pciDomainID(self):
        return self._pvt_ptr[0].pciDomainID
    @pciDomainID.setter
    def pciDomainID(self, int pciDomainID):
        self._pvt_ptr[0].pciDomainID = pciDomainID
    {{endif}}
    {{if 'cudaDeviceProp.tccDriver' in found_struct}}
    @property
    def tccDriver(self):
        return self._pvt_ptr[0].tccDriver
    @tccDriver.setter
    def tccDriver(self, int tccDriver):
        self._pvt_ptr[0].tccDriver = tccDriver
    {{endif}}
    {{if 'cudaDeviceProp.asyncEngineCount' in found_struct}}
    @property
    def asyncEngineCount(self):
        return self._pvt_ptr[0].asyncEngineCount
    @asyncEngineCount.setter
    def asyncEngineCount(self, int asyncEngineCount):
        self._pvt_ptr[0].asyncEngineCount = asyncEngineCount
    {{endif}}
    {{if 'cudaDeviceProp.unifiedAddressing' in found_struct}}
    @property
    def unifiedAddressing(self):
        return self._pvt_ptr[0].unifiedAddressing
    @unifiedAddressing.setter
    def unifiedAddressing(self, int unifiedAddressing):
        self._pvt_ptr[0].unifiedAddressing = unifiedAddressing
    {{endif}}
    {{if 'cudaDeviceProp.memoryBusWidth' in found_struct}}
    @property
    def memoryBusWidth(self):
        return self._pvt_ptr[0].memoryBusWidth
    @memoryBusWidth.setter
    def memoryBusWidth(self, int memoryBusWidth):
        self._pvt_ptr[0].memoryBusWidth = memoryBusWidth
    {{endif}}
    {{if 'cudaDeviceProp.l2CacheSize' in found_struct}}
    @property
    def l2CacheSize(self):
        return self._pvt_ptr[0].l2CacheSize
    @l2CacheSize.setter
    def l2CacheSize(self, int l2CacheSize):
        self._pvt_ptr[0].l2CacheSize = l2CacheSize
    {{endif}}
    {{if 'cudaDeviceProp.persistingL2CacheMaxSize' in found_struct}}
    @property
    def persistingL2CacheMaxSize(self):
        return self._pvt_ptr[0].persistingL2CacheMaxSize
    @persistingL2CacheMaxSize.setter
    def persistingL2CacheMaxSize(self, int persistingL2CacheMaxSize):
        self._pvt_ptr[0].persistingL2CacheMaxSize = persistingL2CacheMaxSize
    {{endif}}
    {{if 'cudaDeviceProp.maxThreadsPerMultiProcessor' in found_struct}}
    @property
    def maxThreadsPerMultiProcessor(self):
        return self._pvt_ptr[0].maxThreadsPerMultiProcessor
    @maxThreadsPerMultiProcessor.setter
    def maxThreadsPerMultiProcessor(self, int maxThreadsPerMultiProcessor):
        self._pvt_ptr[0].maxThreadsPerMultiProcessor = maxThreadsPerMultiProcessor
    {{endif}}
    {{if 'cudaDeviceProp.streamPrioritiesSupported' in found_struct}}
    @property
    def streamPrioritiesSupported(self):
        return self._pvt_ptr[0].streamPrioritiesSupported
    @streamPrioritiesSupported.setter
    def streamPrioritiesSupported(self, int streamPrioritiesSupported):
        self._pvt_ptr[0].streamPrioritiesSupported = streamPrioritiesSupported
    {{endif}}
    {{if 'cudaDeviceProp.globalL1CacheSupported' in found_struct}}
    @property
    def globalL1CacheSupported(self):
        return self._pvt_ptr[0].globalL1CacheSupported
    @globalL1CacheSupported.setter
    def globalL1CacheSupported(self, int globalL1CacheSupported):
        self._pvt_ptr[0].globalL1CacheSupported = globalL1CacheSupported
    {{endif}}
    {{if 'cudaDeviceProp.localL1CacheSupported' in found_struct}}
    @property
    def localL1CacheSupported(self):
        return self._pvt_ptr[0].localL1CacheSupported
    @localL1CacheSupported.setter
    def localL1CacheSupported(self, int localL1CacheSupported):
        self._pvt_ptr[0].localL1CacheSupported = localL1CacheSupported
    {{endif}}
    {{if 'cudaDeviceProp.sharedMemPerMultiprocessor' in found_struct}}
    @property
    def sharedMemPerMultiprocessor(self):
        return self._pvt_ptr[0].sharedMemPerMultiprocessor
    @sharedMemPerMultiprocessor.setter
    def sharedMemPerMultiprocessor(self, size_t sharedMemPerMultiprocessor):
        self._pvt_ptr[0].sharedMemPerMultiprocessor = sharedMemPerMultiprocessor
    {{endif}}
    {{if 'cudaDeviceProp.regsPerMultiprocessor' in found_struct}}
    @property
    def regsPerMultiprocessor(self):
        return self._pvt_ptr[0].regsPerMultiprocessor
    @regsPerMultiprocessor.setter
    def regsPerMultiprocessor(self, int regsPerMultiprocessor):
        self._pvt_ptr[0].regsPerMultiprocessor = regsPerMultiprocessor
    {{endif}}
    {{if 'cudaDeviceProp.managedMemory' in found_struct}}
    @property
    def managedMemory(self):
        return self._pvt_ptr[0].managedMemory
    @managedMemory.setter
    def managedMemory(self, int managedMemory):
        self._pvt_ptr[0].managedMemory = managedMemory
    {{endif}}
    {{if 'cudaDeviceProp.isMultiGpuBoard' in found_struct}}
    @property
    def isMultiGpuBoard(self):
        return self._pvt_ptr[0].isMultiGpuBoard
    @isMultiGpuBoard.setter
    def isMultiGpuBoard(self, int isMultiGpuBoard):
        self._pvt_ptr[0].isMultiGpuBoard = isMultiGpuBoard
    {{endif}}
    {{if 'cudaDeviceProp.multiGpuBoardGroupID' in found_struct}}
    @property
    def multiGpuBoardGroupID(self):
        return self._pvt_ptr[0].multiGpuBoardGroupID
    @multiGpuBoardGroupID.setter
    def multiGpuBoardGroupID(self, int multiGpuBoardGroupID):
        self._pvt_ptr[0].multiGpuBoardGroupID = multiGpuBoardGroupID
    {{endif}}
    {{if 'cudaDeviceProp.hostNativeAtomicSupported' in found_struct}}
    @property
    def hostNativeAtomicSupported(self):
        return self._pvt_ptr[0].hostNativeAtomicSupported
    @hostNativeAtomicSupported.setter
    def hostNativeAtomicSupported(self, int hostNativeAtomicSupported):
        self._pvt_ptr[0].hostNativeAtomicSupported = hostNativeAtomicSupported
    {{endif}}
    {{if 'cudaDeviceProp.pageableMemoryAccess' in found_struct}}
    @property
    def pageableMemoryAccess(self):
        return self._pvt_ptr[0].pageableMemoryAccess
    @pageableMemoryAccess.setter
    def pageableMemoryAccess(self, int pageableMemoryAccess):
        self._pvt_ptr[0].pageableMemoryAccess = pageableMemoryAccess
    {{endif}}
    {{if 'cudaDeviceProp.concurrentManagedAccess' in found_struct}}
    @property
    def concurrentManagedAccess(self):
        return self._pvt_ptr[0].concurrentManagedAccess
    @concurrentManagedAccess.setter
    def concurrentManagedAccess(self, int concurrentManagedAccess):
        self._pvt_ptr[0].concurrentManagedAccess = concurrentManagedAccess
    {{endif}}
    {{if 'cudaDeviceProp.computePreemptionSupported' in found_struct}}
    @property
    def computePreemptionSupported(self):
        return self._pvt_ptr[0].computePreemptionSupported
    @computePreemptionSupported.setter
    def computePreemptionSupported(self, int computePreemptionSupported):
        self._pvt_ptr[0].computePreemptionSupported = computePreemptionSupported
    {{endif}}
    {{if 'cudaDeviceProp.canUseHostPointerForRegisteredMem' in found_struct}}
    @property
    def canUseHostPointerForRegisteredMem(self):
        return self._pvt_ptr[0].canUseHostPointerForRegisteredMem
    @canUseHostPointerForRegisteredMem.setter
    def canUseHostPointerForRegisteredMem(self, int canUseHostPointerForRegisteredMem):
        self._pvt_ptr[0].canUseHostPointerForRegisteredMem = canUseHostPointerForRegisteredMem
    {{endif}}
    {{if 'cudaDeviceProp.cooperativeLaunch' in found_struct}}
    @property
    def cooperativeLaunch(self):
        return self._pvt_ptr[0].cooperativeLaunch
    @cooperativeLaunch.setter
    def cooperativeLaunch(self, int cooperativeLaunch):
        self._pvt_ptr[0].cooperativeLaunch = cooperativeLaunch
    {{endif}}
    {{if 'cudaDeviceProp.sharedMemPerBlockOptin' in found_struct}}
    @property
    def sharedMemPerBlockOptin(self):
        return self._pvt_ptr[0].sharedMemPerBlockOptin
    @sharedMemPerBlockOptin.setter
    def sharedMemPerBlockOptin(self, size_t sharedMemPerBlockOptin):
        self._pvt_ptr[0].sharedMemPerBlockOptin = sharedMemPerBlockOptin
    {{endif}}
    {{if 'cudaDeviceProp.pageableMemoryAccessUsesHostPageTables' in found_struct}}
    @property
    def pageableMemoryAccessUsesHostPageTables(self):
        return self._pvt_ptr[0].pageableMemoryAccessUsesHostPageTables
    @pageableMemoryAccessUsesHostPageTables.setter
    def pageableMemoryAccessUsesHostPageTables(self, int pageableMemoryAccessUsesHostPageTables):
        self._pvt_ptr[0].pageableMemoryAccessUsesHostPageTables = pageableMemoryAccessUsesHostPageTables
    {{endif}}
    {{if 'cudaDeviceProp.directManagedMemAccessFromHost' in found_struct}}
    @property
    def directManagedMemAccessFromHost(self):
        return self._pvt_ptr[0].directManagedMemAccessFromHost
    @directManagedMemAccessFromHost.setter
    def directManagedMemAccessFromHost(self, int directManagedMemAccessFromHost):
        self._pvt_ptr[0].directManagedMemAccessFromHost = directManagedMemAccessFromHost
    {{endif}}
    {{if 'cudaDeviceProp.maxBlocksPerMultiProcessor' in found_struct}}
    @property
    def maxBlocksPerMultiProcessor(self):
        return self._pvt_ptr[0].maxBlocksPerMultiProcessor
    @maxBlocksPerMultiProcessor.setter
    def maxBlocksPerMultiProcessor(self, int maxBlocksPerMultiProcessor):
        self._pvt_ptr[0].maxBlocksPerMultiProcessor = maxBlocksPerMultiProcessor
    {{endif}}
    {{if 'cudaDeviceProp.accessPolicyMaxWindowSize' in found_struct}}
    @property
    def accessPolicyMaxWindowSize(self):
        return self._pvt_ptr[0].accessPolicyMaxWindowSize
    @accessPolicyMaxWindowSize.setter
    def accessPolicyMaxWindowSize(self, int accessPolicyMaxWindowSize):
        self._pvt_ptr[0].accessPolicyMaxWindowSize = accessPolicyMaxWindowSize
    {{endif}}
    {{if 'cudaDeviceProp.reservedSharedMemPerBlock' in found_struct}}
    @property
    def reservedSharedMemPerBlock(self):
        return self._pvt_ptr[0].reservedSharedMemPerBlock
    @reservedSharedMemPerBlock.setter
    def reservedSharedMemPerBlock(self, size_t reservedSharedMemPerBlock):
        self._pvt_ptr[0].reservedSharedMemPerBlock = reservedSharedMemPerBlock
    {{endif}}
    {{if 'cudaDeviceProp.hostRegisterSupported' in found_struct}}
    @property
    def hostRegisterSupported(self):
        return self._pvt_ptr[0].hostRegisterSupported
    @hostRegisterSupported.setter
    def hostRegisterSupported(self, int hostRegisterSupported):
        self._pvt_ptr[0].hostRegisterSupported = hostRegisterSupported
    {{endif}}
    {{if 'cudaDeviceProp.sparseCudaArraySupported' in found_struct}}
    @property
    def sparseCudaArraySupported(self):
        return self._pvt_ptr[0].sparseCudaArraySupported
    @sparseCudaArraySupported.setter
    def sparseCudaArraySupported(self, int sparseCudaArraySupported):
        self._pvt_ptr[0].sparseCudaArraySupported = sparseCudaArraySupported
    {{endif}}
    {{if 'cudaDeviceProp.hostRegisterReadOnlySupported' in found_struct}}
    @property
    def hostRegisterReadOnlySupported(self):
        return self._pvt_ptr[0].hostRegisterReadOnlySupported
    @hostRegisterReadOnlySupported.setter
    def hostRegisterReadOnlySupported(self, int hostRegisterReadOnlySupported):
        self._pvt_ptr[0].hostRegisterReadOnlySupported = hostRegisterReadOnlySupported
    {{endif}}
    {{if 'cudaDeviceProp.timelineSemaphoreInteropSupported' in found_struct}}
    @property
    def timelineSemaphoreInteropSupported(self):
        return self._pvt_ptr[0].timelineSemaphoreInteropSupported
    @timelineSemaphoreInteropSupported.setter
    def timelineSemaphoreInteropSupported(self, int timelineSemaphoreInteropSupported):
        self._pvt_ptr[0].timelineSemaphoreInteropSupported = timelineSemaphoreInteropSupported
    {{endif}}
    {{if 'cudaDeviceProp.memoryPoolsSupported' in found_struct}}
    @property
    def memoryPoolsSupported(self):
        return self._pvt_ptr[0].memoryPoolsSupported
    @memoryPoolsSupported.setter
    def memoryPoolsSupported(self, int memoryPoolsSupported):
        self._pvt_ptr[0].memoryPoolsSupported = memoryPoolsSupported
    {{endif}}
    {{if 'cudaDeviceProp.gpuDirectRDMASupported' in found_struct}}
    @property
    def gpuDirectRDMASupported(self):
        return self._pvt_ptr[0].gpuDirectRDMASupported
    @gpuDirectRDMASupported.setter
    def gpuDirectRDMASupported(self, int gpuDirectRDMASupported):
        self._pvt_ptr[0].gpuDirectRDMASupported = gpuDirectRDMASupported
    {{endif}}
    {{if 'cudaDeviceProp.gpuDirectRDMAFlushWritesOptions' in found_struct}}
    @property
    def gpuDirectRDMAFlushWritesOptions(self):
        return self._pvt_ptr[0].gpuDirectRDMAFlushWritesOptions
    @gpuDirectRDMAFlushWritesOptions.setter
    def gpuDirectRDMAFlushWritesOptions(self, unsigned int gpuDirectRDMAFlushWritesOptions):
        self._pvt_ptr[0].gpuDirectRDMAFlushWritesOptions = gpuDirectRDMAFlushWritesOptions
    {{endif}}
    {{if 'cudaDeviceProp.gpuDirectRDMAWritesOrdering' in found_struct}}
    @property
    def gpuDirectRDMAWritesOrdering(self):
        return self._pvt_ptr[0].gpuDirectRDMAWritesOrdering
    @gpuDirectRDMAWritesOrdering.setter
    def gpuDirectRDMAWritesOrdering(self, int gpuDirectRDMAWritesOrdering):
        self._pvt_ptr[0].gpuDirectRDMAWritesOrdering = gpuDirectRDMAWritesOrdering
    {{endif}}
    {{if 'cudaDeviceProp.memoryPoolSupportedHandleTypes' in found_struct}}
    @property
    def memoryPoolSupportedHandleTypes(self):
        return self._pvt_ptr[0].memoryPoolSupportedHandleTypes
    @memoryPoolSupportedHandleTypes.setter
    def memoryPoolSupportedHandleTypes(self, unsigned int memoryPoolSupportedHandleTypes):
        self._pvt_ptr[0].memoryPoolSupportedHandleTypes = memoryPoolSupportedHandleTypes
    {{endif}}
    {{if 'cudaDeviceProp.deferredMappingCudaArraySupported' in found_struct}}
    @property
    def deferredMappingCudaArraySupported(self):
        return self._pvt_ptr[0].deferredMappingCudaArraySupported
    @deferredMappingCudaArraySupported.setter
    def deferredMappingCudaArraySupported(self, int deferredMappingCudaArraySupported):
        self._pvt_ptr[0].deferredMappingCudaArraySupported = deferredMappingCudaArraySupported
    {{endif}}
    {{if 'cudaDeviceProp.ipcEventSupported' in found_struct}}
    @property
    def ipcEventSupported(self):
        return self._pvt_ptr[0].ipcEventSupported
    @ipcEventSupported.setter
    def ipcEventSupported(self, int ipcEventSupported):
        self._pvt_ptr[0].ipcEventSupported = ipcEventSupported
    {{endif}}
    {{if 'cudaDeviceProp.clusterLaunch' in found_struct}}
    @property
    def clusterLaunch(self):
        return self._pvt_ptr[0].clusterLaunch
    @clusterLaunch.setter
    def clusterLaunch(self, int clusterLaunch):
        self._pvt_ptr[0].clusterLaunch = clusterLaunch
    {{endif}}
    {{if 'cudaDeviceProp.unifiedFunctionPointers' in found_struct}}
    @property
    def unifiedFunctionPointers(self):
        return self._pvt_ptr[0].unifiedFunctionPointers
    @unifiedFunctionPointers.setter
    def unifiedFunctionPointers(self, int unifiedFunctionPointers):
        self._pvt_ptr[0].unifiedFunctionPointers = unifiedFunctionPointers
    {{endif}}
    {{if 'cudaDeviceProp.deviceNumaConfig' in found_struct}}
    @property
    def deviceNumaConfig(self):
        return self._pvt_ptr[0].deviceNumaConfig
    @deviceNumaConfig.setter
    def deviceNumaConfig(self, int deviceNumaConfig):
        self._pvt_ptr[0].deviceNumaConfig = deviceNumaConfig
    {{endif}}
    {{if 'cudaDeviceProp.deviceNumaId' in found_struct}}
    @property
    def deviceNumaId(self):
        return self._pvt_ptr[0].deviceNumaId
    @deviceNumaId.setter
    def deviceNumaId(self, int deviceNumaId):
        self._pvt_ptr[0].deviceNumaId = deviceNumaId
    {{endif}}
    {{if 'cudaDeviceProp.mpsEnabled' in found_struct}}
    @property
    def mpsEnabled(self):
        return self._pvt_ptr[0].mpsEnabled
    @mpsEnabled.setter
    def mpsEnabled(self, int mpsEnabled):
        self._pvt_ptr[0].mpsEnabled = mpsEnabled
    {{endif}}
    {{if 'cudaDeviceProp.hostNumaId' in found_struct}}
    @property
    def hostNumaId(self):
        return self._pvt_ptr[0].hostNumaId
    @hostNumaId.setter
    def hostNumaId(self, int hostNumaId):
        self._pvt_ptr[0].hostNumaId = hostNumaId
    {{endif}}
    {{if 'cudaDeviceProp.gpuPciDeviceID' in found_struct}}
    @property
    def gpuPciDeviceID(self):
        return self._pvt_ptr[0].gpuPciDeviceID
    @gpuPciDeviceID.setter
    def gpuPciDeviceID(self, unsigned int gpuPciDeviceID):
        self._pvt_ptr[0].gpuPciDeviceID = gpuPciDeviceID
    {{endif}}
    {{if 'cudaDeviceProp.gpuPciSubsystemID' in found_struct}}
    @property
    def gpuPciSubsystemID(self):
        return self._pvt_ptr[0].gpuPciSubsystemID
    @gpuPciSubsystemID.setter
    def gpuPciSubsystemID(self, unsigned int gpuPciSubsystemID):
        self._pvt_ptr[0].gpuPciSubsystemID = gpuPciSubsystemID
    {{endif}}
    {{if 'cudaDeviceProp.hostNumaMultinodeIpcSupported' in found_struct}}
    @property
    def hostNumaMultinodeIpcSupported(self):
        return self._pvt_ptr[0].hostNumaMultinodeIpcSupported
    @hostNumaMultinodeIpcSupported.setter
    def hostNumaMultinodeIpcSupported(self, int hostNumaMultinodeIpcSupported):
        self._pvt_ptr[0].hostNumaMultinodeIpcSupported = hostNumaMultinodeIpcSupported
    {{endif}}
    {{if 'cudaDeviceProp.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaIpcEventHandle_st' in found_struct}}

cdef class cudaIpcEventHandle_st:
    """
    CUDA IPC event handle

    Attributes
    ----------
    {{if 'cudaIpcEventHandle_st.reserved' in found_struct}}
    reserved : bytes

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaIpcEventHandle_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaIpcEventHandle_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaIpcEventHandle_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(self._pvt_ptr[0].reserved, 64)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 64:
            raise ValueError("reserved length must be 64, is " + str(len(reserved)))
        if CHAR_MIN == 0:
            for i, b in enumerate(reserved):
                if b < 0 and b > -129:
                    b = b + 256
                self._pvt_ptr[0].reserved[i] = b
        else:
            for i, b in enumerate(reserved):
                if b > 127 and b < 256:
                    b = b - 256
                self._pvt_ptr[0].reserved[i] = b
    {{endif}}
{{endif}}
{{if 'cudaIpcMemHandle_st' in found_struct}}

cdef class cudaIpcMemHandle_st:
    """
    CUDA IPC memory handle

    Attributes
    ----------
    {{if 'cudaIpcMemHandle_st.reserved' in found_struct}}
    reserved : bytes

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaIpcMemHandle_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaIpcMemHandle_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaIpcMemHandle_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(self._pvt_ptr[0].reserved, 64)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 64:
            raise ValueError("reserved length must be 64, is " + str(len(reserved)))
        if CHAR_MIN == 0:
            for i, b in enumerate(reserved):
                if b < 0 and b > -129:
                    b = b + 256
                self._pvt_ptr[0].reserved[i] = b
        else:
            for i, b in enumerate(reserved):
                if b > 127 and b < 256:
                    b = b - 256
                self._pvt_ptr[0].reserved[i] = b
    {{endif}}
{{endif}}
{{if 'cudaMemFabricHandle_st' in found_struct}}

cdef class cudaMemFabricHandle_st:
    """
    Attributes
    ----------
    {{if 'cudaMemFabricHandle_st.reserved' in found_struct}}
    reserved : bytes

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaMemFabricHandle_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaMemFabricHandle_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaMemFabricHandle_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(self._pvt_ptr[0].reserved, 64)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 64:
            raise ValueError("reserved length must be 64, is " + str(len(reserved)))
        if CHAR_MIN == 0:
            for i, b in enumerate(reserved):
                if b < 0 and b > -129:
                    b = b + 256
                self._pvt_ptr[0].reserved[i] = b
        else:
            for i, b in enumerate(reserved):
                if b > 127 and b < 256:
                    b = b - 256
                self._pvt_ptr[0].reserved[i] = b
    {{endif}}
{{endif}}
{{if 'cudaExternalMemoryHandleDesc.handle.win32' in found_struct}}

cdef class anon_struct8:
    """
    Attributes
    ----------
    {{if 'cudaExternalMemoryHandleDesc.handle.win32.handle' in found_struct}}
    handle : Any

    {{endif}}
    {{if 'cudaExternalMemoryHandleDesc.handle.win32.name' in found_struct}}
    name : Any

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaExternalMemoryHandleDesc *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].handle.win32
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalMemoryHandleDesc.handle.win32.handle' in found_struct}}
            try:
                str_list += ['handle : ' + hex(self.handle)]
            except ValueError:
                str_list += ['handle : <ValueError>']
            {{endif}}
            {{if 'cudaExternalMemoryHandleDesc.handle.win32.name' in found_struct}}
            try:
                str_list += ['name : ' + hex(self.name)]
            except ValueError:
                str_list += ['name : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalMemoryHandleDesc.handle.win32.handle' in found_struct}}
    @property
    def handle(self):
        return <void_ptr>self._pvt_ptr[0].handle.win32.handle
    @handle.setter
    def handle(self, handle):
        _chandle = _HelperInputVoidPtr(handle)
        self._pvt_ptr[0].handle.win32.handle = <void*><void_ptr>_chandle.cptr
    {{endif}}
    {{if 'cudaExternalMemoryHandleDesc.handle.win32.name' in found_struct}}
    @property
    def name(self):
        return <void_ptr>self._pvt_ptr[0].handle.win32.name
    @name.setter
    def name(self, name):
        _cname = _HelperInputVoidPtr(name)
        self._pvt_ptr[0].handle.win32.name = <void*><void_ptr>_cname.cptr
    {{endif}}
{{endif}}
{{if 'cudaExternalMemoryHandleDesc.handle' in found_struct}}

cdef class anon_union2:
    """
    Attributes
    ----------
    {{if 'cudaExternalMemoryHandleDesc.handle.fd' in found_struct}}
    fd : int

    {{endif}}
    {{if 'cudaExternalMemoryHandleDesc.handle.win32' in found_struct}}
    win32 : anon_struct8

    {{endif}}
    {{if 'cudaExternalMemoryHandleDesc.handle.nvSciBufObject' in found_struct}}
    nvSciBufObject : Any

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaExternalMemoryHandleDesc *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'cudaExternalMemoryHandleDesc.handle.win32' in found_struct}}
        self._win32 = anon_struct8(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].handle
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalMemoryHandleDesc.handle.fd' in found_struct}}
            try:
                str_list += ['fd : ' + str(self.fd)]
            except ValueError:
                str_list += ['fd : <ValueError>']
            {{endif}}
            {{if 'cudaExternalMemoryHandleDesc.handle.win32' in found_struct}}
            try:
                str_list += ['win32 :\n' + '\n'.join(['    ' + line for line in str(self.win32).splitlines()])]
            except ValueError:
                str_list += ['win32 : <ValueError>']
            {{endif}}
            {{if 'cudaExternalMemoryHandleDesc.handle.nvSciBufObject' in found_struct}}
            try:
                str_list += ['nvSciBufObject : ' + hex(self.nvSciBufObject)]
            except ValueError:
                str_list += ['nvSciBufObject : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalMemoryHandleDesc.handle.fd' in found_struct}}
    @property
    def fd(self):
        return self._pvt_ptr[0].handle.fd
    @fd.setter
    def fd(self, int fd):
        self._pvt_ptr[0].handle.fd = fd
    {{endif}}
    {{if 'cudaExternalMemoryHandleDesc.handle.win32' in found_struct}}
    @property
    def win32(self):
        return self._win32
    @win32.setter
    def win32(self, win32 not None : anon_struct8):
        string.memcpy(&self._pvt_ptr[0].handle.win32, <cyruntime.anon_struct8*><void_ptr>win32.getPtr(), sizeof(self._pvt_ptr[0].handle.win32))
    {{endif}}
    {{if 'cudaExternalMemoryHandleDesc.handle.nvSciBufObject' in found_struct}}
    @property
    def nvSciBufObject(self):
        return <void_ptr>self._pvt_ptr[0].handle.nvSciBufObject
    @nvSciBufObject.setter
    def nvSciBufObject(self, nvSciBufObject):
        _cnvSciBufObject = _HelperInputVoidPtr(nvSciBufObject)
        self._pvt_ptr[0].handle.nvSciBufObject = <void*><void_ptr>_cnvSciBufObject.cptr
    {{endif}}
{{endif}}
{{if 'cudaExternalMemoryHandleDesc' in found_struct}}

cdef class cudaExternalMemoryHandleDesc:
    """
    External memory handle descriptor

    Attributes
    ----------
    {{if 'cudaExternalMemoryHandleDesc.type' in found_struct}}
    type : cudaExternalMemoryHandleType
        Type of the handle
    {{endif}}
    {{if 'cudaExternalMemoryHandleDesc.handle' in found_struct}}
    handle : anon_union2

    {{endif}}
    {{if 'cudaExternalMemoryHandleDesc.size' in found_struct}}
    size : unsigned long long
        Size of the memory allocation
    {{endif}}
    {{if 'cudaExternalMemoryHandleDesc.flags' in found_struct}}
    flags : unsigned int
        Flags must either be zero or cudaExternalMemoryDedicated
    {{endif}}
    {{if 'cudaExternalMemoryHandleDesc.reserved' in found_struct}}
    reserved : list[unsigned int]
        Must be zero
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cyruntime.cudaExternalMemoryHandleDesc *>calloc(1, sizeof(cyruntime.cudaExternalMemoryHandleDesc))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cyruntime.cudaExternalMemoryHandleDesc *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaExternalMemoryHandleDesc.handle' in found_struct}}
        self._handle = anon_union2(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalMemoryHandleDesc.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'cudaExternalMemoryHandleDesc.handle' in found_struct}}
            try:
                str_list += ['handle :\n' + '\n'.join(['    ' + line for line in str(self.handle).splitlines()])]
            except ValueError:
                str_list += ['handle : <ValueError>']
            {{endif}}
            {{if 'cudaExternalMemoryHandleDesc.size' in found_struct}}
            try:
                str_list += ['size : ' + str(self.size)]
            except ValueError:
                str_list += ['size : <ValueError>']
            {{endif}}
            {{if 'cudaExternalMemoryHandleDesc.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'cudaExternalMemoryHandleDesc.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalMemoryHandleDesc.type' in found_struct}}
    @property
    def type(self):
        return cudaExternalMemoryHandleType(self._pvt_ptr[0].type)
    @type.setter
    def type(self, type not None : cudaExternalMemoryHandleType):
        self._pvt_ptr[0].type = int(type)
    {{endif}}
    {{if 'cudaExternalMemoryHandleDesc.handle' in found_struct}}
    @property
    def handle(self):
        return self._handle
    @handle.setter
    def handle(self, handle not None : anon_union2):
        string.memcpy(&self._pvt_ptr[0].handle, <cyruntime.anon_union2*><void_ptr>handle.getPtr(), sizeof(self._pvt_ptr[0].handle))
    {{endif}}
    {{if 'cudaExternalMemoryHandleDesc.size' in found_struct}}
    @property
    def size(self):
        return self._pvt_ptr[0].size
    @size.setter
    def size(self, unsigned long long size):
        self._pvt_ptr[0].size = size
    {{endif}}
    {{if 'cudaExternalMemoryHandleDesc.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'cudaExternalMemoryHandleDesc.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaExternalMemoryBufferDesc' in found_struct}}

cdef class cudaExternalMemoryBufferDesc:
    """
    External memory buffer descriptor

    Attributes
    ----------
    {{if 'cudaExternalMemoryBufferDesc.offset' in found_struct}}
    offset : unsigned long long
        Offset into the memory object where the buffer's base is
    {{endif}}
    {{if 'cudaExternalMemoryBufferDesc.size' in found_struct}}
    size : unsigned long long
        Size of the buffer
    {{endif}}
    {{if 'cudaExternalMemoryBufferDesc.flags' in found_struct}}
    flags : unsigned int
        Flags reserved for future use. Must be zero.
    {{endif}}
    {{if 'cudaExternalMemoryBufferDesc.reserved' in found_struct}}
    reserved : list[unsigned int]
        Must be zero
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaExternalMemoryBufferDesc *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalMemoryBufferDesc.offset' in found_struct}}
            try:
                str_list += ['offset : ' + str(self.offset)]
            except ValueError:
                str_list += ['offset : <ValueError>']
            {{endif}}
            {{if 'cudaExternalMemoryBufferDesc.size' in found_struct}}
            try:
                str_list += ['size : ' + str(self.size)]
            except ValueError:
                str_list += ['size : <ValueError>']
            {{endif}}
            {{if 'cudaExternalMemoryBufferDesc.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'cudaExternalMemoryBufferDesc.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalMemoryBufferDesc.offset' in found_struct}}
    @property
    def offset(self):
        return self._pvt_ptr[0].offset
    @offset.setter
    def offset(self, unsigned long long offset):
        self._pvt_ptr[0].offset = offset
    {{endif}}
    {{if 'cudaExternalMemoryBufferDesc.size' in found_struct}}
    @property
    def size(self):
        return self._pvt_ptr[0].size
    @size.setter
    def size(self, unsigned long long size):
        self._pvt_ptr[0].size = size
    {{endif}}
    {{if 'cudaExternalMemoryBufferDesc.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'cudaExternalMemoryBufferDesc.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaExternalMemoryMipmappedArrayDesc' in found_struct}}

cdef class cudaExternalMemoryMipmappedArrayDesc:
    """
    External memory mipmap descriptor

    Attributes
    ----------
    {{if 'cudaExternalMemoryMipmappedArrayDesc.offset' in found_struct}}
    offset : unsigned long long
        Offset into the memory object where the base level of the mipmap
        chain is.
    {{endif}}
    {{if 'cudaExternalMemoryMipmappedArrayDesc.formatDesc' in found_struct}}
    formatDesc : cudaChannelFormatDesc
        Format of base level of the mipmap chain
    {{endif}}
    {{if 'cudaExternalMemoryMipmappedArrayDesc.extent' in found_struct}}
    extent : cudaExtent
        Dimensions of base level of the mipmap chain
    {{endif}}
    {{if 'cudaExternalMemoryMipmappedArrayDesc.flags' in found_struct}}
    flags : unsigned int
        Flags associated with CUDA mipmapped arrays. See
        cudaMallocMipmappedArray
    {{endif}}
    {{if 'cudaExternalMemoryMipmappedArrayDesc.numLevels' in found_struct}}
    numLevels : unsigned int
        Total number of levels in the mipmap chain
    {{endif}}
    {{if 'cudaExternalMemoryMipmappedArrayDesc.reserved' in found_struct}}
    reserved : list[unsigned int]
        Must be zero
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaExternalMemoryMipmappedArrayDesc *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaExternalMemoryMipmappedArrayDesc.formatDesc' in found_struct}}
        self._formatDesc = cudaChannelFormatDesc(_ptr=<void_ptr>&self._pvt_ptr[0].formatDesc)
        {{endif}}
        {{if 'cudaExternalMemoryMipmappedArrayDesc.extent' in found_struct}}
        self._extent = cudaExtent(_ptr=<void_ptr>&self._pvt_ptr[0].extent)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalMemoryMipmappedArrayDesc.offset' in found_struct}}
            try:
                str_list += ['offset : ' + str(self.offset)]
            except ValueError:
                str_list += ['offset : <ValueError>']
            {{endif}}
            {{if 'cudaExternalMemoryMipmappedArrayDesc.formatDesc' in found_struct}}
            try:
                str_list += ['formatDesc :\n' + '\n'.join(['    ' + line for line in str(self.formatDesc).splitlines()])]
            except ValueError:
                str_list += ['formatDesc : <ValueError>']
            {{endif}}
            {{if 'cudaExternalMemoryMipmappedArrayDesc.extent' in found_struct}}
            try:
                str_list += ['extent :\n' + '\n'.join(['    ' + line for line in str(self.extent).splitlines()])]
            except ValueError:
                str_list += ['extent : <ValueError>']
            {{endif}}
            {{if 'cudaExternalMemoryMipmappedArrayDesc.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'cudaExternalMemoryMipmappedArrayDesc.numLevels' in found_struct}}
            try:
                str_list += ['numLevels : ' + str(self.numLevels)]
            except ValueError:
                str_list += ['numLevels : <ValueError>']
            {{endif}}
            {{if 'cudaExternalMemoryMipmappedArrayDesc.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalMemoryMipmappedArrayDesc.offset' in found_struct}}
    @property
    def offset(self):
        return self._pvt_ptr[0].offset
    @offset.setter
    def offset(self, unsigned long long offset):
        self._pvt_ptr[0].offset = offset
    {{endif}}
    {{if 'cudaExternalMemoryMipmappedArrayDesc.formatDesc' in found_struct}}
    @property
    def formatDesc(self):
        return self._formatDesc
    @formatDesc.setter
    def formatDesc(self, formatDesc not None : cudaChannelFormatDesc):
        string.memcpy(&self._pvt_ptr[0].formatDesc, <cyruntime.cudaChannelFormatDesc*><void_ptr>formatDesc.getPtr(), sizeof(self._pvt_ptr[0].formatDesc))
    {{endif}}
    {{if 'cudaExternalMemoryMipmappedArrayDesc.extent' in found_struct}}
    @property
    def extent(self):
        return self._extent
    @extent.setter
    def extent(self, extent not None : cudaExtent):
        string.memcpy(&self._pvt_ptr[0].extent, <cyruntime.cudaExtent*><void_ptr>extent.getPtr(), sizeof(self._pvt_ptr[0].extent))
    {{endif}}
    {{if 'cudaExternalMemoryMipmappedArrayDesc.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'cudaExternalMemoryMipmappedArrayDesc.numLevels' in found_struct}}
    @property
    def numLevels(self):
        return self._pvt_ptr[0].numLevels
    @numLevels.setter
    def numLevels(self, unsigned int numLevels):
        self._pvt_ptr[0].numLevels = numLevels
    {{endif}}
    {{if 'cudaExternalMemoryMipmappedArrayDesc.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaExternalSemaphoreHandleDesc.handle.win32' in found_struct}}

cdef class anon_struct9:
    """
    Attributes
    ----------
    {{if 'cudaExternalSemaphoreHandleDesc.handle.win32.handle' in found_struct}}
    handle : Any

    {{endif}}
    {{if 'cudaExternalSemaphoreHandleDesc.handle.win32.name' in found_struct}}
    name : Any

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaExternalSemaphoreHandleDesc *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].handle.win32
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalSemaphoreHandleDesc.handle.win32.handle' in found_struct}}
            try:
                str_list += ['handle : ' + hex(self.handle)]
            except ValueError:
                str_list += ['handle : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreHandleDesc.handle.win32.name' in found_struct}}
            try:
                str_list += ['name : ' + hex(self.name)]
            except ValueError:
                str_list += ['name : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalSemaphoreHandleDesc.handle.win32.handle' in found_struct}}
    @property
    def handle(self):
        return <void_ptr>self._pvt_ptr[0].handle.win32.handle
    @handle.setter
    def handle(self, handle):
        _chandle = _HelperInputVoidPtr(handle)
        self._pvt_ptr[0].handle.win32.handle = <void*><void_ptr>_chandle.cptr
    {{endif}}
    {{if 'cudaExternalSemaphoreHandleDesc.handle.win32.name' in found_struct}}
    @property
    def name(self):
        return <void_ptr>self._pvt_ptr[0].handle.win32.name
    @name.setter
    def name(self, name):
        _cname = _HelperInputVoidPtr(name)
        self._pvt_ptr[0].handle.win32.name = <void*><void_ptr>_cname.cptr
    {{endif}}
{{endif}}
{{if 'cudaExternalSemaphoreHandleDesc.handle' in found_struct}}

cdef class anon_union3:
    """
    Attributes
    ----------
    {{if 'cudaExternalSemaphoreHandleDesc.handle.fd' in found_struct}}
    fd : int

    {{endif}}
    {{if 'cudaExternalSemaphoreHandleDesc.handle.win32' in found_struct}}
    win32 : anon_struct9

    {{endif}}
    {{if 'cudaExternalSemaphoreHandleDesc.handle.nvSciSyncObj' in found_struct}}
    nvSciSyncObj : Any

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaExternalSemaphoreHandleDesc *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'cudaExternalSemaphoreHandleDesc.handle.win32' in found_struct}}
        self._win32 = anon_struct9(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].handle
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalSemaphoreHandleDesc.handle.fd' in found_struct}}
            try:
                str_list += ['fd : ' + str(self.fd)]
            except ValueError:
                str_list += ['fd : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreHandleDesc.handle.win32' in found_struct}}
            try:
                str_list += ['win32 :\n' + '\n'.join(['    ' + line for line in str(self.win32).splitlines()])]
            except ValueError:
                str_list += ['win32 : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreHandleDesc.handle.nvSciSyncObj' in found_struct}}
            try:
                str_list += ['nvSciSyncObj : ' + hex(self.nvSciSyncObj)]
            except ValueError:
                str_list += ['nvSciSyncObj : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalSemaphoreHandleDesc.handle.fd' in found_struct}}
    @property
    def fd(self):
        return self._pvt_ptr[0].handle.fd
    @fd.setter
    def fd(self, int fd):
        self._pvt_ptr[0].handle.fd = fd
    {{endif}}
    {{if 'cudaExternalSemaphoreHandleDesc.handle.win32' in found_struct}}
    @property
    def win32(self):
        return self._win32
    @win32.setter
    def win32(self, win32 not None : anon_struct9):
        string.memcpy(&self._pvt_ptr[0].handle.win32, <cyruntime.anon_struct9*><void_ptr>win32.getPtr(), sizeof(self._pvt_ptr[0].handle.win32))
    {{endif}}
    {{if 'cudaExternalSemaphoreHandleDesc.handle.nvSciSyncObj' in found_struct}}
    @property
    def nvSciSyncObj(self):
        return <void_ptr>self._pvt_ptr[0].handle.nvSciSyncObj
    @nvSciSyncObj.setter
    def nvSciSyncObj(self, nvSciSyncObj):
        _cnvSciSyncObj = _HelperInputVoidPtr(nvSciSyncObj)
        self._pvt_ptr[0].handle.nvSciSyncObj = <void*><void_ptr>_cnvSciSyncObj.cptr
    {{endif}}
{{endif}}
{{if 'cudaExternalSemaphoreHandleDesc' in found_struct}}

cdef class cudaExternalSemaphoreHandleDesc:
    """
    External semaphore handle descriptor

    Attributes
    ----------
    {{if 'cudaExternalSemaphoreHandleDesc.type' in found_struct}}
    type : cudaExternalSemaphoreHandleType
        Type of the handle
    {{endif}}
    {{if 'cudaExternalSemaphoreHandleDesc.handle' in found_struct}}
    handle : anon_union3

    {{endif}}
    {{if 'cudaExternalSemaphoreHandleDesc.flags' in found_struct}}
    flags : unsigned int
        Flags reserved for the future. Must be zero.
    {{endif}}
    {{if 'cudaExternalSemaphoreHandleDesc.reserved' in found_struct}}
    reserved : list[unsigned int]
        Must be zero
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cyruntime.cudaExternalSemaphoreHandleDesc *>calloc(1, sizeof(cyruntime.cudaExternalSemaphoreHandleDesc))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cyruntime.cudaExternalSemaphoreHandleDesc *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaExternalSemaphoreHandleDesc.handle' in found_struct}}
        self._handle = anon_union3(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalSemaphoreHandleDesc.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreHandleDesc.handle' in found_struct}}
            try:
                str_list += ['handle :\n' + '\n'.join(['    ' + line for line in str(self.handle).splitlines()])]
            except ValueError:
                str_list += ['handle : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreHandleDesc.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreHandleDesc.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalSemaphoreHandleDesc.type' in found_struct}}
    @property
    def type(self):
        return cudaExternalSemaphoreHandleType(self._pvt_ptr[0].type)
    @type.setter
    def type(self, type not None : cudaExternalSemaphoreHandleType):
        self._pvt_ptr[0].type = int(type)
    {{endif}}
    {{if 'cudaExternalSemaphoreHandleDesc.handle' in found_struct}}
    @property
    def handle(self):
        return self._handle
    @handle.setter
    def handle(self, handle not None : anon_union3):
        string.memcpy(&self._pvt_ptr[0].handle, <cyruntime.anon_union3*><void_ptr>handle.getPtr(), sizeof(self._pvt_ptr[0].handle))
    {{endif}}
    {{if 'cudaExternalSemaphoreHandleDesc.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'cudaExternalSemaphoreHandleDesc.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaExternalSemaphoreSignalParams.params.fence' in found_struct}}

cdef class anon_struct10:
    """
    Attributes
    ----------
    {{if 'cudaExternalSemaphoreSignalParams.params.fence.value' in found_struct}}
    value : unsigned long long

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaExternalSemaphoreSignalParams *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].params.fence
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalSemaphoreSignalParams.params.fence.value' in found_struct}}
            try:
                str_list += ['value : ' + str(self.value)]
            except ValueError:
                str_list += ['value : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalSemaphoreSignalParams.params.fence.value' in found_struct}}
    @property
    def value(self):
        return self._pvt_ptr[0].params.fence.value
    @value.setter
    def value(self, unsigned long long value):
        self._pvt_ptr[0].params.fence.value = value
    {{endif}}
{{endif}}
{{if 'cudaExternalSemaphoreSignalParams.params.nvSciSync' in found_struct}}

cdef class anon_union4:
    """
    Attributes
    ----------
    {{if 'cudaExternalSemaphoreSignalParams.params.nvSciSync.fence' in found_struct}}
    fence : Any

    {{endif}}
    {{if 'cudaExternalSemaphoreSignalParams.params.nvSciSync.reserved' in found_struct}}
    reserved : unsigned long long

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaExternalSemaphoreSignalParams *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].params.nvSciSync
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalSemaphoreSignalParams.params.nvSciSync.fence' in found_struct}}
            try:
                str_list += ['fence : ' + hex(self.fence)]
            except ValueError:
                str_list += ['fence : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreSignalParams.params.nvSciSync.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalSemaphoreSignalParams.params.nvSciSync.fence' in found_struct}}
    @property
    def fence(self):
        return <void_ptr>self._pvt_ptr[0].params.nvSciSync.fence
    @fence.setter
    def fence(self, fence):
        _cfence = _HelperInputVoidPtr(fence)
        self._pvt_ptr[0].params.nvSciSync.fence = <void*><void_ptr>_cfence.cptr
    {{endif}}
    {{if 'cudaExternalSemaphoreSignalParams.params.nvSciSync.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].params.nvSciSync.reserved
    @reserved.setter
    def reserved(self, unsigned long long reserved):
        self._pvt_ptr[0].params.nvSciSync.reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaExternalSemaphoreSignalParams.params.keyedMutex' in found_struct}}

cdef class anon_struct11:
    """
    Attributes
    ----------
    {{if 'cudaExternalSemaphoreSignalParams.params.keyedMutex.key' in found_struct}}
    key : unsigned long long

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaExternalSemaphoreSignalParams *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].params.keyedMutex
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalSemaphoreSignalParams.params.keyedMutex.key' in found_struct}}
            try:
                str_list += ['key : ' + str(self.key)]
            except ValueError:
                str_list += ['key : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalSemaphoreSignalParams.params.keyedMutex.key' in found_struct}}
    @property
    def key(self):
        return self._pvt_ptr[0].params.keyedMutex.key
    @key.setter
    def key(self, unsigned long long key):
        self._pvt_ptr[0].params.keyedMutex.key = key
    {{endif}}
{{endif}}
{{if 'cudaExternalSemaphoreSignalParams.params' in found_struct}}

cdef class anon_struct12:
    """
    Attributes
    ----------
    {{if 'cudaExternalSemaphoreSignalParams.params.fence' in found_struct}}
    fence : anon_struct10

    {{endif}}
    {{if 'cudaExternalSemaphoreSignalParams.params.nvSciSync' in found_struct}}
    nvSciSync : anon_union4

    {{endif}}
    {{if 'cudaExternalSemaphoreSignalParams.params.keyedMutex' in found_struct}}
    keyedMutex : anon_struct11

    {{endif}}
    {{if 'cudaExternalSemaphoreSignalParams.params.reserved' in found_struct}}
    reserved : list[unsigned int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaExternalSemaphoreSignalParams *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'cudaExternalSemaphoreSignalParams.params.fence' in found_struct}}
        self._fence = anon_struct10(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'cudaExternalSemaphoreSignalParams.params.nvSciSync' in found_struct}}
        self._nvSciSync = anon_union4(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'cudaExternalSemaphoreSignalParams.params.keyedMutex' in found_struct}}
        self._keyedMutex = anon_struct11(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].params
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalSemaphoreSignalParams.params.fence' in found_struct}}
            try:
                str_list += ['fence :\n' + '\n'.join(['    ' + line for line in str(self.fence).splitlines()])]
            except ValueError:
                str_list += ['fence : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreSignalParams.params.nvSciSync' in found_struct}}
            try:
                str_list += ['nvSciSync :\n' + '\n'.join(['    ' + line for line in str(self.nvSciSync).splitlines()])]
            except ValueError:
                str_list += ['nvSciSync : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreSignalParams.params.keyedMutex' in found_struct}}
            try:
                str_list += ['keyedMutex :\n' + '\n'.join(['    ' + line for line in str(self.keyedMutex).splitlines()])]
            except ValueError:
                str_list += ['keyedMutex : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreSignalParams.params.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalSemaphoreSignalParams.params.fence' in found_struct}}
    @property
    def fence(self):
        return self._fence
    @fence.setter
    def fence(self, fence not None : anon_struct10):
        string.memcpy(&self._pvt_ptr[0].params.fence, <cyruntime.anon_struct10*><void_ptr>fence.getPtr(), sizeof(self._pvt_ptr[0].params.fence))
    {{endif}}
    {{if 'cudaExternalSemaphoreSignalParams.params.nvSciSync' in found_struct}}
    @property
    def nvSciSync(self):
        return self._nvSciSync
    @nvSciSync.setter
    def nvSciSync(self, nvSciSync not None : anon_union4):
        string.memcpy(&self._pvt_ptr[0].params.nvSciSync, <cyruntime.anon_union4*><void_ptr>nvSciSync.getPtr(), sizeof(self._pvt_ptr[0].params.nvSciSync))
    {{endif}}
    {{if 'cudaExternalSemaphoreSignalParams.params.keyedMutex' in found_struct}}
    @property
    def keyedMutex(self):
        return self._keyedMutex
    @keyedMutex.setter
    def keyedMutex(self, keyedMutex not None : anon_struct11):
        string.memcpy(&self._pvt_ptr[0].params.keyedMutex, <cyruntime.anon_struct11*><void_ptr>keyedMutex.getPtr(), sizeof(self._pvt_ptr[0].params.keyedMutex))
    {{endif}}
    {{if 'cudaExternalSemaphoreSignalParams.params.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].params.reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].params.reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaExternalSemaphoreSignalParams' in found_struct}}

cdef class cudaExternalSemaphoreSignalParams:
    """
    External semaphore signal parameters, compatible with driver type

    Attributes
    ----------
    {{if 'cudaExternalSemaphoreSignalParams.params' in found_struct}}
    params : anon_struct12

    {{endif}}
    {{if 'cudaExternalSemaphoreSignalParams.flags' in found_struct}}
    flags : unsigned int
        Only when cudaExternalSemaphoreSignalParams is used to signal a
        cudaExternalSemaphore_t of type
        cudaExternalSemaphoreHandleTypeNvSciSync, the valid flag is
        cudaExternalSemaphoreSignalSkipNvSciBufMemSync: which indicates
        that while signaling the cudaExternalSemaphore_t, no memory
        synchronization operations should be performed for any external
        memory object imported as cudaExternalMemoryHandleTypeNvSciBuf. For
        all other types of cudaExternalSemaphore_t, flags must be zero.
    {{endif}}
    {{if 'cudaExternalSemaphoreSignalParams.reserved' in found_struct}}
    reserved : list[unsigned int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaExternalSemaphoreSignalParams *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaExternalSemaphoreSignalParams.params' in found_struct}}
        self._params = anon_struct12(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalSemaphoreSignalParams.params' in found_struct}}
            try:
                str_list += ['params :\n' + '\n'.join(['    ' + line for line in str(self.params).splitlines()])]
            except ValueError:
                str_list += ['params : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreSignalParams.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreSignalParams.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalSemaphoreSignalParams.params' in found_struct}}
    @property
    def params(self):
        return self._params
    @params.setter
    def params(self, params not None : anon_struct12):
        string.memcpy(&self._pvt_ptr[0].params, <cyruntime.anon_struct12*><void_ptr>params.getPtr(), sizeof(self._pvt_ptr[0].params))
    {{endif}}
    {{if 'cudaExternalSemaphoreSignalParams.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'cudaExternalSemaphoreSignalParams.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaExternalSemaphoreWaitParams.params.fence' in found_struct}}

cdef class anon_struct13:
    """
    Attributes
    ----------
    {{if 'cudaExternalSemaphoreWaitParams.params.fence.value' in found_struct}}
    value : unsigned long long

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaExternalSemaphoreWaitParams *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].params.fence
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalSemaphoreWaitParams.params.fence.value' in found_struct}}
            try:
                str_list += ['value : ' + str(self.value)]
            except ValueError:
                str_list += ['value : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalSemaphoreWaitParams.params.fence.value' in found_struct}}
    @property
    def value(self):
        return self._pvt_ptr[0].params.fence.value
    @value.setter
    def value(self, unsigned long long value):
        self._pvt_ptr[0].params.fence.value = value
    {{endif}}
{{endif}}
{{if 'cudaExternalSemaphoreWaitParams.params.nvSciSync' in found_struct}}

cdef class anon_union5:
    """
    Attributes
    ----------
    {{if 'cudaExternalSemaphoreWaitParams.params.nvSciSync.fence' in found_struct}}
    fence : Any

    {{endif}}
    {{if 'cudaExternalSemaphoreWaitParams.params.nvSciSync.reserved' in found_struct}}
    reserved : unsigned long long

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaExternalSemaphoreWaitParams *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].params.nvSciSync
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalSemaphoreWaitParams.params.nvSciSync.fence' in found_struct}}
            try:
                str_list += ['fence : ' + hex(self.fence)]
            except ValueError:
                str_list += ['fence : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreWaitParams.params.nvSciSync.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalSemaphoreWaitParams.params.nvSciSync.fence' in found_struct}}
    @property
    def fence(self):
        return <void_ptr>self._pvt_ptr[0].params.nvSciSync.fence
    @fence.setter
    def fence(self, fence):
        _cfence = _HelperInputVoidPtr(fence)
        self._pvt_ptr[0].params.nvSciSync.fence = <void*><void_ptr>_cfence.cptr
    {{endif}}
    {{if 'cudaExternalSemaphoreWaitParams.params.nvSciSync.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].params.nvSciSync.reserved
    @reserved.setter
    def reserved(self, unsigned long long reserved):
        self._pvt_ptr[0].params.nvSciSync.reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaExternalSemaphoreWaitParams.params.keyedMutex' in found_struct}}

cdef class anon_struct14:
    """
    Attributes
    ----------
    {{if 'cudaExternalSemaphoreWaitParams.params.keyedMutex.key' in found_struct}}
    key : unsigned long long

    {{endif}}
    {{if 'cudaExternalSemaphoreWaitParams.params.keyedMutex.timeoutMs' in found_struct}}
    timeoutMs : unsigned int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaExternalSemaphoreWaitParams *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].params.keyedMutex
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalSemaphoreWaitParams.params.keyedMutex.key' in found_struct}}
            try:
                str_list += ['key : ' + str(self.key)]
            except ValueError:
                str_list += ['key : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreWaitParams.params.keyedMutex.timeoutMs' in found_struct}}
            try:
                str_list += ['timeoutMs : ' + str(self.timeoutMs)]
            except ValueError:
                str_list += ['timeoutMs : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalSemaphoreWaitParams.params.keyedMutex.key' in found_struct}}
    @property
    def key(self):
        return self._pvt_ptr[0].params.keyedMutex.key
    @key.setter
    def key(self, unsigned long long key):
        self._pvt_ptr[0].params.keyedMutex.key = key
    {{endif}}
    {{if 'cudaExternalSemaphoreWaitParams.params.keyedMutex.timeoutMs' in found_struct}}
    @property
    def timeoutMs(self):
        return self._pvt_ptr[0].params.keyedMutex.timeoutMs
    @timeoutMs.setter
    def timeoutMs(self, unsigned int timeoutMs):
        self._pvt_ptr[0].params.keyedMutex.timeoutMs = timeoutMs
    {{endif}}
{{endif}}
{{if 'cudaExternalSemaphoreWaitParams.params' in found_struct}}

cdef class anon_struct15:
    """
    Attributes
    ----------
    {{if 'cudaExternalSemaphoreWaitParams.params.fence' in found_struct}}
    fence : anon_struct13

    {{endif}}
    {{if 'cudaExternalSemaphoreWaitParams.params.nvSciSync' in found_struct}}
    nvSciSync : anon_union5

    {{endif}}
    {{if 'cudaExternalSemaphoreWaitParams.params.keyedMutex' in found_struct}}
    keyedMutex : anon_struct14

    {{endif}}
    {{if 'cudaExternalSemaphoreWaitParams.params.reserved' in found_struct}}
    reserved : list[unsigned int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaExternalSemaphoreWaitParams *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'cudaExternalSemaphoreWaitParams.params.fence' in found_struct}}
        self._fence = anon_struct13(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'cudaExternalSemaphoreWaitParams.params.nvSciSync' in found_struct}}
        self._nvSciSync = anon_union5(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'cudaExternalSemaphoreWaitParams.params.keyedMutex' in found_struct}}
        self._keyedMutex = anon_struct14(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].params
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalSemaphoreWaitParams.params.fence' in found_struct}}
            try:
                str_list += ['fence :\n' + '\n'.join(['    ' + line for line in str(self.fence).splitlines()])]
            except ValueError:
                str_list += ['fence : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreWaitParams.params.nvSciSync' in found_struct}}
            try:
                str_list += ['nvSciSync :\n' + '\n'.join(['    ' + line for line in str(self.nvSciSync).splitlines()])]
            except ValueError:
                str_list += ['nvSciSync : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreWaitParams.params.keyedMutex' in found_struct}}
            try:
                str_list += ['keyedMutex :\n' + '\n'.join(['    ' + line for line in str(self.keyedMutex).splitlines()])]
            except ValueError:
                str_list += ['keyedMutex : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreWaitParams.params.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalSemaphoreWaitParams.params.fence' in found_struct}}
    @property
    def fence(self):
        return self._fence
    @fence.setter
    def fence(self, fence not None : anon_struct13):
        string.memcpy(&self._pvt_ptr[0].params.fence, <cyruntime.anon_struct13*><void_ptr>fence.getPtr(), sizeof(self._pvt_ptr[0].params.fence))
    {{endif}}
    {{if 'cudaExternalSemaphoreWaitParams.params.nvSciSync' in found_struct}}
    @property
    def nvSciSync(self):
        return self._nvSciSync
    @nvSciSync.setter
    def nvSciSync(self, nvSciSync not None : anon_union5):
        string.memcpy(&self._pvt_ptr[0].params.nvSciSync, <cyruntime.anon_union5*><void_ptr>nvSciSync.getPtr(), sizeof(self._pvt_ptr[0].params.nvSciSync))
    {{endif}}
    {{if 'cudaExternalSemaphoreWaitParams.params.keyedMutex' in found_struct}}
    @property
    def keyedMutex(self):
        return self._keyedMutex
    @keyedMutex.setter
    def keyedMutex(self, keyedMutex not None : anon_struct14):
        string.memcpy(&self._pvt_ptr[0].params.keyedMutex, <cyruntime.anon_struct14*><void_ptr>keyedMutex.getPtr(), sizeof(self._pvt_ptr[0].params.keyedMutex))
    {{endif}}
    {{if 'cudaExternalSemaphoreWaitParams.params.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].params.reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].params.reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaExternalSemaphoreWaitParams' in found_struct}}

cdef class cudaExternalSemaphoreWaitParams:
    """
    External semaphore wait parameters, compatible with driver type

    Attributes
    ----------
    {{if 'cudaExternalSemaphoreWaitParams.params' in found_struct}}
    params : anon_struct15

    {{endif}}
    {{if 'cudaExternalSemaphoreWaitParams.flags' in found_struct}}
    flags : unsigned int
        Only when cudaExternalSemaphoreSignalParams is used to signal a
        cudaExternalSemaphore_t of type
        cudaExternalSemaphoreHandleTypeNvSciSync, the valid flag is
        cudaExternalSemaphoreSignalSkipNvSciBufMemSync: which indicates
        that while waiting for the cudaExternalSemaphore_t, no memory
        synchronization operations should be performed for any external
        memory object imported as cudaExternalMemoryHandleTypeNvSciBuf. For
        all other types of cudaExternalSemaphore_t, flags must be zero.
    {{endif}}
    {{if 'cudaExternalSemaphoreWaitParams.reserved' in found_struct}}
    reserved : list[unsigned int]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaExternalSemaphoreWaitParams *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaExternalSemaphoreWaitParams.params' in found_struct}}
        self._params = anon_struct15(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalSemaphoreWaitParams.params' in found_struct}}
            try:
                str_list += ['params :\n' + '\n'.join(['    ' + line for line in str(self.params).splitlines()])]
            except ValueError:
                str_list += ['params : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreWaitParams.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreWaitParams.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalSemaphoreWaitParams.params' in found_struct}}
    @property
    def params(self):
        return self._params
    @params.setter
    def params(self, params not None : anon_struct15):
        string.memcpy(&self._pvt_ptr[0].params, <cyruntime.anon_struct15*><void_ptr>params.getPtr(), sizeof(self._pvt_ptr[0].params))
    {{endif}}
    {{if 'cudaExternalSemaphoreWaitParams.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'cudaExternalSemaphoreWaitParams.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaDevSmResource' in found_struct}}

cdef class cudaDevSmResource:
    """
    Data for SM-related resources All parameters in this structure are
    OUTPUT only. Do not write to any of the fields in this structure.

    Attributes
    ----------
    {{if 'cudaDevSmResource.smCount' in found_struct}}
    smCount : unsigned int
        The amount of streaming multiprocessors available in this resource.
    {{endif}}
    {{if 'cudaDevSmResource.minSmPartitionSize' in found_struct}}
    minSmPartitionSize : unsigned int
        The minimum number of streaming multiprocessors required to
        partition this resource.
    {{endif}}
    {{if 'cudaDevSmResource.smCoscheduledAlignment' in found_struct}}
    smCoscheduledAlignment : unsigned int
        The number of streaming multiprocessors in this resource that are
        guaranteed to be co-scheduled on the same GPU processing cluster.
        smCount will be a multiple of this value, unless the backfill flag
        is set.
    {{endif}}
    {{if 'cudaDevSmResource.flags' in found_struct}}
    flags : unsigned int
        The flags set on this SM resource. For available flags see
        ::cudaDevSmResourceGroup_flags.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaDevSmResource *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaDevSmResource.smCount' in found_struct}}
            try:
                str_list += ['smCount : ' + str(self.smCount)]
            except ValueError:
                str_list += ['smCount : <ValueError>']
            {{endif}}
            {{if 'cudaDevSmResource.minSmPartitionSize' in found_struct}}
            try:
                str_list += ['minSmPartitionSize : ' + str(self.minSmPartitionSize)]
            except ValueError:
                str_list += ['minSmPartitionSize : <ValueError>']
            {{endif}}
            {{if 'cudaDevSmResource.smCoscheduledAlignment' in found_struct}}
            try:
                str_list += ['smCoscheduledAlignment : ' + str(self.smCoscheduledAlignment)]
            except ValueError:
                str_list += ['smCoscheduledAlignment : <ValueError>']
            {{endif}}
            {{if 'cudaDevSmResource.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaDevSmResource.smCount' in found_struct}}
    @property
    def smCount(self):
        return self._pvt_ptr[0].smCount
    @smCount.setter
    def smCount(self, unsigned int smCount):
        self._pvt_ptr[0].smCount = smCount
    {{endif}}
    {{if 'cudaDevSmResource.minSmPartitionSize' in found_struct}}
    @property
    def minSmPartitionSize(self):
        return self._pvt_ptr[0].minSmPartitionSize
    @minSmPartitionSize.setter
    def minSmPartitionSize(self, unsigned int minSmPartitionSize):
        self._pvt_ptr[0].minSmPartitionSize = minSmPartitionSize
    {{endif}}
    {{if 'cudaDevSmResource.smCoscheduledAlignment' in found_struct}}
    @property
    def smCoscheduledAlignment(self):
        return self._pvt_ptr[0].smCoscheduledAlignment
    @smCoscheduledAlignment.setter
    def smCoscheduledAlignment(self, unsigned int smCoscheduledAlignment):
        self._pvt_ptr[0].smCoscheduledAlignment = smCoscheduledAlignment
    {{endif}}
    {{if 'cudaDevSmResource.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
{{endif}}
{{if 'cudaDevWorkqueueConfigResource' in found_struct}}

cdef class cudaDevWorkqueueConfigResource:
    """
    Data for workqueue configuration related resources

    Attributes
    ----------
    {{if 'cudaDevWorkqueueConfigResource.device' in found_struct}}
    device : int
        The device on which the workqueue resources are available
    {{endif}}
    {{if 'cudaDevWorkqueueConfigResource.wqConcurrencyLimit' in found_struct}}
    wqConcurrencyLimit : unsigned int
        The expected maximum number of concurrent stream-ordered workloads
    {{endif}}
    {{if 'cudaDevWorkqueueConfigResource.sharingScope' in found_struct}}
    sharingScope : cudaDevWorkqueueConfigScope
        The sharing scope for the workqueue resources
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaDevWorkqueueConfigResource *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaDevWorkqueueConfigResource.device' in found_struct}}
            try:
                str_list += ['device : ' + str(self.device)]
            except ValueError:
                str_list += ['device : <ValueError>']
            {{endif}}
            {{if 'cudaDevWorkqueueConfigResource.wqConcurrencyLimit' in found_struct}}
            try:
                str_list += ['wqConcurrencyLimit : ' + str(self.wqConcurrencyLimit)]
            except ValueError:
                str_list += ['wqConcurrencyLimit : <ValueError>']
            {{endif}}
            {{if 'cudaDevWorkqueueConfigResource.sharingScope' in found_struct}}
            try:
                str_list += ['sharingScope : ' + str(self.sharingScope)]
            except ValueError:
                str_list += ['sharingScope : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaDevWorkqueueConfigResource.device' in found_struct}}
    @property
    def device(self):
        return self._pvt_ptr[0].device
    @device.setter
    def device(self, int device):
        self._pvt_ptr[0].device = device
    {{endif}}
    {{if 'cudaDevWorkqueueConfigResource.wqConcurrencyLimit' in found_struct}}
    @property
    def wqConcurrencyLimit(self):
        return self._pvt_ptr[0].wqConcurrencyLimit
    @wqConcurrencyLimit.setter
    def wqConcurrencyLimit(self, unsigned int wqConcurrencyLimit):
        self._pvt_ptr[0].wqConcurrencyLimit = wqConcurrencyLimit
    {{endif}}
    {{if 'cudaDevWorkqueueConfigResource.sharingScope' in found_struct}}
    @property
    def sharingScope(self):
        return cudaDevWorkqueueConfigScope(self._pvt_ptr[0].sharingScope)
    @sharingScope.setter
    def sharingScope(self, sharingScope not None : cudaDevWorkqueueConfigScope):
        self._pvt_ptr[0].sharingScope = int(sharingScope)
    {{endif}}
{{endif}}
{{if 'cudaDevWorkqueueResource' in found_struct}}

cdef class cudaDevWorkqueueResource:
    """
    Handle to a pre-existing workqueue related resource

    Attributes
    ----------
    {{if 'cudaDevWorkqueueResource.reserved' in found_struct}}
    reserved : bytes
        Reserved for future use
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaDevWorkqueueResource *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaDevWorkqueueResource.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaDevWorkqueueResource.reserved' in found_struct}}
    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(<char*>self._pvt_ptr[0].reserved, 40)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 40:
            raise ValueError("reserved length must be 40, is " + str(len(reserved)))
        for i, b in enumerate(reserved):
            self._pvt_ptr[0].reserved[i] = b
    {{endif}}
{{endif}}
{{if 'cudaDevSmResourceGroupParams_st' in found_struct}}

cdef class cudaDevSmResourceGroupParams_st:
    """
    Input data for splitting SMs

    Attributes
    ----------
    {{if 'cudaDevSmResourceGroupParams_st.smCount' in found_struct}}
    smCount : unsigned int
        The amount of SMs available in this resource.
    {{endif}}
    {{if 'cudaDevSmResourceGroupParams_st.coscheduledSmCount' in found_struct}}
    coscheduledSmCount : unsigned int
        The amount of co-scheduled SMs grouped together for locality
        purposes.
    {{endif}}
    {{if 'cudaDevSmResourceGroupParams_st.preferredCoscheduledSmCount' in found_struct}}
    preferredCoscheduledSmCount : unsigned int
        When possible, combine co-scheduled groups together into larger
        groups of this size.
    {{endif}}
    {{if 'cudaDevSmResourceGroupParams_st.flags' in found_struct}}
    flags : unsigned int
        Combination of `cudaDevSmResourceGroup_flags` values to indicate
        this this group is created.
    {{endif}}
    {{if 'cudaDevSmResourceGroupParams_st.reserved' in found_struct}}
    reserved : list[unsigned int]
        Reserved for future use - ensure this is is zero initialized.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaDevSmResourceGroupParams_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaDevSmResourceGroupParams_st.smCount' in found_struct}}
            try:
                str_list += ['smCount : ' + str(self.smCount)]
            except ValueError:
                str_list += ['smCount : <ValueError>']
            {{endif}}
            {{if 'cudaDevSmResourceGroupParams_st.coscheduledSmCount' in found_struct}}
            try:
                str_list += ['coscheduledSmCount : ' + str(self.coscheduledSmCount)]
            except ValueError:
                str_list += ['coscheduledSmCount : <ValueError>']
            {{endif}}
            {{if 'cudaDevSmResourceGroupParams_st.preferredCoscheduledSmCount' in found_struct}}
            try:
                str_list += ['preferredCoscheduledSmCount : ' + str(self.preferredCoscheduledSmCount)]
            except ValueError:
                str_list += ['preferredCoscheduledSmCount : <ValueError>']
            {{endif}}
            {{if 'cudaDevSmResourceGroupParams_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'cudaDevSmResourceGroupParams_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaDevSmResourceGroupParams_st.smCount' in found_struct}}
    @property
    def smCount(self):
        return self._pvt_ptr[0].smCount
    @smCount.setter
    def smCount(self, unsigned int smCount):
        self._pvt_ptr[0].smCount = smCount
    {{endif}}
    {{if 'cudaDevSmResourceGroupParams_st.coscheduledSmCount' in found_struct}}
    @property
    def coscheduledSmCount(self):
        return self._pvt_ptr[0].coscheduledSmCount
    @coscheduledSmCount.setter
    def coscheduledSmCount(self, unsigned int coscheduledSmCount):
        self._pvt_ptr[0].coscheduledSmCount = coscheduledSmCount
    {{endif}}
    {{if 'cudaDevSmResourceGroupParams_st.preferredCoscheduledSmCount' in found_struct}}
    @property
    def preferredCoscheduledSmCount(self):
        return self._pvt_ptr[0].preferredCoscheduledSmCount
    @preferredCoscheduledSmCount.setter
    def preferredCoscheduledSmCount(self, unsigned int preferredCoscheduledSmCount):
        self._pvt_ptr[0].preferredCoscheduledSmCount = preferredCoscheduledSmCount
    {{endif}}
    {{if 'cudaDevSmResourceGroupParams_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'cudaDevSmResourceGroupParams_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if 'cudaDevResource_st' in found_struct}}

cdef class cudaDevResource_st:
    """
    A tagged union describing different resources identified by the
    type field. This structure should not be directly modified outside
    of the API that created it. struct enumcudaDevResourceTypetype;
    union structcudaDevSmResourcesm;
    structcudaDevWorkqueueConfigResourcewqConfig;
    structcudaDevWorkqueueResourcewq; ; ;  - If `typename` is
    `cudaDevResourceTypeInvalid`, this resoure is not valid and cannot
    be further accessed.    - If `typename` is `cudaDevResourceTypeSm`,
    the cudaDevSmResource structure `sm` is filled in. For example,
    `sm.smCount` will reflect the amount of streaming multiprocessors
    available in this resource.    - If `typename` is
    `cudaDevResourceTypeWorkqueueConfig`, the
    cudaDevWorkqueueConfigResource structure `wqConfig` is filled in.
    - If `typename` is `cudaDevResourceTypeWorkqueue`, the
    cudaDevWorkqueueResource structure `wq` is filled in.

    Attributes
    ----------
    {{if 'cudaDevResource_st.type' in found_struct}}
    type : cudaDevResourceType
        Type of resource, dictates which union field was last set
    {{endif}}
    {{if 'cudaDevResource_st._internal_padding' in found_struct}}
    _internal_padding : bytes

    {{endif}}
    {{if 'cudaDevResource_st.sm' in found_struct}}
    sm : cudaDevSmResource
        Resource corresponding to cudaDevResourceTypeSm `typename`.
    {{endif}}
    {{if 'cudaDevResource_st.wqConfig' in found_struct}}
    wqConfig : cudaDevWorkqueueConfigResource
        Resource corresponding to cudaDevResourceTypeWorkqueueConfig
        `typename`.
    {{endif}}
    {{if 'cudaDevResource_st.wq' in found_struct}}
    wq : cudaDevWorkqueueResource
        Resource corresponding to cudaDevResourceTypeWorkqueue `typename`.
    {{endif}}
    {{if 'cudaDevResource_st._oversize' in found_struct}}
    _oversize : bytes

    {{endif}}
    {{if 'cudaDevResource_st.nextResource' in found_struct}}
    nextResource : cudaDevResource_st

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cyruntime.cudaDevResource_st *>calloc(1, sizeof(cyruntime.cudaDevResource_st))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cyruntime.cudaDevResource_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaDevResource_st.sm' in found_struct}}
        self._sm = cudaDevSmResource(_ptr=<void_ptr>&self._pvt_ptr[0].sm)
        {{endif}}
        {{if 'cudaDevResource_st.wqConfig' in found_struct}}
        self._wqConfig = cudaDevWorkqueueConfigResource(_ptr=<void_ptr>&self._pvt_ptr[0].wqConfig)
        {{endif}}
        {{if 'cudaDevResource_st.wq' in found_struct}}
        self._wq = cudaDevWorkqueueResource(_ptr=<void_ptr>&self._pvt_ptr[0].wq)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
        {{if 'cudaDevResource_st.nextResource' in found_struct}}
        if self._nextResource is not NULL:
            free(self._nextResource)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaDevResource_st.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'cudaDevResource_st._internal_padding' in found_struct}}
            try:
                str_list += ['_internal_padding : ' + str(self._internal_padding)]
            except ValueError:
                str_list += ['_internal_padding : <ValueError>']
            {{endif}}
            {{if 'cudaDevResource_st.sm' in found_struct}}
            try:
                str_list += ['sm :\n' + '\n'.join(['    ' + line for line in str(self.sm).splitlines()])]
            except ValueError:
                str_list += ['sm : <ValueError>']
            {{endif}}
            {{if 'cudaDevResource_st.wqConfig' in found_struct}}
            try:
                str_list += ['wqConfig :\n' + '\n'.join(['    ' + line for line in str(self.wqConfig).splitlines()])]
            except ValueError:
                str_list += ['wqConfig : <ValueError>']
            {{endif}}
            {{if 'cudaDevResource_st.wq' in found_struct}}
            try:
                str_list += ['wq :\n' + '\n'.join(['    ' + line for line in str(self.wq).splitlines()])]
            except ValueError:
                str_list += ['wq : <ValueError>']
            {{endif}}
            {{if 'cudaDevResource_st._oversize' in found_struct}}
            try:
                str_list += ['_oversize : ' + str(self._oversize)]
            except ValueError:
                str_list += ['_oversize : <ValueError>']
            {{endif}}
            {{if 'cudaDevResource_st.nextResource' in found_struct}}
            try:
                str_list += ['nextResource : ' + str(self.nextResource)]
            except ValueError:
                str_list += ['nextResource : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaDevResource_st.type' in found_struct}}
    @property
    def type(self):
        return cudaDevResourceType(self._pvt_ptr[0].type)
    @type.setter
    def type(self, type not None : cudaDevResourceType):
        self._pvt_ptr[0].type = int(type)
    {{endif}}
    {{if 'cudaDevResource_st._internal_padding' in found_struct}}
    @property
    def _internal_padding(self):
        return PyBytes_FromStringAndSize(<char*>self._pvt_ptr[0]._internal_padding, 92)
    @_internal_padding.setter
    def _internal_padding(self, _internal_padding):
        if len(_internal_padding) != 92:
            raise ValueError("_internal_padding length must be 92, is " + str(len(_internal_padding)))
        for i, b in enumerate(_internal_padding):
            self._pvt_ptr[0]._internal_padding[i] = b
    {{endif}}
    {{if 'cudaDevResource_st.sm' in found_struct}}
    @property
    def sm(self):
        return self._sm
    @sm.setter
    def sm(self, sm not None : cudaDevSmResource):
        string.memcpy(&self._pvt_ptr[0].sm, <cyruntime.cudaDevSmResource*><void_ptr>sm.getPtr(), sizeof(self._pvt_ptr[0].sm))
    {{endif}}
    {{if 'cudaDevResource_st.wqConfig' in found_struct}}
    @property
    def wqConfig(self):
        return self._wqConfig
    @wqConfig.setter
    def wqConfig(self, wqConfig not None : cudaDevWorkqueueConfigResource):
        string.memcpy(&self._pvt_ptr[0].wqConfig, <cyruntime.cudaDevWorkqueueConfigResource*><void_ptr>wqConfig.getPtr(), sizeof(self._pvt_ptr[0].wqConfig))
    {{endif}}
    {{if 'cudaDevResource_st.wq' in found_struct}}
    @property
    def wq(self):
        return self._wq
    @wq.setter
    def wq(self, wq not None : cudaDevWorkqueueResource):
        string.memcpy(&self._pvt_ptr[0].wq, <cyruntime.cudaDevWorkqueueResource*><void_ptr>wq.getPtr(), sizeof(self._pvt_ptr[0].wq))
    {{endif}}
    {{if 'cudaDevResource_st._oversize' in found_struct}}
    @property
    def _oversize(self):
        return PyBytes_FromStringAndSize(<char*>self._pvt_ptr[0]._oversize, 40)
    @_oversize.setter
    def _oversize(self, _oversize):
        if len(_oversize) != 40:
            raise ValueError("_oversize length must be 40, is " + str(len(_oversize)))
        for i, b in enumerate(_oversize):
            self._pvt_ptr[0]._oversize[i] = b
    {{endif}}
    {{if 'cudaDevResource_st.nextResource' in found_struct}}
    @property
    def nextResource(self):
        arrs = [<void_ptr>self._pvt_ptr[0].nextResource + x*sizeof(cyruntime.cudaDevResource_st) for x in range(self._nextResource_length)]
        return [cudaDevResource_st(_ptr=arr) for arr in arrs]
    @nextResource.setter
    def nextResource(self, val):
        if len(val) == 0:
            free(self._nextResource)
            self._nextResource_length = 0
            self._pvt_ptr[0].nextResource = NULL
        else:
            if self._nextResource_length != <size_t>len(val):
                free(self._nextResource)
                self._nextResource = <cyruntime.cudaDevResource_st*> calloc(len(val), sizeof(cyruntime.cudaDevResource_st))
                if self._nextResource is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cyruntime.cudaDevResource_st)))
                self._nextResource_length = <size_t>len(val)
                self._pvt_ptr[0].nextResource = self._nextResource
            for idx in range(len(val)):
                string.memcpy(&self._nextResource[idx], (<cudaDevResource_st>val[idx])._pvt_ptr, sizeof(cyruntime.cudaDevResource_st))

    {{endif}}
{{endif}}
{{if 'cudalibraryHostUniversalFunctionAndDataTable' in found_struct}}

cdef class cudalibraryHostUniversalFunctionAndDataTable:
    """
    Attributes
    ----------
    {{if 'cudalibraryHostUniversalFunctionAndDataTable.functionTable' in found_struct}}
    functionTable : Any

    {{endif}}
    {{if 'cudalibraryHostUniversalFunctionAndDataTable.functionWindowSize' in found_struct}}
    functionWindowSize : size_t

    {{endif}}
    {{if 'cudalibraryHostUniversalFunctionAndDataTable.dataTable' in found_struct}}
    dataTable : Any

    {{endif}}
    {{if 'cudalibraryHostUniversalFunctionAndDataTable.dataWindowSize' in found_struct}}
    dataWindowSize : size_t

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudalibraryHostUniversalFunctionAndDataTable *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudalibraryHostUniversalFunctionAndDataTable.functionTable' in found_struct}}
            try:
                str_list += ['functionTable : ' + hex(self.functionTable)]
            except ValueError:
                str_list += ['functionTable : <ValueError>']
            {{endif}}
            {{if 'cudalibraryHostUniversalFunctionAndDataTable.functionWindowSize' in found_struct}}
            try:
                str_list += ['functionWindowSize : ' + str(self.functionWindowSize)]
            except ValueError:
                str_list += ['functionWindowSize : <ValueError>']
            {{endif}}
            {{if 'cudalibraryHostUniversalFunctionAndDataTable.dataTable' in found_struct}}
            try:
                str_list += ['dataTable : ' + hex(self.dataTable)]
            except ValueError:
                str_list += ['dataTable : <ValueError>']
            {{endif}}
            {{if 'cudalibraryHostUniversalFunctionAndDataTable.dataWindowSize' in found_struct}}
            try:
                str_list += ['dataWindowSize : ' + str(self.dataWindowSize)]
            except ValueError:
                str_list += ['dataWindowSize : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudalibraryHostUniversalFunctionAndDataTable.functionTable' in found_struct}}
    @property
    def functionTable(self):
        return <void_ptr>self._pvt_ptr[0].functionTable
    @functionTable.setter
    def functionTable(self, functionTable):
        _cfunctionTable = _HelperInputVoidPtr(functionTable)
        self._pvt_ptr[0].functionTable = <void*><void_ptr>_cfunctionTable.cptr
    {{endif}}
    {{if 'cudalibraryHostUniversalFunctionAndDataTable.functionWindowSize' in found_struct}}
    @property
    def functionWindowSize(self):
        return self._pvt_ptr[0].functionWindowSize
    @functionWindowSize.setter
    def functionWindowSize(self, size_t functionWindowSize):
        self._pvt_ptr[0].functionWindowSize = functionWindowSize
    {{endif}}
    {{if 'cudalibraryHostUniversalFunctionAndDataTable.dataTable' in found_struct}}
    @property
    def dataTable(self):
        return <void_ptr>self._pvt_ptr[0].dataTable
    @dataTable.setter
    def dataTable(self, dataTable):
        _cdataTable = _HelperInputVoidPtr(dataTable)
        self._pvt_ptr[0].dataTable = <void*><void_ptr>_cdataTable.cptr
    {{endif}}
    {{if 'cudalibraryHostUniversalFunctionAndDataTable.dataWindowSize' in found_struct}}
    @property
    def dataWindowSize(self):
        return self._pvt_ptr[0].dataWindowSize
    @dataWindowSize.setter
    def dataWindowSize(self, size_t dataWindowSize):
        self._pvt_ptr[0].dataWindowSize = dataWindowSize
    {{endif}}
{{endif}}
{{if 'cudaKernelNodeParams' in found_struct}}

cdef class cudaKernelNodeParams:
    """
    CUDA GPU kernel node parameters

    Attributes
    ----------
    {{if 'cudaKernelNodeParams.func' in found_struct}}
    func : Any
        Kernel to launch
    {{endif}}
    {{if 'cudaKernelNodeParams.gridDim' in found_struct}}
    gridDim : dim3
        Grid dimensions
    {{endif}}
    {{if 'cudaKernelNodeParams.blockDim' in found_struct}}
    blockDim : dim3
        Block dimensions
    {{endif}}
    {{if 'cudaKernelNodeParams.sharedMemBytes' in found_struct}}
    sharedMemBytes : unsigned int
        Dynamic shared-memory size per thread block in bytes
    {{endif}}
    {{if 'cudaKernelNodeParams.kernelParams' in found_struct}}
    kernelParams : Any
        Array of pointers to individual kernel arguments
    {{endif}}
    {{if 'cudaKernelNodeParams.extra' in found_struct}}
    extra : Any
        Pointer to kernel arguments in the "extra" format
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaKernelNodeParams *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaKernelNodeParams.gridDim' in found_struct}}
        self._gridDim = dim3(_ptr=<void_ptr>&self._pvt_ptr[0].gridDim)
        {{endif}}
        {{if 'cudaKernelNodeParams.blockDim' in found_struct}}
        self._blockDim = dim3(_ptr=<void_ptr>&self._pvt_ptr[0].blockDim)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaKernelNodeParams.func' in found_struct}}
            try:
                str_list += ['func : ' + hex(self.func)]
            except ValueError:
                str_list += ['func : <ValueError>']
            {{endif}}
            {{if 'cudaKernelNodeParams.gridDim' in found_struct}}
            try:
                str_list += ['gridDim :\n' + '\n'.join(['    ' + line for line in str(self.gridDim).splitlines()])]
            except ValueError:
                str_list += ['gridDim : <ValueError>']
            {{endif}}
            {{if 'cudaKernelNodeParams.blockDim' in found_struct}}
            try:
                str_list += ['blockDim :\n' + '\n'.join(['    ' + line for line in str(self.blockDim).splitlines()])]
            except ValueError:
                str_list += ['blockDim : <ValueError>']
            {{endif}}
            {{if 'cudaKernelNodeParams.sharedMemBytes' in found_struct}}
            try:
                str_list += ['sharedMemBytes : ' + str(self.sharedMemBytes)]
            except ValueError:
                str_list += ['sharedMemBytes : <ValueError>']
            {{endif}}
            {{if 'cudaKernelNodeParams.kernelParams' in found_struct}}
            try:
                str_list += ['kernelParams : ' + str(self.kernelParams)]
            except ValueError:
                str_list += ['kernelParams : <ValueError>']
            {{endif}}
            {{if 'cudaKernelNodeParams.extra' in found_struct}}
            try:
                str_list += ['extra : ' + str(self.extra)]
            except ValueError:
                str_list += ['extra : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaKernelNodeParams.func' in found_struct}}
    @property
    def func(self):
        return <void_ptr>self._pvt_ptr[0].func
    @func.setter
    def func(self, func):
        _cfunc = _HelperInputVoidPtr(func)
        self._pvt_ptr[0].func = <void*><void_ptr>_cfunc.cptr
    {{endif}}
    {{if 'cudaKernelNodeParams.gridDim' in found_struct}}
    @property
    def gridDim(self):
        return self._gridDim
    @gridDim.setter
    def gridDim(self, gridDim not None : dim3):
        string.memcpy(&self._pvt_ptr[0].gridDim, <cyruntime.dim3*><void_ptr>gridDim.getPtr(), sizeof(self._pvt_ptr[0].gridDim))
    {{endif}}
    {{if 'cudaKernelNodeParams.blockDim' in found_struct}}
    @property
    def blockDim(self):
        return self._blockDim
    @blockDim.setter
    def blockDim(self, blockDim not None : dim3):
        string.memcpy(&self._pvt_ptr[0].blockDim, <cyruntime.dim3*><void_ptr>blockDim.getPtr(), sizeof(self._pvt_ptr[0].blockDim))
    {{endif}}
    {{if 'cudaKernelNodeParams.sharedMemBytes' in found_struct}}
    @property
    def sharedMemBytes(self):
        return self._pvt_ptr[0].sharedMemBytes
    @sharedMemBytes.setter
    def sharedMemBytes(self, unsigned int sharedMemBytes):
        self._pvt_ptr[0].sharedMemBytes = sharedMemBytes
    {{endif}}
    {{if 'cudaKernelNodeParams.kernelParams' in found_struct}}
    @property
    def kernelParams(self):
        return <void_ptr>self._pvt_ptr[0].kernelParams
    @kernelParams.setter
    def kernelParams(self, kernelParams):
        self._cykernelParams = _HelperKernelParams(kernelParams)
        self._pvt_ptr[0].kernelParams = <void**><void_ptr>self._cykernelParams.ckernelParams
    {{endif}}
    {{if 'cudaKernelNodeParams.extra' in found_struct}}
    @property
    def extra(self):
        return <void_ptr>self._pvt_ptr[0].extra
    @extra.setter
    def extra(self, void_ptr extra):
        self._pvt_ptr[0].extra = <void**>extra
    {{endif}}
{{endif}}
{{if 'cudaKernelNodeParamsV2' in found_struct}}

cdef class cudaKernelNodeParamsV2:
    """
    CUDA GPU kernel node parameters

    Attributes
    ----------
    {{if 'cudaKernelNodeParamsV2.func' in found_struct}}
    func : Any
        Kernel to launch
    {{endif}}
    {{if 'cudaKernelNodeParamsV2.gridDim' in found_struct}}
    gridDim : dim3
        Grid dimensions
    {{endif}}
    {{if 'cudaKernelNodeParamsV2.blockDim' in found_struct}}
    blockDim : dim3
        Block dimensions
    {{endif}}
    {{if 'cudaKernelNodeParamsV2.sharedMemBytes' in found_struct}}
    sharedMemBytes : unsigned int
        Dynamic shared-memory size per thread block in bytes
    {{endif}}
    {{if 'cudaKernelNodeParamsV2.kernelParams' in found_struct}}
    kernelParams : Any
        Array of pointers to individual kernel arguments
    {{endif}}
    {{if 'cudaKernelNodeParamsV2.extra' in found_struct}}
    extra : Any
        Pointer to kernel arguments in the "extra" format
    {{endif}}
    {{if 'cudaKernelNodeParamsV2.ctx' in found_struct}}
    ctx : cudaExecutionContext_t
        Context in which to run the kernel. If NULL will try to use the
        current context.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaKernelNodeParamsV2 *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaKernelNodeParamsV2.gridDim' in found_struct}}
        self._gridDim = dim3(_ptr=<void_ptr>&self._pvt_ptr[0].gridDim)
        {{endif}}
        {{if 'cudaKernelNodeParamsV2.blockDim' in found_struct}}
        self._blockDim = dim3(_ptr=<void_ptr>&self._pvt_ptr[0].blockDim)
        {{endif}}
        {{if 'cudaKernelNodeParamsV2.ctx' in found_struct}}
        self._ctx = cudaExecutionContext_t(_ptr=<void_ptr>&self._pvt_ptr[0].ctx)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaKernelNodeParamsV2.func' in found_struct}}
            try:
                str_list += ['func : ' + hex(self.func)]
            except ValueError:
                str_list += ['func : <ValueError>']
            {{endif}}
            {{if 'cudaKernelNodeParamsV2.gridDim' in found_struct}}
            try:
                str_list += ['gridDim :\n' + '\n'.join(['    ' + line for line in str(self.gridDim).splitlines()])]
            except ValueError:
                str_list += ['gridDim : <ValueError>']
            {{endif}}
            {{if 'cudaKernelNodeParamsV2.blockDim' in found_struct}}
            try:
                str_list += ['blockDim :\n' + '\n'.join(['    ' + line for line in str(self.blockDim).splitlines()])]
            except ValueError:
                str_list += ['blockDim : <ValueError>']
            {{endif}}
            {{if 'cudaKernelNodeParamsV2.sharedMemBytes' in found_struct}}
            try:
                str_list += ['sharedMemBytes : ' + str(self.sharedMemBytes)]
            except ValueError:
                str_list += ['sharedMemBytes : <ValueError>']
            {{endif}}
            {{if 'cudaKernelNodeParamsV2.kernelParams' in found_struct}}
            try:
                str_list += ['kernelParams : ' + str(self.kernelParams)]
            except ValueError:
                str_list += ['kernelParams : <ValueError>']
            {{endif}}
            {{if 'cudaKernelNodeParamsV2.extra' in found_struct}}
            try:
                str_list += ['extra : ' + str(self.extra)]
            except ValueError:
                str_list += ['extra : <ValueError>']
            {{endif}}
            {{if 'cudaKernelNodeParamsV2.ctx' in found_struct}}
            try:
                str_list += ['ctx : ' + str(self.ctx)]
            except ValueError:
                str_list += ['ctx : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaKernelNodeParamsV2.func' in found_struct}}
    @property
    def func(self):
        return <void_ptr>self._pvt_ptr[0].func
    @func.setter
    def func(self, func):
        _cfunc = _HelperInputVoidPtr(func)
        self._pvt_ptr[0].func = <void*><void_ptr>_cfunc.cptr
    {{endif}}
    {{if 'cudaKernelNodeParamsV2.gridDim' in found_struct}}
    @property
    def gridDim(self):
        return self._gridDim
    @gridDim.setter
    def gridDim(self, gridDim not None : dim3):
        string.memcpy(&self._pvt_ptr[0].gridDim, <cyruntime.dim3*><void_ptr>gridDim.getPtr(), sizeof(self._pvt_ptr[0].gridDim))
    {{endif}}
    {{if 'cudaKernelNodeParamsV2.blockDim' in found_struct}}
    @property
    def blockDim(self):
        return self._blockDim
    @blockDim.setter
    def blockDim(self, blockDim not None : dim3):
        string.memcpy(&self._pvt_ptr[0].blockDim, <cyruntime.dim3*><void_ptr>blockDim.getPtr(), sizeof(self._pvt_ptr[0].blockDim))
    {{endif}}
    {{if 'cudaKernelNodeParamsV2.sharedMemBytes' in found_struct}}
    @property
    def sharedMemBytes(self):
        return self._pvt_ptr[0].sharedMemBytes
    @sharedMemBytes.setter
    def sharedMemBytes(self, unsigned int sharedMemBytes):
        self._pvt_ptr[0].sharedMemBytes = sharedMemBytes
    {{endif}}
    {{if 'cudaKernelNodeParamsV2.kernelParams' in found_struct}}
    @property
    def kernelParams(self):
        return <void_ptr>self._pvt_ptr[0].kernelParams
    @kernelParams.setter
    def kernelParams(self, kernelParams):
        self._cykernelParams = _HelperKernelParams(kernelParams)
        self._pvt_ptr[0].kernelParams = <void**><void_ptr>self._cykernelParams.ckernelParams
    {{endif}}
    {{if 'cudaKernelNodeParamsV2.extra' in found_struct}}
    @property
    def extra(self):
        return <void_ptr>self._pvt_ptr[0].extra
    @extra.setter
    def extra(self, void_ptr extra):
        self._pvt_ptr[0].extra = <void**>extra
    {{endif}}
    {{if 'cudaKernelNodeParamsV2.ctx' in found_struct}}
    @property
    def ctx(self):
        return self._ctx
    @ctx.setter
    def ctx(self, ctx):
        cdef cyruntime.cudaExecutionContext_t cyctx
        if ctx is None:
            cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>0
        elif isinstance(ctx, (cudaExecutionContext_t,)):
            pctx = int(ctx)
            cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>pctx
        else:
            pctx = int(cudaExecutionContext_t(ctx))
            cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>pctx
        self._ctx._pvt_ptr[0] = cyctx
    {{endif}}
{{endif}}
{{if 'cudaExternalSemaphoreSignalNodeParams' in found_struct}}

cdef class cudaExternalSemaphoreSignalNodeParams:
    """
    External semaphore signal node parameters

    Attributes
    ----------
    {{if 'cudaExternalSemaphoreSignalNodeParams.extSemArray' in found_struct}}
    extSemArray : cudaExternalSemaphore_t
        Array of external semaphore handles.
    {{endif}}
    {{if 'cudaExternalSemaphoreSignalNodeParams.paramsArray' in found_struct}}
    paramsArray : cudaExternalSemaphoreSignalParams
        Array of external semaphore signal parameters.
    {{endif}}
    {{if 'cudaExternalSemaphoreSignalNodeParams.numExtSems' in found_struct}}
    numExtSems : unsigned int
        Number of handles and parameters supplied in extSemArray and
        paramsArray.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaExternalSemaphoreSignalNodeParams *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
        {{if 'cudaExternalSemaphoreSignalNodeParams.extSemArray' in found_struct}}
        if self._extSemArray is not NULL:
            free(self._extSemArray)
        {{endif}}
        {{if 'cudaExternalSemaphoreSignalNodeParams.paramsArray' in found_struct}}
        if self._paramsArray is not NULL:
            free(self._paramsArray)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalSemaphoreSignalNodeParams.extSemArray' in found_struct}}
            try:
                str_list += ['extSemArray : ' + str(self.extSemArray)]
            except ValueError:
                str_list += ['extSemArray : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreSignalNodeParams.paramsArray' in found_struct}}
            try:
                str_list += ['paramsArray : ' + str(self.paramsArray)]
            except ValueError:
                str_list += ['paramsArray : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreSignalNodeParams.numExtSems' in found_struct}}
            try:
                str_list += ['numExtSems : ' + str(self.numExtSems)]
            except ValueError:
                str_list += ['numExtSems : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalSemaphoreSignalNodeParams.extSemArray' in found_struct}}
    @property
    def extSemArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].extSemArray + x*sizeof(cyruntime.cudaExternalSemaphore_t) for x in range(self._extSemArray_length)]
        return [cudaExternalSemaphore_t(_ptr=arr) for arr in arrs]
    @extSemArray.setter
    def extSemArray(self, val):
        if len(val) == 0:
            free(self._extSemArray)
            self._extSemArray_length = 0
            self._pvt_ptr[0].extSemArray = NULL
        else:
            if self._extSemArray_length != <size_t>len(val):
                free(self._extSemArray)
                self._extSemArray = <cyruntime.cudaExternalSemaphore_t*> calloc(len(val), sizeof(cyruntime.cudaExternalSemaphore_t))
                if self._extSemArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cyruntime.cudaExternalSemaphore_t)))
                self._extSemArray_length = <size_t>len(val)
                self._pvt_ptr[0].extSemArray = self._extSemArray
            for idx in range(len(val)):
                self._extSemArray[idx] = (<cudaExternalSemaphore_t>val[idx])._pvt_ptr[0]

    {{endif}}
    {{if 'cudaExternalSemaphoreSignalNodeParams.paramsArray' in found_struct}}
    @property
    def paramsArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].paramsArray + x*sizeof(cyruntime.cudaExternalSemaphoreSignalParams) for x in range(self._paramsArray_length)]
        return [cudaExternalSemaphoreSignalParams(_ptr=arr) for arr in arrs]
    @paramsArray.setter
    def paramsArray(self, val):
        if len(val) == 0:
            free(self._paramsArray)
            self._paramsArray_length = 0
            self._pvt_ptr[0].paramsArray = NULL
        else:
            if self._paramsArray_length != <size_t>len(val):
                free(self._paramsArray)
                self._paramsArray = <cyruntime.cudaExternalSemaphoreSignalParams*> calloc(len(val), sizeof(cyruntime.cudaExternalSemaphoreSignalParams))
                if self._paramsArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cyruntime.cudaExternalSemaphoreSignalParams)))
                self._paramsArray_length = <size_t>len(val)
                self._pvt_ptr[0].paramsArray = self._paramsArray
            for idx in range(len(val)):
                string.memcpy(&self._paramsArray[idx], (<cudaExternalSemaphoreSignalParams>val[idx])._pvt_ptr, sizeof(cyruntime.cudaExternalSemaphoreSignalParams))

    {{endif}}
    {{if 'cudaExternalSemaphoreSignalNodeParams.numExtSems' in found_struct}}
    @property
    def numExtSems(self):
        return self._pvt_ptr[0].numExtSems
    @numExtSems.setter
    def numExtSems(self, unsigned int numExtSems):
        self._pvt_ptr[0].numExtSems = numExtSems
    {{endif}}
{{endif}}
{{if 'cudaExternalSemaphoreSignalNodeParamsV2' in found_struct}}

cdef class cudaExternalSemaphoreSignalNodeParamsV2:
    """
    External semaphore signal node parameters

    Attributes
    ----------
    {{if 'cudaExternalSemaphoreSignalNodeParamsV2.extSemArray' in found_struct}}
    extSemArray : cudaExternalSemaphore_t
        Array of external semaphore handles.
    {{endif}}
    {{if 'cudaExternalSemaphoreSignalNodeParamsV2.paramsArray' in found_struct}}
    paramsArray : cudaExternalSemaphoreSignalParams
        Array of external semaphore signal parameters.
    {{endif}}
    {{if 'cudaExternalSemaphoreSignalNodeParamsV2.numExtSems' in found_struct}}
    numExtSems : unsigned int
        Number of handles and parameters supplied in extSemArray and
        paramsArray.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaExternalSemaphoreSignalNodeParamsV2 *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
        {{if 'cudaExternalSemaphoreSignalNodeParamsV2.extSemArray' in found_struct}}
        if self._extSemArray is not NULL:
            free(self._extSemArray)
        {{endif}}
        {{if 'cudaExternalSemaphoreSignalNodeParamsV2.paramsArray' in found_struct}}
        if self._paramsArray is not NULL:
            free(self._paramsArray)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalSemaphoreSignalNodeParamsV2.extSemArray' in found_struct}}
            try:
                str_list += ['extSemArray : ' + str(self.extSemArray)]
            except ValueError:
                str_list += ['extSemArray : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreSignalNodeParamsV2.paramsArray' in found_struct}}
            try:
                str_list += ['paramsArray : ' + str(self.paramsArray)]
            except ValueError:
                str_list += ['paramsArray : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreSignalNodeParamsV2.numExtSems' in found_struct}}
            try:
                str_list += ['numExtSems : ' + str(self.numExtSems)]
            except ValueError:
                str_list += ['numExtSems : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalSemaphoreSignalNodeParamsV2.extSemArray' in found_struct}}
    @property
    def extSemArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].extSemArray + x*sizeof(cyruntime.cudaExternalSemaphore_t) for x in range(self._extSemArray_length)]
        return [cudaExternalSemaphore_t(_ptr=arr) for arr in arrs]
    @extSemArray.setter
    def extSemArray(self, val):
        if len(val) == 0:
            free(self._extSemArray)
            self._extSemArray_length = 0
            self._pvt_ptr[0].extSemArray = NULL
        else:
            if self._extSemArray_length != <size_t>len(val):
                free(self._extSemArray)
                self._extSemArray = <cyruntime.cudaExternalSemaphore_t*> calloc(len(val), sizeof(cyruntime.cudaExternalSemaphore_t))
                if self._extSemArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cyruntime.cudaExternalSemaphore_t)))
                self._extSemArray_length = <size_t>len(val)
                self._pvt_ptr[0].extSemArray = self._extSemArray
            for idx in range(len(val)):
                self._extSemArray[idx] = (<cudaExternalSemaphore_t>val[idx])._pvt_ptr[0]

    {{endif}}
    {{if 'cudaExternalSemaphoreSignalNodeParamsV2.paramsArray' in found_struct}}
    @property
    def paramsArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].paramsArray + x*sizeof(cyruntime.cudaExternalSemaphoreSignalParams) for x in range(self._paramsArray_length)]
        return [cudaExternalSemaphoreSignalParams(_ptr=arr) for arr in arrs]
    @paramsArray.setter
    def paramsArray(self, val):
        if len(val) == 0:
            free(self._paramsArray)
            self._paramsArray_length = 0
            self._pvt_ptr[0].paramsArray = NULL
        else:
            if self._paramsArray_length != <size_t>len(val):
                free(self._paramsArray)
                self._paramsArray = <cyruntime.cudaExternalSemaphoreSignalParams*> calloc(len(val), sizeof(cyruntime.cudaExternalSemaphoreSignalParams))
                if self._paramsArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cyruntime.cudaExternalSemaphoreSignalParams)))
                self._paramsArray_length = <size_t>len(val)
                self._pvt_ptr[0].paramsArray = self._paramsArray
            for idx in range(len(val)):
                string.memcpy(&self._paramsArray[idx], (<cudaExternalSemaphoreSignalParams>val[idx])._pvt_ptr, sizeof(cyruntime.cudaExternalSemaphoreSignalParams))

    {{endif}}
    {{if 'cudaExternalSemaphoreSignalNodeParamsV2.numExtSems' in found_struct}}
    @property
    def numExtSems(self):
        return self._pvt_ptr[0].numExtSems
    @numExtSems.setter
    def numExtSems(self, unsigned int numExtSems):
        self._pvt_ptr[0].numExtSems = numExtSems
    {{endif}}
{{endif}}
{{if 'cudaExternalSemaphoreWaitNodeParams' in found_struct}}

cdef class cudaExternalSemaphoreWaitNodeParams:
    """
    External semaphore wait node parameters

    Attributes
    ----------
    {{if 'cudaExternalSemaphoreWaitNodeParams.extSemArray' in found_struct}}
    extSemArray : cudaExternalSemaphore_t
        Array of external semaphore handles.
    {{endif}}
    {{if 'cudaExternalSemaphoreWaitNodeParams.paramsArray' in found_struct}}
    paramsArray : cudaExternalSemaphoreWaitParams
        Array of external semaphore wait parameters.
    {{endif}}
    {{if 'cudaExternalSemaphoreWaitNodeParams.numExtSems' in found_struct}}
    numExtSems : unsigned int
        Number of handles and parameters supplied in extSemArray and
        paramsArray.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaExternalSemaphoreWaitNodeParams *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
        {{if 'cudaExternalSemaphoreWaitNodeParams.extSemArray' in found_struct}}
        if self._extSemArray is not NULL:
            free(self._extSemArray)
        {{endif}}
        {{if 'cudaExternalSemaphoreWaitNodeParams.paramsArray' in found_struct}}
        if self._paramsArray is not NULL:
            free(self._paramsArray)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalSemaphoreWaitNodeParams.extSemArray' in found_struct}}
            try:
                str_list += ['extSemArray : ' + str(self.extSemArray)]
            except ValueError:
                str_list += ['extSemArray : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreWaitNodeParams.paramsArray' in found_struct}}
            try:
                str_list += ['paramsArray : ' + str(self.paramsArray)]
            except ValueError:
                str_list += ['paramsArray : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreWaitNodeParams.numExtSems' in found_struct}}
            try:
                str_list += ['numExtSems : ' + str(self.numExtSems)]
            except ValueError:
                str_list += ['numExtSems : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalSemaphoreWaitNodeParams.extSemArray' in found_struct}}
    @property
    def extSemArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].extSemArray + x*sizeof(cyruntime.cudaExternalSemaphore_t) for x in range(self._extSemArray_length)]
        return [cudaExternalSemaphore_t(_ptr=arr) for arr in arrs]
    @extSemArray.setter
    def extSemArray(self, val):
        if len(val) == 0:
            free(self._extSemArray)
            self._extSemArray_length = 0
            self._pvt_ptr[0].extSemArray = NULL
        else:
            if self._extSemArray_length != <size_t>len(val):
                free(self._extSemArray)
                self._extSemArray = <cyruntime.cudaExternalSemaphore_t*> calloc(len(val), sizeof(cyruntime.cudaExternalSemaphore_t))
                if self._extSemArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cyruntime.cudaExternalSemaphore_t)))
                self._extSemArray_length = <size_t>len(val)
                self._pvt_ptr[0].extSemArray = self._extSemArray
            for idx in range(len(val)):
                self._extSemArray[idx] = (<cudaExternalSemaphore_t>val[idx])._pvt_ptr[0]

    {{endif}}
    {{if 'cudaExternalSemaphoreWaitNodeParams.paramsArray' in found_struct}}
    @property
    def paramsArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].paramsArray + x*sizeof(cyruntime.cudaExternalSemaphoreWaitParams) for x in range(self._paramsArray_length)]
        return [cudaExternalSemaphoreWaitParams(_ptr=arr) for arr in arrs]
    @paramsArray.setter
    def paramsArray(self, val):
        if len(val) == 0:
            free(self._paramsArray)
            self._paramsArray_length = 0
            self._pvt_ptr[0].paramsArray = NULL
        else:
            if self._paramsArray_length != <size_t>len(val):
                free(self._paramsArray)
                self._paramsArray = <cyruntime.cudaExternalSemaphoreWaitParams*> calloc(len(val), sizeof(cyruntime.cudaExternalSemaphoreWaitParams))
                if self._paramsArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cyruntime.cudaExternalSemaphoreWaitParams)))
                self._paramsArray_length = <size_t>len(val)
                self._pvt_ptr[0].paramsArray = self._paramsArray
            for idx in range(len(val)):
                string.memcpy(&self._paramsArray[idx], (<cudaExternalSemaphoreWaitParams>val[idx])._pvt_ptr, sizeof(cyruntime.cudaExternalSemaphoreWaitParams))

    {{endif}}
    {{if 'cudaExternalSemaphoreWaitNodeParams.numExtSems' in found_struct}}
    @property
    def numExtSems(self):
        return self._pvt_ptr[0].numExtSems
    @numExtSems.setter
    def numExtSems(self, unsigned int numExtSems):
        self._pvt_ptr[0].numExtSems = numExtSems
    {{endif}}
{{endif}}
{{if 'cudaExternalSemaphoreWaitNodeParamsV2' in found_struct}}

cdef class cudaExternalSemaphoreWaitNodeParamsV2:
    """
    External semaphore wait node parameters

    Attributes
    ----------
    {{if 'cudaExternalSemaphoreWaitNodeParamsV2.extSemArray' in found_struct}}
    extSemArray : cudaExternalSemaphore_t
        Array of external semaphore handles.
    {{endif}}
    {{if 'cudaExternalSemaphoreWaitNodeParamsV2.paramsArray' in found_struct}}
    paramsArray : cudaExternalSemaphoreWaitParams
        Array of external semaphore wait parameters.
    {{endif}}
    {{if 'cudaExternalSemaphoreWaitNodeParamsV2.numExtSems' in found_struct}}
    numExtSems : unsigned int
        Number of handles and parameters supplied in extSemArray and
        paramsArray.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaExternalSemaphoreWaitNodeParamsV2 *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
        {{if 'cudaExternalSemaphoreWaitNodeParamsV2.extSemArray' in found_struct}}
        if self._extSemArray is not NULL:
            free(self._extSemArray)
        {{endif}}
        {{if 'cudaExternalSemaphoreWaitNodeParamsV2.paramsArray' in found_struct}}
        if self._paramsArray is not NULL:
            free(self._paramsArray)
        {{endif}}
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaExternalSemaphoreWaitNodeParamsV2.extSemArray' in found_struct}}
            try:
                str_list += ['extSemArray : ' + str(self.extSemArray)]
            except ValueError:
                str_list += ['extSemArray : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreWaitNodeParamsV2.paramsArray' in found_struct}}
            try:
                str_list += ['paramsArray : ' + str(self.paramsArray)]
            except ValueError:
                str_list += ['paramsArray : <ValueError>']
            {{endif}}
            {{if 'cudaExternalSemaphoreWaitNodeParamsV2.numExtSems' in found_struct}}
            try:
                str_list += ['numExtSems : ' + str(self.numExtSems)]
            except ValueError:
                str_list += ['numExtSems : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaExternalSemaphoreWaitNodeParamsV2.extSemArray' in found_struct}}
    @property
    def extSemArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].extSemArray + x*sizeof(cyruntime.cudaExternalSemaphore_t) for x in range(self._extSemArray_length)]
        return [cudaExternalSemaphore_t(_ptr=arr) for arr in arrs]
    @extSemArray.setter
    def extSemArray(self, val):
        if len(val) == 0:
            free(self._extSemArray)
            self._extSemArray_length = 0
            self._pvt_ptr[0].extSemArray = NULL
        else:
            if self._extSemArray_length != <size_t>len(val):
                free(self._extSemArray)
                self._extSemArray = <cyruntime.cudaExternalSemaphore_t*> calloc(len(val), sizeof(cyruntime.cudaExternalSemaphore_t))
                if self._extSemArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cyruntime.cudaExternalSemaphore_t)))
                self._extSemArray_length = <size_t>len(val)
                self._pvt_ptr[0].extSemArray = self._extSemArray
            for idx in range(len(val)):
                self._extSemArray[idx] = (<cudaExternalSemaphore_t>val[idx])._pvt_ptr[0]

    {{endif}}
    {{if 'cudaExternalSemaphoreWaitNodeParamsV2.paramsArray' in found_struct}}
    @property
    def paramsArray(self):
        arrs = [<void_ptr>self._pvt_ptr[0].paramsArray + x*sizeof(cyruntime.cudaExternalSemaphoreWaitParams) for x in range(self._paramsArray_length)]
        return [cudaExternalSemaphoreWaitParams(_ptr=arr) for arr in arrs]
    @paramsArray.setter
    def paramsArray(self, val):
        if len(val) == 0:
            free(self._paramsArray)
            self._paramsArray_length = 0
            self._pvt_ptr[0].paramsArray = NULL
        else:
            if self._paramsArray_length != <size_t>len(val):
                free(self._paramsArray)
                self._paramsArray = <cyruntime.cudaExternalSemaphoreWaitParams*> calloc(len(val), sizeof(cyruntime.cudaExternalSemaphoreWaitParams))
                if self._paramsArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(cyruntime.cudaExternalSemaphoreWaitParams)))
                self._paramsArray_length = <size_t>len(val)
                self._pvt_ptr[0].paramsArray = self._paramsArray
            for idx in range(len(val)):
                string.memcpy(&self._paramsArray[idx], (<cudaExternalSemaphoreWaitParams>val[idx])._pvt_ptr, sizeof(cyruntime.cudaExternalSemaphoreWaitParams))

    {{endif}}
    {{if 'cudaExternalSemaphoreWaitNodeParamsV2.numExtSems' in found_struct}}
    @property
    def numExtSems(self):
        return self._pvt_ptr[0].numExtSems
    @numExtSems.setter
    def numExtSems(self, unsigned int numExtSems):
        self._pvt_ptr[0].numExtSems = numExtSems
    {{endif}}
{{endif}}
{{if 'cudaConditionalNodeParams' in found_struct}}

cdef class cudaConditionalNodeParams:
    """
    CUDA conditional node parameters

    Attributes
    ----------
    {{if 'cudaConditionalNodeParams.handle' in found_struct}}
    handle : cudaGraphConditionalHandle
        Conditional node handle. Handles must be created in advance of
        creating the node using cudaGraphConditionalHandleCreate.
    {{endif}}
    {{if 'cudaConditionalNodeParams.type' in found_struct}}
    type : cudaGraphConditionalNodeType
        Type of conditional node.
    {{endif}}
    {{if 'cudaConditionalNodeParams.size' in found_struct}}
    size : unsigned int
        Size of graph output array. Allowed values are 1 for
        cudaGraphCondTypeWhile, 1 or 2 for cudaGraphCondTypeIf, or any
        value greater than zero for cudaGraphCondTypeSwitch.
    {{endif}}
    {{if 'cudaConditionalNodeParams.phGraph_out' in found_struct}}
    phGraph_out : cudaGraph_t
        CUDA-owned array populated with conditional node child graphs
        during creation of the node. Valid for the lifetime of the
        conditional node. The contents of the graph(s) are subject to the
        following constraints:   - Allowed node types are kernel nodes,
        empty nodes, child graphs, memsets, memcopies, and conditionals.
        This applies recursively to child graphs and conditional bodies.
        - All kernels, including kernels in nested conditionals or child
        graphs at any level, must belong to the same CUDA context.
        These graphs may be populated using graph node creation APIs or
        cudaStreamBeginCaptureToGraph. cudaGraphCondTypeIf: phGraph_out[0]
        is executed when the condition is non-zero. If `size` == 2,
        phGraph_out[1] will be executed when the condition is zero.
        cudaGraphCondTypeWhile: phGraph_out[0] is executed as long as the
        condition is non-zero. cudaGraphCondTypeSwitch: phGraph_out[n] is
        executed when the condition is equal to n. If the condition >=
        `size`, no body graph is executed.
    {{endif}}
    {{if 'cudaConditionalNodeParams.ctx' in found_struct}}
    ctx : cudaExecutionContext_t
        CUDA Execution Context
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaConditionalNodeParams *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaConditionalNodeParams.handle' in found_struct}}
        self._handle = cudaGraphConditionalHandle(_ptr=<void_ptr>&self._pvt_ptr[0].handle)
        {{endif}}
        {{if 'cudaConditionalNodeParams.ctx' in found_struct}}
        self._ctx = cudaExecutionContext_t(_ptr=<void_ptr>&self._pvt_ptr[0].ctx)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaConditionalNodeParams.handle' in found_struct}}
            try:
                str_list += ['handle : ' + str(self.handle)]
            except ValueError:
                str_list += ['handle : <ValueError>']
            {{endif}}
            {{if 'cudaConditionalNodeParams.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'cudaConditionalNodeParams.size' in found_struct}}
            try:
                str_list += ['size : ' + str(self.size)]
            except ValueError:
                str_list += ['size : <ValueError>']
            {{endif}}
            {{if 'cudaConditionalNodeParams.phGraph_out' in found_struct}}
            try:
                str_list += ['phGraph_out : ' + str(self.phGraph_out)]
            except ValueError:
                str_list += ['phGraph_out : <ValueError>']
            {{endif}}
            {{if 'cudaConditionalNodeParams.ctx' in found_struct}}
            try:
                str_list += ['ctx : ' + str(self.ctx)]
            except ValueError:
                str_list += ['ctx : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaConditionalNodeParams.handle' in found_struct}}
    @property
    def handle(self):
        return self._handle
    @handle.setter
    def handle(self, handle):
        cdef cyruntime.cudaGraphConditionalHandle cyhandle
        if handle is None:
            cyhandle = <cyruntime.cudaGraphConditionalHandle><void_ptr>0
        elif isinstance(handle, (cudaGraphConditionalHandle)):
            phandle = int(handle)
            cyhandle = <cyruntime.cudaGraphConditionalHandle><void_ptr>phandle
        else:
            phandle = int(cudaGraphConditionalHandle(handle))
            cyhandle = <cyruntime.cudaGraphConditionalHandle><void_ptr>phandle
        self._handle._pvt_ptr[0] = cyhandle

    {{endif}}
    {{if 'cudaConditionalNodeParams.type' in found_struct}}
    @property
    def type(self):
        return cudaGraphConditionalNodeType(self._pvt_ptr[0].type)
    @type.setter
    def type(self, type not None : cudaGraphConditionalNodeType):
        self._pvt_ptr[0].type = int(type)
    {{endif}}
    {{if 'cudaConditionalNodeParams.size' in found_struct}}
    @property
    def size(self):
        return self._pvt_ptr[0].size
    @size.setter
    def size(self, unsigned int size):
        self._pvt_ptr[0].size = size
    {{endif}}
    {{if 'cudaConditionalNodeParams.phGraph_out' in found_struct}}
    @property
    def phGraph_out(self):
        arrs = [<void_ptr>self._pvt_ptr[0].phGraph_out + x*sizeof(cyruntime.cudaGraph_t) for x in range(self.size)]
        return [cudaGraph_t(_ptr=arr) for arr in arrs]
    {{endif}}
    {{if 'cudaConditionalNodeParams.ctx' in found_struct}}
    @property
    def ctx(self):
        return self._ctx
    @ctx.setter
    def ctx(self, ctx):
        cdef cyruntime.cudaExecutionContext_t cyctx
        if ctx is None:
            cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>0
        elif isinstance(ctx, (cudaExecutionContext_t,)):
            pctx = int(ctx)
            cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>pctx
        else:
            pctx = int(cudaExecutionContext_t(ctx))
            cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>pctx
        self._ctx._pvt_ptr[0] = cyctx
    {{endif}}
{{endif}}
{{if 'cudaChildGraphNodeParams' in found_struct}}

cdef class cudaChildGraphNodeParams:
    """
    Child graph node parameters

    Attributes
    ----------
    {{if 'cudaChildGraphNodeParams.graph' in found_struct}}
    graph : cudaGraph_t
        The child graph to clone into the node for node creation, or a
        handle to the graph owned by the node for node query. The graph
        must not contain conditional nodes. Graphs containing memory
        allocation or memory free nodes must set the ownership to be moved
        to the parent.
    {{endif}}
    {{if 'cudaChildGraphNodeParams.ownership' in found_struct}}
    ownership : cudaGraphChildGraphNodeOwnership
        The ownership relationship of the child graph node.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaChildGraphNodeParams *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaChildGraphNodeParams.graph' in found_struct}}
        self._graph = cudaGraph_t(_ptr=<void_ptr>&self._pvt_ptr[0].graph)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaChildGraphNodeParams.graph' in found_struct}}
            try:
                str_list += ['graph : ' + str(self.graph)]
            except ValueError:
                str_list += ['graph : <ValueError>']
            {{endif}}
            {{if 'cudaChildGraphNodeParams.ownership' in found_struct}}
            try:
                str_list += ['ownership : ' + str(self.ownership)]
            except ValueError:
                str_list += ['ownership : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaChildGraphNodeParams.graph' in found_struct}}
    @property
    def graph(self):
        return self._graph
    @graph.setter
    def graph(self, graph):
        cdef cyruntime.cudaGraph_t cygraph
        if graph is None:
            cygraph = <cyruntime.cudaGraph_t><void_ptr>0
        elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
            pgraph = int(graph)
            cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
        else:
            pgraph = int(cudaGraph_t(graph))
            cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
        self._graph._pvt_ptr[0] = cygraph
    {{endif}}
    {{if 'cudaChildGraphNodeParams.ownership' in found_struct}}
    @property
    def ownership(self):
        return cudaGraphChildGraphNodeOwnership(self._pvt_ptr[0].ownership)
    @ownership.setter
    def ownership(self, ownership not None : cudaGraphChildGraphNodeOwnership):
        self._pvt_ptr[0].ownership = int(ownership)
    {{endif}}
{{endif}}
{{if 'cudaEventRecordNodeParams' in found_struct}}

cdef class cudaEventRecordNodeParams:
    """
    Event record node parameters

    Attributes
    ----------
    {{if 'cudaEventRecordNodeParams.event' in found_struct}}
    event : cudaEvent_t
        The event to record when the node executes
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaEventRecordNodeParams *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaEventRecordNodeParams.event' in found_struct}}
        self._event = cudaEvent_t(_ptr=<void_ptr>&self._pvt_ptr[0].event)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaEventRecordNodeParams.event' in found_struct}}
            try:
                str_list += ['event : ' + str(self.event)]
            except ValueError:
                str_list += ['event : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaEventRecordNodeParams.event' in found_struct}}
    @property
    def event(self):
        return self._event
    @event.setter
    def event(self, event):
        cdef cyruntime.cudaEvent_t cyevent
        if event is None:
            cyevent = <cyruntime.cudaEvent_t><void_ptr>0
        elif isinstance(event, (cudaEvent_t,driver.CUevent)):
            pevent = int(event)
            cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
        else:
            pevent = int(cudaEvent_t(event))
            cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
        self._event._pvt_ptr[0] = cyevent
    {{endif}}
{{endif}}
{{if 'cudaEventWaitNodeParams' in found_struct}}

cdef class cudaEventWaitNodeParams:
    """
    Event wait node parameters

    Attributes
    ----------
    {{if 'cudaEventWaitNodeParams.event' in found_struct}}
    event : cudaEvent_t
        The event to wait on from the node
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaEventWaitNodeParams *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaEventWaitNodeParams.event' in found_struct}}
        self._event = cudaEvent_t(_ptr=<void_ptr>&self._pvt_ptr[0].event)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaEventWaitNodeParams.event' in found_struct}}
            try:
                str_list += ['event : ' + str(self.event)]
            except ValueError:
                str_list += ['event : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaEventWaitNodeParams.event' in found_struct}}
    @property
    def event(self):
        return self._event
    @event.setter
    def event(self, event):
        cdef cyruntime.cudaEvent_t cyevent
        if event is None:
            cyevent = <cyruntime.cudaEvent_t><void_ptr>0
        elif isinstance(event, (cudaEvent_t,driver.CUevent)):
            pevent = int(event)
            cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
        else:
            pevent = int(cudaEvent_t(event))
            cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
        self._event._pvt_ptr[0] = cyevent
    {{endif}}
{{endif}}
{{if 'cudaGraphNodeParams' in found_struct}}

cdef class cudaGraphNodeParams:
    """
    Graph node parameters. See cudaGraphAddNode.

    Attributes
    ----------
    {{if 'cudaGraphNodeParams.type' in found_struct}}
    type : cudaGraphNodeType
        Type of the node
    {{endif}}
    {{if 'cudaGraphNodeParams.reserved0' in found_struct}}
    reserved0 : list[int]
        Reserved. Must be zero.
    {{endif}}
    {{if 'cudaGraphNodeParams.reserved1' in found_struct}}
    reserved1 : list[long long]
        Padding. Unused bytes must be zero.
    {{endif}}
    {{if 'cudaGraphNodeParams.kernel' in found_struct}}
    kernel : cudaKernelNodeParamsV2
        Kernel node parameters.
    {{endif}}
    {{if 'cudaGraphNodeParams.memcpy' in found_struct}}
    memcpy : cudaMemcpyNodeParams
        Memcpy node parameters.
    {{endif}}
    {{if 'cudaGraphNodeParams.memset' in found_struct}}
    memset : cudaMemsetParamsV2
        Memset node parameters.
    {{endif}}
    {{if 'cudaGraphNodeParams.host' in found_struct}}
    host : cudaHostNodeParamsV2
        Host node parameters.
    {{endif}}
    {{if 'cudaGraphNodeParams.graph' in found_struct}}
    graph : cudaChildGraphNodeParams
        Child graph node parameters.
    {{endif}}
    {{if 'cudaGraphNodeParams.eventWait' in found_struct}}
    eventWait : cudaEventWaitNodeParams
        Event wait node parameters.
    {{endif}}
    {{if 'cudaGraphNodeParams.eventRecord' in found_struct}}
    eventRecord : cudaEventRecordNodeParams
        Event record node parameters.
    {{endif}}
    {{if 'cudaGraphNodeParams.extSemSignal' in found_struct}}
    extSemSignal : cudaExternalSemaphoreSignalNodeParamsV2
        External semaphore signal node parameters.
    {{endif}}
    {{if 'cudaGraphNodeParams.extSemWait' in found_struct}}
    extSemWait : cudaExternalSemaphoreWaitNodeParamsV2
        External semaphore wait node parameters.
    {{endif}}
    {{if 'cudaGraphNodeParams.alloc' in found_struct}}
    alloc : cudaMemAllocNodeParamsV2
        Memory allocation node parameters.
    {{endif}}
    {{if 'cudaGraphNodeParams.free' in found_struct}}
    free : cudaMemFreeNodeParams
        Memory free node parameters.
    {{endif}}
    {{if 'cudaGraphNodeParams.conditional' in found_struct}}
    conditional : cudaConditionalNodeParams
        Conditional node parameters.
    {{endif}}
    {{if 'cudaGraphNodeParams.reserved2' in found_struct}}
    reserved2 : long long
        Reserved bytes. Must be zero.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cyruntime.cudaGraphNodeParams *>calloc(1, sizeof(cyruntime.cudaGraphNodeParams))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cyruntime.cudaGraphNodeParams *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaGraphNodeParams.kernel' in found_struct}}
        self._kernel = cudaKernelNodeParamsV2(_ptr=<void_ptr>&self._pvt_ptr[0].kernel)
        {{endif}}
        {{if 'cudaGraphNodeParams.memcpy' in found_struct}}
        self._memcpy = cudaMemcpyNodeParams(_ptr=<void_ptr>&self._pvt_ptr[0].memcpy)
        {{endif}}
        {{if 'cudaGraphNodeParams.memset' in found_struct}}
        self._memset = cudaMemsetParamsV2(_ptr=<void_ptr>&self._pvt_ptr[0].memset)
        {{endif}}
        {{if 'cudaGraphNodeParams.host' in found_struct}}
        self._host = cudaHostNodeParamsV2(_ptr=<void_ptr>&self._pvt_ptr[0].host)
        {{endif}}
        {{if 'cudaGraphNodeParams.graph' in found_struct}}
        self._graph = cudaChildGraphNodeParams(_ptr=<void_ptr>&self._pvt_ptr[0].graph)
        {{endif}}
        {{if 'cudaGraphNodeParams.eventWait' in found_struct}}
        self._eventWait = cudaEventWaitNodeParams(_ptr=<void_ptr>&self._pvt_ptr[0].eventWait)
        {{endif}}
        {{if 'cudaGraphNodeParams.eventRecord' in found_struct}}
        self._eventRecord = cudaEventRecordNodeParams(_ptr=<void_ptr>&self._pvt_ptr[0].eventRecord)
        {{endif}}
        {{if 'cudaGraphNodeParams.extSemSignal' in found_struct}}
        self._extSemSignal = cudaExternalSemaphoreSignalNodeParamsV2(_ptr=<void_ptr>&self._pvt_ptr[0].extSemSignal)
        {{endif}}
        {{if 'cudaGraphNodeParams.extSemWait' in found_struct}}
        self._extSemWait = cudaExternalSemaphoreWaitNodeParamsV2(_ptr=<void_ptr>&self._pvt_ptr[0].extSemWait)
        {{endif}}
        {{if 'cudaGraphNodeParams.alloc' in found_struct}}
        self._alloc = cudaMemAllocNodeParamsV2(_ptr=<void_ptr>&self._pvt_ptr[0].alloc)
        {{endif}}
        {{if 'cudaGraphNodeParams.free' in found_struct}}
        self._free = cudaMemFreeNodeParams(_ptr=<void_ptr>&self._pvt_ptr[0].free)
        {{endif}}
        {{if 'cudaGraphNodeParams.conditional' in found_struct}}
        self._conditional = cudaConditionalNodeParams(_ptr=<void_ptr>&self._pvt_ptr[0].conditional)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaGraphNodeParams.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'cudaGraphNodeParams.reserved0' in found_struct}}
            try:
                str_list += ['reserved0 : ' + str(self.reserved0)]
            except ValueError:
                str_list += ['reserved0 : <ValueError>']
            {{endif}}
            {{if 'cudaGraphNodeParams.reserved1' in found_struct}}
            try:
                str_list += ['reserved1 : ' + str(self.reserved1)]
            except ValueError:
                str_list += ['reserved1 : <ValueError>']
            {{endif}}
            {{if 'cudaGraphNodeParams.kernel' in found_struct}}
            try:
                str_list += ['kernel :\n' + '\n'.join(['    ' + line for line in str(self.kernel).splitlines()])]
            except ValueError:
                str_list += ['kernel : <ValueError>']
            {{endif}}
            {{if 'cudaGraphNodeParams.memcpy' in found_struct}}
            try:
                str_list += ['memcpy :\n' + '\n'.join(['    ' + line for line in str(self.memcpy).splitlines()])]
            except ValueError:
                str_list += ['memcpy : <ValueError>']
            {{endif}}
            {{if 'cudaGraphNodeParams.memset' in found_struct}}
            try:
                str_list += ['memset :\n' + '\n'.join(['    ' + line for line in str(self.memset).splitlines()])]
            except ValueError:
                str_list += ['memset : <ValueError>']
            {{endif}}
            {{if 'cudaGraphNodeParams.host' in found_struct}}
            try:
                str_list += ['host :\n' + '\n'.join(['    ' + line for line in str(self.host).splitlines()])]
            except ValueError:
                str_list += ['host : <ValueError>']
            {{endif}}
            {{if 'cudaGraphNodeParams.graph' in found_struct}}
            try:
                str_list += ['graph :\n' + '\n'.join(['    ' + line for line in str(self.graph).splitlines()])]
            except ValueError:
                str_list += ['graph : <ValueError>']
            {{endif}}
            {{if 'cudaGraphNodeParams.eventWait' in found_struct}}
            try:
                str_list += ['eventWait :\n' + '\n'.join(['    ' + line for line in str(self.eventWait).splitlines()])]
            except ValueError:
                str_list += ['eventWait : <ValueError>']
            {{endif}}
            {{if 'cudaGraphNodeParams.eventRecord' in found_struct}}
            try:
                str_list += ['eventRecord :\n' + '\n'.join(['    ' + line for line in str(self.eventRecord).splitlines()])]
            except ValueError:
                str_list += ['eventRecord : <ValueError>']
            {{endif}}
            {{if 'cudaGraphNodeParams.extSemSignal' in found_struct}}
            try:
                str_list += ['extSemSignal :\n' + '\n'.join(['    ' + line for line in str(self.extSemSignal).splitlines()])]
            except ValueError:
                str_list += ['extSemSignal : <ValueError>']
            {{endif}}
            {{if 'cudaGraphNodeParams.extSemWait' in found_struct}}
            try:
                str_list += ['extSemWait :\n' + '\n'.join(['    ' + line for line in str(self.extSemWait).splitlines()])]
            except ValueError:
                str_list += ['extSemWait : <ValueError>']
            {{endif}}
            {{if 'cudaGraphNodeParams.alloc' in found_struct}}
            try:
                str_list += ['alloc :\n' + '\n'.join(['    ' + line for line in str(self.alloc).splitlines()])]
            except ValueError:
                str_list += ['alloc : <ValueError>']
            {{endif}}
            {{if 'cudaGraphNodeParams.free' in found_struct}}
            try:
                str_list += ['free :\n' + '\n'.join(['    ' + line for line in str(self.free).splitlines()])]
            except ValueError:
                str_list += ['free : <ValueError>']
            {{endif}}
            {{if 'cudaGraphNodeParams.conditional' in found_struct}}
            try:
                str_list += ['conditional :\n' + '\n'.join(['    ' + line for line in str(self.conditional).splitlines()])]
            except ValueError:
                str_list += ['conditional : <ValueError>']
            {{endif}}
            {{if 'cudaGraphNodeParams.reserved2' in found_struct}}
            try:
                str_list += ['reserved2 : ' + str(self.reserved2)]
            except ValueError:
                str_list += ['reserved2 : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaGraphNodeParams.type' in found_struct}}
    @property
    def type(self):
        return cudaGraphNodeType(self._pvt_ptr[0].type)
    @type.setter
    def type(self, type not None : cudaGraphNodeType):
        self._pvt_ptr[0].type = int(type)
    {{endif}}
    {{if 'cudaGraphNodeParams.reserved0' in found_struct}}
    @property
    def reserved0(self):
        return self._pvt_ptr[0].reserved0
    @reserved0.setter
    def reserved0(self, reserved0):
        self._pvt_ptr[0].reserved0 = reserved0
    {{endif}}
    {{if 'cudaGraphNodeParams.reserved1' in found_struct}}
    @property
    def reserved1(self):
        return self._pvt_ptr[0].reserved1
    @reserved1.setter
    def reserved1(self, reserved1):
        self._pvt_ptr[0].reserved1 = reserved1
    {{endif}}
    {{if 'cudaGraphNodeParams.kernel' in found_struct}}
    @property
    def kernel(self):
        return self._kernel
    @kernel.setter
    def kernel(self, kernel not None : cudaKernelNodeParamsV2):
        string.memcpy(&self._pvt_ptr[0].kernel, <cyruntime.cudaKernelNodeParamsV2*><void_ptr>kernel.getPtr(), sizeof(self._pvt_ptr[0].kernel))
    {{endif}}
    {{if 'cudaGraphNodeParams.memcpy' in found_struct}}
    @property
    def memcpy(self):
        return self._memcpy
    @memcpy.setter
    def memcpy(self, memcpy not None : cudaMemcpyNodeParams):
        string.memcpy(&self._pvt_ptr[0].memcpy, <cyruntime.cudaMemcpyNodeParams*><void_ptr>memcpy.getPtr(), sizeof(self._pvt_ptr[0].memcpy))
    {{endif}}
    {{if 'cudaGraphNodeParams.memset' in found_struct}}
    @property
    def memset(self):
        return self._memset
    @memset.setter
    def memset(self, memset not None : cudaMemsetParamsV2):
        string.memcpy(&self._pvt_ptr[0].memset, <cyruntime.cudaMemsetParamsV2*><void_ptr>memset.getPtr(), sizeof(self._pvt_ptr[0].memset))
    {{endif}}
    {{if 'cudaGraphNodeParams.host' in found_struct}}
    @property
    def host(self):
        return self._host
    @host.setter
    def host(self, host not None : cudaHostNodeParamsV2):
        string.memcpy(&self._pvt_ptr[0].host, <cyruntime.cudaHostNodeParamsV2*><void_ptr>host.getPtr(), sizeof(self._pvt_ptr[0].host))
    {{endif}}
    {{if 'cudaGraphNodeParams.graph' in found_struct}}
    @property
    def graph(self):
        return self._graph
    @graph.setter
    def graph(self, graph not None : cudaChildGraphNodeParams):
        string.memcpy(&self._pvt_ptr[0].graph, <cyruntime.cudaChildGraphNodeParams*><void_ptr>graph.getPtr(), sizeof(self._pvt_ptr[0].graph))
    {{endif}}
    {{if 'cudaGraphNodeParams.eventWait' in found_struct}}
    @property
    def eventWait(self):
        return self._eventWait
    @eventWait.setter
    def eventWait(self, eventWait not None : cudaEventWaitNodeParams):
        string.memcpy(&self._pvt_ptr[0].eventWait, <cyruntime.cudaEventWaitNodeParams*><void_ptr>eventWait.getPtr(), sizeof(self._pvt_ptr[0].eventWait))
    {{endif}}
    {{if 'cudaGraphNodeParams.eventRecord' in found_struct}}
    @property
    def eventRecord(self):
        return self._eventRecord
    @eventRecord.setter
    def eventRecord(self, eventRecord not None : cudaEventRecordNodeParams):
        string.memcpy(&self._pvt_ptr[0].eventRecord, <cyruntime.cudaEventRecordNodeParams*><void_ptr>eventRecord.getPtr(), sizeof(self._pvt_ptr[0].eventRecord))
    {{endif}}
    {{if 'cudaGraphNodeParams.extSemSignal' in found_struct}}
    @property
    def extSemSignal(self):
        return self._extSemSignal
    @extSemSignal.setter
    def extSemSignal(self, extSemSignal not None : cudaExternalSemaphoreSignalNodeParamsV2):
        string.memcpy(&self._pvt_ptr[0].extSemSignal, <cyruntime.cudaExternalSemaphoreSignalNodeParamsV2*><void_ptr>extSemSignal.getPtr(), sizeof(self._pvt_ptr[0].extSemSignal))
    {{endif}}
    {{if 'cudaGraphNodeParams.extSemWait' in found_struct}}
    @property
    def extSemWait(self):
        return self._extSemWait
    @extSemWait.setter
    def extSemWait(self, extSemWait not None : cudaExternalSemaphoreWaitNodeParamsV2):
        string.memcpy(&self._pvt_ptr[0].extSemWait, <cyruntime.cudaExternalSemaphoreWaitNodeParamsV2*><void_ptr>extSemWait.getPtr(), sizeof(self._pvt_ptr[0].extSemWait))
    {{endif}}
    {{if 'cudaGraphNodeParams.alloc' in found_struct}}
    @property
    def alloc(self):
        return self._alloc
    @alloc.setter
    def alloc(self, alloc not None : cudaMemAllocNodeParamsV2):
        string.memcpy(&self._pvt_ptr[0].alloc, <cyruntime.cudaMemAllocNodeParamsV2*><void_ptr>alloc.getPtr(), sizeof(self._pvt_ptr[0].alloc))
    {{endif}}
    {{if 'cudaGraphNodeParams.free' in found_struct}}
    @property
    def free(self):
        return self._free
    @free.setter
    def free(self, free not None : cudaMemFreeNodeParams):
        string.memcpy(&self._pvt_ptr[0].free, <cyruntime.cudaMemFreeNodeParams*><void_ptr>free.getPtr(), sizeof(self._pvt_ptr[0].free))
    {{endif}}
    {{if 'cudaGraphNodeParams.conditional' in found_struct}}
    @property
    def conditional(self):
        return self._conditional
    @conditional.setter
    def conditional(self, conditional not None : cudaConditionalNodeParams):
        string.memcpy(&self._pvt_ptr[0].conditional, <cyruntime.cudaConditionalNodeParams*><void_ptr>conditional.getPtr(), sizeof(self._pvt_ptr[0].conditional))
    {{endif}}
    {{if 'cudaGraphNodeParams.reserved2' in found_struct}}
    @property
    def reserved2(self):
        return self._pvt_ptr[0].reserved2
    @reserved2.setter
    def reserved2(self, long long reserved2):
        self._pvt_ptr[0].reserved2 = reserved2
    {{endif}}
{{endif}}
{{if 'cudaGraphEdgeData_st' in found_struct}}

cdef class cudaGraphEdgeData_st:
    """
    Optional annotation for edges in a CUDA graph. Note, all edges
    implicitly have annotations and default to a zero-initialized value
    if not specified. A zero-initialized struct indicates a standard
    full serialization of two nodes with memory visibility.

    Attributes
    ----------
    {{if 'cudaGraphEdgeData_st.from_port' in found_struct}}
    from_port : bytes
        This indicates when the dependency is triggered from the upstream
        node on the edge. The meaning is specfic to the node type. A value
        of 0 in all cases means full completion of the upstream node, with
        memory visibility to the downstream node or portion thereof
        (indicated by `to_port`).   Only kernel nodes define non-zero
        ports. A kernel node can use the following output port types:
        cudaGraphKernelNodePortDefault,
        cudaGraphKernelNodePortProgrammatic, or
        cudaGraphKernelNodePortLaunchCompletion.
    {{endif}}
    {{if 'cudaGraphEdgeData_st.to_port' in found_struct}}
    to_port : bytes
        This indicates what portion of the downstream node is dependent on
        the upstream node or portion thereof (indicated by `from_port`).
        The meaning is specific to the node type. A value of 0 in all cases
        means the entirety of the downstream node is dependent on the
        upstream work.   Currently no node types define non-zero ports.
        Accordingly, this field must be set to zero.
    {{endif}}
    {{if 'cudaGraphEdgeData_st.type' in found_struct}}
    type : bytes
        This should be populated with a value from
        ::cudaGraphDependencyType. (It is typed as char due to compiler-
        specific layout of bitfields.) See ::cudaGraphDependencyType.
    {{endif}}
    {{if 'cudaGraphEdgeData_st.reserved' in found_struct}}
    reserved : bytes
        These bytes are unused and must be zeroed. This ensures
        compatibility if additional fields are added in the future.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaGraphEdgeData_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaGraphEdgeData_st.from_port' in found_struct}}
            try:
                str_list += ['from_port : ' + str(self.from_port)]
            except ValueError:
                str_list += ['from_port : <ValueError>']
            {{endif}}
            {{if 'cudaGraphEdgeData_st.to_port' in found_struct}}
            try:
                str_list += ['to_port : ' + str(self.to_port)]
            except ValueError:
                str_list += ['to_port : <ValueError>']
            {{endif}}
            {{if 'cudaGraphEdgeData_st.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'cudaGraphEdgeData_st.reserved' in found_struct}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaGraphEdgeData_st.from_port' in found_struct}}
    @property
    def from_port(self):
        return self._pvt_ptr[0].from_port
    @from_port.setter
    def from_port(self, unsigned char from_port):
        self._pvt_ptr[0].from_port = from_port
    {{endif}}
    {{if 'cudaGraphEdgeData_st.to_port' in found_struct}}
    @property
    def to_port(self):
        return self._pvt_ptr[0].to_port
    @to_port.setter
    def to_port(self, unsigned char to_port):
        self._pvt_ptr[0].to_port = to_port
    {{endif}}
    {{if 'cudaGraphEdgeData_st.type' in found_struct}}
    @property
    def type(self):
        return self._pvt_ptr[0].type
    @type.setter
    def type(self, unsigned char type):
        self._pvt_ptr[0].type = type
    {{endif}}
    {{if 'cudaGraphEdgeData_st.reserved' in found_struct}}
    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(<char*>self._pvt_ptr[0].reserved, 5)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 5:
            raise ValueError("reserved length must be 5, is " + str(len(reserved)))
        for i, b in enumerate(reserved):
            self._pvt_ptr[0].reserved[i] = b
    {{endif}}
{{endif}}
{{if 'cudaGraphInstantiateParams_st' in found_struct}}

cdef class cudaGraphInstantiateParams_st:
    """
    Graph instantiation parameters

    Attributes
    ----------
    {{if 'cudaGraphInstantiateParams_st.flags' in found_struct}}
    flags : unsigned long long
        Instantiation flags
    {{endif}}
    {{if 'cudaGraphInstantiateParams_st.uploadStream' in found_struct}}
    uploadStream : cudaStream_t
        Upload stream
    {{endif}}
    {{if 'cudaGraphInstantiateParams_st.errNode_out' in found_struct}}
    errNode_out : cudaGraphNode_t
        The node which caused instantiation to fail, if any
    {{endif}}
    {{if 'cudaGraphInstantiateParams_st.result_out' in found_struct}}
    result_out : cudaGraphInstantiateResult
        Whether instantiation was successful. If it failed, the reason why
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaGraphInstantiateParams_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaGraphInstantiateParams_st.uploadStream' in found_struct}}
        self._uploadStream = cudaStream_t(_ptr=<void_ptr>&self._pvt_ptr[0].uploadStream)
        {{endif}}
        {{if 'cudaGraphInstantiateParams_st.errNode_out' in found_struct}}
        self._errNode_out = cudaGraphNode_t(_ptr=<void_ptr>&self._pvt_ptr[0].errNode_out)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaGraphInstantiateParams_st.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'cudaGraphInstantiateParams_st.uploadStream' in found_struct}}
            try:
                str_list += ['uploadStream : ' + str(self.uploadStream)]
            except ValueError:
                str_list += ['uploadStream : <ValueError>']
            {{endif}}
            {{if 'cudaGraphInstantiateParams_st.errNode_out' in found_struct}}
            try:
                str_list += ['errNode_out : ' + str(self.errNode_out)]
            except ValueError:
                str_list += ['errNode_out : <ValueError>']
            {{endif}}
            {{if 'cudaGraphInstantiateParams_st.result_out' in found_struct}}
            try:
                str_list += ['result_out : ' + str(self.result_out)]
            except ValueError:
                str_list += ['result_out : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaGraphInstantiateParams_st.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].flags
    @flags.setter
    def flags(self, unsigned long long flags):
        self._pvt_ptr[0].flags = flags
    {{endif}}
    {{if 'cudaGraphInstantiateParams_st.uploadStream' in found_struct}}
    @property
    def uploadStream(self):
        return self._uploadStream
    @uploadStream.setter
    def uploadStream(self, uploadStream):
        cdef cyruntime.cudaStream_t cyuploadStream
        if uploadStream is None:
            cyuploadStream = <cyruntime.cudaStream_t><void_ptr>0
        elif isinstance(uploadStream, (cudaStream_t,driver.CUstream)):
            puploadStream = int(uploadStream)
            cyuploadStream = <cyruntime.cudaStream_t><void_ptr>puploadStream
        else:
            puploadStream = int(cudaStream_t(uploadStream))
            cyuploadStream = <cyruntime.cudaStream_t><void_ptr>puploadStream
        self._uploadStream._pvt_ptr[0] = cyuploadStream
    {{endif}}
    {{if 'cudaGraphInstantiateParams_st.errNode_out' in found_struct}}
    @property
    def errNode_out(self):
        return self._errNode_out
    @errNode_out.setter
    def errNode_out(self, errNode_out):
        cdef cyruntime.cudaGraphNode_t cyerrNode_out
        if errNode_out is None:
            cyerrNode_out = <cyruntime.cudaGraphNode_t><void_ptr>0
        elif isinstance(errNode_out, (cudaGraphNode_t,driver.CUgraphNode)):
            perrNode_out = int(errNode_out)
            cyerrNode_out = <cyruntime.cudaGraphNode_t><void_ptr>perrNode_out
        else:
            perrNode_out = int(cudaGraphNode_t(errNode_out))
            cyerrNode_out = <cyruntime.cudaGraphNode_t><void_ptr>perrNode_out
        self._errNode_out._pvt_ptr[0] = cyerrNode_out
    {{endif}}
    {{if 'cudaGraphInstantiateParams_st.result_out' in found_struct}}
    @property
    def result_out(self):
        return cudaGraphInstantiateResult(self._pvt_ptr[0].result_out)
    @result_out.setter
    def result_out(self, result_out not None : cudaGraphInstantiateResult):
        self._pvt_ptr[0].result_out = int(result_out)
    {{endif}}
{{endif}}
{{if 'cudaGraphExecUpdateResultInfo_st' in found_struct}}

cdef class cudaGraphExecUpdateResultInfo_st:
    """
    Result information returned by cudaGraphExecUpdate

    Attributes
    ----------
    {{if 'cudaGraphExecUpdateResultInfo_st.result' in found_struct}}
    result : cudaGraphExecUpdateResult
        Gives more specific detail when a cuda graph update fails.
    {{endif}}
    {{if 'cudaGraphExecUpdateResultInfo_st.errorNode' in found_struct}}
    errorNode : cudaGraphNode_t
        The "to node" of the error edge when the topologies do not match.
        The error node when the error is associated with a specific node.
        NULL when the error is generic.
    {{endif}}
    {{if 'cudaGraphExecUpdateResultInfo_st.errorFromNode' in found_struct}}
    errorFromNode : cudaGraphNode_t
        The from node of error edge when the topologies do not match.
        Otherwise NULL.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaGraphExecUpdateResultInfo_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaGraphExecUpdateResultInfo_st.errorNode' in found_struct}}
        self._errorNode = cudaGraphNode_t(_ptr=<void_ptr>&self._pvt_ptr[0].errorNode)
        {{endif}}
        {{if 'cudaGraphExecUpdateResultInfo_st.errorFromNode' in found_struct}}
        self._errorFromNode = cudaGraphNode_t(_ptr=<void_ptr>&self._pvt_ptr[0].errorFromNode)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaGraphExecUpdateResultInfo_st.result' in found_struct}}
            try:
                str_list += ['result : ' + str(self.result)]
            except ValueError:
                str_list += ['result : <ValueError>']
            {{endif}}
            {{if 'cudaGraphExecUpdateResultInfo_st.errorNode' in found_struct}}
            try:
                str_list += ['errorNode : ' + str(self.errorNode)]
            except ValueError:
                str_list += ['errorNode : <ValueError>']
            {{endif}}
            {{if 'cudaGraphExecUpdateResultInfo_st.errorFromNode' in found_struct}}
            try:
                str_list += ['errorFromNode : ' + str(self.errorFromNode)]
            except ValueError:
                str_list += ['errorFromNode : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaGraphExecUpdateResultInfo_st.result' in found_struct}}
    @property
    def result(self):
        return cudaGraphExecUpdateResult(self._pvt_ptr[0].result)
    @result.setter
    def result(self, result not None : cudaGraphExecUpdateResult):
        self._pvt_ptr[0].result = int(result)
    {{endif}}
    {{if 'cudaGraphExecUpdateResultInfo_st.errorNode' in found_struct}}
    @property
    def errorNode(self):
        return self._errorNode
    @errorNode.setter
    def errorNode(self, errorNode):
        cdef cyruntime.cudaGraphNode_t cyerrorNode
        if errorNode is None:
            cyerrorNode = <cyruntime.cudaGraphNode_t><void_ptr>0
        elif isinstance(errorNode, (cudaGraphNode_t,driver.CUgraphNode)):
            perrorNode = int(errorNode)
            cyerrorNode = <cyruntime.cudaGraphNode_t><void_ptr>perrorNode
        else:
            perrorNode = int(cudaGraphNode_t(errorNode))
            cyerrorNode = <cyruntime.cudaGraphNode_t><void_ptr>perrorNode
        self._errorNode._pvt_ptr[0] = cyerrorNode
    {{endif}}
    {{if 'cudaGraphExecUpdateResultInfo_st.errorFromNode' in found_struct}}
    @property
    def errorFromNode(self):
        return self._errorFromNode
    @errorFromNode.setter
    def errorFromNode(self, errorFromNode):
        cdef cyruntime.cudaGraphNode_t cyerrorFromNode
        if errorFromNode is None:
            cyerrorFromNode = <cyruntime.cudaGraphNode_t><void_ptr>0
        elif isinstance(errorFromNode, (cudaGraphNode_t,driver.CUgraphNode)):
            perrorFromNode = int(errorFromNode)
            cyerrorFromNode = <cyruntime.cudaGraphNode_t><void_ptr>perrorFromNode
        else:
            perrorFromNode = int(cudaGraphNode_t(errorFromNode))
            cyerrorFromNode = <cyruntime.cudaGraphNode_t><void_ptr>perrorFromNode
        self._errorFromNode._pvt_ptr[0] = cyerrorFromNode
    {{endif}}
{{endif}}
{{if 'cudaGraphKernelNodeUpdate.updateData.param' in found_struct}}

cdef class anon_struct16:
    """
    Attributes
    ----------
    {{if 'cudaGraphKernelNodeUpdate.updateData.param.pValue' in found_struct}}
    pValue : Any

    {{endif}}
    {{if 'cudaGraphKernelNodeUpdate.updateData.param.offset' in found_struct}}
    offset : size_t

    {{endif}}
    {{if 'cudaGraphKernelNodeUpdate.updateData.param.size' in found_struct}}
    size : size_t

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaGraphKernelNodeUpdate *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].updateData.param
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaGraphKernelNodeUpdate.updateData.param.pValue' in found_struct}}
            try:
                str_list += ['pValue : ' + hex(self.pValue)]
            except ValueError:
                str_list += ['pValue : <ValueError>']
            {{endif}}
            {{if 'cudaGraphKernelNodeUpdate.updateData.param.offset' in found_struct}}
            try:
                str_list += ['offset : ' + str(self.offset)]
            except ValueError:
                str_list += ['offset : <ValueError>']
            {{endif}}
            {{if 'cudaGraphKernelNodeUpdate.updateData.param.size' in found_struct}}
            try:
                str_list += ['size : ' + str(self.size)]
            except ValueError:
                str_list += ['size : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaGraphKernelNodeUpdate.updateData.param.pValue' in found_struct}}
    @property
    def pValue(self):
        return <void_ptr>self._pvt_ptr[0].updateData.param.pValue
    @pValue.setter
    def pValue(self, pValue):
        _cpValue = _HelperInputVoidPtr(pValue)
        self._pvt_ptr[0].updateData.param.pValue = <void*><void_ptr>_cpValue.cptr
    {{endif}}
    {{if 'cudaGraphKernelNodeUpdate.updateData.param.offset' in found_struct}}
    @property
    def offset(self):
        return self._pvt_ptr[0].updateData.param.offset
    @offset.setter
    def offset(self, size_t offset):
        self._pvt_ptr[0].updateData.param.offset = offset
    {{endif}}
    {{if 'cudaGraphKernelNodeUpdate.updateData.param.size' in found_struct}}
    @property
    def size(self):
        return self._pvt_ptr[0].updateData.param.size
    @size.setter
    def size(self, size_t size):
        self._pvt_ptr[0].updateData.param.size = size
    {{endif}}
{{endif}}
{{if 'cudaGraphKernelNodeUpdate.updateData' in found_struct}}

cdef class anon_union8:
    """
    Attributes
    ----------
    {{if 'cudaGraphKernelNodeUpdate.updateData.gridDim' in found_struct}}
    gridDim : dim3

    {{endif}}
    {{if 'cudaGraphKernelNodeUpdate.updateData.param' in found_struct}}
    param : anon_struct16

    {{endif}}
    {{if 'cudaGraphKernelNodeUpdate.updateData.isEnabled' in found_struct}}
    isEnabled : unsigned int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaGraphKernelNodeUpdate *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'cudaGraphKernelNodeUpdate.updateData.gridDim' in found_struct}}
        self._gridDim = dim3(_ptr=<void_ptr>&self._pvt_ptr[0].updateData.gridDim)
        {{endif}}
        {{if 'cudaGraphKernelNodeUpdate.updateData.param' in found_struct}}
        self._param = anon_struct16(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].updateData
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaGraphKernelNodeUpdate.updateData.gridDim' in found_struct}}
            try:
                str_list += ['gridDim :\n' + '\n'.join(['    ' + line for line in str(self.gridDim).splitlines()])]
            except ValueError:
                str_list += ['gridDim : <ValueError>']
            {{endif}}
            {{if 'cudaGraphKernelNodeUpdate.updateData.param' in found_struct}}
            try:
                str_list += ['param :\n' + '\n'.join(['    ' + line for line in str(self.param).splitlines()])]
            except ValueError:
                str_list += ['param : <ValueError>']
            {{endif}}
            {{if 'cudaGraphKernelNodeUpdate.updateData.isEnabled' in found_struct}}
            try:
                str_list += ['isEnabled : ' + str(self.isEnabled)]
            except ValueError:
                str_list += ['isEnabled : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaGraphKernelNodeUpdate.updateData.gridDim' in found_struct}}
    @property
    def gridDim(self):
        return self._gridDim
    @gridDim.setter
    def gridDim(self, gridDim not None : dim3):
        string.memcpy(&self._pvt_ptr[0].updateData.gridDim, <cyruntime.dim3*><void_ptr>gridDim.getPtr(), sizeof(self._pvt_ptr[0].updateData.gridDim))
    {{endif}}
    {{if 'cudaGraphKernelNodeUpdate.updateData.param' in found_struct}}
    @property
    def param(self):
        return self._param
    @param.setter
    def param(self, param not None : anon_struct16):
        string.memcpy(&self._pvt_ptr[0].updateData.param, <cyruntime.anon_struct16*><void_ptr>param.getPtr(), sizeof(self._pvt_ptr[0].updateData.param))
    {{endif}}
    {{if 'cudaGraphKernelNodeUpdate.updateData.isEnabled' in found_struct}}
    @property
    def isEnabled(self):
        return self._pvt_ptr[0].updateData.isEnabled
    @isEnabled.setter
    def isEnabled(self, unsigned int isEnabled):
        self._pvt_ptr[0].updateData.isEnabled = isEnabled
    {{endif}}
{{endif}}
{{if 'cudaGraphKernelNodeUpdate' in found_struct}}

cdef class cudaGraphKernelNodeUpdate:
    """
    Struct to specify a single node update to pass as part of a larger
    array to ::cudaGraphKernelNodeUpdatesApply

    Attributes
    ----------
    {{if 'cudaGraphKernelNodeUpdate.node' in found_struct}}
    node : cudaGraphDeviceNode_t
        Node to update
    {{endif}}
    {{if 'cudaGraphKernelNodeUpdate.field' in found_struct}}
    field : cudaGraphKernelNodeField
        Which type of update to apply. Determines how updateData is
        interpreted
    {{endif}}
    {{if 'cudaGraphKernelNodeUpdate.updateData' in found_struct}}
    updateData : anon_union8
        Update data to apply. Which field is used depends on field's value
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cyruntime.cudaGraphKernelNodeUpdate *>calloc(1, sizeof(cyruntime.cudaGraphKernelNodeUpdate))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cyruntime.cudaGraphKernelNodeUpdate *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaGraphKernelNodeUpdate.node' in found_struct}}
        self._node = cudaGraphDeviceNode_t(_ptr=<void_ptr>&self._pvt_ptr[0].node)
        {{endif}}
        {{if 'cudaGraphKernelNodeUpdate.updateData' in found_struct}}
        self._updateData = anon_union8(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaGraphKernelNodeUpdate.node' in found_struct}}
            try:
                str_list += ['node : ' + str(self.node)]
            except ValueError:
                str_list += ['node : <ValueError>']
            {{endif}}
            {{if 'cudaGraphKernelNodeUpdate.field' in found_struct}}
            try:
                str_list += ['field : ' + str(self.field)]
            except ValueError:
                str_list += ['field : <ValueError>']
            {{endif}}
            {{if 'cudaGraphKernelNodeUpdate.updateData' in found_struct}}
            try:
                str_list += ['updateData :\n' + '\n'.join(['    ' + line for line in str(self.updateData).splitlines()])]
            except ValueError:
                str_list += ['updateData : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaGraphKernelNodeUpdate.node' in found_struct}}
    @property
    def node(self):
        return self._node
    @node.setter
    def node(self, node):
        cdef cyruntime.cudaGraphDeviceNode_t cynode
        if node is None:
            cynode = <cyruntime.cudaGraphDeviceNode_t><void_ptr>0
        elif isinstance(node, (cudaGraphDeviceNode_t,)):
            pnode = int(node)
            cynode = <cyruntime.cudaGraphDeviceNode_t><void_ptr>pnode
        else:
            pnode = int(cudaGraphDeviceNode_t(node))
            cynode = <cyruntime.cudaGraphDeviceNode_t><void_ptr>pnode
        self._node._pvt_ptr[0] = cynode
    {{endif}}
    {{if 'cudaGraphKernelNodeUpdate.field' in found_struct}}
    @property
    def field(self):
        return cudaGraphKernelNodeField(self._pvt_ptr[0].field)
    @field.setter
    def field(self, field not None : cudaGraphKernelNodeField):
        self._pvt_ptr[0].field = int(field)
    {{endif}}
    {{if 'cudaGraphKernelNodeUpdate.updateData' in found_struct}}
    @property
    def updateData(self):
        return self._updateData
    @updateData.setter
    def updateData(self, updateData not None : anon_union8):
        string.memcpy(&self._pvt_ptr[0].updateData, <cyruntime.anon_union8*><void_ptr>updateData.getPtr(), sizeof(self._pvt_ptr[0].updateData))
    {{endif}}
{{endif}}
{{if 'cudaLaunchMemSyncDomainMap_st' in found_struct}}

cdef class cudaLaunchMemSyncDomainMap_st:
    """
    Memory Synchronization Domain map  See cudaLaunchMemSyncDomain.  By
    default, kernels are launched in domain 0. Kernel launched with
    cudaLaunchMemSyncDomainRemote will have a different domain ID. User
    may also alter the domain ID with ::cudaLaunchMemSyncDomainMap for
    a specific stream / graph node / kernel launch. See
    cudaLaunchAttributeMemSyncDomainMap.  Domain ID range is available
    through cudaDevAttrMemSyncDomainCount.

    Attributes
    ----------
    {{if 'cudaLaunchMemSyncDomainMap_st.default_' in found_struct}}
    default_ : bytes
        The default domain ID to use for designated kernels
    {{endif}}
    {{if 'cudaLaunchMemSyncDomainMap_st.remote' in found_struct}}
    remote : bytes
        The remote domain ID to use for designated kernels
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaLaunchMemSyncDomainMap_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaLaunchMemSyncDomainMap_st.default_' in found_struct}}
            try:
                str_list += ['default_ : ' + str(self.default_)]
            except ValueError:
                str_list += ['default_ : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchMemSyncDomainMap_st.remote' in found_struct}}
            try:
                str_list += ['remote : ' + str(self.remote)]
            except ValueError:
                str_list += ['remote : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaLaunchMemSyncDomainMap_st.default_' in found_struct}}
    @property
    def default_(self):
        return self._pvt_ptr[0].default_
    @default_.setter
    def default_(self, unsigned char default_):
        self._pvt_ptr[0].default_ = default_
    {{endif}}
    {{if 'cudaLaunchMemSyncDomainMap_st.remote' in found_struct}}
    @property
    def remote(self):
        return self._pvt_ptr[0].remote
    @remote.setter
    def remote(self, unsigned char remote):
        self._pvt_ptr[0].remote = remote
    {{endif}}
{{endif}}
{{if 'cudaLaunchAttributeValue.clusterDim' in found_struct}}

cdef class anon_struct17:
    """
    Attributes
    ----------
    {{if 'cudaLaunchAttributeValue.clusterDim.x' in found_struct}}
    x : unsigned int

    {{endif}}
    {{if 'cudaLaunchAttributeValue.clusterDim.y' in found_struct}}
    y : unsigned int

    {{endif}}
    {{if 'cudaLaunchAttributeValue.clusterDim.z' in found_struct}}
    z : unsigned int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaLaunchAttributeValue *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].clusterDim
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaLaunchAttributeValue.clusterDim.x' in found_struct}}
            try:
                str_list += ['x : ' + str(self.x)]
            except ValueError:
                str_list += ['x : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.clusterDim.y' in found_struct}}
            try:
                str_list += ['y : ' + str(self.y)]
            except ValueError:
                str_list += ['y : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.clusterDim.z' in found_struct}}
            try:
                str_list += ['z : ' + str(self.z)]
            except ValueError:
                str_list += ['z : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaLaunchAttributeValue.clusterDim.x' in found_struct}}
    @property
    def x(self):
        return self._pvt_ptr[0].clusterDim.x
    @x.setter
    def x(self, unsigned int x):
        self._pvt_ptr[0].clusterDim.x = x
    {{endif}}
    {{if 'cudaLaunchAttributeValue.clusterDim.y' in found_struct}}
    @property
    def y(self):
        return self._pvt_ptr[0].clusterDim.y
    @y.setter
    def y(self, unsigned int y):
        self._pvt_ptr[0].clusterDim.y = y
    {{endif}}
    {{if 'cudaLaunchAttributeValue.clusterDim.z' in found_struct}}
    @property
    def z(self):
        return self._pvt_ptr[0].clusterDim.z
    @z.setter
    def z(self, unsigned int z):
        self._pvt_ptr[0].clusterDim.z = z
    {{endif}}
{{endif}}
{{if 'cudaLaunchAttributeValue.programmaticEvent' in found_struct}}

cdef class anon_struct18:
    """
    Attributes
    ----------
    {{if 'cudaLaunchAttributeValue.programmaticEvent.event' in found_struct}}
    event : cudaEvent_t

    {{endif}}
    {{if 'cudaLaunchAttributeValue.programmaticEvent.flags' in found_struct}}
    flags : int

    {{endif}}
    {{if 'cudaLaunchAttributeValue.programmaticEvent.triggerAtBlockStart' in found_struct}}
    triggerAtBlockStart : int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaLaunchAttributeValue *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'cudaLaunchAttributeValue.programmaticEvent.event' in found_struct}}
        self._event = cudaEvent_t(_ptr=<void_ptr>&self._pvt_ptr[0].programmaticEvent.event)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].programmaticEvent
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaLaunchAttributeValue.programmaticEvent.event' in found_struct}}
            try:
                str_list += ['event : ' + str(self.event)]
            except ValueError:
                str_list += ['event : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.programmaticEvent.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.programmaticEvent.triggerAtBlockStart' in found_struct}}
            try:
                str_list += ['triggerAtBlockStart : ' + str(self.triggerAtBlockStart)]
            except ValueError:
                str_list += ['triggerAtBlockStart : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaLaunchAttributeValue.programmaticEvent.event' in found_struct}}
    @property
    def event(self):
        return self._event
    @event.setter
    def event(self, event):
        cdef cyruntime.cudaEvent_t cyevent
        if event is None:
            cyevent = <cyruntime.cudaEvent_t><void_ptr>0
        elif isinstance(event, (cudaEvent_t,driver.CUevent)):
            pevent = int(event)
            cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
        else:
            pevent = int(cudaEvent_t(event))
            cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
        self._event._pvt_ptr[0] = cyevent
    {{endif}}
    {{if 'cudaLaunchAttributeValue.programmaticEvent.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].programmaticEvent.flags
    @flags.setter
    def flags(self, int flags):
        self._pvt_ptr[0].programmaticEvent.flags = flags
    {{endif}}
    {{if 'cudaLaunchAttributeValue.programmaticEvent.triggerAtBlockStart' in found_struct}}
    @property
    def triggerAtBlockStart(self):
        return self._pvt_ptr[0].programmaticEvent.triggerAtBlockStart
    @triggerAtBlockStart.setter
    def triggerAtBlockStart(self, int triggerAtBlockStart):
        self._pvt_ptr[0].programmaticEvent.triggerAtBlockStart = triggerAtBlockStart
    {{endif}}
{{endif}}
{{if 'cudaLaunchAttributeValue.preferredClusterDim' in found_struct}}

cdef class anon_struct19:
    """
    Attributes
    ----------
    {{if 'cudaLaunchAttributeValue.preferredClusterDim.x' in found_struct}}
    x : unsigned int

    {{endif}}
    {{if 'cudaLaunchAttributeValue.preferredClusterDim.y' in found_struct}}
    y : unsigned int

    {{endif}}
    {{if 'cudaLaunchAttributeValue.preferredClusterDim.z' in found_struct}}
    z : unsigned int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaLaunchAttributeValue *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].preferredClusterDim
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaLaunchAttributeValue.preferredClusterDim.x' in found_struct}}
            try:
                str_list += ['x : ' + str(self.x)]
            except ValueError:
                str_list += ['x : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.preferredClusterDim.y' in found_struct}}
            try:
                str_list += ['y : ' + str(self.y)]
            except ValueError:
                str_list += ['y : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.preferredClusterDim.z' in found_struct}}
            try:
                str_list += ['z : ' + str(self.z)]
            except ValueError:
                str_list += ['z : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaLaunchAttributeValue.preferredClusterDim.x' in found_struct}}
    @property
    def x(self):
        return self._pvt_ptr[0].preferredClusterDim.x
    @x.setter
    def x(self, unsigned int x):
        self._pvt_ptr[0].preferredClusterDim.x = x
    {{endif}}
    {{if 'cudaLaunchAttributeValue.preferredClusterDim.y' in found_struct}}
    @property
    def y(self):
        return self._pvt_ptr[0].preferredClusterDim.y
    @y.setter
    def y(self, unsigned int y):
        self._pvt_ptr[0].preferredClusterDim.y = y
    {{endif}}
    {{if 'cudaLaunchAttributeValue.preferredClusterDim.z' in found_struct}}
    @property
    def z(self):
        return self._pvt_ptr[0].preferredClusterDim.z
    @z.setter
    def z(self, unsigned int z):
        self._pvt_ptr[0].preferredClusterDim.z = z
    {{endif}}
{{endif}}
{{if 'cudaLaunchAttributeValue.launchCompletionEvent' in found_struct}}

cdef class anon_struct20:
    """
    Attributes
    ----------
    {{if 'cudaLaunchAttributeValue.launchCompletionEvent.event' in found_struct}}
    event : cudaEvent_t

    {{endif}}
    {{if 'cudaLaunchAttributeValue.launchCompletionEvent.flags' in found_struct}}
    flags : int

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaLaunchAttributeValue *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'cudaLaunchAttributeValue.launchCompletionEvent.event' in found_struct}}
        self._event = cudaEvent_t(_ptr=<void_ptr>&self._pvt_ptr[0].launchCompletionEvent.event)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].launchCompletionEvent
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaLaunchAttributeValue.launchCompletionEvent.event' in found_struct}}
            try:
                str_list += ['event : ' + str(self.event)]
            except ValueError:
                str_list += ['event : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.launchCompletionEvent.flags' in found_struct}}
            try:
                str_list += ['flags : ' + str(self.flags)]
            except ValueError:
                str_list += ['flags : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaLaunchAttributeValue.launchCompletionEvent.event' in found_struct}}
    @property
    def event(self):
        return self._event
    @event.setter
    def event(self, event):
        cdef cyruntime.cudaEvent_t cyevent
        if event is None:
            cyevent = <cyruntime.cudaEvent_t><void_ptr>0
        elif isinstance(event, (cudaEvent_t,driver.CUevent)):
            pevent = int(event)
            cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
        else:
            pevent = int(cudaEvent_t(event))
            cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
        self._event._pvt_ptr[0] = cyevent
    {{endif}}
    {{if 'cudaLaunchAttributeValue.launchCompletionEvent.flags' in found_struct}}
    @property
    def flags(self):
        return self._pvt_ptr[0].launchCompletionEvent.flags
    @flags.setter
    def flags(self, int flags):
        self._pvt_ptr[0].launchCompletionEvent.flags = flags
    {{endif}}
{{endif}}
{{if 'cudaLaunchAttributeValue.deviceUpdatableKernelNode' in found_struct}}

cdef class anon_struct21:
    """
    Attributes
    ----------
    {{if 'cudaLaunchAttributeValue.deviceUpdatableKernelNode.deviceUpdatable' in found_struct}}
    deviceUpdatable : int

    {{endif}}
    {{if 'cudaLaunchAttributeValue.deviceUpdatableKernelNode.devNode' in found_struct}}
    devNode : cudaGraphDeviceNode_t

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaLaunchAttributeValue *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'cudaLaunchAttributeValue.deviceUpdatableKernelNode.devNode' in found_struct}}
        self._devNode = cudaGraphDeviceNode_t(_ptr=<void_ptr>&self._pvt_ptr[0].deviceUpdatableKernelNode.devNode)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].deviceUpdatableKernelNode
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaLaunchAttributeValue.deviceUpdatableKernelNode.deviceUpdatable' in found_struct}}
            try:
                str_list += ['deviceUpdatable : ' + str(self.deviceUpdatable)]
            except ValueError:
                str_list += ['deviceUpdatable : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.deviceUpdatableKernelNode.devNode' in found_struct}}
            try:
                str_list += ['devNode : ' + str(self.devNode)]
            except ValueError:
                str_list += ['devNode : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaLaunchAttributeValue.deviceUpdatableKernelNode.deviceUpdatable' in found_struct}}
    @property
    def deviceUpdatable(self):
        return self._pvt_ptr[0].deviceUpdatableKernelNode.deviceUpdatable
    @deviceUpdatable.setter
    def deviceUpdatable(self, int deviceUpdatable):
        self._pvt_ptr[0].deviceUpdatableKernelNode.deviceUpdatable = deviceUpdatable
    {{endif}}
    {{if 'cudaLaunchAttributeValue.deviceUpdatableKernelNode.devNode' in found_struct}}
    @property
    def devNode(self):
        return self._devNode
    @devNode.setter
    def devNode(self, devNode):
        cdef cyruntime.cudaGraphDeviceNode_t cydevNode
        if devNode is None:
            cydevNode = <cyruntime.cudaGraphDeviceNode_t><void_ptr>0
        elif isinstance(devNode, (cudaGraphDeviceNode_t,)):
            pdevNode = int(devNode)
            cydevNode = <cyruntime.cudaGraphDeviceNode_t><void_ptr>pdevNode
        else:
            pdevNode = int(cudaGraphDeviceNode_t(devNode))
            cydevNode = <cyruntime.cudaGraphDeviceNode_t><void_ptr>pdevNode
        self._devNode._pvt_ptr[0] = cydevNode
    {{endif}}
{{endif}}
{{if 'cudaLaunchAttributeValue' in found_struct}}

cdef class cudaLaunchAttributeValue:
    """
    Launch attributes union; used as value field of
    ::cudaLaunchAttribute

    Attributes
    ----------
    {{if 'cudaLaunchAttributeValue.pad' in found_struct}}
    pad : bytes

    {{endif}}
    {{if 'cudaLaunchAttributeValue.accessPolicyWindow' in found_struct}}
    accessPolicyWindow : cudaAccessPolicyWindow
        Value of launch attribute cudaLaunchAttributeAccessPolicyWindow.
    {{endif}}
    {{if 'cudaLaunchAttributeValue.cooperative' in found_struct}}
    cooperative : int
        Value of launch attribute cudaLaunchAttributeCooperative. Nonzero
        indicates a cooperative kernel (see cudaLaunchCooperativeKernel).
    {{endif}}
    {{if 'cudaLaunchAttributeValue.syncPolicy' in found_struct}}
    syncPolicy : cudaSynchronizationPolicy
        Value of launch attribute cudaLaunchAttributeSynchronizationPolicy.
        ::cudaSynchronizationPolicy for work queued up in this stream.
    {{endif}}
    {{if 'cudaLaunchAttributeValue.clusterDim' in found_struct}}
    clusterDim : anon_struct17
        Value of launch attribute cudaLaunchAttributeClusterDimension that
        represents the desired cluster dimensions for the kernel. Opaque
        type with the following fields: - `x` - The X dimension of the
        cluster, in blocks. Must be a divisor of the grid X dimension.    -
        `y` - The Y dimension of the cluster, in blocks. Must be a divisor
        of the grid Y dimension.    - `z` - The Z dimension of the cluster,
        in blocks. Must be a divisor of the grid Z dimension.
    {{endif}}
    {{if 'cudaLaunchAttributeValue.clusterSchedulingPolicyPreference' in found_struct}}
    clusterSchedulingPolicyPreference : cudaClusterSchedulingPolicy
        Value of launch attribute
        cudaLaunchAttributeClusterSchedulingPolicyPreference. Cluster
        scheduling policy preference for the kernel.
    {{endif}}
    {{if 'cudaLaunchAttributeValue.programmaticStreamSerializationAllowed' in found_struct}}
    programmaticStreamSerializationAllowed : int
        Value of launch attribute
        cudaLaunchAttributeProgrammaticStreamSerialization.
    {{endif}}
    {{if 'cudaLaunchAttributeValue.programmaticEvent' in found_struct}}
    programmaticEvent : anon_struct18
        Value of launch attribute cudaLaunchAttributeProgrammaticEvent with
        the following fields: - `cudaEvent_t` event - Event to fire when
        all blocks trigger it.    - `int` flags; - Event record flags, see
        cudaEventRecordWithFlags. Does not accept cudaEventRecordExternal.
        - `int` triggerAtBlockStart - If this is set to non-0, each block
        launch will automatically trigger the event.
    {{endif}}
    {{if 'cudaLaunchAttributeValue.priority' in found_struct}}
    priority : int
        Value of launch attribute cudaLaunchAttributePriority. Execution
        priority of the kernel.
    {{endif}}
    {{if 'cudaLaunchAttributeValue.memSyncDomainMap' in found_struct}}
    memSyncDomainMap : cudaLaunchMemSyncDomainMap
        Value of launch attribute cudaLaunchAttributeMemSyncDomainMap. See
        ::cudaLaunchMemSyncDomainMap.
    {{endif}}
    {{if 'cudaLaunchAttributeValue.memSyncDomain' in found_struct}}
    memSyncDomain : cudaLaunchMemSyncDomain
        Value of launch attribute cudaLaunchAttributeMemSyncDomain. See
        cudaLaunchMemSyncDomain.
    {{endif}}
    {{if 'cudaLaunchAttributeValue.preferredClusterDim' in found_struct}}
    preferredClusterDim : anon_struct19
        Value of launch attribute
        cudaLaunchAttributePreferredClusterDimension that represents the
        desired preferred cluster dimensions for the kernel. Opaque type
        with the following fields: - `x` - The X dimension of the preferred
        cluster, in blocks. Must be a divisor of the grid X dimension, and
        must be a multiple of the `x` field of
        cudaLaunchAttributeValue::clusterDim.    - `y` - The Y dimension of
        the preferred cluster, in blocks. Must be a divisor of the grid Y
        dimension, and must be a multiple of the `y` field of
        cudaLaunchAttributeValue::clusterDim.    - `z` - The Z dimension of
        the preferred cluster, in blocks. Must be equal to the `z` field of
        cudaLaunchAttributeValue::clusterDim.
    {{endif}}
    {{if 'cudaLaunchAttributeValue.launchCompletionEvent' in found_struct}}
    launchCompletionEvent : anon_struct20
        Value of launch attribute cudaLaunchAttributeLaunchCompletionEvent
        with the following fields: - `cudaEvent_t` event - Event to fire
        when the last block launches.    - `int` flags - Event record
        flags, see cudaEventRecordWithFlags. Does not accept
        cudaEventRecordExternal.
    {{endif}}
    {{if 'cudaLaunchAttributeValue.deviceUpdatableKernelNode' in found_struct}}
    deviceUpdatableKernelNode : anon_struct21
        Value of launch attribute
        cudaLaunchAttributeDeviceUpdatableKernelNode with the following
        fields: - `int` deviceUpdatable - Whether or not the resulting
        kernel node should be device-updatable.    -
        `cudaGraphDeviceNode_t` devNode - Returns a handle to pass to the
        various device-side update functions.
    {{endif}}
    {{if 'cudaLaunchAttributeValue.sharedMemCarveout' in found_struct}}
    sharedMemCarveout : unsigned int
        Value of launch attribute
        cudaLaunchAttributePreferredSharedMemoryCarveout.
    {{endif}}
    {{if 'cudaLaunchAttributeValue.nvlinkUtilCentricScheduling' in found_struct}}
    nvlinkUtilCentricScheduling : unsigned int
        Value of launch attribute
        cudaLaunchAttributeNvlinkUtilCentricScheduling.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaLaunchAttributeValue *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaLaunchAttributeValue.accessPolicyWindow' in found_struct}}
        self._accessPolicyWindow = cudaAccessPolicyWindow(_ptr=<void_ptr>&self._pvt_ptr[0].accessPolicyWindow)
        {{endif}}
        {{if 'cudaLaunchAttributeValue.clusterDim' in found_struct}}
        self._clusterDim = anon_struct17(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'cudaLaunchAttributeValue.programmaticEvent' in found_struct}}
        self._programmaticEvent = anon_struct18(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'cudaLaunchAttributeValue.memSyncDomainMap' in found_struct}}
        self._memSyncDomainMap = cudaLaunchMemSyncDomainMap(_ptr=<void_ptr>&self._pvt_ptr[0].memSyncDomainMap)
        {{endif}}
        {{if 'cudaLaunchAttributeValue.preferredClusterDim' in found_struct}}
        self._preferredClusterDim = anon_struct19(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'cudaLaunchAttributeValue.launchCompletionEvent' in found_struct}}
        self._launchCompletionEvent = anon_struct20(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
        {{if 'cudaLaunchAttributeValue.deviceUpdatableKernelNode' in found_struct}}
        self._deviceUpdatableKernelNode = anon_struct21(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaLaunchAttributeValue.pad' in found_struct}}
            try:
                str_list += ['pad : ' + str(self.pad)]
            except ValueError:
                str_list += ['pad : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.accessPolicyWindow' in found_struct}}
            try:
                str_list += ['accessPolicyWindow :\n' + '\n'.join(['    ' + line for line in str(self.accessPolicyWindow).splitlines()])]
            except ValueError:
                str_list += ['accessPolicyWindow : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.cooperative' in found_struct}}
            try:
                str_list += ['cooperative : ' + str(self.cooperative)]
            except ValueError:
                str_list += ['cooperative : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.syncPolicy' in found_struct}}
            try:
                str_list += ['syncPolicy : ' + str(self.syncPolicy)]
            except ValueError:
                str_list += ['syncPolicy : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.clusterDim' in found_struct}}
            try:
                str_list += ['clusterDim :\n' + '\n'.join(['    ' + line for line in str(self.clusterDim).splitlines()])]
            except ValueError:
                str_list += ['clusterDim : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.clusterSchedulingPolicyPreference' in found_struct}}
            try:
                str_list += ['clusterSchedulingPolicyPreference : ' + str(self.clusterSchedulingPolicyPreference)]
            except ValueError:
                str_list += ['clusterSchedulingPolicyPreference : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.programmaticStreamSerializationAllowed' in found_struct}}
            try:
                str_list += ['programmaticStreamSerializationAllowed : ' + str(self.programmaticStreamSerializationAllowed)]
            except ValueError:
                str_list += ['programmaticStreamSerializationAllowed : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.programmaticEvent' in found_struct}}
            try:
                str_list += ['programmaticEvent :\n' + '\n'.join(['    ' + line for line in str(self.programmaticEvent).splitlines()])]
            except ValueError:
                str_list += ['programmaticEvent : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.priority' in found_struct}}
            try:
                str_list += ['priority : ' + str(self.priority)]
            except ValueError:
                str_list += ['priority : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.memSyncDomainMap' in found_struct}}
            try:
                str_list += ['memSyncDomainMap :\n' + '\n'.join(['    ' + line for line in str(self.memSyncDomainMap).splitlines()])]
            except ValueError:
                str_list += ['memSyncDomainMap : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.memSyncDomain' in found_struct}}
            try:
                str_list += ['memSyncDomain : ' + str(self.memSyncDomain)]
            except ValueError:
                str_list += ['memSyncDomain : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.preferredClusterDim' in found_struct}}
            try:
                str_list += ['preferredClusterDim :\n' + '\n'.join(['    ' + line for line in str(self.preferredClusterDim).splitlines()])]
            except ValueError:
                str_list += ['preferredClusterDim : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.launchCompletionEvent' in found_struct}}
            try:
                str_list += ['launchCompletionEvent :\n' + '\n'.join(['    ' + line for line in str(self.launchCompletionEvent).splitlines()])]
            except ValueError:
                str_list += ['launchCompletionEvent : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.deviceUpdatableKernelNode' in found_struct}}
            try:
                str_list += ['deviceUpdatableKernelNode :\n' + '\n'.join(['    ' + line for line in str(self.deviceUpdatableKernelNode).splitlines()])]
            except ValueError:
                str_list += ['deviceUpdatableKernelNode : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.sharedMemCarveout' in found_struct}}
            try:
                str_list += ['sharedMemCarveout : ' + str(self.sharedMemCarveout)]
            except ValueError:
                str_list += ['sharedMemCarveout : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttributeValue.nvlinkUtilCentricScheduling' in found_struct}}
            try:
                str_list += ['nvlinkUtilCentricScheduling : ' + str(self.nvlinkUtilCentricScheduling)]
            except ValueError:
                str_list += ['nvlinkUtilCentricScheduling : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaLaunchAttributeValue.pad' in found_struct}}
    @property
    def pad(self):
        return PyBytes_FromStringAndSize(self._pvt_ptr[0].pad, 64)
    @pad.setter
    def pad(self, pad):
        if len(pad) != 64:
            raise ValueError("pad length must be 64, is " + str(len(pad)))
        if CHAR_MIN == 0:
            for i, b in enumerate(pad):
                if b < 0 and b > -129:
                    b = b + 256
                self._pvt_ptr[0].pad[i] = b
        else:
            for i, b in enumerate(pad):
                if b > 127 and b < 256:
                    b = b - 256
                self._pvt_ptr[0].pad[i] = b
    {{endif}}
    {{if 'cudaLaunchAttributeValue.accessPolicyWindow' in found_struct}}
    @property
    def accessPolicyWindow(self):
        return self._accessPolicyWindow
    @accessPolicyWindow.setter
    def accessPolicyWindow(self, accessPolicyWindow not None : cudaAccessPolicyWindow):
        string.memcpy(&self._pvt_ptr[0].accessPolicyWindow, <cyruntime.cudaAccessPolicyWindow*><void_ptr>accessPolicyWindow.getPtr(), sizeof(self._pvt_ptr[0].accessPolicyWindow))
    {{endif}}
    {{if 'cudaLaunchAttributeValue.cooperative' in found_struct}}
    @property
    def cooperative(self):
        return self._pvt_ptr[0].cooperative
    @cooperative.setter
    def cooperative(self, int cooperative):
        self._pvt_ptr[0].cooperative = cooperative
    {{endif}}
    {{if 'cudaLaunchAttributeValue.syncPolicy' in found_struct}}
    @property
    def syncPolicy(self):
        return cudaSynchronizationPolicy(self._pvt_ptr[0].syncPolicy)
    @syncPolicy.setter
    def syncPolicy(self, syncPolicy not None : cudaSynchronizationPolicy):
        self._pvt_ptr[0].syncPolicy = int(syncPolicy)
    {{endif}}
    {{if 'cudaLaunchAttributeValue.clusterDim' in found_struct}}
    @property
    def clusterDim(self):
        return self._clusterDim
    @clusterDim.setter
    def clusterDim(self, clusterDim not None : anon_struct17):
        string.memcpy(&self._pvt_ptr[0].clusterDim, <cyruntime.anon_struct17*><void_ptr>clusterDim.getPtr(), sizeof(self._pvt_ptr[0].clusterDim))
    {{endif}}
    {{if 'cudaLaunchAttributeValue.clusterSchedulingPolicyPreference' in found_struct}}
    @property
    def clusterSchedulingPolicyPreference(self):
        return cudaClusterSchedulingPolicy(self._pvt_ptr[0].clusterSchedulingPolicyPreference)
    @clusterSchedulingPolicyPreference.setter
    def clusterSchedulingPolicyPreference(self, clusterSchedulingPolicyPreference not None : cudaClusterSchedulingPolicy):
        self._pvt_ptr[0].clusterSchedulingPolicyPreference = int(clusterSchedulingPolicyPreference)
    {{endif}}
    {{if 'cudaLaunchAttributeValue.programmaticStreamSerializationAllowed' in found_struct}}
    @property
    def programmaticStreamSerializationAllowed(self):
        return self._pvt_ptr[0].programmaticStreamSerializationAllowed
    @programmaticStreamSerializationAllowed.setter
    def programmaticStreamSerializationAllowed(self, int programmaticStreamSerializationAllowed):
        self._pvt_ptr[0].programmaticStreamSerializationAllowed = programmaticStreamSerializationAllowed
    {{endif}}
    {{if 'cudaLaunchAttributeValue.programmaticEvent' in found_struct}}
    @property
    def programmaticEvent(self):
        return self._programmaticEvent
    @programmaticEvent.setter
    def programmaticEvent(self, programmaticEvent not None : anon_struct18):
        string.memcpy(&self._pvt_ptr[0].programmaticEvent, <cyruntime.anon_struct18*><void_ptr>programmaticEvent.getPtr(), sizeof(self._pvt_ptr[0].programmaticEvent))
    {{endif}}
    {{if 'cudaLaunchAttributeValue.priority' in found_struct}}
    @property
    def priority(self):
        return self._pvt_ptr[0].priority
    @priority.setter
    def priority(self, int priority):
        self._pvt_ptr[0].priority = priority
    {{endif}}
    {{if 'cudaLaunchAttributeValue.memSyncDomainMap' in found_struct}}
    @property
    def memSyncDomainMap(self):
        return self._memSyncDomainMap
    @memSyncDomainMap.setter
    def memSyncDomainMap(self, memSyncDomainMap not None : cudaLaunchMemSyncDomainMap):
        string.memcpy(&self._pvt_ptr[0].memSyncDomainMap, <cyruntime.cudaLaunchMemSyncDomainMap*><void_ptr>memSyncDomainMap.getPtr(), sizeof(self._pvt_ptr[0].memSyncDomainMap))
    {{endif}}
    {{if 'cudaLaunchAttributeValue.memSyncDomain' in found_struct}}
    @property
    def memSyncDomain(self):
        return cudaLaunchMemSyncDomain(self._pvt_ptr[0].memSyncDomain)
    @memSyncDomain.setter
    def memSyncDomain(self, memSyncDomain not None : cudaLaunchMemSyncDomain):
        self._pvt_ptr[0].memSyncDomain = int(memSyncDomain)
    {{endif}}
    {{if 'cudaLaunchAttributeValue.preferredClusterDim' in found_struct}}
    @property
    def preferredClusterDim(self):
        return self._preferredClusterDim
    @preferredClusterDim.setter
    def preferredClusterDim(self, preferredClusterDim not None : anon_struct19):
        string.memcpy(&self._pvt_ptr[0].preferredClusterDim, <cyruntime.anon_struct19*><void_ptr>preferredClusterDim.getPtr(), sizeof(self._pvt_ptr[0].preferredClusterDim))
    {{endif}}
    {{if 'cudaLaunchAttributeValue.launchCompletionEvent' in found_struct}}
    @property
    def launchCompletionEvent(self):
        return self._launchCompletionEvent
    @launchCompletionEvent.setter
    def launchCompletionEvent(self, launchCompletionEvent not None : anon_struct20):
        string.memcpy(&self._pvt_ptr[0].launchCompletionEvent, <cyruntime.anon_struct20*><void_ptr>launchCompletionEvent.getPtr(), sizeof(self._pvt_ptr[0].launchCompletionEvent))
    {{endif}}
    {{if 'cudaLaunchAttributeValue.deviceUpdatableKernelNode' in found_struct}}
    @property
    def deviceUpdatableKernelNode(self):
        return self._deviceUpdatableKernelNode
    @deviceUpdatableKernelNode.setter
    def deviceUpdatableKernelNode(self, deviceUpdatableKernelNode not None : anon_struct21):
        string.memcpy(&self._pvt_ptr[0].deviceUpdatableKernelNode, <cyruntime.anon_struct21*><void_ptr>deviceUpdatableKernelNode.getPtr(), sizeof(self._pvt_ptr[0].deviceUpdatableKernelNode))
    {{endif}}
    {{if 'cudaLaunchAttributeValue.sharedMemCarveout' in found_struct}}
    @property
    def sharedMemCarveout(self):
        return self._pvt_ptr[0].sharedMemCarveout
    @sharedMemCarveout.setter
    def sharedMemCarveout(self, unsigned int sharedMemCarveout):
        self._pvt_ptr[0].sharedMemCarveout = sharedMemCarveout
    {{endif}}
    {{if 'cudaLaunchAttributeValue.nvlinkUtilCentricScheduling' in found_struct}}
    @property
    def nvlinkUtilCentricScheduling(self):
        return self._pvt_ptr[0].nvlinkUtilCentricScheduling
    @nvlinkUtilCentricScheduling.setter
    def nvlinkUtilCentricScheduling(self, unsigned int nvlinkUtilCentricScheduling):
        self._pvt_ptr[0].nvlinkUtilCentricScheduling = nvlinkUtilCentricScheduling
    {{endif}}
{{endif}}
{{if 'cudaLaunchAttribute_st' in found_struct}}

cdef class cudaLaunchAttribute_st:
    """
    Launch attribute

    Attributes
    ----------
    {{if 'cudaLaunchAttribute_st.id' in found_struct}}
    id : cudaLaunchAttributeID
        Attribute to set
    {{endif}}
    {{if 'cudaLaunchAttribute_st.val' in found_struct}}
    val : cudaLaunchAttributeValue
        Value of the attribute
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaLaunchAttribute_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaLaunchAttribute_st.val' in found_struct}}
        self._val = cudaLaunchAttributeValue(_ptr=<void_ptr>&self._pvt_ptr[0].val)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaLaunchAttribute_st.id' in found_struct}}
            try:
                str_list += ['id : ' + str(self.id)]
            except ValueError:
                str_list += ['id : <ValueError>']
            {{endif}}
            {{if 'cudaLaunchAttribute_st.val' in found_struct}}
            try:
                str_list += ['val :\n' + '\n'.join(['    ' + line for line in str(self.val).splitlines()])]
            except ValueError:
                str_list += ['val : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaLaunchAttribute_st.id' in found_struct}}
    @property
    def id(self):
        return cudaLaunchAttributeID(self._pvt_ptr[0].id)
    @id.setter
    def id(self, id not None : cudaLaunchAttributeID):
        self._pvt_ptr[0].id = int(id)
    {{endif}}
    {{if 'cudaLaunchAttribute_st.val' in found_struct}}
    @property
    def val(self):
        return self._val
    @val.setter
    def val(self, val not None : cudaLaunchAttributeValue):
        string.memcpy(&self._pvt_ptr[0].val, <cyruntime.cudaLaunchAttributeValue*><void_ptr>val.getPtr(), sizeof(self._pvt_ptr[0].val))
    {{endif}}
{{endif}}
{{if 'cudaAsyncNotificationInfo.info.overBudget' in found_struct}}

cdef class anon_struct22:
    """
    Attributes
    ----------
    {{if 'cudaAsyncNotificationInfo.info.overBudget.bytesOverBudget' in found_struct}}
    bytesOverBudget : unsigned long long

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaAsyncNotificationInfo *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].info.overBudget
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaAsyncNotificationInfo.info.overBudget.bytesOverBudget' in found_struct}}
            try:
                str_list += ['bytesOverBudget : ' + str(self.bytesOverBudget)]
            except ValueError:
                str_list += ['bytesOverBudget : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaAsyncNotificationInfo.info.overBudget.bytesOverBudget' in found_struct}}
    @property
    def bytesOverBudget(self):
        return self._pvt_ptr[0].info.overBudget.bytesOverBudget
    @bytesOverBudget.setter
    def bytesOverBudget(self, unsigned long long bytesOverBudget):
        self._pvt_ptr[0].info.overBudget.bytesOverBudget = bytesOverBudget
    {{endif}}
{{endif}}
{{if 'cudaAsyncNotificationInfo.info' in found_struct}}

cdef class anon_union9:
    """
    Attributes
    ----------
    {{if 'cudaAsyncNotificationInfo.info.overBudget' in found_struct}}
    overBudget : anon_struct22

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaAsyncNotificationInfo *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
        {{if 'cudaAsyncNotificationInfo.info.overBudget' in found_struct}}
        self._overBudget = anon_struct22(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].info
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaAsyncNotificationInfo.info.overBudget' in found_struct}}
            try:
                str_list += ['overBudget :\n' + '\n'.join(['    ' + line for line in str(self.overBudget).splitlines()])]
            except ValueError:
                str_list += ['overBudget : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaAsyncNotificationInfo.info.overBudget' in found_struct}}
    @property
    def overBudget(self):
        return self._overBudget
    @overBudget.setter
    def overBudget(self, overBudget not None : anon_struct22):
        string.memcpy(&self._pvt_ptr[0].info.overBudget, <cyruntime.anon_struct22*><void_ptr>overBudget.getPtr(), sizeof(self._pvt_ptr[0].info.overBudget))
    {{endif}}
{{endif}}
{{if 'cudaAsyncNotificationInfo' in found_struct}}

cdef class cudaAsyncNotificationInfo:
    """
    Information describing an async notification event

    Attributes
    ----------
    {{if 'cudaAsyncNotificationInfo.type' in found_struct}}
    type : cudaAsyncNotificationType
        The type of notification being sent
    {{endif}}
    {{if 'cudaAsyncNotificationInfo.info' in found_struct}}
    info : anon_union9
        Information about the notification. `typename` must be checked in
        order to interpret this field.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cyruntime.cudaAsyncNotificationInfo *>calloc(1, sizeof(cyruntime.cudaAsyncNotificationInfo))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cyruntime.cudaAsyncNotificationInfo *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if 'cudaAsyncNotificationInfo.info' in found_struct}}
        self._info = anon_union9(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaAsyncNotificationInfo.type' in found_struct}}
            try:
                str_list += ['type : ' + str(self.type)]
            except ValueError:
                str_list += ['type : <ValueError>']
            {{endif}}
            {{if 'cudaAsyncNotificationInfo.info' in found_struct}}
            try:
                str_list += ['info :\n' + '\n'.join(['    ' + line for line in str(self.info).splitlines()])]
            except ValueError:
                str_list += ['info : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaAsyncNotificationInfo.type' in found_struct}}
    @property
    def type(self):
        return cudaAsyncNotificationType(self._pvt_ptr[0].type)
    @type.setter
    def type(self, type not None : cudaAsyncNotificationType):
        self._pvt_ptr[0].type = int(type)
    {{endif}}
    {{if 'cudaAsyncNotificationInfo.info' in found_struct}}
    @property
    def info(self):
        return self._info
    @info.setter
    def info(self, info not None : anon_union9):
        string.memcpy(&self._pvt_ptr[0].info, <cyruntime.anon_union9*><void_ptr>info.getPtr(), sizeof(self._pvt_ptr[0].info))
    {{endif}}
{{endif}}
{{if 'cudaTextureDesc' in found_struct}}

cdef class cudaTextureDesc:
    """
    CUDA texture descriptor

    Attributes
    ----------
    {{if 'cudaTextureDesc.addressMode' in found_struct}}
    addressMode : list[cudaTextureAddressMode]
        Texture address mode for up to 3 dimensions
    {{endif}}
    {{if 'cudaTextureDesc.filterMode' in found_struct}}
    filterMode : cudaTextureFilterMode
        Texture filter mode
    {{endif}}
    {{if 'cudaTextureDesc.readMode' in found_struct}}
    readMode : cudaTextureReadMode
        Texture read mode
    {{endif}}
    {{if 'cudaTextureDesc.sRGB' in found_struct}}
    sRGB : int
        Perform sRGB->linear conversion during texture read
    {{endif}}
    {{if 'cudaTextureDesc.borderColor' in found_struct}}
    borderColor : list[float]
        Texture Border Color
    {{endif}}
    {{if 'cudaTextureDesc.normalizedCoords' in found_struct}}
    normalizedCoords : int
        Indicates whether texture reads are normalized or not
    {{endif}}
    {{if 'cudaTextureDesc.maxAnisotropy' in found_struct}}
    maxAnisotropy : unsigned int
        Limit to the anisotropy ratio
    {{endif}}
    {{if 'cudaTextureDesc.mipmapFilterMode' in found_struct}}
    mipmapFilterMode : cudaTextureFilterMode
        Mipmap filter mode
    {{endif}}
    {{if 'cudaTextureDesc.mipmapLevelBias' in found_struct}}
    mipmapLevelBias : float
        Offset applied to the supplied mipmap level
    {{endif}}
    {{if 'cudaTextureDesc.minMipmapLevelClamp' in found_struct}}
    minMipmapLevelClamp : float
        Lower end of the mipmap level range to clamp access to
    {{endif}}
    {{if 'cudaTextureDesc.maxMipmapLevelClamp' in found_struct}}
    maxMipmapLevelClamp : float
        Upper end of the mipmap level range to clamp access to
    {{endif}}
    {{if 'cudaTextureDesc.disableTrilinearOptimization' in found_struct}}
    disableTrilinearOptimization : int
        Disable any trilinear filtering optimizations.
    {{endif}}
    {{if 'cudaTextureDesc.seamlessCubemap' in found_struct}}
    seamlessCubemap : int
        Enable seamless cube map filtering.
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaTextureDesc *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if 'cudaTextureDesc.addressMode' in found_struct}}
            try:
                str_list += ['addressMode : ' + str(self.addressMode)]
            except ValueError:
                str_list += ['addressMode : <ValueError>']
            {{endif}}
            {{if 'cudaTextureDesc.filterMode' in found_struct}}
            try:
                str_list += ['filterMode : ' + str(self.filterMode)]
            except ValueError:
                str_list += ['filterMode : <ValueError>']
            {{endif}}
            {{if 'cudaTextureDesc.readMode' in found_struct}}
            try:
                str_list += ['readMode : ' + str(self.readMode)]
            except ValueError:
                str_list += ['readMode : <ValueError>']
            {{endif}}
            {{if 'cudaTextureDesc.sRGB' in found_struct}}
            try:
                str_list += ['sRGB : ' + str(self.sRGB)]
            except ValueError:
                str_list += ['sRGB : <ValueError>']
            {{endif}}
            {{if 'cudaTextureDesc.borderColor' in found_struct}}
            try:
                str_list += ['borderColor : ' + str(self.borderColor)]
            except ValueError:
                str_list += ['borderColor : <ValueError>']
            {{endif}}
            {{if 'cudaTextureDesc.normalizedCoords' in found_struct}}
            try:
                str_list += ['normalizedCoords : ' + str(self.normalizedCoords)]
            except ValueError:
                str_list += ['normalizedCoords : <ValueError>']
            {{endif}}
            {{if 'cudaTextureDesc.maxAnisotropy' in found_struct}}
            try:
                str_list += ['maxAnisotropy : ' + str(self.maxAnisotropy)]
            except ValueError:
                str_list += ['maxAnisotropy : <ValueError>']
            {{endif}}
            {{if 'cudaTextureDesc.mipmapFilterMode' in found_struct}}
            try:
                str_list += ['mipmapFilterMode : ' + str(self.mipmapFilterMode)]
            except ValueError:
                str_list += ['mipmapFilterMode : <ValueError>']
            {{endif}}
            {{if 'cudaTextureDesc.mipmapLevelBias' in found_struct}}
            try:
                str_list += ['mipmapLevelBias : ' + str(self.mipmapLevelBias)]
            except ValueError:
                str_list += ['mipmapLevelBias : <ValueError>']
            {{endif}}
            {{if 'cudaTextureDesc.minMipmapLevelClamp' in found_struct}}
            try:
                str_list += ['minMipmapLevelClamp : ' + str(self.minMipmapLevelClamp)]
            except ValueError:
                str_list += ['minMipmapLevelClamp : <ValueError>']
            {{endif}}
            {{if 'cudaTextureDesc.maxMipmapLevelClamp' in found_struct}}
            try:
                str_list += ['maxMipmapLevelClamp : ' + str(self.maxMipmapLevelClamp)]
            except ValueError:
                str_list += ['maxMipmapLevelClamp : <ValueError>']
            {{endif}}
            {{if 'cudaTextureDesc.disableTrilinearOptimization' in found_struct}}
            try:
                str_list += ['disableTrilinearOptimization : ' + str(self.disableTrilinearOptimization)]
            except ValueError:
                str_list += ['disableTrilinearOptimization : <ValueError>']
            {{endif}}
            {{if 'cudaTextureDesc.seamlessCubemap' in found_struct}}
            try:
                str_list += ['seamlessCubemap : ' + str(self.seamlessCubemap)]
            except ValueError:
                str_list += ['seamlessCubemap : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if 'cudaTextureDesc.addressMode' in found_struct}}
    @property
    def addressMode(self):
        return [cudaTextureAddressMode(_x) for _x in list(self._pvt_ptr[0].addressMode)]
    @addressMode.setter
    def addressMode(self, addressMode):
        self._pvt_ptr[0].addressMode = [int(_x) for _x in addressMode]
    {{endif}}
    {{if 'cudaTextureDesc.filterMode' in found_struct}}
    @property
    def filterMode(self):
        return cudaTextureFilterMode(self._pvt_ptr[0].filterMode)
    @filterMode.setter
    def filterMode(self, filterMode not None : cudaTextureFilterMode):
        self._pvt_ptr[0].filterMode = int(filterMode)
    {{endif}}
    {{if 'cudaTextureDesc.readMode' in found_struct}}
    @property
    def readMode(self):
        return cudaTextureReadMode(self._pvt_ptr[0].readMode)
    @readMode.setter
    def readMode(self, readMode not None : cudaTextureReadMode):
        self._pvt_ptr[0].readMode = int(readMode)
    {{endif}}
    {{if 'cudaTextureDesc.sRGB' in found_struct}}
    @property
    def sRGB(self):
        return self._pvt_ptr[0].sRGB
    @sRGB.setter
    def sRGB(self, int sRGB):
        self._pvt_ptr[0].sRGB = sRGB
    {{endif}}
    {{if 'cudaTextureDesc.borderColor' in found_struct}}
    @property
    def borderColor(self):
        return self._pvt_ptr[0].borderColor
    @borderColor.setter
    def borderColor(self, borderColor):
        self._pvt_ptr[0].borderColor = borderColor
    {{endif}}
    {{if 'cudaTextureDesc.normalizedCoords' in found_struct}}
    @property
    def normalizedCoords(self):
        return self._pvt_ptr[0].normalizedCoords
    @normalizedCoords.setter
    def normalizedCoords(self, int normalizedCoords):
        self._pvt_ptr[0].normalizedCoords = normalizedCoords
    {{endif}}
    {{if 'cudaTextureDesc.maxAnisotropy' in found_struct}}
    @property
    def maxAnisotropy(self):
        return self._pvt_ptr[0].maxAnisotropy
    @maxAnisotropy.setter
    def maxAnisotropy(self, unsigned int maxAnisotropy):
        self._pvt_ptr[0].maxAnisotropy = maxAnisotropy
    {{endif}}
    {{if 'cudaTextureDesc.mipmapFilterMode' in found_struct}}
    @property
    def mipmapFilterMode(self):
        return cudaTextureFilterMode(self._pvt_ptr[0].mipmapFilterMode)
    @mipmapFilterMode.setter
    def mipmapFilterMode(self, mipmapFilterMode not None : cudaTextureFilterMode):
        self._pvt_ptr[0].mipmapFilterMode = int(mipmapFilterMode)
    {{endif}}
    {{if 'cudaTextureDesc.mipmapLevelBias' in found_struct}}
    @property
    def mipmapLevelBias(self):
        return self._pvt_ptr[0].mipmapLevelBias
    @mipmapLevelBias.setter
    def mipmapLevelBias(self, float mipmapLevelBias):
        self._pvt_ptr[0].mipmapLevelBias = mipmapLevelBias
    {{endif}}
    {{if 'cudaTextureDesc.minMipmapLevelClamp' in found_struct}}
    @property
    def minMipmapLevelClamp(self):
        return self._pvt_ptr[0].minMipmapLevelClamp
    @minMipmapLevelClamp.setter
    def minMipmapLevelClamp(self, float minMipmapLevelClamp):
        self._pvt_ptr[0].minMipmapLevelClamp = minMipmapLevelClamp
    {{endif}}
    {{if 'cudaTextureDesc.maxMipmapLevelClamp' in found_struct}}
    @property
    def maxMipmapLevelClamp(self):
        return self._pvt_ptr[0].maxMipmapLevelClamp
    @maxMipmapLevelClamp.setter
    def maxMipmapLevelClamp(self, float maxMipmapLevelClamp):
        self._pvt_ptr[0].maxMipmapLevelClamp = maxMipmapLevelClamp
    {{endif}}
    {{if 'cudaTextureDesc.disableTrilinearOptimization' in found_struct}}
    @property
    def disableTrilinearOptimization(self):
        return self._pvt_ptr[0].disableTrilinearOptimization
    @disableTrilinearOptimization.setter
    def disableTrilinearOptimization(self, int disableTrilinearOptimization):
        self._pvt_ptr[0].disableTrilinearOptimization = disableTrilinearOptimization
    {{endif}}
    {{if 'cudaTextureDesc.seamlessCubemap' in found_struct}}
    @property
    def seamlessCubemap(self):
        return self._pvt_ptr[0].seamlessCubemap
    @seamlessCubemap.setter
    def seamlessCubemap(self, int seamlessCubemap):
        self._pvt_ptr[0].seamlessCubemap = seamlessCubemap
    {{endif}}
{{endif}}
{{if True}}

cdef class cudaEglPlaneDesc_st:
    """
    CUDA EGL Plane Descriptor - structure defining each plane of a CUDA
    EGLFrame

    Attributes
    ----------
    {{if True}}
    width : unsigned int
        Width of plane
    {{endif}}
    {{if True}}
    height : unsigned int
        Height of plane
    {{endif}}
    {{if True}}
    depth : unsigned int
        Depth of plane
    {{endif}}
    {{if True}}
    pitch : unsigned int
        Pitch of plane
    {{endif}}
    {{if True}}
    numChannels : unsigned int
        Number of channels for the plane
    {{endif}}
    {{if True}}
    channelDesc : cudaChannelFormatDesc
        Channel Format Descriptor
    {{endif}}
    {{if True}}
    reserved : list[unsigned int]
        Reserved for future use
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaEglPlaneDesc_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if True}}
        self._channelDesc = cudaChannelFormatDesc(_ptr=<void_ptr>&self._pvt_ptr[0].channelDesc)
        {{endif}}
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if True}}
            try:
                str_list += ['width : ' + str(self.width)]
            except ValueError:
                str_list += ['width : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['height : ' + str(self.height)]
            except ValueError:
                str_list += ['height : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['depth : ' + str(self.depth)]
            except ValueError:
                str_list += ['depth : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['pitch : ' + str(self.pitch)]
            except ValueError:
                str_list += ['pitch : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['numChannels : ' + str(self.numChannels)]
            except ValueError:
                str_list += ['numChannels : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['channelDesc :\n' + '\n'.join(['    ' + line for line in str(self.channelDesc).splitlines()])]
            except ValueError:
                str_list += ['channelDesc : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['reserved : ' + str(self.reserved)]
            except ValueError:
                str_list += ['reserved : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if True}}
    @property
    def width(self):
        return self._pvt_ptr[0].width
    @width.setter
    def width(self, unsigned int width):
        self._pvt_ptr[0].width = width
    {{endif}}
    {{if True}}
    @property
    def height(self):
        return self._pvt_ptr[0].height
    @height.setter
    def height(self, unsigned int height):
        self._pvt_ptr[0].height = height
    {{endif}}
    {{if True}}
    @property
    def depth(self):
        return self._pvt_ptr[0].depth
    @depth.setter
    def depth(self, unsigned int depth):
        self._pvt_ptr[0].depth = depth
    {{endif}}
    {{if True}}
    @property
    def pitch(self):
        return self._pvt_ptr[0].pitch
    @pitch.setter
    def pitch(self, unsigned int pitch):
        self._pvt_ptr[0].pitch = pitch
    {{endif}}
    {{if True}}
    @property
    def numChannels(self):
        return self._pvt_ptr[0].numChannels
    @numChannels.setter
    def numChannels(self, unsigned int numChannels):
        self._pvt_ptr[0].numChannels = numChannels
    {{endif}}
    {{if True}}
    @property
    def channelDesc(self):
        return self._channelDesc
    @channelDesc.setter
    def channelDesc(self, channelDesc not None : cudaChannelFormatDesc):
        string.memcpy(&self._pvt_ptr[0].channelDesc, <cyruntime.cudaChannelFormatDesc*><void_ptr>channelDesc.getPtr(), sizeof(self._pvt_ptr[0].channelDesc))
    {{endif}}
    {{if True}}
    @property
    def reserved(self):
        return self._pvt_ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        self._pvt_ptr[0].reserved = reserved
    {{endif}}
{{endif}}
{{if True}}

cdef class anon_union10:
    """
    Attributes
    ----------
    {{if True}}
    pArray : list[cudaArray_t]

    {{endif}}
    {{if True}}
    pPitch : list[cudaPitchedPtr]

    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr):
        self._pvt_ptr = <cyruntime.cudaEglFrame_st *>_ptr

    def __init__(self, void_ptr _ptr):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>&self._pvt_ptr[0].frame
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if True}}
            try:
                str_list += ['pArray : ' + str(self.pArray)]
            except ValueError:
                str_list += ['pArray : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['pPitch :\n' + '\n'.join(['    ' + line for line in str(self.pPitch).splitlines()])]
            except ValueError:
                str_list += ['pPitch : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if True}}
    @property
    def pArray(self):
        return [cudaArray_t(init_value=<void_ptr>_pArray) for _pArray in self._pvt_ptr[0].frame.pArray]
    @pArray.setter
    def pArray(self, pArray : list[cudaArray_t]):
        if len(pArray) != 3:
            raise IndexError('not enough values found during array assignment, expected 3, got', len(pArray))
        pArray = [int(_pArray) for _pArray in pArray]
        for _idx, _pArray in enumerate(pArray):
            self._pvt_ptr[0].frame.pArray[_idx] = <cyruntime.cudaArray_t><void_ptr>_pArray

    {{endif}}
    {{if True}}
    @property
    def pPitch(self):
        out_pPitch = [cudaPitchedPtr() for _pPitch in self._pvt_ptr[0].frame.pPitch]
        for _idx in range(len(out_pPitch)):
            string.memcpy(<cyruntime.cudaPitchedPtr*><void_ptr>out_pPitch[_idx].getPtr(), &self._pvt_ptr[0].frame.pPitch[_idx], sizeof(cyruntime.cudaPitchedPtr))
        return out_pPitch
    @pPitch.setter
    def pPitch(self, pPitch : list[cudaPitchedPtr]):
        if len(pPitch) != 3:
            raise IndexError('not enough values found during array assignment, expected 3, got', len(pPitch))
        for _idx in range(len(pPitch)):
            string.memcpy(&self._pvt_ptr[0].frame.pPitch[_idx], <cyruntime.cudaPitchedPtr*><void_ptr>pPitch[_idx].getPtr(), sizeof(cyruntime.cudaPitchedPtr))

    {{endif}}
{{endif}}
{{if True}}

cdef class cudaEglFrame_st:
    """
    CUDA EGLFrame Descriptor - structure defining one frame of EGL.
    Each frame may contain one or more planes depending on whether the
    surface is Multiplanar or not. Each plane of EGLFrame is
    represented by cudaEglPlaneDesc which is defined as:
    typedefstructcudaEglPlaneDesc_st unsignedintwidth;
    unsignedintheight; unsignedintdepth; unsignedintpitch;
    unsignedintnumChannels; structcudaChannelFormatDescchannelDesc;
    unsignedintreserved[4]; cudaEglPlaneDesc;

    Attributes
    ----------
    {{if True}}
    frame : anon_union10

    {{endif}}
    {{if True}}
    planeDesc : list[cudaEglPlaneDesc]
        CUDA EGL Plane Descriptor cudaEglPlaneDesc
    {{endif}}
    {{if True}}
    planeCount : unsigned int
        Number of planes
    {{endif}}
    {{if True}}
    frameType : cudaEglFrameType
        Array or Pitch
    {{endif}}
    {{if True}}
    eglColorFormat : cudaEglColorFormat
        CUDA EGL Color Format
    {{endif}}

    Methods
    -------
    getPtr()
        Get memory address of class instance
    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._val_ptr = <cyruntime.cudaEglFrame_st *>calloc(1, sizeof(cyruntime.cudaEglFrame_st))
            self._pvt_ptr = self._val_ptr
        else:
            self._pvt_ptr = <cyruntime.cudaEglFrame_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
        {{if True}}
        self._frame = anon_union10(_ptr=<void_ptr>self._pvt_ptr)
        {{endif}}
    def __dealloc__(self):
        if self._val_ptr is not NULL:
            free(self._val_ptr)
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
    def __repr__(self):
        if self._pvt_ptr is not NULL:
            str_list = []
            {{if True}}
            try:
                str_list += ['frame :\n' + '\n'.join(['    ' + line for line in str(self.frame).splitlines()])]
            except ValueError:
                str_list += ['frame : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['planeDesc :\n' + '\n'.join(['    ' + line for line in str(self.planeDesc).splitlines()])]
            except ValueError:
                str_list += ['planeDesc : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['planeCount : ' + str(self.planeCount)]
            except ValueError:
                str_list += ['planeCount : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['frameType : ' + str(self.frameType)]
            except ValueError:
                str_list += ['frameType : <ValueError>']
            {{endif}}
            {{if True}}
            try:
                str_list += ['eglColorFormat : ' + str(self.eglColorFormat)]
            except ValueError:
                str_list += ['eglColorFormat : <ValueError>']
            {{endif}}
            return '\n'.join(str_list)
        else:
            return ''
    {{if True}}
    @property
    def frame(self):
        return self._frame
    @frame.setter
    def frame(self, frame not None : anon_union10):
        string.memcpy(&self._pvt_ptr[0].frame, <cyruntime.anon_union10*><void_ptr>frame.getPtr(), sizeof(self._pvt_ptr[0].frame))
    {{endif}}
    {{if True}}
    @property
    def planeDesc(self):
        out_planeDesc = [cudaEglPlaneDesc() for _planeDesc in self._pvt_ptr[0].planeDesc]
        for _idx in range(len(out_planeDesc)):
            string.memcpy(<cyruntime.cudaEglPlaneDesc*><void_ptr>out_planeDesc[_idx].getPtr(), &self._pvt_ptr[0].planeDesc[_idx], sizeof(cyruntime.cudaEglPlaneDesc))
        return out_planeDesc
    @planeDesc.setter
    def planeDesc(self, planeDesc : list[cudaEglPlaneDesc]):
        if len(planeDesc) != 3:
            raise IndexError('not enough values found during array assignment, expected 3, got', len(planeDesc))
        for _idx in range(len(planeDesc)):
            string.memcpy(&self._pvt_ptr[0].planeDesc[_idx], <cyruntime.cudaEglPlaneDesc*><void_ptr>planeDesc[_idx].getPtr(), sizeof(cyruntime.cudaEglPlaneDesc))

    {{endif}}
    {{if True}}
    @property
    def planeCount(self):
        return self._pvt_ptr[0].planeCount
    @planeCount.setter
    def planeCount(self, unsigned int planeCount):
        self._pvt_ptr[0].planeCount = planeCount
    {{endif}}
    {{if True}}
    @property
    def frameType(self):
        return cudaEglFrameType(self._pvt_ptr[0].frameType)
    @frameType.setter
    def frameType(self, frameType not None : cudaEglFrameType):
        self._pvt_ptr[0].frameType = int(frameType)
    {{endif}}
    {{if True}}
    @property
    def eglColorFormat(self):
        return cudaEglColorFormat(self._pvt_ptr[0].eglColorFormat)
    @eglColorFormat.setter
    def eglColorFormat(self, eglColorFormat not None : cudaEglColorFormat):
        self._pvt_ptr[0].eglColorFormat = int(eglColorFormat)
    {{endif}}
{{endif}}
{{if 'cudaGraphConditionalHandle' in found_types}}

cdef class cudaGraphConditionalHandle:
    """

    CUDA handle for conditional graph nodes

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaGraphConditionalHandle *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<cudaGraphConditionalHandle ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaLogIterator' in found_types}}

cdef class cudaLogIterator:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned int init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaLogIterator *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<cudaLogIterator ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned int>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaSurfaceObject_t' in found_types}}

cdef class cudaSurfaceObject_t:
    """

    An opaque value that represents a CUDA Surface object

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaSurfaceObject_t *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<cudaSurfaceObject_t ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaTextureObject_t' in found_types}}

cdef class cudaTextureObject_t:
    """

    An opaque value that represents a CUDA texture object

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.cudaTextureObject_t *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<cudaTextureObject_t ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class GLenum:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned int init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.GLenum *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<GLenum ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned int>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class GLuint:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned int init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.GLuint *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<GLuint ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned int>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class EGLint:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned int init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.EGLint *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<EGLint ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned int>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class VdpDevice:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, uint32_t init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.VdpDevice *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<VdpDevice ' + str(self.__int__()) + '>'
    def __int__(self):
        return <uint32_t>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class VdpGetProcAddress:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.VdpGetProcAddress *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<VdpGetProcAddress ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class VdpVideoSurface:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, uint32_t init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.VdpVideoSurface *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<VdpVideoSurface ' + str(self.__int__()) + '>'
    def __int__(self):
        return <uint32_t>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if True}}

cdef class VdpOutputSurface:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, uint32_t init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._pvt_ptr = &self._pvt_val
        else:
            self._pvt_ptr = <cyruntime.VdpOutputSurface *>_ptr
        if init_value:
            self._pvt_ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<VdpOutputSurface ' + str(self.__int__()) + '>'
    def __int__(self):
        return <uint32_t>self._pvt_ptr[0]
    def getPtr(self):
        return <void_ptr>self._pvt_ptr
{{endif}}

{{if 'cudaDeviceReset' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceReset():
    """ Destroy all allocations and reset all state on the current device in the current process.

    Explicitly destroys and cleans up all resources associated with the
    current device in the current process. It is the caller's
    responsibility to ensure that the resources are not accessed or passed
    in subsequent API calls and doing so will result in undefined behavior.
    These resources include CUDA types :py:obj:`~.cudaStream_t`,
    :py:obj:`~.cudaEvent_t`, :py:obj:`~.cudaArray_t`,
    :py:obj:`~.cudaMipmappedArray_t`, :py:obj:`~.cudaPitchedPtr`,
    :py:obj:`~.cudaTextureObject_t`, :py:obj:`~.cudaSurfaceObject_t`,
    :py:obj:`~.textureReference`, :py:obj:`~.surfaceReference`,
    :py:obj:`~.cudaExternalMemory_t`, :py:obj:`~.cudaExternalSemaphore_t`
    and :py:obj:`~.cudaGraphicsResource_t`. These resources also include
    memory allocations by :py:obj:`~.cudaMalloc`,
    :py:obj:`~.cudaMallocHost`, :py:obj:`~.cudaMallocManaged` and
    :py:obj:`~.cudaMallocPitch`. Any subsequent API call to this device
    will reinitialize the device.

    Note that this function will reset the device immediately. It is the
    caller's responsibility to ensure that the device is not being accessed
    by any other host threads from the process when this function is
    called.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`

    See Also
    --------
    :py:obj:`~.cudaDeviceSynchronize`

    Notes
    -----
    :py:obj:`~.cudaDeviceReset()` will not destroy memory allocations by :py:obj:`~.cudaMallocAsync()` and :py:obj:`~.cudaMallocFromPoolAsync()`. These memory allocations need to be destroyed explicitly.

    If a non-primary :py:obj:`~.CUcontext` is current to the thread, :py:obj:`~.cudaDeviceReset()` will destroy only the internal CUDA RT state for that :py:obj:`~.CUcontext`.
    """
    with nogil:
        err = cyruntime.cudaDeviceReset()
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaDeviceSynchronize' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceSynchronize():
    """ Wait for compute device to finish.

    Blocks until the device has completed all preceding requested tasks.
    :py:obj:`~.cudaDeviceSynchronize()` returns an error if one of the
    preceding tasks has failed. If the
    :py:obj:`~.cudaDeviceScheduleBlockingSync` flag was set for this
    device, the host thread will block until the device has finished its
    work.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorStreamCaptureUnsupported`

    See Also
    --------
    :py:obj:`~.cudaDeviceReset`, :py:obj:`~.cuCtxSynchronize`
    """
    with nogil:
        err = cyruntime.cudaDeviceSynchronize()
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaDeviceSetLimit' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceSetLimit(limit not None : cudaLimit, size_t value):
    """ Set resource limits.

    Setting `limit` to `value` is a request by the application to update
    the current limit maintained by the device. The driver is free to
    modify the requested value to meet h/w requirements (this could be
    clamping to minimum or maximum values, rounding up to nearest element
    size, etc). The application can use :py:obj:`~.cudaDeviceGetLimit()` to
    find out exactly what the limit has been set to.

    Setting each :py:obj:`~.cudaLimit` has its own specific restrictions,
    so each is discussed here.

    - :py:obj:`~.cudaLimitStackSize` controls the stack size in bytes of
      each GPU thread.

    - :py:obj:`~.cudaLimitPrintfFifoSize` controls the size in bytes of the
      shared FIFO used by the :py:obj:`~.printf()` device system call.
      Setting :py:obj:`~.cudaLimitPrintfFifoSize` must not be performed
      after launching any kernel that uses the :py:obj:`~.printf()` device
      system call - in such case :py:obj:`~.cudaErrorInvalidValue` will be
      returned.

    - :py:obj:`~.cudaLimitMallocHeapSize` controls the size in bytes of the
      heap used by the :py:obj:`~.malloc()` and :py:obj:`~.free()` device
      system calls. Setting :py:obj:`~.cudaLimitMallocHeapSize` must not be
      performed after launching any kernel that uses the
      :py:obj:`~.malloc()` or :py:obj:`~.free()` device system calls - in
      such case :py:obj:`~.cudaErrorInvalidValue` will be returned.

    - :py:obj:`~.cudaLimitDevRuntimeSyncDepth` controls the maximum nesting
      depth of a grid at which a thread can safely call
      :py:obj:`~.cudaDeviceSynchronize()`. Setting this limit must be
      performed before any launch of a kernel that uses the device runtime
      and calls :py:obj:`~.cudaDeviceSynchronize()` above the default sync
      depth, two levels of grids. Calls to
      :py:obj:`~.cudaDeviceSynchronize()` will fail with error code
      :py:obj:`~.cudaErrorSyncDepthExceeded` if the limitation is violated.
      This limit can be set smaller than the default or up the maximum
      launch depth of 24. When setting this limit, keep in mind that
      additional levels of sync depth require the runtime to reserve large
      amounts of device memory which can no longer be used for user
      allocations. If these reservations of device memory fail,
      :py:obj:`~.cudaDeviceSetLimit` will return
      :py:obj:`~.cudaErrorMemoryAllocation`, and the limit can be reset to
      a lower value. This limit is only applicable to devices of compute
      capability < 9.0. Attempting to set this limit on devices of other
      compute capability will results in error
      :py:obj:`~.cudaErrorUnsupportedLimit` being returned.

    - :py:obj:`~.cudaLimitDevRuntimePendingLaunchCount` controls the
      maximum number of outstanding device runtime launches that can be
      made from the current device. A grid is outstanding from the point of
      launch up until the grid is known to have been completed. Device
      runtime launches which violate this limitation fail and return
      :py:obj:`~.cudaErrorLaunchPendingCountExceeded` when
      :py:obj:`~.cudaGetLastError()` is called after launch. If more
      pending launches than the default (2048 launches) are needed for a
      module using the device runtime, this limit can be increased. Keep in
      mind that being able to sustain additional pending launches will
      require the runtime to reserve larger amounts of device memory
      upfront which can no longer be used for allocations. If these
      reservations fail, :py:obj:`~.cudaDeviceSetLimit` will return
      :py:obj:`~.cudaErrorMemoryAllocation`, and the limit can be reset to
      a lower value. This limit is only applicable to devices of compute
      capability 3.5 and higher. Attempting to set this limit on devices of
      compute capability less than 3.5 will result in the error
      :py:obj:`~.cudaErrorUnsupportedLimit` being returned.

    - :py:obj:`~.cudaLimitMaxL2FetchGranularity` controls the L2 cache
      fetch granularity. Values can range from 0B to 128B. This is purely a
      performance hint and it can be ignored or clamped depending on the
      platform.

    - :py:obj:`~.cudaLimitPersistingL2CacheSize` controls size in bytes
      available for persisting L2 cache. This is purely a performance hint
      and it can be ignored or clamped depending on the platform.

    Parameters
    ----------
    limit : :py:obj:`~.cudaLimit`
        Limit to set
    value : size_t
        Size of limit

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorUnsupportedLimit`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorMemoryAllocation`

    See Also
    --------
    :py:obj:`~.cudaDeviceGetLimit`, :py:obj:`~.cuCtxSetLimit`
    """
    cdef cyruntime.cudaLimit cylimit = int(limit)
    with nogil:
        err = cyruntime.cudaDeviceSetLimit(cylimit, value)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaDeviceGetLimit' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGetLimit(limit not None : cudaLimit):
    """ Return resource limits.

    Returns in `*pValue` the current size of `limit`. The following
    :py:obj:`~.cudaLimit` values are supported.

    - :py:obj:`~.cudaLimitStackSize` is the stack size in bytes of each GPU
      thread.

    - :py:obj:`~.cudaLimitPrintfFifoSize` is the size in bytes of the
      shared FIFO used by the :py:obj:`~.printf()` device system call.

    - :py:obj:`~.cudaLimitMallocHeapSize` is the size in bytes of the heap
      used by the :py:obj:`~.malloc()` and :py:obj:`~.free()` device system
      calls.

    - :py:obj:`~.cudaLimitDevRuntimeSyncDepth` is the maximum grid depth at
      which a thread can isssue the device runtime call
      :py:obj:`~.cudaDeviceSynchronize()` to wait on child grid launches to
      complete. This functionality is removed for devices of compute
      capability >= 9.0, and hence will return error
      :py:obj:`~.cudaErrorUnsupportedLimit` on such devices.

    - :py:obj:`~.cudaLimitDevRuntimePendingLaunchCount` is the maximum
      number of outstanding device runtime launches.

    - :py:obj:`~.cudaLimitMaxL2FetchGranularity` is the L2 cache fetch
      granularity.

    - :py:obj:`~.cudaLimitPersistingL2CacheSize` is the persisting L2 cache
      size in bytes.

    Parameters
    ----------
    limit : :py:obj:`~.cudaLimit`
        Limit to query

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorUnsupportedLimit`, :py:obj:`~.cudaErrorInvalidValue`
    pValue : int
        Returned size of the limit

    See Also
    --------
    :py:obj:`~.cudaDeviceSetLimit`, :py:obj:`~.cuCtxGetLimit`
    """
    cdef size_t pValue = 0
    cdef cyruntime.cudaLimit cylimit = int(limit)
    with nogil:
        err = cyruntime.cudaDeviceGetLimit(&pValue, cylimit)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pValue)
{{endif}}

{{if 'cudaDeviceGetTexture1DLinearMaxWidth' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGetTexture1DLinearMaxWidth(fmtDesc : Optional[cudaChannelFormatDesc], int device):
    """ Returns the maximum number of elements allocatable in a 1D linear texture for a given element size.

    Returns in `maxWidthInElements` the maximum number of elements
    allocatable in a 1D linear texture for given format descriptor
    `fmtDesc`.

    Parameters
    ----------
    fmtDesc : :py:obj:`~.cudaChannelFormatDesc`
        Texture format description.
    None : int
        None

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorUnsupportedLimit`, :py:obj:`~.cudaErrorInvalidValue`
    maxWidthInElements : int
        Returns maximum number of texture elements allocatable for given
        `fmtDesc`.

    See Also
    --------
    :py:obj:`~.cuDeviceGetTexture1DLinearMaxWidth`
    """
    cdef size_t maxWidthInElements = 0
    cdef cyruntime.cudaChannelFormatDesc* cyfmtDesc_ptr = fmtDesc._pvt_ptr if fmtDesc is not None else NULL
    with nogil:
        err = cyruntime.cudaDeviceGetTexture1DLinearMaxWidth(&maxWidthInElements, cyfmtDesc_ptr, device)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), maxWidthInElements)
{{endif}}

{{if 'cudaDeviceGetCacheConfig' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGetCacheConfig():
    """ Returns the preferred cache configuration for the current device.

    On devices where the L1 cache and shared memory use the same hardware
    resources, this returns through `pCacheConfig` the preferred cache
    configuration for the current device. This is only a preference. The
    runtime will use the requested configuration if possible, but it is
    free to choose a different configuration if required to execute
    functions.

    This will return a `pCacheConfig` of
    :py:obj:`~.cudaFuncCachePreferNone` on devices where the size of the L1
    cache and shared memory are fixed.

    The supported cache configurations are:

    - :py:obj:`~.cudaFuncCachePreferNone`: no preference for shared memory
      or L1 (default)

    - :py:obj:`~.cudaFuncCachePreferShared`: prefer larger shared memory
      and smaller L1 cache

    - :py:obj:`~.cudaFuncCachePreferL1`: prefer larger L1 cache and smaller
      shared memory

    - :py:obj:`~.cudaFuncCachePreferEqual`: prefer equal size L1 cache and
      shared memory

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`
    pCacheConfig : :py:obj:`~.cudaFuncCache`
        Returned cache configuration

    See Also
    --------
    :py:obj:`~.cudaDeviceSetCacheConfig`, :py:obj:`~.cudaFuncSetCacheConfig (C API)`, cudaFuncSetCacheConfig (C++ API), :py:obj:`~.cuCtxGetCacheConfig`
    """
    cdef cyruntime.cudaFuncCache pCacheConfig
    with nogil:
        err = cyruntime.cudaDeviceGetCacheConfig(&pCacheConfig)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), cudaFuncCache(pCacheConfig))
{{endif}}

{{if 'cudaDeviceGetStreamPriorityRange' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGetStreamPriorityRange():
    """ Returns numerical values that correspond to the least and greatest stream priorities.

    Returns in `*leastPriority` and `*greatestPriority` the numerical
    values that correspond to the least and greatest stream priorities
    respectively. Stream priorities follow a convention where lower numbers
    imply greater priorities. The range of meaningful stream priorities is
    given by [`*greatestPriority`, `*leastPriority`]. If the user attempts
    to create a stream with a priority value that is outside the the
    meaningful range as specified by this API, the priority is
    automatically clamped down or up to either `*leastPriority` or
    `*greatestPriority` respectively. See
    :py:obj:`~.cudaStreamCreateWithPriority` for details on creating a
    priority stream. A NULL may be passed in for `*leastPriority` or
    `*greatestPriority` if the value is not desired.

    This function will return '0' in both `*leastPriority` and
    `*greatestPriority` if the current context's device does not support
    stream priorities (see :py:obj:`~.cudaDeviceGetAttribute`).

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`
    leastPriority : int
        Pointer to an int in which the numerical value for least stream
        priority is returned
    greatestPriority : int
        Pointer to an int in which the numerical value for greatest stream
        priority is returned

    See Also
    --------
    :py:obj:`~.cudaStreamCreateWithPriority`, :py:obj:`~.cudaStreamGetPriority`, :py:obj:`~.cuCtxGetStreamPriorityRange`
    """
    cdef int leastPriority = 0
    cdef int greatestPriority = 0
    with nogil:
        err = cyruntime.cudaDeviceGetStreamPriorityRange(&leastPriority, &greatestPriority)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None)
    return (cudaError_t(err), leastPriority, greatestPriority)
{{endif}}

{{if 'cudaDeviceSetCacheConfig' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceSetCacheConfig(cacheConfig not None : cudaFuncCache):
    """ Sets the preferred cache configuration for the current device.

    On devices where the L1 cache and shared memory use the same hardware
    resources, this sets through `cacheConfig` the preferred cache
    configuration for the current device. This is only a preference. The
    runtime will use the requested configuration if possible, but it is
    free to choose a different configuration if required to execute the
    function. Any function preference set via
    :py:obj:`~.cudaFuncSetCacheConfig (C API)` or cudaFuncSetCacheConfig
    (C++ API) will be preferred over this device-wide setting. Setting the
    device-wide cache configuration to :py:obj:`~.cudaFuncCachePreferNone`
    will cause subsequent kernel launches to prefer to not change the cache
    configuration unless required to launch the kernel.

    This setting does nothing on devices where the size of the L1 cache and
    shared memory are fixed.

    Launching a kernel with a different preference than the most recent
    preference setting may insert a device-side synchronization point.

    The supported cache configurations are:

    - :py:obj:`~.cudaFuncCachePreferNone`: no preference for shared memory
      or L1 (default)

    - :py:obj:`~.cudaFuncCachePreferShared`: prefer larger shared memory
      and smaller L1 cache

    - :py:obj:`~.cudaFuncCachePreferL1`: prefer larger L1 cache and smaller
      shared memory

    - :py:obj:`~.cudaFuncCachePreferEqual`: prefer equal size L1 cache and
      shared memory

    Parameters
    ----------
    cacheConfig : :py:obj:`~.cudaFuncCache`
        Requested cache configuration

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`

    See Also
    --------
    :py:obj:`~.cudaDeviceGetCacheConfig`, :py:obj:`~.cudaFuncSetCacheConfig (C API)`, cudaFuncSetCacheConfig (C++ API), :py:obj:`~.cuCtxSetCacheConfig`
    """
    cdef cyruntime.cudaFuncCache cycacheConfig = int(cacheConfig)
    with nogil:
        err = cyruntime.cudaDeviceSetCacheConfig(cycacheConfig)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaDeviceGetByPCIBusId' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGetByPCIBusId(char* pciBusId):
    """ Returns a handle to a compute device.

    Returns in `*device` a device ordinal given a PCI bus ID string.

    where `domain`, `bus`, `device`, and `function` are all hexadecimal
    values

    Parameters
    ----------
    pciBusId : bytes
        String in one of the following forms:

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidDevice`
    device : int
        Returned device ordinal

    See Also
    --------
    :py:obj:`~.cudaDeviceGetPCIBusId`, :py:obj:`~.cuDeviceGetByPCIBusId`
    """
    cdef int device = 0
    with nogil:
        err = cyruntime.cudaDeviceGetByPCIBusId(&device, pciBusId)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), device)
{{endif}}

{{if 'cudaDeviceGetPCIBusId' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGetPCIBusId(int length, int device):
    """ Returns a PCI Bus Id string for the device.

    Returns an ASCII string identifying the device `dev` in the NULL-
    terminated string pointed to by `pciBusId`. `length` specifies the
    maximum length of the string that may be returned.

    where `domain`, `bus`, `device`, and `function` are all hexadecimal
    values. pciBusId should be large enough to store 13 characters
    including the NULL-terminator.

    Parameters
    ----------
    length : int
        Maximum length of string to store in `name`
    device : int
        Device to get identifier string for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidDevice`
    pciBusId : bytes
        Returned identifier string for the device in the following format

    See Also
    --------
    :py:obj:`~.cudaDeviceGetByPCIBusId`, :py:obj:`~.cuDeviceGetPCIBusId`
    """
    pypciBusId = b" " * length
    cdef char* pciBusId = pypciBusId
    with nogil:
        err = cyruntime.cudaDeviceGetPCIBusId(pciBusId, length, device)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pypciBusId)
{{endif}}

{{if 'cudaIpcGetEventHandle' in found_functions}}

@cython.embedsignature(True)
def cudaIpcGetEventHandle(event):
    """ Gets an interprocess handle for a previously allocated event.

    Takes as input a previously allocated event. This event must have been
    created with the :py:obj:`~.cudaEventInterprocess` and
    :py:obj:`~.cudaEventDisableTiming` flags set. This opaque handle may be
    copied into other processes and opened with
    :py:obj:`~.cudaIpcOpenEventHandle` to allow efficient hardware
    synchronization between GPU work in different processes.

    After the event has been been opened in the importing process,
    :py:obj:`~.cudaEventRecord`, :py:obj:`~.cudaEventSynchronize`,
    :py:obj:`~.cudaStreamWaitEvent` and :py:obj:`~.cudaEventQuery` may be
    used in either process. Performing operations on the imported event
    after the exported event has been freed with
    :py:obj:`~.cudaEventDestroy` will result in undefined behavior.

    IPC functionality is restricted to devices with support for unified
    addressing on Linux and Windows operating systems. IPC functionality on
    Windows is supported for compatibility purposes but not recommended as
    it comes with performance cost. Users can test their device for IPC
    functionality by calling :py:obj:`~.cudaDeviceGetAttribute` with
    :py:obj:`~.cudaDevAttrIpcEventSupport`

    Parameters
    ----------
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event allocated with :py:obj:`~.cudaEventInterprocess` and
        :py:obj:`~.cudaEventDisableTiming` flags.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorMemoryAllocation`, :py:obj:`~.cudaErrorMapBufferObjectFailed`, :py:obj:`~.cudaErrorNotSupported`, :py:obj:`~.cudaErrorInvalidValue`
    handle : :py:obj:`~.cudaIpcEventHandle_t`
        Pointer to a user allocated cudaIpcEventHandle in which to return
        the opaque event handle

    See Also
    --------
    :py:obj:`~.cudaEventCreate`, :py:obj:`~.cudaEventDestroy`, :py:obj:`~.cudaEventSynchronize`, :py:obj:`~.cudaEventQuery`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaIpcOpenEventHandle`, :py:obj:`~.cudaIpcGetMemHandle`, :py:obj:`~.cudaIpcOpenMemHandle`, :py:obj:`~.cudaIpcCloseMemHandle`, :py:obj:`~.cuIpcGetEventHandle`
    """
    cdef cyruntime.cudaEvent_t cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (cudaEvent_t,driver.CUevent)):
        pevent = int(event)
    else:
        pevent = int(cudaEvent_t(event))
    cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
    cdef cudaIpcEventHandle_t handle = cudaIpcEventHandle_t()
    with nogil:
        err = cyruntime.cudaIpcGetEventHandle(<cyruntime.cudaIpcEventHandle_t*>handle._pvt_ptr, cyevent)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), handle)
{{endif}}

{{if 'cudaIpcOpenEventHandle' in found_functions}}

@cython.embedsignature(True)
def cudaIpcOpenEventHandle(handle not None : cudaIpcEventHandle_t):
    """ Opens an interprocess event handle for use in the current process.

    Opens an interprocess event handle exported from another process with
    :py:obj:`~.cudaIpcGetEventHandle`. This function returns a
    :py:obj:`~.cudaEvent_t` that behaves like a locally created event with
    the :py:obj:`~.cudaEventDisableTiming` flag specified. This event must
    be freed with :py:obj:`~.cudaEventDestroy`.

    Performing operations on the imported event after the exported event
    has been freed with :py:obj:`~.cudaEventDestroy` will result in
    undefined behavior.

    IPC functionality is restricted to devices with support for unified
    addressing on Linux and Windows operating systems. IPC functionality on
    Windows is supported for compatibility purposes but not recommended as
    it comes with performance cost. Users can test their device for IPC
    functionality by calling :py:obj:`~.cudaDeviceGetAttribute` with
    :py:obj:`~.cudaDevAttrIpcEventSupport`

    Parameters
    ----------
    handle : :py:obj:`~.cudaIpcEventHandle_t`
        Interprocess handle to open

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorMapBufferObjectFailed`, :py:obj:`~.cudaErrorNotSupported`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorDeviceUninitialized`
    event : :py:obj:`~.cudaEvent_t`
        Returns the imported event

    See Also
    --------
    :py:obj:`~.cudaEventCreate`, :py:obj:`~.cudaEventDestroy`, :py:obj:`~.cudaEventSynchronize`, :py:obj:`~.cudaEventQuery`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaIpcGetEventHandle`, :py:obj:`~.cudaIpcGetMemHandle`, :py:obj:`~.cudaIpcOpenMemHandle`, :py:obj:`~.cudaIpcCloseMemHandle`, :py:obj:`~.cuIpcOpenEventHandle`
    """
    cdef cudaEvent_t event = cudaEvent_t()
    with nogil:
        err = cyruntime.cudaIpcOpenEventHandle(<cyruntime.cudaEvent_t*>event._pvt_ptr, handle._pvt_ptr[0])
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), event)
{{endif}}

{{if 'cudaIpcGetMemHandle' in found_functions}}

@cython.embedsignature(True)
def cudaIpcGetMemHandle(devPtr):
    """ Gets an interprocess memory handle for an existing device memory allocation.

    Takes a pointer to the base of an existing device memory allocation
    created with :py:obj:`~.cudaMalloc` and exports it for use in another
    process. This is a lightweight operation and may be called multiple
    times on an allocation without adverse effects.

    If a region of memory is freed with :py:obj:`~.cudaFree` and a
    subsequent call to :py:obj:`~.cudaMalloc` returns memory with the same
    device address, :py:obj:`~.cudaIpcGetMemHandle` will return a unique
    handle for the new memory.

    IPC functionality is restricted to devices with support for unified
    addressing on Linux and Windows operating systems. IPC functionality on
    Windows is supported for compatibility purposes but not recommended as
    it comes with performance cost. Users can test their device for IPC
    functionality by calling :py:obj:`~.cudaDeviceGetAttribute` with
    :py:obj:`~.cudaDevAttrIpcEventSupport`

    Parameters
    ----------
    devPtr : Any
        Base pointer to previously allocated device memory

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorMemoryAllocation`, :py:obj:`~.cudaErrorMapBufferObjectFailed`, :py:obj:`~.cudaErrorNotSupported`, :py:obj:`~.cudaErrorInvalidValue`
    handle : :py:obj:`~.cudaIpcMemHandle_t`
        Pointer to user allocated :py:obj:`~.cudaIpcMemHandle` to return
        the handle in.

    See Also
    --------
    :py:obj:`~.cudaMalloc`, :py:obj:`~.cudaFree`, :py:obj:`~.cudaIpcGetEventHandle`, :py:obj:`~.cudaIpcOpenEventHandle`, :py:obj:`~.cudaIpcOpenMemHandle`, :py:obj:`~.cudaIpcCloseMemHandle`, :py:obj:`~.cuIpcGetMemHandle`
    """
    cdef cudaIpcMemHandle_t handle = cudaIpcMemHandle_t()
    cdef _HelperInputVoidPtrStruct cydevPtrHelper
    cdef void* cydevPtr = _helper_input_void_ptr(devPtr, &cydevPtrHelper)
    with nogil:
        err = cyruntime.cudaIpcGetMemHandle(<cyruntime.cudaIpcMemHandle_t*>handle._pvt_ptr, cydevPtr)
    _helper_input_void_ptr_free(&cydevPtrHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), handle)
{{endif}}

{{if 'cudaIpcOpenMemHandle' in found_functions}}

@cython.embedsignature(True)
def cudaIpcOpenMemHandle(handle not None : cudaIpcMemHandle_t, unsigned int flags):
    """ Opens an interprocess memory handle exported from another process and returns a device pointer usable in the local process.

    Maps memory exported from another process with
    :py:obj:`~.cudaIpcGetMemHandle` into the current device address space.
    For contexts on different devices :py:obj:`~.cudaIpcOpenMemHandle` can
    attempt to enable peer access between the devices as if the user called
    :py:obj:`~.cudaDeviceEnablePeerAccess`. This behavior is controlled by
    the :py:obj:`~.cudaIpcMemLazyEnablePeerAccess` flag.
    :py:obj:`~.cudaDeviceCanAccessPeer` can determine if a mapping is
    possible.

    :py:obj:`~.cudaIpcOpenMemHandle` can open handles to devices that may
    not be visible in the process calling the API.

    Contexts that may open :py:obj:`~.cudaIpcMemHandles` are restricted in
    the following way. :py:obj:`~.cudaIpcMemHandles` from each device in a
    given process may only be opened by one context per device per other
    process.

    If the memory handle has already been opened by the current context,
    the reference count on the handle is incremented by 1 and the existing
    device pointer is returned.

    Memory returned from :py:obj:`~.cudaIpcOpenMemHandle` must be freed
    with :py:obj:`~.cudaIpcCloseMemHandle`.

    Calling :py:obj:`~.cudaFree` on an exported memory region before
    calling :py:obj:`~.cudaIpcCloseMemHandle` in the importing context will
    result in undefined behavior.

    IPC functionality is restricted to devices with support for unified
    addressing on Linux and Windows operating systems. IPC functionality on
    Windows is supported for compatibility purposes but not recommended as
    it comes with performance cost. Users can test their device for IPC
    functionality by calling :py:obj:`~.cudaDeviceGetAttribute` with
    :py:obj:`~.cudaDevAttrIpcEventSupport`

    Parameters
    ----------
    handle : :py:obj:`~.cudaIpcMemHandle_t`
        :py:obj:`~.cudaIpcMemHandle` to open
    flags : unsigned int
        Flags for this operation. Must be specified as
        :py:obj:`~.cudaIpcMemLazyEnablePeerAccess`

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorMapBufferObjectFailed`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorDeviceUninitialized`, :py:obj:`~.cudaErrorTooManyPeers`, :py:obj:`~.cudaErrorNotSupported`, :py:obj:`~.cudaErrorInvalidValue`
    devPtr : Any
        Returned device pointer

    See Also
    --------
    :py:obj:`~.cudaMalloc`, :py:obj:`~.cudaFree`, :py:obj:`~.cudaIpcGetEventHandle`, :py:obj:`~.cudaIpcOpenEventHandle`, :py:obj:`~.cudaIpcGetMemHandle`, :py:obj:`~.cudaIpcCloseMemHandle`, :py:obj:`~.cudaDeviceEnablePeerAccess`, :py:obj:`~.cudaDeviceCanAccessPeer`, :py:obj:`~.cuIpcOpenMemHandle`

    Notes
    -----
    No guarantees are made about the address returned in `*devPtr`. 
     In particular, multiple processes may not receive the same address for the same `handle`.
    """
    cdef void_ptr devPtr = 0
    with nogil:
        err = cyruntime.cudaIpcOpenMemHandle(<void**>&devPtr, handle._pvt_ptr[0], flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), devPtr)
{{endif}}

{{if 'cudaIpcCloseMemHandle' in found_functions}}

@cython.embedsignature(True)
def cudaIpcCloseMemHandle(devPtr):
    """ Attempts to close memory mapped with cudaIpcOpenMemHandle.

    Decrements the reference count of the memory returnd by
    :py:obj:`~.cudaIpcOpenMemHandle` by 1. When the reference count reaches
    0, this API unmaps the memory. The original allocation in the exporting
    process as well as imported mappings in other processes will be
    unaffected.

    Any resources used to enable peer access will be freed if this is the
    last mapping using them.

    IPC functionality is restricted to devices with support for unified
    addressing on Linux and Windows operating systems. IPC functionality on
    Windows is supported for compatibility purposes but not recommended as
    it comes with performance cost. Users can test their device for IPC
    functionality by calling :py:obj:`~.cudaDeviceGetAttribute` with
    :py:obj:`~.cudaDevAttrIpcEventSupport`

    Parameters
    ----------
    devPtr : Any
        Device pointer returned by :py:obj:`~.cudaIpcOpenMemHandle`

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorMapBufferObjectFailed`, :py:obj:`~.cudaErrorNotSupported`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaMalloc`, :py:obj:`~.cudaFree`, :py:obj:`~.cudaIpcGetEventHandle`, :py:obj:`~.cudaIpcOpenEventHandle`, :py:obj:`~.cudaIpcGetMemHandle`, :py:obj:`~.cudaIpcOpenMemHandle`, :py:obj:`~.cuIpcCloseMemHandle`
    """
    cdef _HelperInputVoidPtrStruct cydevPtrHelper
    cdef void* cydevPtr = _helper_input_void_ptr(devPtr, &cydevPtrHelper)
    with nogil:
        err = cyruntime.cudaIpcCloseMemHandle(cydevPtr)
    _helper_input_void_ptr_free(&cydevPtrHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaDeviceFlushGPUDirectRDMAWrites' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceFlushGPUDirectRDMAWrites(target not None : cudaFlushGPUDirectRDMAWritesTarget, scope not None : cudaFlushGPUDirectRDMAWritesScope):
    """ Blocks until remote writes are visible to the specified scope.

    Blocks until remote writes to the target context via mappings created
    through GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see
    https://docs.nvidia.com/cuda/gpudirect-rdma for more information), are
    visible to the specified scope.

    If the scope equals or lies within the scope indicated by
    :py:obj:`~.cudaDevAttrGPUDirectRDMAWritesOrdering`, the call will be a
    no-op and can be safely omitted for performance. This can be determined
    by comparing the numerical values between the two enums, with smaller
    scopes having smaller values.

    Users may query support for this API via
    :py:obj:`~.cudaDevAttrGPUDirectRDMAFlushWritesOptions`.

    Parameters
    ----------
    target : :py:obj:`~.cudaFlushGPUDirectRDMAWritesTarget`
        The target of the operation, see cudaFlushGPUDirectRDMAWritesTarget
    scope : :py:obj:`~.cudaFlushGPUDirectRDMAWritesScope`
        The scope of the operation, see cudaFlushGPUDirectRDMAWritesScope

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorNotSupported`,

    See Also
    --------
    :py:obj:`~.cuFlushGPUDirectRDMAWrites`
    """
    cdef cyruntime.cudaFlushGPUDirectRDMAWritesTarget cytarget = int(target)
    cdef cyruntime.cudaFlushGPUDirectRDMAWritesScope cyscope = int(scope)
    with nogil:
        err = cyruntime.cudaDeviceFlushGPUDirectRDMAWrites(cytarget, cyscope)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaDeviceRegisterAsyncNotification' in found_functions}}

ctypedef struct cudaAsyncCallbackData_st:
    cyruntime.cudaAsyncCallback callback
    void *userData

ctypedef cudaAsyncCallbackData_st cudaAsyncCallbackData

@cython.show_performance_hints(False)
cdef void cudaAsyncNotificationCallbackWrapper(cyruntime.cudaAsyncNotificationInfo_t *info, void *data, cyruntime.cudaAsyncCallbackHandle_t handle) nogil:
    cdef cudaAsyncCallbackData *cbData = <cudaAsyncCallbackData *>data
    with gil:
        cbData.callback(info, cbData.userData, handle)

@cython.embedsignature(True)
def cudaDeviceRegisterAsyncNotification(int device, callbackFunc, userData):
    """ Registers a callback function to receive async notifications.

    Registers `callbackFunc` to receive async notifications.

    The `userData` parameter is passed to the callback function at async
    notification time. Likewise, `callback` is also passed to the callback
    function to distinguish between multiple registered callbacks.

    The callback function being registered should be designed to return
    quickly (~10ms). Any long running tasks should be queued for execution
    on an application thread.

    Callbacks may not call cudaDeviceRegisterAsyncNotification or
    cudaDeviceUnregisterAsyncNotification. Doing so will result in
    :py:obj:`~.cudaErrorNotPermitted`. Async notification callbacks execute
    in an undefined order and may be serialized.

    Returns in `*callback` a handle representing the registered callback
    instance.

    Parameters
    ----------
    device : int
        The device on which to register the callback
    callbackFunc : :py:obj:`~.cudaAsyncCallback`
        The function to register as a callback
    userData : Any
        A generic pointer to user data. This is passed into the callback
        function.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess` :py:obj:`~.cudaErrorNotSupported` :py:obj:`~.cudaErrorInvalidDevice` :py:obj:`~.cudaErrorInvalidValue` :py:obj:`~.cudaErrorNotPermitted` :py:obj:`~.cudaErrorUnknown`
    callback : :py:obj:`~.cudaAsyncCallbackHandle_t`
        A handle representing the registered callback instance

    See Also
    --------
    :py:obj:`~.cudaDeviceUnregisterAsyncNotification`
    """
    cdef cyruntime.cudaAsyncCallback cycallbackFunc
    if callbackFunc is None:
        pcallbackFunc = 0
    elif isinstance(callbackFunc, (cudaAsyncCallback,)):
        pcallbackFunc = int(callbackFunc)
    else:
        pcallbackFunc = int(cudaAsyncCallback(callbackFunc))
    cycallbackFunc = <cyruntime.cudaAsyncCallback><void_ptr>pcallbackFunc
    cdef _HelperInputVoidPtrStruct cyuserDataHelper
    cdef void* cyuserData = _helper_input_void_ptr(userData, &cyuserDataHelper)

    cdef cudaAsyncCallbackData *cbData = NULL
    cbData = <cudaAsyncCallbackData *>malloc(sizeof(cbData[0]))
    if cbData == NULL:
        return (cudaError_t.cudaErrorMemoryAllocation, None)
    cbData.callback = cycallbackFunc
    cbData.userData = cyuserData

    cdef cudaAsyncCallbackHandle_t callback = cudaAsyncCallbackHandle_t()
    with nogil:
        err = cyruntime.cudaDeviceRegisterAsyncNotification(device, <cyruntime.cudaAsyncCallback>cudaAsyncNotificationCallbackWrapper, <void *>cbData, <cyruntime.cudaAsyncCallbackHandle_t*>callback._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        free(cbData)
    else:
        m_global._allocated[int(callback)] = cbData
    _helper_input_void_ptr_free(&cyuserDataHelper)

    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), callback)
{{endif}}

{{if 'cudaDeviceUnregisterAsyncNotification' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceUnregisterAsyncNotification(int device, callback):
    """ Unregisters an async notification callback.

    Unregisters `callback` so that the corresponding callback function will
    stop receiving async notifications.

    Parameters
    ----------
    device : int
        The device from which to remove `callback`.
    callback : :py:obj:`~.cudaAsyncCallbackHandle_t`
        The callback instance to unregister from receiving async
        notifications.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess` :py:obj:`~.cudaErrorNotSupported` :py:obj:`~.cudaErrorInvalidDevice` :py:obj:`~.cudaErrorInvalidValue` :py:obj:`~.cudaErrorNotPermitted` :py:obj:`~.cudaErrorUnknown`

    See Also
    --------
    :py:obj:`~.cudaDeviceRegisterAsyncNotification`
    """
    cdef cyruntime.cudaAsyncCallbackHandle_t cycallback
    if callback is None:
        pcallback = 0
    elif isinstance(callback, (cudaAsyncCallbackHandle_t,)):
        pcallback = int(callback)
    else:
        pcallback = int(cudaAsyncCallbackHandle_t(callback))
    cycallback = <cyruntime.cudaAsyncCallbackHandle_t><void_ptr>pcallback
    with nogil:
        err = cyruntime.cudaDeviceUnregisterAsyncNotification(device, cycallback)
    if err == cyruntime.cudaSuccess:
        free(m_global._allocated[pcallback])
        m_global._allocated.erase(<void_ptr>pcallback)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaDeviceGetSharedMemConfig' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGetSharedMemConfig():
    """ Returns the shared memory configuration for the current device.

    [Deprecated]

    This function will return in `pConfig` the current size of shared
    memory banks on the current device. On devices with configurable shared
    memory banks, :py:obj:`~.cudaDeviceSetSharedMemConfig` can be used to
    change this setting, so that all subsequent kernel launches will by
    default use the new bank size. When
    :py:obj:`~.cudaDeviceGetSharedMemConfig` is called on devices without
    configurable shared memory, it will return the fixed bank size of the
    hardware.

    The returned bank configurations can be either:

    - :py:obj:`~.cudaSharedMemBankSizeFourByte` - shared memory bank width
      is four bytes.

    - :py:obj:`~.cudaSharedMemBankSizeEightByte` - shared memory bank width
      is eight bytes.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pConfig : :py:obj:`~.cudaSharedMemConfig`
        Returned cache configuration

    See Also
    --------
    :py:obj:`~.cudaDeviceSetCacheConfig`, :py:obj:`~.cudaDeviceGetCacheConfig`, :py:obj:`~.cudaDeviceSetSharedMemConfig`, :py:obj:`~.cudaFuncSetCacheConfig`, :py:obj:`~.cuCtxGetSharedMemConfig`
    """
    cdef cyruntime.cudaSharedMemConfig pConfig
    with nogil:
        err = cyruntime.cudaDeviceGetSharedMemConfig(&pConfig)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), cudaSharedMemConfig(pConfig))
{{endif}}

{{if 'cudaDeviceSetSharedMemConfig' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceSetSharedMemConfig(config not None : cudaSharedMemConfig):
    """ Sets the shared memory configuration for the current device.

    [Deprecated]

    On devices with configurable shared memory banks, this function will
    set the shared memory bank size which is used for all subsequent kernel
    launches. Any per-function setting of shared memory set via
    :py:obj:`~.cudaFuncSetSharedMemConfig` will override the device wide
    setting.

    Changing the shared memory configuration between launches may introduce
    a device side synchronization point.

    Changing the shared memory bank size will not increase shared memory
    usage or affect occupancy of kernels, but may have major effects on
    performance. Larger bank sizes will allow for greater potential
    bandwidth to shared memory, but will change what kinds of accesses to
    shared memory will result in bank conflicts.

    This function will do nothing on devices with fixed shared memory bank
    size.

    The supported bank configurations are:

    - :py:obj:`~.cudaSharedMemBankSizeDefault`: set bank width the device
      default (currently, four bytes)

    - :py:obj:`~.cudaSharedMemBankSizeFourByte`: set shared memory bank
      width to be four bytes natively.

    - :py:obj:`~.cudaSharedMemBankSizeEightByte`: set shared memory bank
      width to be eight bytes natively.

    Parameters
    ----------
    config : :py:obj:`~.cudaSharedMemConfig`
        Requested cache configuration

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaDeviceSetCacheConfig`, :py:obj:`~.cudaDeviceGetCacheConfig`, :py:obj:`~.cudaDeviceGetSharedMemConfig`, :py:obj:`~.cudaFuncSetCacheConfig`, :py:obj:`~.cuCtxSetSharedMemConfig`
    """
    cdef cyruntime.cudaSharedMemConfig cyconfig = int(config)
    with nogil:
        err = cyruntime.cudaDeviceSetSharedMemConfig(cyconfig)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGetLastError' in found_functions}}

@cython.embedsignature(True)
def cudaGetLastError():
    """ Returns the last error from a runtime call.

    Returns the last error that has been produced by any of the runtime
    calls in the same instance of the CUDA Runtime library in the host
    thread and resets it to :py:obj:`~.cudaSuccess`.

    Note: Multiple instances of the CUDA Runtime library can be present in
    an application when using a library that statically links the CUDA
    Runtime.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorMissingConfiguration`, :py:obj:`~.cudaErrorMemoryAllocation`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorLaunchFailure`, :py:obj:`~.cudaErrorLaunchTimeout`, :py:obj:`~.cudaErrorLaunchOutOfResources`, :py:obj:`~.cudaErrorInvalidDeviceFunction`, :py:obj:`~.cudaErrorInvalidConfiguration`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidPitchValue`, :py:obj:`~.cudaErrorInvalidSymbol`, :py:obj:`~.cudaErrorUnmapBufferObjectFailed`, :py:obj:`~.cudaErrorInvalidDevicePointer`, :py:obj:`~.cudaErrorInvalidTexture`, :py:obj:`~.cudaErrorInvalidTextureBinding`, :py:obj:`~.cudaErrorInvalidChannelDescriptor`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`, :py:obj:`~.cudaErrorInvalidFilterSetting`, :py:obj:`~.cudaErrorInvalidNormSetting`, :py:obj:`~.cudaErrorUnknown`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorInsufficientDriver`, :py:obj:`~.cudaErrorNoDevice`, :py:obj:`~.cudaErrorSetOnActiveProcess`, :py:obj:`~.cudaErrorStartupFailure`, :py:obj:`~.cudaErrorInvalidPtx`, :py:obj:`~.cudaErrorUnsupportedPtxVersion`, :py:obj:`~.cudaErrorNoKernelImageForDevice`, :py:obj:`~.cudaErrorJitCompilerNotFound`, :py:obj:`~.cudaErrorJitCompilationDisabled`

    See Also
    --------
    :py:obj:`~.cudaPeekAtLastError`, :py:obj:`~.cudaGetErrorName`, :py:obj:`~.cudaGetErrorString`, :py:obj:`~.cudaError`
    """
    with nogil:
        err = cyruntime.cudaGetLastError()
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaPeekAtLastError' in found_functions}}

@cython.embedsignature(True)
def cudaPeekAtLastError():
    """ Returns the last error from a runtime call.

    Returns the last error that has been produced by any of the runtime
    calls in the same instance of the CUDA Runtime library in the host
    thread. This call does not reset the error to :py:obj:`~.cudaSuccess`
    like :py:obj:`~.cudaGetLastError()`.

    Note: Multiple instances of the CUDA Runtime library can be present in
    an application when using a library that statically links the CUDA
    Runtime.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorMissingConfiguration`, :py:obj:`~.cudaErrorMemoryAllocation`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorLaunchFailure`, :py:obj:`~.cudaErrorLaunchTimeout`, :py:obj:`~.cudaErrorLaunchOutOfResources`, :py:obj:`~.cudaErrorInvalidDeviceFunction`, :py:obj:`~.cudaErrorInvalidConfiguration`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidPitchValue`, :py:obj:`~.cudaErrorInvalidSymbol`, :py:obj:`~.cudaErrorUnmapBufferObjectFailed`, :py:obj:`~.cudaErrorInvalidDevicePointer`, :py:obj:`~.cudaErrorInvalidTexture`, :py:obj:`~.cudaErrorInvalidTextureBinding`, :py:obj:`~.cudaErrorInvalidChannelDescriptor`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`, :py:obj:`~.cudaErrorInvalidFilterSetting`, :py:obj:`~.cudaErrorInvalidNormSetting`, :py:obj:`~.cudaErrorUnknown`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorInsufficientDriver`, :py:obj:`~.cudaErrorNoDevice`, :py:obj:`~.cudaErrorSetOnActiveProcess`, :py:obj:`~.cudaErrorStartupFailure`, :py:obj:`~.cudaErrorInvalidPtx`, :py:obj:`~.cudaErrorUnsupportedPtxVersion`, :py:obj:`~.cudaErrorNoKernelImageForDevice`, :py:obj:`~.cudaErrorJitCompilerNotFound`, :py:obj:`~.cudaErrorJitCompilationDisabled`

    See Also
    --------
    :py:obj:`~.cudaGetLastError`, :py:obj:`~.cudaGetErrorName`, :py:obj:`~.cudaGetErrorString`, :py:obj:`~.cudaError`
    """
    with nogil:
        err = cyruntime.cudaPeekAtLastError()
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGetErrorName' in found_functions}}

@cython.embedsignature(True)
def cudaGetErrorName(error not None : cudaError_t):
    """ Returns the string representation of an error code enum name.

    Returns a string containing the name of an error code in the enum. If
    the error code is not recognized, "unrecognized error code" is
    returned.

    Parameters
    ----------
    error : :py:obj:`~.cudaError_t`
        Error code to convert to string

    Returns
    -------
    cudaError_t.cudaSuccess
        cudaError_t.cudaSuccess
    bytes
        `char*` pointer to a NULL-terminated string

    See Also
    --------
    :py:obj:`~.cudaGetErrorString`, :py:obj:`~.cudaGetLastError`, :py:obj:`~.cudaPeekAtLastError`, :py:obj:`~.cudaError`, :py:obj:`~.cuGetErrorName`
    """
    cdef cyruntime.cudaError_t cyerror = int(error)
    with nogil:
        err = cyruntime.cudaGetErrorName(cyerror)
    return (cudaError_t.cudaSuccess, err)
{{endif}}

{{if 'cudaGetErrorString' in found_functions}}

@cython.embedsignature(True)
def cudaGetErrorString(error not None : cudaError_t):
    """ Returns the description string for an error code.

    Returns the description string for an error code. If the error code is
    not recognized, "unrecognized error code" is returned.

    Parameters
    ----------
    error : :py:obj:`~.cudaError_t`
        Error code to convert to string

    Returns
    -------
    cudaError_t.cudaSuccess
        cudaError_t.cudaSuccess
    bytes
        `char*` pointer to a NULL-terminated string

    See Also
    --------
    :py:obj:`~.cudaGetErrorName`, :py:obj:`~.cudaGetLastError`, :py:obj:`~.cudaPeekAtLastError`, :py:obj:`~.cudaError`, :py:obj:`~.cuGetErrorString`
    """
    cdef cyruntime.cudaError_t cyerror = int(error)
    with nogil:
        err = cyruntime.cudaGetErrorString(cyerror)
    return (cudaError_t.cudaSuccess, err)
{{endif}}

{{if 'cudaGetDeviceCount' in found_functions}}

@cython.embedsignature(True)
def cudaGetDeviceCount():
    """ Returns the number of compute-capable devices.

    Returns in `*count` the number of devices with compute capability
    greater or equal to 2.0 that are available for execution.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`
    count : int
        Returns the number of devices with compute capability greater or
        equal to 2.0

    See Also
    --------
    :py:obj:`~.cudaGetDevice`, :py:obj:`~.cudaSetDevice`, :py:obj:`~.cudaGetDeviceProperties`, :py:obj:`~.cudaChooseDevice`, :py:obj:`~.cudaInitDevice`, :py:obj:`~.cuDeviceGetCount`
    """
    cdef int count = 0
    with nogil:
        err = cyruntime.cudaGetDeviceCount(&count)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), count)
{{endif}}

{{if 'cudaGetDeviceProperties' in found_functions}}

@cython.embedsignature(True)
def cudaGetDeviceProperties(int device):
    """ Returns information about the compute-device.

    Returns in `*prop` the properties of device `dev`.

    Parameters
    ----------
    device : int
        Device number to get properties for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`
    prop : :py:obj:`~.cudaDeviceProp`
        Properties for the specified device

    See Also
    --------
    :py:obj:`~.cudaGetDeviceCount`, :py:obj:`~.cudaGetDevice`, :py:obj:`~.cudaSetDevice`, :py:obj:`~.cudaChooseDevice`, :py:obj:`~.cudaDeviceGetAttribute`, :py:obj:`~.cudaInitDevice`, :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetName`
    """
    cdef cudaDeviceProp prop = cudaDeviceProp()
    with nogil:
        err = cyruntime.cudaGetDeviceProperties(<cyruntime.cudaDeviceProp*>prop._pvt_ptr, device)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), prop)
{{endif}}

{{if 'cudaDeviceGetAttribute' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGetAttribute(attr not None : cudaDeviceAttr, int device):
    """ Returns information about the device.

    Returns in `*value` the integer value of the attribute `attr` on device
    `device`.

    Parameters
    ----------
    attr : :py:obj:`~.cudaDeviceAttr`
        Device attribute to query
    device : int
        Device number to query

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidValue`
    value : int
        Returned device attribute value

    See Also
    --------
    :py:obj:`~.cudaGetDeviceCount`, :py:obj:`~.cudaGetDevice`, :py:obj:`~.cudaSetDevice`, :py:obj:`~.cudaChooseDevice`, :py:obj:`~.cudaGetDeviceProperties`, :py:obj:`~.cudaInitDevice`, :py:obj:`~.cuDeviceGetAttribute`
    """
    cdef int value = 0
    cdef cyruntime.cudaDeviceAttr cyattr = int(attr)
    with nogil:
        err = cyruntime.cudaDeviceGetAttribute(&value, cyattr, device)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), value)
{{endif}}

{{if 'cudaDeviceGetHostAtomicCapabilities' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGetHostAtomicCapabilities(operations : Optional[tuple[cudaAtomicOperation] | list[cudaAtomicOperation]], unsigned int count, int device):
    """ Queries details about atomic operations supported between the device and host.

    Returns in `*capabilities` the details about requested atomic
    `*operations` over the the link between `dev` and the host. The
    allocated size of `*operations` and `*capabilities` must be `count`.

    For each :py:obj:`~.cudaAtomicOperation` in `*operations`, the
    corresponding result in `*capabilities` will be a bitmask indicating
    which of :py:obj:`~.cudaAtomicOperationCapability` the link supports
    natively.

    Returns :py:obj:`~.cudaErrorInvalidDevice` if `dev` is not valid.

    Returns :py:obj:`~.cudaErrorInvalidValue` if `*capabilities` or
    `*operations` is NULL, if `count` is 0, or if any of `*operations` is
    not valid.

    Parameters
    ----------
    operations : list[:py:obj:`~.cudaAtomicOperation`]
        Requested operations
    count : unsigned int
        Count of requested operations and size of capabilities
    dev : int
        Device handle

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidValue`
    capabilities : list[unsigned int]
        Returned capability details of each requested operation

    See Also
    --------
    :py:obj:`~.cudaDeviceGetAttribute`, :py:obj:`~.cudaDeviceGetP2PAtomicCapabilities`, :py:obj:`~.cuDeviceGeHostAtomicCapabilities`
    """
    operations = [] if operations is None else operations
    if not all(isinstance(_x, (cudaAtomicOperation)) for _x in operations):
        raise TypeError("Argument 'operations' is not instance of type (expected tuple[cyruntime.cudaAtomicOperation] or list[cyruntime.cudaAtomicOperation]")
    cdef unsigned int* cycapabilities = NULL
    pycapabilities = []
    if count != 0:
        cycapabilities = <unsigned int*>calloc(count, sizeof(unsigned int))
        if cycapabilities is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(count) + 'x' + str(sizeof(unsigned int)))
    cdef vector[cyruntime.cudaAtomicOperation] cyoperations = [int(pyoperations) for pyoperations in (operations)]
    if count > len(operations): raise RuntimeError("List is too small: " + str(len(operations)) + " < " + str(count))
    with nogil:
        err = cyruntime.cudaDeviceGetHostAtomicCapabilities(cycapabilities, cyoperations.data(), count, device)
    if cudaError_t(err) == cudaError_t(0):
        pycapabilities = [<unsigned int>cycapabilities[idx] for idx in range(count)]
    if cycapabilities is not NULL:
        free(cycapabilities)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pycapabilities)
{{endif}}

{{if 'cudaDeviceGetDefaultMemPool' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGetDefaultMemPool(int device):
    """ Returns the default mempool of a device.

    The default mempool of a device contains device memory from that
    device.

    Parameters
    ----------
    device : int
        None

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidValue` :py:obj:`~.cudaErrorNotSupported`
    memPool : :py:obj:`~.cudaMemPool_t`
        None

    See Also
    --------
    :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cudaMallocAsync`, :py:obj:`~.cudaMemPoolTrimTo`, :py:obj:`~.cudaMemPoolGetAttribute`, :py:obj:`~.cudaDeviceSetMemPool`, :py:obj:`~.cudaMemPoolSetAttribute`, :py:obj:`~.cudaMemPoolSetAccess`
    """
    cdef cudaMemPool_t memPool = cudaMemPool_t()
    with nogil:
        err = cyruntime.cudaDeviceGetDefaultMemPool(<cyruntime.cudaMemPool_t*>memPool._pvt_ptr, device)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), memPool)
{{endif}}

{{if 'cudaDeviceSetMemPool' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceSetMemPool(int device, memPool):
    """ Sets the current memory pool of a device.

    The memory pool must be local to the specified device. Unless a mempool
    is specified in the :py:obj:`~.cudaMallocAsync` call,
    :py:obj:`~.cudaMallocAsync` allocates from the current mempool of the
    provided stream's device. By default, a device's current memory pool is
    its default memory pool.

    Parameters
    ----------
    device : int
        None
    memPool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        None

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue` :py:obj:`~.cudaErrorInvalidDevice` :py:obj:`~.cudaErrorNotSupported`

    See Also
    --------
    :py:obj:`~.cuDeviceSetMemPool`, :py:obj:`~.cudaDeviceGetMemPool`, :py:obj:`~.cudaDeviceGetDefaultMemPool`, :py:obj:`~.cudaMemPoolCreate`, :py:obj:`~.cudaMemPoolDestroy`, :py:obj:`~.cudaMallocFromPoolAsync`

    Notes
    -----
    Use :py:obj:`~.cudaMallocFromPoolAsync` to specify asynchronous allocations from a device different than the one the stream runs on.
    """
    cdef cyruntime.cudaMemPool_t cymemPool
    if memPool is None:
        pmemPool = 0
    elif isinstance(memPool, (cudaMemPool_t,driver.CUmemoryPool)):
        pmemPool = int(memPool)
    else:
        pmemPool = int(cudaMemPool_t(memPool))
    cymemPool = <cyruntime.cudaMemPool_t><void_ptr>pmemPool
    with nogil:
        err = cyruntime.cudaDeviceSetMemPool(device, cymemPool)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaDeviceGetMemPool' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGetMemPool(int device):
    """ Gets the current mempool for a device.

    Returns the last pool provided to :py:obj:`~.cudaDeviceSetMemPool` for
    this device or the device's default memory pool if
    :py:obj:`~.cudaDeviceSetMemPool` has never been called. By default the
    current mempool is the default mempool for a device, otherwise the
    returned pool must have been set with :py:obj:`~.cuDeviceSetMemPool` or
    :py:obj:`~.cudaDeviceSetMemPool`.

    Parameters
    ----------
    device : int
        None

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue` :py:obj:`~.cudaErrorNotSupported`
    memPool : :py:obj:`~.cudaMemPool_t`
        None

    See Also
    --------
    :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cudaDeviceGetDefaultMemPool`, :py:obj:`~.cudaDeviceSetMemPool`
    """
    cdef cudaMemPool_t memPool = cudaMemPool_t()
    with nogil:
        err = cyruntime.cudaDeviceGetMemPool(<cyruntime.cudaMemPool_t*>memPool._pvt_ptr, device)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), memPool)
{{endif}}

{{if 'cudaDeviceGetNvSciSyncAttributes' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGetNvSciSyncAttributes(nvSciSyncAttrList, int device, int flags):
    """ Return NvSciSync attributes that this device can support.

    Returns in `nvSciSyncAttrList`, the properties of NvSciSync that this
    CUDA device, `dev` can support. The returned `nvSciSyncAttrList` can be
    used to create an NvSciSync that matches this device's capabilities.

    If NvSciSyncAttrKey_RequiredPerm field in `nvSciSyncAttrList` is
    already set this API will return :py:obj:`~.cudaErrorInvalidValue`.

    The applications should set `nvSciSyncAttrList` to a valid
    NvSciSyncAttrList failing which this API will return
    :py:obj:`~.cudaErrorInvalidHandle`.

    The `flags` controls how applications intends to use the NvSciSync
    created from the `nvSciSyncAttrList`. The valid flags are:

    - :py:obj:`~.cudaNvSciSyncAttrSignal`, specifies that the applications
      intends to signal an NvSciSync on this CUDA device.

    - :py:obj:`~.cudaNvSciSyncAttrWait`, specifies that the applications
      intends to wait on an NvSciSync on this CUDA device.

    At least one of these flags must be set, failing which the API returns
    :py:obj:`~.cudaErrorInvalidValue`. Both the flags are orthogonal to one
    another: a developer may set both these flags that allows to set both
    wait and signal specific attributes in the same `nvSciSyncAttrList`.

    Note that this API updates the input `nvSciSyncAttrList` with values
    equivalent to the following public attribute key-values:
    NvSciSyncAttrKey_RequiredPerm is set to

    - NvSciSyncAccessPerm_SignalOnly if :py:obj:`~.cudaNvSciSyncAttrSignal`
      is set in `flags`.

    - NvSciSyncAccessPerm_WaitOnly if :py:obj:`~.cudaNvSciSyncAttrWait` is
      set in `flags`.

    - NvSciSyncAccessPerm_WaitSignal if both
      :py:obj:`~.cudaNvSciSyncAttrWait` and
      :py:obj:`~.cudaNvSciSyncAttrSignal` are set in `flags`.
      NvSciSyncAttrKey_PrimitiveInfo is set to

    - NvSciSyncAttrValPrimitiveType_SysmemSemaphore on any valid `device`.

    - NvSciSyncAttrValPrimitiveType_Syncpoint if `device` is a Tegra
      device.

    - NvSciSyncAttrValPrimitiveType_SysmemSemaphorePayload64b if `device`
      is GA10X+. NvSciSyncAttrKey_GpuId is set to the same UUID that is
      returned in `None` from :py:obj:`~.cudaDeviceGetProperties` for this
      `device`.

    :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorDeviceUninitialized`,
    :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidHandle`,
    :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorNotSupported`,
    :py:obj:`~.cudaErrorMemoryAllocation`

    Parameters
    ----------
    nvSciSyncAttrList : Any
        Return NvSciSync attributes supported.
    device : int
        Valid Cuda Device to get NvSciSync attributes for.
    flags : int
        flags describing NvSciSync usage.

    Returns
    -------
    cudaError_t


    See Also
    --------
    :py:obj:`~.cudaImportExternalSemaphore`, :py:obj:`~.cudaDestroyExternalSemaphore`, :py:obj:`~.cudaSignalExternalSemaphoresAsync`, :py:obj:`~.cudaWaitExternalSemaphoresAsync`
    """
    cdef _HelperInputVoidPtrStruct cynvSciSyncAttrListHelper
    cdef void* cynvSciSyncAttrList = _helper_input_void_ptr(nvSciSyncAttrList, &cynvSciSyncAttrListHelper)
    with nogil:
        err = cyruntime.cudaDeviceGetNvSciSyncAttributes(cynvSciSyncAttrList, device, flags)
    _helper_input_void_ptr_free(&cynvSciSyncAttrListHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaDeviceGetP2PAttribute' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGetP2PAttribute(attr not None : cudaDeviceP2PAttr, int srcDevice, int dstDevice):
    """ Queries attributes of the link between two devices.

    Returns in `*value` the value of the requested attribute `attrib` of
    the link between `srcDevice` and `dstDevice`. The supported attributes
    are:

    - :py:obj:`~.cudaDevP2PAttrPerformanceRank`: A relative value
      indicating the performance of the link between two devices. Lower
      value means better performance (0 being the value used for most
      performant link).

    - :py:obj:`~.cudaDevP2PAttrAccessSupported`: 1 if peer access is
      enabled.

    - :py:obj:`~.cudaDevP2PAttrNativeAtomicSupported`: 1 if all native
      atomic operations over the link are supported.

    - :py:obj:`~.cudaDevP2PAttrCudaArrayAccessSupported`: 1 if accessing
      CUDA arrays over the link is supported.

    - :py:obj:`~.cudaDevP2PAttrOnlyPartialNativeAtomicSupported`: 1 if some
      CUDA-valid atomic operations over the link are supported. Information
      about specific operations can be retrieved with
      :py:obj:`~.cudaDeviceGetP2PAtomicCapabilities`.

    Returns :py:obj:`~.cudaErrorInvalidDevice` if `srcDevice` or
    `dstDevice` are not valid or if they represent the same device.

    Returns :py:obj:`~.cudaErrorInvalidValue` if `attrib` is not valid or
    if `value` is a null pointer.

    Parameters
    ----------
    attrib : :py:obj:`~.cudaDeviceP2PAttr`
        The requested attribute of the link between `srcDevice` and
        `dstDevice`.
    srcDevice : int
        The source device of the target link.
    dstDevice : int
        The destination device of the target link.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidValue`
    value : int
        Returned value of the requested attribute

    See Also
    --------
    :py:obj:`~.cudaDeviceEnablePeerAccess`, :py:obj:`~.cudaDeviceDisablePeerAccess`, :py:obj:`~.cudaDeviceCanAccessPeer`, :py:obj:`~.cuDeviceGetP2PAttribute` :py:obj:`~.cudaDeviceGetP2PAtomicCapabilities`
    """
    cdef int value = 0
    cdef cyruntime.cudaDeviceP2PAttr cyattr = int(attr)
    with nogil:
        err = cyruntime.cudaDeviceGetP2PAttribute(&value, cyattr, srcDevice, dstDevice)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), value)
{{endif}}

{{if 'cudaDeviceGetP2PAtomicCapabilities' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGetP2PAtomicCapabilities(operations : Optional[tuple[cudaAtomicOperation] | list[cudaAtomicOperation]], unsigned int count, int srcDevice, int dstDevice):
    """ Queries details about atomic operations supported between two devices.

    Returns in `*capabilities` the details about requested atomic
    `*operations` over the the link between `srcDevice` and `dstDevice`.
    The allocated size of `*operations` and `*capabilities` must be
    `count`.

    For each :py:obj:`~.cudaAtomicOperation` in `*operations`, the
    corresponding result in `*capabilities` will be a bitmask indicating
    which of :py:obj:`~.cudaAtomicOperationCapability` the link supports
    natively.

    Returns :py:obj:`~.cudaErrorInvalidDevice` if `srcDevice` or
    `dstDevice` are not valid or if they represent the same device.

    Returns :py:obj:`~.cudaErrorInvalidValue` if `*capabilities` or
    `*operations` is NULL, if `count` is 0, or if any of `*operations` is
    not valid.

    Parameters
    ----------
    operations : list[:py:obj:`~.cudaAtomicOperation`]
        Requested operations
    count : unsigned int
        Count of requested operations and size of capabilities
    srcDevice : int
        The source device of the target link
    dstDevice : int
        The destination device of the target link

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidValue`
    capabilities : list[unsigned int]
        Returned capability details of each requested operation

    See Also
    --------
    :py:obj:`~.cudaDeviceGetP2PAttribute`, :py:obj:`~.cuDeviceGetP2PAttribute`, :py:obj:`~.cuDeviceGetP2PAtomicCapabilities`
    """
    operations = [] if operations is None else operations
    if not all(isinstance(_x, (cudaAtomicOperation)) for _x in operations):
        raise TypeError("Argument 'operations' is not instance of type (expected tuple[cyruntime.cudaAtomicOperation] or list[cyruntime.cudaAtomicOperation]")
    cdef unsigned int* cycapabilities = NULL
    pycapabilities = []
    if count != 0:
        cycapabilities = <unsigned int*>calloc(count, sizeof(unsigned int))
        if cycapabilities is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(count) + 'x' + str(sizeof(unsigned int)))
    cdef vector[cyruntime.cudaAtomicOperation] cyoperations = [int(pyoperations) for pyoperations in (operations)]
    if count > len(operations): raise RuntimeError("List is too small: " + str(len(operations)) + " < " + str(count))
    with nogil:
        err = cyruntime.cudaDeviceGetP2PAtomicCapabilities(cycapabilities, cyoperations.data(), count, srcDevice, dstDevice)
    if cudaError_t(err) == cudaError_t(0):
        pycapabilities = [<unsigned int>cycapabilities[idx] for idx in range(count)]
    if cycapabilities is not NULL:
        free(cycapabilities)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pycapabilities)
{{endif}}

{{if 'cudaChooseDevice' in found_functions}}

@cython.embedsignature(True)
def cudaChooseDevice(prop : Optional[cudaDeviceProp]):
    """ Select compute-device which best matches criteria.

    Returns in `*device` the device which has properties that best match
    `*prop`.

    Parameters
    ----------
    prop : :py:obj:`~.cudaDeviceProp`
        Desired device properties

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    device : int
        Device with best match

    See Also
    --------
    :py:obj:`~.cudaGetDeviceCount`, :py:obj:`~.cudaGetDevice`, :py:obj:`~.cudaSetDevice`, :py:obj:`~.cudaGetDeviceProperties`, :py:obj:`~.cudaInitDevice`
    """
    cdef int device = 0
    cdef cyruntime.cudaDeviceProp* cyprop_ptr = prop._pvt_ptr if prop is not None else NULL
    with nogil:
        err = cyruntime.cudaChooseDevice(&device, cyprop_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), device)
{{endif}}

{{if 'cudaInitDevice' in found_functions}}

@cython.embedsignature(True)
def cudaInitDevice(int device, unsigned int deviceFlags, unsigned int flags):
    """ Initialize device to be used for GPU executions.

    This function will initialize the CUDA Runtime structures and primary
    context on `device` when called, but the context will not be made
    current to `device`.

    When :py:obj:`~.cudaInitDeviceFlagsAreValid` is set in `flags`,
    deviceFlags are applied to the requested device. The values of
    deviceFlags match those of the flags parameters in
    :py:obj:`~.cudaSetDeviceFlags`. The effect may be verified by
    :py:obj:`~.cudaGetDeviceFlags`.

    This function will return an error if the device is in
    :py:obj:`~.cudaComputeModeExclusiveProcess` and is occupied by another
    process or if the device is in :py:obj:`~.cudaComputeModeProhibited`.

    Parameters
    ----------
    device : int
        Device on which the runtime will initialize itself.
    deviceFlags : unsigned int
        Parameters for device operation.
    flags : unsigned int
        Flags for controlling the device initialization.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`,

    See Also
    --------
    :py:obj:`~.cudaGetDeviceCount`, :py:obj:`~.cudaGetDevice`, :py:obj:`~.cudaGetDeviceProperties`, :py:obj:`~.cudaChooseDevice`, :py:obj:`~.cudaSetDevice` :py:obj:`~.cuCtxSetCurrent`
    """
    with nogil:
        err = cyruntime.cudaInitDevice(device, deviceFlags, flags)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaSetDevice' in found_functions}}

@cython.embedsignature(True)
def cudaSetDevice(int device):
    """ Set device to be used for GPU executions.

    Sets `device` as the current device for the calling host thread. Valid
    device id's are 0 to (:py:obj:`~.cudaGetDeviceCount()` - 1).

    Any device memory subsequently allocated from this host thread using
    :py:obj:`~.cudaMalloc()`, :py:obj:`~.cudaMallocPitch()` or
    :py:obj:`~.cudaMallocArray()` will be physically resident on `device`.
    Any host memory allocated from this host thread using
    :py:obj:`~.cudaMallocHost()` or :py:obj:`~.cudaHostAlloc()` or
    :py:obj:`~.cudaHostRegister()` will have its lifetime associated with
    `device`. Any streams or events created from this host thread will be
    associated with `device`. Any kernels launched from this host thread
    using the <<<>>> operator or :py:obj:`~.cudaLaunchKernel()` will be
    executed on `device`.

    This call may be made from any host thread, to any device, and at any
    time. This function will do no synchronization with the previous or new
    device, and should only take significant time when it initializes the
    runtime's context state. This call will bind the primary context of the
    specified device to the calling thread and all the subsequent memory
    allocations, stream and event creations, and kernel launches will be
    associated with the primary context. This function will also
    immediately initialize the runtime state on the primary context, and
    the context will be current on `device` immediately. This function will
    return an error if the device is in
    :py:obj:`~.cudaComputeModeExclusiveProcess` and is occupied by another
    process or if the device is in :py:obj:`~.cudaComputeModeProhibited`.

    It is not required to call :py:obj:`~.cudaInitDevice` before using this
    function.

    Parameters
    ----------
    device : int
        Device on which the active host thread should execute the device
        code.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorDeviceUnavailable`,

    See Also
    --------
    :py:obj:`~.cudaGetDeviceCount`, :py:obj:`~.cudaGetDevice`, :py:obj:`~.cudaGetDeviceProperties`, :py:obj:`~.cudaChooseDevice`, :py:obj:`~.cudaInitDevice`, :py:obj:`~.cuCtxSetCurrent`
    """
    with nogil:
        err = cyruntime.cudaSetDevice(device)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGetDevice' in found_functions}}

@cython.embedsignature(True)
def cudaGetDevice():
    """ Returns which device is currently being used.

    Returns in `*device` the current device for the calling host thread.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorDeviceUnavailable`,
    device : int
        Returns the device on which the active host thread executes the
        device code.

    See Also
    --------
    :py:obj:`~.cudaGetDeviceCount`, :py:obj:`~.cudaSetDevice`, :py:obj:`~.cudaGetDeviceProperties`, :py:obj:`~.cudaChooseDevice`, :py:obj:`~.cuCtxGetCurrent`
    """
    cdef int device = 0
    with nogil:
        err = cyruntime.cudaGetDevice(&device)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), device)
{{endif}}

{{if 'cudaSetDeviceFlags' in found_functions}}

@cython.embedsignature(True)
def cudaSetDeviceFlags(unsigned int flags):
    """ Sets flags to be used for device executions.

    Records `flags` as the flags for the current device. If the current
    device has been set and that device has already been initialized, the
    previous flags are overwritten. If the current device has not been
    initialized, it is initialized with the provided flags. If no device
    has been made current to the calling thread, a default device is
    selected and initialized with the provided flags.

    The three LSBs of the `flags` parameter can be used to control how the
    CPU thread interacts with the OS scheduler when waiting for results
    from the device.

    - :py:obj:`~.cudaDeviceScheduleAuto`: The default value if the `flags`
      parameter is zero, uses a heuristic based on the number of active
      CUDA contexts in the process `C` and the number of logical processors
      in the system `P`. If `C` > `P`, then CUDA will yield to other OS
      threads when waiting for the device, otherwise CUDA will not yield
      while waiting for results and actively spin on the processor.
      Additionally, on Tegra devices, :py:obj:`~.cudaDeviceScheduleAuto`
      uses a heuristic based on the power profile of the platform and may
      choose :py:obj:`~.cudaDeviceScheduleBlockingSync` for low-powered
      devices.

    - :py:obj:`~.cudaDeviceScheduleSpin`: Instruct CUDA to actively spin
      when waiting for results from the device. This can decrease latency
      when waiting for the device, but may lower the performance of CPU
      threads if they are performing work in parallel with the CUDA thread.

    - :py:obj:`~.cudaDeviceScheduleYield`: Instruct CUDA to yield its
      thread when waiting for results from the device. This can increase
      latency when waiting for the device, but can increase the performance
      of CPU threads performing work in parallel with the device.

    - :py:obj:`~.cudaDeviceScheduleBlockingSync`: Instruct CUDA to block
      the CPU thread on a synchronization primitive when waiting for the
      device to finish work.

    - :py:obj:`~.cudaDeviceBlockingSync`: Instruct CUDA to block the CPU
      thread on a synchronization primitive when waiting for the device to
      finish work.   :py:obj:`~.Deprecated:` This flag was deprecated as of
      CUDA 4.0 and replaced with
      :py:obj:`~.cudaDeviceScheduleBlockingSync`.

    - :py:obj:`~.cudaDeviceMapHost`: This flag enables allocating pinned
      host memory that is accessible to the device. It is implicit for the
      runtime but may be absent if a context is created using the driver
      API. If this flag is not set, :py:obj:`~.cudaHostGetDevicePointer()`
      will always return a failure code.

    - :py:obj:`~.cudaDeviceLmemResizeToMax`: Instruct CUDA to not reduce
      local memory after resizing local memory for a kernel. This can
      prevent thrashing by local memory allocations when launching many
      kernels with high local memory usage at the cost of potentially
      increased memory usage.   :py:obj:`~.Deprecated:` This flag is
      deprecated and the behavior enabled by this flag is now the default
      and cannot be disabled.

    - :py:obj:`~.cudaDeviceSyncMemops`: Ensures that synchronous memory
      operations initiated on this context will always synchronize. See
      further documentation in the section titled "API Synchronization
      behavior" to learn more about cases when synchronous memory
      operations can exhibit asynchronous behavior.

    Parameters
    ----------
    flags : unsigned int
        Parameters for device operation

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaGetDeviceFlags`, :py:obj:`~.cudaGetDeviceCount`, :py:obj:`~.cudaGetDevice`, :py:obj:`~.cudaGetDeviceProperties`, :py:obj:`~.cudaSetDevice`, :py:obj:`~.cudaSetValidDevices`, :py:obj:`~.cudaInitDevice`, :py:obj:`~.cudaChooseDevice`, :py:obj:`~.cuDevicePrimaryCtxSetFlags`
    """
    with nogil:
        err = cyruntime.cudaSetDeviceFlags(flags)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGetDeviceFlags' in found_functions}}

@cython.embedsignature(True)
def cudaGetDeviceFlags():
    """ Gets the flags for the current device.

    Returns in `flags` the flags for the current device. If there is a
    current device for the calling thread, the flags for the device are
    returned. If there is no current device, the flags for the first device
    are returned, which may be the default flags. Compare to the behavior
    of :py:obj:`~.cudaSetDeviceFlags`.

    Typically, the flags returned should match the behavior that will be
    seen if the calling thread uses a device after this call, without any
    change to the flags or current device inbetween by this or another
    thread. Note that if the device is not initialized, it is possible for
    another thread to change the flags for the current device before it is
    initialized. Additionally, when using exclusive mode, if this thread
    has not requested a specific device, it may use a device other than the
    first device, contrary to the assumption made by this function.

    If a context has been created via the driver API and is current to the
    calling thread, the flags for that context are always returned.

    Flags returned by this function may specifically include
    :py:obj:`~.cudaDeviceMapHost` even though it is not accepted by
    :py:obj:`~.cudaSetDeviceFlags` because it is implicit in runtime API
    flags. The reason for this is that the current context may have been
    created via the driver API in which case the flag is not implicit and
    may be unset.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`
    flags : unsigned int
        Pointer to store the device flags

    See Also
    --------
    :py:obj:`~.cudaGetDevice`, :py:obj:`~.cudaGetDeviceProperties`, :py:obj:`~.cudaSetDevice`, :py:obj:`~.cudaSetDeviceFlags`, :py:obj:`~.cudaInitDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuDevicePrimaryCtxGetState`
    """
    cdef unsigned int flags = 0
    with nogil:
        err = cyruntime.cudaGetDeviceFlags(&flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), flags)
{{endif}}

{{if 'cudaStreamCreate' in found_functions}}

@cython.embedsignature(True)
def cudaStreamCreate():
    """ Create an asynchronous stream.

    Creates a new asynchronous stream on the context that is current to the
    calling host thread. If no context is current to the calling host
    thread, then the primary context for a device is selected, made current
    to the calling thread, and initialized before creating a stream on it.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pStream : :py:obj:`~.cudaStream_t`
        Pointer to new stream identifier

    See Also
    --------
    :py:obj:`~.cudaStreamCreateWithPriority`, :py:obj:`~.cudaStreamCreateWithFlags`, :py:obj:`~.cudaStreamGetPriority`, :py:obj:`~.cudaStreamGetFlags`, :py:obj:`~.cudaStreamGetDevice`, :py:obj:`~.cudaStreamGetDevResource`, :py:obj:`~.cudaStreamQuery`, :py:obj:`~.cudaStreamSynchronize`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaStreamAddCallback`, :py:obj:`~.cudaSetDevice`, :py:obj:`~.cudaStreamDestroy`, :py:obj:`~.cuStreamCreate`
    """
    cdef cudaStream_t pStream = cudaStream_t()
    with nogil:
        err = cyruntime.cudaStreamCreate(<cyruntime.cudaStream_t*>pStream._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pStream)
{{endif}}

{{if 'cudaStreamCreateWithFlags' in found_functions}}

@cython.embedsignature(True)
def cudaStreamCreateWithFlags(unsigned int flags):
    """ Create an asynchronous stream.

    Creates a new asynchronous stream on the context that is current to the
    calling host thread. If no context is current to the calling host
    thread, then the primary context for a device is selected, made current
    to the calling thread, and initialized before creating a stream on it.
    The `flags` argument determines the behaviors of the stream. Valid
    values for `flags` are

    - :py:obj:`~.cudaStreamDefault`: Default stream creation flag.

    - :py:obj:`~.cudaStreamNonBlocking`: Specifies that work running in the
      created stream may run concurrently with work in stream 0 (the NULL
      stream), and that the created stream should perform no implicit
      synchronization with stream 0.

    Parameters
    ----------
    flags : unsigned int
        Parameters for stream creation

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pStream : :py:obj:`~.cudaStream_t`
        Pointer to new stream identifier

    See Also
    --------
    :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithPriority`, :py:obj:`~.cudaStreamGetFlags`, :py:obj:`~.cudaStreamGetDevice`, :py:obj:`~.cudaStreamGetDevResource`, :py:obj:`~.cudaStreamQuery`, :py:obj:`~.cudaStreamSynchronize`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaStreamAddCallback`, :py:obj:`~.cudaSetDevice`, :py:obj:`~.cudaStreamDestroy`, :py:obj:`~.cuStreamCreate`
    """
    cdef cudaStream_t pStream = cudaStream_t()
    with nogil:
        err = cyruntime.cudaStreamCreateWithFlags(<cyruntime.cudaStream_t*>pStream._pvt_ptr, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pStream)
{{endif}}

{{if 'cudaStreamCreateWithPriority' in found_functions}}

@cython.embedsignature(True)
def cudaStreamCreateWithPriority(unsigned int flags, int priority):
    """ Create an asynchronous stream with the specified priority.

    Creates a stream with the specified priority and returns a handle in
    `pStream`. The stream is created on the context that is current to the
    calling host thread. If no context is current to the calling host
    thread, then the primary context for a device is selected, made current
    to the calling thread, and initialized before creating a stream on it.
    This affects the scheduling priority of work in the stream. Priorities
    provide a hint to preferentially run work with higher priority when
    possible, but do not preempt already-running work or provide any other
    functional guarantee on execution order.

    `priority` follows a convention where lower numbers represent higher
    priorities. '0' represents default priority. The range of meaningful
    numerical priorities can be queried using
    :py:obj:`~.cudaDeviceGetStreamPriorityRange`. If the specified priority
    is outside the numerical range returned by
    :py:obj:`~.cudaDeviceGetStreamPriorityRange`, it will automatically be
    clamped to the lowest or the highest number in the range.

    Parameters
    ----------
    flags : unsigned int
        Flags for stream creation. See
        :py:obj:`~.cudaStreamCreateWithFlags` for a list of valid flags
        that can be passed
    priority : int
        Priority of the stream. Lower numbers represent higher priorities.
        See :py:obj:`~.cudaDeviceGetStreamPriorityRange` for more
        information about the meaningful stream priorities that can be
        passed.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pStream : :py:obj:`~.cudaStream_t`
        Pointer to new stream identifier

    See Also
    --------
    :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithFlags`, :py:obj:`~.cudaDeviceGetStreamPriorityRange`, :py:obj:`~.cudaStreamGetPriority`, :py:obj:`~.cudaStreamQuery`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaStreamAddCallback`, :py:obj:`~.cudaStreamSynchronize`, :py:obj:`~.cudaSetDevice`, :py:obj:`~.cudaStreamDestroy`, :py:obj:`~.cuStreamCreateWithPriority`

    Notes
    -----
    Stream priorities are supported only on GPUs with compute capability 3.5 or higher.

    In the current implementation, only compute kernels launched in priority streams are affected by the stream's priority. Stream priorities have no effect on host-to-device and device-to-host memory operations.
    """
    cdef cudaStream_t pStream = cudaStream_t()
    with nogil:
        err = cyruntime.cudaStreamCreateWithPriority(<cyruntime.cudaStream_t*>pStream._pvt_ptr, flags, priority)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pStream)
{{endif}}

{{if 'cudaStreamGetPriority' in found_functions}}

@cython.embedsignature(True)
def cudaStreamGetPriority(hStream):
    """ Query the priority of a stream.

    Query the priority of a stream. The priority is returned in in
    `priority`. Note that if the stream was created with a priority outside
    the meaningful numerical range returned by
    :py:obj:`~.cudaDeviceGetStreamPriorityRange`, this function returns the
    clamped priority. See :py:obj:`~.cudaStreamCreateWithPriority` for
    details about priority clamping.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Handle to the stream to be queried

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`
    priority : int
        Pointer to a signed integer in which the stream's priority is
        returned

    See Also
    --------
    :py:obj:`~.cudaStreamCreateWithPriority`, :py:obj:`~.cudaDeviceGetStreamPriorityRange`, :py:obj:`~.cudaStreamGetFlags`, :py:obj:`~.cudaStreamGetDevice`, :py:obj:`~.cudaStreamGetDevResource`, :py:obj:`~.cuStreamGetPriority`
    """
    cdef cyruntime.cudaStream_t cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (cudaStream_t,driver.CUstream)):
        phStream = int(hStream)
    else:
        phStream = int(cudaStream_t(hStream))
    cyhStream = <cyruntime.cudaStream_t><void_ptr>phStream
    cdef int priority = 0
    with nogil:
        err = cyruntime.cudaStreamGetPriority(cyhStream, &priority)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), priority)
{{endif}}

{{if 'cudaStreamGetFlags' in found_functions}}

@cython.embedsignature(True)
def cudaStreamGetFlags(hStream):
    """ Query the flags of a stream.

    Query the flags of a stream. The flags are returned in `flags`. See
    :py:obj:`~.cudaStreamCreateWithFlags` for a list of valid flags.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Handle to the stream to be queried

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`
    flags : unsigned int
        Pointer to an unsigned integer in which the stream's flags are
        returned

    See Also
    --------
    :py:obj:`~.cudaStreamCreateWithPriority`, :py:obj:`~.cudaStreamCreateWithFlags`, :py:obj:`~.cudaStreamGetPriority`, :py:obj:`~.cudaStreamGetDevice`, :py:obj:`~.cuStreamGetFlags`
    """
    cdef cyruntime.cudaStream_t cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (cudaStream_t,driver.CUstream)):
        phStream = int(hStream)
    else:
        phStream = int(cudaStream_t(hStream))
    cyhStream = <cyruntime.cudaStream_t><void_ptr>phStream
    cdef unsigned int flags = 0
    with nogil:
        err = cyruntime.cudaStreamGetFlags(cyhStream, &flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), flags)
{{endif}}

{{if 'cudaStreamGetId' in found_functions}}

@cython.embedsignature(True)
def cudaStreamGetId(hStream):
    """ Query the Id of a stream.

    Query the Id of a stream. The Id is returned in `streamId`. The Id is
    unique for the life of the program.

    The stream handle `hStream` can refer to any of the following:

    - a stream created via any of the CUDA runtime APIs such as
      :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithFlags`
      and :py:obj:`~.cudaStreamCreateWithPriority`, or their driver API
      equivalents such as :py:obj:`~.cuStreamCreate` or
      :py:obj:`~.cuStreamCreateWithPriority`. Passing an invalid handle
      will result in undefined behavior.

    - any of the special streams such as the NULL stream,
      :py:obj:`~.cudaStreamLegacy` and :py:obj:`~.cudaStreamPerThread`
      respectively. The driver API equivalents of these are also accepted
      which are NULL, :py:obj:`~.CU_STREAM_LEGACY` and
      :py:obj:`~.CU_STREAM_PER_THREAD`.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Handle to the stream to be queried

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`
    streamId : unsigned long long
        Pointer to an unsigned long long in which the stream Id is returned

    See Also
    --------
    :py:obj:`~.cudaStreamCreateWithPriority`, :py:obj:`~.cudaStreamCreateWithFlags`, :py:obj:`~.cudaStreamGetPriority`, :py:obj:`~.cudaStreamGetFlags`, :py:obj:`~.cuStreamGetId`
    """
    cdef cyruntime.cudaStream_t cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (cudaStream_t,driver.CUstream)):
        phStream = int(hStream)
    else:
        phStream = int(cudaStream_t(hStream))
    cyhStream = <cyruntime.cudaStream_t><void_ptr>phStream
    cdef unsigned long long streamId = 0
    with nogil:
        err = cyruntime.cudaStreamGetId(cyhStream, &streamId)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), streamId)
{{endif}}

{{if 'cudaStreamGetDevice' in found_functions}}

@cython.embedsignature(True)
def cudaStreamGetDevice(hStream):
    """ Query the device of a stream.

    Returns in `*device` the device of the stream.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Handle to the stream to be queried

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorDeviceUnavailable`,
    device : int
        Returns the device to which the stream belongs

    See Also
    --------
    :py:obj:`~.cudaSetDevice`, :py:obj:`~.cudaGetDevice`, :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamGetPriority`, :py:obj:`~.cudaStreamGetFlags`, :py:obj:`~.cuStreamGetId`
    """
    cdef cyruntime.cudaStream_t cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (cudaStream_t,driver.CUstream)):
        phStream = int(hStream)
    else:
        phStream = int(cudaStream_t(hStream))
    cyhStream = <cyruntime.cudaStream_t><void_ptr>phStream
    cdef int device = 0
    with nogil:
        err = cyruntime.cudaStreamGetDevice(cyhStream, &device)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), device)
{{endif}}

{{if 'cudaCtxResetPersistingL2Cache' in found_functions}}

@cython.embedsignature(True)
def cudaCtxResetPersistingL2Cache():
    """ Resets all persisting lines in cache to normal status.

    Resets all persisting lines in cache to normal status. Takes effect on
    function return.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`,

    See Also
    --------
    :py:obj:`~.cudaAccessPolicyWindow`
    """
    with nogil:
        err = cyruntime.cudaCtxResetPersistingL2Cache()
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaStreamCopyAttributes' in found_functions}}

@cython.embedsignature(True)
def cudaStreamCopyAttributes(dst, src):
    """ Copies attributes from source stream to destination stream.

    Copies attributes from source stream `src` to destination stream `dst`.
    Both streams must have the same context.

    Parameters
    ----------
    dst : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Destination stream
    src : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Source stream For attributes see :py:obj:`~.cudaStreamAttrID`

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorNotSupported`

    See Also
    --------
    :py:obj:`~.cudaAccessPolicyWindow`
    """
    cdef cyruntime.cudaStream_t cysrc
    if src is None:
        psrc = 0
    elif isinstance(src, (cudaStream_t,driver.CUstream)):
        psrc = int(src)
    else:
        psrc = int(cudaStream_t(src))
    cysrc = <cyruntime.cudaStream_t><void_ptr>psrc
    cdef cyruntime.cudaStream_t cydst
    if dst is None:
        pdst = 0
    elif isinstance(dst, (cudaStream_t,driver.CUstream)):
        pdst = int(dst)
    else:
        pdst = int(cudaStream_t(dst))
    cydst = <cyruntime.cudaStream_t><void_ptr>pdst
    with nogil:
        err = cyruntime.cudaStreamCopyAttributes(cydst, cysrc)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaStreamGetAttribute' in found_functions}}

@cython.embedsignature(True)
def cudaStreamGetAttribute(hStream, attr not None : cudaStreamAttrID):
    """ Queries stream attribute.

    Queries attribute `attr` from `hStream` and stores it in corresponding
    member of `value_out`.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`

    attr : :py:obj:`~.cudaStreamAttrID`


    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`
    value_out : :py:obj:`~.cudaStreamAttrValue`


    See Also
    --------
    :py:obj:`~.cudaAccessPolicyWindow`
    """
    cdef cyruntime.cudaStream_t cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (cudaStream_t,driver.CUstream)):
        phStream = int(hStream)
    else:
        phStream = int(cudaStream_t(hStream))
    cyhStream = <cyruntime.cudaStream_t><void_ptr>phStream
    cdef cyruntime.cudaStreamAttrID cyattr = int(attr)
    cdef cudaStreamAttrValue value_out = cudaStreamAttrValue()
    with nogil:
        err = cyruntime.cudaStreamGetAttribute(cyhStream, cyattr, <cyruntime.cudaStreamAttrValue*>value_out._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), value_out)
{{endif}}

{{if 'cudaStreamSetAttribute' in found_functions}}

@cython.embedsignature(True)
def cudaStreamSetAttribute(hStream, attr not None : cudaStreamAttrID, value : Optional[cudaStreamAttrValue]):
    """ Sets stream attribute.

    Sets attribute `attr` on `hStream` from corresponding attribute of
    `value`. The updated attribute will be applied to subsequent work
    submitted to the stream. It will not affect previously submitted work.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`

    attr : :py:obj:`~.cudaStreamAttrID`

    value : :py:obj:`~.cudaStreamAttrValue`


    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`

    See Also
    --------
    :py:obj:`~.cudaAccessPolicyWindow`
    """
    cdef cyruntime.cudaStream_t cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (cudaStream_t,driver.CUstream)):
        phStream = int(hStream)
    else:
        phStream = int(cudaStream_t(hStream))
    cyhStream = <cyruntime.cudaStream_t><void_ptr>phStream
    cdef cyruntime.cudaStreamAttrID cyattr = int(attr)
    cdef cyruntime.cudaStreamAttrValue* cyvalue_ptr = value._pvt_ptr if value is not None else NULL
    with nogil:
        err = cyruntime.cudaStreamSetAttribute(cyhStream, cyattr, cyvalue_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaStreamDestroy' in found_functions}}

@cython.embedsignature(True)
def cudaStreamDestroy(stream):
    """ Destroys and cleans up an asynchronous stream.

    Destroys and cleans up the asynchronous stream specified by `stream`.

    In case the device is still doing work in the stream `stream` when
    :py:obj:`~.cudaStreamDestroy()` is called, the function will return
    immediately and the resources associated with `stream` will be released
    automatically once the device has completed all work in `stream`.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`

    See Also
    --------
    :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithFlags`, :py:obj:`~.cudaStreamQuery`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaStreamSynchronize`, :py:obj:`~.cudaStreamAddCallback`, :py:obj:`~.cuStreamDestroy`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    with nogil:
        err = cyruntime.cudaStreamDestroy(cystream)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaStreamWaitEvent' in found_functions}}

@cython.embedsignature(True)
def cudaStreamWaitEvent(stream, event, unsigned int flags):
    """ Make a compute stream wait on an event.

    Makes all future work submitted to `stream` wait for all work captured
    in `event`. See :py:obj:`~.cudaEventRecord()` for details on what is
    captured by an event. The synchronization will be performed efficiently
    on the device when applicable. `event` may be from a different device
    than `stream`.

    flags include:

    - :py:obj:`~.cudaEventWaitDefault`: Default event creation flag.

    - :py:obj:`~.cudaEventWaitExternal`: Event is captured in the graph as
      an external event node when performing stream capture.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to wait
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to wait on
    flags : unsigned int
        Parameters for the operation(See above)

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`

    See Also
    --------
    :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithFlags`, :py:obj:`~.cudaStreamQuery`, :py:obj:`~.cudaStreamSynchronize`, :py:obj:`~.cudaStreamAddCallback`, :py:obj:`~.cudaStreamDestroy`, :py:obj:`~.cuStreamWaitEvent`
    """
    cdef cyruntime.cudaEvent_t cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (cudaEvent_t,driver.CUevent)):
        pevent = int(event)
    else:
        pevent = int(cudaEvent_t(event))
    cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    with nogil:
        err = cyruntime.cudaStreamWaitEvent(cystream, cyevent, flags)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaStreamAddCallback' in found_functions}}

ctypedef struct cudaStreamCallbackData_st:
    cyruntime.cudaStreamCallback_t callback
    void *userData

ctypedef cudaStreamCallbackData_st cudaStreamCallbackData

@cython.show_performance_hints(False)
cdef void cudaStreamRtCallbackWrapper(cyruntime.cudaStream_t stream, cyruntime.cudaError_t status, void *data) nogil:
    cdef cudaStreamCallbackData *cbData = <cudaStreamCallbackData *>data
    with gil:
        cbData.callback(stream, status, cbData.userData)
    free(cbData)

@cython.embedsignature(True)
def cudaStreamAddCallback(stream, callback, userData, unsigned int flags):
    """ Add a callback to a compute stream.

    Adds a callback to be called on the host after all currently enqueued
    items in the stream have completed. For each cudaStreamAddCallback
    call, a callback will be executed exactly once. The callback will block
    later work in the stream until it is finished.

    The callback may be passed :py:obj:`~.cudaSuccess` or an error code. In
    the event of a device error, all subsequently executed callbacks will
    receive an appropriate :py:obj:`~.cudaError_t`.

    Callbacks must not make any CUDA API calls. Attempting to use CUDA APIs
    may result in :py:obj:`~.cudaErrorNotPermitted`. Callbacks must not
    perform any synchronization that may depend on outstanding device work
    or other callbacks that are not mandated to run earlier. Callbacks
    without a mandated order (in independent streams) execute in undefined
    order and may be serialized.

    For the purposes of Unified Memory, callback execution makes a number
    of guarantees:

    - The callback stream is considered idle for the duration of the
      callback. Thus, for example, a callback may always use memory
      attached to the callback stream.

    - The start of execution of a callback has the same effect as
      synchronizing an event recorded in the same stream immediately prior
      to the callback. It thus synchronizes streams which have been
      "joined" prior to the callback.

    - Adding device work to any stream does not have the effect of making
      the stream active until all preceding callbacks have executed. Thus,
      for example, a callback might use global attached memory even if work
      has been added to another stream, if it has been properly ordered
      with an event.

    - Completion of a callback does not cause a stream to become active
      except as described above. The callback stream will remain idle if no
      device work follows the callback, and will remain idle across
      consecutive callbacks without device work in between. Thus, for
      example, stream synchronization can be done by signaling from a
      callback at the end of the stream.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to add callback to
    callback : :py:obj:`~.cudaStreamCallback_t`
        The function to call once preceding stream operations are complete
    userData : Any
        User specified data to be passed to the callback function
    flags : unsigned int
        Reserved for future use, must be 0

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotSupported`

    See Also
    --------
    :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithFlags`, :py:obj:`~.cudaStreamQuery`, :py:obj:`~.cudaStreamSynchronize`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaStreamDestroy`, :py:obj:`~.cudaMallocManaged`, :py:obj:`~.cudaStreamAttachMemAsync`, :py:obj:`~.cudaLaunchHostFunc`, :py:obj:`~.cuStreamAddCallback`

    Notes
    -----
    This function is slated for eventual deprecation and removal. If you do not require the callback to execute in case of a device error, consider using :py:obj:`~.cudaLaunchHostFunc`. Additionally, this function is not supported with :py:obj:`~.cudaStreamBeginCapture` and :py:obj:`~.cudaStreamEndCapture`, unlike :py:obj:`~.cudaLaunchHostFunc`.
    """
    cdef cyruntime.cudaStreamCallback_t cycallback
    if callback is None:
        pcallback = 0
    elif isinstance(callback, (cudaStreamCallback_t,)):
        pcallback = int(callback)
    else:
        pcallback = int(cudaStreamCallback_t(callback))
    cycallback = <cyruntime.cudaStreamCallback_t><void_ptr>pcallback
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef _HelperInputVoidPtrStruct cyuserDataHelper
    cdef void* cyuserData = _helper_input_void_ptr(userData, &cyuserDataHelper)

    cdef cudaStreamCallbackData *cbData = NULL
    cbData = <cudaStreamCallbackData *>malloc(sizeof(cbData[0]))
    if cbData == NULL:
        return (cudaError_t.cudaErrorMemoryAllocation,)
    cbData.callback = cycallback
    cbData.userData = cyuserData

    with nogil:
        err = cyruntime.cudaStreamAddCallback(cystream, <cyruntime.cudaStreamCallback_t>cudaStreamRtCallbackWrapper, <void *>cbData, flags)
    if err != cyruntime.cudaSuccess:
        free(cbData)
    _helper_input_void_ptr_free(&cyuserDataHelper)

    return (cudaError_t(err),)
{{endif}}

{{if 'cudaStreamSynchronize' in found_functions}}

@cython.embedsignature(True)
def cudaStreamSynchronize(stream):
    """ Waits for stream tasks to complete.

    Blocks until `stream` has completed all operations. If the
    :py:obj:`~.cudaDeviceScheduleBlockingSync` flag was set for this
    device, the host thread will block until the stream is finished with
    all of its tasks.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidResourceHandle`

    See Also
    --------
    :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithFlags`, :py:obj:`~.cudaStreamQuery`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaStreamAddCallback`, :py:obj:`~.cudaStreamDestroy`, :py:obj:`~.cuStreamSynchronize`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    with nogil:
        err = cyruntime.cudaStreamSynchronize(cystream)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaStreamQuery' in found_functions}}

@cython.embedsignature(True)
def cudaStreamQuery(stream):
    """ Queries an asynchronous stream for completion status.

    Returns :py:obj:`~.cudaSuccess` if all operations in `stream` have
    completed, or :py:obj:`~.cudaErrorNotReady` if not.

    For the purposes of Unified Memory, a return value of
    :py:obj:`~.cudaSuccess` is equivalent to having called
    :py:obj:`~.cudaStreamSynchronize()`.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorNotReady`, :py:obj:`~.cudaErrorInvalidResourceHandle`

    See Also
    --------
    :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithFlags`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaStreamSynchronize`, :py:obj:`~.cudaStreamAddCallback`, :py:obj:`~.cudaStreamDestroy`, :py:obj:`~.cuStreamQuery`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    with nogil:
        err = cyruntime.cudaStreamQuery(cystream)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaStreamAttachMemAsync' in found_functions}}

@cython.embedsignature(True)
def cudaStreamAttachMemAsync(stream, devPtr, size_t length, unsigned int flags):
    """ Attach memory to a stream asynchronously.

    Enqueues an operation in `stream` to specify stream association of
    `length` bytes of memory starting from `devPtr`. This function is a
    stream-ordered operation, meaning that it is dependent on, and will
    only take effect when, previous work in stream has completed. Any
    previous association is automatically replaced.

    `devPtr` must point to an one of the following types of memories:

    - managed memory declared using the managed keyword or allocated with
      :py:obj:`~.cudaMallocManaged`.

    - a valid host-accessible region of system-allocated pageable memory.
      This type of memory may only be specified if the device associated
      with the stream reports a non-zero value for the device attribute
      :py:obj:`~.cudaDevAttrPageableMemoryAccess`.

    For managed allocations, `length` must be either zero or the entire
    allocation's size. Both indicate that the entire allocation's stream
    association is being changed. Currently, it is not possible to change
    stream association for a portion of a managed allocation.

    For pageable allocations, `length` must be non-zero.

    The stream association is specified using `flags` which must be one of
    :py:obj:`~.cudaMemAttachGlobal`, :py:obj:`~.cudaMemAttachHost` or
    :py:obj:`~.cudaMemAttachSingle`. The default value for `flags` is
    :py:obj:`~.cudaMemAttachSingle` If the :py:obj:`~.cudaMemAttachGlobal`
    flag is specified, the memory can be accessed by any stream on any
    device. If the :py:obj:`~.cudaMemAttachHost` flag is specified, the
    program makes a guarantee that it won't access the memory on the device
    from any stream on a device that has a zero value for the device
    attribute :py:obj:`~.cudaDevAttrConcurrentManagedAccess`. If the
    :py:obj:`~.cudaMemAttachSingle` flag is specified and `stream` is
    associated with a device that has a zero value for the device attribute
    :py:obj:`~.cudaDevAttrConcurrentManagedAccess`, the program makes a
    guarantee that it will only access the memory on the device from
    `stream`. It is illegal to attach singly to the NULL stream, because
    the NULL stream is a virtual global stream and not a specific stream.
    An error will be returned in this case.

    When memory is associated with a single stream, the Unified Memory
    system will allow CPU access to this memory region so long as all
    operations in `stream` have completed, regardless of whether other
    streams are active. In effect, this constrains exclusive ownership of
    the managed memory region by an active GPU to per-stream activity
    instead of whole-GPU activity.

    Accessing memory on the device from streams that are not associated
    with it will produce undefined results. No error checking is performed
    by the Unified Memory system to ensure that kernels launched into other
    streams do not access this region.

    It is a program's responsibility to order calls to
    :py:obj:`~.cudaStreamAttachMemAsync` via events, synchronization or
    other means to ensure legal access to memory at all times. Data
    visibility and coherency will be changed appropriately for all kernels
    which follow a stream-association change.

    If `stream` is destroyed while data is associated with it, the
    association is removed and the association reverts to the default
    visibility of the allocation as specified at
    :py:obj:`~.cudaMallocManaged`. For managed variables, the default
    association is always :py:obj:`~.cudaMemAttachGlobal`. Note that
    destroying a stream is an asynchronous operation, and as a result, the
    change to default association won't happen until all work in the stream
    has completed.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream in which to enqueue the attach operation
    devPtr : Any
        Pointer to memory (must be a pointer to managed memory or to a
        valid host-accessible region of system-allocated memory)
    length : size_t
        Length of memory (defaults to zero)
    flags : unsigned int
        Must be one of :py:obj:`~.cudaMemAttachGlobal`,
        :py:obj:`~.cudaMemAttachHost` or :py:obj:`~.cudaMemAttachSingle`
        (defaults to :py:obj:`~.cudaMemAttachSingle`)

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorNotReady`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`

    See Also
    --------
    :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithFlags`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaStreamSynchronize`, :py:obj:`~.cudaStreamAddCallback`, :py:obj:`~.cudaStreamDestroy`, :py:obj:`~.cudaMallocManaged`, :py:obj:`~.cuStreamAttachMemAsync`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef _HelperInputVoidPtrStruct cydevPtrHelper
    cdef void* cydevPtr = _helper_input_void_ptr(devPtr, &cydevPtrHelper)
    with nogil:
        err = cyruntime.cudaStreamAttachMemAsync(cystream, cydevPtr, length, flags)
    _helper_input_void_ptr_free(&cydevPtrHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaStreamBeginCapture' in found_functions}}

@cython.embedsignature(True)
def cudaStreamBeginCapture(stream, mode not None : cudaStreamCaptureMode):
    """ Begins graph capture on a stream.

    Begin graph capture on `stream`. When a stream is in capture mode, all
    operations pushed into the stream will not be executed, but will
    instead be captured into a graph, which will be returned via
    :py:obj:`~.cudaStreamEndCapture`. Capture may not be initiated if
    `stream` is :py:obj:`~.cudaStreamLegacy`. Capture must be ended on the
    same stream in which it was initiated, and it may only be initiated if
    the stream is not already in capture mode. The capture mode may be
    queried via :py:obj:`~.cudaStreamIsCapturing`. A unique id representing
    the capture sequence may be queried via
    :py:obj:`~.cudaStreamGetCaptureInfo`.

    If `mode` is not :py:obj:`~.cudaStreamCaptureModeRelaxed`,
    :py:obj:`~.cudaStreamEndCapture` must be called on this stream from the
    same thread.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream in which to initiate capture
    mode : :py:obj:`~.cudaStreamCaptureMode`
        Controls the interaction of this capture sequence with other API
        calls that are potentially unsafe. For more details see
        :py:obj:`~.cudaThreadExchangeStreamCaptureMode`.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamIsCapturing`, :py:obj:`~.cudaStreamEndCapture`, :py:obj:`~.cudaThreadExchangeStreamCaptureMode`

    Notes
    -----
    Kernels captured using this API must not use texture and surface references. Reading or writing through any texture or surface reference is undefined behavior. This restriction does not apply to texture and surface objects.
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaStreamCaptureMode cymode = int(mode)
    with nogil:
        err = cyruntime.cudaStreamBeginCapture(cystream, cymode)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaStreamBeginCaptureToGraph' in found_functions}}

@cython.embedsignature(True)
def cudaStreamBeginCaptureToGraph(stream, graph, dependencies : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], dependencyData : Optional[tuple[cudaGraphEdgeData] | list[cudaGraphEdgeData]], size_t numDependencies, mode not None : cudaStreamCaptureMode):
    """ Begins graph capture on a stream to an existing graph.

    Begin graph capture on `stream`. When a stream is in capture mode, all
    operations pushed into the stream will not be executed, but will
    instead be captured into `graph`, which will be returned via
    :py:obj:`~.cudaStreamEndCapture`.

    Capture may not be initiated if `stream` is
    :py:obj:`~.cudaStreamLegacy`. Capture must be ended on the same stream
    in which it was initiated, and it may only be initiated if the stream
    is not already in capture mode. The capture mode may be queried via
    :py:obj:`~.cudaStreamIsCapturing`. A unique id representing the capture
    sequence may be queried via :py:obj:`~.cudaStreamGetCaptureInfo`.

    If `mode` is not :py:obj:`~.cudaStreamCaptureModeRelaxed`,
    :py:obj:`~.cudaStreamEndCapture` must be called on this stream from the
    same thread.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream in which to initiate capture.
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to capture into.
    dependencies : list[:py:obj:`~.cudaGraphNode_t`]
        Dependencies of the first node captured in the stream. Can be NULL
        if numDependencies is 0.
    dependencyData : list[:py:obj:`~.cudaGraphEdgeData`]
        Optional array of data associated with each dependency.
    numDependencies : size_t
        Number of dependencies.
    mode : :py:obj:`~.cudaStreamCaptureMode`
        Controls the interaction of this capture sequence with other API
        calls that are potentially unsafe. For more details see
        :py:obj:`~.cudaThreadExchangeStreamCaptureMode`.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamIsCapturing`, :py:obj:`~.cudaStreamEndCapture`, :py:obj:`~.cudaThreadExchangeStreamCaptureMode`

    Notes
    -----
    Kernels captured using this API must not use texture and surface references. Reading or writing through any texture or surface reference is undefined behavior. This restriction does not apply to texture and surface objects.
    """
    dependencyData = [] if dependencyData is None else dependencyData
    if not all(isinstance(_x, (cudaGraphEdgeData,)) for _x in dependencyData):
        raise TypeError("Argument 'dependencyData' is not instance of type (expected tuple[cyruntime.cudaGraphEdgeData,] or list[cyruntime.cudaGraphEdgeData,]")
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaGraphNode_t* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cyruntime.cudaGraphNode_t*> calloc(len(dependencies), sizeof(cyruntime.cudaGraphNode_t))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>dependencies[0])._pvt_ptr
    cdef cyruntime.cudaGraphEdgeData* cydependencyData = NULL
    if len(dependencyData) > 1:
        cydependencyData = <cyruntime.cudaGraphEdgeData*> calloc(len(dependencyData), sizeof(cyruntime.cudaGraphEdgeData))
        if cydependencyData is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencyData)) + 'x' + str(sizeof(cyruntime.cudaGraphEdgeData)))
        for idx in range(len(dependencyData)):
            string.memcpy(&cydependencyData[idx], (<cudaGraphEdgeData>dependencyData[idx])._pvt_ptr, sizeof(cyruntime.cudaGraphEdgeData))
    elif len(dependencyData) == 1:
        cydependencyData = (<cudaGraphEdgeData>dependencyData[0])._pvt_ptr
    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef cyruntime.cudaStreamCaptureMode cymode = int(mode)
    with nogil:
        err = cyruntime.cudaStreamBeginCaptureToGraph(cystream, cygraph, cydependencies, cydependencyData, numDependencies, cymode)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if len(dependencyData) > 1 and cydependencyData is not NULL:
        free(cydependencyData)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaThreadExchangeStreamCaptureMode' in found_functions}}

@cython.embedsignature(True)
def cudaThreadExchangeStreamCaptureMode(mode not None : cudaStreamCaptureMode):
    """ Swaps the stream capture interaction mode for a thread.

    Sets the calling thread's stream capture interaction mode to the value
    contained in `*mode`, and overwrites `*mode` with the previous mode for
    the thread. To facilitate deterministic behavior across function or
    module boundaries, callers are encouraged to use this API in a push-pop
    fashion:

    **View CUDA Toolkit Documentation for a C++ code example**

    During stream capture (see :py:obj:`~.cudaStreamBeginCapture`), some
    actions, such as a call to :py:obj:`~.cudaMalloc`, may be unsafe. In
    the case of :py:obj:`~.cudaMalloc`, the operation is not enqueued
    asynchronously to a stream, and is not observed by stream capture.
    Therefore, if the sequence of operations captured via
    :py:obj:`~.cudaStreamBeginCapture` depended on the allocation being
    replayed whenever the graph is launched, the captured graph would be
    invalid.

    Therefore, stream capture places restrictions on API calls that can be
    made within or concurrently to a
    :py:obj:`~.cudaStreamBeginCapture`-:py:obj:`~.cudaStreamEndCapture`
    sequence. This behavior can be controlled via this API and flags to
    :py:obj:`~.cudaStreamBeginCapture`.

    A thread's mode is one of the following:

    - `cudaStreamCaptureModeGlobal:` This is the default mode. If the local
      thread has an ongoing capture sequence that was not initiated with
      `cudaStreamCaptureModeRelaxed` at `cuStreamBeginCapture`, or if any
      other thread has a concurrent capture sequence initiated with
      `cudaStreamCaptureModeGlobal`, this thread is prohibited from
      potentially unsafe API calls.

    - `cudaStreamCaptureModeThreadLocal:` If the local thread has an
      ongoing capture sequence not initiated with
      `cudaStreamCaptureModeRelaxed`, it is prohibited from potentially
      unsafe API calls. Concurrent capture sequences in other threads are
      ignored.

    - `cudaStreamCaptureModeRelaxed:` The local thread is not prohibited
      from potentially unsafe API calls. Note that the thread is still
      prohibited from API calls which necessarily conflict with stream
      capture, for example, attempting :py:obj:`~.cudaEventQuery` on an
      event that was last recorded inside a capture sequence.

    Parameters
    ----------
    mode : :py:obj:`~.cudaStreamCaptureMode`
        Pointer to mode value to swap with the current mode

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    mode : :py:obj:`~.cudaStreamCaptureMode`
        Pointer to mode value to swap with the current mode

    See Also
    --------
    :py:obj:`~.cudaStreamBeginCapture`
    """
    cdef cyruntime.cudaStreamCaptureMode cymode = int(mode)
    with nogil:
        err = cyruntime.cudaThreadExchangeStreamCaptureMode(&cymode)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), cudaStreamCaptureMode(cymode))
{{endif}}

{{if 'cudaStreamEndCapture' in found_functions}}

@cython.embedsignature(True)
def cudaStreamEndCapture(stream):
    """ Ends capture on a stream, returning the captured graph.

    End capture on `stream`, returning the captured graph via `pGraph`.
    Capture must have been initiated on `stream` via a call to
    :py:obj:`~.cudaStreamBeginCapture`. If capture was invalidated, due to
    a violation of the rules of stream capture, then a NULL graph will be
    returned.

    If the `mode` argument to :py:obj:`~.cudaStreamBeginCapture` was not
    :py:obj:`~.cudaStreamCaptureModeRelaxed`, this call must be from the
    same thread as :py:obj:`~.cudaStreamBeginCapture`.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to query

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorStreamCaptureWrongThread`
    pGraph : :py:obj:`~.cudaGraph_t`
        The captured graph

    See Also
    --------
    :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamBeginCapture`, :py:obj:`~.cudaStreamIsCapturing`, :py:obj:`~.cudaGraphDestroy`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cudaGraph_t pGraph = cudaGraph_t()
    with nogil:
        err = cyruntime.cudaStreamEndCapture(cystream, <cyruntime.cudaGraph_t*>pGraph._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraph)
{{endif}}

{{if 'cudaStreamIsCapturing' in found_functions}}

@cython.embedsignature(True)
def cudaStreamIsCapturing(stream):
    """ Returns a stream's capture status.

    Return the capture status of `stream` via `pCaptureStatus`. After a
    successful call, `*pCaptureStatus` will contain one of the following:

    - :py:obj:`~.cudaStreamCaptureStatusNone`: The stream is not capturing.

    - :py:obj:`~.cudaStreamCaptureStatusActive`: The stream is capturing.

    - :py:obj:`~.cudaStreamCaptureStatusInvalidated`: The stream was
      capturing but an error has invalidated the capture sequence. The
      capture sequence must be terminated with
      :py:obj:`~.cudaStreamEndCapture` on the stream where it was initiated
      in order to continue using `stream`.

    Note that, if this is called on :py:obj:`~.cudaStreamLegacy` (the "null
    stream") while a blocking stream on the same device is capturing, it
    will return :py:obj:`~.cudaErrorStreamCaptureImplicit` and
    `*pCaptureStatus` is unspecified after the call. The blocking stream
    capture is not invalidated.

    When a blocking stream is capturing, the legacy stream is in an
    unusable state until the blocking stream capture is terminated. The
    legacy stream is not supported for stream capture, but attempted use
    would have an implicit dependency on the capturing stream(s).

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to query

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorStreamCaptureImplicit`
    pCaptureStatus : :py:obj:`~.cudaStreamCaptureStatus`
        Returns the stream's capture status

    See Also
    --------
    :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamBeginCapture`, :py:obj:`~.cudaStreamEndCapture`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaStreamCaptureStatus pCaptureStatus
    with nogil:
        err = cyruntime.cudaStreamIsCapturing(cystream, &pCaptureStatus)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), cudaStreamCaptureStatus(pCaptureStatus))
{{endif}}

{{if 'cudaStreamGetCaptureInfo' in found_functions}}

@cython.embedsignature(True)
def cudaStreamGetCaptureInfo(stream):
    """ Query a stream's capture state.

    Query stream state related to stream capture.

    If called on :py:obj:`~.cudaStreamLegacy` (the "null stream") while a
    stream not created with :py:obj:`~.cudaStreamNonBlocking` is capturing,
    returns :py:obj:`~.cudaErrorStreamCaptureImplicit`.

    Valid data (other than capture status) is returned only if both of the
    following are true:

    - the call returns cudaSuccess

    - the returned capture status is
      :py:obj:`~.cudaStreamCaptureStatusActive`

    If `edgeData_out` is non-NULL then `dependencies_out` must be as well.
    If `dependencies_out` is non-NULL and `edgeData_out` is NULL, but there
    is non-zero edge data for one or more of the current stream
    dependencies, the call will return :py:obj:`~.cudaErrorLossyQuery`.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to query

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorStreamCaptureImplicit`, :py:obj:`~.cudaErrorLossyQuery`
    captureStatus_out : :py:obj:`~.cudaStreamCaptureStatus`
        Location to return the capture status of the stream; required
    id_out : unsigned long long
        Optional location to return an id for the capture sequence, which
        is unique over the lifetime of the process
    graph_out : :py:obj:`~.cudaGraph_t`
        Optional location to return the graph being captured into. All
        operations other than destroy and node removal are permitted on the
        graph while the capture sequence is in progress. This API does not
        transfer ownership of the graph, which is transferred or destroyed
        at :py:obj:`~.cudaStreamEndCapture`. Note that the graph handle may
        be invalidated before end of capture for certain errors. Nodes that
        are or become unreachable from the original stream at
        :py:obj:`~.cudaStreamEndCapture` due to direct actions on the graph
        do not trigger :py:obj:`~.cudaErrorStreamCaptureUnjoined`.
    dependencies_out : list[:py:obj:`~.cudaGraphNode_t`]
        Optional location to store a pointer to an array of nodes. The next
        node to be captured in the stream will depend on this set of nodes,
        absent operations such as event wait which modify this set. The
        array pointer is valid until the next API call which operates on
        the stream or until the capture is terminated. The node handles may
        be copied out and are valid until they or the graph is destroyed.
        The driver-owned array may also be passed directly to APIs that
        operate on the graph (not the stream) without copying.
    edgeData_out : list[:py:obj:`~.cudaGraphEdgeData`]
        Optional location to store a pointer to an array of graph edge
        data. This array parallels `dependencies_out`; the next node to be
        added has an edge to `dependencies_out`[i] with annotation
        `edgeData_out`[i] for each `i`. The array pointer is valid until
        the next API call which operates on the stream or until the capture
        is terminated.
    numDependencies_out : int
        Optional location to store the size of the array returned in
        dependencies_out.

    See Also
    --------
    :py:obj:`~.cudaStreamBeginCapture`, :py:obj:`~.cudaStreamIsCapturing`, :py:obj:`~.cudaStreamUpdateCaptureDependencies`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaStreamCaptureStatus captureStatus_out
    cdef unsigned long long id_out = 0
    cdef cudaGraph_t graph_out = cudaGraph_t()
    cdef const cyruntime.cudaGraphNode_t* cydependencies_out = NULL
    pydependencies_out = []
    cdef const cyruntime.cudaGraphEdgeData* cyedgeData_out = NULL
    pyedgeData_out = []
    cdef size_t numDependencies_out = 0
    with nogil:
        err = cyruntime.cudaStreamGetCaptureInfo(cystream, &captureStatus_out, &id_out, <cyruntime.cudaGraph_t*>graph_out._pvt_ptr, &cydependencies_out, &cyedgeData_out, &numDependencies_out)
    if cudaError_t(err) == cudaError_t(0):
        pydependencies_out = [cudaGraphNode_t(init_value=<void_ptr>cydependencies_out[idx]) for idx in range(numDependencies_out)]
    if cudaError_t(err) == cudaError_t(0):
        pyedgeData_out = [cudaGraphEdgeData(_ptr=<void_ptr>&cyedgeData_out[idx]) for idx in range(numDependencies_out)]
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None, None, None, None, None)
    return (cudaError_t(err), cudaStreamCaptureStatus(captureStatus_out), id_out, graph_out, pydependencies_out, pyedgeData_out, numDependencies_out)
{{endif}}

{{if 'cudaStreamUpdateCaptureDependencies' in found_functions}}

@cython.embedsignature(True)
def cudaStreamUpdateCaptureDependencies(stream, dependencies : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], dependencyData : Optional[tuple[cudaGraphEdgeData] | list[cudaGraphEdgeData]], size_t numDependencies, unsigned int flags):
    """ Update the set of dependencies in a capturing stream.

    Modifies the dependency set of a capturing stream. The dependency set
    is the set of nodes that the next captured node in the stream will
    depend on.

    Valid flags are :py:obj:`~.cudaStreamAddCaptureDependencies` and
    :py:obj:`~.cudaStreamSetCaptureDependencies`. These control whether the
    set passed to the API is added to the existing set or replaces it. A
    flags value of 0 defaults to
    :py:obj:`~.cudaStreamAddCaptureDependencies`.

    Nodes that are removed from the dependency set via this API do not
    result in :py:obj:`~.cudaErrorStreamCaptureUnjoined` if they are
    unreachable from the stream at :py:obj:`~.cudaStreamEndCapture`.

    Returns :py:obj:`~.cudaErrorIllegalState` if the stream is not
    capturing.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to update
    dependencies : list[:py:obj:`~.cudaGraphNode_t`]
        The set of dependencies to add
    dependencyData : list[:py:obj:`~.cudaGraphEdgeData`]
        Optional array of data associated with each dependency.
    numDependencies : size_t
        The size of the dependencies array
    flags : unsigned int
        See above

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorIllegalState`

    See Also
    --------
    :py:obj:`~.cudaStreamBeginCapture`, :py:obj:`~.cudaStreamGetCaptureInfo`,
    """
    dependencyData = [] if dependencyData is None else dependencyData
    if not all(isinstance(_x, (cudaGraphEdgeData,)) for _x in dependencyData):
        raise TypeError("Argument 'dependencyData' is not instance of type (expected tuple[cyruntime.cudaGraphEdgeData,] or list[cyruntime.cudaGraphEdgeData,]")
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaGraphNode_t* cydependencies = NULL
    if len(dependencies) > 1:
        cydependencies = <cyruntime.cudaGraphNode_t*> calloc(len(dependencies), sizeof(cyruntime.cudaGraphNode_t))
        if cydependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(dependencies)):
                cydependencies[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>dependencies[idx])._pvt_ptr[0]
    elif len(dependencies) == 1:
        cydependencies = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>dependencies[0])._pvt_ptr
    cdef cyruntime.cudaGraphEdgeData* cydependencyData = NULL
    if len(dependencyData) > 1:
        cydependencyData = <cyruntime.cudaGraphEdgeData*> calloc(len(dependencyData), sizeof(cyruntime.cudaGraphEdgeData))
        if cydependencyData is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencyData)) + 'x' + str(sizeof(cyruntime.cudaGraphEdgeData)))
        for idx in range(len(dependencyData)):
            string.memcpy(&cydependencyData[idx], (<cudaGraphEdgeData>dependencyData[idx])._pvt_ptr, sizeof(cyruntime.cudaGraphEdgeData))
    elif len(dependencyData) == 1:
        cydependencyData = (<cudaGraphEdgeData>dependencyData[0])._pvt_ptr
    with nogil:
        err = cyruntime.cudaStreamUpdateCaptureDependencies(cystream, cydependencies, cydependencyData, numDependencies, flags)
    if len(dependencies) > 1 and cydependencies is not NULL:
        free(cydependencies)
    if len(dependencyData) > 1 and cydependencyData is not NULL:
        free(cydependencyData)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaEventCreate' in found_functions}}

@cython.embedsignature(True)
def cudaEventCreate():
    """ Creates an event object.

    Creates an event object for the current device using
    :py:obj:`~.cudaEventDefault`.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorLaunchFailure`, :py:obj:`~.cudaErrorMemoryAllocation`
    event : :py:obj:`~.cudaEvent_t`
        Newly created event

    See Also
    --------
    cudaEventCreate (C++ API), :py:obj:`~.cudaEventCreateWithFlags`, :py:obj:`~.cudaEventRecord`, :py:obj:`~.cudaEventQuery`, :py:obj:`~.cudaEventSynchronize`, :py:obj:`~.cudaEventDestroy`, :py:obj:`~.cudaEventElapsedTime`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cuEventCreate`
    """
    cdef cudaEvent_t event = cudaEvent_t()
    with nogil:
        err = cyruntime.cudaEventCreate(<cyruntime.cudaEvent_t*>event._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), event)
{{endif}}

{{if 'cudaEventCreateWithFlags' in found_functions}}

@cython.embedsignature(True)
def cudaEventCreateWithFlags(unsigned int flags):
    """ Creates an event object with the specified flags.

    Creates an event object for the current device with the specified
    flags. Valid flags include:

    - :py:obj:`~.cudaEventDefault`: Default event creation flag.

    - :py:obj:`~.cudaEventBlockingSync`: Specifies that event should use
      blocking synchronization. A host thread that uses
      :py:obj:`~.cudaEventSynchronize()` to wait on an event created with
      this flag will block until the event actually completes.

    - :py:obj:`~.cudaEventDisableTiming`: Specifies that the created event
      does not need to record timing data. Events created with this flag
      specified and the :py:obj:`~.cudaEventBlockingSync` flag not
      specified will provide the best performance when used with
      :py:obj:`~.cudaStreamWaitEvent()` and :py:obj:`~.cudaEventQuery()`.

    - :py:obj:`~.cudaEventInterprocess`: Specifies that the created event
      may be used as an interprocess event by
      :py:obj:`~.cudaIpcGetEventHandle()`.
      :py:obj:`~.cudaEventInterprocess` must be specified along with
      :py:obj:`~.cudaEventDisableTiming`.

    Parameters
    ----------
    flags : unsigned int
        Flags for new event

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorLaunchFailure`, :py:obj:`~.cudaErrorMemoryAllocation`
    event : :py:obj:`~.cudaEvent_t`
        Newly created event

    See Also
    --------
    :py:obj:`~.cudaEventCreate (C API)`, :py:obj:`~.cudaEventSynchronize`, :py:obj:`~.cudaEventDestroy`, :py:obj:`~.cudaEventElapsedTime`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cuEventCreate`
    """
    cdef cudaEvent_t event = cudaEvent_t()
    with nogil:
        err = cyruntime.cudaEventCreateWithFlags(<cyruntime.cudaEvent_t*>event._pvt_ptr, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), event)
{{endif}}

{{if 'cudaEventRecord' in found_functions}}

@cython.embedsignature(True)
def cudaEventRecord(event, stream):
    """ Records an event.

    Captures in `event` the contents of `stream` at the time of this call.
    `event` and `stream` must be on the same CUDA context. Calls such as
    :py:obj:`~.cudaEventQuery()` or :py:obj:`~.cudaStreamWaitEvent()` will
    then examine or wait for completion of the work that was captured. Uses
    of `stream` after this call do not modify `event`. See note on default
    stream behavior for what is captured in the default case.

    :py:obj:`~.cudaEventRecord()` can be called multiple times on the same
    event and will overwrite the previously captured state. Other APIs such
    as :py:obj:`~.cudaStreamWaitEvent()` use the most recently captured
    state at the time of the API call, and are not affected by later calls
    to :py:obj:`~.cudaEventRecord()`. Before the first call to
    :py:obj:`~.cudaEventRecord()`, an event represents an empty set of
    work, so for example :py:obj:`~.cudaEventQuery()` would return
    :py:obj:`~.cudaSuccess`.

    Parameters
    ----------
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to record
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream in which to record event

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorLaunchFailure`

    See Also
    --------
    :py:obj:`~.cudaEventCreate (C API)`, :py:obj:`~.cudaEventCreateWithFlags`, :py:obj:`~.cudaEventQuery`, :py:obj:`~.cudaEventSynchronize`, :py:obj:`~.cudaEventDestroy`, :py:obj:`~.cudaEventElapsedTime`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaEventRecordWithFlags`, :py:obj:`~.cuEventRecord`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaEvent_t cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (cudaEvent_t,driver.CUevent)):
        pevent = int(event)
    else:
        pevent = int(cudaEvent_t(event))
    cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
    with nogil:
        err = cyruntime.cudaEventRecord(cyevent, cystream)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaEventRecordWithFlags' in found_functions}}

@cython.embedsignature(True)
def cudaEventRecordWithFlags(event, stream, unsigned int flags):
    """ Records an event.

    Captures in `event` the contents of `stream` at the time of this call.
    `event` and `stream` must be on the same CUDA context. Calls such as
    :py:obj:`~.cudaEventQuery()` or :py:obj:`~.cudaStreamWaitEvent()` will
    then examine or wait for completion of the work that was captured. Uses
    of `stream` after this call do not modify `event`. See note on default
    stream behavior for what is captured in the default case.

    :py:obj:`~.cudaEventRecordWithFlags()` can be called multiple times on
    the same event and will overwrite the previously captured state. Other
    APIs such as :py:obj:`~.cudaStreamWaitEvent()` use the most recently
    captured state at the time of the API call, and are not affected by
    later calls to :py:obj:`~.cudaEventRecordWithFlags()`. Before the first
    call to :py:obj:`~.cudaEventRecordWithFlags()`, an event represents an
    empty set of work, so for example :py:obj:`~.cudaEventQuery()` would
    return :py:obj:`~.cudaSuccess`.

    flags include:

    - :py:obj:`~.cudaEventRecordDefault`: Default event creation flag.

    - :py:obj:`~.cudaEventRecordExternal`: Event is captured in the graph
      as an external event node when performing stream capture.

    Parameters
    ----------
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to record
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream in which to record event
    flags : unsigned int
        Parameters for the operation(See above)

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorLaunchFailure`

    See Also
    --------
    :py:obj:`~.cudaEventCreate (C API)`, :py:obj:`~.cudaEventCreateWithFlags`, :py:obj:`~.cudaEventQuery`, :py:obj:`~.cudaEventSynchronize`, :py:obj:`~.cudaEventDestroy`, :py:obj:`~.cudaEventElapsedTime`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaEventRecord`, :py:obj:`~.cuEventRecord`,
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaEvent_t cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (cudaEvent_t,driver.CUevent)):
        pevent = int(event)
    else:
        pevent = int(cudaEvent_t(event))
    cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
    with nogil:
        err = cyruntime.cudaEventRecordWithFlags(cyevent, cystream, flags)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaEventQuery' in found_functions}}

@cython.embedsignature(True)
def cudaEventQuery(event):
    """ Queries an event's status.

    Queries the status of all work currently captured by `event`. See
    :py:obj:`~.cudaEventRecord()` for details on what is captured by an
    event.

    Returns :py:obj:`~.cudaSuccess` if all captured work has been
    completed, or :py:obj:`~.cudaErrorNotReady` if any captured work is
    incomplete.

    For the purposes of Unified Memory, a return value of
    :py:obj:`~.cudaSuccess` is equivalent to having called
    :py:obj:`~.cudaEventSynchronize()`.

    Parameters
    ----------
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to query

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorNotReady`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorLaunchFailure`

    See Also
    --------
    :py:obj:`~.cudaEventCreate (C API)`, :py:obj:`~.cudaEventCreateWithFlags`, :py:obj:`~.cudaEventRecord`, :py:obj:`~.cudaEventSynchronize`, :py:obj:`~.cudaEventDestroy`, :py:obj:`~.cudaEventElapsedTime`, :py:obj:`~.cuEventQuery`
    """
    cdef cyruntime.cudaEvent_t cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (cudaEvent_t,driver.CUevent)):
        pevent = int(event)
    else:
        pevent = int(cudaEvent_t(event))
    cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
    with nogil:
        err = cyruntime.cudaEventQuery(cyevent)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaEventSynchronize' in found_functions}}

@cython.embedsignature(True)
def cudaEventSynchronize(event):
    """ Waits for an event to complete.

    Waits until the completion of all work currently captured in `event`.
    See :py:obj:`~.cudaEventRecord()` for details on what is captured by an
    event.

    Waiting for an event that was created with the
    :py:obj:`~.cudaEventBlockingSync` flag will cause the calling CPU
    thread to block until the event has been completed by the device. If
    the :py:obj:`~.cudaEventBlockingSync` flag has not been set, then the
    CPU thread will busy-wait until the event has been completed by the
    device.

    Parameters
    ----------
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to wait for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorLaunchFailure`

    See Also
    --------
    :py:obj:`~.cudaEventCreate (C API)`, :py:obj:`~.cudaEventCreateWithFlags`, :py:obj:`~.cudaEventRecord`, :py:obj:`~.cudaEventQuery`, :py:obj:`~.cudaEventDestroy`, :py:obj:`~.cudaEventElapsedTime`, :py:obj:`~.cuEventSynchronize`
    """
    cdef cyruntime.cudaEvent_t cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (cudaEvent_t,driver.CUevent)):
        pevent = int(event)
    else:
        pevent = int(cudaEvent_t(event))
    cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
    with nogil:
        err = cyruntime.cudaEventSynchronize(cyevent)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaEventDestroy' in found_functions}}

@cython.embedsignature(True)
def cudaEventDestroy(event):
    """ Destroys an event object.

    Destroys the event specified by `event`.

    An event may be destroyed before it is complete (i.e., while
    :py:obj:`~.cudaEventQuery()` would return
    :py:obj:`~.cudaErrorNotReady`). In this case, the call does not block
    on completion of the event, and any associated resources will
    automatically be released asynchronously at completion.

    Parameters
    ----------
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to destroy

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorLaunchFailure`

    See Also
    --------
    :py:obj:`~.cudaEventCreate (C API)`, :py:obj:`~.cudaEventCreateWithFlags`, :py:obj:`~.cudaEventQuery`, :py:obj:`~.cudaEventSynchronize`, :py:obj:`~.cudaEventRecord`, :py:obj:`~.cudaEventElapsedTime`, :py:obj:`~.cuEventDestroy`
    """
    cdef cyruntime.cudaEvent_t cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (cudaEvent_t,driver.CUevent)):
        pevent = int(event)
    else:
        pevent = int(cudaEvent_t(event))
    cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
    with nogil:
        err = cyruntime.cudaEventDestroy(cyevent)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaEventElapsedTime' in found_functions}}

@cython.embedsignature(True)
def cudaEventElapsedTime(start, end):
    """ Computes the elapsed time between events.

    Computes the elapsed time between two events (in milliseconds with a
    resolution of around 0.5 microseconds). Note this API is not guaranteed
    to return the latest errors for pending work. As such this API is
    intended to serve as a elapsed time calculation only and polling for
    completion on the events to be compared should be done with
    :py:obj:`~.cudaEventQuery` instead.

    If either event was last recorded in a non-NULL stream, the resulting
    time may be greater than expected (even if both used the same stream
    handle). This happens because the :py:obj:`~.cudaEventRecord()`
    operation takes place asynchronously and there is no guarantee that the
    measured latency is actually just between the two events. Any number of
    other different stream operations could execute in between the two
    measured events, thus altering the timing in a significant way.

    If :py:obj:`~.cudaEventRecord()` has not been called on either event,
    then :py:obj:`~.cudaErrorInvalidResourceHandle` is returned. If
    :py:obj:`~.cudaEventRecord()` has been called on both events but one or
    both of them has not yet been completed (that is,
    :py:obj:`~.cudaEventQuery()` would return :py:obj:`~.cudaErrorNotReady`
    on at least one of the events), :py:obj:`~.cudaErrorNotReady` is
    returned. If either event was created with the
    :py:obj:`~.cudaEventDisableTiming` flag, then this function will return
    :py:obj:`~.cudaErrorInvalidResourceHandle`.

    Parameters
    ----------
    start : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Starting event
    end : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Ending event

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorNotReady`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorLaunchFailure`, :py:obj:`~.cudaErrorUnknown`
    ms : float
        Time between `start` and `end` in ms

    See Also
    --------
    :py:obj:`~.cudaEventCreate (C API)`, :py:obj:`~.cudaEventCreateWithFlags`, :py:obj:`~.cudaEventQuery`, :py:obj:`~.cudaEventSynchronize`, :py:obj:`~.cudaEventDestroy`, :py:obj:`~.cudaEventRecord`, :py:obj:`~.cuEventElapsedTime`
    """
    cdef cyruntime.cudaEvent_t cyend
    if end is None:
        pend = 0
    elif isinstance(end, (cudaEvent_t,driver.CUevent)):
        pend = int(end)
    else:
        pend = int(cudaEvent_t(end))
    cyend = <cyruntime.cudaEvent_t><void_ptr>pend
    cdef cyruntime.cudaEvent_t cystart
    if start is None:
        pstart = 0
    elif isinstance(start, (cudaEvent_t,driver.CUevent)):
        pstart = int(start)
    else:
        pstart = int(cudaEvent_t(start))
    cystart = <cyruntime.cudaEvent_t><void_ptr>pstart
    cdef float ms = 0
    with nogil:
        err = cyruntime.cudaEventElapsedTime(&ms, cystart, cyend)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), ms)
{{endif}}

{{if 'cudaImportExternalMemory' in found_functions}}

@cython.embedsignature(True)
def cudaImportExternalMemory(memHandleDesc : Optional[cudaExternalMemoryHandleDesc]):
    """ Imports an external memory object.

    Imports an externally allocated memory object and returns a handle to
    that in `extMem_out`.

    The properties of the handle being imported must be described in
    `memHandleDesc`. The :py:obj:`~.cudaExternalMemoryHandleDesc` structure
    is defined as follows:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.cudaExternalMemoryHandleDesc.type` specifies the type
    of handle being imported. :py:obj:`~.cudaExternalMemoryHandleType` is
    defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.cudaExternalMemoryHandleDesc.type` is
    :py:obj:`~.cudaExternalMemoryHandleTypeOpaqueFd`, then
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::fd must be a valid
    file descriptor referencing a memory object. Ownership of the file
    descriptor is transferred to the CUDA driver when the handle is
    imported successfully. Performing any operations on the file descriptor
    after it is imported results in undefined behavior.

    If :py:obj:`~.cudaExternalMemoryHandleDesc.type` is
    :py:obj:`~.cudaExternalMemoryHandleTypeOpaqueWin32`, then exactly one
    of :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::handle and
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::name must not
    be NULL. If
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::handle is not
    NULL, then it must represent a valid shared NT handle that references a
    memory object. Ownership of this handle is not transferred to CUDA
    after the import operation, so the application must release the handle
    using the appropriate system call. If
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::name is not
    NULL, then it must point to a NULL-terminated array of UTF-16
    characters that refers to a memory object.

    If :py:obj:`~.cudaExternalMemoryHandleDesc.type` is
    :py:obj:`~.cudaExternalMemoryHandleTypeOpaqueWin32Kmt`, then
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::handle must be
    non-NULL and
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::name must be
    NULL. The handle specified must be a globally shared KMT handle. This
    handle does not hold a reference to the underlying object, and thus
    will be invalid when all references to the memory object are destroyed.

    If :py:obj:`~.cudaExternalMemoryHandleDesc.type` is
    :py:obj:`~.cudaExternalMemoryHandleTypeD3D12Heap`, then exactly one of
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::handle and
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::name must not
    be NULL. If
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::handle is not
    NULL, then it must represent a valid shared NT handle that is returned
    by ID3D12Device::CreateSharedHandle when referring to a ID3D12Heap
    object. This handle holds a reference to the underlying object. If
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::name is not
    NULL, then it must point to a NULL-terminated array of UTF-16
    characters that refers to a ID3D12Heap object.

    If :py:obj:`~.cudaExternalMemoryHandleDesc.type` is
    :py:obj:`~.cudaExternalMemoryHandleTypeD3D12Resource`, then exactly one
    of :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::handle and
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::name must not
    be NULL. If
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::handle is not
    NULL, then it must represent a valid shared NT handle that is returned
    by ID3D12Device::CreateSharedHandle when referring to a ID3D12Resource
    object. This handle holds a reference to the underlying object. If
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::name is not
    NULL, then it must point to a NULL-terminated array of UTF-16
    characters that refers to a ID3D12Resource object.

    If :py:obj:`~.cudaExternalMemoryHandleDesc.type` is
    :py:obj:`~.cudaExternalMemoryHandleTypeD3D11Resource`,then exactly one
    of :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::handle and
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::name must not
    be NULL. If
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::handle is
    not NULL, then it must represent a valid shared NT handle that is
    returned by IDXGIResource1::CreateSharedHandle when referring to a
    ID3D11Resource object. If
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::name is not
    NULL, then it must point to a NULL-terminated array of UTF-16
    characters that refers to a ID3D11Resource object.

    If :py:obj:`~.cudaExternalMemoryHandleDesc.type` is
    :py:obj:`~.cudaExternalMemoryHandleTypeD3D11ResourceKmt`, then
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::handle must be
    non-NULL and
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::win32::name must be
    NULL. The handle specified must be a valid shared KMT handle that is
    returned by IDXGIResource::GetSharedHandle when referring to a
    ID3D11Resource object.

    If :py:obj:`~.cudaExternalMemoryHandleDesc.type` is
    :py:obj:`~.cudaExternalMemoryHandleTypeNvSciBuf`, then
    :py:obj:`~.cudaExternalMemoryHandleDesc`::handle::nvSciBufObject must
    be NON-NULL and reference a valid NvSciBuf object. If the NvSciBuf
    object imported into CUDA is also mapped by other drivers, then the
    application must use :py:obj:`~.cudaWaitExternalSemaphoresAsync` or
    :py:obj:`~.cudaSignalExternalSemaphoresAsync` as approprriate barriers
    to maintain coherence between CUDA and the other drivers. See
    :py:obj:`~.cudaExternalSemaphoreWaitSkipNvSciBufMemSync` and
    :py:obj:`~.cudaExternalSemaphoreSignalSkipNvSciBufMemSync` for memory
    synchronization.

    The size of the memory object must be specified in
    :py:obj:`~.cudaExternalMemoryHandleDesc.size`.

    Specifying the flag :py:obj:`~.cudaExternalMemoryDedicated` in
    :py:obj:`~.cudaExternalMemoryHandleDesc.flags` indicates that the
    resource is a dedicated resource. The definition of what a dedicated
    resource is outside the scope of this extension. This flag must be set
    if :py:obj:`~.cudaExternalMemoryHandleDesc.type` is one of the
    following: :py:obj:`~.cudaExternalMemoryHandleTypeD3D12Resource`
    :py:obj:`~.cudaExternalMemoryHandleTypeD3D11Resource`
    :py:obj:`~.cudaExternalMemoryHandleTypeD3D11ResourceKmt`

    Parameters
    ----------
    memHandleDesc : :py:obj:`~.cudaExternalMemoryHandleDesc`
        Memory import handle descriptor

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorOperatingSystem`
    extMem_out : :py:obj:`~.cudaExternalMemory_t`
        Returned handle to an external memory object

    See Also
    --------
    :py:obj:`~.cudaDestroyExternalMemory`, :py:obj:`~.cudaExternalMemoryGetMappedBuffer`, :py:obj:`~.cudaExternalMemoryGetMappedMipmappedArray`

    Notes
    -----
    If the Vulkan memory imported into CUDA is mapped on the CPU then the application must use vkInvalidateMappedMemoryRanges/vkFlushMappedMemoryRanges as well as appropriate Vulkan pipeline barriers to maintain coherence between CPU and GPU. For more information on these APIs, please refer to "Synchronization
    and Cache Control" chapter from Vulkan specification.
    """
    cdef cudaExternalMemory_t extMem_out = cudaExternalMemory_t()
    cdef cyruntime.cudaExternalMemoryHandleDesc* cymemHandleDesc_ptr = memHandleDesc._pvt_ptr if memHandleDesc is not None else NULL
    with nogil:
        err = cyruntime.cudaImportExternalMemory(<cyruntime.cudaExternalMemory_t*>extMem_out._pvt_ptr, cymemHandleDesc_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), extMem_out)
{{endif}}

{{if 'cudaExternalMemoryGetMappedBuffer' in found_functions}}

@cython.embedsignature(True)
def cudaExternalMemoryGetMappedBuffer(extMem, bufferDesc : Optional[cudaExternalMemoryBufferDesc]):
    """ Maps a buffer onto an imported memory object.

    Maps a buffer onto an imported memory object and returns a device
    pointer in `devPtr`.

    The properties of the buffer being mapped must be described in
    `bufferDesc`. The :py:obj:`~.cudaExternalMemoryBufferDesc` structure is
    defined as follows:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.cudaExternalMemoryBufferDesc.offset` is the offset in
    the memory object where the buffer's base address is.
    :py:obj:`~.cudaExternalMemoryBufferDesc.size` is the size of the
    buffer. :py:obj:`~.cudaExternalMemoryBufferDesc.flags` must be zero.

    The offset and size have to be suitably aligned to match the
    requirements of the external API. Mapping two buffers whose ranges
    overlap may or may not result in the same virtual address being
    returned for the overlapped portion. In such cases, the application
    must ensure that all accesses to that region from the GPU are volatile.
    Otherwise writes made via one address are not guaranteed to be visible
    via the other address, even if they're issued by the same thread. It is
    recommended that applications map the combined range instead of mapping
    separate buffers and then apply the appropriate offsets to the returned
    pointer to derive the individual buffers.

    The returned pointer `devPtr` must be freed using :py:obj:`~.cudaFree`.

    Parameters
    ----------
    extMem : :py:obj:`~.cudaExternalMemory_t`
        Handle to external memory object
    bufferDesc : :py:obj:`~.cudaExternalMemoryBufferDesc`
        Buffer descriptor

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`
    devPtr : Any
        Returned device pointer to buffer

    See Also
    --------
    :py:obj:`~.cudaImportExternalMemory`, :py:obj:`~.cudaDestroyExternalMemory`, :py:obj:`~.cudaExternalMemoryGetMappedMipmappedArray`
    """
    cdef cyruntime.cudaExternalMemory_t cyextMem
    if extMem is None:
        pextMem = 0
    elif isinstance(extMem, (cudaExternalMemory_t,)):
        pextMem = int(extMem)
    else:
        pextMem = int(cudaExternalMemory_t(extMem))
    cyextMem = <cyruntime.cudaExternalMemory_t><void_ptr>pextMem
    cdef void_ptr devPtr = 0
    cdef cyruntime.cudaExternalMemoryBufferDesc* cybufferDesc_ptr = bufferDesc._pvt_ptr if bufferDesc is not None else NULL
    with nogil:
        err = cyruntime.cudaExternalMemoryGetMappedBuffer(<void**>&devPtr, cyextMem, cybufferDesc_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), devPtr)
{{endif}}

{{if 'cudaExternalMemoryGetMappedMipmappedArray' in found_functions}}

@cython.embedsignature(True)
def cudaExternalMemoryGetMappedMipmappedArray(extMem, mipmapDesc : Optional[cudaExternalMemoryMipmappedArrayDesc]):
    """ Maps a CUDA mipmapped array onto an external memory object.

    Maps a CUDA mipmapped array onto an external object and returns a
    handle to it in `mipmap`.

    The properties of the CUDA mipmapped array being mapped must be
    described in `mipmapDesc`. The structure
    :py:obj:`~.cudaExternalMemoryMipmappedArrayDesc` is defined as follows:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.cudaExternalMemoryMipmappedArrayDesc.offset` is the
    offset in the memory object where the base level of the mipmap chain
    is. :py:obj:`~.cudaExternalMemoryMipmappedArrayDesc.formatDesc`
    describes the format of the data.
    :py:obj:`~.cudaExternalMemoryMipmappedArrayDesc.extent` specifies the
    dimensions of the base level of the mipmap chain.
    :py:obj:`~.cudaExternalMemoryMipmappedArrayDesc.flags` are flags
    associated with CUDA mipmapped arrays. For further details, please
    refer to the documentation for :py:obj:`~.cudaMalloc3DArray`. Note that
    if the mipmapped array is bound as a color target in the graphics API,
    then the flag :py:obj:`~.cudaArrayColorAttachment` must be specified in
    :py:obj:`~.cudaExternalMemoryMipmappedArrayDesc.flags`.
    :py:obj:`~.cudaExternalMemoryMipmappedArrayDesc.numLevels` specifies
    the total number of levels in the mipmap chain.

    The returned CUDA mipmapped array must be freed using
    :py:obj:`~.cudaFreeMipmappedArray`.

    Parameters
    ----------
    extMem : :py:obj:`~.cudaExternalMemory_t`
        Handle to external memory object
    mipmapDesc : :py:obj:`~.cudaExternalMemoryMipmappedArrayDesc`
        CUDA array descriptor

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`
    mipmap : :py:obj:`~.cudaMipmappedArray_t`
        Returned CUDA mipmapped array

    See Also
    --------
    :py:obj:`~.cudaImportExternalMemory`, :py:obj:`~.cudaDestroyExternalMemory`, :py:obj:`~.cudaExternalMemoryGetMappedBuffer`

    Notes
    -----
    If :py:obj:`~.cudaExternalMemoryHandleDesc.type` is :py:obj:`~.cudaExternalMemoryHandleTypeNvSciBuf`, then :py:obj:`~.cudaExternalMemoryMipmappedArrayDesc.numLevels` must not be greater than 1.
    """
    cdef cyruntime.cudaExternalMemory_t cyextMem
    if extMem is None:
        pextMem = 0
    elif isinstance(extMem, (cudaExternalMemory_t,)):
        pextMem = int(extMem)
    else:
        pextMem = int(cudaExternalMemory_t(extMem))
    cyextMem = <cyruntime.cudaExternalMemory_t><void_ptr>pextMem
    cdef cudaMipmappedArray_t mipmap = cudaMipmappedArray_t()
    cdef cyruntime.cudaExternalMemoryMipmappedArrayDesc* cymipmapDesc_ptr = mipmapDesc._pvt_ptr if mipmapDesc is not None else NULL
    with nogil:
        err = cyruntime.cudaExternalMemoryGetMappedMipmappedArray(<cyruntime.cudaMipmappedArray_t*>mipmap._pvt_ptr, cyextMem, cymipmapDesc_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), mipmap)
{{endif}}

{{if 'cudaDestroyExternalMemory' in found_functions}}

@cython.embedsignature(True)
def cudaDestroyExternalMemory(extMem):
    """ Destroys an external memory object.

    Destroys the specified external memory object. Any existing buffers and
    CUDA mipmapped arrays mapped onto this object must no longer be used
    and must be explicitly freed using :py:obj:`~.cudaFree` and
    :py:obj:`~.cudaFreeMipmappedArray` respectively.

    Parameters
    ----------
    extMem : :py:obj:`~.cudaExternalMemory_t`
        External memory object to be destroyed

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidResourceHandle`

    See Also
    --------
    :py:obj:`~.cudaImportExternalMemory`, :py:obj:`~.cudaExternalMemoryGetMappedBuffer`, :py:obj:`~.cudaExternalMemoryGetMappedMipmappedArray`
    """
    cdef cyruntime.cudaExternalMemory_t cyextMem
    if extMem is None:
        pextMem = 0
    elif isinstance(extMem, (cudaExternalMemory_t,)):
        pextMem = int(extMem)
    else:
        pextMem = int(cudaExternalMemory_t(extMem))
    cyextMem = <cyruntime.cudaExternalMemory_t><void_ptr>pextMem
    with nogil:
        err = cyruntime.cudaDestroyExternalMemory(cyextMem)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaImportExternalSemaphore' in found_functions}}

@cython.embedsignature(True)
def cudaImportExternalSemaphore(semHandleDesc : Optional[cudaExternalSemaphoreHandleDesc]):
    """ Imports an external semaphore.

    Imports an externally allocated synchronization object and returns a
    handle to that in `extSem_out`.

    The properties of the handle being imported must be described in
    `semHandleDesc`. The :py:obj:`~.cudaExternalSemaphoreHandleDesc` is
    defined as follows:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.cudaExternalSemaphoreHandleDesc.type` specifies the
    type of handle being imported.
    :py:obj:`~.cudaExternalSemaphoreHandleType` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.cudaExternalSemaphoreHandleDesc.type` is
    :py:obj:`~.cudaExternalSemaphoreHandleTypeOpaqueFd`, then
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::fd must be a valid
    file descriptor referencing a synchronization object. Ownership of the
    file descriptor is transferred to the CUDA driver when the handle is
    imported successfully. Performing any operations on the file descriptor
    after it is imported results in undefined behavior.

    If :py:obj:`~.cudaExternalSemaphoreHandleDesc.type` is
    :py:obj:`~.cudaExternalSemaphoreHandleTypeOpaqueWin32`, then exactly
    one of
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::handle and
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::name must
    not be NULL. If
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::handle is
    not NULL, then it must represent a valid shared NT handle that
    references a synchronization object. Ownership of this handle is not
    transferred to CUDA after the import operation, so the application must
    release the handle using the appropriate system call. If
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::name is not
    NULL, then it must name a valid synchronization object.

    If :py:obj:`~.cudaExternalSemaphoreHandleDesc.type` is
    :py:obj:`~.cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt`, then
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::handle must
    be non-NULL and
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::name must
    be NULL. The handle specified must be a globally shared KMT handle.
    This handle does not hold a reference to the underlying object, and
    thus will be invalid when all references to the synchronization object
    are destroyed.

    If :py:obj:`~.cudaExternalSemaphoreHandleDesc.type` is
    :py:obj:`~.cudaExternalSemaphoreHandleTypeD3D12Fence`, then exactly one
    of :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::handle
    and :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::name
    must not be NULL. If
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::handle is
    not NULL, then it must represent a valid shared NT handle that is
    returned by ID3D12Device::CreateSharedHandle when referring to a
    ID3D12Fence object. This handle holds a reference to the underlying
    object. If
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::name is not
    NULL, then it must name a valid synchronization object that refers to a
    valid ID3D12Fence object.

    If :py:obj:`~.cudaExternalSemaphoreHandleDesc.type` is
    :py:obj:`~.cudaExternalSemaphoreHandleTypeD3D11Fence`, then exactly one
    of :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::handle
    and :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::name
    must not be NULL. If
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::handle is
    not NULL, then it must represent a valid shared NT handle that is
    returned by ID3D11Fence::CreateSharedHandle. If
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::name is not
    NULL, then it must name a valid synchronization object that refers to a
    valid ID3D11Fence object.

    If :py:obj:`~.cudaExternalSemaphoreHandleDesc.type` is
    :py:obj:`~.cudaExternalSemaphoreHandleTypeNvSciSync`, then
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::nvSciSyncObj
    represents a valid NvSciSyncObj.

    :py:obj:`~.cudaExternalSemaphoreHandleTypeKeyedMutex`, then exactly one
    of :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::handle
    and :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::name
    must not be NULL. If
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::handle is
    not NULL, then it represent a valid shared NT handle that is returned
    by IDXGIResource1::CreateSharedHandle when referring to a
    IDXGIKeyedMutex object.

    If :py:obj:`~.cudaExternalSemaphoreHandleDesc.type` is
    :py:obj:`~.cudaExternalSemaphoreHandleTypeKeyedMutexKmt`, then
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::handle must
    be non-NULL and
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::name must
    be NULL. The handle specified must represent a valid KMT handle that is
    returned by IDXGIResource::GetSharedHandle when referring to a
    IDXGIKeyedMutex object.

    If :py:obj:`~.cudaExternalSemaphoreHandleDesc.type` is
    :py:obj:`~.cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd`, then
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::fd must be a valid
    file descriptor referencing a synchronization object. Ownership of the
    file descriptor is transferred to the CUDA driver when the handle is
    imported successfully. Performing any operations on the file descriptor
    after it is imported results in undefined behavior.

    If :py:obj:`~.cudaExternalSemaphoreHandleDesc.type` is
    :py:obj:`~.cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32`, then
    exactly one of
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::handle and
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::name must
    not be NULL. If
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::handle is
    not NULL, then it must represent a valid shared NT handle that
    references a synchronization object. Ownership of this handle is not
    transferred to CUDA after the import operation, so the application must
    release the handle using the appropriate system call. If
    :py:obj:`~.cudaExternalSemaphoreHandleDesc`::handle::win32::name is not
    NULL, then it must name a valid synchronization object.

    Parameters
    ----------
    semHandleDesc : :py:obj:`~.cudaExternalSemaphoreHandleDesc`
        Semaphore import handle descriptor

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorOperatingSystem`
    extSem_out : :py:obj:`~.cudaExternalSemaphore_t`
        Returned handle to an external semaphore

    See Also
    --------
    :py:obj:`~.cudaDestroyExternalSemaphore`, :py:obj:`~.cudaSignalExternalSemaphoresAsync`, :py:obj:`~.cudaWaitExternalSemaphoresAsync`
    """
    cdef cudaExternalSemaphore_t extSem_out = cudaExternalSemaphore_t()
    cdef cyruntime.cudaExternalSemaphoreHandleDesc* cysemHandleDesc_ptr = semHandleDesc._pvt_ptr if semHandleDesc is not None else NULL
    with nogil:
        err = cyruntime.cudaImportExternalSemaphore(<cyruntime.cudaExternalSemaphore_t*>extSem_out._pvt_ptr, cysemHandleDesc_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), extSem_out)
{{endif}}

{{if 'cudaSignalExternalSemaphoresAsync' in found_functions}}

@cython.embedsignature(True)
def cudaSignalExternalSemaphoresAsync(extSemArray : Optional[tuple[cudaExternalSemaphore_t] | list[cudaExternalSemaphore_t]], paramsArray : Optional[tuple[cudaExternalSemaphoreSignalParams] | list[cudaExternalSemaphoreSignalParams]], unsigned int numExtSems, stream):
    """ Signals a set of external semaphore objects.

    Enqueues a signal operation on a set of externally allocated semaphore
    object in the specified stream. The operations will be executed when
    all prior operations in the stream complete.

    The exact semantics of signaling a semaphore depends on the type of the
    object.

    If the semaphore object is any one of the following types:
    :py:obj:`~.cudaExternalSemaphoreHandleTypeOpaqueFd`,
    :py:obj:`~.cudaExternalSemaphoreHandleTypeOpaqueWin32`,
    :py:obj:`~.cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt` then
    signaling the semaphore will set it to the signaled state.

    If the semaphore object is any one of the following types:
    :py:obj:`~.cudaExternalSemaphoreHandleTypeD3D12Fence`,
    :py:obj:`~.cudaExternalSemaphoreHandleTypeD3D11Fence`,
    :py:obj:`~.cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd`,
    :py:obj:`~.cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32` then
    the semaphore will be set to the value specified in
    :py:obj:`~.cudaExternalSemaphoreSignalParams`::params::fence::value.

    If the semaphore object is of the type
    :py:obj:`~.cudaExternalSemaphoreHandleTypeNvSciSync` this API sets
    :py:obj:`~.cudaExternalSemaphoreSignalParams`::params::nvSciSync::fence
    to a value that can be used by subsequent waiters of the same NvSciSync
    object to order operations with those currently submitted in `stream`.
    Such an update will overwrite previous contents of
    :py:obj:`~.cudaExternalSemaphoreSignalParams`::params::nvSciSync::fence.
    By default, signaling such an external semaphore object causes
    appropriate memory synchronization operations to be performed over all
    the external memory objects that are imported as
    :py:obj:`~.cudaExternalMemoryHandleTypeNvSciBuf`. This ensures that any
    subsequent accesses made by other importers of the same set of NvSciBuf
    memory object(s) are coherent. These operations can be skipped by
    specifying the flag
    :py:obj:`~.cudaExternalSemaphoreSignalSkipNvSciBufMemSync`, which can
    be used as a performance optimization when data coherency is not
    required. But specifying this flag in scenarios where data coherency is
    required results in undefined behavior. Also, for semaphore object of
    the type :py:obj:`~.cudaExternalSemaphoreHandleTypeNvSciSync`, if the
    NvSciSyncAttrList used to create the NvSciSyncObj had not set the flags
    in :py:obj:`~.cudaDeviceGetNvSciSyncAttributes` to
    cudaNvSciSyncAttrSignal, this API will return cudaErrorNotSupported.

    :py:obj:`~.cudaExternalSemaphoreSignalParams`::params::nvSciSync::fence
    associated with semaphore object of the type
    :py:obj:`~.cudaExternalSemaphoreHandleTypeNvSciSync` can be
    deterministic. For this the NvSciSyncAttrList used to create the
    semaphore object must have value of
    NvSciSyncAttrKey_RequireDeterministicFences key set to true.
    Deterministic fences allow users to enqueue a wait over the semaphore
    object even before corresponding signal is enqueued. For such a
    semaphore object, CUDA guarantees that each signal operation will
    increment the fence value by '1'. Users are expected to track count of
    signals enqueued on the semaphore object and insert waits accordingly.
    When such a semaphore object is signaled from multiple streams, due to
    concurrent stream execution, it is possible that the order in which the
    semaphore gets signaled is indeterministic. This could lead to waiters
    of the semaphore getting unblocked incorrectly. Users are expected to
    handle such situations, either by not using the same semaphore object
    with deterministic fence support enabled in different streams or by
    adding explicit dependency amongst such streams so that the semaphore
    is signaled in order.
    :py:obj:`~.cudaExternalSemaphoreSignalParams`::params::nvSciSync::fence
    associated with semaphore object of the type
    :py:obj:`~.cudaExternalSemaphoreHandleTypeNvSciSync` can be timestamp
    enabled. For this the NvSciSyncAttrList used to create the object must
    have the value of NvSciSyncAttrKey_WaiterRequireTimestamps key set to
    true. Timestamps are emitted asynchronously by the GPU and CUDA saves
    the GPU timestamp in the corresponding NvSciSyncFence at the time of
    signal on GPU. Users are expected to convert GPU clocks to CPU clocks
    using appropriate scaling functions. Users are expected to wait for the
    completion of the fence before extracting timestamp using appropriate
    NvSciSync APIs. Users are expected to ensure that there is only one
    outstanding timestamp enabled fence per Cuda-NvSciSync object at any
    point of time, failing which leads to undefined behavior. Extracting
    the timestamp before the corresponding fence is signalled could lead to
    undefined behaviour. Timestamp extracted via appropriate NvSciSync API
    would be in microseconds.

    If the semaphore object is any one of the following types:
    :py:obj:`~.cudaExternalSemaphoreHandleTypeKeyedMutex`,
    :py:obj:`~.cudaExternalSemaphoreHandleTypeKeyedMutexKmt`, then the
    keyed mutex will be released with the key specified in
    :py:obj:`~.cudaExternalSemaphoreSignalParams`::params::keyedmutex::key.

    Parameters
    ----------
    extSemArray : list[:py:obj:`~.cudaExternalSemaphore_t`]
        Set of external semaphores to be signaled
    paramsArray : list[:py:obj:`~.cudaExternalSemaphoreSignalParams`]
        Array of semaphore parameters
    numExtSems : unsigned int
        Number of semaphores to signal
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to enqueue the signal operations in

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidResourceHandle`

    See Also
    --------
    :py:obj:`~.cudaImportExternalSemaphore`, :py:obj:`~.cudaDestroyExternalSemaphore`, :py:obj:`~.cudaWaitExternalSemaphoresAsync`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    paramsArray = [] if paramsArray is None else paramsArray
    if not all(isinstance(_x, (cudaExternalSemaphoreSignalParams,)) for _x in paramsArray):
        raise TypeError("Argument 'paramsArray' is not instance of type (expected tuple[cyruntime.cudaExternalSemaphoreSignalParams,] or list[cyruntime.cudaExternalSemaphoreSignalParams,]")
    extSemArray = [] if extSemArray is None else extSemArray
    if not all(isinstance(_x, (cudaExternalSemaphore_t,)) for _x in extSemArray):
        raise TypeError("Argument 'extSemArray' is not instance of type (expected tuple[cyruntime.cudaExternalSemaphore_t,] or list[cyruntime.cudaExternalSemaphore_t,]")
    cdef cyruntime.cudaExternalSemaphore_t* cyextSemArray = NULL
    if len(extSemArray) > 1:
        cyextSemArray = <cyruntime.cudaExternalSemaphore_t*> calloc(len(extSemArray), sizeof(cyruntime.cudaExternalSemaphore_t))
        if cyextSemArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(extSemArray)) + 'x' + str(sizeof(cyruntime.cudaExternalSemaphore_t)))
        else:
            for idx in range(len(extSemArray)):
                cyextSemArray[idx] = <cyruntime.cudaExternalSemaphore_t>(<cudaExternalSemaphore_t>extSemArray[idx])._pvt_ptr[0]
    elif len(extSemArray) == 1:
        cyextSemArray = <cyruntime.cudaExternalSemaphore_t*>(<cudaExternalSemaphore_t>extSemArray[0])._pvt_ptr
    cdef cyruntime.cudaExternalSemaphoreSignalParams* cyparamsArray = NULL
    if len(paramsArray) > 1:
        cyparamsArray = <cyruntime.cudaExternalSemaphoreSignalParams*> calloc(len(paramsArray), sizeof(cyruntime.cudaExternalSemaphoreSignalParams))
        if cyparamsArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(paramsArray)) + 'x' + str(sizeof(cyruntime.cudaExternalSemaphoreSignalParams)))
        for idx in range(len(paramsArray)):
            string.memcpy(&cyparamsArray[idx], (<cudaExternalSemaphoreSignalParams>paramsArray[idx])._pvt_ptr, sizeof(cyruntime.cudaExternalSemaphoreSignalParams))
    elif len(paramsArray) == 1:
        cyparamsArray = (<cudaExternalSemaphoreSignalParams>paramsArray[0])._pvt_ptr
    if numExtSems > len(extSemArray): raise RuntimeError("List is too small: " + str(len(extSemArray)) + " < " + str(numExtSems))
    if numExtSems > len(paramsArray): raise RuntimeError("List is too small: " + str(len(paramsArray)) + " < " + str(numExtSems))
    with nogil:
        err = cyruntime.cudaSignalExternalSemaphoresAsync(cyextSemArray, cyparamsArray, numExtSems, cystream)
    if len(extSemArray) > 1 and cyextSemArray is not NULL:
        free(cyextSemArray)
    if len(paramsArray) > 1 and cyparamsArray is not NULL:
        free(cyparamsArray)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaWaitExternalSemaphoresAsync' in found_functions}}

@cython.embedsignature(True)
def cudaWaitExternalSemaphoresAsync(extSemArray : Optional[tuple[cudaExternalSemaphore_t] | list[cudaExternalSemaphore_t]], paramsArray : Optional[tuple[cudaExternalSemaphoreWaitParams] | list[cudaExternalSemaphoreWaitParams]], unsigned int numExtSems, stream):
    """ Waits on a set of external semaphore objects.

    Enqueues a wait operation on a set of externally allocated semaphore
    object in the specified stream. The operations will be executed when
    all prior operations in the stream complete.

    The exact semantics of waiting on a semaphore depends on the type of
    the object.

    If the semaphore object is any one of the following types:
    :py:obj:`~.cudaExternalSemaphoreHandleTypeOpaqueFd`,
    :py:obj:`~.cudaExternalSemaphoreHandleTypeOpaqueWin32`,
    :py:obj:`~.cudaExternalSemaphoreHandleTypeOpaqueWin32Kmt` then waiting
    on the semaphore will wait until the semaphore reaches the signaled
    state. The semaphore will then be reset to the unsignaled state.
    Therefore for every signal operation, there can only be one wait
    operation.

    If the semaphore object is any one of the following types:
    :py:obj:`~.cudaExternalSemaphoreHandleTypeD3D12Fence`,
    :py:obj:`~.cudaExternalSemaphoreHandleTypeD3D11Fence`,
    :py:obj:`~.cudaExternalSemaphoreHandleTypeTimelineSemaphoreFd`,
    :py:obj:`~.cudaExternalSemaphoreHandleTypeTimelineSemaphoreWin32` then
    waiting on the semaphore will wait until the value of the semaphore is
    greater than or equal to
    :py:obj:`~.cudaExternalSemaphoreWaitParams`::params::fence::value.

    If the semaphore object is of the type
    :py:obj:`~.cudaExternalSemaphoreHandleTypeNvSciSync` then, waiting on
    the semaphore will wait until the
    :py:obj:`~.cudaExternalSemaphoreSignalParams`::params::nvSciSync::fence
    is signaled by the signaler of the NvSciSyncObj that was associated
    with this semaphore object. By default, waiting on such an external
    semaphore object causes appropriate memory synchronization operations
    to be performed over all external memory objects that are imported as
    :py:obj:`~.cudaExternalMemoryHandleTypeNvSciBuf`. This ensures that any
    subsequent accesses made by other importers of the same set of NvSciBuf
    memory object(s) are coherent. These operations can be skipped by
    specifying the flag
    :py:obj:`~.cudaExternalSemaphoreWaitSkipNvSciBufMemSync`, which can be
    used as a performance optimization when data coherency is not required.
    But specifying this flag in scenarios where data coherency is required
    results in undefined behavior. Also, for semaphore object of the type
    :py:obj:`~.cudaExternalSemaphoreHandleTypeNvSciSync`, if the
    NvSciSyncAttrList used to create the NvSciSyncObj had not set the flags
    in :py:obj:`~.cudaDeviceGetNvSciSyncAttributes` to
    cudaNvSciSyncAttrWait, this API will return cudaErrorNotSupported.

    If the semaphore object is any one of the following types:
    :py:obj:`~.cudaExternalSemaphoreHandleTypeKeyedMutex`,
    :py:obj:`~.cudaExternalSemaphoreHandleTypeKeyedMutexKmt`, then the
    keyed mutex will be acquired when it is released with the key specified
    in
    :py:obj:`~.cudaExternalSemaphoreSignalParams`::params::keyedmutex::key
    or until the timeout specified by
    :py:obj:`~.cudaExternalSemaphoreSignalParams`::params::keyedmutex::timeoutMs
    has lapsed. The timeout interval can either be a finite value specified
    in milliseconds or an infinite value. In case an infinite value is
    specified the timeout never elapses. The windows INFINITE macro must be
    used to specify infinite timeout

    Parameters
    ----------
    extSemArray : list[:py:obj:`~.cudaExternalSemaphore_t`]
        External semaphores to be waited on
    paramsArray : list[:py:obj:`~.cudaExternalSemaphoreWaitParams`]
        Array of semaphore parameters
    numExtSems : unsigned int
        Number of semaphores to wait on
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to enqueue the wait operations in

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidResourceHandle` :py:obj:`~.cudaErrorTimeout`

    See Also
    --------
    :py:obj:`~.cudaImportExternalSemaphore`, :py:obj:`~.cudaDestroyExternalSemaphore`, :py:obj:`~.cudaSignalExternalSemaphoresAsync`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    paramsArray = [] if paramsArray is None else paramsArray
    if not all(isinstance(_x, (cudaExternalSemaphoreWaitParams,)) for _x in paramsArray):
        raise TypeError("Argument 'paramsArray' is not instance of type (expected tuple[cyruntime.cudaExternalSemaphoreWaitParams,] or list[cyruntime.cudaExternalSemaphoreWaitParams,]")
    extSemArray = [] if extSemArray is None else extSemArray
    if not all(isinstance(_x, (cudaExternalSemaphore_t,)) for _x in extSemArray):
        raise TypeError("Argument 'extSemArray' is not instance of type (expected tuple[cyruntime.cudaExternalSemaphore_t,] or list[cyruntime.cudaExternalSemaphore_t,]")
    cdef cyruntime.cudaExternalSemaphore_t* cyextSemArray = NULL
    if len(extSemArray) > 1:
        cyextSemArray = <cyruntime.cudaExternalSemaphore_t*> calloc(len(extSemArray), sizeof(cyruntime.cudaExternalSemaphore_t))
        if cyextSemArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(extSemArray)) + 'x' + str(sizeof(cyruntime.cudaExternalSemaphore_t)))
        else:
            for idx in range(len(extSemArray)):
                cyextSemArray[idx] = <cyruntime.cudaExternalSemaphore_t>(<cudaExternalSemaphore_t>extSemArray[idx])._pvt_ptr[0]
    elif len(extSemArray) == 1:
        cyextSemArray = <cyruntime.cudaExternalSemaphore_t*>(<cudaExternalSemaphore_t>extSemArray[0])._pvt_ptr
    cdef cyruntime.cudaExternalSemaphoreWaitParams* cyparamsArray = NULL
    if len(paramsArray) > 1:
        cyparamsArray = <cyruntime.cudaExternalSemaphoreWaitParams*> calloc(len(paramsArray), sizeof(cyruntime.cudaExternalSemaphoreWaitParams))
        if cyparamsArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(paramsArray)) + 'x' + str(sizeof(cyruntime.cudaExternalSemaphoreWaitParams)))
        for idx in range(len(paramsArray)):
            string.memcpy(&cyparamsArray[idx], (<cudaExternalSemaphoreWaitParams>paramsArray[idx])._pvt_ptr, sizeof(cyruntime.cudaExternalSemaphoreWaitParams))
    elif len(paramsArray) == 1:
        cyparamsArray = (<cudaExternalSemaphoreWaitParams>paramsArray[0])._pvt_ptr
    if numExtSems > len(extSemArray): raise RuntimeError("List is too small: " + str(len(extSemArray)) + " < " + str(numExtSems))
    if numExtSems > len(paramsArray): raise RuntimeError("List is too small: " + str(len(paramsArray)) + " < " + str(numExtSems))
    with nogil:
        err = cyruntime.cudaWaitExternalSemaphoresAsync(cyextSemArray, cyparamsArray, numExtSems, cystream)
    if len(extSemArray) > 1 and cyextSemArray is not NULL:
        free(cyextSemArray)
    if len(paramsArray) > 1 and cyparamsArray is not NULL:
        free(cyparamsArray)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaDestroyExternalSemaphore' in found_functions}}

@cython.embedsignature(True)
def cudaDestroyExternalSemaphore(extSem):
    """ Destroys an external semaphore.

    Destroys an external semaphore object and releases any references to
    the underlying resource. Any outstanding signals or waits must have
    completed before the semaphore is destroyed.

    Parameters
    ----------
    extSem : :py:obj:`~.cudaExternalSemaphore_t`
        External semaphore to be destroyed

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidResourceHandle`

    See Also
    --------
    :py:obj:`~.cudaImportExternalSemaphore`, :py:obj:`~.cudaSignalExternalSemaphoresAsync`, :py:obj:`~.cudaWaitExternalSemaphoresAsync`
    """
    cdef cyruntime.cudaExternalSemaphore_t cyextSem
    if extSem is None:
        pextSem = 0
    elif isinstance(extSem, (cudaExternalSemaphore_t,)):
        pextSem = int(extSem)
    else:
        pextSem = int(cudaExternalSemaphore_t(extSem))
    cyextSem = <cyruntime.cudaExternalSemaphore_t><void_ptr>pextSem
    with nogil:
        err = cyruntime.cudaDestroyExternalSemaphore(cyextSem)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaFuncSetCacheConfig' in found_functions}}

@cython.embedsignature(True)
def cudaFuncSetCacheConfig(func, cacheConfig not None : cudaFuncCache):
    """ Sets the preferred cache configuration for a device function.

    On devices where the L1 cache and shared memory use the same hardware
    resources, this sets through `cacheConfig` the preferred cache
    configuration for the function specified via `func`. This is only a
    preference. The runtime will use the requested configuration if
    possible, but it is free to choose a different configuration if
    required to execute `func`.

    `func` is a device function symbol and must be declared as a `None`
    function. If the specified function does not exist, then
    :py:obj:`~.cudaErrorInvalidDeviceFunction` is returned. For templated
    functions, pass the function symbol as follows:
    func_name<template_arg_0,...,template_arg_N>

    This setting does nothing on devices where the size of the L1 cache and
    shared memory are fixed.

    Launching a kernel with a different preference than the most recent
    preference setting may insert a device-side synchronization point.

    The supported cache configurations are:

    - :py:obj:`~.cudaFuncCachePreferNone`: no preference for shared memory
      or L1 (default)

    - :py:obj:`~.cudaFuncCachePreferShared`: prefer larger shared memory
      and smaller L1 cache

    - :py:obj:`~.cudaFuncCachePreferL1`: prefer larger L1 cache and smaller
      shared memory

    - :py:obj:`~.cudaFuncCachePreferEqual`: prefer equal size L1 cache and
      shared memory

    Parameters
    ----------
    func : Any
        Device function symbol
    cacheConfig : :py:obj:`~.cudaFuncCache`
        Requested cache configuration

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDeviceFunction`2

    See Also
    --------
    cudaFuncSetCacheConfig (C++ API), :py:obj:`~.cudaFuncGetAttributes (C API)`, :py:obj:`~.cudaLaunchKernel (C API)`, :py:obj:`~.cuFuncSetCacheConfig`

    Notes
    -----
    This API does not accept a :py:obj:`~.cudaKernel_t` casted as void*. If cache config modification is required for a :py:obj:`~.cudaKernel_t` (or a global function), it can be replaced with a call to :py:obj:`~.cudaFuncSetAttributes` with the attribute :py:obj:`~.cudaFuncAttributePreferredSharedMemoryCarveout` to specify a more granular L1 cache and shared memory split configuration.
    """
    cdef _HelperInputVoidPtrStruct cyfuncHelper
    cdef void* cyfunc = _helper_input_void_ptr(func, &cyfuncHelper)
    cdef cyruntime.cudaFuncCache cycacheConfig = int(cacheConfig)
    with nogil:
        err = cyruntime.cudaFuncSetCacheConfig(cyfunc, cycacheConfig)
    _helper_input_void_ptr_free(&cyfuncHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaFuncGetAttributes' in found_functions}}

@cython.embedsignature(True)
def cudaFuncGetAttributes(func):
    """ Find out attributes for a given function.

    This function obtains the attributes of a function specified via
    `func`. `func` is a device function symbol and must be declared as a
    `None` function. The fetched attributes are placed in `attr`. If the
    specified function does not exist, then it is assumed to be a
    :py:obj:`~.cudaKernel_t` and used as is. For templated functions, pass
    the function symbol as follows:
    func_name<template_arg_0,...,template_arg_N>

    Note that some function attributes such as
    :py:obj:`~.maxThreadsPerBlock` may vary based on the device that is
    currently being used.

    Parameters
    ----------
    func : Any
        Device function symbol

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDeviceFunction`2
    attr : :py:obj:`~.cudaFuncAttributes`
        Return pointer to function's attributes

    See Also
    --------
    :py:obj:`~.cudaFuncSetCacheConfig (C API)`, cudaFuncGetAttributes (C++ API), :py:obj:`~.cudaLaunchKernel (C API)`, :py:obj:`~.cuFuncGetAttribute`
    """
    cdef cudaFuncAttributes attr = cudaFuncAttributes()
    cdef _HelperInputVoidPtrStruct cyfuncHelper
    cdef void* cyfunc = _helper_input_void_ptr(func, &cyfuncHelper)
    with nogil:
        err = cyruntime.cudaFuncGetAttributes(<cyruntime.cudaFuncAttributes*>attr._pvt_ptr, cyfunc)
    _helper_input_void_ptr_free(&cyfuncHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), attr)
{{endif}}

{{if 'cudaFuncSetAttribute' in found_functions}}

@cython.embedsignature(True)
def cudaFuncSetAttribute(func, attr not None : cudaFuncAttribute, int value):
    """ Set attributes for a given function.

    This function sets the attributes of a function specified via `func`.
    The parameter `func` must be a pointer to a function that executes on
    the device. The parameter specified by `func` must be declared as a
    `None` function. The enumeration defined by `attr` is set to the value
    defined by `value`. If the specified function does not exist, then it
    is assumed to be a :py:obj:`~.cudaKernel_t` and used as is. If the
    specified attribute cannot be written, or if the value is incorrect,
    then :py:obj:`~.cudaErrorInvalidValue` is returned.

    Valid values for `attr` are:

    - :py:obj:`~.cudaFuncAttributeMaxDynamicSharedMemorySize` - The
      requested maximum size in bytes of dynamically-allocated shared
      memory. The sum of this value and the function attribute
      :py:obj:`~.sharedSizeBytes` cannot exceed the device attribute
      :py:obj:`~.cudaDevAttrMaxSharedMemoryPerBlockOptin`. The maximal size
      of requestable dynamic shared memory may differ by GPU architecture.

    - :py:obj:`~.cudaFuncAttributePreferredSharedMemoryCarveout` - On
      devices where the L1 cache and shared memory use the same hardware
      resources, this sets the shared memory carveout preference, in
      percent of the total shared memory. See
      :py:obj:`~.cudaDevAttrMaxSharedMemoryPerMultiprocessor`. This is only
      a hint, and the driver can choose a different ratio if required to
      execute the function.

    - :py:obj:`~.cudaFuncAttributeRequiredClusterWidth`: The required
      cluster width in blocks. The width, height, and depth values must
      either all be 0 or all be positive. The validity of the cluster
      dimensions is checked at launch time. If the value is set during
      compile time, it cannot be set at runtime. Setting it at runtime will
      return cudaErrorNotPermitted.

    - :py:obj:`~.cudaFuncAttributeRequiredClusterHeight`: The required
      cluster height in blocks. The width, height, and depth values must
      either all be 0 or all be positive. The validity of the cluster
      dimensions is checked at launch time. If the value is set during
      compile time, it cannot be set at runtime. Setting it at runtime will
      return cudaErrorNotPermitted.

    - :py:obj:`~.cudaFuncAttributeRequiredClusterDepth`: The required
      cluster depth in blocks. The width, height, and depth values must
      either all be 0 or all be positive. The validity of the cluster
      dimensions is checked at launch time. If the value is set during
      compile time, it cannot be set at runtime. Setting it at runtime will
      return cudaErrorNotPermitted.

    - :py:obj:`~.cudaFuncAttributeNonPortableClusterSizeAllowed`: Indicates
      whether the function can be launched with non-portable cluster size.
      1 is allowed, 0 is disallowed.

    - :py:obj:`~.cudaFuncAttributeClusterSchedulingPolicyPreference`: The
      block scheduling policy of a function. The value type is
      cudaClusterSchedulingPolicy.

    cudaLaunchKernel (C++ API), cudaFuncSetCacheConfig (C++ API),
    :py:obj:`~.cudaFuncGetAttributes (C API)`,

    Parameters
    ----------
    func : Any
        Function to get attributes of
    attr : :py:obj:`~.cudaFuncAttribute`
        Attribute to set
    value : int
        Value to set

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDeviceFunction`, :py:obj:`~.cudaErrorInvalidValue`
    """
    cdef _HelperInputVoidPtrStruct cyfuncHelper
    cdef void* cyfunc = _helper_input_void_ptr(func, &cyfuncHelper)
    cdef cyruntime.cudaFuncAttribute cyattr = int(attr)
    with nogil:
        err = cyruntime.cudaFuncSetAttribute(cyfunc, cyattr, value)
    _helper_input_void_ptr_free(&cyfuncHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaLaunchHostFunc' in found_functions}}

ctypedef struct cudaStreamHostCallbackData_st:
    cyruntime.cudaHostFn_t callback
    void *userData

ctypedef cudaStreamHostCallbackData_st cudaStreamHostCallbackData

@cython.show_performance_hints(False)
cdef void cudaStreamRtHostCallbackWrapper(void *data) nogil:
    cdef cudaStreamHostCallbackData *cbData = <cudaStreamHostCallbackData *>data
    with gil:
        cbData.callback(cbData.userData)
    free(cbData)

@cython.embedsignature(True)
def cudaLaunchHostFunc(stream, fn, userData):
    """ Enqueues a host function call in a stream.

    Enqueues a host function to run in a stream. The function will be
    called after currently enqueued work and will block work added after
    it.

    The host function must not make any CUDA API calls. Attempting to use a
    CUDA API may result in :py:obj:`~.cudaErrorNotPermitted`, but this is
    not required. The host function must not perform any synchronization
    that may depend on outstanding CUDA work not mandated to run earlier.
    Host functions without a mandated order (such as in independent
    streams) execute in undefined order and may be serialized.

    For the purposes of Unified Memory, execution makes a number of
    guarantees:

    - The stream is considered idle for the duration of the function's
      execution. Thus, for example, the function may always use memory
      attached to the stream it was enqueued in.

    - The start of execution of the function has the same effect as
      synchronizing an event recorded in the same stream immediately prior
      to the function. It thus synchronizes streams which have been
      "joined" prior to the function.

    - Adding device work to any stream does not have the effect of making
      the stream active until all preceding host functions and stream
      callbacks have executed. Thus, for example, a function might use
      global attached memory even if work has been added to another stream,
      if the work has been ordered behind the function call with an event.

    - Completion of the function does not cause a stream to become active
      except as described above. The stream will remain idle if no device
      work follows the function, and will remain idle across consecutive
      host functions or stream callbacks without device work in between.
      Thus, for example, stream synchronization can be done by signaling
      from a host function at the end of the stream.

    Note that, in constrast to :py:obj:`~.cuStreamAddCallback`, the
    function will not be called in the event of an error in the CUDA
    context.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to enqueue function call in
    fn : :py:obj:`~.cudaHostFn_t`
        The function to call once preceding stream operations are complete
    userData : Any
        User-specified data to be passed to the function

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotSupported`

    See Also
    --------
    :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamQuery`, :py:obj:`~.cudaStreamSynchronize`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaStreamDestroy`, :py:obj:`~.cudaMallocManaged`, :py:obj:`~.cudaStreamAttachMemAsync`, :py:obj:`~.cudaStreamAddCallback`, :py:obj:`~.cuLaunchHostFunc`
    """
    cdef cyruntime.cudaHostFn_t cyfn
    if fn is None:
        pfn = 0
    elif isinstance(fn, (cudaHostFn_t,)):
        pfn = int(fn)
    else:
        pfn = int(cudaHostFn_t(fn))
    cyfn = <cyruntime.cudaHostFn_t><void_ptr>pfn
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef _HelperInputVoidPtrStruct cyuserDataHelper
    cdef void* cyuserData = _helper_input_void_ptr(userData, &cyuserDataHelper)

    cdef cudaStreamHostCallbackData *cbData = NULL
    cbData = <cudaStreamHostCallbackData *>malloc(sizeof(cbData[0]))
    if cbData == NULL:
        return (cudaError_t.cudaErrorMemoryAllocation,)
    cbData.callback = cyfn
    cbData.userData = cyuserData

    with nogil:
        err = cyruntime.cudaLaunchHostFunc(cystream, <cyruntime.cudaHostFn_t>cudaStreamRtHostCallbackWrapper, <void *>cbData)
    if err != cyruntime.cudaSuccess:
        free(cbData)
    _helper_input_void_ptr_free(&cyuserDataHelper)

    return (cudaError_t(err),)
{{endif}}

{{if 'cudaFuncSetSharedMemConfig' in found_functions}}

@cython.embedsignature(True)
def cudaFuncSetSharedMemConfig(func, config not None : cudaSharedMemConfig):
    """ Sets the shared memory configuration for a device function.

    [Deprecated]

    On devices with configurable shared memory banks, this function will
    force all subsequent launches of the specified device function to have
    the given shared memory bank size configuration. On any given launch of
    the function, the shared memory configuration of the device will be
    temporarily changed if needed to suit the function's preferred
    configuration. Changes in shared memory configuration between
    subsequent launches of functions, may introduce a device side
    synchronization point.

    Any per-function setting of shared memory bank size set via
    :py:obj:`~.cudaFuncSetSharedMemConfig` will override the device wide
    setting set by :py:obj:`~.cudaDeviceSetSharedMemConfig`.

    Changing the shared memory bank size will not increase shared memory
    usage or affect occupancy of kernels, but may have major effects on
    performance. Larger bank sizes will allow for greater potential
    bandwidth to shared memory, but will change what kinds of accesses to
    shared memory will result in bank conflicts.

    This function will do nothing on devices with fixed shared memory bank
    size.

    For templated functions, pass the function symbol as follows:
    func_name<template_arg_0,...,template_arg_N>

    The supported bank configurations are:

    - :py:obj:`~.cudaSharedMemBankSizeDefault`: use the device's shared
      memory configuration when launching this function.

    - :py:obj:`~.cudaSharedMemBankSizeFourByte`: set shared memory bank
      width to be four bytes natively when launching this function.

    - :py:obj:`~.cudaSharedMemBankSizeEightByte`: set shared memory bank
      width to be eight bytes natively when launching this function.

    Parameters
    ----------
    func : Any
        Device function symbol
    config : :py:obj:`~.cudaSharedMemConfig`
        Requested shared memory configuration

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDeviceFunction`, :py:obj:`~.cudaErrorInvalidValue`,2

    See Also
    --------
    :py:obj:`~.cudaDeviceSetSharedMemConfig`, :py:obj:`~.cudaDeviceGetSharedMemConfig`, :py:obj:`~.cudaDeviceSetCacheConfig`, :py:obj:`~.cudaDeviceGetCacheConfig`, :py:obj:`~.cudaFuncSetCacheConfig`, :py:obj:`~.cuFuncSetSharedMemConfig`
    """
    cdef _HelperInputVoidPtrStruct cyfuncHelper
    cdef void* cyfunc = _helper_input_void_ptr(func, &cyfuncHelper)
    cdef cyruntime.cudaSharedMemConfig cyconfig = int(config)
    with nogil:
        err = cyruntime.cudaFuncSetSharedMemConfig(cyfunc, cyconfig)
    _helper_input_void_ptr_free(&cyfuncHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaOccupancyMaxActiveBlocksPerMultiprocessor' in found_functions}}

@cython.embedsignature(True)
def cudaOccupancyMaxActiveBlocksPerMultiprocessor(func, int blockSize, size_t dynamicSMemSize):
    """ Returns occupancy for a device function.

    Returns in `*numBlocks` the maximum number of active blocks per
    streaming multiprocessor for the device function.

    Parameters
    ----------
    func : Any
        Kernel function for which occupancy is calculated
    blockSize : int
        Block size the kernel is intended to be launched with
    dynamicSMemSize : size_t
        Per-block dynamic shared memory usage intended, in bytes

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidDeviceFunction`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorUnknown`,
    numBlocks : int
        Returned occupancy

    See Also
    --------
    :py:obj:`~.cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags`, cudaOccupancyMaxPotentialBlockSize (C++ API), cudaOccupancyMaxPotentialBlockSizeWithFlags (C++ API), cudaOccupancyMaxPotentialBlockSizeVariableSMem (C++ API), cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags (C++ API), cudaOccupancyAvailableDynamicSMemPerBlock (C++ API), :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessor`
    """
    cdef int numBlocks = 0
    cdef _HelperInputVoidPtrStruct cyfuncHelper
    cdef void* cyfunc = _helper_input_void_ptr(func, &cyfuncHelper)
    with nogil:
        err = cyruntime.cudaOccupancyMaxActiveBlocksPerMultiprocessor(&numBlocks, cyfunc, blockSize, dynamicSMemSize)
    _helper_input_void_ptr_free(&cyfuncHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), numBlocks)
{{endif}}

{{if 'cudaOccupancyAvailableDynamicSMemPerBlock' in found_functions}}

@cython.embedsignature(True)
def cudaOccupancyAvailableDynamicSMemPerBlock(func, int numBlocks, int blockSize):
    """ Returns dynamic shared memory available per block when launching `numBlocks` blocks on SM.

    Returns in `*dynamicSmemSize` the maximum size of dynamic shared memory
    to allow `numBlocks` blocks per SM.

    Parameters
    ----------
    func : Any
        Kernel function for which occupancy is calculated
    numBlocks : int
        Number of blocks to fit on SM
    blockSize : int
        Size of the block

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidDeviceFunction`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorUnknown`,
    dynamicSmemSize : int
        Returned maximum dynamic shared memory

    See Also
    --------
    :py:obj:`~.cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags`, cudaOccupancyMaxPotentialBlockSize (C++ API), cudaOccupancyMaxPotentialBlockSizeWithFlags (C++ API), cudaOccupancyMaxPotentialBlockSizeVariableSMem (C++ API), cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags (C++ API), :py:obj:`~.cudaOccupancyAvailableDynamicSMemPerBlock`
    """
    cdef size_t dynamicSmemSize = 0
    cdef _HelperInputVoidPtrStruct cyfuncHelper
    cdef void* cyfunc = _helper_input_void_ptr(func, &cyfuncHelper)
    with nogil:
        err = cyruntime.cudaOccupancyAvailableDynamicSMemPerBlock(&dynamicSmemSize, cyfunc, numBlocks, blockSize)
    _helper_input_void_ptr_free(&cyfuncHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), dynamicSmemSize)
{{endif}}

{{if 'cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags' in found_functions}}

@cython.embedsignature(True)
def cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(func, int blockSize, size_t dynamicSMemSize, unsigned int flags):
    """ Returns occupancy for a device function with the specified flags.

    Returns in `*numBlocks` the maximum number of active blocks per
    streaming multiprocessor for the device function.

    The `flags` parameter controls how special cases are handled. Valid
    flags include:

    - :py:obj:`~.cudaOccupancyDefault`: keeps the default behavior as
      :py:obj:`~.cudaOccupancyMaxActiveBlocksPerMultiprocessor`

    - :py:obj:`~.cudaOccupancyDisableCachingOverride`: This flag suppresses
      the default behavior on platform where global caching affects
      occupancy. On such platforms, if caching is enabled, but per-block SM
      resource usage would result in zero occupancy, the occupancy
      calculator will calculate the occupancy as if caching is disabled.
      Setting this flag makes the occupancy calculator to return 0 in such
      cases. More information can be found about this feature in the
      "Unified L1/Texture Cache" section of the Maxwell tuning guide.

    Parameters
    ----------
    func : Any
        Kernel function for which occupancy is calculated
    blockSize : int
        Block size the kernel is intended to be launched with
    dynamicSMemSize : size_t
        Per-block dynamic shared memory usage intended, in bytes
    flags : unsigned int
        Requested behavior for the occupancy calculator

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidDeviceFunction`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorUnknown`,
    numBlocks : int
        Returned occupancy

    See Also
    --------
    :py:obj:`~.cudaOccupancyMaxActiveBlocksPerMultiprocessor`, cudaOccupancyMaxPotentialBlockSize (C++ API), cudaOccupancyMaxPotentialBlockSizeWithFlags (C++ API), cudaOccupancyMaxPotentialBlockSizeVariableSMem (C++ API), cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags (C++ API), cudaOccupancyAvailableDynamicSMemPerBlock (C++ API), :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags`
    """
    cdef int numBlocks = 0
    cdef _HelperInputVoidPtrStruct cyfuncHelper
    cdef void* cyfunc = _helper_input_void_ptr(func, &cyfuncHelper)
    with nogil:
        err = cyruntime.cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(&numBlocks, cyfunc, blockSize, dynamicSMemSize, flags)
    _helper_input_void_ptr_free(&cyfuncHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), numBlocks)
{{endif}}

{{if 'cudaMallocManaged' in found_functions}}

@cython.embedsignature(True)
def cudaMallocManaged(size_t size, unsigned int flags):
    """ Allocates memory that will be automatically managed by the Unified Memory system.

    Allocates `size` bytes of managed memory on the device and returns in
    `*devPtr` a pointer to the allocated memory. If the device doesn't
    support allocating managed memory, :py:obj:`~.cudaErrorNotSupported` is
    returned. Support for managed memory can be queried using the device
    attribute :py:obj:`~.cudaDevAttrManagedMemory`. The allocated memory is
    suitably aligned for any kind of variable. The memory is not cleared.
    If `size` is 0, :py:obj:`~.cudaMallocManaged` returns
    :py:obj:`~.cudaErrorInvalidValue`. The pointer is valid on the CPU and
    on all GPUs in the system that support managed memory. All accesses to
    this pointer must obey the Unified Memory programming model.

    `flags` specifies the default stream association for this allocation.
    `flags` must be one of :py:obj:`~.cudaMemAttachGlobal` or
    :py:obj:`~.cudaMemAttachHost`. The default value for `flags` is
    :py:obj:`~.cudaMemAttachGlobal`. If :py:obj:`~.cudaMemAttachGlobal` is
    specified, then this memory is accessible from any stream on any
    device. If :py:obj:`~.cudaMemAttachHost` is specified, then the
    allocation should not be accessed from devices that have a zero value
    for the device attribute
    :py:obj:`~.cudaDevAttrConcurrentManagedAccess`; an explicit call to
    :py:obj:`~.cudaStreamAttachMemAsync` will be required to enable access
    on such devices.

    If the association is later changed via
    :py:obj:`~.cudaStreamAttachMemAsync` to a single stream, the default
    association, as specifed during :py:obj:`~.cudaMallocManaged`, is
    restored when that stream is destroyed. For managed variables, the
    default association is always :py:obj:`~.cudaMemAttachGlobal`. Note
    that destroying a stream is an asynchronous operation, and as a result,
    the change to default association won't happen until all work in the
    stream has completed.

    Memory allocated with :py:obj:`~.cudaMallocManaged` should be released
    with :py:obj:`~.cudaFree`.

    Device memory oversubscription is possible for GPUs that have a non-
    zero value for the device attribute
    :py:obj:`~.cudaDevAttrConcurrentManagedAccess`. Managed memory on such
    GPUs may be evicted from device memory to host memory at any time by
    the Unified Memory driver in order to make room for other allocations.

    In a system where all GPUs have a non-zero value for the device
    attribute :py:obj:`~.cudaDevAttrConcurrentManagedAccess`, managed
    memory may not be populated when this API returns and instead may be
    populated on access. In such systems, managed memory can migrate to any
    processor's memory at any time. The Unified Memory driver will employ
    heuristics to maintain data locality and prevent excessive page faults
    to the extent possible. The application can also guide the driver about
    memory usage patterns via :py:obj:`~.cudaMemAdvise`. The application
    can also explicitly migrate memory to a desired processor's memory via
    :py:obj:`~.cudaMemPrefetchAsync`.

    In a multi-GPU system where all of the GPUs have a zero value for the
    device attribute :py:obj:`~.cudaDevAttrConcurrentManagedAccess` and all
    the GPUs have peer-to-peer support with each other, the physical
    storage for managed memory is created on the GPU which is active at the
    time :py:obj:`~.cudaMallocManaged` is called. All other GPUs will
    reference the data at reduced bandwidth via peer mappings over the PCIe
    bus. The Unified Memory driver does not migrate memory among such GPUs.

    In a multi-GPU system where not all GPUs have peer-to-peer support with
    each other and where the value of the device attribute
    :py:obj:`~.cudaDevAttrConcurrentManagedAccess` is zero for at least one
    of those GPUs, the location chosen for physical storage of managed
    memory is system-dependent.

    - On Linux, the location chosen will be device memory as long as the
      current set of active contexts are on devices that either have peer-
      to-peer support with each other or have a non-zero value for the
      device attribute :py:obj:`~.cudaDevAttrConcurrentManagedAccess`. If
      there is an active context on a GPU that does not have a non-zero
      value for that device attribute and it does not have peer-to-peer
      support with the other devices that have active contexts on them,
      then the location for physical storage will be 'zero-copy' or host
      memory. Note that this means that managed memory that is located in
      device memory is migrated to host memory if a new context is created
      on a GPU that doesn't have a non-zero value for the device attribute
      and does not support peer-to-peer with at least one of the other
      devices that has an active context. This in turn implies that context
      creation may fail if there is insufficient host memory to migrate all
      managed allocations.

    - On Windows, the physical storage is always created in 'zero-copy' or
      host memory. All GPUs will reference the data at reduced bandwidth
      over the PCIe bus. In these circumstances, use of the environment
      variable CUDA_VISIBLE_DEVICES is recommended to restrict CUDA to only
      use those GPUs that have peer-to-peer support. Alternatively, users
      can also set CUDA_MANAGED_FORCE_DEVICE_ALLOC to a non-zero value to
      force the driver to always use device memory for physical storage.
      When this environment variable is set to a non-zero value, all
      devices used in that process that support managed memory have to be
      peer-to-peer compatible with each other. The error
      :py:obj:`~.cudaErrorInvalidDevice` will be returned if a device that
      supports managed memory is used and it is not peer-to-peer compatible
      with any of the other managed memory supporting devices that were
      previously used in that process, even if :py:obj:`~.cudaDeviceReset`
      has been called on those devices. These environment variables are
      described in the CUDA programming guide under the "CUDA environment
      variables" section.

    Parameters
    ----------
    size : size_t
        Requested allocation size in bytes
    flags : unsigned int
        Must be either :py:obj:`~.cudaMemAttachGlobal` or
        :py:obj:`~.cudaMemAttachHost` (defaults to
        :py:obj:`~.cudaMemAttachGlobal`)

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorMemoryAllocation`, :py:obj:`~.cudaErrorNotSupported`, :py:obj:`~.cudaErrorInvalidValue`
    devPtr : Any
        Pointer to allocated device memory

    See Also
    --------
    :py:obj:`~.cudaMallocPitch`, :py:obj:`~.cudaFree`, :py:obj:`~.cudaMallocArray`, :py:obj:`~.cudaFreeArray`, :py:obj:`~.cudaMalloc3D`, :py:obj:`~.cudaMalloc3DArray`, :py:obj:`~.cudaMallocHost (C API)`, :py:obj:`~.cudaFreeHost`, :py:obj:`~.cudaHostAlloc`, :py:obj:`~.cudaDeviceGetAttribute`, :py:obj:`~.cudaStreamAttachMemAsync`, :py:obj:`~.cuMemAllocManaged`
    """
    cdef void_ptr devPtr = 0
    with nogil:
        err = cyruntime.cudaMallocManaged(<void**>&devPtr, size, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), devPtr)
{{endif}}

{{if 'cudaMalloc' in found_functions}}

@cython.embedsignature(True)
def cudaMalloc(size_t size):
    """ Allocate memory on the device.

    Allocates `size` bytes of linear memory on the device and returns in
    `*devPtr` a pointer to the allocated memory. The allocated memory is
    suitably aligned for any kind of variable. The memory is not cleared.
    :py:obj:`~.cudaMalloc()` returns :py:obj:`~.cudaErrorMemoryAllocation`
    in case of failure.

    The device version of :py:obj:`~.cudaFree` cannot be used with a
    `*devPtr` allocated using the host API, and vice versa.

    Parameters
    ----------
    size : size_t
        Requested allocation size in bytes

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorMemoryAllocation`
    devPtr : Any
        Pointer to allocated device memory

    See Also
    --------
    :py:obj:`~.cudaMallocPitch`, :py:obj:`~.cudaFree`, :py:obj:`~.cudaMallocArray`, :py:obj:`~.cudaFreeArray`, :py:obj:`~.cudaMalloc3D`, :py:obj:`~.cudaMalloc3DArray`, :py:obj:`~.cudaMallocHost (C API)`, :py:obj:`~.cudaFreeHost`, :py:obj:`~.cudaHostAlloc`, :py:obj:`~.cuMemAlloc`
    """
    cdef void_ptr devPtr = 0
    with nogil:
        err = cyruntime.cudaMalloc(<void**>&devPtr, size)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), devPtr)
{{endif}}

{{if 'cudaMallocHost' in found_functions}}

@cython.embedsignature(True)
def cudaMallocHost(size_t size):
    """ Allocates page-locked memory on the host.

    Allocates `size` bytes of host memory that is page-locked and
    accessible to the device. The driver tracks the virtual memory ranges
    allocated with this function and automatically accelerates calls to
    functions such as :py:obj:`~.cudaMemcpy`*(). Since the memory can be
    accessed directly by the device, it can be read or written with much
    higher bandwidth than pageable memory obtained with functions such as
    :py:obj:`~.malloc()`.

    On systems where :py:obj:`~.pageableMemoryAccessUsesHostPageTables` is
    true, :py:obj:`~.cudaMallocHost` may not page-lock the allocated
    memory.

    Page-locking excessive amounts of memory with
    :py:obj:`~.cudaMallocHost()` may degrade system performance, since it
    reduces the amount of memory available to the system for paging. As a
    result, this function is best used sparingly to allocate staging areas
    for data exchange between host and device.

    Parameters
    ----------
    size : size_t
        Requested allocation size in bytes

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorMemoryAllocation`
    ptr : Any
        Pointer to allocated host memory

    See Also
    --------
    :py:obj:`~.cudaMalloc`, :py:obj:`~.cudaMallocPitch`, :py:obj:`~.cudaMallocArray`, :py:obj:`~.cudaMalloc3D`, :py:obj:`~.cudaMalloc3DArray`, :py:obj:`~.cudaHostAlloc`, :py:obj:`~.cudaFree`, :py:obj:`~.cudaFreeArray`, cudaMallocHost (C++ API), :py:obj:`~.cudaFreeHost`, :py:obj:`~.cudaHostAlloc`, :py:obj:`~.cuMemAllocHost`
    """
    cdef void_ptr ptr = 0
    with nogil:
        err = cyruntime.cudaMallocHost(<void**>&ptr, size)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), ptr)
{{endif}}

{{if 'cudaMallocPitch' in found_functions}}

@cython.embedsignature(True)
def cudaMallocPitch(size_t width, size_t height):
    """ Allocates pitched memory on the device.

    Allocates at least `width` (in bytes) * `height` bytes of linear memory
    on the device and returns in `*devPtr` a pointer to the allocated
    memory. The function may pad the allocation to ensure that
    corresponding pointers in any given row will continue to meet the
    alignment requirements for coalescing as the address is updated from
    row to row. The pitch returned in `*pitch` by
    :py:obj:`~.cudaMallocPitch()` is the width in bytes of the allocation.
    The intended usage of `pitch` is as a separate parameter of the
    allocation, used to compute addresses within the 2D array. Given the
    row and column of an array element of type `T`, the address is computed
    as:

    **View CUDA Toolkit Documentation for a C++ code example**

    For allocations of 2D arrays, it is recommended that programmers
    consider performing pitch allocations using
    :py:obj:`~.cudaMallocPitch()`. Due to pitch alignment restrictions in
    the hardware, this is especially true if the application will be
    performing 2D memory copies between different regions of device memory
    (whether linear memory or CUDA arrays).

    Parameters
    ----------
    width : size_t
        Requested pitched allocation width (in bytes)
    height : size_t
        Requested pitched allocation height

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorMemoryAllocation`
    devPtr : Any
        Pointer to allocated pitched device memory
    pitch : int
        Pitch for allocation

    See Also
    --------
    :py:obj:`~.cudaMalloc`, :py:obj:`~.cudaFree`, :py:obj:`~.cudaMallocArray`, :py:obj:`~.cudaFreeArray`, :py:obj:`~.cudaMallocHost (C API)`, :py:obj:`~.cudaFreeHost`, :py:obj:`~.cudaMalloc3D`, :py:obj:`~.cudaMalloc3DArray`, :py:obj:`~.cudaHostAlloc`, :py:obj:`~.cuMemAllocPitch`
    """
    cdef void_ptr devPtr = 0
    cdef size_t pitch = 0
    with nogil:
        err = cyruntime.cudaMallocPitch(<void**>&devPtr, &pitch, width, height)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None)
    return (cudaError_t(err), devPtr, pitch)
{{endif}}

{{if 'cudaMallocArray' in found_functions}}

@cython.embedsignature(True)
def cudaMallocArray(desc : Optional[cudaChannelFormatDesc], size_t width, size_t height, unsigned int flags):
    """ Allocate an array on the device.

    Allocates a CUDA array according to the
    :py:obj:`~.cudaChannelFormatDesc` structure `desc` and returns a handle
    to the new CUDA array in `*array`.

    The :py:obj:`~.cudaChannelFormatDesc` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.cudaChannelFormatKind` is one of
    :py:obj:`~.cudaChannelFormatKindSigned`,
    :py:obj:`~.cudaChannelFormatKindUnsigned`, or
    :py:obj:`~.cudaChannelFormatKindFloat`.

    The `flags` parameter enables different options to be specified that
    affect the allocation, as follows.

    - :py:obj:`~.cudaArrayDefault`: This flag's value is defined to be 0
      and provides default array allocation

    - :py:obj:`~.cudaArraySurfaceLoadStore`: Allocates an array that can be
      read from or written to using a surface reference

    - :py:obj:`~.cudaArrayTextureGather`: This flag indicates that texture
      gather operations will be performed on the array.

    - :py:obj:`~.cudaArraySparse`: Allocates a CUDA array without physical
      backing memory. The subregions within this sparse array can later be
      mapped onto a physical memory allocation by calling
      :py:obj:`~.cuMemMapArrayAsync`. The physical backing memory must be
      allocated via :py:obj:`~.cuMemCreate`.

    - :py:obj:`~.cudaArrayDeferredMapping`: Allocates a CUDA array without
      physical backing memory. The entire array can later be mapped onto a
      physical memory allocation by calling :py:obj:`~.cuMemMapArrayAsync`.
      The physical backing memory must be allocated via
      :py:obj:`~.cuMemCreate`.

    `width` and `height` must meet certain size requirements. See
    :py:obj:`~.cudaMalloc3DArray()` for more details.

    Parameters
    ----------
    desc : :py:obj:`~.cudaChannelFormatDesc`
        Requested channel format
    width : size_t
        Requested array allocation width
    height : size_t
        Requested array allocation height
    flags : unsigned int
        Requested properties of allocated array

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorMemoryAllocation`
    array : :py:obj:`~.cudaArray_t`
        Pointer to allocated array in device memory

    See Also
    --------
    :py:obj:`~.cudaMalloc`, :py:obj:`~.cudaMallocPitch`, :py:obj:`~.cudaFree`, :py:obj:`~.cudaFreeArray`, :py:obj:`~.cudaMallocHost (C API)`, :py:obj:`~.cudaFreeHost`, :py:obj:`~.cudaMalloc3D`, :py:obj:`~.cudaMalloc3DArray`, :py:obj:`~.cudaHostAlloc`, :py:obj:`~.cuArrayCreate`
    """
    cdef cudaArray_t array = cudaArray_t()
    cdef cyruntime.cudaChannelFormatDesc* cydesc_ptr = desc._pvt_ptr if desc is not None else NULL
    with nogil:
        err = cyruntime.cudaMallocArray(<cyruntime.cudaArray_t*>array._pvt_ptr, cydesc_ptr, width, height, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), array)
{{endif}}

{{if 'cudaFree' in found_functions}}

@cython.embedsignature(True)
def cudaFree(devPtr):
    """ Frees memory on the device.

    Frees the memory space pointed to by `devPtr`, which must have been
    returned by a previous call to one of the following memory allocation
    APIs - :py:obj:`~.cudaMalloc()`, :py:obj:`~.cudaMallocPitch()`,
    :py:obj:`~.cudaMallocManaged()`, :py:obj:`~.cudaMallocAsync()`,
    :py:obj:`~.cudaMallocFromPoolAsync()`.

    Note - This API will not perform any implicit synchronization when the
    pointer was allocated with :py:obj:`~.cudaMallocAsync` or
    :py:obj:`~.cudaMallocFromPoolAsync`. Callers must ensure that all
    accesses to these pointer have completed before invoking
    :py:obj:`~.cudaFree`. For best performance and memory reuse, users
    should use :py:obj:`~.cudaFreeAsync` to free memory allocated via the
    stream ordered memory allocator. For all other pointers, this API may
    perform implicit synchronization.

    If :py:obj:`~.cudaFree`(`devPtr`) has already been called before, an
    error is returned. If `devPtr` is 0, no operation is performed.
    :py:obj:`~.cudaFree()` returns :py:obj:`~.cudaErrorValue` in case of
    failure.

    The device version of :py:obj:`~.cudaFree` cannot be used with a
    `*devPtr` allocated using the host API, and vice versa.

    Parameters
    ----------
    devPtr : Any
        Device pointer to memory to free

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaMalloc`, :py:obj:`~.cudaMallocPitch`, :py:obj:`~.cudaMallocManaged`, :py:obj:`~.cudaMallocArray`, :py:obj:`~.cudaFreeArray`, :py:obj:`~.cudaMallocAsync`, :py:obj:`~.cudaMallocFromPoolAsync` :py:obj:`~.cudaMallocHost (C API)`, :py:obj:`~.cudaFreeHost`, :py:obj:`~.cudaMalloc3D`, :py:obj:`~.cudaMalloc3DArray`, :py:obj:`~.cudaFreeAsync` :py:obj:`~.cudaHostAlloc`, :py:obj:`~.cuMemFree`
    """
    cdef _HelperInputVoidPtrStruct cydevPtrHelper
    cdef void* cydevPtr = _helper_input_void_ptr(devPtr, &cydevPtrHelper)
    with nogil:
        err = cyruntime.cudaFree(cydevPtr)
    _helper_input_void_ptr_free(&cydevPtrHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaFreeHost' in found_functions}}

@cython.embedsignature(True)
def cudaFreeHost(ptr):
    """ Frees page-locked memory.

    Frees the memory space pointed to by `hostPtr`, which must have been
    returned by a previous call to :py:obj:`~.cudaMallocHost()` or
    :py:obj:`~.cudaHostAlloc()`.

    Parameters
    ----------
    ptr : Any
        Pointer to memory to free

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaMalloc`, :py:obj:`~.cudaMallocPitch`, :py:obj:`~.cudaFree`, :py:obj:`~.cudaMallocArray`, :py:obj:`~.cudaFreeArray`, :py:obj:`~.cudaMallocHost (C API)`, :py:obj:`~.cudaMalloc3D`, :py:obj:`~.cudaMalloc3DArray`, :py:obj:`~.cudaHostAlloc`, :py:obj:`~.cuMemFreeHost`
    """
    cdef _HelperInputVoidPtrStruct cyptrHelper
    cdef void* cyptr = _helper_input_void_ptr(ptr, &cyptrHelper)
    with nogil:
        err = cyruntime.cudaFreeHost(cyptr)
    _helper_input_void_ptr_free(&cyptrHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaFreeArray' in found_functions}}

@cython.embedsignature(True)
def cudaFreeArray(array):
    """ Frees an array on the device.

    Frees the CUDA array `array`, which must have been returned by a
    previous call to :py:obj:`~.cudaMallocArray()`. If `devPtr` is 0, no
    operation is performed.

    Parameters
    ----------
    array : :py:obj:`~.cudaArray_t`
        Pointer to array to free

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaMalloc`, :py:obj:`~.cudaMallocPitch`, :py:obj:`~.cudaFree`, :py:obj:`~.cudaMallocArray`, :py:obj:`~.cudaMallocHost (C API)`, :py:obj:`~.cudaFreeHost`, :py:obj:`~.cudaHostAlloc`, :py:obj:`~.cuArrayDestroy`
    """
    cdef cyruntime.cudaArray_t cyarray
    if array is None:
        parray = 0
    elif isinstance(array, (cudaArray_t,)):
        parray = int(array)
    else:
        parray = int(cudaArray_t(array))
    cyarray = <cyruntime.cudaArray_t><void_ptr>parray
    with nogil:
        err = cyruntime.cudaFreeArray(cyarray)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaFreeMipmappedArray' in found_functions}}

@cython.embedsignature(True)
def cudaFreeMipmappedArray(mipmappedArray):
    """ Frees a mipmapped array on the device.

    Frees the CUDA mipmapped array `mipmappedArray`, which must have been
    returned by a previous call to :py:obj:`~.cudaMallocMipmappedArray()`.
    If `devPtr` is 0, no operation is performed.

    Parameters
    ----------
    mipmappedArray : :py:obj:`~.cudaMipmappedArray_t`
        Pointer to mipmapped array to free

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaMalloc`, :py:obj:`~.cudaMallocPitch`, :py:obj:`~.cudaFree`, :py:obj:`~.cudaMallocArray`, :py:obj:`~.cudaMallocHost (C API)`, :py:obj:`~.cudaFreeHost`, :py:obj:`~.cudaHostAlloc`, :py:obj:`~.cuMipmappedArrayDestroy`
    """
    cdef cyruntime.cudaMipmappedArray_t cymipmappedArray
    if mipmappedArray is None:
        pmipmappedArray = 0
    elif isinstance(mipmappedArray, (cudaMipmappedArray_t,)):
        pmipmappedArray = int(mipmappedArray)
    else:
        pmipmappedArray = int(cudaMipmappedArray_t(mipmappedArray))
    cymipmappedArray = <cyruntime.cudaMipmappedArray_t><void_ptr>pmipmappedArray
    with nogil:
        err = cyruntime.cudaFreeMipmappedArray(cymipmappedArray)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaHostAlloc' in found_functions}}

@cython.embedsignature(True)
def cudaHostAlloc(size_t size, unsigned int flags):
    """ Allocates page-locked memory on the host.

    Allocates `size` bytes of host memory that is page-locked and
    accessible to the device. The driver tracks the virtual memory ranges
    allocated with this function and automatically accelerates calls to
    functions such as :py:obj:`~.cudaMemcpy()`. Since the memory can be
    accessed directly by the device, it can be read or written with much
    higher bandwidth than pageable memory obtained with functions such as
    :py:obj:`~.malloc()`. Allocating excessive amounts of pinned memory may
    degrade system performance, since it reduces the amount of memory
    available to the system for paging. As a result, this function is best
    used sparingly to allocate staging areas for data exchange between host
    and device.

    The `flags` parameter enables different options to be specified that
    affect the allocation, as follows.

    - :py:obj:`~.cudaHostAllocDefault`: This flag's value is defined to be
      0 and causes :py:obj:`~.cudaHostAlloc()` to emulate
      :py:obj:`~.cudaMallocHost()`.

    - :py:obj:`~.cudaHostAllocPortable`: The memory returned by this call
      will be considered as pinned memory by all CUDA contexts, not just
      the one that performed the allocation.

    - :py:obj:`~.cudaHostAllocMapped`: Maps the allocation into the CUDA
      address space. The device pointer to the memory may be obtained by
      calling :py:obj:`~.cudaHostGetDevicePointer()`.

    - :py:obj:`~.cudaHostAllocWriteCombined`: Allocates the memory as
      write-combined (WC). WC memory can be transferred across the PCI
      Express bus more quickly on some system configurations, but cannot be
      read efficiently by most CPUs. WC memory is a good option for buffers
      that will be written by the CPU and read by the device via mapped
      pinned memory or host->device transfers.

    All of these flags are orthogonal to one another: a developer may
    allocate memory that is portable, mapped and/or write-combined with no
    restrictions.

    In order for the :py:obj:`~.cudaHostAllocMapped` flag to have any
    effect, the CUDA context must support the :py:obj:`~.cudaDeviceMapHost`
    flag, which can be checked via :py:obj:`~.cudaGetDeviceFlags()`. The
    :py:obj:`~.cudaDeviceMapHost` flag is implicitly set for contexts
    created via the runtime API.

    The :py:obj:`~.cudaHostAllocMapped` flag may be specified on CUDA
    contexts for devices that do not support mapped pinned memory. The
    failure is deferred to :py:obj:`~.cudaHostGetDevicePointer()` because
    the memory may be mapped into other CUDA contexts via the
    :py:obj:`~.cudaHostAllocPortable` flag.

    Memory allocated by this function must be freed with
    :py:obj:`~.cudaFreeHost()`.

    Parameters
    ----------
    size : size_t
        Requested allocation size in bytes
    flags : unsigned int
        Requested properties of allocated memory

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorMemoryAllocation`
    pHost : Any
        Device pointer to allocated memory

    See Also
    --------
    :py:obj:`~.cudaSetDeviceFlags`, :py:obj:`~.cudaMallocHost (C API)`, :py:obj:`~.cudaFreeHost`, :py:obj:`~.cudaGetDeviceFlags`, :py:obj:`~.cuMemHostAlloc`
    """
    cdef void_ptr pHost = 0
    with nogil:
        err = cyruntime.cudaHostAlloc(<void**>&pHost, size, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pHost)
{{endif}}

{{if 'cudaHostRegister' in found_functions}}

@cython.embedsignature(True)
def cudaHostRegister(ptr, size_t size, unsigned int flags):
    """ Registers an existing host memory range for use by CUDA.

    Page-locks the memory range specified by `ptr` and `size` and maps it
    for the device(s) as specified by `flags`. This memory range also is
    added to the same tracking mechanism as :py:obj:`~.cudaHostAlloc()` to
    automatically accelerate calls to functions such as
    :py:obj:`~.cudaMemcpy()`. Since the memory can be accessed directly by
    the device, it can be read or written with much higher bandwidth than
    pageable memory that has not been registered. Page-locking excessive
    amounts of memory may degrade system performance, since it reduces the
    amount of memory available to the system for paging. As a result, this
    function is best used sparingly to register staging areas for data
    exchange between host and device.

    On systems where :py:obj:`~.pageableMemoryAccessUsesHostPageTables` is
    true, :py:obj:`~.cudaHostRegister` will not page-lock the memory range
    specified by `ptr` but only populate unpopulated pages.

    :py:obj:`~.cudaHostRegister` is supported only on I/O coherent devices
    that have a non-zero value for the device attribute
    :py:obj:`~.cudaDevAttrHostRegisterSupported`.

    The `flags` parameter enables different options to be specified that
    affect the allocation, as follows.

    - :py:obj:`~.cudaHostRegisterDefault`: On a system with unified virtual
      addressing, the memory will be both mapped and portable. On a system
      with no unified virtual addressing, the memory will be neither mapped
      nor portable.

    - :py:obj:`~.cudaHostRegisterPortable`: The memory returned by this
      call will be considered as pinned memory by all CUDA contexts, not
      just the one that performed the allocation.

    - :py:obj:`~.cudaHostRegisterMapped`: Maps the allocation into the CUDA
      address space. The device pointer to the memory may be obtained by
      calling :py:obj:`~.cudaHostGetDevicePointer()`.

    - :py:obj:`~.cudaHostRegisterIoMemory`: The passed memory pointer is
      treated as pointing to some memory-mapped I/O space, e.g. belonging
      to a third-party PCIe device, and it will marked as non cache-
      coherent and contiguous.

    - :py:obj:`~.cudaHostRegisterReadOnly`: The passed memory pointer is
      treated as pointing to memory that is considered read-only by the
      device. On platforms without
      :py:obj:`~.cudaDevAttrPageableMemoryAccessUsesHostPageTables`, this
      flag is required in order to register memory mapped to the CPU as
      read-only. Support for the use of this flag can be queried from the
      device attribute
      :py:obj:`~.cudaDevAttrHostRegisterReadOnlySupported`. Using this flag
      with a current context associated with a device that does not have
      this attribute set will cause :py:obj:`~.cudaHostRegister` to error
      with cudaErrorNotSupported.

    All of these flags are orthogonal to one another: a developer may page-
    lock memory that is portable or mapped with no restrictions.

    The CUDA context must have been created with the
    :py:obj:`~.cudaMapHost` flag in order for the
    :py:obj:`~.cudaHostRegisterMapped` flag to have any effect.

    The :py:obj:`~.cudaHostRegisterMapped` flag may be specified on CUDA
    contexts for devices that do not support mapped pinned memory. The
    failure is deferred to :py:obj:`~.cudaHostGetDevicePointer()` because
    the memory may be mapped into other CUDA contexts via the
    :py:obj:`~.cudaHostRegisterPortable` flag.

    For devices that have a non-zero value for the device attribute
    :py:obj:`~.cudaDevAttrCanUseHostPointerForRegisteredMem`, the memory
    can also be accessed from the device using the host pointer `ptr`. The
    device pointer returned by :py:obj:`~.cudaHostGetDevicePointer()` may
    or may not match the original host pointer `ptr` and depends on the
    devices visible to the application. If all devices visible to the
    application have a non-zero value for the device attribute, the device
    pointer returned by :py:obj:`~.cudaHostGetDevicePointer()` will match
    the original pointer `ptr`. If any device visible to the application
    has a zero value for the device attribute, the device pointer returned
    by :py:obj:`~.cudaHostGetDevicePointer()` will not match the original
    host pointer `ptr`, but it will be suitable for use on all devices
    provided Unified Virtual Addressing is enabled. In such systems, it is
    valid to access the memory using either pointer on devices that have a
    non-zero value for the device attribute. Note however that such devices
    should access the memory using only of the two pointers and not both.

    The memory page-locked by this function must be unregistered with
    :py:obj:`~.cudaHostUnregister()`.

    Parameters
    ----------
    ptr : Any
        Host pointer to memory to page-lock
    size : size_t
        Size in bytes of the address range to page-lock in bytes
    flags : unsigned int
        Flags for allocation request

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorMemoryAllocation`, :py:obj:`~.cudaErrorHostMemoryAlreadyRegistered`, :py:obj:`~.cudaErrorNotSupported`

    See Also
    --------
    :py:obj:`~.cudaHostUnregister`, :py:obj:`~.cudaHostGetFlags`, :py:obj:`~.cudaHostGetDevicePointer`, :py:obj:`~.cuMemHostRegister`
    """
    cdef _HelperInputVoidPtrStruct cyptrHelper
    cdef void* cyptr = _helper_input_void_ptr(ptr, &cyptrHelper)
    with nogil:
        err = cyruntime.cudaHostRegister(cyptr, size, flags)
    _helper_input_void_ptr_free(&cyptrHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaHostUnregister' in found_functions}}

@cython.embedsignature(True)
def cudaHostUnregister(ptr):
    """ Unregisters a memory range that was registered with cudaHostRegister.

    Unmaps the memory range whose base address is specified by `ptr`, and
    makes it pageable again.

    The base address must be the same one specified to
    :py:obj:`~.cudaHostRegister()`.

    Parameters
    ----------
    ptr : Any
        Host pointer to memory to unregister

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorHostMemoryNotRegistered`

    See Also
    --------
    :py:obj:`~.cudaHostUnregister`, :py:obj:`~.cuMemHostUnregister`
    """
    cdef _HelperInputVoidPtrStruct cyptrHelper
    cdef void* cyptr = _helper_input_void_ptr(ptr, &cyptrHelper)
    with nogil:
        err = cyruntime.cudaHostUnregister(cyptr)
    _helper_input_void_ptr_free(&cyptrHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaHostGetDevicePointer' in found_functions}}

@cython.embedsignature(True)
def cudaHostGetDevicePointer(pHost, unsigned int flags):
    """ Passes back device pointer of mapped host memory allocated by cudaHostAlloc or registered by cudaHostRegister.

    Passes back the device pointer corresponding to the mapped, pinned host
    buffer allocated by :py:obj:`~.cudaHostAlloc()` or registered by
    :py:obj:`~.cudaHostRegister()`.

    :py:obj:`~.cudaHostGetDevicePointer()` will fail if the
    :py:obj:`~.cudaDeviceMapHost` flag was not specified before deferred
    context creation occurred, or if called on a device that does not
    support mapped, pinned memory.

    For devices that have a non-zero value for the device attribute
    :py:obj:`~.cudaDevAttrCanUseHostPointerForRegisteredMem`, the memory
    can also be accessed from the device using the host pointer `pHost`.
    The device pointer returned by :py:obj:`~.cudaHostGetDevicePointer()`
    may or may not match the original host pointer `pHost` and depends on
    the devices visible to the application. If all devices visible to the
    application have a non-zero value for the device attribute, the device
    pointer returned by :py:obj:`~.cudaHostGetDevicePointer()` will match
    the original pointer `pHost`. If any device visible to the application
    has a zero value for the device attribute, the device pointer returned
    by :py:obj:`~.cudaHostGetDevicePointer()` will not match the original
    host pointer `pHost`, but it will be suitable for use on all devices
    provided Unified Virtual Addressing is enabled. In such systems, it is
    valid to access the memory using either pointer on devices that have a
    non-zero value for the device attribute. Note however that such devices
    should access the memory using only of the two pointers and not both.

    `flags` provides for future releases. For now, it must be set to 0.

    Parameters
    ----------
    pHost : Any
        Requested host pointer mapping
    flags : unsigned int
        Flags for extensions (must be 0 for now)

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorMemoryAllocation`
    pDevice : Any
        Returned device pointer for mapped memory

    See Also
    --------
    :py:obj:`~.cudaSetDeviceFlags`, :py:obj:`~.cudaHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`
    """
    cdef void_ptr pDevice = 0
    cdef _HelperInputVoidPtrStruct cypHostHelper
    cdef void* cypHost = _helper_input_void_ptr(pHost, &cypHostHelper)
    with nogil:
        err = cyruntime.cudaHostGetDevicePointer(<void**>&pDevice, cypHost, flags)
    _helper_input_void_ptr_free(&cypHostHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pDevice)
{{endif}}

{{if 'cudaHostGetFlags' in found_functions}}

@cython.embedsignature(True)
def cudaHostGetFlags(pHost):
    """ Passes back flags used to allocate pinned host memory allocated by cudaHostAlloc.

    :py:obj:`~.cudaHostGetFlags()` will fail if the input pointer does not
    reside in an address range allocated by :py:obj:`~.cudaHostAlloc()`.

    Parameters
    ----------
    pHost : Any
        Host pointer

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pFlags : unsigned int
        Returned flags word

    See Also
    --------
    :py:obj:`~.cudaHostAlloc`, :py:obj:`~.cuMemHostGetFlags`
    """
    cdef unsigned int pFlags = 0
    cdef _HelperInputVoidPtrStruct cypHostHelper
    cdef void* cypHost = _helper_input_void_ptr(pHost, &cypHostHelper)
    with nogil:
        err = cyruntime.cudaHostGetFlags(&pFlags, cypHost)
    _helper_input_void_ptr_free(&cypHostHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pFlags)
{{endif}}

{{if 'cudaMalloc3D' in found_functions}}

@cython.embedsignature(True)
def cudaMalloc3D(extent not None : cudaExtent):
    """ Allocates logical 1D, 2D, or 3D memory objects on the device.

    Allocates at least `width` * `height` * `depth` bytes of linear memory
    on the device and returns a :py:obj:`~.cudaPitchedPtr` in which `ptr`
    is a pointer to the allocated memory. The function may pad the
    allocation to ensure hardware alignment requirements are met. The pitch
    returned in the `pitch` field of `pitchedDevPtr` is the width in bytes
    of the allocation.

    The returned :py:obj:`~.cudaPitchedPtr` contains additional fields
    `xsize` and `ysize`, the logical width and height of the allocation,
    which are equivalent to the `width` and `height` `extent` parameters
    provided by the programmer during allocation.

    For allocations of 2D and 3D objects, it is highly recommended that
    programmers perform allocations using :py:obj:`~.cudaMalloc3D()` or
    :py:obj:`~.cudaMallocPitch()`. Due to alignment restrictions in the
    hardware, this is especially true if the application will be performing
    memory copies involving 2D or 3D objects (whether linear memory or CUDA
    arrays).

    Parameters
    ----------
    extent : :py:obj:`~.cudaExtent`
        Requested allocation size (`width` field in bytes)

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorMemoryAllocation`
    pitchedDevPtr : :py:obj:`~.cudaPitchedPtr`
        Pointer to allocated pitched device memory

    See Also
    --------
    :py:obj:`~.cudaMallocPitch`, :py:obj:`~.cudaFree`, :py:obj:`~.cudaMemcpy3D`, :py:obj:`~.cudaMemset3D`, :py:obj:`~.cudaMalloc3DArray`, :py:obj:`~.cudaMallocArray`, :py:obj:`~.cudaFreeArray`, :py:obj:`~.cudaMallocHost (C API)`, :py:obj:`~.cudaFreeHost`, :py:obj:`~.cudaHostAlloc`, :py:obj:`~.make_cudaPitchedPtr`, :py:obj:`~.make_cudaExtent`, :py:obj:`~.cuMemAllocPitch`
    """
    cdef cudaPitchedPtr pitchedDevPtr = cudaPitchedPtr()
    with nogil:
        err = cyruntime.cudaMalloc3D(<cyruntime.cudaPitchedPtr*>pitchedDevPtr._pvt_ptr, extent._pvt_ptr[0])
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pitchedDevPtr)
{{endif}}

{{if 'cudaMalloc3DArray' in found_functions}}

@cython.embedsignature(True)
def cudaMalloc3DArray(desc : Optional[cudaChannelFormatDesc], extent not None : cudaExtent, unsigned int flags):
    """ Allocate an array on the device.

    Allocates a CUDA array according to the
    :py:obj:`~.cudaChannelFormatDesc` structure `desc` and returns a handle
    to the new CUDA array in `*array`.

    The :py:obj:`~.cudaChannelFormatDesc` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.cudaChannelFormatKind` is one of
    :py:obj:`~.cudaChannelFormatKindSigned`,
    :py:obj:`~.cudaChannelFormatKindUnsigned`, or
    :py:obj:`~.cudaChannelFormatKindFloat`.

    :py:obj:`~.cudaMalloc3DArray()` can allocate the following:

    - A 1D array is allocated if the height and depth extents are both
      zero.

    - A 2D array is allocated if only the depth extent is zero.

    - A 3D array is allocated if all three extents are non-zero.

    - A 1D layered CUDA array is allocated if only the height extent is
      zero and the cudaArrayLayered flag is set. Each layer is a 1D array.
      The number of layers is determined by the depth extent.

    - A 2D layered CUDA array is allocated if all three extents are non-
      zero and the cudaArrayLayered flag is set. Each layer is a 2D array.
      The number of layers is determined by the depth extent.

    - A cubemap CUDA array is allocated if all three extents are non-zero
      and the cudaArrayCubemap flag is set. Width must be equal to height,
      and depth must be six. A cubemap is a special type of 2D layered CUDA
      array, where the six layers represent the six faces of a cube. The
      order of the six layers in memory is the same as that listed in
      :py:obj:`~.cudaGraphicsCubeFace`.

    - A cubemap layered CUDA array is allocated if all three extents are
      non-zero, and both, cudaArrayCubemap and cudaArrayLayered flags are
      set. Width must be equal to height, and depth must be a multiple of
      six. A cubemap layered CUDA array is a special type of 2D layered
      CUDA array that consists of a collection of cubemaps. The first six
      layers represent the first cubemap, the next six layers form the
      second cubemap, and so on.

    The `flags` parameter enables different options to be specified that
    affect the allocation, as follows.

    - :py:obj:`~.cudaArrayDefault`: This flag's value is defined to be 0
      and provides default array allocation

    - :py:obj:`~.cudaArrayLayered`: Allocates a layered CUDA array, with
      the depth extent indicating the number of layers

    - :py:obj:`~.cudaArrayCubemap`: Allocates a cubemap CUDA array. Width
      must be equal to height, and depth must be six. If the
      cudaArrayLayered flag is also set, depth must be a multiple of six.

    - :py:obj:`~.cudaArraySurfaceLoadStore`: Allocates a CUDA array that
      could be read from or written to using a surface reference.

    - :py:obj:`~.cudaArrayTextureGather`: This flag indicates that texture
      gather operations will be performed on the CUDA array. Texture gather
      can only be performed on 2D CUDA arrays.

    - :py:obj:`~.cudaArraySparse`: Allocates a CUDA array without physical
      backing memory. The subregions within this sparse array can later be
      mapped onto a physical memory allocation by calling
      :py:obj:`~.cuMemMapArrayAsync`. This flag can only be used for
      creating 2D, 3D or 2D layered sparse CUDA arrays. The physical
      backing memory must be allocated via :py:obj:`~.cuMemCreate`.

    - :py:obj:`~.cudaArrayDeferredMapping`: Allocates a CUDA array without
      physical backing memory. The entire array can later be mapped onto a
      physical memory allocation by calling :py:obj:`~.cuMemMapArrayAsync`.
      The physical backing memory must be allocated via
      :py:obj:`~.cuMemCreate`.

    The width, height and depth extents must meet certain size requirements
    as listed in the following table. All values are specified in elements.

    Note that 2D CUDA arrays have different size requirements if the
    :py:obj:`~.cudaArrayTextureGather` flag is set. In that case, the valid
    range for (width, height, depth) is ((1,maxTexture2DGather[0]),
    (1,maxTexture2DGather[1]), 0).

    **View CUDA Toolkit Documentation for a table example**

    Parameters
    ----------
    desc : :py:obj:`~.cudaChannelFormatDesc`
        Requested channel format
    extent : :py:obj:`~.cudaExtent`
        Requested allocation size (`width` field in elements)
    flags : unsigned int
        Flags for extensions

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorMemoryAllocation`
    array : :py:obj:`~.cudaArray_t`
        Pointer to allocated array in device memory

    See Also
    --------
    :py:obj:`~.cudaMalloc3D`, :py:obj:`~.cudaMalloc`, :py:obj:`~.cudaMallocPitch`, :py:obj:`~.cudaFree`, :py:obj:`~.cudaFreeArray`, :py:obj:`~.cudaMallocHost (C API)`, :py:obj:`~.cudaFreeHost`, :py:obj:`~.cudaHostAlloc`, :py:obj:`~.make_cudaExtent`, :py:obj:`~.cuArray3DCreate`
    """
    cdef cudaArray_t array = cudaArray_t()
    cdef cyruntime.cudaChannelFormatDesc* cydesc_ptr = desc._pvt_ptr if desc is not None else NULL
    with nogil:
        err = cyruntime.cudaMalloc3DArray(<cyruntime.cudaArray_t*>array._pvt_ptr, cydesc_ptr, extent._pvt_ptr[0], flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), array)
{{endif}}

{{if 'cudaMallocMipmappedArray' in found_functions}}

@cython.embedsignature(True)
def cudaMallocMipmappedArray(desc : Optional[cudaChannelFormatDesc], extent not None : cudaExtent, unsigned int numLevels, unsigned int flags):
    """ Allocate a mipmapped array on the device.

    Allocates a CUDA mipmapped array according to the
    :py:obj:`~.cudaChannelFormatDesc` structure `desc` and returns a handle
    to the new CUDA mipmapped array in `*mipmappedArray`. `numLevels`
    specifies the number of mipmap levels to be allocated. This value is
    clamped to the range [1, 1 + floor(log2(max(width, height, depth)))].

    The :py:obj:`~.cudaChannelFormatDesc` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.cudaChannelFormatKind` is one of
    :py:obj:`~.cudaChannelFormatKindSigned`,
    :py:obj:`~.cudaChannelFormatKindUnsigned`, or
    :py:obj:`~.cudaChannelFormatKindFloat`.

    :py:obj:`~.cudaMallocMipmappedArray()` can allocate the following:

    - A 1D mipmapped array is allocated if the height and depth extents are
      both zero.

    - A 2D mipmapped array is allocated if only the depth extent is zero.

    - A 3D mipmapped array is allocated if all three extents are non-zero.

    - A 1D layered CUDA mipmapped array is allocated if only the height
      extent is zero and the cudaArrayLayered flag is set. Each layer is a
      1D mipmapped array. The number of layers is determined by the depth
      extent.

    - A 2D layered CUDA mipmapped array is allocated if all three extents
      are non-zero and the cudaArrayLayered flag is set. Each layer is a 2D
      mipmapped array. The number of layers is determined by the depth
      extent.

    - A cubemap CUDA mipmapped array is allocated if all three extents are
      non-zero and the cudaArrayCubemap flag is set. Width must be equal to
      height, and depth must be six. The order of the six layers in memory
      is the same as that listed in :py:obj:`~.cudaGraphicsCubeFace`.

    - A cubemap layered CUDA mipmapped array is allocated if all three
      extents are non-zero, and both, cudaArrayCubemap and cudaArrayLayered
      flags are set. Width must be equal to height, and depth must be a
      multiple of six. A cubemap layered CUDA mipmapped array is a special
      type of 2D layered CUDA mipmapped array that consists of a collection
      of cubemap mipmapped arrays. The first six layers represent the first
      cubemap mipmapped array, the next six layers form the second cubemap
      mipmapped array, and so on.

    The `flags` parameter enables different options to be specified that
    affect the allocation, as follows.

    - :py:obj:`~.cudaArrayDefault`: This flag's value is defined to be 0
      and provides default mipmapped array allocation

    - :py:obj:`~.cudaArrayLayered`: Allocates a layered CUDA mipmapped
      array, with the depth extent indicating the number of layers

    - :py:obj:`~.cudaArrayCubemap`: Allocates a cubemap CUDA mipmapped
      array. Width must be equal to height, and depth must be six. If the
      cudaArrayLayered flag is also set, depth must be a multiple of six.

    - :py:obj:`~.cudaArraySurfaceLoadStore`: This flag indicates that
      individual mipmap levels of the CUDA mipmapped array will be read
      from or written to using a surface reference.

    - :py:obj:`~.cudaArrayTextureGather`: This flag indicates that texture
      gather operations will be performed on the CUDA array. Texture gather
      can only be performed on 2D CUDA mipmapped arrays, and the gather
      operations are performed only on the most detailed mipmap level.

    - :py:obj:`~.cudaArraySparse`: Allocates a CUDA mipmapped array without
      physical backing memory. The subregions within this sparse array can
      later be mapped onto a physical memory allocation by calling
      :py:obj:`~.cuMemMapArrayAsync`. This flag can only be used for
      creating 2D, 3D or 2D layered sparse CUDA mipmapped arrays. The
      physical backing memory must be allocated via
      :py:obj:`~.cuMemCreate`.

    - :py:obj:`~.cudaArrayDeferredMapping`: Allocates a CUDA mipmapped
      array without physical backing memory. The entire array can later be
      mapped onto a physical memory allocation by calling
      :py:obj:`~.cuMemMapArrayAsync`. The physical backing memory must be
      allocated via :py:obj:`~.cuMemCreate`.

    The width, height and depth extents must meet certain size requirements
    as listed in the following table. All values are specified in elements.

    **View CUDA Toolkit Documentation for a table example**

    Parameters
    ----------
    desc : :py:obj:`~.cudaChannelFormatDesc`
        Requested channel format
    extent : :py:obj:`~.cudaExtent`
        Requested allocation size (`width` field in elements)
    numLevels : unsigned int
        Number of mipmap levels to allocate
    flags : unsigned int
        Flags for extensions

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorMemoryAllocation`
    mipmappedArray : :py:obj:`~.cudaMipmappedArray_t`
        Pointer to allocated mipmapped array in device memory

    See Also
    --------
    :py:obj:`~.cudaMalloc3D`, :py:obj:`~.cudaMalloc`, :py:obj:`~.cudaMallocPitch`, :py:obj:`~.cudaFree`, :py:obj:`~.cudaFreeArray`, :py:obj:`~.cudaMallocHost (C API)`, :py:obj:`~.cudaFreeHost`, :py:obj:`~.cudaHostAlloc`, :py:obj:`~.make_cudaExtent`, :py:obj:`~.cuMipmappedArrayCreate`
    """
    cdef cudaMipmappedArray_t mipmappedArray = cudaMipmappedArray_t()
    cdef cyruntime.cudaChannelFormatDesc* cydesc_ptr = desc._pvt_ptr if desc is not None else NULL
    with nogil:
        err = cyruntime.cudaMallocMipmappedArray(<cyruntime.cudaMipmappedArray_t*>mipmappedArray._pvt_ptr, cydesc_ptr, extent._pvt_ptr[0], numLevels, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), mipmappedArray)
{{endif}}

{{if 'cudaGetMipmappedArrayLevel' in found_functions}}

@cython.embedsignature(True)
def cudaGetMipmappedArrayLevel(mipmappedArray, unsigned int level):
    """ Gets a mipmap level of a CUDA mipmapped array.

    Returns in `*levelArray` a CUDA array that represents a single mipmap
    level of the CUDA mipmapped array `mipmappedArray`.

    If `level` is greater than the maximum number of levels in this
    mipmapped array, :py:obj:`~.cudaErrorInvalidValue` is returned.

    If `mipmappedArray` is NULL, :py:obj:`~.cudaErrorInvalidResourceHandle`
    is returned.

    Parameters
    ----------
    mipmappedArray : :py:obj:`~.cudaMipmappedArray_const_t`
        CUDA mipmapped array
    level : unsigned int
        Mipmap level

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue` :py:obj:`~.cudaErrorInvalidResourceHandle`
    levelArray : :py:obj:`~.cudaArray_t`
        Returned mipmap level CUDA array

    See Also
    --------
    :py:obj:`~.cudaMalloc3D`, :py:obj:`~.cudaMalloc`, :py:obj:`~.cudaMallocPitch`, :py:obj:`~.cudaFree`, :py:obj:`~.cudaFreeArray`, :py:obj:`~.cudaMallocHost (C API)`, :py:obj:`~.cudaFreeHost`, :py:obj:`~.cudaHostAlloc`, :py:obj:`~.make_cudaExtent`, :py:obj:`~.cuMipmappedArrayGetLevel`
    """
    cdef cyruntime.cudaMipmappedArray_const_t cymipmappedArray
    if mipmappedArray is None:
        pmipmappedArray = 0
    elif isinstance(mipmappedArray, (cudaMipmappedArray_const_t,)):
        pmipmappedArray = int(mipmappedArray)
    else:
        pmipmappedArray = int(cudaMipmappedArray_const_t(mipmappedArray))
    cymipmappedArray = <cyruntime.cudaMipmappedArray_const_t><void_ptr>pmipmappedArray
    cdef cudaArray_t levelArray = cudaArray_t()
    with nogil:
        err = cyruntime.cudaGetMipmappedArrayLevel(<cyruntime.cudaArray_t*>levelArray._pvt_ptr, cymipmappedArray, level)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), levelArray)
{{endif}}

{{if 'cudaMemcpy3D' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpy3D(p : Optional[cudaMemcpy3DParms]):
    """ Copies data between 3D objects.

    **View CUDA Toolkit Documentation for a C++ code example**

    :py:obj:`~.cudaMemcpy3D()` copies data betwen two 3D objects. The
    source and destination objects may be in either host memory, device
    memory, or a CUDA array. The source, destination, extent, and kind of
    copy performed is specified by the :py:obj:`~.cudaMemcpy3DParms` struct
    which should be initialized to zero before use:

    **View CUDA Toolkit Documentation for a C++ code example**

    The struct passed to :py:obj:`~.cudaMemcpy3D()` must specify one of
    `srcArray` or `srcPtr` and one of `dstArray` or `dstPtr`. Passing more
    than one non-zero source or destination will cause
    :py:obj:`~.cudaMemcpy3D()` to return an error.

    The `srcPos` and `dstPos` fields are optional offsets into the source
    and destination objects and are defined in units of each object's
    elements. The element for a host or device pointer is assumed to be
    unsigned char.

    The `extent` field defines the dimensions of the transferred area in
    elements. If a CUDA array is participating in the copy, the extent is
    defined in terms of that array's elements. If no CUDA array is
    participating in the copy then the extents are defined in elements of
    unsigned char.

    The `kind` field defines the direction of the copy. It must be one of
    :py:obj:`~.cudaMemcpyHostToHost`, :py:obj:`~.cudaMemcpyHostToDevice`,
    :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing. For :py:obj:`~.cudaMemcpyHostToHost` or
    :py:obj:`~.cudaMemcpyHostToDevice` or
    :py:obj:`~.cudaMemcpyDeviceToHost` passed as kind and cudaArray type
    passed as source or destination, if the kind implies cudaArray type to
    be present on the host, :py:obj:`~.cudaMemcpy3D()` will disregard that
    implication and silently correct the kind based on the fact that
    cudaArray type can only be present on the device.

    If the source and destination are both arrays,
    :py:obj:`~.cudaMemcpy3D()` will return an error if they do not have the
    same element size.

    The source and destination object may not overlap. If overlapping
    source and destination objects are specified, undefined behavior will
    result.

    The source object must entirely contain the region defined by `srcPos`
    and `extent`. The destination object must entirely contain the region
    defined by `dstPos` and `extent`.

    :py:obj:`~.cudaMemcpy3D()` returns an error if the pitch of `srcPtr` or
    `dstPtr` exceeds the maximum allowed. The pitch of a
    :py:obj:`~.cudaPitchedPtr` allocated with :py:obj:`~.cudaMalloc3D()`
    will always be valid.

    Parameters
    ----------
    p : :py:obj:`~.cudaMemcpy3DParms`
        3D memory copy parameters

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidPitchValue`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`

    See Also
    --------
    :py:obj:`~.cudaMalloc3D`, :py:obj:`~.cudaMalloc3DArray`, :py:obj:`~.cudaMemset3D`, :py:obj:`~.cudaMemcpy3DAsync`, :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpy2DFromArray`, :py:obj:`~.cudaMemcpy2DArrayToArray`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy2DAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`, :py:obj:`~.cudaMemcpy2DFromArrayAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`, :py:obj:`~.make_cudaExtent`, :py:obj:`~.make_cudaPos`, :py:obj:`~.cuMemcpy3D`
    """
    cdef cyruntime.cudaMemcpy3DParms* cyp_ptr = p._pvt_ptr if p is not None else NULL
    with nogil:
        err = cyruntime.cudaMemcpy3D(cyp_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpy3DPeer' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpy3DPeer(p : Optional[cudaMemcpy3DPeerParms]):
    """ Copies memory between devices.

    Perform a 3D memory copy according to the parameters specified in `p`.
    See the definition of the :py:obj:`~.cudaMemcpy3DPeerParms` structure
    for documentation of its parameters.

    Note that this function is synchronous with respect to the host only if
    the source or destination of the transfer is host memory. Note also
    that this copy is serialized with respect to all pending and future
    asynchronous work in to the current device, the copy's source device,
    and the copy's destination device (use
    :py:obj:`~.cudaMemcpy3DPeerAsync` to avoid this synchronization).

    Parameters
    ----------
    p : :py:obj:`~.cudaMemcpy3DPeerParms`
        Parameters for the memory copy

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidPitchValue`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyPeer`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpyPeerAsync`, :py:obj:`~.cudaMemcpy3DPeerAsync`, :py:obj:`~.cuMemcpy3DPeer`
    """
    cdef cyruntime.cudaMemcpy3DPeerParms* cyp_ptr = p._pvt_ptr if p is not None else NULL
    with nogil:
        err = cyruntime.cudaMemcpy3DPeer(cyp_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpy3DAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpy3DAsync(p : Optional[cudaMemcpy3DParms], stream):
    """ Copies data between 3D objects.

    **View CUDA Toolkit Documentation for a C++ code example**

    :py:obj:`~.cudaMemcpy3DAsync()` copies data betwen two 3D objects. The
    source and destination objects may be in either host memory, device
    memory, or a CUDA array. The source, destination, extent, and kind of
    copy performed is specified by the :py:obj:`~.cudaMemcpy3DParms` struct
    which should be initialized to zero before use:

    **View CUDA Toolkit Documentation for a C++ code example**

    The struct passed to :py:obj:`~.cudaMemcpy3DAsync()` must specify one
    of `srcArray` or `srcPtr` and one of `dstArray` or `dstPtr`. Passing
    more than one non-zero source or destination will cause
    :py:obj:`~.cudaMemcpy3DAsync()` to return an error.

    The `srcPos` and `dstPos` fields are optional offsets into the source
    and destination objects and are defined in units of each object's
    elements. The element for a host or device pointer is assumed to be
    unsigned char. For CUDA arrays, positions must be in the range [0,
    2048) for any dimension.

    The `extent` field defines the dimensions of the transferred area in
    elements. If a CUDA array is participating in the copy, the extent is
    defined in terms of that array's elements. If no CUDA array is
    participating in the copy then the extents are defined in elements of
    unsigned char.

    The `kind` field defines the direction of the copy. It must be one of
    :py:obj:`~.cudaMemcpyHostToHost`, :py:obj:`~.cudaMemcpyHostToDevice`,
    :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing. For :py:obj:`~.cudaMemcpyHostToHost` or
    :py:obj:`~.cudaMemcpyHostToDevice` or
    :py:obj:`~.cudaMemcpyDeviceToHost` passed as kind and cudaArray type
    passed as source or destination, if the kind implies cudaArray type to
    be present on the host, :py:obj:`~.cudaMemcpy3DAsync()` will disregard
    that implication and silently correct the kind based on the fact that
    cudaArray type can only be present on the device.

    If the source and destination are both arrays,
    :py:obj:`~.cudaMemcpy3DAsync()` will return an error if they do not
    have the same element size.

    The source and destination object may not overlap. If overlapping
    source and destination objects are specified, undefined behavior will
    result.

    The source object must lie entirely within the region defined by
    `srcPos` and `extent`. The destination object must lie entirely within
    the region defined by `dstPos` and `extent`.

    :py:obj:`~.cudaMemcpy3DAsync()` returns an error if the pitch of
    `srcPtr` or `dstPtr` exceeds the maximum allowed. The pitch of a
    :py:obj:`~.cudaPitchedPtr` allocated with :py:obj:`~.cudaMalloc3D()`
    will always be valid.

    :py:obj:`~.cudaMemcpy3DAsync()` is asynchronous with respect to the
    host, so the call may return before the copy is complete. The copy can
    optionally be associated to a stream by passing a non-zero `stream`
    argument. If `kind` is :py:obj:`~.cudaMemcpyHostToDevice` or
    :py:obj:`~.cudaMemcpyDeviceToHost` and `stream` is non-zero, the copy
    may overlap with operations in other streams.

    The device version of this function only handles device to device
    copies and cannot be given local or shared pointers.

    Parameters
    ----------
    p : :py:obj:`~.cudaMemcpy3DParms`
        3D memory copy parameters
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidPitchValue`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`

    See Also
    --------
    :py:obj:`~.cudaMalloc3D`, :py:obj:`~.cudaMalloc3DArray`, :py:obj:`~.cudaMemset3D`, :py:obj:`~.cudaMemcpy3D`, :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpy2DToArray`, ::::py:obj:`~.cudaMemcpy2DFromArray`, :py:obj:`~.cudaMemcpy2DArrayToArray`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy2DAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`, :py:obj:`~.cudaMemcpy2DFromArrayAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`, :py:obj:`~.make_cudaExtent`, :py:obj:`~.make_cudaPos`, :py:obj:`~.cuMemcpy3DAsync`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaMemcpy3DParms* cyp_ptr = p._pvt_ptr if p is not None else NULL
    with nogil:
        err = cyruntime.cudaMemcpy3DAsync(cyp_ptr, cystream)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpy3DPeerAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpy3DPeerAsync(p : Optional[cudaMemcpy3DPeerParms], stream):
    """ Copies memory between devices asynchronously.

    Perform a 3D memory copy according to the parameters specified in `p`.
    See the definition of the :py:obj:`~.cudaMemcpy3DPeerParms` structure
    for documentation of its parameters.

    Parameters
    ----------
    p : :py:obj:`~.cudaMemcpy3DPeerParms`
        Parameters for the memory copy
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidPitchValue`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyPeer`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpyPeerAsync`, :py:obj:`~.cudaMemcpy3DPeerAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaMemcpy3DPeerParms* cyp_ptr = p._pvt_ptr if p is not None else NULL
    with nogil:
        err = cyruntime.cudaMemcpy3DPeerAsync(cyp_ptr, cystream)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemGetInfo' in found_functions}}

@cython.embedsignature(True)
def cudaMemGetInfo():
    """ Gets free and total device memory.

    Returns in `*total` the total amount of memory available to the the
    current context. Returns in `*free` the amount of memory on the device
    that is free according to the OS. CUDA is not guaranteed to be able to
    allocate all of the memory that the OS reports as free. In a multi-
    tenet situation, free estimate returned is prone to race condition
    where a new allocation/free done by a different process or a different
    thread in the same process between the time when free memory was
    estimated and reported, will result in deviation in free value reported
    and actual free memory.

    The integrated GPU on Tegra shares memory with CPU and other component
    of the SoC. The free and total values returned by the API excludes the
    SWAP memory space maintained by the OS on some platforms. The OS may
    move some of the memory pages into swap area as the GPU or CPU allocate
    or access memory. See Tegra app note on how to calculate total and free
    memory on Tegra.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorLaunchFailure`
    free : int
        Returned free memory in bytes
    total : int
        Returned total memory in bytes

    See Also
    --------
    :py:obj:`~.cuMemGetInfo`
    """
    cdef size_t free = 0
    cdef size_t total = 0
    with nogil:
        err = cyruntime.cudaMemGetInfo(&free, &total)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None)
    return (cudaError_t(err), free, total)
{{endif}}

{{if 'cudaArrayGetInfo' in found_functions}}

@cython.embedsignature(True)
def cudaArrayGetInfo(array):
    """ Gets info about the specified cudaArray.

    Returns in `*desc`, `*extent` and `*flags` respectively, the type,
    shape and flags of `array`.

    Any of `*desc`, `*extent` and `*flags` may be specified as NULL.

    Parameters
    ----------
    array : :py:obj:`~.cudaArray_t`
        The :py:obj:`~.cudaArray` to get info for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    desc : :py:obj:`~.cudaChannelFormatDesc`
        Returned array type
    extent : :py:obj:`~.cudaExtent`
        Returned array shape. 2D arrays will have depth of zero
    flags : unsigned int
        Returned array flags

    See Also
    --------
    :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuArray3DGetDescriptor`
    """
    cdef cyruntime.cudaArray_t cyarray
    if array is None:
        parray = 0
    elif isinstance(array, (cudaArray_t,)):
        parray = int(array)
    else:
        parray = int(cudaArray_t(array))
    cyarray = <cyruntime.cudaArray_t><void_ptr>parray
    cdef cudaChannelFormatDesc desc = cudaChannelFormatDesc()
    cdef cudaExtent extent = cudaExtent()
    cdef unsigned int flags = 0
    with nogil:
        err = cyruntime.cudaArrayGetInfo(<cyruntime.cudaChannelFormatDesc*>desc._pvt_ptr, <cyruntime.cudaExtent*>extent._pvt_ptr, &flags, cyarray)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None, None)
    return (cudaError_t(err), desc, extent, flags)
{{endif}}

{{if 'cudaArrayGetPlane' in found_functions}}

@cython.embedsignature(True)
def cudaArrayGetPlane(hArray, unsigned int planeIdx):
    """ Gets a CUDA array plane from a CUDA array.

    Returns in `pPlaneArray` a CUDA array that represents a single format
    plane of the CUDA array `hArray`.

    If `planeIdx` is greater than the maximum number of planes in this
    array or if the array does not have a multi-planar format e.g:
    :py:obj:`~.cudaChannelFormatKindNV12`, then
    :py:obj:`~.cudaErrorInvalidValue` is returned.

    Note that if the `hArray` has format
    :py:obj:`~.cudaChannelFormatKindNV12`, then passing in 0 for `planeIdx`
    returns a CUDA array of the same size as `hArray` but with one 8-bit
    channel and :py:obj:`~.cudaChannelFormatKindUnsigned` as its format
    kind. If 1 is passed for `planeIdx`, then the returned CUDA array has
    half the height and width of `hArray` with two 8-bit channels and
    :py:obj:`~.cudaChannelFormatKindUnsigned` as its format kind.

    Parameters
    ----------
    hArray : :py:obj:`~.cudaArray_t`
        CUDA array
    planeIdx : unsigned int
        Plane index

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue` :py:obj:`~.cudaErrorInvalidResourceHandle`
    pPlaneArray : :py:obj:`~.cudaArray_t`
        Returned CUDA array referenced by the `planeIdx`

    See Also
    --------
    :py:obj:`~.cuArrayGetPlane`
    """
    cdef cyruntime.cudaArray_t cyhArray
    if hArray is None:
        phArray = 0
    elif isinstance(hArray, (cudaArray_t,)):
        phArray = int(hArray)
    else:
        phArray = int(cudaArray_t(hArray))
    cyhArray = <cyruntime.cudaArray_t><void_ptr>phArray
    cdef cudaArray_t pPlaneArray = cudaArray_t()
    with nogil:
        err = cyruntime.cudaArrayGetPlane(<cyruntime.cudaArray_t*>pPlaneArray._pvt_ptr, cyhArray, planeIdx)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pPlaneArray)
{{endif}}

{{if 'cudaArrayGetMemoryRequirements' in found_functions}}

@cython.embedsignature(True)
def cudaArrayGetMemoryRequirements(array, int device):
    """ Returns the memory requirements of a CUDA array.

    Returns the memory requirements of a CUDA array in `memoryRequirements`
    If the CUDA array is not allocated with flag
    :py:obj:`~.cudaArrayDeferredMapping` :py:obj:`~.cudaErrorInvalidValue`
    will be returned.

    The returned value in :py:obj:`~.cudaArrayMemoryRequirements.size`
    represents the total size of the CUDA array. The returned value in
    :py:obj:`~.cudaArrayMemoryRequirements.alignment` represents the
    alignment necessary for mapping the CUDA array.

    Parameters
    ----------
    array : :py:obj:`~.cudaArray_t`
        CUDA array to get the memory requirements of
    device : int
        Device to get the memory requirements for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess` :py:obj:`~.cudaErrorInvalidValue`
    memoryRequirements : :py:obj:`~.cudaArrayMemoryRequirements`
        Pointer to :py:obj:`~.cudaArrayMemoryRequirements`

    See Also
    --------
    :py:obj:`~.cudaMipmappedArrayGetMemoryRequirements`
    """
    cdef cyruntime.cudaArray_t cyarray
    if array is None:
        parray = 0
    elif isinstance(array, (cudaArray_t,)):
        parray = int(array)
    else:
        parray = int(cudaArray_t(array))
    cyarray = <cyruntime.cudaArray_t><void_ptr>parray
    cdef cudaArrayMemoryRequirements memoryRequirements = cudaArrayMemoryRequirements()
    with nogil:
        err = cyruntime.cudaArrayGetMemoryRequirements(<cyruntime.cudaArrayMemoryRequirements*>memoryRequirements._pvt_ptr, cyarray, device)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), memoryRequirements)
{{endif}}

{{if 'cudaMipmappedArrayGetMemoryRequirements' in found_functions}}

@cython.embedsignature(True)
def cudaMipmappedArrayGetMemoryRequirements(mipmap, int device):
    """ Returns the memory requirements of a CUDA mipmapped array.

    Returns the memory requirements of a CUDA mipmapped array in
    `memoryRequirements` If the CUDA mipmapped array is not allocated with
    flag :py:obj:`~.cudaArrayDeferredMapping`
    :py:obj:`~.cudaErrorInvalidValue` will be returned.

    The returned value in :py:obj:`~.cudaArrayMemoryRequirements.size`
    represents the total size of the CUDA mipmapped array. The returned
    value in :py:obj:`~.cudaArrayMemoryRequirements.alignment` represents
    the alignment necessary for mapping the CUDA mipmapped array.

    Parameters
    ----------
    mipmap : :py:obj:`~.cudaMipmappedArray_t`
        CUDA mipmapped array to get the memory requirements of
    device : int
        Device to get the memory requirements for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess` :py:obj:`~.cudaErrorInvalidValue`
    memoryRequirements : :py:obj:`~.cudaArrayMemoryRequirements`
        Pointer to :py:obj:`~.cudaArrayMemoryRequirements`

    See Also
    --------
    :py:obj:`~.cudaArrayGetMemoryRequirements`
    """
    cdef cyruntime.cudaMipmappedArray_t cymipmap
    if mipmap is None:
        pmipmap = 0
    elif isinstance(mipmap, (cudaMipmappedArray_t,)):
        pmipmap = int(mipmap)
    else:
        pmipmap = int(cudaMipmappedArray_t(mipmap))
    cymipmap = <cyruntime.cudaMipmappedArray_t><void_ptr>pmipmap
    cdef cudaArrayMemoryRequirements memoryRequirements = cudaArrayMemoryRequirements()
    with nogil:
        err = cyruntime.cudaMipmappedArrayGetMemoryRequirements(<cyruntime.cudaArrayMemoryRequirements*>memoryRequirements._pvt_ptr, cymipmap, device)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), memoryRequirements)
{{endif}}

{{if 'cudaArrayGetSparseProperties' in found_functions}}

@cython.embedsignature(True)
def cudaArrayGetSparseProperties(array):
    """ Returns the layout properties of a sparse CUDA array.

    Returns the layout properties of a sparse CUDA array in
    `sparseProperties`. If the CUDA array is not allocated with flag
    :py:obj:`~.cudaArraySparse` :py:obj:`~.cudaErrorInvalidValue` will be
    returned.

    If the returned value in :py:obj:`~.cudaArraySparseProperties.flags`
    contains :py:obj:`~.cudaArraySparsePropertiesSingleMipTail`, then
    :py:obj:`~.cudaArraySparseProperties.miptailSize` represents the total
    size of the array. Otherwise, it will be zero. Also, the returned value
    in :py:obj:`~.cudaArraySparseProperties.miptailFirstLevel` is always
    zero. Note that the `array` must have been allocated using
    :py:obj:`~.cudaMallocArray` or :py:obj:`~.cudaMalloc3DArray`. For CUDA
    arrays obtained using :py:obj:`~.cudaMipmappedArrayGetLevel`,
    :py:obj:`~.cudaErrorInvalidValue` will be returned. Instead,
    :py:obj:`~.cudaMipmappedArrayGetSparseProperties` must be used to
    obtain the sparse properties of the entire CUDA mipmapped array to
    which `array` belongs to.

    Parameters
    ----------
    array : :py:obj:`~.cudaArray_t`
        The CUDA array to get the sparse properties of

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess` :py:obj:`~.cudaErrorInvalidValue`
    sparseProperties : :py:obj:`~.cudaArraySparseProperties`
        Pointer to return the :py:obj:`~.cudaArraySparseProperties`

    See Also
    --------
    :py:obj:`~.cudaMipmappedArrayGetSparseProperties`, :py:obj:`~.cuMemMapArrayAsync`
    """
    cdef cyruntime.cudaArray_t cyarray
    if array is None:
        parray = 0
    elif isinstance(array, (cudaArray_t,)):
        parray = int(array)
    else:
        parray = int(cudaArray_t(array))
    cyarray = <cyruntime.cudaArray_t><void_ptr>parray
    cdef cudaArraySparseProperties sparseProperties = cudaArraySparseProperties()
    with nogil:
        err = cyruntime.cudaArrayGetSparseProperties(<cyruntime.cudaArraySparseProperties*>sparseProperties._pvt_ptr, cyarray)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), sparseProperties)
{{endif}}

{{if 'cudaMipmappedArrayGetSparseProperties' in found_functions}}

@cython.embedsignature(True)
def cudaMipmappedArrayGetSparseProperties(mipmap):
    """ Returns the layout properties of a sparse CUDA mipmapped array.

    Returns the sparse array layout properties in `sparseProperties`. If
    the CUDA mipmapped array is not allocated with flag
    :py:obj:`~.cudaArraySparse` :py:obj:`~.cudaErrorInvalidValue` will be
    returned.

    For non-layered CUDA mipmapped arrays,
    :py:obj:`~.cudaArraySparseProperties.miptailSize` returns the size of
    the mip tail region. The mip tail region includes all mip levels whose
    width, height or depth is less than that of the tile. For layered CUDA
    mipmapped arrays, if :py:obj:`~.cudaArraySparseProperties.flags`
    contains :py:obj:`~.cudaArraySparsePropertiesSingleMipTail`, then
    :py:obj:`~.cudaArraySparseProperties.miptailSize` specifies the size of
    the mip tail of all layers combined. Otherwise,
    :py:obj:`~.cudaArraySparseProperties.miptailSize` specifies mip tail
    size per layer. The returned value of
    :py:obj:`~.cudaArraySparseProperties.miptailFirstLevel` is valid only
    if :py:obj:`~.cudaArraySparseProperties.miptailSize` is non-zero.

    Parameters
    ----------
    mipmap : :py:obj:`~.cudaMipmappedArray_t`
        The CUDA mipmapped array to get the sparse properties of

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess` :py:obj:`~.cudaErrorInvalidValue`
    sparseProperties : :py:obj:`~.cudaArraySparseProperties`
        Pointer to return :py:obj:`~.cudaArraySparseProperties`

    See Also
    --------
    :py:obj:`~.cudaArrayGetSparseProperties`, :py:obj:`~.cuMemMapArrayAsync`
    """
    cdef cyruntime.cudaMipmappedArray_t cymipmap
    if mipmap is None:
        pmipmap = 0
    elif isinstance(mipmap, (cudaMipmappedArray_t,)):
        pmipmap = int(mipmap)
    else:
        pmipmap = int(cudaMipmappedArray_t(mipmap))
    cymipmap = <cyruntime.cudaMipmappedArray_t><void_ptr>pmipmap
    cdef cudaArraySparseProperties sparseProperties = cudaArraySparseProperties()
    with nogil:
        err = cyruntime.cudaMipmappedArrayGetSparseProperties(<cyruntime.cudaArraySparseProperties*>sparseProperties._pvt_ptr, cymipmap)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), sparseProperties)
{{endif}}

{{if 'cudaMemcpy' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpy(dst, src, size_t count, kind not None : cudaMemcpyKind):
    """ Copies data between host and device.

    Copies `count` bytes from the memory area pointed to by `src` to the
    memory area pointed to by `dst`, where `kind` specifies the direction
    of the copy, and must be one of :py:obj:`~.cudaMemcpyHostToHost`,
    :py:obj:`~.cudaMemcpyHostToDevice`, :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing. Calling :py:obj:`~.cudaMemcpy()` with dst
    and src pointers that do not match the direction of the copy results in
    an undefined behavior.

    \note_sync

    Parameters
    ----------
    dst : Any
        Destination memory address
    src : Any
        Source memory address
    count : size_t
        Size in bytes to copy
    kind : :py:obj:`~.cudaMemcpyKind`
        Type of transfer

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`

    See Also
    --------
    :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpy2DFromArray`, :py:obj:`~.cudaMemcpy2DArrayToArray`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy2DAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`, :py:obj:`~.cudaMemcpy2DFromArrayAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpy`
    """
    cdef _HelperInputVoidPtrStruct cydstHelper
    cdef void* cydst = _helper_input_void_ptr(dst, &cydstHelper)
    cdef _HelperInputVoidPtrStruct cysrcHelper
    cdef void* cysrc = _helper_input_void_ptr(src, &cysrcHelper)
    cdef cyruntime.cudaMemcpyKind cykind = int(kind)
    with nogil:
        err = cyruntime.cudaMemcpy(cydst, cysrc, count, cykind)
    _helper_input_void_ptr_free(&cydstHelper)
    _helper_input_void_ptr_free(&cysrcHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpyPeer' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpyPeer(dst, int dstDevice, src, int srcDevice, size_t count):
    """ Copies memory between two devices.

    Copies memory from one device to memory on another device. `dst` is the
    base device pointer of the destination memory and `dstDevice` is the
    destination device. `src` is the base device pointer of the source
    memory and `srcDevice` is the source device. `count` specifies the
    number of bytes to copy.

    Note that this function is asynchronous with respect to the host, but
    serialized with respect all pending and future asynchronous work in to
    the current device, `srcDevice`, and `dstDevice` (use
    :py:obj:`~.cudaMemcpyPeerAsync` to avoid this synchronization).

    Parameters
    ----------
    dst : Any
        Destination device pointer
    dstDevice : int
        Destination device
    src : Any
        Source device pointer
    srcDevice : int
        Source device
    count : size_t
        Size of memory copy in bytes

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidDevice`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpyPeerAsync`, :py:obj:`~.cudaMemcpy3DPeerAsync`, :py:obj:`~.cuMemcpyPeer`
    """
    cdef _HelperInputVoidPtrStruct cydstHelper
    cdef void* cydst = _helper_input_void_ptr(dst, &cydstHelper)
    cdef _HelperInputVoidPtrStruct cysrcHelper
    cdef void* cysrc = _helper_input_void_ptr(src, &cysrcHelper)
    with nogil:
        err = cyruntime.cudaMemcpyPeer(cydst, dstDevice, cysrc, srcDevice, count)
    _helper_input_void_ptr_free(&cydstHelper)
    _helper_input_void_ptr_free(&cysrcHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpy2D' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpy2D(dst, size_t dpitch, src, size_t spitch, size_t width, size_t height, kind not None : cudaMemcpyKind):
    """ Copies data between host and device.

    Copies a matrix (`height` rows of `width` bytes each) from the memory
    area pointed to by `src` to the memory area pointed to by `dst`, where
    `kind` specifies the direction of the copy, and must be one of
    :py:obj:`~.cudaMemcpyHostToHost`, :py:obj:`~.cudaMemcpyHostToDevice`,
    :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing. `dpitch` and `spitch` are the widths in
    memory in bytes of the 2D arrays pointed to by `dst` and `src`,
    including any padding added to the end of each row. The memory areas
    may not overlap. `width` must not exceed either `dpitch` or `spitch`.
    Calling :py:obj:`~.cudaMemcpy2D()` with `dst` and `src` pointers that
    do not match the direction of the copy results in an undefined
    behavior. :py:obj:`~.cudaMemcpy2D()` returns an error if `dpitch` or
    `spitch` exceeds the maximum allowed.

    Parameters
    ----------
    dst : Any
        Destination memory address
    dpitch : size_t
        Pitch of destination memory
    src : Any
        Source memory address
    spitch : size_t
        Pitch of source memory
    width : size_t
        Width of matrix transfer (columns in bytes)
    height : size_t
        Height of matrix transfer (rows)
    kind : :py:obj:`~.cudaMemcpyKind`
        Type of transfer

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidPitchValue`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpy2DFromArray`, :py:obj:`~.cudaMemcpy2DArrayToArray`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy2DAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`, :py:obj:`~.cudaMemcpy2DFromArrayAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DUnaligned`
    """
    cdef _HelperInputVoidPtrStruct cydstHelper
    cdef void* cydst = _helper_input_void_ptr(dst, &cydstHelper)
    cdef _HelperInputVoidPtrStruct cysrcHelper
    cdef void* cysrc = _helper_input_void_ptr(src, &cysrcHelper)
    cdef cyruntime.cudaMemcpyKind cykind = int(kind)
    with nogil:
        err = cyruntime.cudaMemcpy2D(cydst, dpitch, cysrc, spitch, width, height, cykind)
    _helper_input_void_ptr_free(&cydstHelper)
    _helper_input_void_ptr_free(&cysrcHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpy2DToArray' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpy2DToArray(dst, size_t wOffset, size_t hOffset, src, size_t spitch, size_t width, size_t height, kind not None : cudaMemcpyKind):
    """ Copies data between host and device.

    Copies a matrix (`height` rows of `width` bytes each) from the memory
    area pointed to by `src` to the CUDA array `dst` starting at `hOffset`
    rows and `wOffset` bytes from the upper left corner, where `kind`
    specifies the direction of the copy, and must be one of
    :py:obj:`~.cudaMemcpyHostToHost`, :py:obj:`~.cudaMemcpyHostToDevice`,
    :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing. `spitch` is the width in memory in bytes of
    the 2D array pointed to by `src`, including any padding added to the
    end of each row. `wOffset` + `width` must not exceed the width of the
    CUDA array `dst`. `width` must not exceed `spitch`.
    :py:obj:`~.cudaMemcpy2DToArray()` returns an error if `spitch` exceeds
    the maximum allowed.

    Parameters
    ----------
    dst : :py:obj:`~.cudaArray_t`
        Destination memory address
    wOffset : size_t
        Destination starting X offset (columns in bytes)
    hOffset : size_t
        Destination starting Y offset (rows)
    src : Any
        Source memory address
    spitch : size_t
        Pitch of source memory
    width : size_t
        Width of matrix transfer (columns in bytes)
    height : size_t
        Height of matrix transfer (rows)
    kind : :py:obj:`~.cudaMemcpyKind`
        Type of transfer

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidPitchValue`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpy2DFromArray`, :py:obj:`~.cudaMemcpy2DArrayToArray`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy2DAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`, :py:obj:`~.cudaMemcpy2DFromArrayAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DUnaligned`
    """
    cdef cyruntime.cudaArray_t cydst
    if dst is None:
        pdst = 0
    elif isinstance(dst, (cudaArray_t,)):
        pdst = int(dst)
    else:
        pdst = int(cudaArray_t(dst))
    cydst = <cyruntime.cudaArray_t><void_ptr>pdst
    cdef _HelperInputVoidPtrStruct cysrcHelper
    cdef void* cysrc = _helper_input_void_ptr(src, &cysrcHelper)
    cdef cyruntime.cudaMemcpyKind cykind = int(kind)
    with nogil:
        err = cyruntime.cudaMemcpy2DToArray(cydst, wOffset, hOffset, cysrc, spitch, width, height, cykind)
    _helper_input_void_ptr_free(&cysrcHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpy2DFromArray' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpy2DFromArray(dst, size_t dpitch, src, size_t wOffset, size_t hOffset, size_t width, size_t height, kind not None : cudaMemcpyKind):
    """ Copies data between host and device.

    Copies a matrix (`height` rows of `width` bytes each) from the CUDA
    array `src` starting at `hOffset` rows and `wOffset` bytes from the
    upper left corner to the memory area pointed to by `dst`, where `kind`
    specifies the direction of the copy, and must be one of
    :py:obj:`~.cudaMemcpyHostToHost`, :py:obj:`~.cudaMemcpyHostToDevice`,
    :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing. `dpitch` is the width in memory in bytes of
    the 2D array pointed to by `dst`, including any padding added to the
    end of each row. `wOffset` + `width` must not exceed the width of the
    CUDA array `src`. `width` must not exceed `dpitch`.
    :py:obj:`~.cudaMemcpy2DFromArray()` returns an error if `dpitch`
    exceeds the maximum allowed.

    Parameters
    ----------
    dst : Any
        Destination memory address
    dpitch : size_t
        Pitch of destination memory
    src : :py:obj:`~.cudaArray_const_t`
        Source memory address
    wOffset : size_t
        Source starting X offset (columns in bytes)
    hOffset : size_t
        Source starting Y offset (rows)
    width : size_t
        Width of matrix transfer (columns in bytes)
    height : size_t
        Height of matrix transfer (rows)
    kind : :py:obj:`~.cudaMemcpyKind`
        Type of transfer

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidPitchValue`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpy2DArrayToArray`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy2DAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`, :py:obj:`~.cudaMemcpy2DFromArrayAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DUnaligned`
    """
    cdef cyruntime.cudaArray_const_t cysrc
    if src is None:
        psrc = 0
    elif isinstance(src, (cudaArray_const_t,)):
        psrc = int(src)
    else:
        psrc = int(cudaArray_const_t(src))
    cysrc = <cyruntime.cudaArray_const_t><void_ptr>psrc
    cdef _HelperInputVoidPtrStruct cydstHelper
    cdef void* cydst = _helper_input_void_ptr(dst, &cydstHelper)
    cdef cyruntime.cudaMemcpyKind cykind = int(kind)
    with nogil:
        err = cyruntime.cudaMemcpy2DFromArray(cydst, dpitch, cysrc, wOffset, hOffset, width, height, cykind)
    _helper_input_void_ptr_free(&cydstHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpy2DArrayToArray' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpy2DArrayToArray(dst, size_t wOffsetDst, size_t hOffsetDst, src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, kind not None : cudaMemcpyKind):
    """ Copies data between host and device.

    Copies a matrix (`height` rows of `width` bytes each) from the CUDA
    array `src` starting at `hOffsetSrc` rows and `wOffsetSrc` bytes from
    the upper left corner to the CUDA array `dst` starting at `hOffsetDst`
    rows and `wOffsetDst` bytes from the upper left corner, where `kind`
    specifies the direction of the copy, and must be one of
    :py:obj:`~.cudaMemcpyHostToHost`, :py:obj:`~.cudaMemcpyHostToDevice`,
    :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing. `wOffsetDst` + `width` must not exceed the
    width of the CUDA array `dst`. `wOffsetSrc` + `width` must not exceed
    the width of the CUDA array `src`.

    Parameters
    ----------
    dst : :py:obj:`~.cudaArray_t`
        Destination memory address
    wOffsetDst : size_t
        Destination starting X offset (columns in bytes)
    hOffsetDst : size_t
        Destination starting Y offset (rows)
    src : :py:obj:`~.cudaArray_const_t`
        Source memory address
    wOffsetSrc : size_t
        Source starting X offset (columns in bytes)
    hOffsetSrc : size_t
        Source starting Y offset (rows)
    width : size_t
        Width of matrix transfer (columns in bytes)
    height : size_t
        Height of matrix transfer (rows)
    kind : :py:obj:`~.cudaMemcpyKind`
        Type of transfer

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpy2DFromArray`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy2DAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`, :py:obj:`~.cudaMemcpy2DFromArrayAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DUnaligned`
    """
    cdef cyruntime.cudaArray_const_t cysrc
    if src is None:
        psrc = 0
    elif isinstance(src, (cudaArray_const_t,)):
        psrc = int(src)
    else:
        psrc = int(cudaArray_const_t(src))
    cysrc = <cyruntime.cudaArray_const_t><void_ptr>psrc
    cdef cyruntime.cudaArray_t cydst
    if dst is None:
        pdst = 0
    elif isinstance(dst, (cudaArray_t,)):
        pdst = int(dst)
    else:
        pdst = int(cudaArray_t(dst))
    cydst = <cyruntime.cudaArray_t><void_ptr>pdst
    cdef cyruntime.cudaMemcpyKind cykind = int(kind)
    with nogil:
        err = cyruntime.cudaMemcpy2DArrayToArray(cydst, wOffsetDst, hOffsetDst, cysrc, wOffsetSrc, hOffsetSrc, width, height, cykind)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpyAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpyAsync(dst, src, size_t count, kind not None : cudaMemcpyKind, stream):
    """ Copies data between host and device.

    Copies `count` bytes from the memory area pointed to by `src` to the
    memory area pointed to by `dst`, where `kind` specifies the direction
    of the copy, and must be one of :py:obj:`~.cudaMemcpyHostToHost`,
    :py:obj:`~.cudaMemcpyHostToDevice`, :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing.

    The memory areas may not overlap. Calling :py:obj:`~.cudaMemcpyAsync()`
    with `dst` and `src` pointers that do not match the direction of the
    copy results in an undefined behavior.

    :py:obj:`~.cudaMemcpyAsync()` is asynchronous with respect to the host,
    so the call may return before the copy is complete. The copy can
    optionally be associated to a stream by passing a non-zero `stream`
    argument. If `kind` is :py:obj:`~.cudaMemcpyHostToDevice` or
    :py:obj:`~.cudaMemcpyDeviceToHost` and the `stream` is non-zero, the
    copy may overlap with operations in other streams.

    The device version of this function only handles device to device
    copies and cannot be given local or shared pointers.

    Parameters
    ----------
    dst : Any
        Destination memory address
    src : Any
        Source memory address
    count : size_t
        Size in bytes to copy
    kind : :py:obj:`~.cudaMemcpyKind`
        Type of transfer
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpy2DFromArray`, :py:obj:`~.cudaMemcpy2DArrayToArray`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`, :py:obj:`~.cudaMemcpy2DAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`, :py:obj:`~.cudaMemcpy2DFromArrayAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`, :py:obj:`~.cuMemcpyAsync`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemcpyDtoDAsync`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef _HelperInputVoidPtrStruct cydstHelper
    cdef void* cydst = _helper_input_void_ptr(dst, &cydstHelper)
    cdef _HelperInputVoidPtrStruct cysrcHelper
    cdef void* cysrc = _helper_input_void_ptr(src, &cysrcHelper)
    cdef cyruntime.cudaMemcpyKind cykind = int(kind)
    with nogil:
        err = cyruntime.cudaMemcpyAsync(cydst, cysrc, count, cykind, cystream)
    _helper_input_void_ptr_free(&cydstHelper)
    _helper_input_void_ptr_free(&cysrcHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpyPeerAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpyPeerAsync(dst, int dstDevice, src, int srcDevice, size_t count, stream):
    """ Copies memory between two devices asynchronously.

    Copies memory from one device to memory on another device. `dst` is the
    base device pointer of the destination memory and `dstDevice` is the
    destination device. `src` is the base device pointer of the source
    memory and `srcDevice` is the source device. `count` specifies the
    number of bytes to copy.

    Note that this function is asynchronous with respect to the host and
    all work on other devices.

    Parameters
    ----------
    dst : Any
        Destination device pointer
    dstDevice : int
        Destination device
    src : Any
        Source device pointer
    srcDevice : int
        Source device
    count : size_t
        Size of memory copy in bytes
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidDevice`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyPeer`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy3DPeerAsync`, :py:obj:`~.cuMemcpyPeerAsync`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef _HelperInputVoidPtrStruct cydstHelper
    cdef void* cydst = _helper_input_void_ptr(dst, &cydstHelper)
    cdef _HelperInputVoidPtrStruct cysrcHelper
    cdef void* cysrc = _helper_input_void_ptr(src, &cysrcHelper)
    with nogil:
        err = cyruntime.cudaMemcpyPeerAsync(cydst, dstDevice, cysrc, srcDevice, count, cystream)
    _helper_input_void_ptr_free(&cydstHelper)
    _helper_input_void_ptr_free(&cysrcHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpyBatchAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpyBatchAsync(dsts : Optional[tuple[Any] | list[Any]], srcs : Optional[tuple[Any] | list[Any]], sizes : tuple[int] | list[int], size_t count, attrs : Optional[tuple[cudaMemcpyAttributes] | list[cudaMemcpyAttributes]], attrsIdxs : tuple[int] | list[int], size_t numAttrs, stream):
    """ Performs a batch of memory copies asynchronously.

    Performs a batch of memory copies. The batch as a whole executes in
    stream order but copies within a batch are not guaranteed to execute in
    any specific order. This API only supports pointer-to-pointer copies.
    For copies involving CUDA arrays, please see
    :py:obj:`~.cudaMemcpy3DBatchAsync`.

    Performs memory copies from source buffers specified in `srcs` to
    destination buffers specified in `dsts`. The size of each copy is
    specified in `sizes`. All three arrays must be of the same length as
    specified by `count`. Since there are no ordering guarantees for copies
    within a batch, specifying any dependent copies within a batch will
    result in undefined behavior.

    Every copy in the batch has to be associated with a set of attributes
    specified in the `attrs` array. Each entry in this array can apply to
    more than one copy. This can be done by specifying in the `attrsIdxs`
    array, the index of the first copy that the corresponding entry in the
    `attrs` array applies to. Both `attrs` and `attrsIdxs` must be of the
    same length as specified by `numAttrs`. For example, if a batch has 10
    copies listed in dst/src/sizes, the first 6 of which have one set of
    attributes and the remaining 4 another, then `numAttrs` will be 2,
    `attrsIdxs` will be {0, 6} and `attrs` will contains the two sets of
    attributes. Note that the first entry in `attrsIdxs` must always be 0.
    Also, each entry must be greater than the previous entry and the last
    entry should be less than `count`. Furthermore, `numAttrs` must be
    lesser than or equal to `count`.

    The :py:obj:`~.cudaMemcpyAttributes.srcAccessOrder` indicates the
    source access ordering to be observed for copies associated with the
    attribute. If the source access order is set to
    :py:obj:`~.cudaMemcpySrcAccessOrderStream`, then the source will be
    accessed in stream order. If the source access order is set to
    :py:obj:`~.cudaMemcpySrcAccessOrderDuringApiCall` then it indicates
    that access to the source pointer can be out of stream order and all
    accesses must be complete before the API call returns. This flag is
    suited for ephemeral sources (ex., stack variables) when it's known
    that no prior operations in the stream can be accessing the memory and
    also that the lifetime of the memory is limited to the scope that the
    source variable was declared in. Specifying this flag allows the driver
    to optimize the copy and removes the need for the user to synchronize
    the stream after the API call. If the source access order is set to
    :py:obj:`~.cudaMemcpySrcAccessOrderAny` then it indicates that access
    to the source pointer can be out of stream order and the accesses can
    happen even after the API call returns. This flag is suited for host
    pointers allocated outside CUDA (ex., via malloc) when it's known that
    no prior operations in the stream can be accessing the memory.
    Specifying this flag allows the driver to optimize the copy on certain
    platforms. Each memcpy operation in the batch must have a valid
    :py:obj:`~.cudaMemcpyAttributes` corresponding to it including the
    appropriate srcAccessOrder setting, otherwise the API will return
    :py:obj:`~.cudaErrorInvalidValue`.

    The :py:obj:`~.cudaMemcpyAttributes.srcLocHint` and
    :py:obj:`~.cudaMemcpyAttributes.dstLocHint` allows applications to
    specify hint locations for operands of a copy when the operand doesn't
    have a fixed location. That is, these hints are only applicable for
    managed memory pointers on devices where
    :py:obj:`~.cudaDevAttrConcurrentManagedAccess` is true or system-
    allocated pageable memory on devices where
    :py:obj:`~.cudaDevAttrPageableMemoryAccess` is true. For other cases,
    these hints are ignored.

    The :py:obj:`~.cudaMemcpyAttributes.flags` field can be used to specify
    certain flags for copies. Setting the
    :py:obj:`~.cudaMemcpyFlagPreferOverlapWithCompute` flag indicates that
    the associated copies should preferably overlap with any compute work.
    Note that this flag is a hint and can be ignored depending on the
    platform and other parameters of the copy.

    Parameters
    ----------
    dsts : list[Any]
        Array of destination pointers.
    srcs : list[Any]
        Array of memcpy source pointers.
    sizes : list[int]
        Array of sizes for memcpy operations.
    count : size_t
        Size of `dsts`, `srcs` and `sizes` arrays
    attrs : list[:py:obj:`~.cudaMemcpyAttributes`]
        Array of memcpy attributes.
    attrsIdxs : list[int]
        Array of indices to specify which copies each entry in the `attrs`
        array applies to. The attributes specified in attrs[k] will be
        applied to copies starting from attrsIdxs[k] through attrsIdxs[k+1]
        - 1. Also attrs[numAttrs-1] will apply to copies starting from
        attrsIdxs[numAttrs-1] through count - 1.
    numAttrs : size_t
        Size of `attrs` and `attrsIdxs` arrays.
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to enqueue the operations in. Must not be legacy NULL
        stream.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess` :py:obj:`~.cudaErrorInvalidValue`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    if not all(isinstance(_x, (int)) for _x in attrsIdxs):
        raise TypeError("Argument 'attrsIdxs' is not instance of type (expected tuple[int] or list[int]")
    attrs = [] if attrs is None else attrs
    if not all(isinstance(_x, (cudaMemcpyAttributes,)) for _x in attrs):
        raise TypeError("Argument 'attrs' is not instance of type (expected tuple[cyruntime.cudaMemcpyAttributes,] or list[cyruntime.cudaMemcpyAttributes,]")
    if not all(isinstance(_x, (int)) for _x in sizes):
        raise TypeError("Argument 'sizes' is not instance of type (expected tuple[int] or list[int]")
    srcs = [] if srcs is None else srcs
    dsts = [] if dsts is None else dsts
    pylist = [_HelperInputVoidPtr(pydsts) for pydsts in dsts]
    cdef _InputVoidPtrPtrHelper voidStarHelperdsts = _InputVoidPtrPtrHelper(pylist)
    cdef const void** cydsts_ptr = <const void**><void_ptr>voidStarHelperdsts.cptr
    pylist = [_HelperInputVoidPtr(pysrcs) for pysrcs in srcs]
    cdef _InputVoidPtrPtrHelper voidStarHelpersrcs = _InputVoidPtrPtrHelper(pylist)
    cdef const void** cysrcs_ptr = <const void**><void_ptr>voidStarHelpersrcs.cptr
    cdef vector[size_t] cysizes = sizes
    if count > <size_t>len(dsts): raise RuntimeError("List is too small: " + str(len(dsts)) + " < " + str(count))
    if count > <size_t>len(srcs): raise RuntimeError("List is too small: " + str(len(srcs)) + " < " + str(count))
    if count > <size_t>len(sizes): raise RuntimeError("List is too small: " + str(len(sizes)) + " < " + str(count))
    cdef cyruntime.cudaMemcpyAttributes* cyattrs = NULL
    if len(attrs) > 1:
        cyattrs = <cyruntime.cudaMemcpyAttributes*> calloc(len(attrs), sizeof(cyruntime.cudaMemcpyAttributes))
        if cyattrs is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(attrs)) + 'x' + str(sizeof(cyruntime.cudaMemcpyAttributes)))
        for idx in range(len(attrs)):
            string.memcpy(&cyattrs[idx], (<cudaMemcpyAttributes>attrs[idx])._pvt_ptr, sizeof(cyruntime.cudaMemcpyAttributes))
    elif len(attrs) == 1:
        cyattrs = (<cudaMemcpyAttributes>attrs[0])._pvt_ptr
    cdef vector[size_t] cyattrsIdxs = attrsIdxs
    if numAttrs > <size_t>len(attrs): raise RuntimeError("List is too small: " + str(len(attrs)) + " < " + str(numAttrs))
    if numAttrs > <size_t>len(attrsIdxs): raise RuntimeError("List is too small: " + str(len(attrsIdxs)) + " < " + str(numAttrs))
    with nogil:
        err = cyruntime.cudaMemcpyBatchAsync(cydsts_ptr, cysrcs_ptr, cysizes.data(), count, cyattrs, cyattrsIdxs.data(), numAttrs, cystream)
    if len(attrs) > 1 and cyattrs is not NULL:
        free(cyattrs)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpy3DBatchAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpy3DBatchAsync(size_t numOps, opList : Optional[tuple[cudaMemcpy3DBatchOp] | list[cudaMemcpy3DBatchOp]], unsigned long long flags, stream):
    """ Performs a batch of 3D memory copies asynchronously.

    Performs a batch of memory copies. The batch as a whole executes in
    stream order but copies within a batch are not guaranteed to execute in
    any specific order. Note that this means specifying any dependent
    copies within a batch will result in undefined behavior.

    Performs memory copies as specified in the `opList` array. The length
    of this array is specified in `numOps`. Each entry in this array
    describes a copy operation. This includes among other things, the
    source and destination operands for the copy as specified in
    :py:obj:`~.cudaMemcpy3DBatchOp.src` and
    :py:obj:`~.cudaMemcpy3DBatchOp.dst` respectively. The source and
    destination operands of a copy can either be a pointer or a CUDA array.
    The width, height and depth of a copy is specified in
    :py:obj:`~.cudaMemcpy3DBatchOp.extent`. The width, height and depth of
    a copy are specified in elements and must not be zero. For pointer-to-
    pointer copies, the element size is considered to be 1. For pointer to
    CUDA array or vice versa copies, the element size is determined by the
    CUDA array. For CUDA array to CUDA array copies, the element size of
    the two CUDA arrays must match.

    For a given operand, if :py:obj:`~.cudaMemcpy3DOperand`::type is
    specified as :py:obj:`~.cudaMemcpyOperandTypePointer`, then
    :py:obj:`~.cudaMemcpy3DOperand`::op::ptr will be used. The
    :py:obj:`~.cudaMemcpy3DOperand`::op::ptr::ptr field must contain the
    pointer where the copy should begin. The
    :py:obj:`~.cudaMemcpy3DOperand`::op::ptr::rowLength field specifies the
    length of each row in elements and must either be zero or be greater
    than or equal to the width of the copy specified in
    :py:obj:`~.cudaMemcpy3DBatchOp`::extent::width. The
    :py:obj:`~.cudaMemcpy3DOperand`::op::ptr::layerHeight field specifies
    the height of each layer and must either be zero or be greater than or
    equal to the height of the copy specified in
    :py:obj:`~.cudaMemcpy3DBatchOp`::extent::height. When either of these
    values is zero, that aspect of the operand is considered to be tightly
    packed according to the copy extent. For managed memory pointers on
    devices where :py:obj:`~.cudaDevAttrConcurrentManagedAccess` is true or
    system-allocated pageable memory on devices where
    :py:obj:`~.cudaDevAttrPageableMemoryAccess` is true, the
    :py:obj:`~.cudaMemcpy3DOperand`::op::ptr::locHint field can be used to
    hint the location of the operand.

    If an operand's type is specified as
    :py:obj:`~.cudaMemcpyOperandTypeArray`, then
    :py:obj:`~.cudaMemcpy3DOperand`::op::array will be used. The
    :py:obj:`~.cudaMemcpy3DOperand`::op::array::array field specifies the
    CUDA array and :py:obj:`~.cudaMemcpy3DOperand`::op::array::offset
    specifies the 3D offset into that array where the copy begins.

    The :py:obj:`~.cudaMemcpyAttributes.srcAccessOrder` indicates the
    source access ordering to be observed for copies associated with the
    attribute. If the source access order is set to
    :py:obj:`~.cudaMemcpySrcAccessOrderStream`, then the source will be
    accessed in stream order. If the source access order is set to
    :py:obj:`~.cudaMemcpySrcAccessOrderDuringApiCall` then it indicates
    that access to the source pointer can be out of stream order and all
    accesses must be complete before the API call returns. This flag is
    suited for ephemeral sources (ex., stack variables) when it's known
    that no prior operations in the stream can be accessing the memory and
    also that the lifetime of the memory is limited to the scope that the
    source variable was declared in. Specifying this flag allows the driver
    to optimize the copy and removes the need for the user to synchronize
    the stream after the API call. If the source access order is set to
    :py:obj:`~.cudaMemcpySrcAccessOrderAny` then it indicates that access
    to the source pointer can be out of stream order and the accesses can
    happen even after the API call returns. This flag is suited for host
    pointers allocated outside CUDA (ex., via malloc) when it's known that
    no prior operations in the stream can be accessing the memory.
    Specifying this flag allows the driver to optimize the copy on certain
    platforms. Each memcopy operation in `opList` must have a valid
    srcAccessOrder setting, otherwise this API will return
    :py:obj:`~.cudaErrorInvalidValue`.

    The :py:obj:`~.cudaMemcpyAttributes.flags` field can be used to specify
    certain flags for copies. Setting the
    :py:obj:`~.cudaMemcpyFlagPreferOverlapWithCompute` flag indicates that
    the associated copies should preferably overlap with any compute work.
    Note that this flag is a hint and can be ignored depending on the
    platform and other parameters of the copy.

    Parameters
    ----------
    numOps : size_t
        Total number of memcpy operations.
    opList : list[:py:obj:`~.cudaMemcpy3DBatchOp`]
        Array of size `numOps` containing the actual memcpy operations.
    flags : unsigned long long
        Flags for future use, must be zero now.
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to enqueue the operations in. Must not be default NULL
        stream.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess` :py:obj:`~.cudaErrorInvalidValue`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    opList = [] if opList is None else opList
    if not all(isinstance(_x, (cudaMemcpy3DBatchOp,)) for _x in opList):
        raise TypeError("Argument 'opList' is not instance of type (expected tuple[cyruntime.cudaMemcpy3DBatchOp,] or list[cyruntime.cudaMemcpy3DBatchOp,]")
    if numOps > <size_t>len(opList): raise RuntimeError("List is too small: " + str(len(opList)) + " < " + str(numOps))
    cdef cyruntime.cudaMemcpy3DBatchOp* cyopList = NULL
    if len(opList) > 1:
        cyopList = <cyruntime.cudaMemcpy3DBatchOp*> calloc(len(opList), sizeof(cyruntime.cudaMemcpy3DBatchOp))
        if cyopList is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(opList)) + 'x' + str(sizeof(cyruntime.cudaMemcpy3DBatchOp)))
        for idx in range(len(opList)):
            string.memcpy(&cyopList[idx], (<cudaMemcpy3DBatchOp>opList[idx])._pvt_ptr, sizeof(cyruntime.cudaMemcpy3DBatchOp))
    elif len(opList) == 1:
        cyopList = (<cudaMemcpy3DBatchOp>opList[0])._pvt_ptr
    with nogil:
        err = cyruntime.cudaMemcpy3DBatchAsync(numOps, cyopList, flags, cystream)
    if len(opList) > 1 and cyopList is not NULL:
        free(cyopList)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpy2DAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpy2DAsync(dst, size_t dpitch, src, size_t spitch, size_t width, size_t height, kind not None : cudaMemcpyKind, stream):
    """ Copies data between host and device.

    Copies a matrix (`height` rows of `width` bytes each) from the memory
    area pointed to by `src` to the memory area pointed to by `dst`, where
    `kind` specifies the direction of the copy, and must be one of
    :py:obj:`~.cudaMemcpyHostToHost`, :py:obj:`~.cudaMemcpyHostToDevice`,
    :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing. `dpitch` and `spitch` are the widths in
    memory in bytes of the 2D arrays pointed to by `dst` and `src`,
    including any padding added to the end of each row. The memory areas
    may not overlap. `width` must not exceed either `dpitch` or `spitch`.

    Calling :py:obj:`~.cudaMemcpy2DAsync()` with `dst` and `src` pointers
    that do not match the direction of the copy results in an undefined
    behavior. :py:obj:`~.cudaMemcpy2DAsync()` returns an error if `dpitch`
    or `spitch` is greater than the maximum allowed.

    :py:obj:`~.cudaMemcpy2DAsync()` is asynchronous with respect to the
    host, so the call may return before the copy is complete. The copy can
    optionally be associated to a stream by passing a non-zero `stream`
    argument. If `kind` is :py:obj:`~.cudaMemcpyHostToDevice` or
    :py:obj:`~.cudaMemcpyDeviceToHost` and `stream` is non-zero, the copy
    may overlap with operations in other streams.

    The device version of this function only handles device to device
    copies and cannot be given local or shared pointers.

    Parameters
    ----------
    dst : Any
        Destination memory address
    dpitch : size_t
        Pitch of destination memory
    src : Any
        Source memory address
    spitch : size_t
        Pitch of source memory
    width : size_t
        Width of matrix transfer (columns in bytes)
    height : size_t
        Height of matrix transfer (rows)
    kind : :py:obj:`~.cudaMemcpyKind`
        Type of transfer
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidPitchValue`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpy2DFromArray`, :py:obj:`~.cudaMemcpy2DArrayToArray`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`, :py:obj:`~.cudaMemcpy2DFromArrayAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`, :py:obj:`~.cuMemcpy2DAsync`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef _HelperInputVoidPtrStruct cydstHelper
    cdef void* cydst = _helper_input_void_ptr(dst, &cydstHelper)
    cdef _HelperInputVoidPtrStruct cysrcHelper
    cdef void* cysrc = _helper_input_void_ptr(src, &cysrcHelper)
    cdef cyruntime.cudaMemcpyKind cykind = int(kind)
    with nogil:
        err = cyruntime.cudaMemcpy2DAsync(cydst, dpitch, cysrc, spitch, width, height, cykind, cystream)
    _helper_input_void_ptr_free(&cydstHelper)
    _helper_input_void_ptr_free(&cysrcHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpy2DToArrayAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpy2DToArrayAsync(dst, size_t wOffset, size_t hOffset, src, size_t spitch, size_t width, size_t height, kind not None : cudaMemcpyKind, stream):
    """ Copies data between host and device.

    Copies a matrix (`height` rows of `width` bytes each) from the memory
    area pointed to by `src` to the CUDA array `dst` starting at `hOffset`
    rows and `wOffset` bytes from the upper left corner, where `kind`
    specifies the direction of the copy, and must be one of
    :py:obj:`~.cudaMemcpyHostToHost`, :py:obj:`~.cudaMemcpyHostToDevice`,
    :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing. `spitch` is the width in memory in bytes of
    the 2D array pointed to by `src`, including any padding added to the
    end of each row. `wOffset` + `width` must not exceed the width of the
    CUDA array `dst`. `width` must not exceed `spitch`.
    :py:obj:`~.cudaMemcpy2DToArrayAsync()` returns an error if `spitch`
    exceeds the maximum allowed.

    :py:obj:`~.cudaMemcpy2DToArrayAsync()` is asynchronous with respect to
    the host, so the call may return before the copy is complete. The copy
    can optionally be associated to a stream by passing a non-zero `stream`
    argument. If `kind` is :py:obj:`~.cudaMemcpyHostToDevice` or
    :py:obj:`~.cudaMemcpyDeviceToHost` and `stream` is non-zero, the copy
    may overlap with operations in other streams.

    :py:obj:`~.cudaMemcpy2DFromArrayAsync`,
    :py:obj:`~.cudaMemcpyToSymbolAsync`,
    :py:obj:`~.cudaMemcpyFromSymbolAsync`, :py:obj:`~.cuMemcpy2DAsync`

    Parameters
    ----------
    dst : :py:obj:`~.cudaArray_t`
        Destination memory address
    wOffset : size_t
        Destination starting X offset (columns in bytes)
    hOffset : size_t
        Destination starting Y offset (rows)
    src : Any
        Source memory address
    spitch : size_t
        Pitch of source memory
    width : size_t
        Width of matrix transfer (columns in bytes)
    height : size_t
        Height of matrix transfer (rows)
    kind : :py:obj:`~.cudaMemcpyKind`
        Type of transfer
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidPitchValue`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpy2DFromArray`, :py:obj:`~.cudaMemcpy2DArrayToArray`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy2DAsync`,
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaArray_t cydst
    if dst is None:
        pdst = 0
    elif isinstance(dst, (cudaArray_t,)):
        pdst = int(dst)
    else:
        pdst = int(cudaArray_t(dst))
    cydst = <cyruntime.cudaArray_t><void_ptr>pdst
    cdef _HelperInputVoidPtrStruct cysrcHelper
    cdef void* cysrc = _helper_input_void_ptr(src, &cysrcHelper)
    cdef cyruntime.cudaMemcpyKind cykind = int(kind)
    with nogil:
        err = cyruntime.cudaMemcpy2DToArrayAsync(cydst, wOffset, hOffset, cysrc, spitch, width, height, cykind, cystream)
    _helper_input_void_ptr_free(&cysrcHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpy2DFromArrayAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpy2DFromArrayAsync(dst, size_t dpitch, src, size_t wOffset, size_t hOffset, size_t width, size_t height, kind not None : cudaMemcpyKind, stream):
    """ Copies data between host and device.

    Copies a matrix (`height` rows of `width` bytes each) from the CUDA
    array `src` starting at `hOffset` rows and `wOffset` bytes from the
    upper left corner to the memory area pointed to by `dst`, where `kind`
    specifies the direction of the copy, and must be one of
    :py:obj:`~.cudaMemcpyHostToHost`, :py:obj:`~.cudaMemcpyHostToDevice`,
    :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing. `dpitch` is the width in memory in bytes of
    the 2D array pointed to by `dst`, including any padding added to the
    end of each row. `wOffset` + `width` must not exceed the width of the
    CUDA array `src`. `width` must not exceed `dpitch`.
    :py:obj:`~.cudaMemcpy2DFromArrayAsync()` returns an error if `dpitch`
    exceeds the maximum allowed.

    :py:obj:`~.cudaMemcpy2DFromArrayAsync()` is asynchronous with respect
    to the host, so the call may return before the copy is complete. The
    copy can optionally be associated to a stream by passing a non-zero
    `stream` argument. If `kind` is :py:obj:`~.cudaMemcpyHostToDevice` or
    :py:obj:`~.cudaMemcpyDeviceToHost` and `stream` is non-zero, the copy
    may overlap with operations in other streams.

    :py:obj:`~.cudaMemcpyToSymbolAsync`,
    :py:obj:`~.cudaMemcpyFromSymbolAsync`, :py:obj:`~.cuMemcpy2DAsync`

    Parameters
    ----------
    dst : Any
        Destination memory address
    dpitch : size_t
        Pitch of destination memory
    src : :py:obj:`~.cudaArray_const_t`
        Source memory address
    wOffset : size_t
        Source starting X offset (columns in bytes)
    hOffset : size_t
        Source starting Y offset (rows)
    width : size_t
        Width of matrix transfer (columns in bytes)
    height : size_t
        Height of matrix transfer (rows)
    kind : :py:obj:`~.cudaMemcpyKind`
        Type of transfer
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidPitchValue`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpy2DFromArray`, :py:obj:`~.cudaMemcpy2DArrayToArray`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy2DAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`,
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaArray_const_t cysrc
    if src is None:
        psrc = 0
    elif isinstance(src, (cudaArray_const_t,)):
        psrc = int(src)
    else:
        psrc = int(cudaArray_const_t(src))
    cysrc = <cyruntime.cudaArray_const_t><void_ptr>psrc
    cdef _HelperInputVoidPtrStruct cydstHelper
    cdef void* cydst = _helper_input_void_ptr(dst, &cydstHelper)
    cdef cyruntime.cudaMemcpyKind cykind = int(kind)
    with nogil:
        err = cyruntime.cudaMemcpy2DFromArrayAsync(cydst, dpitch, cysrc, wOffset, hOffset, width, height, cykind, cystream)
    _helper_input_void_ptr_free(&cydstHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemset' in found_functions}}

@cython.embedsignature(True)
def cudaMemset(devPtr, int value, size_t count):
    """ Initializes or sets device memory to a value.

    Fills the first `count` bytes of the memory area pointed to by `devPtr`
    with the constant byte value `value`.

    Note that this function is asynchronous with respect to the host unless
    `devPtr` refers to pinned host memory.

    Parameters
    ----------
    devPtr : Any
        Pointer to device memory
    value : int
        Value to set for each byte of specified memory
    count : size_t
        Size in bytes to set

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`
    """
    cdef _HelperInputVoidPtrStruct cydevPtrHelper
    cdef void* cydevPtr = _helper_input_void_ptr(devPtr, &cydevPtrHelper)
    with nogil:
        err = cyruntime.cudaMemset(cydevPtr, value, count)
    _helper_input_void_ptr_free(&cydevPtrHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemset2D' in found_functions}}

@cython.embedsignature(True)
def cudaMemset2D(devPtr, size_t pitch, int value, size_t width, size_t height):
    """ Initializes or sets device memory to a value.

    Sets to the specified value `value` a matrix (`height` rows of `width`
    bytes each) pointed to by `dstPtr`. `pitch` is the width in bytes of
    the 2D array pointed to by `dstPtr`, including any padding added to the
    end of each row. This function performs fastest when the pitch is one
    that has been passed back by :py:obj:`~.cudaMallocPitch()`.

    Note that this function is asynchronous with respect to the host unless
    `devPtr` refers to pinned host memory.

    Parameters
    ----------
    devPtr : Any
        Pointer to 2D device memory
    pitch : size_t
        Pitch in bytes of 2D device memory(Unused if `height` is 1)
    value : int
        Value to set for each byte of specified memory
    width : size_t
        Width of matrix set (columns in bytes)
    height : size_t
        Height of matrix set (rows)

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cudaMemset`, :py:obj:`~.cudaMemset3D`, :py:obj:`~.cudaMemsetAsync`, :py:obj:`~.cudaMemset2DAsync`, :py:obj:`~.cudaMemset3DAsync`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`
    """
    cdef _HelperInputVoidPtrStruct cydevPtrHelper
    cdef void* cydevPtr = _helper_input_void_ptr(devPtr, &cydevPtrHelper)
    with nogil:
        err = cyruntime.cudaMemset2D(cydevPtr, pitch, value, width, height)
    _helper_input_void_ptr_free(&cydevPtrHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemset3D' in found_functions}}

@cython.embedsignature(True)
def cudaMemset3D(pitchedDevPtr not None : cudaPitchedPtr, int value, extent not None : cudaExtent):
    """ Initializes or sets device memory to a value.

    Initializes each element of a 3D array to the specified value `value`.
    The object to initialize is defined by `pitchedDevPtr`. The `pitch`
    field of `pitchedDevPtr` is the width in memory in bytes of the 3D
    array pointed to by `pitchedDevPtr`, including any padding added to the
    end of each row. The `xsize` field specifies the logical width of each
    row in bytes, while the `ysize` field specifies the height of each 2D
    slice in rows. The `pitch` field of `pitchedDevPtr` is ignored when
    `height` and `depth` are both equal to 1.

    The extents of the initialized region are specified as a `width` in
    bytes, a `height` in rows, and a `depth` in slices.

    Extents with `width` greater than or equal to the `xsize` of
    `pitchedDevPtr` may perform significantly faster than extents narrower
    than the `xsize`. Secondarily, extents with `height` equal to the
    `ysize` of `pitchedDevPtr` will perform faster than when the `height`
    is shorter than the `ysize`.

    This function performs fastest when the `pitchedDevPtr` has been
    allocated by :py:obj:`~.cudaMalloc3D()`.

    Note that this function is asynchronous with respect to the host unless
    `pitchedDevPtr` refers to pinned host memory.

    Parameters
    ----------
    pitchedDevPtr : :py:obj:`~.cudaPitchedPtr`
        Pointer to pitched device memory
    value : int
        Value to set for each byte of specified memory
    extent : :py:obj:`~.cudaExtent`
        Size parameters for where to set device memory (`width` field in
        bytes)

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cudaMemset`, :py:obj:`~.cudaMemset2D`, :py:obj:`~.cudaMemsetAsync`, :py:obj:`~.cudaMemset2DAsync`, :py:obj:`~.cudaMemset3DAsync`, :py:obj:`~.cudaMalloc3D`, :py:obj:`~.make_cudaPitchedPtr`, :py:obj:`~.make_cudaExtent`
    """
    with nogil:
        err = cyruntime.cudaMemset3D(pitchedDevPtr._pvt_ptr[0], value, extent._pvt_ptr[0])
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemsetAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemsetAsync(devPtr, int value, size_t count, stream):
    """ Initializes or sets device memory to a value.

    Fills the first `count` bytes of the memory area pointed to by `devPtr`
    with the constant byte value `value`.

    :py:obj:`~.cudaMemsetAsync()` is asynchronous with respect to the host,
    so the call may return before the memset is complete. The operation can
    optionally be associated to a stream by passing a non-zero `stream`
    argument. If `stream` is non-zero, the operation may overlap with
    operations in other streams.

    The device version of this function only handles device to device
    copies and cannot be given local or shared pointers.

    Parameters
    ----------
    devPtr : Any
        Pointer to device memory
    value : int
        Value to set for each byte of specified memory
    count : size_t
        Size in bytes to set
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cudaMemset`, :py:obj:`~.cudaMemset2D`, :py:obj:`~.cudaMemset3D`, :py:obj:`~.cudaMemset2DAsync`, :py:obj:`~.cudaMemset3DAsync`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32Async`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef _HelperInputVoidPtrStruct cydevPtrHelper
    cdef void* cydevPtr = _helper_input_void_ptr(devPtr, &cydevPtrHelper)
    with nogil:
        err = cyruntime.cudaMemsetAsync(cydevPtr, value, count, cystream)
    _helper_input_void_ptr_free(&cydevPtrHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemset2DAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemset2DAsync(devPtr, size_t pitch, int value, size_t width, size_t height, stream):
    """ Initializes or sets device memory to a value.

    Sets to the specified value `value` a matrix (`height` rows of `width`
    bytes each) pointed to by `dstPtr`. `pitch` is the width in bytes of
    the 2D array pointed to by `dstPtr`, including any padding added to the
    end of each row. This function performs fastest when the pitch is one
    that has been passed back by :py:obj:`~.cudaMallocPitch()`.

    :py:obj:`~.cudaMemset2DAsync()` is asynchronous with respect to the
    host, so the call may return before the memset is complete. The
    operation can optionally be associated to a stream by passing a non-
    zero `stream` argument. If `stream` is non-zero, the operation may
    overlap with operations in other streams.

    The device version of this function only handles device to device
    copies and cannot be given local or shared pointers.

    Parameters
    ----------
    devPtr : Any
        Pointer to 2D device memory
    pitch : size_t
        Pitch in bytes of 2D device memory(Unused if `height` is 1)
    value : int
        Value to set for each byte of specified memory
    width : size_t
        Width of matrix set (columns in bytes)
    height : size_t
        Height of matrix set (rows)
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cudaMemset`, :py:obj:`~.cudaMemset2D`, :py:obj:`~.cudaMemset3D`, :py:obj:`~.cudaMemsetAsync`, :py:obj:`~.cudaMemset3DAsync`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32Async`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef _HelperInputVoidPtrStruct cydevPtrHelper
    cdef void* cydevPtr = _helper_input_void_ptr(devPtr, &cydevPtrHelper)
    with nogil:
        err = cyruntime.cudaMemset2DAsync(cydevPtr, pitch, value, width, height, cystream)
    _helper_input_void_ptr_free(&cydevPtrHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemset3DAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemset3DAsync(pitchedDevPtr not None : cudaPitchedPtr, int value, extent not None : cudaExtent, stream):
    """ Initializes or sets device memory to a value.

    Initializes each element of a 3D array to the specified value `value`.
    The object to initialize is defined by `pitchedDevPtr`. The `pitch`
    field of `pitchedDevPtr` is the width in memory in bytes of the 3D
    array pointed to by `pitchedDevPtr`, including any padding added to the
    end of each row. The `xsize` field specifies the logical width of each
    row in bytes, while the `ysize` field specifies the height of each 2D
    slice in rows. The `pitch` field of `pitchedDevPtr` is ignored when
    `height` and `depth` are both equal to 1.

    The extents of the initialized region are specified as a `width` in
    bytes, a `height` in rows, and a `depth` in slices.

    Extents with `width` greater than or equal to the `xsize` of
    `pitchedDevPtr` may perform significantly faster than extents narrower
    than the `xsize`. Secondarily, extents with `height` equal to the
    `ysize` of `pitchedDevPtr` will perform faster than when the `height`
    is shorter than the `ysize`.

    This function performs fastest when the `pitchedDevPtr` has been
    allocated by :py:obj:`~.cudaMalloc3D()`.

    :py:obj:`~.cudaMemset3DAsync()` is asynchronous with respect to the
    host, so the call may return before the memset is complete. The
    operation can optionally be associated to a stream by passing a non-
    zero `stream` argument. If `stream` is non-zero, the operation may
    overlap with operations in other streams.

    The device version of this function only handles device to device
    copies and cannot be given local or shared pointers.

    Parameters
    ----------
    pitchedDevPtr : :py:obj:`~.cudaPitchedPtr`
        Pointer to pitched device memory
    value : int
        Value to set for each byte of specified memory
    extent : :py:obj:`~.cudaExtent`
        Size parameters for where to set device memory (`width` field in
        bytes)
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cudaMemset`, :py:obj:`~.cudaMemset2D`, :py:obj:`~.cudaMemset3D`, :py:obj:`~.cudaMemsetAsync`, :py:obj:`~.cudaMemset2DAsync`, :py:obj:`~.cudaMalloc3D`, :py:obj:`~.make_cudaPitchedPtr`, :py:obj:`~.make_cudaExtent`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    with nogil:
        err = cyruntime.cudaMemset3DAsync(pitchedDevPtr._pvt_ptr[0], value, extent._pvt_ptr[0], cystream)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemPrefetchAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemPrefetchAsync(devPtr, size_t count, location not None : cudaMemLocation, unsigned int flags, stream):
    """ Prefetches memory to the specified destination location.

    Prefetches memory to the specified destination location. `devPtr` is
    the base device pointer of the memory to be prefetched and `location`
    specifies the destination location. `count` specifies the number of
    bytes to copy. `stream` is the stream in which the operation is
    enqueued. The memory range must refer to managed memory allocated via
    :py:obj:`~.cudaMallocManaged` or declared via managed variables, or it
    may also refer to memory allocated from a managed memory pool, or it
    may also refer to system-allocated memory on systems with non-zero
    cudaDevAttrPageableMemoryAccess.

    Specifying :py:obj:`~.cudaMemLocationTypeDevice` for
    :py:obj:`~.cudaMemLocation.type` will prefetch memory to GPU specified
    by device ordinal :py:obj:`~.cudaMemLocation.id` which must have non-
    zero value for the device attribute
    :py:obj:`~.concurrentManagedAccess`. Additionally, `stream` must be
    associated with a device that has a non-zero value for the device
    attribute :py:obj:`~.concurrentManagedAccess`. Specifying
    :py:obj:`~.cudaMemLocationTypeHost` as :py:obj:`~.cudaMemLocation.type`
    will prefetch data to host memory. Applications can request prefetching
    memory to a specific host NUMA node by specifying
    :py:obj:`~.cudaMemLocationTypeHostNuma` for
    :py:obj:`~.cudaMemLocation.type` and a valid host NUMA node id in
    :py:obj:`~.cudaMemLocation.id` Users can also request prefetching
    memory to the host NUMA node closest to the current thread's CPU by
    specifying :py:obj:`~.cudaMemLocationTypeHostNumaCurrent` for
    :py:obj:`~.cudaMemLocation.type`. Note when
    :py:obj:`~.cudaMemLocation.type` is etiher
    :py:obj:`~.cudaMemLocationTypeHost` OR
    :py:obj:`~.cudaMemLocationTypeHostNumaCurrent`,
    :py:obj:`~.cudaMemLocation.id` will be ignored.

    The start address and end address of the memory range will be rounded
    down and rounded up respectively to be aligned to CPU page size before
    the prefetch operation is enqueued in the stream.

    If no physical memory has been allocated for this region, then this
    memory region will be populated and mapped on the destination device.
    If there's insufficient memory to prefetch the desired region, the
    Unified Memory driver may evict pages from other
    :py:obj:`~.cudaMallocManaged` allocations to host memory in order to
    make room. Device memory allocated using :py:obj:`~.cudaMalloc` or
    :py:obj:`~.cudaMallocArray` will not be evicted.

    By default, any mappings to the previous location of the migrated pages
    are removed and mappings for the new location are only setup on the
    destination location. The exact behavior however also depends on the
    settings applied to this memory range via :py:obj:`~.cuMemAdvise` as
    described below:

    If :py:obj:`~.cudaMemAdviseSetReadMostly` was set on any subset of this
    memory range, then that subset will create a read-only copy of the
    pages on destination location. If however the destination location is a
    host NUMA node, then any pages of that subset that are already in
    another host NUMA node will be transferred to the destination.

    If :py:obj:`~.cudaMemAdviseSetPreferredLocation` was called on any
    subset of this memory range, then the pages will be migrated to
    `location` even if `location` is not the preferred location of any
    pages in the memory range.

    If :py:obj:`~.cudaMemAdviseSetAccessedBy` was called on any subset of
    this memory range, then mappings to those pages from all the
    appropriate processors are updated to refer to the new location if
    establishing such a mapping is possible. Otherwise, those mappings are
    cleared.

    Note that this API is not required for functionality and only serves to
    improve performance by allowing the application to migrate data to a
    suitable location before it is accessed. Memory accesses to this range
    are always coherent and are allowed even when the data is actively
    being migrated.

    Note that this function is asynchronous with respect to the host and
    all work on other devices.

    Parameters
    ----------
    devPtr : Any
        Pointer to be prefetched
    count : size_t
        Size in bytes
    location : :py:obj:`~.cudaMemLocation`
        location to prefetch to
    flags : unsigned int
        flags for future use, must be zero now.
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to enqueue prefetch operation

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidDevice`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyPeer`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy3DPeerAsync`, :py:obj:`~.cudaMemAdvise`, :py:obj:`~.cuMemPrefetchAsync`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef _HelperInputVoidPtrStruct cydevPtrHelper
    cdef void* cydevPtr = _helper_input_void_ptr(devPtr, &cydevPtrHelper)
    with nogil:
        err = cyruntime.cudaMemPrefetchAsync(cydevPtr, count, location._pvt_ptr[0], flags, cystream)
    _helper_input_void_ptr_free(&cydevPtrHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemPrefetchBatchAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemPrefetchBatchAsync(dptrs : Optional[tuple[Any] | list[Any]], sizes : tuple[int] | list[int], size_t count, prefetchLocs : Optional[tuple[cudaMemLocation] | list[cudaMemLocation]], prefetchLocIdxs : tuple[int] | list[int], size_t numPrefetchLocs, unsigned long long flags, stream):
    """ Performs a batch of memory prefetches asynchronously.

    Performs a batch of memory prefetches. The batch as a whole executes in
    stream order but operations within a batch are not guaranteed to
    execute in any specific order. All devices in the system must have a
    non-zero value for the device attribute
    :py:obj:`~.cudaDevAttrConcurrentManagedAccess` otherwise the API will
    return an error.

    The semantics of the individual prefetch operations are as described in
    :py:obj:`~.cudaMemPrefetchAsync`.

    Performs memory prefetch on address ranges specified in `dptrs` and
    `sizes`. Both arrays must be of the same length as specified by
    `count`. Each memory range specified must refer to managed memory
    allocated via :py:obj:`~.cudaMallocManaged` or declared via managed
    variables or it may also refer to system-allocated memory when all
    devices have a non-zero value for
    :py:obj:`~.cudaDevAttrPageableMemoryAccess`. The prefetch location for
    every operation in the batch is specified in the `prefetchLocs` array.
    Each entry in this array can apply to more than one operation. This can
    be done by specifying in the `prefetchLocIdxs` array, the index of the
    first prefetch operation that the corresponding entry in the
    `prefetchLocs` array applies to. Both `prefetchLocs` and
    `prefetchLocIdxs` must be of the same length as specified by
    `numPrefetchLocs`. For example, if a batch has 10 prefetches listed in
    dptrs/sizes, the first 4 of which are to be prefetched to one location
    and the remaining 6 are to be prefetched to another, then
    `numPrefetchLocs` will be 2, `prefetchLocIdxs` will be {0, 4} and
    `prefetchLocs` will contain the two locations. Note the first entry in
    `prefetchLocIdxs` must always be 0. Also, each entry must be greater
    than the previous entry and the last entry should be less than `count`.
    Furthermore, `numPrefetchLocs` must be lesser than or equal to `count`.

    Parameters
    ----------
    dptrs : list[Any]
        Array of pointers to be prefetched
    sizes : list[int]
        Array of sizes for memory prefetch operations.
    count : size_t
        Size of `dptrs` and `sizes` arrays.
    prefetchLocs : list[:py:obj:`~.cudaMemLocation`]
        Array of locations to prefetch to.
    prefetchLocIdxs : list[int]
        Array of indices to specify which operands each entry in the
        `prefetchLocs` array applies to. The locations specified in
        prefetchLocs[k] will be applied to copies starting from
        prefetchLocIdxs[k] through prefetchLocIdxs[k+1] - 1. Also
        prefetchLocs[numPrefetchLocs - 1] will apply to prefetches starting
        from prefetchLocIdxs[numPrefetchLocs - 1] through count - 1.
    numPrefetchLocs : size_t
        Size of `prefetchLocs` and `prefetchLocIdxs` arrays.
    flags : unsigned long long
        Flags reserved for future use. Must be zero.
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to enqueue the operations in. Must not be legacy NULL
        stream.

    Returns
    -------
    cudaError_t

    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    if not all(isinstance(_x, (int)) for _x in prefetchLocIdxs):
        raise TypeError("Argument 'prefetchLocIdxs' is not instance of type (expected tuple[int] or list[int]")
    prefetchLocs = [] if prefetchLocs is None else prefetchLocs
    if not all(isinstance(_x, (cudaMemLocation,)) for _x in prefetchLocs):
        raise TypeError("Argument 'prefetchLocs' is not instance of type (expected tuple[cyruntime.cudaMemLocation,] or list[cyruntime.cudaMemLocation,]")
    if not all(isinstance(_x, (int)) for _x in sizes):
        raise TypeError("Argument 'sizes' is not instance of type (expected tuple[int] or list[int]")
    dptrs = [] if dptrs is None else dptrs
    pylist = [_HelperInputVoidPtr(pydptrs) for pydptrs in dptrs]
    cdef _InputVoidPtrPtrHelper voidStarHelperdptrs = _InputVoidPtrPtrHelper(pylist)
    cdef void** cydptrs_ptr = <void**><void_ptr>voidStarHelperdptrs.cptr
    cdef vector[size_t] cysizes = sizes
    if count > <size_t>len(dptrs): raise RuntimeError("List is too small: " + str(len(dptrs)) + " < " + str(count))
    if count > <size_t>len(sizes): raise RuntimeError("List is too small: " + str(len(sizes)) + " < " + str(count))
    cdef cyruntime.cudaMemLocation* cyprefetchLocs = NULL
    if len(prefetchLocs) > 1:
        cyprefetchLocs = <cyruntime.cudaMemLocation*> calloc(len(prefetchLocs), sizeof(cyruntime.cudaMemLocation))
        if cyprefetchLocs is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(prefetchLocs)) + 'x' + str(sizeof(cyruntime.cudaMemLocation)))
        for idx in range(len(prefetchLocs)):
            string.memcpy(&cyprefetchLocs[idx], (<cudaMemLocation>prefetchLocs[idx])._pvt_ptr, sizeof(cyruntime.cudaMemLocation))
    elif len(prefetchLocs) == 1:
        cyprefetchLocs = (<cudaMemLocation>prefetchLocs[0])._pvt_ptr
    cdef vector[size_t] cyprefetchLocIdxs = prefetchLocIdxs
    if numPrefetchLocs > <size_t>len(prefetchLocs): raise RuntimeError("List is too small: " + str(len(prefetchLocs)) + " < " + str(numPrefetchLocs))
    if numPrefetchLocs > <size_t>len(prefetchLocIdxs): raise RuntimeError("List is too small: " + str(len(prefetchLocIdxs)) + " < " + str(numPrefetchLocs))
    with nogil:
        err = cyruntime.cudaMemPrefetchBatchAsync(cydptrs_ptr, cysizes.data(), count, cyprefetchLocs, cyprefetchLocIdxs.data(), numPrefetchLocs, flags, cystream)
    if len(prefetchLocs) > 1 and cyprefetchLocs is not NULL:
        free(cyprefetchLocs)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemDiscardBatchAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemDiscardBatchAsync(dptrs : Optional[tuple[Any] | list[Any]], sizes : tuple[int] | list[int], size_t count, unsigned long long flags, stream):
    """ Performs a batch of memory discards asynchronously.

    Performs a batch of memory discards. The batch as a whole executes in
    stream order but operations within a batch are not guaranteed to
    execute in any specific order. All devices in the system must have a
    non-zero value for the device attribute
    :py:obj:`~.cudaDevAttrConcurrentManagedAccess` otherwise the API will
    return an error.

    Discarding a memory range informs the driver that the contents of that
    range are no longer useful. Discarding memory ranges allows the driver
    to optimize certain data migrations and can also help reduce memory
    pressure. This operation can be undone on any part of the range by
    either writing to it or prefetching it via
    :py:obj:`~.cudaMemPrefetchAsync` or
    :py:obj:`~.cudaMemPrefetchBatchAsync`. Reading from a discarded range,
    without a subsequent write or prefetch to that part of the range, will
    return an indeterminate value. Note that any reads, writes or
    prefetches to any part of the memory range that occur simultaneously
    with the discard operation result in undefined behavior.

    Performs memory discard on address ranges specified in `dptrs` and
    `sizes`. Both arrays must be of the same length as specified by
    `count`. Each memory range specified must refer to managed memory
    allocated via :py:obj:`~.cudaMallocManaged` or declared via managed
    variables or it may also refer to system-allocated memory when all
    devices have a non-zero value for
    :py:obj:`~.cudaDevAttrPageableMemoryAccess`.

    Parameters
    ----------
    dptrs : list[Any]
        Array of pointers to be discarded
    sizes : list[int]
        Array of sizes for memory discard operations.
    count : size_t
        Size of `dptrs` and `sizes` arrays.
    flags : unsigned long long
        Flags reserved for future use. Must be zero.
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to enqueue the operations in. Must not be legacy NULL
        stream.

    Returns
    -------
    cudaError_t

    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    if not all(isinstance(_x, (int)) for _x in sizes):
        raise TypeError("Argument 'sizes' is not instance of type (expected tuple[int] or list[int]")
    dptrs = [] if dptrs is None else dptrs
    pylist = [_HelperInputVoidPtr(pydptrs) for pydptrs in dptrs]
    cdef _InputVoidPtrPtrHelper voidStarHelperdptrs = _InputVoidPtrPtrHelper(pylist)
    cdef void** cydptrs_ptr = <void**><void_ptr>voidStarHelperdptrs.cptr
    cdef vector[size_t] cysizes = sizes
    if count > <size_t>len(dptrs): raise RuntimeError("List is too small: " + str(len(dptrs)) + " < " + str(count))
    if count > <size_t>len(sizes): raise RuntimeError("List is too small: " + str(len(sizes)) + " < " + str(count))
    with nogil:
        err = cyruntime.cudaMemDiscardBatchAsync(cydptrs_ptr, cysizes.data(), count, flags, cystream)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemDiscardAndPrefetchBatchAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemDiscardAndPrefetchBatchAsync(dptrs : Optional[tuple[Any] | list[Any]], sizes : tuple[int] | list[int], size_t count, prefetchLocs : Optional[tuple[cudaMemLocation] | list[cudaMemLocation]], prefetchLocIdxs : tuple[int] | list[int], size_t numPrefetchLocs, unsigned long long flags, stream):
    """ Performs a batch of memory discards and prefetches asynchronously.

    Performs a batch of memory discards followed by prefetches. The batch
    as a whole executes in stream order but operations within a batch are
    not guaranteed to execute in any specific order. All devices in the
    system must have a non-zero value for the device attribute
    :py:obj:`~.cudaDevAttrConcurrentManagedAccess` otherwise the API will
    return an error.

    Calling :py:obj:`~.cudaMemDiscardAndPrefetchBatchAsync` is semantically
    equivalent to calling :py:obj:`~.cudaMemDiscardBatchAsync` followed by
    :py:obj:`~.cudaMemPrefetchBatchAsync`, but is more optimal. For more
    details on what discarding and prefetching imply, please refer to
    :py:obj:`~.cudaMemDiscardBatchAsync` and
    :py:obj:`~.cudaMemPrefetchBatchAsync` respectively. Note that any
    reads, writes or prefetches to any part of the memory range that occur
    simultaneously with this combined discard+prefetch operation result in
    undefined behavior.

    Performs memory discard and prefetch on address ranges specified in
    `dptrs` and `sizes`. Both arrays must be of the same length as
    specified by `count`. Each memory range specified must refer to managed
    memory allocated via :py:obj:`~.cudaMallocManaged` or declared via
    managed variables or it may also refer to system-allocated memory when
    all devices have a non-zero value for
    :py:obj:`~.cudaDevAttrPageableMemoryAccess`. Every operation in the
    batch has to be associated with a valid location to prefetch the
    address range to and specified in the `prefetchLocs` array. Each entry
    in this array can apply to more than one operation. This can be done by
    specifying in the `prefetchLocIdxs` array, the index of the first
    operation that the corresponding entry in the `prefetchLocs` array
    applies to. Both `prefetchLocs` and `prefetchLocIdxs` must be of the
    same length as specified by `numPrefetchLocs`. For example, if a batch
    has 10 operations listed in dptrs/sizes, the first 6 of which are to be
    prefetched to one location and the remaining 4 are to be prefetched to
    another, then `numPrefetchLocs` will be 2, `prefetchLocIdxs` will be
    {0, 6} and `prefetchLocs` will contain the two set of locations. Note
    the first entry in `prefetchLocIdxs` must always be 0. Also, each entry
    must be greater than the previous entry and the last entry should be
    less than `count`. Furthermore, `numPrefetchLocs` must be lesser than
    or equal to `count`.

    Parameters
    ----------
    dptrs : list[Any]
        Array of pointers to be discarded
    sizes : list[int]
        Array of sizes for memory discard operations.
    count : size_t
        Size of `dptrs` and `sizes` arrays.
    prefetchLocs : list[:py:obj:`~.cudaMemLocation`]
        Array of locations to prefetch to.
    prefetchLocIdxs : list[int]
        Array of indices to specify which operands each entry in the
        `prefetchLocs` array applies to. The locations specified in
        prefetchLocs[k] will be applied to operations starting from
        prefetchLocIdxs[k] through prefetchLocIdxs[k+1] - 1. Also
        prefetchLocs[numPrefetchLocs - 1] will apply to copies starting
        from prefetchLocIdxs[numPrefetchLocs - 1] through count - 1.
    numPrefetchLocs : size_t
        Size of `prefetchLocs` and `prefetchLocIdxs` arrays.
    flags : unsigned long long
        Flags reserved for future use. Must be zero.
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to enqueue the operations in. Must not be legacy NULL
        stream.

    Returns
    -------
    cudaError_t

    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    if not all(isinstance(_x, (int)) for _x in prefetchLocIdxs):
        raise TypeError("Argument 'prefetchLocIdxs' is not instance of type (expected tuple[int] or list[int]")
    prefetchLocs = [] if prefetchLocs is None else prefetchLocs
    if not all(isinstance(_x, (cudaMemLocation,)) for _x in prefetchLocs):
        raise TypeError("Argument 'prefetchLocs' is not instance of type (expected tuple[cyruntime.cudaMemLocation,] or list[cyruntime.cudaMemLocation,]")
    if not all(isinstance(_x, (int)) for _x in sizes):
        raise TypeError("Argument 'sizes' is not instance of type (expected tuple[int] or list[int]")
    dptrs = [] if dptrs is None else dptrs
    pylist = [_HelperInputVoidPtr(pydptrs) for pydptrs in dptrs]
    cdef _InputVoidPtrPtrHelper voidStarHelperdptrs = _InputVoidPtrPtrHelper(pylist)
    cdef void** cydptrs_ptr = <void**><void_ptr>voidStarHelperdptrs.cptr
    cdef vector[size_t] cysizes = sizes
    if count > <size_t>len(dptrs): raise RuntimeError("List is too small: " + str(len(dptrs)) + " < " + str(count))
    if count > <size_t>len(sizes): raise RuntimeError("List is too small: " + str(len(sizes)) + " < " + str(count))
    cdef cyruntime.cudaMemLocation* cyprefetchLocs = NULL
    if len(prefetchLocs) > 1:
        cyprefetchLocs = <cyruntime.cudaMemLocation*> calloc(len(prefetchLocs), sizeof(cyruntime.cudaMemLocation))
        if cyprefetchLocs is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(prefetchLocs)) + 'x' + str(sizeof(cyruntime.cudaMemLocation)))
        for idx in range(len(prefetchLocs)):
            string.memcpy(&cyprefetchLocs[idx], (<cudaMemLocation>prefetchLocs[idx])._pvt_ptr, sizeof(cyruntime.cudaMemLocation))
    elif len(prefetchLocs) == 1:
        cyprefetchLocs = (<cudaMemLocation>prefetchLocs[0])._pvt_ptr
    cdef vector[size_t] cyprefetchLocIdxs = prefetchLocIdxs
    if numPrefetchLocs > <size_t>len(prefetchLocs): raise RuntimeError("List is too small: " + str(len(prefetchLocs)) + " < " + str(numPrefetchLocs))
    if numPrefetchLocs > <size_t>len(prefetchLocIdxs): raise RuntimeError("List is too small: " + str(len(prefetchLocIdxs)) + " < " + str(numPrefetchLocs))
    with nogil:
        err = cyruntime.cudaMemDiscardAndPrefetchBatchAsync(cydptrs_ptr, cysizes.data(), count, cyprefetchLocs, cyprefetchLocIdxs.data(), numPrefetchLocs, flags, cystream)
    if len(prefetchLocs) > 1 and cyprefetchLocs is not NULL:
        free(cyprefetchLocs)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemAdvise' in found_functions}}

@cython.embedsignature(True)
def cudaMemAdvise(devPtr, size_t count, advice not None : cudaMemoryAdvise, location not None : cudaMemLocation):
    """ Advise about the usage of a given memory range.

    Advise the Unified Memory subsystem about the usage pattern for the
    memory range starting at `devPtr` with a size of `count` bytes. The
    start address and end address of the memory range will be rounded down
    and rounded up respectively to be aligned to CPU page size before the
    advice is applied. The memory range must refer to managed memory
    allocated via :py:obj:`~.cudaMallocManaged` or declared via managed
    variables. The memory range could also refer to system-allocated
    pageable memory provided it represents a valid, host-accessible region
    of memory and all additional constraints imposed by `advice` as
    outlined below are also satisfied. Specifying an invalid system-
    allocated pageable memory range results in an error being returned.

    The `advice` parameter can take the following values:

    - :py:obj:`~.cudaMemAdviseSetReadMostly`: This implies that the data is
      mostly going to be read from and only occasionally written to. Any
      read accesses from any processor to this region will create a read-
      only copy of at least the accessed pages in that processor's memory.
      Additionally, if :py:obj:`~.cudaMemPrefetchAsync` or
      :py:obj:`~.cudaMemPrefetchAsync` is called on this region, it will
      create a read-only copy of the data on the destination processor. If
      the target location for :py:obj:`~.cudaMemPrefetchAsync` is a host
      NUMA node and a read-only copy already exists on another host NUMA
      node, that copy will be migrated to the targeted host NUMA node. If
      any processor writes to this region, all copies of the corresponding
      page will be invalidated except for the one where the write occurred.
      If the writing processor is the CPU and the preferred location of the
      page is a host NUMA node, then the page will also be migrated to that
      host NUMA node. The `location` argument is ignored for this advice.
      Note that for a page to be read-duplicated, the accessing processor
      must either be the CPU or a GPU that has a non-zero value for the
      device attribute :py:obj:`~.cudaDevAttrConcurrentManagedAccess`.
      Also, if a context is created on a device that does not have the
      device attribute :py:obj:`~.cudaDevAttrConcurrentManagedAccess` set,
      then read-duplication will not occur until all such contexts are
      destroyed. If the memory region refers to valid system-allocated
      pageable memory, then the accessing device must have a non-zero value
      for the device attribute :py:obj:`~.cudaDevAttrPageableMemoryAccess`
      for a read-only copy to be created on that device. Note however that
      if the accessing device also has a non-zero value for the device
      attribute
      :py:obj:`~.cudaDevAttrPageableMemoryAccessUsesHostPageTables`, then
      setting this advice will not create a read-only copy when that device
      accesses this memory region.

    - :py:obj:`~.cudaMemAdviceUnsetReadMostly`: Undoes the effect of
      :py:obj:`~.cudaMemAdviseSetReadMostly` and also prevents the Unified
      Memory driver from attempting heuristic read-duplication on the
      memory range. Any read-duplicated copies of the data will be
      collapsed into a single copy. The location for the collapsed copy
      will be the preferred location if the page has a preferred location
      and one of the read-duplicated copies was resident at that location.
      Otherwise, the location chosen is arbitrary. Note: The `location`
      argument is ignored for this advice.

    - :py:obj:`~.cudaMemAdviseSetPreferredLocation`: This advice sets the
      preferred location for the data to be the memory belonging to
      `location`. When :py:obj:`~.cudaMemLocation.type` is
      :py:obj:`~.cudaMemLocationTypeHost`, :py:obj:`~.cudaMemLocation.id`
      is ignored and the preferred location is set to be host memory. To
      set the preferred location to a specific host NUMA node, applications
      must set :py:obj:`~.cudaMemLocation.type` to
      :py:obj:`~.cudaMemLocationTypeHostNuma` and
      :py:obj:`~.cudaMemLocation.id` must specify the NUMA ID of the host
      NUMA node. If :py:obj:`~.cudaMemLocation.type` is set to
      :py:obj:`~.cudaMemLocationTypeHostNumaCurrent`,
      :py:obj:`~.cudaMemLocation.id` will be ignored and the host NUMA node
      closest to the calling thread's CPU will be used as the preferred
      location. If :py:obj:`~.cudaMemLocation.type` is a
      :py:obj:`~.cudaMemLocationTypeDevice`, then
      :py:obj:`~.cudaMemLocation.id` must be a valid device ordinal and the
      device must have a non-zero value for the device attribute
      :py:obj:`~.cudaDevAttrConcurrentManagedAccess`. Setting the preferred
      location does not cause data to migrate to that location immediately.
      Instead, it guides the migration policy when a fault occurs on that
      memory region. If the data is already in its preferred location and
      the faulting processor can establish a mapping without requiring the
      data to be migrated, then data migration will be avoided. On the
      other hand, if the data is not in its preferred location or if a
      direct mapping cannot be established, then it will be migrated to the
      processor accessing it. It is important to note that setting the
      preferred location does not prevent data prefetching done using
      :py:obj:`~.cudaMemPrefetchAsync`. Having a preferred location can
      override the page thrash detection and resolution logic in the
      Unified Memory driver. Normally, if a page is detected to be
      constantly thrashing between for example host and device memory, the
      page may eventually be pinned to host memory by the Unified Memory
      driver. But if the preferred location is set as device memory, then
      the page will continue to thrash indefinitely. If
      :py:obj:`~.cudaMemAdviseSetReadMostly` is also set on this memory
      region or any subset of it, then the policies associated with that
      advice will override the policies of this advice, unless read
      accesses from `location` will not result in a read-only copy being
      created on that procesor as outlined in description for the advice
      :py:obj:`~.cudaMemAdviseSetReadMostly`. If the memory region refers
      to valid system-allocated pageable memory, and
      :py:obj:`~.cudaMemLocation.type` is
      :py:obj:`~.cudaMemLocationTypeDevice` then
      :py:obj:`~.cudaMemLocation.id` must be a valid device that has a non-
      zero alue for the device attribute
      :py:obj:`~.cudaDevAttrPageableMemoryAccess`.

    - :py:obj:`~.cudaMemAdviseUnsetPreferredLocation`: Undoes the effect of
      :py:obj:`~.cudaMemAdviseSetPreferredLocation` and changes the
      preferred location to none. The `location` argument is ignored for
      this advice.

    - :py:obj:`~.cudaMemAdviseSetAccessedBy`: This advice implies that the
      data will be accessed by processor `location`. The
      :py:obj:`~.cudaMemLocation.type` must be either
      :py:obj:`~.cudaMemLocationTypeDevice` with
      :py:obj:`~.cudaMemLocation.id` representing a valid device ordinal or
      :py:obj:`~.cudaMemLocationTypeHost` and
      :py:obj:`~.cudaMemLocation.id` will be ignored. All other location
      types are invalid. If :py:obj:`~.cudaMemLocation.id` is a GPU, then
      the device attribute :py:obj:`~.cudaDevAttrConcurrentManagedAccess`
      must be non-zero. This advice does not cause data migration and has
      no impact on the location of the data per se. Instead, it causes the
      data to always be mapped in the specified processor's page tables, as
      long as the location of the data permits a mapping to be established.
      If the data gets migrated for any reason, the mappings are updated
      accordingly. This advice is recommended in scenarios where data
      locality is not important, but avoiding faults is. Consider for
      example a system containing multiple GPUs with peer-to-peer access
      enabled, where the data located on one GPU is occasionally accessed
      by peer GPUs. In such scenarios, migrating data over to the other
      GPUs is not as important because the accesses are infrequent and the
      overhead of migration may be too high. But preventing faults can
      still help improve performance, and so having a mapping set up in
      advance is useful. Note that on CPU access of this data, the data may
      be migrated to host memory because the CPU typically cannot access
      device memory directly. Any GPU that had the
      :py:obj:`~.cudaMemAdviseSetAccessedBy` flag set for this data will
      now have its mapping updated to point to the page in host memory. If
      :py:obj:`~.cudaMemAdviseSetReadMostly` is also set on this memory
      region or any subset of it, then the policies associated with that
      advice will override the policies of this advice. Additionally, if
      the preferred location of this memory region or any subset of it is
      also `location`, then the policies associated with
      :py:obj:`~.CU_MEM_ADVISE_SET_PREFERRED_LOCATION` will override the
      policies of this advice. If the memory region refers to valid system-
      allocated pageable memory, and :py:obj:`~.cudaMemLocation.type` is
      :py:obj:`~.cudaMemLocationTypeDevice` then device in
      :py:obj:`~.cudaMemLocation.id` must have a non-zero value for the
      device attribute :py:obj:`~.cudaDevAttrPageableMemoryAccess`.
      Additionally, if :py:obj:`~.cudaMemLocation.id` has a non-zero value
      for the device attribute
      :py:obj:`~.cudaDevAttrPageableMemoryAccessUsesHostPageTables`, then
      this call has no effect.

    - :py:obj:`~.CU_MEM_ADVISE_UNSET_ACCESSED_BY`: Undoes the effect of
      :py:obj:`~.cudaMemAdviseSetAccessedBy`. Any mappings to the data from
      `location` may be removed at any time causing accesses to result in
      non-fatal page faults. If the memory region refers to valid system-
      allocated pageable memory, and :py:obj:`~.cudaMemLocation.type` is
      :py:obj:`~.cudaMemLocationTypeDevice` then device in
      :py:obj:`~.cudaMemLocation.id` must have a non-zero value for the
      device attribute :py:obj:`~.cudaDevAttrPageableMemoryAccess`.
      Additionally, if :py:obj:`~.cudaMemLocation.id` has a non-zero value
      for the device attribute
      :py:obj:`~.cudaDevAttrPageableMemoryAccessUsesHostPageTables`, then
      this call has no effect.

    Parameters
    ----------
    devPtr : Any
        Pointer to memory to set the advice for
    count : size_t
        Size in bytes of the memory range
    advice : :py:obj:`~.cudaMemoryAdvise`
        Advice to be applied for the specified memory range
    location : :py:obj:`~.cudaMemLocation`
        location to apply the advice for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidDevice`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyPeer`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy3DPeerAsync`, :py:obj:`~.cudaMemPrefetchAsync`, :py:obj:`~.cuMemAdvise`
    """
    cdef _HelperInputVoidPtrStruct cydevPtrHelper
    cdef void* cydevPtr = _helper_input_void_ptr(devPtr, &cydevPtrHelper)
    cdef cyruntime.cudaMemoryAdvise cyadvice = int(advice)
    with nogil:
        err = cyruntime.cudaMemAdvise(cydevPtr, count, cyadvice, location._pvt_ptr[0])
    _helper_input_void_ptr_free(&cydevPtrHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemRangeGetAttribute' in found_functions}}

@cython.embedsignature(True)
def cudaMemRangeGetAttribute(size_t dataSize, attribute not None : cudaMemRangeAttribute, devPtr, size_t count):
    """ Query an attribute of a given memory range.

    Query an attribute about the memory range starting at `devPtr` with a
    size of `count` bytes. The memory range must refer to managed memory
    allocated via :py:obj:`~.cudaMallocManaged` or declared via managed
    variables.

    The `attribute` parameter can take the following values:

    - :py:obj:`~.cudaMemRangeAttributeReadMostly`: If this attribute is
      specified, `data` will be interpreted as a 32-bit integer, and
      `dataSize` must be 4. The result returned will be 1 if all pages in
      the given memory range have read-duplication enabled, or 0 otherwise.

    - :py:obj:`~.cudaMemRangeAttributePreferredLocation`: If this attribute
      is specified, `data` will be interpreted as a 32-bit integer, and
      `dataSize` must be 4. The result returned will be a GPU device id if
      all pages in the memory range have that GPU as their preferred
      location, or it will be cudaCpuDeviceId if all pages in the memory
      range have the CPU as their preferred location, or it will be
      cudaInvalidDeviceId if either all the pages don't have the same
      preferred location or some of the pages don't have a preferred
      location at all. Note that the actual location of the pages in the
      memory range at the time of the query may be different from the
      preferred location.

    - :py:obj:`~.cudaMemRangeAttributeAccessedBy`: If this attribute is
      specified, `data` will be interpreted as an array of 32-bit integers,
      and `dataSize` must be a non-zero multiple of 4. The result returned
      will be a list of device ids that had
      :py:obj:`~.cudaMemAdviceSetAccessedBy` set for that entire memory
      range. If any device does not have that advice set for the entire
      memory range, that device will not be included. If `data` is larger
      than the number of devices that have that advice set for that memory
      range, cudaInvalidDeviceId will be returned in all the extra space
      provided. For ex., if `dataSize` is 12 (i.e. `data` has 3 elements)
      and only device 0 has the advice set, then the result returned will
      be { 0, cudaInvalidDeviceId, cudaInvalidDeviceId }. If `data` is
      smaller than the number of devices that have that advice set, then
      only as many devices will be returned as can fit in the array. There
      is no guarantee on which specific devices will be returned, however.

    - :py:obj:`~.cudaMemRangeAttributeLastPrefetchLocation`: If this
      attribute is specified, `data` will be interpreted as a 32-bit
      integer, and `dataSize` must be 4. The result returned will be the
      last location to which all pages in the memory range were prefetched
      explicitly via :py:obj:`~.cudaMemPrefetchAsync`. This will either be
      a GPU id or cudaCpuDeviceId depending on whether the last location
      for prefetch was a GPU or the CPU respectively. If any page in the
      memory range was never explicitly prefetched or if all pages were not
      prefetched to the same location, cudaInvalidDeviceId will be
      returned. Note that this simply returns the last location that the
      applicaton requested to prefetch the memory range to. It gives no
      indication as to whether the prefetch operation to that location has
      completed or even begun.

    - :py:obj:`~.cudaMemRangeAttributePreferredLocationType`: If this
      attribute is specified, `data` will be interpreted as a
      :py:obj:`~.cudaMemLocationType`, and `dataSize` must be
      sizeof(cudaMemLocationType). The :py:obj:`~.cudaMemLocationType`
      returned will be :py:obj:`~.cudaMemLocationTypeDevice` if all pages
      in the memory range have the same GPU as their preferred location, or
      :py:obj:`~.cudaMemLocationType` will be
      :py:obj:`~.cudaMemLocationTypeHost` if all pages in the memory range
      have the CPU as their preferred location, or or it will be
      :py:obj:`~.cudaMemLocationTypeHostNuma` if all the pages in the
      memory range have the same host NUMA node ID as their preferred
      location or it will be :py:obj:`~.cudaMemLocationTypeInvalid` if
      either all the pages don't have the same preferred location or some
      of the pages don't have a preferred location at all. Note that the
      actual location type of the pages in the memory range at the time of
      the query may be different from the preferred location type.

      - :py:obj:`~.cudaMemRangeAttributePreferredLocationId`: If this
        attribute is specified, `data` will be interpreted as a 32-bit
        integer, and `dataSize` must be 4. If the
        :py:obj:`~.cudaMemRangeAttributePreferredLocationType` query for
        the same address range returns
        :py:obj:`~.cudaMemLocationTypeDevice`, it will be a valid device
        ordinal or if it returns :py:obj:`~.cudaMemLocationTypeHostNuma`,
        it will be a valid host NUMA node ID or if it returns any other
        location type, the id should be ignored.

    - :py:obj:`~.cudaMemRangeAttributeLastPrefetchLocationType`: If this
      attribute is specified, `data` will be interpreted as a
      :py:obj:`~.cudaMemLocationType`, and `dataSize` must be
      sizeof(cudaMemLocationType). The result returned will be the last
      location type to which all pages in the memory range were prefetched
      explicitly via :py:obj:`~.cuMemPrefetchAsync`. The
      :py:obj:`~.cudaMemLocationType` returned will be
      :py:obj:`~.cudaMemLocationTypeDevice` if the last prefetch location
      was the GPU or :py:obj:`~.cudaMemLocationTypeHost` if it was the CPU
      or :py:obj:`~.cudaMemLocationTypeHostNuma` if the last prefetch
      location was a specific host NUMA node. If any page in the memory
      range was never explicitly prefetched or if all pages were not
      prefetched to the same location, :py:obj:`~.CUmemLocationType` will
      be :py:obj:`~.cudaMemLocationTypeInvalid`. Note that this simply
      returns the last location type that the application requested to
      prefetch the memory range to. It gives no indication as to whether
      the prefetch operation to that location has completed or even begun.

      - :py:obj:`~.cudaMemRangeAttributeLastPrefetchLocationId`: If this
        attribute is specified, `data` will be interpreted as a 32-bit
        integer, and `dataSize` must be 4. If the
        :py:obj:`~.cudaMemRangeAttributeLastPrefetchLocationType` query for
        the same address range returns
        :py:obj:`~.cudaMemLocationTypeDevice`, it will be a valid device
        ordinal or if it returns :py:obj:`~.cudaMemLocationTypeHostNuma`,
        it will be a valid host NUMA node ID or if it returns any other
        location type, the id should be ignored.

    Parameters
    ----------
    dataSize : size_t
        Array containing the size of data
    attribute : :py:obj:`~.cudaMemRangeAttribute`
        The attribute to query
    devPtr : Any
        Start of the range to query
    count : size_t
        Size of the range to query

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    data : Any
        A pointers to a memory location where the result of each attribute
        query will be written to.

    See Also
    --------
    :py:obj:`~.cudaMemRangeGetAttributes`, :py:obj:`~.cudaMemPrefetchAsync`, :py:obj:`~.cudaMemAdvise`, :py:obj:`~.cuMemRangeGetAttribute`
    """
    cdef _HelperCUmem_range_attribute cydata = _HelperCUmem_range_attribute(attribute, dataSize)
    cdef void* cydata_ptr = <void*><void_ptr>cydata.cptr
    cdef cyruntime.cudaMemRangeAttribute cyattribute = int(attribute)
    cdef _HelperInputVoidPtrStruct cydevPtrHelper
    cdef void* cydevPtr = _helper_input_void_ptr(devPtr, &cydevPtrHelper)
    with nogil:
        err = cyruntime.cudaMemRangeGetAttribute(cydata_ptr, dataSize, cyattribute, cydevPtr, count)
    _helper_input_void_ptr_free(&cydevPtrHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), cydata.pyObj())
{{endif}}

{{if 'cudaMemRangeGetAttributes' in found_functions}}

@cython.embedsignature(True)
def cudaMemRangeGetAttributes(dataSizes : tuple[int] | list[int], attributes : Optional[tuple[cudaMemRangeAttribute] | list[cudaMemRangeAttribute]], size_t numAttributes, devPtr, size_t count):
    """ Query attributes of a given memory range.

    Query attributes of the memory range starting at `devPtr` with a size
    of `count` bytes. The memory range must refer to managed memory
    allocated via :py:obj:`~.cudaMallocManaged` or declared via managed
    variables. The `attributes` array will be interpreted to have
    `numAttributes` entries. The `dataSizes` array will also be interpreted
    to have `numAttributes` entries. The results of the query will be
    stored in `data`.

    The list of supported attributes are given below. Please refer to
    :py:obj:`~.cudaMemRangeGetAttribute` for attribute descriptions and
    restrictions.

    - :py:obj:`~.cudaMemRangeAttributeReadMostly`

    - :py:obj:`~.cudaMemRangeAttributePreferredLocation`

    - :py:obj:`~.cudaMemRangeAttributeAccessedBy`

    - :py:obj:`~.cudaMemRangeAttributeLastPrefetchLocation`

    - :: cudaMemRangeAttributePreferredLocationType

    - :: cudaMemRangeAttributePreferredLocationId

    - :: cudaMemRangeAttributeLastPrefetchLocationType

    - :: cudaMemRangeAttributeLastPrefetchLocationId

    Parameters
    ----------
    dataSizes : list[int]
        Array containing the sizes of each result
    attributes : list[:py:obj:`~.cudaMemRangeAttribute`]
        An array of attributes to query (numAttributes and the number of
        attributes in this array should match)
    numAttributes : size_t
        Number of attributes to query
    devPtr : Any
        Start of the range to query
    count : size_t
        Size of the range to query

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    data : list[Any]
        A two-dimensional array containing pointers to memory locations
        where the result of each attribute query will be written to.

    See Also
    --------
    :py:obj:`~.cudaMemRangeGetAttribute`, :py:obj:`~.cudaMemAdvise`, :py:obj:`~.cudaMemPrefetchAsync`, :py:obj:`~.cuMemRangeGetAttributes`
    """
    attributes = [] if attributes is None else attributes
    if not all(isinstance(_x, (cudaMemRangeAttribute)) for _x in attributes):
        raise TypeError("Argument 'attributes' is not instance of type (expected tuple[cyruntime.cudaMemRangeAttribute] or list[cyruntime.cudaMemRangeAttribute]")
    if not all(isinstance(_x, (int)) for _x in dataSizes):
        raise TypeError("Argument 'dataSizes' is not instance of type (expected tuple[int] or list[int]")
    pylist = [_HelperCUmem_range_attribute(pyattributes, pydataSizes) for (pyattributes, pydataSizes) in zip(attributes, dataSizes)]
    cdef _InputVoidPtrPtrHelper voidStarHelperdata = _InputVoidPtrPtrHelper(pylist)
    cdef void** cyvoidStarHelper_ptr = <void**><void_ptr>voidStarHelperdata.cptr
    cdef vector[size_t] cydataSizes = dataSizes
    cdef vector[cyruntime.cudaMemRangeAttribute] cyattributes = [int(pyattributes) for pyattributes in (attributes)]
    if numAttributes > <size_t>len(dataSizes): raise RuntimeError("List is too small: " + str(len(dataSizes)) + " < " + str(numAttributes))
    if numAttributes > <size_t>len(attributes): raise RuntimeError("List is too small: " + str(len(attributes)) + " < " + str(numAttributes))
    cdef _HelperInputVoidPtrStruct cydevPtrHelper
    cdef void* cydevPtr = _helper_input_void_ptr(devPtr, &cydevPtrHelper)
    with nogil:
        err = cyruntime.cudaMemRangeGetAttributes(cyvoidStarHelper_ptr, cydataSizes.data(), cyattributes.data(), numAttributes, cydevPtr, count)
    _helper_input_void_ptr_free(&cydevPtrHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), [obj.pyObj() for obj in pylist])
{{endif}}

{{if 'cudaMemcpyToArray' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpyToArray(dst, size_t wOffset, size_t hOffset, src, size_t count, kind not None : cudaMemcpyKind):
    """ Copies data between host and device.

    [Deprecated]

    Copies `count` bytes from the memory area pointed to by `src` to the
    CUDA array `dst` starting at `hOffset` rows and `wOffset` bytes from
    the upper left corner, where `kind` specifies the direction of the
    copy, and must be one of :py:obj:`~.cudaMemcpyHostToHost`,
    :py:obj:`~.cudaMemcpyHostToDevice`, :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing.

    Parameters
    ----------
    dst : :py:obj:`~.cudaArray_t`
        Destination memory address
    wOffset : size_t
        Destination starting X offset (columns in bytes)
    hOffset : size_t
        Destination starting Y offset (rows)
    src : Any
        Source memory address
    count : size_t
        Size in bytes to copy
    kind : :py:obj:`~.cudaMemcpyKind`
        Type of transfer

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpyFromArray`, :py:obj:`~.cudaMemcpy2DFromArray`, :py:obj:`~.cudaMemcpyArrayToArray`, :py:obj:`~.cudaMemcpy2DArrayToArray`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy2DAsync`, :py:obj:`~.cudaMemcpyToArrayAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`, :py:obj:`~.cudaMemcpyFromArrayAsync`, :py:obj:`~.cudaMemcpy2DFromArrayAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyDtoA`
    """
    cdef cyruntime.cudaArray_t cydst
    if dst is None:
        pdst = 0
    elif isinstance(dst, (cudaArray_t,)):
        pdst = int(dst)
    else:
        pdst = int(cudaArray_t(dst))
    cydst = <cyruntime.cudaArray_t><void_ptr>pdst
    cdef _HelperInputVoidPtrStruct cysrcHelper
    cdef void* cysrc = _helper_input_void_ptr(src, &cysrcHelper)
    cdef cyruntime.cudaMemcpyKind cykind = int(kind)
    with nogil:
        err = cyruntime.cudaMemcpyToArray(cydst, wOffset, hOffset, cysrc, count, cykind)
    _helper_input_void_ptr_free(&cysrcHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpyFromArray' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpyFromArray(dst, src, size_t wOffset, size_t hOffset, size_t count, kind not None : cudaMemcpyKind):
    """ Copies data between host and device.

    [Deprecated]

    Copies `count` bytes from the CUDA array `src` starting at `hOffset`
    rows and `wOffset` bytes from the upper left corner to the memory area
    pointed to by `dst`, where `kind` specifies the direction of the copy,
    and must be one of :py:obj:`~.cudaMemcpyHostToHost`,
    :py:obj:`~.cudaMemcpyHostToDevice`, :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing.

    Parameters
    ----------
    dst : Any
        Destination memory address
    src : :py:obj:`~.cudaArray_const_t`
        Source memory address
    wOffset : size_t
        Source starting X offset (columns in bytes)
    hOffset : size_t
        Source starting Y offset (rows)
    count : size_t
        Size in bytes to copy
    kind : :py:obj:`~.cudaMemcpyKind`
        Type of transfer

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpyToArray`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpy2DFromArray`, :py:obj:`~.cudaMemcpyArrayToArray`, :py:obj:`~.cudaMemcpy2DArrayToArray`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy2DAsync`, :py:obj:`~.cudaMemcpyToArrayAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`, :py:obj:`~.cudaMemcpyFromArrayAsync`, :py:obj:`~.cudaMemcpy2DFromArrayAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoD`
    """
    cdef cyruntime.cudaArray_const_t cysrc
    if src is None:
        psrc = 0
    elif isinstance(src, (cudaArray_const_t,)):
        psrc = int(src)
    else:
        psrc = int(cudaArray_const_t(src))
    cysrc = <cyruntime.cudaArray_const_t><void_ptr>psrc
    cdef _HelperInputVoidPtrStruct cydstHelper
    cdef void* cydst = _helper_input_void_ptr(dst, &cydstHelper)
    cdef cyruntime.cudaMemcpyKind cykind = int(kind)
    with nogil:
        err = cyruntime.cudaMemcpyFromArray(cydst, cysrc, wOffset, hOffset, count, cykind)
    _helper_input_void_ptr_free(&cydstHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpyArrayToArray' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpyArrayToArray(dst, size_t wOffsetDst, size_t hOffsetDst, src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, kind not None : cudaMemcpyKind):
    """ Copies data between host and device.

    [Deprecated]

    Copies `count` bytes from the CUDA array `src` starting at `hOffsetSrc`
    rows and `wOffsetSrc` bytes from the upper left corner to the CUDA
    array `dst` starting at `hOffsetDst` rows and `wOffsetDst` bytes from
    the upper left corner, where `kind` specifies the direction of the
    copy, and must be one of :py:obj:`~.cudaMemcpyHostToHost`,
    :py:obj:`~.cudaMemcpyHostToDevice`, :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing.

    Parameters
    ----------
    dst : :py:obj:`~.cudaArray_t`
        Destination memory address
    wOffsetDst : size_t
        Destination starting X offset (columns in bytes)
    hOffsetDst : size_t
        Destination starting Y offset (rows)
    src : :py:obj:`~.cudaArray_const_t`
        Source memory address
    wOffsetSrc : size_t
        Source starting X offset (columns in bytes)
    hOffsetSrc : size_t
        Source starting Y offset (rows)
    count : size_t
        Size in bytes to copy
    kind : :py:obj:`~.cudaMemcpyKind`
        Type of transfer

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpyToArray`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpyFromArray`, :py:obj:`~.cudaMemcpy2DFromArray`, :py:obj:`~.cudaMemcpy2DArrayToArray`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy2DAsync`, :py:obj:`~.cudaMemcpyToArrayAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`, :py:obj:`~.cudaMemcpyFromArrayAsync`, :py:obj:`~.cudaMemcpy2DFromArrayAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`, :py:obj:`~.cuMemcpyAtoA`
    """
    cdef cyruntime.cudaArray_const_t cysrc
    if src is None:
        psrc = 0
    elif isinstance(src, (cudaArray_const_t,)):
        psrc = int(src)
    else:
        psrc = int(cudaArray_const_t(src))
    cysrc = <cyruntime.cudaArray_const_t><void_ptr>psrc
    cdef cyruntime.cudaArray_t cydst
    if dst is None:
        pdst = 0
    elif isinstance(dst, (cudaArray_t,)):
        pdst = int(dst)
    else:
        pdst = int(cudaArray_t(dst))
    cydst = <cyruntime.cudaArray_t><void_ptr>pdst
    cdef cyruntime.cudaMemcpyKind cykind = int(kind)
    with nogil:
        err = cyruntime.cudaMemcpyArrayToArray(cydst, wOffsetDst, hOffsetDst, cysrc, wOffsetSrc, hOffsetSrc, count, cykind)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpyToArrayAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpyToArrayAsync(dst, size_t wOffset, size_t hOffset, src, size_t count, kind not None : cudaMemcpyKind, stream):
    """ Copies data between host and device.

    [Deprecated]

    Copies `count` bytes from the memory area pointed to by `src` to the
    CUDA array `dst` starting at `hOffset` rows and `wOffset` bytes from
    the upper left corner, where `kind` specifies the direction of the
    copy, and must be one of :py:obj:`~.cudaMemcpyHostToHost`,
    :py:obj:`~.cudaMemcpyHostToDevice`, :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing.

    :py:obj:`~.cudaMemcpyToArrayAsync()` is asynchronous with respect to
    the host, so the call may return before the copy is complete. The copy
    can optionally be associated to a stream by passing a non-zero `stream`
    argument. If `kind` is :py:obj:`~.cudaMemcpyHostToDevice` or
    :py:obj:`~.cudaMemcpyDeviceToHost` and `stream` is non-zero, the copy
    may overlap with operations in other streams.

    Parameters
    ----------
    dst : :py:obj:`~.cudaArray_t`
        Destination memory address
    wOffset : size_t
        Destination starting X offset (columns in bytes)
    hOffset : size_t
        Destination starting Y offset (rows)
    src : Any
        Source memory address
    count : size_t
        Size in bytes to copy
    kind : :py:obj:`~.cudaMemcpyKind`
        Type of transfer
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpyToArray`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpyFromArray`, :py:obj:`~.cudaMemcpy2DFromArray`, :py:obj:`~.cudaMemcpyArrayToArray`, :py:obj:`~.cudaMemcpy2DArrayToArray`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy2DAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`, :py:obj:`~.cudaMemcpyFromArrayAsync`, :py:obj:`~.cudaMemcpy2DFromArrayAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpy2DAsync`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaArray_t cydst
    if dst is None:
        pdst = 0
    elif isinstance(dst, (cudaArray_t,)):
        pdst = int(dst)
    else:
        pdst = int(cudaArray_t(dst))
    cydst = <cyruntime.cudaArray_t><void_ptr>pdst
    cdef _HelperInputVoidPtrStruct cysrcHelper
    cdef void* cysrc = _helper_input_void_ptr(src, &cysrcHelper)
    cdef cyruntime.cudaMemcpyKind cykind = int(kind)
    with nogil:
        err = cyruntime.cudaMemcpyToArrayAsync(cydst, wOffset, hOffset, cysrc, count, cykind, cystream)
    _helper_input_void_ptr_free(&cysrcHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemcpyFromArrayAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMemcpyFromArrayAsync(dst, src, size_t wOffset, size_t hOffset, size_t count, kind not None : cudaMemcpyKind, stream):
    """ Copies data between host and device.

    [Deprecated]

    Copies `count` bytes from the CUDA array `src` starting at `hOffset`
    rows and `wOffset` bytes from the upper left corner to the memory area
    pointed to by `dst`, where `kind` specifies the direction of the copy,
    and must be one of :py:obj:`~.cudaMemcpyHostToHost`,
    :py:obj:`~.cudaMemcpyHostToDevice`, :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing.

    :py:obj:`~.cudaMemcpyFromArrayAsync()` is asynchronous with respect to
    the host, so the call may return before the copy is complete. The copy
    can optionally be associated to a stream by passing a non-zero `stream`
    argument. If `kind` is :py:obj:`~.cudaMemcpyHostToDevice` or
    :py:obj:`~.cudaMemcpyDeviceToHost` and `stream` is non-zero, the copy
    may overlap with operations in other streams.

    Parameters
    ----------
    dst : Any
        Destination memory address
    src : :py:obj:`~.cudaArray_const_t`
        Source memory address
    wOffset : size_t
        Source starting X offset (columns in bytes)
    hOffset : size_t
        Source starting Y offset (rows)
    count : size_t
        Size in bytes to copy
    kind : :py:obj:`~.cudaMemcpyKind`
        Type of transfer
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidMemcpyDirection`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpyToArray`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpyFromArray`, :py:obj:`~.cudaMemcpy2DFromArray`, :py:obj:`~.cudaMemcpyArrayToArray`, :py:obj:`~.cudaMemcpy2DArrayToArray`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpy2DAsync`, :py:obj:`~.cudaMemcpyToArrayAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`, :py:obj:`~.cudaMemcpy2DFromArrayAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpy2DAsync`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaArray_const_t cysrc
    if src is None:
        psrc = 0
    elif isinstance(src, (cudaArray_const_t,)):
        psrc = int(src)
    else:
        psrc = int(cudaArray_const_t(src))
    cysrc = <cyruntime.cudaArray_const_t><void_ptr>psrc
    cdef _HelperInputVoidPtrStruct cydstHelper
    cdef void* cydst = _helper_input_void_ptr(dst, &cydstHelper)
    cdef cyruntime.cudaMemcpyKind cykind = int(kind)
    with nogil:
        err = cyruntime.cudaMemcpyFromArrayAsync(cydst, cysrc, wOffset, hOffset, count, cykind, cystream)
    _helper_input_void_ptr_free(&cydstHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMallocAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMallocAsync(size_t size, hStream):
    """ Allocates memory with stream ordered semantics.

    Inserts an allocation operation into `hStream`. A pointer to the
    allocated memory is returned immediately in *dptr. The allocation must
    not be accessed until the the allocation operation completes. The
    allocation comes from the memory pool associated with the stream's
    device.

    Parameters
    ----------
    size : size_t
        Number of bytes to allocate
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream establishing the stream ordering contract and the memory
        pool to allocate from

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotSupported`, :py:obj:`~.cudaErrorOutOfMemory`,
    devPtr : Any
        Returned device pointer

    See Also
    --------
    :py:obj:`~.cuMemAllocAsync`, cudaMallocAsync (C++ API), :py:obj:`~.cudaMallocFromPoolAsync`, :py:obj:`~.cudaFreeAsync`, :py:obj:`~.cudaDeviceSetMemPool`, :py:obj:`~.cudaDeviceGetDefaultMemPool`, :py:obj:`~.cudaDeviceGetMemPool`, :py:obj:`~.cudaMemPoolSetAccess`, :py:obj:`~.cudaMemPoolSetAttribute`, :py:obj:`~.cudaMemPoolGetAttribute`

    Notes
    -----
    The default memory pool of a device contains device memory from that device.

    Basic stream ordering allows future work submitted into the same stream to use the allocation. Stream query, stream synchronize, and CUDA events can be used to guarantee that the allocation operation completes before work submitted in a separate stream runs.

    During stream capture, this function results in the creation of an allocation node. In this case, the allocation is owned by the graph instead of the memory pool. The memory pool's properties are used to set the node's creation parameters.
    """
    cdef cyruntime.cudaStream_t cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (cudaStream_t,driver.CUstream)):
        phStream = int(hStream)
    else:
        phStream = int(cudaStream_t(hStream))
    cyhStream = <cyruntime.cudaStream_t><void_ptr>phStream
    cdef void_ptr devPtr = 0
    with nogil:
        err = cyruntime.cudaMallocAsync(<void**>&devPtr, size, cyhStream)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), devPtr)
{{endif}}

{{if 'cudaFreeAsync' in found_functions}}

@cython.embedsignature(True)
def cudaFreeAsync(devPtr, hStream):
    """ Frees memory with stream ordered semantics.

    Inserts a free operation into `hStream`. The allocation must not be
    accessed after stream execution reaches the free. After this API
    returns, accessing the memory from any subsequent work launched on the
    GPU or querying its pointer attributes results in undefined behavior.

    Parameters
    ----------
    dptr : Any
        memory to free
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream establishing the stream ordering promise

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotSupported`

    See Also
    --------
    :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cudaMallocAsync`

    Notes
    -----
    During stream capture, this function results in the creation of a free node and must therefore be passed the address of a graph allocation.
    """
    cdef cyruntime.cudaStream_t cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (cudaStream_t,driver.CUstream)):
        phStream = int(hStream)
    else:
        phStream = int(cudaStream_t(hStream))
    cyhStream = <cyruntime.cudaStream_t><void_ptr>phStream
    cdef _HelperInputVoidPtrStruct cydevPtrHelper
    cdef void* cydevPtr = _helper_input_void_ptr(devPtr, &cydevPtrHelper)
    with nogil:
        err = cyruntime.cudaFreeAsync(cydevPtr, cyhStream)
    _helper_input_void_ptr_free(&cydevPtrHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemPoolTrimTo' in found_functions}}

@cython.embedsignature(True)
def cudaMemPoolTrimTo(memPool, size_t minBytesToKeep):
    """ Tries to release memory back to the OS.

    Releases memory back to the OS until the pool contains fewer than
    minBytesToKeep reserved bytes, or there is no more memory that the
    allocator can safely release. The allocator cannot release OS
    allocations that back outstanding asynchronous allocations. The OS
    allocations may happen at different granularity from the user
    allocations.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        The memory pool to trim
    minBytesToKeep : size_t
        If the pool has less than minBytesToKeep reserved, the TrimTo
        operation is a no-op. Otherwise the pool will be guaranteed to have
        at least minBytesToKeep bytes reserved after the operation.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cuMemPoolTrimTo`, :py:obj:`~.cudaMallocAsync`, :py:obj:`~.cudaFreeAsync`, :py:obj:`~.cudaDeviceGetDefaultMemPool`, :py:obj:`~.cudaDeviceGetMemPool`, :py:obj:`~.cudaMemPoolCreate`

    Notes
    -----
    : Allocations that have not been freed count as outstanding.

    : Allocations that have been asynchronously freed but whose completion has not been observed on the host (eg. by a synchronize) can count as outstanding.
    """
    cdef cyruntime.cudaMemPool_t cymemPool
    if memPool is None:
        pmemPool = 0
    elif isinstance(memPool, (cudaMemPool_t,driver.CUmemoryPool)):
        pmemPool = int(memPool)
    else:
        pmemPool = int(cudaMemPool_t(memPool))
    cymemPool = <cyruntime.cudaMemPool_t><void_ptr>pmemPool
    with nogil:
        err = cyruntime.cudaMemPoolTrimTo(cymemPool, minBytesToKeep)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemPoolSetAttribute' in found_functions}}

@cython.embedsignature(True)
def cudaMemPoolSetAttribute(memPool, attr not None : cudaMemPoolAttr, value):
    """ Sets attributes of a memory pool.

    Supported attributes are:

    - :py:obj:`~.cudaMemPoolAttrReleaseThreshold`: (value type =
      cuuint64_t) Amount of reserved memory in bytes to hold onto before
      trying to release memory back to the OS. When more than the release
      threshold bytes of memory are held by the memory pool, the allocator
      will try to release memory back to the OS on the next call to stream,
      event or context synchronize. (default 0)

    - :py:obj:`~.cudaMemPoolReuseFollowEventDependencies`: (value type =
      int) Allow :py:obj:`~.cudaMallocAsync` to use memory asynchronously
      freed in another stream as long as a stream ordering dependency of
      the allocating stream on the free action exists. Cuda events and null
      stream interactions can create the required stream ordered
      dependencies. (default enabled)

    - :py:obj:`~.cudaMemPoolReuseAllowOpportunistic`: (value type = int)
      Allow reuse of already completed frees when there is no dependency
      between the free and allocation. (default enabled)

    - :py:obj:`~.cudaMemPoolReuseAllowInternalDependencies`: (value type =
      int) Allow :py:obj:`~.cudaMallocAsync` to insert new stream
      dependencies in order to establish the stream ordering required to
      reuse a piece of memory released by :py:obj:`~.cudaFreeAsync`
      (default enabled).

    - :py:obj:`~.cudaMemPoolAttrReservedMemHigh`: (value type = cuuint64_t)
      Reset the high watermark that tracks the amount of backing memory
      that was allocated for the memory pool. It is illegal to set this
      attribute to a non-zero value.

    - :py:obj:`~.cudaMemPoolAttrUsedMemHigh`: (value type = cuuint64_t)
      Reset the high watermark that tracks the amount of used memory that
      was allocated for the memory pool. It is illegal to set this
      attribute to a non-zero value.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        The memory pool to modify
    attr : :py:obj:`~.cudaMemPoolAttr`
        The attribute to modify
    value : Any
        Pointer to the value to assign

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cuMemPoolSetAttribute`, :py:obj:`~.cudaMallocAsync`, :py:obj:`~.cudaFreeAsync`, :py:obj:`~.cudaDeviceGetDefaultMemPool`, :py:obj:`~.cudaDeviceGetMemPool`, :py:obj:`~.cudaMemPoolCreate`
    """
    cdef cyruntime.cudaMemPool_t cymemPool
    if memPool is None:
        pmemPool = 0
    elif isinstance(memPool, (cudaMemPool_t,driver.CUmemoryPool)):
        pmemPool = int(memPool)
    else:
        pmemPool = int(cudaMemPool_t(memPool))
    cymemPool = <cyruntime.cudaMemPool_t><void_ptr>pmemPool
    cdef cyruntime.cudaMemPoolAttr cyattr = int(attr)
    cdef _HelperCUmemPool_attribute cyvalue = _HelperCUmemPool_attribute(attr, value, is_getter=False)
    cdef void* cyvalue_ptr = <void*><void_ptr>cyvalue.cptr
    with nogil:
        err = cyruntime.cudaMemPoolSetAttribute(cymemPool, cyattr, cyvalue_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemPoolGetAttribute' in found_functions}}

@cython.embedsignature(True)
def cudaMemPoolGetAttribute(memPool, attr not None : cudaMemPoolAttr):
    """ Gets attributes of a memory pool.

    Supported attributes are:

    - :py:obj:`~.cudaMemPoolAttrReleaseThreshold`: (value type =
      cuuint64_t) Amount of reserved memory in bytes to hold onto before
      trying to release memory back to the OS. When more than the release
      threshold bytes of memory are held by the memory pool, the allocator
      will try to release memory back to the OS on the next call to stream,
      event or context synchronize. (default 0)

    - :py:obj:`~.cudaMemPoolReuseFollowEventDependencies`: (value type =
      int) Allow :py:obj:`~.cudaMallocAsync` to use memory asynchronously
      freed in another stream as long as a stream ordering dependency of
      the allocating stream on the free action exists. Cuda events and null
      stream interactions can create the required stream ordered
      dependencies. (default enabled)

    - :py:obj:`~.cudaMemPoolReuseAllowOpportunistic`: (value type = int)
      Allow reuse of already completed frees when there is no dependency
      between the free and allocation. (default enabled)

    - :py:obj:`~.cudaMemPoolReuseAllowInternalDependencies`: (value type =
      int) Allow :py:obj:`~.cudaMallocAsync` to insert new stream
      dependencies in order to establish the stream ordering required to
      reuse a piece of memory released by :py:obj:`~.cudaFreeAsync`
      (default enabled).

    - :py:obj:`~.cudaMemPoolAttrReservedMemCurrent`: (value type =
      cuuint64_t) Amount of backing memory currently allocated for the
      mempool.

    - :py:obj:`~.cudaMemPoolAttrReservedMemHigh`: (value type = cuuint64_t)
      High watermark of backing memory allocated for the mempool since the
      last time it was reset.

    - :py:obj:`~.cudaMemPoolAttrUsedMemCurrent`: (value type = cuuint64_t)
      Amount of memory from the pool that is currently in use by the
      application.

    - :py:obj:`~.cudaMemPoolAttrUsedMemHigh`: (value type = cuuint64_t)
      High watermark of the amount of memory from the pool that was in use
      by the application since the last time it was reset.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        The memory pool to get attributes of
    attr : :py:obj:`~.cudaMemPoolAttr`
        The attribute to get

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    value : Any
        Retrieved value

    See Also
    --------
    :py:obj:`~.cuMemPoolGetAttribute`, :py:obj:`~.cudaMallocAsync`, :py:obj:`~.cudaFreeAsync`, :py:obj:`~.cudaDeviceGetDefaultMemPool`, :py:obj:`~.cudaDeviceGetMemPool`, :py:obj:`~.cudaMemPoolCreate`
    """
    cdef cyruntime.cudaMemPool_t cymemPool
    if memPool is None:
        pmemPool = 0
    elif isinstance(memPool, (cudaMemPool_t,driver.CUmemoryPool)):
        pmemPool = int(memPool)
    else:
        pmemPool = int(cudaMemPool_t(memPool))
    cymemPool = <cyruntime.cudaMemPool_t><void_ptr>pmemPool
    cdef cyruntime.cudaMemPoolAttr cyattr = int(attr)
    cdef _HelperCUmemPool_attribute cyvalue = _HelperCUmemPool_attribute(attr, 0, is_getter=True)
    cdef void* cyvalue_ptr = <void*><void_ptr>cyvalue.cptr
    with nogil:
        err = cyruntime.cudaMemPoolGetAttribute(cymemPool, cyattr, cyvalue_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), cyvalue.pyObj())
{{endif}}

{{if 'cudaMemPoolSetAccess' in found_functions}}

@cython.embedsignature(True)
def cudaMemPoolSetAccess(memPool, descList : Optional[tuple[cudaMemAccessDesc] | list[cudaMemAccessDesc]], size_t count):
    """ Controls visibility of pools between devices.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        The pool being modified
    map : list[:py:obj:`~.cudaMemAccessDesc`]
        Array of access descriptors. Each descriptor instructs the access
        to enable for a single gpu
    count : size_t
        Number of descriptors in the map array.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cuMemPoolSetAccess`, :py:obj:`~.cudaMemPoolGetAccess`, :py:obj:`~.cudaMallocAsync`, :py:obj:`~.cudaFreeAsync`
    """
    descList = [] if descList is None else descList
    if not all(isinstance(_x, (cudaMemAccessDesc,)) for _x in descList):
        raise TypeError("Argument 'descList' is not instance of type (expected tuple[cyruntime.cudaMemAccessDesc,] or list[cyruntime.cudaMemAccessDesc,]")
    cdef cyruntime.cudaMemPool_t cymemPool
    if memPool is None:
        pmemPool = 0
    elif isinstance(memPool, (cudaMemPool_t,driver.CUmemoryPool)):
        pmemPool = int(memPool)
    else:
        pmemPool = int(cudaMemPool_t(memPool))
    cymemPool = <cyruntime.cudaMemPool_t><void_ptr>pmemPool
    cdef cyruntime.cudaMemAccessDesc* cydescList = NULL
    if len(descList) > 1:
        cydescList = <cyruntime.cudaMemAccessDesc*> calloc(len(descList), sizeof(cyruntime.cudaMemAccessDesc))
        if cydescList is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(descList)) + 'x' + str(sizeof(cyruntime.cudaMemAccessDesc)))
        for idx in range(len(descList)):
            string.memcpy(&cydescList[idx], (<cudaMemAccessDesc>descList[idx])._pvt_ptr, sizeof(cyruntime.cudaMemAccessDesc))
    elif len(descList) == 1:
        cydescList = (<cudaMemAccessDesc>descList[0])._pvt_ptr
    if count > <size_t>len(descList): raise RuntimeError("List is too small: " + str(len(descList)) + " < " + str(count))
    with nogil:
        err = cyruntime.cudaMemPoolSetAccess(cymemPool, cydescList, count)
    if len(descList) > 1 and cydescList is not NULL:
        free(cydescList)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemPoolGetAccess' in found_functions}}

@cython.embedsignature(True)
def cudaMemPoolGetAccess(memPool, location : Optional[cudaMemLocation]):
    """ Returns the accessibility of a pool from a device.

    Returns the accessibility of the pool's memory from the specified
    location.

    Parameters
    ----------
    memPool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        the pool being queried
    location : :py:obj:`~.cudaMemLocation`
        the location accessing the pool

    Returns
    -------
    cudaError_t

    flags : :py:obj:`~.cudaMemAccessFlags`
        the accessibility of the pool from the specified location

    See Also
    --------
    :py:obj:`~.cuMemPoolGetAccess`, :py:obj:`~.cudaMemPoolSetAccess`
    """
    cdef cyruntime.cudaMemPool_t cymemPool
    if memPool is None:
        pmemPool = 0
    elif isinstance(memPool, (cudaMemPool_t,driver.CUmemoryPool)):
        pmemPool = int(memPool)
    else:
        pmemPool = int(cudaMemPool_t(memPool))
    cymemPool = <cyruntime.cudaMemPool_t><void_ptr>pmemPool
    cdef cyruntime.cudaMemAccessFlags flags
    cdef cyruntime.cudaMemLocation* cylocation_ptr = location._pvt_ptr if location is not None else NULL
    with nogil:
        err = cyruntime.cudaMemPoolGetAccess(&flags, cymemPool, cylocation_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), cudaMemAccessFlags(flags))
{{endif}}

{{if 'cudaMemPoolCreate' in found_functions}}

@cython.embedsignature(True)
def cudaMemPoolCreate(poolProps : Optional[cudaMemPoolProps]):
    """ Creates a memory pool.

    Creates a CUDA memory pool and returns the handle in `pool`. The
    `poolProps` determines the properties of the pool such as the backing
    device and IPC capabilities.

    To create a memory pool for host memory not targeting a specific NUMA
    node, applications must set set
    :py:obj:`~.cudaMemPoolProps`::cudaMemLocation::type to
    :py:obj:`~.cudaMemLocationTypeHost`.
    :py:obj:`~.cudaMemPoolProps`::cudaMemLocation::id is ignored for such
    pools. Pools created with the type :py:obj:`~.cudaMemLocationTypeHost`
    are not IPC capable and :py:obj:`~.cudaMemPoolProps.handleTypes` must
    be 0, any other values will result in
    :py:obj:`~.cudaErrorInvalidValue`. To create a memory pool targeting a
    specific host NUMA node, applications must set
    :py:obj:`~.cudaMemPoolProps`::cudaMemLocation::type to
    :py:obj:`~.cudaMemLocationTypeHostNuma` and
    :py:obj:`~.cudaMemPoolProps`::cudaMemLocation::id must specify the NUMA
    ID of the host memory node. Specifying
    :py:obj:`~.cudaMemLocationTypeHostNumaCurrent` as the
    :py:obj:`~.cudaMemPoolProps`::cudaMemLocation::type will result in
    :py:obj:`~.cudaErrorInvalidValue`. By default, the pool's memory will
    be accessible from the device it is allocated on. In the case of pools
    created with :py:obj:`~.cudaMemLocationTypeHostNuma` or
    :py:obj:`~.cudaMemLocationTypeHost`, their default accessibility will
    be from the host CPU. Applications can control the maximum size of the
    pool by specifying a non-zero value for
    :py:obj:`~.cudaMemPoolProps.maxSize`. If set to 0, the maximum size of
    the pool will default to a system dependent value.

    Applications that intend to use :py:obj:`~.CU_MEM_HANDLE_TYPE_FABRIC`
    based memory sharing must ensure: (1) `nvidia-caps-imex-channels`
    character device is created by the driver and is listed under
    /proc/devices (2) have at least one IMEX channel file accessible by the
    user launching the application.

    When exporter and importer CUDA processes have been granted access to
    the same IMEX channel, they can securely share memory.

    The IMEX channel security model works on a per user basis. Which means
    all processes under a user can share memory if the user has access to a
    valid IMEX channel. When multi-user isolation is desired, a separate
    IMEX channel is required for each user.

    These channel files exist in /dev/nvidia-caps-imex-channels/channel*
    and can be created using standard OS native calls like mknod on Linux.
    For example: To create channel0 with the major number from
    /proc/devices users can execute the following command: `mknod
    /dev/nvidia-caps-imex-channels/channel0 c <major number> 0`

    To create a managed memory pool, applications must set
    :py:obj:`~.cudaMemPoolProps`:cudaMemAllocationType to
    :py:obj:`~.cudaMemAllocationTypeManaged`.
    :py:obj:`~.cudaMemPoolProps`::cudaMemAllocationHandleType must also be
    set to :py:obj:`~.cudaMemHandleTypeNone` since IPC is not supported.
    For managed memory pools, :py:obj:`~.cudaMemPoolProps`::cudaMemLocation
    will be treated as the preferred location for all allocations created
    from the pool. An application can also set
    :py:obj:`~.cudaMemLocationTypeNone` to indicate no preferred location.
    :py:obj:`~.cudaMemPoolProps.maxSize` must be set to zero for managed
    memory pools. :py:obj:`~.cudaMemPoolProps.usage` should be zero as
    decompress for managed memory is not supported. For managed memory
    pools, all devices on the system must have non-zero
    :py:obj:`~.concurrentManagedAccess`. If not, this call returns
    :py:obj:`~.cudaErrorNotSupported`

    Parameters
    ----------
    poolProps : :py:obj:`~.cudaMemPoolProps`
        None

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotSupported`
    memPool : :py:obj:`~.cudaMemPool_t`
        None

    See Also
    --------
    :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cudaDeviceSetMemPool`, :py:obj:`~.cudaMallocFromPoolAsync`, :py:obj:`~.cudaMemPoolExportToShareableHandle`, :py:obj:`~.cudaDeviceGetDefaultMemPool`, :py:obj:`~.cudaDeviceGetMemPool`

    Notes
    -----
    Specifying :py:obj:`~.cudaMemHandleTypeNone` creates a memory pool that will not support IPC.
    """
    cdef cudaMemPool_t memPool = cudaMemPool_t()
    cdef cyruntime.cudaMemPoolProps* cypoolProps_ptr = poolProps._pvt_ptr if poolProps is not None else NULL
    with nogil:
        err = cyruntime.cudaMemPoolCreate(<cyruntime.cudaMemPool_t*>memPool._pvt_ptr, cypoolProps_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), memPool)
{{endif}}

{{if 'cudaMemPoolDestroy' in found_functions}}

@cython.embedsignature(True)
def cudaMemPoolDestroy(memPool):
    """ Destroys the specified memory pool.

    If any pointers obtained from this pool haven't been freed or the pool
    has free operations that haven't completed when
    :py:obj:`~.cudaMemPoolDestroy` is invoked, the function will return
    immediately and the resources associated with the pool will be released
    automatically once there are no more outstanding allocations.

    Destroying the current mempool of a device sets the default mempool of
    that device as the current mempool for that device.

    Parameters
    ----------
    memPool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        None

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    cuMemPoolDestroy, :py:obj:`~.cudaFreeAsync`, :py:obj:`~.cudaDeviceSetMemPool`, :py:obj:`~.cudaDeviceGetDefaultMemPool`, :py:obj:`~.cudaDeviceGetMemPool`, :py:obj:`~.cudaMemPoolCreate`

    Notes
    -----
    A device's default memory pool cannot be destroyed.
    """
    cdef cyruntime.cudaMemPool_t cymemPool
    if memPool is None:
        pmemPool = 0
    elif isinstance(memPool, (cudaMemPool_t,driver.CUmemoryPool)):
        pmemPool = int(memPool)
    else:
        pmemPool = int(cudaMemPool_t(memPool))
    cymemPool = <cyruntime.cudaMemPool_t><void_ptr>pmemPool
    with nogil:
        err = cyruntime.cudaMemPoolDestroy(cymemPool)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMemGetDefaultMemPool' in found_functions}}

@cython.embedsignature(True)
def cudaMemGetDefaultMemPool(location : Optional[cudaMemLocation], typename not None : cudaMemAllocationType):
    """ Returns the default memory pool for a given location and allocation type.

    The memory location can be of one of
    :py:obj:`~.cudaMemLocationTypeDevice`,
    :py:obj:`~.cudaMemLocationTypeHost` or
    :py:obj:`~.cudaMemLocationTypeHostNuma`. The allocation type can be one
    of :py:obj:`~.cudaMemAllocationTypePinned` or
    :py:obj:`~.cudaMemAllocationTypeManaged`. When the allocation type is
    :py:obj:`~.cudaMemAllocationTypeManaged`, the location type can also be
    :py:obj:`~.cudaMemLocationTypeNone` to indicate no preferred location
    for the managed memory pool. In all other cases, the call return
    :py:obj:`~.cudaErrorInvalidValue`

    Parameters
    ----------
    location : :py:obj:`~.cudaMemLocation`
        None
    typename : :py:obj:`~.cudaMemAllocationType`
        None

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotSupported`,
    memPool : :py:obj:`~.cudaMemPool_t`
        None

    See Also
    --------
    :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemPoolTrimTo`, :py:obj:`~.cuMemPoolGetAttribute`, :py:obj:`~.cuMemPoolSetAttribute`, cuMemPoolSetAccess, :py:obj:`~.cuMemGetMemPool`, :py:obj:`~.cuMemPoolCreate`
    """
    cdef cudaMemPool_t memPool = cudaMemPool_t()
    cdef cyruntime.cudaMemLocation* cylocation_ptr = location._pvt_ptr if location is not None else NULL
    cdef cyruntime.cudaMemAllocationType cytypename = int(typename)
    with nogil:
        err = cyruntime.cudaMemGetDefaultMemPool(<cyruntime.cudaMemPool_t*>memPool._pvt_ptr, cylocation_ptr, cytypename)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), memPool)
{{endif}}

{{if 'cudaMemGetMemPool' in found_functions}}

@cython.embedsignature(True)
def cudaMemGetMemPool(location : Optional[cudaMemLocation], typename not None : cudaMemAllocationType):
    """ Gets the current memory pool for a given memory location and allocation type.

    The memory location can be of one of
    :py:obj:`~.cudaMemLocationTypeDevice`,
    :py:obj:`~.cudaMemLocationTypeHost` or
    :py:obj:`~.cudaMemLocationTypeHostNuma`. The allocation type can be one
    of :py:obj:`~.cudaMemAllocationTypePinned` or
    :py:obj:`~.cudaMemAllocationTypeManaged`. When the allocation type is
    :py:obj:`~.cudaMemAllocationTypeManaged`, the location type can also be
    :py:obj:`~.cudaMemLocationTypeNone` to indicate no preferred location
    for the managed memory pool. In all other cases, the call return
    :py:obj:`~.cudaErrorInvalidValue`

    Returns the last pool provided to :py:obj:`~.cudaMemSetMemPool` or
    :py:obj:`~.cudaDeviceSetMemPool` for this location and allocation type
    or the location's default memory pool if :py:obj:`~.cudaMemSetMemPool`
    or :py:obj:`~.cudaDeviceSetMemPool` for that allocType and location has
    never been called. By default the current mempool of a location is the
    default mempool for a device that can be obtained via
    cudaMemGetDefaultMemPool Otherwise the returned pool must have been set
    with :py:obj:`~.cudaDeviceSetMemPool`.

    Parameters
    ----------
    location : :py:obj:`~.cudaMemLocation`
        None
    typename : :py:obj:`~.cudaMemAllocationType`
        None

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    memPool : :py:obj:`~.cudaMemPool_t`
        None

    See Also
    --------
    :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuDeviceSetMemPool`, :py:obj:`~.cuMemSetMemPool`
    """
    cdef cudaMemPool_t memPool = cudaMemPool_t()
    cdef cyruntime.cudaMemLocation* cylocation_ptr = location._pvt_ptr if location is not None else NULL
    cdef cyruntime.cudaMemAllocationType cytypename = int(typename)
    with nogil:
        err = cyruntime.cudaMemGetMemPool(<cyruntime.cudaMemPool_t*>memPool._pvt_ptr, cylocation_ptr, cytypename)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), memPool)
{{endif}}

{{if 'cudaMemSetMemPool' in found_functions}}

@cython.embedsignature(True)
def cudaMemSetMemPool(location : Optional[cudaMemLocation], typename not None : cudaMemAllocationType, memPool):
    """ Sets the current memory pool for a memory location and allocation type.

    The memory location can be of one of
    :py:obj:`~.cudaMemLocationTypeDevice`,
    :py:obj:`~.cudaMemLocationTypeHost` or
    :py:obj:`~.cudaMemLocationTypeHostNuma`. The allocation type can be one
    of :py:obj:`~.cudaMemAllocationTypePinned` or
    :py:obj:`~.cudaMemAllocationTypeManaged`. When the allocation type is
    :py:obj:`~.cudaMemAllocationTypeManaged`, the location type can also be
    :py:obj:`~.cudaMemLocationTypeNone` to indicate no preferred location
    for the managed memory pool. In all other cases, the call return
    :py:obj:`~.cudaErrorInvalidValue`

    When a memory pool is set as the current memory pool, the location
    parameter should be the same as the location of the pool. If the
    location type or index don't match, the call returns
    :py:obj:`~.cudaErrorInvalidValue`. The type of memory pool should also
    match the parameter allocType. Else the call returns
    :py:obj:`~.cudaErrorInvalidValue`.   By default, a memory location's
    current memory pool is its default memory pool. If the location type is
    :py:obj:`~.cudaMemLocationTypeDevice` and the allocation type is
    :py:obj:`~.cudaMemAllocationTypePinned`, then this API is the
    equivalent of calling :py:obj:`~.cudaDeviceSetMemPool` with the
    location id as the device. For further details on the implications,
    please refer to the documentation for :py:obj:`~.cudaDeviceSetMemPool`.

    Parameters
    ----------
    location : :py:obj:`~.cudaMemLocation`
        None
    typename : :py:obj:`~.cudaMemAllocationType`
        None
    memPool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        None

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemGetMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuMemPoolDestroy`, :py:obj:`~.cuMemAllocFromPoolAsync`

    Notes
    -----
    Use :py:obj:`~.cudaMallocFromPoolAsync` to specify asynchronous allocations from a device different than the one the stream runs on.
    """
    cdef cyruntime.cudaMemPool_t cymemPool
    if memPool is None:
        pmemPool = 0
    elif isinstance(memPool, (cudaMemPool_t,driver.CUmemoryPool)):
        pmemPool = int(memPool)
    else:
        pmemPool = int(cudaMemPool_t(memPool))
    cymemPool = <cyruntime.cudaMemPool_t><void_ptr>pmemPool
    cdef cyruntime.cudaMemLocation* cylocation_ptr = location._pvt_ptr if location is not None else NULL
    cdef cyruntime.cudaMemAllocationType cytypename = int(typename)
    with nogil:
        err = cyruntime.cudaMemSetMemPool(cylocation_ptr, cytypename, cymemPool)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaMallocFromPoolAsync' in found_functions}}

@cython.embedsignature(True)
def cudaMallocFromPoolAsync(size_t size, memPool, stream):
    """ Allocates memory from a specified pool with stream ordered semantics.

    Inserts an allocation operation into `hStream`. A pointer to the
    allocated memory is returned immediately in *dptr. The allocation must
    not be accessed until the the allocation operation completes. The
    allocation comes from the specified memory pool.

    Parameters
    ----------
    bytesize : size_t
        Number of bytes to allocate
    memPool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        The pool to allocate from
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream establishing the stream ordering semantic

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotSupported`, :py:obj:`~.cudaErrorOutOfMemory`
    ptr : Any
        Returned device pointer

    See Also
    --------
    :py:obj:`~.cuMemAllocFromPoolAsync`, cudaMallocAsync (C++ API), :py:obj:`~.cudaMallocAsync`, :py:obj:`~.cudaFreeAsync`, :py:obj:`~.cudaDeviceGetDefaultMemPool`, :py:obj:`~.cudaMemPoolCreate`, :py:obj:`~.cudaMemPoolSetAccess`, :py:obj:`~.cudaMemPoolSetAttribute`

    Notes
    -----
    During stream capture, this function results in the creation of an allocation node. In this case, the allocation is owned by the graph instead of the memory pool. The memory pool's properties are used to set the node's creation parameters.
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaMemPool_t cymemPool
    if memPool is None:
        pmemPool = 0
    elif isinstance(memPool, (cudaMemPool_t,driver.CUmemoryPool)):
        pmemPool = int(memPool)
    else:
        pmemPool = int(cudaMemPool_t(memPool))
    cymemPool = <cyruntime.cudaMemPool_t><void_ptr>pmemPool
    cdef void_ptr ptr = 0
    with nogil:
        err = cyruntime.cudaMallocFromPoolAsync(<void**>&ptr, size, cymemPool, cystream)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), ptr)
{{endif}}

{{if 'cudaMemPoolExportToShareableHandle' in found_functions}}

@cython.embedsignature(True)
def cudaMemPoolExportToShareableHandle(memPool, handleType not None : cudaMemAllocationHandleType, unsigned int flags):
    """ Exports a memory pool to the requested handle type.

    Given an IPC capable mempool, create an OS handle to share the pool
    with another process. A recipient process can convert the shareable
    handle into a mempool with
    :py:obj:`~.cudaMemPoolImportFromShareableHandle`. Individual pointers
    can then be shared with the :py:obj:`~.cudaMemPoolExportPointer` and
    :py:obj:`~.cudaMemPoolImportPointer` APIs. The implementation of what
    the shareable handle is and how it can be transferred is defined by the
    requested handle type.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        pool to export
    handleType : :py:obj:`~.cudaMemAllocationHandleType`
        the type of handle to create
    flags : unsigned int
        must be 0

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorOutOfMemory`
    handle_out : Any
        pointer to the location in which to store the requested handle

    See Also
    --------
    :py:obj:`~.cuMemPoolExportToShareableHandle`, :py:obj:`~.cudaMemPoolImportFromShareableHandle`, :py:obj:`~.cudaMemPoolExportPointer`, :py:obj:`~.cudaMemPoolImportPointer`

    Notes
    -----
    : To create an IPC capable mempool, create a mempool with a CUmemAllocationHandleType other than cudaMemHandleTypeNone.
    """
    cdef cyruntime.cudaMemPool_t cymemPool
    if memPool is None:
        pmemPool = 0
    elif isinstance(memPool, (cudaMemPool_t,driver.CUmemoryPool)):
        pmemPool = int(memPool)
    else:
        pmemPool = int(cudaMemPool_t(memPool))
    cymemPool = <cyruntime.cudaMemPool_t><void_ptr>pmemPool
    cdef _HelperCUmemAllocationHandleType cyshareableHandle = _HelperCUmemAllocationHandleType(handleType)
    cdef void* cyshareableHandle_ptr = <void*><void_ptr>cyshareableHandle.cptr
    cdef cyruntime.cudaMemAllocationHandleType cyhandleType = int(handleType)
    with nogil:
        err = cyruntime.cudaMemPoolExportToShareableHandle(cyshareableHandle_ptr, cymemPool, cyhandleType, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), cyshareableHandle.pyObj())
{{endif}}

{{if 'cudaMemPoolImportFromShareableHandle' in found_functions}}

@cython.embedsignature(True)
def cudaMemPoolImportFromShareableHandle(shareableHandle, handleType not None : cudaMemAllocationHandleType, unsigned int flags):
    """ imports a memory pool from a shared handle.

    Specific allocations can be imported from the imported pool with
    :py:obj:`~.cudaMemPoolImportPointer`.

    Parameters
    ----------
    handle : Any
        OS handle of the pool to open
    handleType : :py:obj:`~.cudaMemAllocationHandleType`
        The type of handle being imported
    flags : unsigned int
        must be 0

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorOutOfMemory`
    pool_out : :py:obj:`~.cudaMemPool_t`
        Returned memory pool

    See Also
    --------
    :py:obj:`~.cuMemPoolImportFromShareableHandle`, :py:obj:`~.cudaMemPoolExportToShareableHandle`, :py:obj:`~.cudaMemPoolExportPointer`, :py:obj:`~.cudaMemPoolImportPointer`

    Notes
    -----
    Imported memory pools do not support creating new allocations. As such imported memory pools may not be used in :py:obj:`~.cudaDeviceSetMemPool` or :py:obj:`~.cudaMallocFromPoolAsync` calls.
    """
    cdef cudaMemPool_t memPool = cudaMemPool_t()
    cdef _HelperInputVoidPtrStruct cyshareableHandleHelper
    cdef void* cyshareableHandle = _helper_input_void_ptr(shareableHandle, &cyshareableHandleHelper)
    cdef cyruntime.cudaMemAllocationHandleType cyhandleType = int(handleType)
    with nogil:
        err = cyruntime.cudaMemPoolImportFromShareableHandle(<cyruntime.cudaMemPool_t*>memPool._pvt_ptr, cyshareableHandle, cyhandleType, flags)
    _helper_input_void_ptr_free(&cyshareableHandleHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), memPool)
{{endif}}

{{if 'cudaMemPoolExportPointer' in found_functions}}

@cython.embedsignature(True)
def cudaMemPoolExportPointer(ptr):
    """ Export data to share a memory pool allocation between processes.

    Constructs `shareData_out` for sharing a specific allocation from an
    already shared memory pool. The recipient process can import the
    allocation with the :py:obj:`~.cudaMemPoolImportPointer` api. The data
    is not a handle and may be shared through any IPC mechanism.

    Parameters
    ----------
    ptr : Any
        pointer to memory being exported

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorOutOfMemory`
    shareData_out : :py:obj:`~.cudaMemPoolPtrExportData`
        Returned export data

    See Also
    --------
    :py:obj:`~.cuMemPoolExportPointer`, :py:obj:`~.cudaMemPoolExportToShareableHandle`, :py:obj:`~.cudaMemPoolImportFromShareableHandle`, :py:obj:`~.cudaMemPoolImportPointer`
    """
    cdef cudaMemPoolPtrExportData exportData = cudaMemPoolPtrExportData()
    cdef _HelperInputVoidPtrStruct cyptrHelper
    cdef void* cyptr = _helper_input_void_ptr(ptr, &cyptrHelper)
    with nogil:
        err = cyruntime.cudaMemPoolExportPointer(<cyruntime.cudaMemPoolPtrExportData*>exportData._pvt_ptr, cyptr)
    _helper_input_void_ptr_free(&cyptrHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), exportData)
{{endif}}

{{if 'cudaMemPoolImportPointer' in found_functions}}

@cython.embedsignature(True)
def cudaMemPoolImportPointer(memPool, exportData : Optional[cudaMemPoolPtrExportData]):
    """ Import a memory pool allocation from another process.

    Returns in `ptr_out` a pointer to the imported memory. The imported
    memory must not be accessed before the allocation operation completes
    in the exporting process. The imported memory must be freed from all
    importing processes before being freed in the exporting process. The
    pointer may be freed with cudaFree or cudaFreeAsync. If
    :py:obj:`~.cudaFreeAsync` is used, the free must be completed on the
    importing process before the free operation on the exporting process.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        pool from which to import
    shareData : :py:obj:`~.cudaMemPoolPtrExportData`
        data specifying the memory to import

    Returns
    -------
    cudaError_t
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    ptr_out : Any
        pointer to imported memory

    See Also
    --------
    :py:obj:`~.cuMemPoolImportPointer`, :py:obj:`~.cudaMemPoolExportToShareableHandle`, :py:obj:`~.cudaMemPoolImportFromShareableHandle`, :py:obj:`~.cudaMemPoolExportPointer`

    Notes
    -----
    The :py:obj:`~.cudaFreeAsync` api may be used in the exporting process before the :py:obj:`~.cudaFreeAsync` operation completes in its stream as long as the :py:obj:`~.cudaFreeAsync` in the exporting process specifies a stream with a stream dependency on the importing process's :py:obj:`~.cudaFreeAsync`.
    """
    cdef cyruntime.cudaMemPool_t cymemPool
    if memPool is None:
        pmemPool = 0
    elif isinstance(memPool, (cudaMemPool_t,driver.CUmemoryPool)):
        pmemPool = int(memPool)
    else:
        pmemPool = int(cudaMemPool_t(memPool))
    cymemPool = <cyruntime.cudaMemPool_t><void_ptr>pmemPool
    cdef void_ptr ptr = 0
    cdef cyruntime.cudaMemPoolPtrExportData* cyexportData_ptr = exportData._pvt_ptr if exportData is not None else NULL
    with nogil:
        err = cyruntime.cudaMemPoolImportPointer(<void**>&ptr, cymemPool, cyexportData_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), ptr)
{{endif}}

{{if 'cudaPointerGetAttributes' in found_functions}}

@cython.embedsignature(True)
def cudaPointerGetAttributes(ptr):
    """ Returns attributes about a specified pointer.

    Returns in `*attributes` the attributes of the pointer `ptr`. If
    pointer was not allocated in, mapped by or registered with context
    supporting unified addressing :py:obj:`~.cudaErrorInvalidValue` is
    returned.

    The :py:obj:`~.cudaPointerAttributes` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    In this structure, the individual fields mean

    - :py:obj:`~.cudaPointerAttributes.type` identifies type of memory. It
      can be :py:obj:`~.cudaMemoryTypeUnregistered` for unregistered host
      memory, :py:obj:`~.cudaMemoryTypeHost` for registered host memory,
      :py:obj:`~.cudaMemoryTypeDevice` for device memory or
      :py:obj:`~.cudaMemoryTypeManaged` for managed memory.

    - :py:obj:`~.device` is the device against which `ptr` was allocated.
      If `ptr` has memory type :py:obj:`~.cudaMemoryTypeDevice` then this
      identifies the device on which the memory referred to by `ptr`
      physically resides. If `ptr` has memory type
      :py:obj:`~.cudaMemoryTypeHost` then this identifies the device which
      was current when the allocation was made (and if that device is
      deinitialized then this allocation will vanish with that device's
      state).

    - :py:obj:`~.devicePointer` is the device pointer alias through which
      the memory referred to by `ptr` may be accessed on the current
      device. If the memory referred to by `ptr` cannot be accessed
      directly by the current device then this is NULL.

    - :py:obj:`~.hostPointer` is the host pointer alias through which the
      memory referred to by `ptr` may be accessed on the host. If the
      memory referred to by `ptr` cannot be accessed directly by the host
      then this is NULL.

    Parameters
    ----------
    ptr : Any
        Pointer to get attributes for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidValue`
    attributes : :py:obj:`~.cudaPointerAttributes`
        Attributes for the specified pointer

    See Also
    --------
    :py:obj:`~.cudaGetDeviceCount`, :py:obj:`~.cudaGetDevice`, :py:obj:`~.cudaSetDevice`, :py:obj:`~.cudaChooseDevice`, :py:obj:`~.cudaInitDevice`, :py:obj:`~.cuPointerGetAttributes`

    Notes
    -----
    In CUDA 11.0 forward passing host pointer will return :py:obj:`~.cudaMemoryTypeUnregistered` in :py:obj:`~.cudaPointerAttributes.type` and call will return :py:obj:`~.cudaSuccess`.
    """
    cdef cudaPointerAttributes attributes = cudaPointerAttributes()
    cdef _HelperInputVoidPtrStruct cyptrHelper
    cdef void* cyptr = _helper_input_void_ptr(ptr, &cyptrHelper)
    with nogil:
        err = cyruntime.cudaPointerGetAttributes(<cyruntime.cudaPointerAttributes*>attributes._pvt_ptr, cyptr)
    _helper_input_void_ptr_free(&cyptrHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), attributes)
{{endif}}

{{if 'cudaDeviceCanAccessPeer' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceCanAccessPeer(int device, int peerDevice):
    """ Queries if a device may directly access a peer device's memory.

    Returns in `*canAccessPeer` a value of 1 if device `device` is capable
    of directly accessing memory from `peerDevice` and 0 otherwise. If
    direct access of `peerDevice` from `device` is possible, then access
    may be enabled by calling :py:obj:`~.cudaDeviceEnablePeerAccess()`.

    Parameters
    ----------
    device : int
        Device from which allocations on `peerDevice` are to be directly
        accessed.
    peerDevice : int
        Device on which the allocations to be directly accessed by `device`
        reside.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`
    canAccessPeer : int
        Returned access capability

    See Also
    --------
    :py:obj:`~.cudaDeviceEnablePeerAccess`, :py:obj:`~.cudaDeviceDisablePeerAccess`, :py:obj:`~.cuDeviceCanAccessPeer`
    """
    cdef int canAccessPeer = 0
    with nogil:
        err = cyruntime.cudaDeviceCanAccessPeer(&canAccessPeer, device, peerDevice)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), canAccessPeer)
{{endif}}

{{if 'cudaDeviceEnablePeerAccess' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceEnablePeerAccess(int peerDevice, unsigned int flags):
    """ Enables direct access to memory allocations on a peer device.

    On success, all allocations from `peerDevice` will immediately be
    accessible by the current device. They will remain accessible until
    access is explicitly disabled using
    :py:obj:`~.cudaDeviceDisablePeerAccess()` or either device is reset
    using :py:obj:`~.cudaDeviceReset()`.

    Note that access granted by this call is unidirectional and that in
    order to access memory on the current device from `peerDevice`, a
    separate symmetric call to :py:obj:`~.cudaDeviceEnablePeerAccess()` is
    required.

    Note that there are both device-wide and system-wide limitations per
    system configuration, as noted in the CUDA Programming Guide under the
    section "Peer-to-Peer Memory Access".

    Returns :py:obj:`~.cudaErrorInvalidDevice` if
    :py:obj:`~.cudaDeviceCanAccessPeer()` indicates that the current device
    cannot directly access memory from `peerDevice`.

    Returns :py:obj:`~.cudaErrorPeerAccessAlreadyEnabled` if direct access
    of `peerDevice` from the current device has already been enabled.

    Returns :py:obj:`~.cudaErrorInvalidValue` if `flags` is not 0.

    Parameters
    ----------
    peerDevice : int
        Peer device to enable direct access to from the current device
    flags : unsigned int
        Reserved for future use and must be set to 0

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorPeerAccessAlreadyEnabled`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaDeviceCanAccessPeer`, :py:obj:`~.cudaDeviceDisablePeerAccess`, :py:obj:`~.cuCtxEnablePeerAccess`
    """
    with nogil:
        err = cyruntime.cudaDeviceEnablePeerAccess(peerDevice, flags)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaDeviceDisablePeerAccess' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceDisablePeerAccess(int peerDevice):
    """ Disables direct access to memory allocations on a peer device.

    Returns :py:obj:`~.cudaErrorPeerAccessNotEnabled` if direct access to
    memory on `peerDevice` has not yet been enabled from the current
    device.

    Parameters
    ----------
    peerDevice : int
        Peer device to disable direct access to

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorPeerAccessNotEnabled`, :py:obj:`~.cudaErrorInvalidDevice`

    See Also
    --------
    :py:obj:`~.cudaDeviceCanAccessPeer`, :py:obj:`~.cudaDeviceEnablePeerAccess`, :py:obj:`~.cuCtxDisablePeerAccess`
    """
    with nogil:
        err = cyruntime.cudaDeviceDisablePeerAccess(peerDevice)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphicsUnregisterResource' in found_functions}}

@cython.embedsignature(True)
def cudaGraphicsUnregisterResource(resource):
    """ Unregisters a graphics resource for access by CUDA.

    Unregisters the graphics resource `resource` so it is not accessible by
    CUDA unless registered again.

    If `resource` is invalid then
    :py:obj:`~.cudaErrorInvalidResourceHandle` is returned.

    Parameters
    ----------
    resource : :py:obj:`~.cudaGraphicsResource_t`
        Resource to unregister

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorUnknown`

    See Also
    --------
    :py:obj:`~.cudaGraphicsD3D9RegisterResource`, :py:obj:`~.cudaGraphicsD3D10RegisterResource`, :py:obj:`~.cudaGraphicsD3D11RegisterResource`, :py:obj:`~.cudaGraphicsGLRegisterBuffer`, :py:obj:`~.cudaGraphicsGLRegisterImage`, :py:obj:`~.cuGraphicsUnregisterResource`
    """
    cdef cyruntime.cudaGraphicsResource_t cyresource
    if resource is None:
        presource = 0
    elif isinstance(resource, (cudaGraphicsResource_t,)):
        presource = int(resource)
    else:
        presource = int(cudaGraphicsResource_t(resource))
    cyresource = <cyruntime.cudaGraphicsResource_t><void_ptr>presource
    with nogil:
        err = cyruntime.cudaGraphicsUnregisterResource(cyresource)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphicsResourceSetMapFlags' in found_functions}}

@cython.embedsignature(True)
def cudaGraphicsResourceSetMapFlags(resource, unsigned int flags):
    """ Set usage flags for mapping a graphics resource.

    Set `flags` for mapping the graphics resource `resource`.

    Changes to `flags` will take effect the next time `resource` is mapped.
    The `flags` argument may be any of the following:

    - :py:obj:`~.cudaGraphicsMapFlagsNone`: Specifies no hints about how
      `resource` will be used. It is therefore assumed that CUDA may read
      from or write to `resource`.

    - :py:obj:`~.cudaGraphicsMapFlagsReadOnly`: Specifies that CUDA will
      not write to `resource`.

    - :py:obj:`~.cudaGraphicsMapFlagsWriteDiscard`: Specifies CUDA will not
      read from `resource` and will write over the entire contents of
      `resource`, so none of the data previously stored in `resource` will
      be preserved.

    If `resource` is presently mapped for access by CUDA then
    :py:obj:`~.cudaErrorUnknown` is returned. If `flags` is not one of the
    above values then :py:obj:`~.cudaErrorInvalidValue` is returned.

    Parameters
    ----------
    resource : :py:obj:`~.cudaGraphicsResource_t`
        Registered resource to set flags for
    flags : unsigned int
        Parameters for resource mapping

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorUnknown`,

    See Also
    --------
    :py:obj:`~.cudaGraphicsMapResources`, :py:obj:`~.cuGraphicsResourceSetMapFlags`
    """
    cdef cyruntime.cudaGraphicsResource_t cyresource
    if resource is None:
        presource = 0
    elif isinstance(resource, (cudaGraphicsResource_t,)):
        presource = int(resource)
    else:
        presource = int(cudaGraphicsResource_t(resource))
    cyresource = <cyruntime.cudaGraphicsResource_t><void_ptr>presource
    with nogil:
        err = cyruntime.cudaGraphicsResourceSetMapFlags(cyresource, flags)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphicsMapResources' in found_functions}}

@cython.embedsignature(True)
def cudaGraphicsMapResources(int count, resources, stream):
    """ Map graphics resources for access by CUDA.

    Maps the `count` graphics resources in `resources` for access by CUDA.

    The resources in `resources` may be accessed by CUDA until they are
    unmapped. The graphics API from which `resources` were registered
    should not access any resources while they are mapped by CUDA. If an
    application does so, the results are undefined.

    This function provides the synchronization guarantee that any graphics
    calls issued before :py:obj:`~.cudaGraphicsMapResources()` will
    complete before any subsequent CUDA work issued in `stream` begins.

    If `resources` contains any duplicate entries then
    :py:obj:`~.cudaErrorInvalidResourceHandle` is returned. If any of
    `resources` are presently mapped for access by CUDA then
    :py:obj:`~.cudaErrorUnknown` is returned.

    Parameters
    ----------
    count : int
        Number of resources to map
    resources : :py:obj:`~.cudaGraphicsResource_t`
        Resources to map for CUDA
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream for synchronization

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorUnknown`

    See Also
    --------
    :py:obj:`~.cudaGraphicsResourceGetMappedPointer`, :py:obj:`~.cudaGraphicsSubResourceGetMappedArray`, :py:obj:`~.cudaGraphicsUnmapResources`, :py:obj:`~.cuGraphicsMapResources`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaGraphicsResource_t *cyresources
    if resources is None:
        cyresources = <cyruntime.cudaGraphicsResource_t*><void_ptr>NULL
    elif isinstance(resources, (cudaGraphicsResource_t,)):
        presources = resources.getPtr()
        cyresources = <cyruntime.cudaGraphicsResource_t*><void_ptr>presources
    elif isinstance(resources, (int)):
        cyresources = <cyruntime.cudaGraphicsResource_t*><void_ptr>resources
    else:
        raise TypeError("Argument 'resources' is not instance of type (expected <class 'int, runtime.cudaGraphicsResource_t'>, found " + str(type(resources)))
    with nogil:
        err = cyruntime.cudaGraphicsMapResources(count, cyresources, cystream)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphicsUnmapResources' in found_functions}}

@cython.embedsignature(True)
def cudaGraphicsUnmapResources(int count, resources, stream):
    """ Unmap graphics resources.

    Unmaps the `count` graphics resources in `resources`.

    Once unmapped, the resources in `resources` may not be accessed by CUDA
    until they are mapped again.

    This function provides the synchronization guarantee that any CUDA work
    issued in `stream` before :py:obj:`~.cudaGraphicsUnmapResources()` will
    complete before any subsequently issued graphics work begins.

    If `resources` contains any duplicate entries then
    :py:obj:`~.cudaErrorInvalidResourceHandle` is returned. If any of
    `resources` are not presently mapped for access by CUDA then
    :py:obj:`~.cudaErrorUnknown` is returned.

    Parameters
    ----------
    count : int
        Number of resources to unmap
    resources : :py:obj:`~.cudaGraphicsResource_t`
        Resources to unmap
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream for synchronization

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorUnknown`

    See Also
    --------
    :py:obj:`~.cudaGraphicsMapResources`, :py:obj:`~.cuGraphicsUnmapResources`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaGraphicsResource_t *cyresources
    if resources is None:
        cyresources = <cyruntime.cudaGraphicsResource_t*><void_ptr>NULL
    elif isinstance(resources, (cudaGraphicsResource_t,)):
        presources = resources.getPtr()
        cyresources = <cyruntime.cudaGraphicsResource_t*><void_ptr>presources
    elif isinstance(resources, (int)):
        cyresources = <cyruntime.cudaGraphicsResource_t*><void_ptr>resources
    else:
        raise TypeError("Argument 'resources' is not instance of type (expected <class 'int, runtime.cudaGraphicsResource_t'>, found " + str(type(resources)))
    with nogil:
        err = cyruntime.cudaGraphicsUnmapResources(count, cyresources, cystream)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphicsResourceGetMappedPointer' in found_functions}}

@cython.embedsignature(True)
def cudaGraphicsResourceGetMappedPointer(resource):
    """ Get an device pointer through which to access a mapped graphics resource.

    Returns in `*devPtr` a pointer through which the mapped graphics
    resource `resource` may be accessed. Returns in `*size` the size of the
    memory in bytes which may be accessed from that pointer. The value set
    in `devPtr` may change every time that `resource` is mapped.

    If `resource` is not a buffer then it cannot be accessed via a pointer
    and :py:obj:`~.cudaErrorUnknown` is returned. If `resource` is not
    mapped then :py:obj:`~.cudaErrorUnknown` is returned.

    Parameters
    ----------
    resource : :py:obj:`~.cudaGraphicsResource_t`
        None

    Returns
    -------
    cudaError_t

    devPtr : Any
        None
    size : int
        None
    """
    cdef cyruntime.cudaGraphicsResource_t cyresource
    if resource is None:
        presource = 0
    elif isinstance(resource, (cudaGraphicsResource_t,)):
        presource = int(resource)
    else:
        presource = int(cudaGraphicsResource_t(resource))
    cyresource = <cyruntime.cudaGraphicsResource_t><void_ptr>presource
    cdef void_ptr devPtr = 0
    cdef size_t size = 0
    with nogil:
        err = cyruntime.cudaGraphicsResourceGetMappedPointer(<void**>&devPtr, &size, cyresource)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None)
    return (cudaError_t(err), devPtr, size)
{{endif}}

{{if 'cudaGraphicsSubResourceGetMappedArray' in found_functions}}

@cython.embedsignature(True)
def cudaGraphicsSubResourceGetMappedArray(resource, unsigned int arrayIndex, unsigned int mipLevel):
    """ Get an array through which to access a subresource of a mapped graphics resource.

    Returns in `*array` an array through which the subresource of the
    mapped graphics resource `resource` which corresponds to array index
    `arrayIndex` and mipmap level `mipLevel` may be accessed. The value set
    in `array` may change every time that `resource` is mapped.

    If `resource` is not a texture then it cannot be accessed via an array
    and :py:obj:`~.cudaErrorUnknown` is returned. If `arrayIndex` is not a
    valid array index for `resource` then :py:obj:`~.cudaErrorInvalidValue`
    is returned. If `mipLevel` is not a valid mipmap level for `resource`
    then :py:obj:`~.cudaErrorInvalidValue` is returned. If `resource` is
    not mapped then :py:obj:`~.cudaErrorUnknown` is returned.

    Parameters
    ----------
    resource : :py:obj:`~.cudaGraphicsResource_t`
        Mapped resource to access
    arrayIndex : unsigned int
        Array index for array textures or cubemap face index as defined by
        :py:obj:`~.cudaGraphicsCubeFace` for cubemap textures for the
        subresource to access
    mipLevel : unsigned int
        Mipmap level for the subresource to access

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorUnknown`
    array : :py:obj:`~.cudaArray_t`
        Returned array through which a subresource of `resource` may be
        accessed

    See Also
    --------
    :py:obj:`~.cudaGraphicsResourceGetMappedPointer`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`
    """
    cdef cyruntime.cudaGraphicsResource_t cyresource
    if resource is None:
        presource = 0
    elif isinstance(resource, (cudaGraphicsResource_t,)):
        presource = int(resource)
    else:
        presource = int(cudaGraphicsResource_t(resource))
    cyresource = <cyruntime.cudaGraphicsResource_t><void_ptr>presource
    cdef cudaArray_t array = cudaArray_t()
    with nogil:
        err = cyruntime.cudaGraphicsSubResourceGetMappedArray(<cyruntime.cudaArray_t*>array._pvt_ptr, cyresource, arrayIndex, mipLevel)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), array)
{{endif}}

{{if 'cudaGraphicsResourceGetMappedMipmappedArray' in found_functions}}

@cython.embedsignature(True)
def cudaGraphicsResourceGetMappedMipmappedArray(resource):
    """ Get a mipmapped array through which to access a mapped graphics resource.

    Returns in `*mipmappedArray` a mipmapped array through which the mapped
    graphics resource `resource` may be accessed. The value set in
    `mipmappedArray` may change every time that `resource` is mapped.

    If `resource` is not a texture then it cannot be accessed via an array
    and :py:obj:`~.cudaErrorUnknown` is returned. If `resource` is not
    mapped then :py:obj:`~.cudaErrorUnknown` is returned.

    Parameters
    ----------
    resource : :py:obj:`~.cudaGraphicsResource_t`
        Mapped resource to access

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorUnknown`
    mipmappedArray : :py:obj:`~.cudaMipmappedArray_t`
        Returned mipmapped array through which `resource` may be accessed

    See Also
    --------
    :py:obj:`~.cudaGraphicsResourceGetMappedPointer`, :py:obj:`~.cuGraphicsResourceGetMappedMipmappedArray`
    """
    cdef cyruntime.cudaGraphicsResource_t cyresource
    if resource is None:
        presource = 0
    elif isinstance(resource, (cudaGraphicsResource_t,)):
        presource = int(resource)
    else:
        presource = int(cudaGraphicsResource_t(resource))
    cyresource = <cyruntime.cudaGraphicsResource_t><void_ptr>presource
    cdef cudaMipmappedArray_t mipmappedArray = cudaMipmappedArray_t()
    with nogil:
        err = cyruntime.cudaGraphicsResourceGetMappedMipmappedArray(<cyruntime.cudaMipmappedArray_t*>mipmappedArray._pvt_ptr, cyresource)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), mipmappedArray)
{{endif}}

{{if 'cudaGetChannelDesc' in found_functions}}

@cython.embedsignature(True)
def cudaGetChannelDesc(array):
    """ Get the channel descriptor of an array.

    Returns in `*desc` the channel descriptor of the CUDA array `array`.

    Parameters
    ----------
    array : :py:obj:`~.cudaArray_const_t`
        Memory array on device

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    desc : :py:obj:`~.cudaChannelFormatDesc`
        Channel format

    See Also
    --------
    :py:obj:`~.cudaCreateChannelDesc (C API)`, :py:obj:`~.cudaCreateTextureObject`, :py:obj:`~.cudaCreateSurfaceObject`
    """
    cdef cyruntime.cudaArray_const_t cyarray
    if array is None:
        parray = 0
    elif isinstance(array, (cudaArray_const_t,)):
        parray = int(array)
    else:
        parray = int(cudaArray_const_t(array))
    cyarray = <cyruntime.cudaArray_const_t><void_ptr>parray
    cdef cudaChannelFormatDesc desc = cudaChannelFormatDesc()
    with nogil:
        err = cyruntime.cudaGetChannelDesc(<cyruntime.cudaChannelFormatDesc*>desc._pvt_ptr, cyarray)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), desc)
{{endif}}

{{if 'cudaCreateChannelDesc' in found_functions}}

@cython.embedsignature(True)
def cudaCreateChannelDesc(int x, int y, int z, int w, f not None : cudaChannelFormatKind):
    """ Returns a channel descriptor using the specified format.

    Returns a channel descriptor with format `f` and number of bits of each
    component `x`, `y`, `z`, and `w`. The :py:obj:`~.cudaChannelFormatDesc`
    is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.cudaChannelFormatKind` is one of
    :py:obj:`~.cudaChannelFormatKindSigned`,
    :py:obj:`~.cudaChannelFormatKindUnsigned`, or
    :py:obj:`~.cudaChannelFormatKindFloat`.

    Parameters
    ----------
    x : int
        X component
    y : int
        Y component
    z : int
        Z component
    w : int
        W component
    f : :py:obj:`~.cudaChannelFormatKind`
        Channel format

    Returns
    -------
    cudaError_t.cudaSuccess
        cudaError_t.cudaSuccess
    :py:obj:`~.cudaChannelFormatDesc`
        Channel descriptor with format `f`

    See Also
    --------
    cudaCreateChannelDesc (C++ API), :py:obj:`~.cudaGetChannelDesc`, :py:obj:`~.cudaCreateTextureObject`, :py:obj:`~.cudaCreateSurfaceObject`
    """
    cdef cyruntime.cudaChannelFormatKind cyf = int(f)
    with nogil:
        err = cyruntime.cudaCreateChannelDesc(x, y, z, w, cyf)
    cdef cudaChannelFormatDesc wrapper = cudaChannelFormatDesc()
    wrapper._pvt_ptr[0] = err
    return (cudaError_t.cudaSuccess, wrapper)
{{endif}}

{{if 'cudaCreateTextureObject' in found_functions}}

@cython.embedsignature(True)
def cudaCreateTextureObject(pResDesc : Optional[cudaResourceDesc], pTexDesc : Optional[cudaTextureDesc], pResViewDesc : Optional[cudaResourceViewDesc]):
    """ Creates a texture object.

    Creates a texture object and returns it in `pTexObject`. `pResDesc`
    describes the data to texture from. `pTexDesc` describes how the data
    should be sampled. `pResViewDesc` is an optional argument that
    specifies an alternate format for the data described by `pResDesc`, and
    also describes the subresource region to restrict access to when
    texturing. `pResViewDesc` can only be specified if the type of resource
    is a CUDA array or a CUDA mipmapped array not in a block compressed
    format.

    Texture objects are only supported on devices of compute capability 3.0
    or higher. Additionally, a texture object is an opaque value, and, as
    such, should only be accessed through CUDA API calls.

    The :py:obj:`~.cudaResourceDesc` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.cudaResourceDesc.resType` specifies the type of resource
      to texture from. CUresourceType is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.cudaResourceDesc.resType` is set to
    :py:obj:`~.cudaResourceTypeArray`,
    :py:obj:`~.cudaResourceDesc`::res::array::array must be set to a valid
    CUDA array handle.

    If :py:obj:`~.cudaResourceDesc.resType` is set to
    :py:obj:`~.cudaResourceTypeMipmappedArray`,
    :py:obj:`~.cudaResourceDesc`::res::mipmap::mipmap must be set to a
    valid CUDA mipmapped array handle and
    :py:obj:`~.cudaTextureDesc.normalizedCoords` must be set to true.

    If :py:obj:`~.cudaResourceDesc.resType` is set to
    :py:obj:`~.cudaResourceTypeLinear`,
    :py:obj:`~.cudaResourceDesc`::res::linear::devPtr must be set to a
    valid device pointer, that is aligned to
    :py:obj:`~.cudaDeviceProp.textureAlignment`.
    :py:obj:`~.cudaResourceDesc`::res::linear::desc describes the format
    and the number of components per array element.
    :py:obj:`~.cudaResourceDesc`::res::linear::sizeInBytes specifies the
    size of the array in bytes. The total number of elements in the linear
    address range cannot exceed
    :py:obj:`~.cudaDeviceGetTexture1DLinearMaxWidth()`. The number of
    elements is computed as (sizeInBytes / sizeof(desc)).

    If :py:obj:`~.cudaResourceDesc.resType` is set to
    :py:obj:`~.cudaResourceTypePitch2D`,
    :py:obj:`~.cudaResourceDesc`::res::pitch2D::devPtr must be set to a
    valid device pointer, that is aligned to
    :py:obj:`~.cudaDeviceProp.textureAlignment`.
    :py:obj:`~.cudaResourceDesc`::res::pitch2D::desc describes the format
    and the number of components per array element.
    :py:obj:`~.cudaResourceDesc`::res::pitch2D::width and
    :py:obj:`~.cudaResourceDesc`::res::pitch2D::height specify the width
    and height of the array in elements, and cannot exceed
    :py:obj:`~.cudaDeviceProp.maxTexture2DLinear`[0] and
    :py:obj:`~.cudaDeviceProp.maxTexture2DLinear`[1] respectively.
    :py:obj:`~.cudaResourceDesc`::res::pitch2D::pitchInBytes specifies the
    pitch between two rows in bytes and has to be aligned to
    :py:obj:`~.cudaDeviceProp.texturePitchAlignment`. Pitch cannot exceed
    :py:obj:`~.cudaDeviceProp.maxTexture2DLinear`[2].

    The :py:obj:`~.cudaTextureDesc` struct is defined as

    **View CUDA Toolkit Documentation for a C++ code example**

    where

    - :py:obj:`~.cudaTextureDesc.addressMode` specifies the addressing mode
      for each dimension of the texture data.
      :py:obj:`~.cudaTextureAddressMode` is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - This is ignored if :py:obj:`~.cudaResourceDesc.resType` is
      :py:obj:`~.cudaResourceTypeLinear`. Also, if
      :py:obj:`~.cudaTextureDesc.normalizedCoords` is set to zero,
      :py:obj:`~.cudaAddressModeWrap` and :py:obj:`~.cudaAddressModeMirror`
      won't be supported and will be switched to
      :py:obj:`~.cudaAddressModeClamp`.

    - :py:obj:`~.cudaTextureDesc.filterMode` specifies the filtering mode
      to be used when fetching from the texture.
      :py:obj:`~.cudaTextureFilterMode` is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - This is ignored if :py:obj:`~.cudaResourceDesc.resType` is
      :py:obj:`~.cudaResourceTypeLinear`.

    - :py:obj:`~.cudaTextureDesc.readMode` specifies whether integer data
      should be converted to floating point or not.
      :py:obj:`~.cudaTextureReadMode` is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - Note that this applies only to 8-bit and 16-bit integer formats.
      32-bit integer format would not be promoted, regardless of whether or
      not this :py:obj:`~.cudaTextureDesc.readMode` is set
      :py:obj:`~.cudaReadModeNormalizedFloat` is specified.

    - :py:obj:`~.cudaTextureDesc.sRGB` specifies whether sRGB to linear
      conversion should be performed during texture fetch.

    - :py:obj:`~.cudaTextureDesc.borderColor` specifies the float values of
      color. where: :py:obj:`~.cudaTextureDesc.borderColor`[0] contains
      value of 'R', :py:obj:`~.cudaTextureDesc.borderColor`[1] contains
      value of 'G', :py:obj:`~.cudaTextureDesc.borderColor`[2] contains
      value of 'B', :py:obj:`~.cudaTextureDesc.borderColor`[3] contains
      value of 'A' Note that application using integer border color values
      will need to <reinterpret_cast> these values to float. The values are
      set only when the addressing mode specified by
      :py:obj:`~.cudaTextureDesc.addressMode` is cudaAddressModeBorder.

    - :py:obj:`~.cudaTextureDesc.normalizedCoords` specifies whether the
      texture coordinates will be normalized or not.

    - :py:obj:`~.cudaTextureDesc.maxAnisotropy` specifies the maximum
      anistropy ratio to be used when doing anisotropic filtering. This
      value will be clamped to the range [1,16].

    - :py:obj:`~.cudaTextureDesc.mipmapFilterMode` specifies the filter
      mode when the calculated mipmap level lies between two defined mipmap
      levels.

    - :py:obj:`~.cudaTextureDesc.mipmapLevelBias` specifies the offset to
      be applied to the calculated mipmap level.

    - :py:obj:`~.cudaTextureDesc.minMipmapLevelClamp` specifies the lower
      end of the mipmap level range to clamp access to.

    - :py:obj:`~.cudaTextureDesc.maxMipmapLevelClamp` specifies the upper
      end of the mipmap level range to clamp access to.

    - :py:obj:`~.cudaTextureDesc.disableTrilinearOptimization` specifies
      whether the trilinear filtering optimizations will be disabled.

    - :py:obj:`~.cudaTextureDesc.seamlessCubemap` specifies whether
      seamless cube map filtering is enabled. This flag can only be
      specified if the underlying resource is a CUDA array or a CUDA
      mipmapped array that was created with the flag
      :py:obj:`~.cudaArrayCubemap`. When seamless cube map filtering is
      enabled, texture address modes specified by
      :py:obj:`~.cudaTextureDesc.addressMode` are ignored. Instead, if the
      :py:obj:`~.cudaTextureDesc.filterMode` is set to
      :py:obj:`~.cudaFilterModePoint` the address mode
      :py:obj:`~.cudaAddressModeClamp` will be applied for all dimensions.
      If the :py:obj:`~.cudaTextureDesc.filterMode` is set to
      :py:obj:`~.cudaFilterModeLinear` seamless cube map filtering will be
      performed when sampling along the cube face borders.

    The :py:obj:`~.cudaResourceViewDesc` struct is defined as

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.cudaResourceViewDesc.format` specifies how the data
      contained in the CUDA array or CUDA mipmapped array should be
      interpreted. Note that this can incur a change in size of the texture
      data. If the resource view format is a block compressed format, then
      the underlying CUDA array or CUDA mipmapped array has to have a
      32-bit unsigned integer format with 2 or 4 channels, depending on the
      block compressed format. For ex., BC1 and BC4 require the underlying
      CUDA array to have a 32-bit unsigned int with 2 channels. The other
      BC formats require the underlying resource to have the same 32-bit
      unsigned int format but with 4 channels.

    - :py:obj:`~.cudaResourceViewDesc.width` specifies the new width of the
      texture data. If the resource view format is a block compressed
      format, this value has to be 4 times the original width of the
      resource. For non block compressed formats, this value has to be
      equal to that of the original resource.

    - :py:obj:`~.cudaResourceViewDesc.height` specifies the new height of
      the texture data. If the resource view format is a block compressed
      format, this value has to be 4 times the original height of the
      resource. For non block compressed formats, this value has to be
      equal to that of the original resource.

    - :py:obj:`~.cudaResourceViewDesc.depth` specifies the new depth of the
      texture data. This value has to be equal to that of the original
      resource.

    - :py:obj:`~.cudaResourceViewDesc.firstMipmapLevel` specifies the most
      detailed mipmap level. This will be the new mipmap level zero. For
      non-mipmapped resources, this value has to be
      zero.:py:obj:`~.cudaTextureDesc.minMipmapLevelClamp` and
      :py:obj:`~.cudaTextureDesc.maxMipmapLevelClamp` will be relative to
      this value. For ex., if the firstMipmapLevel is set to 2, and a
      minMipmapLevelClamp of 1.2 is specified, then the actual minimum
      mipmap level clamp will be 3.2.

    - :py:obj:`~.cudaResourceViewDesc.lastMipmapLevel` specifies the least
      detailed mipmap level. For non-mipmapped resources, this value has to
      be zero.

    - :py:obj:`~.cudaResourceViewDesc.firstLayer` specifies the first layer
      index for layered textures. This will be the new layer zero. For non-
      layered resources, this value has to be zero.

    - :py:obj:`~.cudaResourceViewDesc.lastLayer` specifies the last layer
      index for layered textures. For non-layered resources, this value has
      to be zero.

    Parameters
    ----------
    pResDesc : :py:obj:`~.cudaResourceDesc`
        Resource descriptor
    pTexDesc : :py:obj:`~.cudaTextureDesc`
        Texture descriptor
    pResViewDesc : :py:obj:`~.cudaResourceViewDesc`
        Resource view descriptor

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pTexObject : :py:obj:`~.cudaTextureObject_t`
        Texture object to create

    See Also
    --------
    :py:obj:`~.cudaDestroyTextureObject`, :py:obj:`~.cuTexObjectCreate`
    """
    cdef cudaTextureObject_t pTexObject = cudaTextureObject_t()
    cdef cyruntime.cudaResourceDesc* cypResDesc_ptr = pResDesc._pvt_ptr if pResDesc is not None else NULL
    cdef cyruntime.cudaTextureDesc* cypTexDesc_ptr = pTexDesc._pvt_ptr if pTexDesc is not None else NULL
    cdef cyruntime.cudaResourceViewDesc* cypResViewDesc_ptr = pResViewDesc._pvt_ptr if pResViewDesc is not None else NULL
    with nogil:
        err = cyruntime.cudaCreateTextureObject(<cyruntime.cudaTextureObject_t*>pTexObject._pvt_ptr, cypResDesc_ptr, cypTexDesc_ptr, cypResViewDesc_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pTexObject)
{{endif}}

{{if 'cudaDestroyTextureObject' in found_functions}}

@cython.embedsignature(True)
def cudaDestroyTextureObject(texObject):
    """ Destroys a texture object.

    Destroys the texture object specified by `texObject`.

    Parameters
    ----------
    texObject : :py:obj:`~.cudaTextureObject_t`
        Texture object to destroy

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaCreateTextureObject`, :py:obj:`~.cuTexObjectDestroy`
    """
    cdef cyruntime.cudaTextureObject_t cytexObject
    if texObject is None:
        ptexObject = 0
    elif isinstance(texObject, (cudaTextureObject_t,)):
        ptexObject = int(texObject)
    else:
        ptexObject = int(cudaTextureObject_t(texObject))
    cytexObject = <cyruntime.cudaTextureObject_t><void_ptr>ptexObject
    with nogil:
        err = cyruntime.cudaDestroyTextureObject(cytexObject)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGetTextureObjectResourceDesc' in found_functions}}

@cython.embedsignature(True)
def cudaGetTextureObjectResourceDesc(texObject):
    """ Returns a texture object's resource descriptor.

    Returns the resource descriptor for the texture object specified by
    `texObject`.

    Parameters
    ----------
    texObject : :py:obj:`~.cudaTextureObject_t`
        Texture object

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pResDesc : :py:obj:`~.cudaResourceDesc`
        Resource descriptor

    See Also
    --------
    :py:obj:`~.cudaCreateTextureObject`, :py:obj:`~.cuTexObjectGetResourceDesc`
    """
    cdef cyruntime.cudaTextureObject_t cytexObject
    if texObject is None:
        ptexObject = 0
    elif isinstance(texObject, (cudaTextureObject_t,)):
        ptexObject = int(texObject)
    else:
        ptexObject = int(cudaTextureObject_t(texObject))
    cytexObject = <cyruntime.cudaTextureObject_t><void_ptr>ptexObject
    cdef cudaResourceDesc pResDesc = cudaResourceDesc()
    with nogil:
        err = cyruntime.cudaGetTextureObjectResourceDesc(<cyruntime.cudaResourceDesc*>pResDesc._pvt_ptr, cytexObject)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pResDesc)
{{endif}}

{{if 'cudaGetTextureObjectTextureDesc' in found_functions}}

@cython.embedsignature(True)
def cudaGetTextureObjectTextureDesc(texObject):
    """ Returns a texture object's texture descriptor.

    Returns the texture descriptor for the texture object specified by
    `texObject`.

    Parameters
    ----------
    texObject : :py:obj:`~.cudaTextureObject_t`
        Texture object

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pTexDesc : :py:obj:`~.cudaTextureDesc`
        Texture descriptor

    See Also
    --------
    :py:obj:`~.cudaCreateTextureObject`, :py:obj:`~.cuTexObjectGetTextureDesc`
    """
    cdef cyruntime.cudaTextureObject_t cytexObject
    if texObject is None:
        ptexObject = 0
    elif isinstance(texObject, (cudaTextureObject_t,)):
        ptexObject = int(texObject)
    else:
        ptexObject = int(cudaTextureObject_t(texObject))
    cytexObject = <cyruntime.cudaTextureObject_t><void_ptr>ptexObject
    cdef cudaTextureDesc pTexDesc = cudaTextureDesc()
    with nogil:
        err = cyruntime.cudaGetTextureObjectTextureDesc(<cyruntime.cudaTextureDesc*>pTexDesc._pvt_ptr, cytexObject)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pTexDesc)
{{endif}}

{{if 'cudaGetTextureObjectResourceViewDesc' in found_functions}}

@cython.embedsignature(True)
def cudaGetTextureObjectResourceViewDesc(texObject):
    """ Returns a texture object's resource view descriptor.

    Returns the resource view descriptor for the texture object specified
    by `texObject`. If no resource view was specified,
    :py:obj:`~.cudaErrorInvalidValue` is returned.

    Parameters
    ----------
    texObject : :py:obj:`~.cudaTextureObject_t`
        Texture object

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pResViewDesc : :py:obj:`~.cudaResourceViewDesc`
        Resource view descriptor

    See Also
    --------
    :py:obj:`~.cudaCreateTextureObject`, :py:obj:`~.cuTexObjectGetResourceViewDesc`
    """
    cdef cyruntime.cudaTextureObject_t cytexObject
    if texObject is None:
        ptexObject = 0
    elif isinstance(texObject, (cudaTextureObject_t,)):
        ptexObject = int(texObject)
    else:
        ptexObject = int(cudaTextureObject_t(texObject))
    cytexObject = <cyruntime.cudaTextureObject_t><void_ptr>ptexObject
    cdef cudaResourceViewDesc pResViewDesc = cudaResourceViewDesc()
    with nogil:
        err = cyruntime.cudaGetTextureObjectResourceViewDesc(<cyruntime.cudaResourceViewDesc*>pResViewDesc._pvt_ptr, cytexObject)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pResViewDesc)
{{endif}}

{{if 'cudaCreateSurfaceObject' in found_functions}}

@cython.embedsignature(True)
def cudaCreateSurfaceObject(pResDesc : Optional[cudaResourceDesc]):
    """ Creates a surface object.

    Creates a surface object and returns it in `pSurfObject`. `pResDesc`
    describes the data to perform surface load/stores on.
    :py:obj:`~.cudaResourceDesc.resType` must be
    :py:obj:`~.cudaResourceTypeArray` and
    :py:obj:`~.cudaResourceDesc`::res::array::array must be set to a valid
    CUDA array handle.

    Surface objects are only supported on devices of compute capability 3.0
    or higher. Additionally, a surface object is an opaque value, and, as
    such, should only be accessed through CUDA API calls.

    Parameters
    ----------
    pResDesc : :py:obj:`~.cudaResourceDesc`
        Resource descriptor

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidChannelDescriptor`, :py:obj:`~.cudaErrorInvalidResourceHandle`
    pSurfObject : :py:obj:`~.cudaSurfaceObject_t`
        Surface object to create

    See Also
    --------
    :py:obj:`~.cudaDestroySurfaceObject`, :py:obj:`~.cuSurfObjectCreate`
    """
    cdef cudaSurfaceObject_t pSurfObject = cudaSurfaceObject_t()
    cdef cyruntime.cudaResourceDesc* cypResDesc_ptr = pResDesc._pvt_ptr if pResDesc is not None else NULL
    with nogil:
        err = cyruntime.cudaCreateSurfaceObject(<cyruntime.cudaSurfaceObject_t*>pSurfObject._pvt_ptr, cypResDesc_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pSurfObject)
{{endif}}

{{if 'cudaDestroySurfaceObject' in found_functions}}

@cython.embedsignature(True)
def cudaDestroySurfaceObject(surfObject):
    """ Destroys a surface object.

    Destroys the surface object specified by `surfObject`.

    Parameters
    ----------
    surfObject : :py:obj:`~.cudaSurfaceObject_t`
        Surface object to destroy

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaCreateSurfaceObject`, :py:obj:`~.cuSurfObjectDestroy`
    """
    cdef cyruntime.cudaSurfaceObject_t cysurfObject
    if surfObject is None:
        psurfObject = 0
    elif isinstance(surfObject, (cudaSurfaceObject_t,)):
        psurfObject = int(surfObject)
    else:
        psurfObject = int(cudaSurfaceObject_t(surfObject))
    cysurfObject = <cyruntime.cudaSurfaceObject_t><void_ptr>psurfObject
    with nogil:
        err = cyruntime.cudaDestroySurfaceObject(cysurfObject)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGetSurfaceObjectResourceDesc' in found_functions}}

@cython.embedsignature(True)
def cudaGetSurfaceObjectResourceDesc(surfObject):
    """ Returns a surface object's resource descriptor Returns the resource descriptor for the surface object specified by `surfObject`.

    Parameters
    ----------
    surfObject : :py:obj:`~.cudaSurfaceObject_t`
        Surface object

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pResDesc : :py:obj:`~.cudaResourceDesc`
        Resource descriptor

    See Also
    --------
    :py:obj:`~.cudaCreateSurfaceObject`, :py:obj:`~.cuSurfObjectGetResourceDesc`
    """
    cdef cyruntime.cudaSurfaceObject_t cysurfObject
    if surfObject is None:
        psurfObject = 0
    elif isinstance(surfObject, (cudaSurfaceObject_t,)):
        psurfObject = int(surfObject)
    else:
        psurfObject = int(cudaSurfaceObject_t(surfObject))
    cysurfObject = <cyruntime.cudaSurfaceObject_t><void_ptr>psurfObject
    cdef cudaResourceDesc pResDesc = cudaResourceDesc()
    with nogil:
        err = cyruntime.cudaGetSurfaceObjectResourceDesc(<cyruntime.cudaResourceDesc*>pResDesc._pvt_ptr, cysurfObject)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pResDesc)
{{endif}}

{{if 'cudaDriverGetVersion' in found_functions}}

@cython.embedsignature(True)
def cudaDriverGetVersion():
    """ Returns the latest version of CUDA supported by the driver.

    Returns in `*driverVersion` the latest version of CUDA supported by the
    driver. The version is returned as (1000 * major + 10 * minor). For
    example, CUDA 9.2 would be represented by 9020. If no driver is
    installed, then 0 is returned as the driver version.

    This function automatically returns :py:obj:`~.cudaErrorInvalidValue`
    if `driverVersion` is NULL.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    driverVersion : int
        Returns the CUDA driver version.

    See Also
    --------
    :py:obj:`~.cudaRuntimeGetVersion`, :py:obj:`~.cuDriverGetVersion`
    """
    cdef int driverVersion = 0
    with nogil:
        err = cyruntime.cudaDriverGetVersion(&driverVersion)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), driverVersion)
{{endif}}

{{if 'cudaRuntimeGetVersion' in found_functions}}

@cython.embedsignature(True)
def cudaRuntimeGetVersion():
    """ Returns the CUDA Runtime version.

    Returns in `*runtimeVersion` the version number of the current CUDA
    Runtime instance. The version is returned as (1000 * major + 10 *
    minor). For example, CUDA 9.2 would be represented by 9020.

    As of CUDA 12.0, this function no longer initializes CUDA. The purpose
    of this API is solely to return a compile-time constant stating the
    CUDA Toolkit version in the above format.

    This function automatically returns :py:obj:`~.cudaErrorInvalidValue`
    if the `runtimeVersion` argument is NULL.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    runtimeVersion : int
        Returns the CUDA Runtime version.

    See Also
    --------
    :py:obj:`~.cudaDriverGetVersion`, :py:obj:`~.cuDriverGetVersion`
    """
    cdef int runtimeVersion = 0
    with nogil:
        err = cyruntime.cudaRuntimeGetVersion(&runtimeVersion)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), runtimeVersion)
{{endif}}

{{if 'cudaLogsRegisterCallback' in found_functions}}

@cython.embedsignature(True)
def cudaLogsRegisterCallback(callbackFunc, userData):
    """ Register a callback function to receive error log messages.

    Parameters
    ----------
    callbackFunc : :py:obj:`~.cudaLogsCallback_t`
        The function to register as a callback
    userData : Any
        A generic pointer to user data. This is passed into the callback
        function.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,
    callback_out : :py:obj:`~.cudaLogsCallbackHandle`
        Optional location to store the callback handle after it is
        registered
    """
    cdef cyruntime.cudaLogsCallback_t cycallbackFunc
    if callbackFunc is None:
        pcallbackFunc = 0
    elif isinstance(callbackFunc, (cudaLogsCallback_t,)):
        pcallbackFunc = int(callbackFunc)
    else:
        pcallbackFunc = int(cudaLogsCallback_t(callbackFunc))
    cycallbackFunc = <cyruntime.cudaLogsCallback_t><void_ptr>pcallbackFunc
    cdef _HelperInputVoidPtrStruct cyuserDataHelper
    cdef void* cyuserData = _helper_input_void_ptr(userData, &cyuserDataHelper)
    cdef cudaLogsCallbackHandle callback_out = cudaLogsCallbackHandle()
    with nogil:
        err = cyruntime.cudaLogsRegisterCallback(cycallbackFunc, cyuserData, <cyruntime.cudaLogsCallbackHandle*>callback_out._pvt_ptr)
    _helper_input_void_ptr_free(&cyuserDataHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), callback_out)
{{endif}}

{{if 'cudaLogsUnregisterCallback' in found_functions}}

@cython.embedsignature(True)
def cudaLogsUnregisterCallback(callback):
    """ Unregister a log message callback.

    Parameters
    ----------
    callback : :py:obj:`~.cudaLogsCallbackHandle`
        The callback instance to unregister from receiving log messages

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,
    """
    cdef cyruntime.cudaLogsCallbackHandle cycallback
    if callback is None:
        pcallback = 0
    elif isinstance(callback, (cudaLogsCallbackHandle,)):
        pcallback = int(callback)
    else:
        pcallback = int(cudaLogsCallbackHandle(callback))
    cycallback = <cyruntime.cudaLogsCallbackHandle><void_ptr>pcallback
    with nogil:
        err = cyruntime.cudaLogsUnregisterCallback(cycallback)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaLogsCurrent' in found_functions}}

@cython.embedsignature(True)
def cudaLogsCurrent(unsigned int flags):
    """ Sets log iterator to point to the end of log buffer, where the next message would be written.

    Parameters
    ----------
    flags : unsigned int
        Reserved for future use, must be 0

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,
    iterator_out : :py:obj:`~.cudaLogIterator`
        Location to store an iterator to the current tail of the logs
    """
    cdef cudaLogIterator iterator_out = cudaLogIterator()
    with nogil:
        err = cyruntime.cudaLogsCurrent(<cyruntime.cudaLogIterator*>iterator_out._pvt_ptr, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), iterator_out)
{{endif}}

{{if 'cudaLogsDumpToFile' in found_functions}}

@cython.embedsignature(True)
def cudaLogsDumpToFile(iterator : Optional[cudaLogIterator], char* pathToFile, unsigned int flags):
    """ Dump accumulated driver logs into a file.

    Logs generated by the driver are stored in an internal buffer and can
    be copied out using this API. This API dumps all driver logs starting
    from `iterator` into `pathToFile` provided.

    Parameters
    ----------
    iterator : :py:obj:`~.cudaLogIterator`
        Optional auto-advancing iterator specifying the starting log to
        read. NULL value dumps all logs.
    pathToFile : bytes
        Path to output file for dumping logs
    flags : unsigned int
        Reserved for future use, must be 0

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,
    iterator : :py:obj:`~.cudaLogIterator`
        Optional auto-advancing iterator specifying the starting log to
        read. NULL value dumps all logs.

    Notes
    -----
    `iterator` is auto-advancing. Dumping logs will update the value of `iterator` to receive the next generated log.

    The driver reserves limited memory for storing logs. The oldest logs may be overwritten and become unrecoverable. An indication will appear in the destination outupt if the logs have been truncated. Call dump after each failed API to mitigate this risk.
    """
    cdef cyruntime.cudaLogIterator* cyiterator = NULL
    if iterator is not None:
        cyiterator = iterator._pvt_ptr
    with nogil:
        err = cyruntime.cudaLogsDumpToFile(cyiterator, pathToFile, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), iterator)
{{endif}}

{{if 'cudaLogsDumpToMemory' in found_functions}}

@cython.embedsignature(True)
def cudaLogsDumpToMemory(iterator : Optional[cudaLogIterator], char* buffer, size_t size, unsigned int flags):
    """ Dump accumulated driver logs into a buffer.

    Logs generated by the driver are stored in an internal buffer and can
    be copied out using this API. This API dumps driver logs from
    `iterator` into `buffer` up to the size specified in `*size`. The
    driver will always null terminate the buffer but there will not be a
    null character between log entries, only a newline \n. The driver will
    then return the actual number of bytes written in `*size`, excluding
    the null terminator. If there are no messages to dump, `*size` will be
    set to 0 and the function will return :py:obj:`~.CUDA_SUCCESS`. If the
    provided `buffer` is not large enough to hold any messages, `*size`
    will be set to 0 and the function will return
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

    Parameters
    ----------
    iterator : :py:obj:`~.cudaLogIterator`
        Optional auto-advancing iterator specifying the starting log to
        read. NULL value dumps all logs.
    buffer : bytes
        Pointer to dump logs
    size : int
        See description
    flags : unsigned int
        Reserved for future use, must be 0

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,
    iterator : :py:obj:`~.cudaLogIterator`
        Optional auto-advancing iterator specifying the starting log to
        read. NULL value dumps all logs.
    size : int
        See description

    Notes
    -----
    `iterator` is auto-advancing. Dumping logs will update the value of `iterator` to receive the next generated log.

    The driver reserves limited memory for storing logs. The maximum size of the buffer is 25600 bytes. The oldest logs may be overwritten and become unrecoverable. An indication will appear in the destination outupt if the logs have been truncated. Call dump after each failed API to mitigate this risk.

    If the provided value in `*size` is not large enough to hold all buffered messages, a message will be added at the head of the buffer indicating this. The driver then computes the number of messages it is able to store in `buffer` and writes it out. The final message in `buffer` will always be the most recent log message as of when the API is called.
    """
    cdef cyruntime.cudaLogIterator* cyiterator = NULL
    if iterator is not None:
        cyiterator = iterator._pvt_ptr
    with nogil:
        err = cyruntime.cudaLogsDumpToMemory(cyiterator, buffer, &size, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None)
    return (cudaError_t(err), iterator, size)
{{endif}}

{{if 'cudaGraphCreate' in found_functions}}

@cython.embedsignature(True)
def cudaGraphCreate(unsigned int flags):
    """ Creates a graph.

    Creates an empty graph, which is returned via `pGraph`.

    Parameters
    ----------
    flags : unsigned int
        Graph creation flags, must be 0

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorMemoryAllocation`
    pGraph : :py:obj:`~.cudaGraph_t`
        Returns newly created graph

    See Also
    --------
    :py:obj:`~.cudaGraphAddChildGraphNode`, :py:obj:`~.cudaGraphAddEmptyNode`, :py:obj:`~.cudaGraphAddKernelNode`, :py:obj:`~.cudaGraphAddHostNode`, :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphAddMemsetNode`, :py:obj:`~.cudaGraphInstantiate`, :py:obj:`~.cudaGraphDestroy`, :py:obj:`~.cudaGraphGetNodes`, :py:obj:`~.cudaGraphGetRootNodes`, :py:obj:`~.cudaGraphGetEdges`, :py:obj:`~.cudaGraphClone`
    """
    cdef cudaGraph_t pGraph = cudaGraph_t()
    with nogil:
        err = cyruntime.cudaGraphCreate(<cyruntime.cudaGraph_t*>pGraph._pvt_ptr, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraph)
{{endif}}

{{if 'cudaGraphAddKernelNode' in found_functions}}

@cython.embedsignature(True)
def cudaGraphAddKernelNode(graph, pDependencies : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], size_t numDependencies, pNodeParams : Optional[cudaKernelNodeParams]):
    """ Creates a kernel execution node and adds it to a graph.

    Creates a new kernel execution node and adds it to `graph` with
    `numDependencies` dependencies specified via `pDependencies` and
    arguments specified in `pNodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `pDependencies` may not have any duplicate entries.
    A handle to the new node will be returned in `pGraphNode`.

    The :py:obj:`~.cudaKernelNodeParams` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    When the graph is launched, the node will invoke kernel `func` on a
    (`gridDim.x` x `gridDim.y` x `gridDim.z`) grid of blocks. Each block
    contains (`blockDim.x` x `blockDim.y` x `blockDim.z`) threads.

    `sharedMem` sets the amount of dynamic shared memory that will be
    available to each thread block.

    Kernel parameters to `func` can be specified in one of two ways:

    1) Kernel parameters can be specified via `kernelParams`. If the kernel
    has N parameters, then `kernelParams` needs to be an array of N
    pointers. Each pointer, from `kernelParams`[0] to `kernelParams`[N-1],
    points to the region of memory from which the actual parameter will be
    copied. The number of kernel parameters and their offsets and sizes do
    not need to be specified as that information is retrieved directly from
    the kernel's image.

    2) Kernel parameters can also be packaged by the application into a
    single buffer that is passed in via `extra`. This places the burden on
    the application of knowing each kernel parameter's size and
    alignment/padding within the buffer. The `extra` parameter exists to
    allow this function to take additional less commonly used arguments.
    `extra` specifies a list of names of extra settings and their
    corresponding values. Each extra setting name is immediately followed
    by the corresponding value. The list must be terminated with either
    NULL or CU_LAUNCH_PARAM_END.

    - :py:obj:`~.CU_LAUNCH_PARAM_END`, which indicates the end of the
      `extra` array;

    - :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER`, which specifies that the
      next value in `extra` will be a pointer to a buffer containing all
      the kernel parameters for launching kernel `func`;

    - :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_SIZE`, which specifies that the
      next value in `extra` will be a pointer to a size_t containing the
      size of the buffer specified with
      :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER`;

    The error :py:obj:`~.cudaErrorInvalidValue` will be returned if kernel
    parameters are specified with both `kernelParams` and `extra` (i.e.
    both `kernelParams` and `extra` are non-NULL).

    The `kernelParams` or `extra` array, as well as the argument values it
    points to, are copied during this call.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    pDependencies : list[:py:obj:`~.cudaGraphNode_t`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    pNodeParams : :py:obj:`~.cudaKernelNodeParams`
        Parameters for the GPU execution node

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidDeviceFunction`
    pGraphNode : :py:obj:`~.cudaGraphNode_t`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cudaGraphAddNode`, :py:obj:`~.cudaLaunchKernel`, :py:obj:`~.cudaGraphKernelNodeGetParams`, :py:obj:`~.cudaGraphKernelNodeSetParams`, :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphDestroyNode`, :py:obj:`~.cudaGraphAddChildGraphNode`, :py:obj:`~.cudaGraphAddEmptyNode`, :py:obj:`~.cudaGraphAddHostNode`, :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphAddMemsetNode`

    Notes
    -----
    Kernels launched using graphs must not use texture and surface references. Reading or writing through any texture or surface reference is undefined behavior. This restriction does not apply to texture and surface objects.
    """
    pDependencies = [] if pDependencies is None else pDependencies
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in pDependencies):
        raise TypeError("Argument 'pDependencies' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphNode_t pGraphNode = cudaGraphNode_t()
    cdef cyruntime.cudaGraphNode_t* cypDependencies = NULL
    if len(pDependencies) > 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*> calloc(len(pDependencies), sizeof(cyruntime.cudaGraphNode_t))
        if cypDependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(pDependencies)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(pDependencies)):
                cypDependencies[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>pDependencies[idx])._pvt_ptr[0]
    elif len(pDependencies) == 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>pDependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(pDependencies): raise RuntimeError("List is too small: " + str(len(pDependencies)) + " < " + str(numDependencies))
    cdef cyruntime.cudaKernelNodeParams* cypNodeParams_ptr = pNodeParams._pvt_ptr if pNodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphAddKernelNode(<cyruntime.cudaGraphNode_t*>pGraphNode._pvt_ptr, cygraph, cypDependencies, numDependencies, cypNodeParams_ptr)
    if len(pDependencies) > 1 and cypDependencies is not NULL:
        free(cypDependencies)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphNode)
{{endif}}

{{if 'cudaGraphKernelNodeGetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphKernelNodeGetParams(node):
    """ Returns a kernel node's parameters.

    Returns the parameters of kernel node `node` in `pNodeParams`. The
    `kernelParams` or `extra` array returned in `pNodeParams`, as well as
    the argument values it points to, are owned by the node. This memory
    remains valid until the node is destroyed or its parameters are
    modified, and should not be modified directly. Use
    :py:obj:`~.cudaGraphKernelNodeSetParams` to update the parameters of
    this node.

    The params will contain either `kernelParams` or `extra`, according to
    which of these was most recently set on the node.

    Parameters
    ----------
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidDeviceFunction`
    pNodeParams : :py:obj:`~.cudaKernelNodeParams`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cudaLaunchKernel`, :py:obj:`~.cudaGraphAddKernelNode`, :py:obj:`~.cudaGraphKernelNodeSetParams`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cudaKernelNodeParams pNodeParams = cudaKernelNodeParams()
    with nogil:
        err = cyruntime.cudaGraphKernelNodeGetParams(cynode, <cyruntime.cudaKernelNodeParams*>pNodeParams._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pNodeParams)
{{endif}}

{{if 'cudaGraphKernelNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphKernelNodeSetParams(node, pNodeParams : Optional[cudaKernelNodeParams]):
    """ Sets a kernel node's parameters.

    Sets the parameters of kernel node `node` to `pNodeParams`.

    Parameters
    ----------
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    pNodeParams : :py:obj:`~.cudaKernelNodeParams`
        Parameters to copy

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorMemoryAllocation`

    See Also
    --------
    :py:obj:`~.cudaGraphNodeSetParams`, :py:obj:`~.cudaLaunchKernel`, :py:obj:`~.cudaGraphAddKernelNode`, :py:obj:`~.cudaGraphKernelNodeGetParams`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cyruntime.cudaKernelNodeParams* cypNodeParams_ptr = pNodeParams._pvt_ptr if pNodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphKernelNodeSetParams(cynode, cypNodeParams_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphKernelNodeCopyAttributes' in found_functions}}

@cython.embedsignature(True)
def cudaGraphKernelNodeCopyAttributes(hDst, hSrc):
    """ Copies attributes from source node to destination node.

    Copies attributes from source node `hSrc` to destination node `hDst`.
    Both node must have the same context.

    Parameters
    ----------
    hDst : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Destination node
    hSrc : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Source node For list of attributes see
        :py:obj:`~.cudaKernelNodeAttrID`

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidContext`

    See Also
    --------
    :py:obj:`~.cudaAccessPolicyWindow`
    """
    cdef cyruntime.cudaGraphNode_t cyhSrc
    if hSrc is None:
        phSrc = 0
    elif isinstance(hSrc, (cudaGraphNode_t,driver.CUgraphNode)):
        phSrc = int(hSrc)
    else:
        phSrc = int(cudaGraphNode_t(hSrc))
    cyhSrc = <cyruntime.cudaGraphNode_t><void_ptr>phSrc
    cdef cyruntime.cudaGraphNode_t cyhDst
    if hDst is None:
        phDst = 0
    elif isinstance(hDst, (cudaGraphNode_t,driver.CUgraphNode)):
        phDst = int(hDst)
    else:
        phDst = int(cudaGraphNode_t(hDst))
    cyhDst = <cyruntime.cudaGraphNode_t><void_ptr>phDst
    with nogil:
        err = cyruntime.cudaGraphKernelNodeCopyAttributes(cyhDst, cyhSrc)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphKernelNodeGetAttribute' in found_functions}}

@cython.embedsignature(True)
def cudaGraphKernelNodeGetAttribute(hNode, attr not None : cudaKernelNodeAttrID):
    """ Queries node attribute.

    Queries attribute `attr` from node `hNode` and stores it in
    corresponding member of `value_out`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`

    attr : :py:obj:`~.cudaKernelNodeAttrID`


    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`
    value_out : :py:obj:`~.cudaKernelNodeAttrValue`


    See Also
    --------
    :py:obj:`~.cudaAccessPolicyWindow`
    """
    cdef cyruntime.cudaGraphNode_t cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (cudaGraphNode_t,driver.CUgraphNode)):
        phNode = int(hNode)
    else:
        phNode = int(cudaGraphNode_t(hNode))
    cyhNode = <cyruntime.cudaGraphNode_t><void_ptr>phNode
    cdef cyruntime.cudaKernelNodeAttrID cyattr = int(attr)
    cdef cudaKernelNodeAttrValue value_out = cudaKernelNodeAttrValue()
    with nogil:
        err = cyruntime.cudaGraphKernelNodeGetAttribute(cyhNode, cyattr, <cyruntime.cudaKernelNodeAttrValue*>value_out._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), value_out)
{{endif}}

{{if 'cudaGraphKernelNodeSetAttribute' in found_functions}}

@cython.embedsignature(True)
def cudaGraphKernelNodeSetAttribute(hNode, attr not None : cudaKernelNodeAttrID, value : Optional[cudaKernelNodeAttrValue]):
    """ Sets node attribute.

    Sets attribute `attr` on node `hNode` from corresponding attribute of
    `value`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`

    attr : :py:obj:`~.cudaKernelNodeAttrID`

    value : :py:obj:`~.cudaKernelNodeAttrValue`


    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`

    See Also
    --------
    :py:obj:`~.cudaAccessPolicyWindow`
    """
    cdef cyruntime.cudaGraphNode_t cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (cudaGraphNode_t,driver.CUgraphNode)):
        phNode = int(hNode)
    else:
        phNode = int(cudaGraphNode_t(hNode))
    cyhNode = <cyruntime.cudaGraphNode_t><void_ptr>phNode
    cdef cyruntime.cudaKernelNodeAttrID cyattr = int(attr)
    cdef cyruntime.cudaKernelNodeAttrValue* cyvalue_ptr = value._pvt_ptr if value is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphKernelNodeSetAttribute(cyhNode, cyattr, cyvalue_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphAddMemcpyNode' in found_functions}}

@cython.embedsignature(True)
def cudaGraphAddMemcpyNode(graph, pDependencies : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], size_t numDependencies, pCopyParams : Optional[cudaMemcpy3DParms]):
    """ Creates a memcpy node and adds it to a graph.

    Creates a new memcpy node and adds it to `graph` with `numDependencies`
    dependencies specified via `pDependencies`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `pDependencies` may not have any duplicate entries.
    A handle to the new node will be returned in `pGraphNode`.

    When the graph is launched, the node will perform the memcpy described
    by `pCopyParams`. See :py:obj:`~.cudaMemcpy3D()` for a description of
    the structure and its restrictions.

    Memcpy nodes have some additional restrictions with regards to managed
    memory, if the system contains at least one device which has a zero
    value for the device attribute
    :py:obj:`~.cudaDevAttrConcurrentManagedAccess`.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    pDependencies : list[:py:obj:`~.cudaGraphNode_t`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    pCopyParams : :py:obj:`~.cudaMemcpy3DParms`
        Parameters for the memory copy

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pGraphNode : :py:obj:`~.cudaGraphNode_t`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cudaGraphAddNode`, :py:obj:`~.cudaMemcpy3D`, :py:obj:`~.cudaGraphAddMemcpyNodeToSymbol`, :py:obj:`~.cudaGraphAddMemcpyNodeFromSymbol`, :py:obj:`~.cudaGraphAddMemcpyNode1D`, :py:obj:`~.cudaGraphMemcpyNodeGetParams`, :py:obj:`~.cudaGraphMemcpyNodeSetParams`, :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphDestroyNode`, :py:obj:`~.cudaGraphAddChildGraphNode`, :py:obj:`~.cudaGraphAddEmptyNode`, :py:obj:`~.cudaGraphAddKernelNode`, :py:obj:`~.cudaGraphAddHostNode`, :py:obj:`~.cudaGraphAddMemsetNode`
    """
    pDependencies = [] if pDependencies is None else pDependencies
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in pDependencies):
        raise TypeError("Argument 'pDependencies' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphNode_t pGraphNode = cudaGraphNode_t()
    cdef cyruntime.cudaGraphNode_t* cypDependencies = NULL
    if len(pDependencies) > 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*> calloc(len(pDependencies), sizeof(cyruntime.cudaGraphNode_t))
        if cypDependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(pDependencies)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(pDependencies)):
                cypDependencies[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>pDependencies[idx])._pvt_ptr[0]
    elif len(pDependencies) == 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>pDependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(pDependencies): raise RuntimeError("List is too small: " + str(len(pDependencies)) + " < " + str(numDependencies))
    cdef cyruntime.cudaMemcpy3DParms* cypCopyParams_ptr = pCopyParams._pvt_ptr if pCopyParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphAddMemcpyNode(<cyruntime.cudaGraphNode_t*>pGraphNode._pvt_ptr, cygraph, cypDependencies, numDependencies, cypCopyParams_ptr)
    if len(pDependencies) > 1 and cypDependencies is not NULL:
        free(cypDependencies)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphNode)
{{endif}}

{{if 'cudaGraphAddMemcpyNode1D' in found_functions}}

@cython.embedsignature(True)
def cudaGraphAddMemcpyNode1D(graph, pDependencies : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], size_t numDependencies, dst, src, size_t count, kind not None : cudaMemcpyKind):
    """ Creates a 1D memcpy node and adds it to a graph.

    Creates a new 1D memcpy node and adds it to `graph` with
    `numDependencies` dependencies specified via `pDependencies`. It is
    possible for `numDependencies` to be 0, in which case the node will be
    placed at the root of the graph. `pDependencies` may not have any
    duplicate entries. A handle to the new node will be returned in
    `pGraphNode`.

    When the graph is launched, the node will copy `count` bytes from the
    memory area pointed to by `src` to the memory area pointed to by `dst`,
    where `kind` specifies the direction of the copy, and must be one of
    :py:obj:`~.cudaMemcpyHostToHost`, :py:obj:`~.cudaMemcpyHostToDevice`,
    :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing. Launching a memcpy node with dst and src
    pointers that do not match the direction of the copy results in an
    undefined behavior.

    Memcpy nodes have some additional restrictions with regards to managed
    memory, if the system contains at least one device which has a zero
    value for the device attribute
    :py:obj:`~.cudaDevAttrConcurrentManagedAccess`.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    pDependencies : list[:py:obj:`~.cudaGraphNode_t`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    dst : Any
        Destination memory address
    src : Any
        Source memory address
    count : size_t
        Size in bytes to copy
    kind : :py:obj:`~.cudaMemcpyKind`
        Type of transfer

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pGraphNode : :py:obj:`~.cudaGraphNode_t`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphMemcpyNodeGetParams`, :py:obj:`~.cudaGraphMemcpyNodeSetParams`, :py:obj:`~.cudaGraphMemcpyNodeSetParams1D`, :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphDestroyNode`, :py:obj:`~.cudaGraphAddChildGraphNode`, :py:obj:`~.cudaGraphAddEmptyNode`, :py:obj:`~.cudaGraphAddKernelNode`, :py:obj:`~.cudaGraphAddHostNode`, :py:obj:`~.cudaGraphAddMemsetNode`
    """
    pDependencies = [] if pDependencies is None else pDependencies
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in pDependencies):
        raise TypeError("Argument 'pDependencies' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphNode_t pGraphNode = cudaGraphNode_t()
    cdef cyruntime.cudaGraphNode_t* cypDependencies = NULL
    if len(pDependencies) > 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*> calloc(len(pDependencies), sizeof(cyruntime.cudaGraphNode_t))
        if cypDependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(pDependencies)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(pDependencies)):
                cypDependencies[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>pDependencies[idx])._pvt_ptr[0]
    elif len(pDependencies) == 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>pDependencies[0])._pvt_ptr
    cdef _HelperInputVoidPtrStruct cydstHelper
    cdef void* cydst = _helper_input_void_ptr(dst, &cydstHelper)
    cdef _HelperInputVoidPtrStruct cysrcHelper
    cdef void* cysrc = _helper_input_void_ptr(src, &cysrcHelper)
    cdef cyruntime.cudaMemcpyKind cykind = int(kind)
    with nogil:
        err = cyruntime.cudaGraphAddMemcpyNode1D(<cyruntime.cudaGraphNode_t*>pGraphNode._pvt_ptr, cygraph, cypDependencies, numDependencies, cydst, cysrc, count, cykind)
    if len(pDependencies) > 1 and cypDependencies is not NULL:
        free(cypDependencies)
    _helper_input_void_ptr_free(&cydstHelper)
    _helper_input_void_ptr_free(&cysrcHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphNode)
{{endif}}

{{if 'cudaGraphMemcpyNodeGetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphMemcpyNodeGetParams(node):
    """ Returns a memcpy node's parameters.

    Returns the parameters of memcpy node `node` in `pNodeParams`.

    Parameters
    ----------
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pNodeParams : :py:obj:`~.cudaMemcpy3DParms`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cudaMemcpy3D`, :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphMemcpyNodeSetParams`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cudaMemcpy3DParms pNodeParams = cudaMemcpy3DParms()
    with nogil:
        err = cyruntime.cudaGraphMemcpyNodeGetParams(cynode, <cyruntime.cudaMemcpy3DParms*>pNodeParams._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pNodeParams)
{{endif}}

{{if 'cudaGraphMemcpyNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphMemcpyNodeSetParams(node, pNodeParams : Optional[cudaMemcpy3DParms]):
    """ Sets a memcpy node's parameters.

    Sets the parameters of memcpy node `node` to `pNodeParams`.

    Parameters
    ----------
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    pNodeParams : :py:obj:`~.cudaMemcpy3DParms`
        Parameters to copy

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cudaGraphNodeSetParams`, :py:obj:`~.cudaMemcpy3D`, :py:obj:`~.cudaGraphMemcpyNodeSetParamsToSymbol`, :py:obj:`~.cudaGraphMemcpyNodeSetParamsFromSymbol`, :py:obj:`~.cudaGraphMemcpyNodeSetParams1D`, :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphMemcpyNodeGetParams`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cyruntime.cudaMemcpy3DParms* cypNodeParams_ptr = pNodeParams._pvt_ptr if pNodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphMemcpyNodeSetParams(cynode, cypNodeParams_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphMemcpyNodeSetParams1D' in found_functions}}

@cython.embedsignature(True)
def cudaGraphMemcpyNodeSetParams1D(node, dst, src, size_t count, kind not None : cudaMemcpyKind):
    """ Sets a memcpy node's parameters to perform a 1-dimensional copy.

    Sets the parameters of memcpy node `node` to the copy described by the
    provided parameters.

    When the graph is launched, the node will copy `count` bytes from the
    memory area pointed to by `src` to the memory area pointed to by `dst`,
    where `kind` specifies the direction of the copy, and must be one of
    :py:obj:`~.cudaMemcpyHostToHost`, :py:obj:`~.cudaMemcpyHostToDevice`,
    :py:obj:`~.cudaMemcpyDeviceToHost`,
    :py:obj:`~.cudaMemcpyDeviceToDevice`, or :py:obj:`~.cudaMemcpyDefault`.
    Passing :py:obj:`~.cudaMemcpyDefault` is recommended, in which case the
    type of transfer is inferred from the pointer values. However,
    :py:obj:`~.cudaMemcpyDefault` is only allowed on systems that support
    unified virtual addressing. Launching a memcpy node with dst and src
    pointers that do not match the direction of the copy results in an
    undefined behavior.

    Parameters
    ----------
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    dst : Any
        Destination memory address
    src : Any
        Source memory address
    count : size_t
        Size in bytes to copy
    kind : :py:obj:`~.cudaMemcpyKind`
        Type of transfer

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaGraphMemcpyNodeSetParams`, :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphMemcpyNodeGetParams`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef _HelperInputVoidPtrStruct cydstHelper
    cdef void* cydst = _helper_input_void_ptr(dst, &cydstHelper)
    cdef _HelperInputVoidPtrStruct cysrcHelper
    cdef void* cysrc = _helper_input_void_ptr(src, &cysrcHelper)
    cdef cyruntime.cudaMemcpyKind cykind = int(kind)
    with nogil:
        err = cyruntime.cudaGraphMemcpyNodeSetParams1D(cynode, cydst, cysrc, count, cykind)
    _helper_input_void_ptr_free(&cydstHelper)
    _helper_input_void_ptr_free(&cysrcHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphAddMemsetNode' in found_functions}}

@cython.embedsignature(True)
def cudaGraphAddMemsetNode(graph, pDependencies : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], size_t numDependencies, pMemsetParams : Optional[cudaMemsetParams]):
    """ Creates a memset node and adds it to a graph.

    Creates a new memset node and adds it to `graph` with `numDependencies`
    dependencies specified via `pDependencies`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `pDependencies` may not have any duplicate entries.
    A handle to the new node will be returned in `pGraphNode`.

    The element size must be 1, 2, or 4 bytes. When the graph is launched,
    the node will perform the memset described by `pMemsetParams`.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    pDependencies : list[:py:obj:`~.cudaGraphNode_t`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    pMemsetParams : :py:obj:`~.cudaMemsetParams`
        Parameters for the memory set

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidDevice`
    pGraphNode : :py:obj:`~.cudaGraphNode_t`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cudaGraphAddNode`, :py:obj:`~.cudaMemset2D`, :py:obj:`~.cudaGraphMemsetNodeGetParams`, :py:obj:`~.cudaGraphMemsetNodeSetParams`, :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphDestroyNode`, :py:obj:`~.cudaGraphAddChildGraphNode`, :py:obj:`~.cudaGraphAddEmptyNode`, :py:obj:`~.cudaGraphAddKernelNode`, :py:obj:`~.cudaGraphAddHostNode`, :py:obj:`~.cudaGraphAddMemcpyNode`
    """
    pDependencies = [] if pDependencies is None else pDependencies
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in pDependencies):
        raise TypeError("Argument 'pDependencies' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphNode_t pGraphNode = cudaGraphNode_t()
    cdef cyruntime.cudaGraphNode_t* cypDependencies = NULL
    if len(pDependencies) > 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*> calloc(len(pDependencies), sizeof(cyruntime.cudaGraphNode_t))
        if cypDependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(pDependencies)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(pDependencies)):
                cypDependencies[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>pDependencies[idx])._pvt_ptr[0]
    elif len(pDependencies) == 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>pDependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(pDependencies): raise RuntimeError("List is too small: " + str(len(pDependencies)) + " < " + str(numDependencies))
    cdef cyruntime.cudaMemsetParams* cypMemsetParams_ptr = pMemsetParams._pvt_ptr if pMemsetParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphAddMemsetNode(<cyruntime.cudaGraphNode_t*>pGraphNode._pvt_ptr, cygraph, cypDependencies, numDependencies, cypMemsetParams_ptr)
    if len(pDependencies) > 1 and cypDependencies is not NULL:
        free(cypDependencies)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphNode)
{{endif}}

{{if 'cudaGraphMemsetNodeGetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphMemsetNodeGetParams(node):
    """ Returns a memset node's parameters.

    Returns the parameters of memset node `node` in `pNodeParams`.

    Parameters
    ----------
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pNodeParams : :py:obj:`~.cudaMemsetParams`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cudaMemset2D`, :py:obj:`~.cudaGraphAddMemsetNode`, :py:obj:`~.cudaGraphMemsetNodeSetParams`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cudaMemsetParams pNodeParams = cudaMemsetParams()
    with nogil:
        err = cyruntime.cudaGraphMemsetNodeGetParams(cynode, <cyruntime.cudaMemsetParams*>pNodeParams._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pNodeParams)
{{endif}}

{{if 'cudaGraphMemsetNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphMemsetNodeSetParams(node, pNodeParams : Optional[cudaMemsetParams]):
    """ Sets a memset node's parameters.

    Sets the parameters of memset node `node` to `pNodeParams`.

    Parameters
    ----------
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    pNodeParams : :py:obj:`~.cudaMemsetParams`
        Parameters to copy

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaGraphNodeSetParams`, :py:obj:`~.cudaMemset2D`, :py:obj:`~.cudaGraphAddMemsetNode`, :py:obj:`~.cudaGraphMemsetNodeGetParams`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cyruntime.cudaMemsetParams* cypNodeParams_ptr = pNodeParams._pvt_ptr if pNodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphMemsetNodeSetParams(cynode, cypNodeParams_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphAddHostNode' in found_functions}}

@cython.embedsignature(True)
def cudaGraphAddHostNode(graph, pDependencies : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], size_t numDependencies, pNodeParams : Optional[cudaHostNodeParams]):
    """ Creates a host execution node and adds it to a graph.

    Creates a new CPU execution node and adds it to `graph` with
    `numDependencies` dependencies specified via `pDependencies` and
    arguments specified in `pNodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `pDependencies` may not have any duplicate entries.
    A handle to the new node will be returned in `pGraphNode`.

    When the graph is launched, the node will invoke the specified CPU
    function. Host nodes are not supported under MPS with pre-Volta GPUs.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    pDependencies : list[:py:obj:`~.cudaGraphNode_t`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    pNodeParams : :py:obj:`~.cudaHostNodeParams`
        Parameters for the host node

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorNotSupported`, :py:obj:`~.cudaErrorInvalidValue`
    pGraphNode : :py:obj:`~.cudaGraphNode_t`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cudaGraphAddNode`, :py:obj:`~.cudaLaunchHostFunc`, :py:obj:`~.cudaGraphHostNodeGetParams`, :py:obj:`~.cudaGraphHostNodeSetParams`, :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphDestroyNode`, :py:obj:`~.cudaGraphAddChildGraphNode`, :py:obj:`~.cudaGraphAddEmptyNode`, :py:obj:`~.cudaGraphAddKernelNode`, :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphAddMemsetNode`
    """
    pDependencies = [] if pDependencies is None else pDependencies
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in pDependencies):
        raise TypeError("Argument 'pDependencies' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphNode_t pGraphNode = cudaGraphNode_t()
    cdef cyruntime.cudaGraphNode_t* cypDependencies = NULL
    if len(pDependencies) > 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*> calloc(len(pDependencies), sizeof(cyruntime.cudaGraphNode_t))
        if cypDependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(pDependencies)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(pDependencies)):
                cypDependencies[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>pDependencies[idx])._pvt_ptr[0]
    elif len(pDependencies) == 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>pDependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(pDependencies): raise RuntimeError("List is too small: " + str(len(pDependencies)) + " < " + str(numDependencies))
    cdef cyruntime.cudaHostNodeParams* cypNodeParams_ptr = pNodeParams._pvt_ptr if pNodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphAddHostNode(<cyruntime.cudaGraphNode_t*>pGraphNode._pvt_ptr, cygraph, cypDependencies, numDependencies, cypNodeParams_ptr)
    if len(pDependencies) > 1 and cypDependencies is not NULL:
        free(cypDependencies)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphNode)
{{endif}}

{{if 'cudaGraphHostNodeGetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphHostNodeGetParams(node):
    """ Returns a host node's parameters.

    Returns the parameters of host node `node` in `pNodeParams`.

    Parameters
    ----------
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pNodeParams : :py:obj:`~.cudaHostNodeParams`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cudaLaunchHostFunc`, :py:obj:`~.cudaGraphAddHostNode`, :py:obj:`~.cudaGraphHostNodeSetParams`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cudaHostNodeParams pNodeParams = cudaHostNodeParams()
    with nogil:
        err = cyruntime.cudaGraphHostNodeGetParams(cynode, <cyruntime.cudaHostNodeParams*>pNodeParams._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pNodeParams)
{{endif}}

{{if 'cudaGraphHostNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphHostNodeSetParams(node, pNodeParams : Optional[cudaHostNodeParams]):
    """ Sets a host node's parameters.

    Sets the parameters of host node `node` to `nodeParams`.

    Parameters
    ----------
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    pNodeParams : :py:obj:`~.cudaHostNodeParams`
        Parameters to copy

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaGraphNodeSetParams`, :py:obj:`~.cudaLaunchHostFunc`, :py:obj:`~.cudaGraphAddHostNode`, :py:obj:`~.cudaGraphHostNodeGetParams`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cyruntime.cudaHostNodeParams* cypNodeParams_ptr = pNodeParams._pvt_ptr if pNodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphHostNodeSetParams(cynode, cypNodeParams_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphAddChildGraphNode' in found_functions}}

@cython.embedsignature(True)
def cudaGraphAddChildGraphNode(graph, pDependencies : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], size_t numDependencies, childGraph):
    """ Creates a child graph node and adds it to a graph.

    Creates a new node which executes an embedded graph, and adds it to
    `graph` with `numDependencies` dependencies specified via
    `pDependencies`. It is possible for `numDependencies` to be 0, in which
    case the node will be placed at the root of the graph. `pDependencies`
    may not have any duplicate entries. A handle to the new node will be
    returned in `pGraphNode`.

    If `childGraph` contains allocation nodes, free nodes, or conditional
    nodes, this call will return an error.

    The node executes an embedded child graph. The child graph is cloned in
    this call.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    pDependencies : list[:py:obj:`~.cudaGraphNode_t`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    childGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph to clone into this node

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pGraphNode : :py:obj:`~.cudaGraphNode_t`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cudaGraphAddNode`, :py:obj:`~.cudaGraphChildGraphNodeGetGraph`, :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphDestroyNode`, :py:obj:`~.cudaGraphAddEmptyNode`, :py:obj:`~.cudaGraphAddKernelNode`, :py:obj:`~.cudaGraphAddHostNode`, :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphAddMemsetNode`, :py:obj:`~.cudaGraphClone`
    """
    cdef cyruntime.cudaGraph_t cychildGraph
    if childGraph is None:
        pchildGraph = 0
    elif isinstance(childGraph, (cudaGraph_t,driver.CUgraph)):
        pchildGraph = int(childGraph)
    else:
        pchildGraph = int(cudaGraph_t(childGraph))
    cychildGraph = <cyruntime.cudaGraph_t><void_ptr>pchildGraph
    pDependencies = [] if pDependencies is None else pDependencies
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in pDependencies):
        raise TypeError("Argument 'pDependencies' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphNode_t pGraphNode = cudaGraphNode_t()
    cdef cyruntime.cudaGraphNode_t* cypDependencies = NULL
    if len(pDependencies) > 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*> calloc(len(pDependencies), sizeof(cyruntime.cudaGraphNode_t))
        if cypDependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(pDependencies)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(pDependencies)):
                cypDependencies[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>pDependencies[idx])._pvt_ptr[0]
    elif len(pDependencies) == 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>pDependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(pDependencies): raise RuntimeError("List is too small: " + str(len(pDependencies)) + " < " + str(numDependencies))
    with nogil:
        err = cyruntime.cudaGraphAddChildGraphNode(<cyruntime.cudaGraphNode_t*>pGraphNode._pvt_ptr, cygraph, cypDependencies, numDependencies, cychildGraph)
    if len(pDependencies) > 1 and cypDependencies is not NULL:
        free(cypDependencies)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphNode)
{{endif}}

{{if 'cudaGraphChildGraphNodeGetGraph' in found_functions}}

@cython.embedsignature(True)
def cudaGraphChildGraphNodeGetGraph(node):
    """ Gets a handle to the embedded graph of a child graph node.

    Gets a handle to the embedded graph in a child graph node. This call
    does not clone the graph. Changes to the graph will be reflected in the
    node, and the node retains ownership of the graph.

    Allocation and free nodes cannot be added to the returned graph.
    Attempting to do so will return an error.

    Parameters
    ----------
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the embedded graph for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pGraph : :py:obj:`~.cudaGraph_t`
        Location to store a handle to the graph

    See Also
    --------
    :py:obj:`~.cudaGraphAddChildGraphNode`, :py:obj:`~.cudaGraphNodeFindInClone`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cudaGraph_t pGraph = cudaGraph_t()
    with nogil:
        err = cyruntime.cudaGraphChildGraphNodeGetGraph(cynode, <cyruntime.cudaGraph_t*>pGraph._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraph)
{{endif}}

{{if 'cudaGraphAddEmptyNode' in found_functions}}

@cython.embedsignature(True)
def cudaGraphAddEmptyNode(graph, pDependencies : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], size_t numDependencies):
    """ Creates an empty node and adds it to a graph.

    Creates a new node which performs no operation, and adds it to `graph`
    with `numDependencies` dependencies specified via `pDependencies`. It
    is possible for `numDependencies` to be 0, in which case the node will
    be placed at the root of the graph. `pDependencies` may not have any
    duplicate entries. A handle to the new node will be returned in
    `pGraphNode`.

    An empty node performs no operation during execution, but can be used
    for transitive ordering. For example, a phased execution graph with 2
    groups of n nodes with a barrier between them can be represented using
    an empty node and 2*n dependency edges, rather than no empty node and
    n^2 dependency edges.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    pDependencies : list[:py:obj:`~.cudaGraphNode_t`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pGraphNode : :py:obj:`~.cudaGraphNode_t`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cudaGraphAddNode`, :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphDestroyNode`, :py:obj:`~.cudaGraphAddChildGraphNode`, :py:obj:`~.cudaGraphAddKernelNode`, :py:obj:`~.cudaGraphAddHostNode`, :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphAddMemsetNode`
    """
    pDependencies = [] if pDependencies is None else pDependencies
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in pDependencies):
        raise TypeError("Argument 'pDependencies' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphNode_t pGraphNode = cudaGraphNode_t()
    cdef cyruntime.cudaGraphNode_t* cypDependencies = NULL
    if len(pDependencies) > 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*> calloc(len(pDependencies), sizeof(cyruntime.cudaGraphNode_t))
        if cypDependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(pDependencies)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(pDependencies)):
                cypDependencies[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>pDependencies[idx])._pvt_ptr[0]
    elif len(pDependencies) == 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>pDependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(pDependencies): raise RuntimeError("List is too small: " + str(len(pDependencies)) + " < " + str(numDependencies))
    with nogil:
        err = cyruntime.cudaGraphAddEmptyNode(<cyruntime.cudaGraphNode_t*>pGraphNode._pvt_ptr, cygraph, cypDependencies, numDependencies)
    if len(pDependencies) > 1 and cypDependencies is not NULL:
        free(cypDependencies)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphNode)
{{endif}}

{{if 'cudaGraphAddEventRecordNode' in found_functions}}

@cython.embedsignature(True)
def cudaGraphAddEventRecordNode(graph, pDependencies : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], size_t numDependencies, event):
    """ Creates an event record node and adds it to a graph.

    Creates a new event record node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and event
    specified in `event`. It is possible for `numDependencies` to be 0, in
    which case the node will be placed at the root of the graph.
    `dependencies` may not have any duplicate entries. A handle to the new
    node will be returned in `phGraphNode`.

    Each launch of the graph will record `event` to capture execution of
    the node's dependencies.

    These nodes may not be used in loops or conditionals.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : list[:py:obj:`~.cudaGraphNode_t`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event for the node

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    phGraphNode : :py:obj:`~.cudaGraphNode_t`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cudaGraphAddNode`, :py:obj:`~.cudaGraphAddEventWaitNode`, :py:obj:`~.cudaEventRecordWithFlags`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphDestroyNode`, :py:obj:`~.cudaGraphAddChildGraphNode`, :py:obj:`~.cudaGraphAddEmptyNode`, :py:obj:`~.cudaGraphAddKernelNode`, :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphAddMemsetNode`
    """
    cdef cyruntime.cudaEvent_t cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (cudaEvent_t,driver.CUevent)):
        pevent = int(event)
    else:
        pevent = int(cudaEvent_t(event))
    cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
    pDependencies = [] if pDependencies is None else pDependencies
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in pDependencies):
        raise TypeError("Argument 'pDependencies' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphNode_t pGraphNode = cudaGraphNode_t()
    cdef cyruntime.cudaGraphNode_t* cypDependencies = NULL
    if len(pDependencies) > 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*> calloc(len(pDependencies), sizeof(cyruntime.cudaGraphNode_t))
        if cypDependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(pDependencies)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(pDependencies)):
                cypDependencies[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>pDependencies[idx])._pvt_ptr[0]
    elif len(pDependencies) == 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>pDependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(pDependencies): raise RuntimeError("List is too small: " + str(len(pDependencies)) + " < " + str(numDependencies))
    with nogil:
        err = cyruntime.cudaGraphAddEventRecordNode(<cyruntime.cudaGraphNode_t*>pGraphNode._pvt_ptr, cygraph, cypDependencies, numDependencies, cyevent)
    if len(pDependencies) > 1 and cypDependencies is not NULL:
        free(cypDependencies)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphNode)
{{endif}}

{{if 'cudaGraphEventRecordNodeGetEvent' in found_functions}}

@cython.embedsignature(True)
def cudaGraphEventRecordNodeGetEvent(node):
    """ Returns the event associated with an event record node.

    Returns the event of event record node `hNode` in `event_out`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the event for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    event_out : :py:obj:`~.cudaEvent_t`
        Pointer to return the event

    See Also
    --------
    :py:obj:`~.cudaGraphAddEventRecordNode`, :py:obj:`~.cudaGraphEventRecordNodeSetEvent`, :py:obj:`~.cudaGraphEventWaitNodeGetEvent`, :py:obj:`~.cudaEventRecordWithFlags`, :py:obj:`~.cudaStreamWaitEvent`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cudaEvent_t event_out = cudaEvent_t()
    with nogil:
        err = cyruntime.cudaGraphEventRecordNodeGetEvent(cynode, <cyruntime.cudaEvent_t*>event_out._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), event_out)
{{endif}}

{{if 'cudaGraphEventRecordNodeSetEvent' in found_functions}}

@cython.embedsignature(True)
def cudaGraphEventRecordNodeSetEvent(node, event):
    """ Sets an event record node's event.

    Sets the event of event record node `hNode` to `event`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the event for
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to use

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaGraphNodeSetParams`, :py:obj:`~.cudaGraphAddEventRecordNode`, :py:obj:`~.cudaGraphEventRecordNodeGetEvent`, :py:obj:`~.cudaGraphEventWaitNodeSetEvent`, :py:obj:`~.cudaEventRecordWithFlags`, :py:obj:`~.cudaStreamWaitEvent`
    """
    cdef cyruntime.cudaEvent_t cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (cudaEvent_t,driver.CUevent)):
        pevent = int(event)
    else:
        pevent = int(cudaEvent_t(event))
    cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    with nogil:
        err = cyruntime.cudaGraphEventRecordNodeSetEvent(cynode, cyevent)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphAddEventWaitNode' in found_functions}}

@cython.embedsignature(True)
def cudaGraphAddEventWaitNode(graph, pDependencies : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], size_t numDependencies, event):
    """ Creates an event wait node and adds it to a graph.

    Creates a new event wait node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and event
    specified in `event`. It is possible for `numDependencies` to be 0, in
    which case the node will be placed at the root of the graph.
    `dependencies` may not have any duplicate entries. A handle to the new
    node will be returned in `phGraphNode`.

    The graph node will wait for all work captured in `event`. See
    :py:obj:`~.cuEventRecord()` for details on what is captured by an
    event. The synchronization will be performed efficiently on the device
    when applicable. `event` may be from a different context or device than
    the launch stream.

    These nodes may not be used in loops or conditionals.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : list[:py:obj:`~.cudaGraphNode_t`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event for the node

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    phGraphNode : :py:obj:`~.cudaGraphNode_t`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cudaGraphAddNode`, :py:obj:`~.cudaGraphAddEventRecordNode`, :py:obj:`~.cudaEventRecordWithFlags`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphDestroyNode`, :py:obj:`~.cudaGraphAddChildGraphNode`, :py:obj:`~.cudaGraphAddEmptyNode`, :py:obj:`~.cudaGraphAddKernelNode`, :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphAddMemsetNode`
    """
    cdef cyruntime.cudaEvent_t cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (cudaEvent_t,driver.CUevent)):
        pevent = int(event)
    else:
        pevent = int(cudaEvent_t(event))
    cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
    pDependencies = [] if pDependencies is None else pDependencies
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in pDependencies):
        raise TypeError("Argument 'pDependencies' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphNode_t pGraphNode = cudaGraphNode_t()
    cdef cyruntime.cudaGraphNode_t* cypDependencies = NULL
    if len(pDependencies) > 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*> calloc(len(pDependencies), sizeof(cyruntime.cudaGraphNode_t))
        if cypDependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(pDependencies)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(pDependencies)):
                cypDependencies[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>pDependencies[idx])._pvt_ptr[0]
    elif len(pDependencies) == 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>pDependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(pDependencies): raise RuntimeError("List is too small: " + str(len(pDependencies)) + " < " + str(numDependencies))
    with nogil:
        err = cyruntime.cudaGraphAddEventWaitNode(<cyruntime.cudaGraphNode_t*>pGraphNode._pvt_ptr, cygraph, cypDependencies, numDependencies, cyevent)
    if len(pDependencies) > 1 and cypDependencies is not NULL:
        free(cypDependencies)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphNode)
{{endif}}

{{if 'cudaGraphEventWaitNodeGetEvent' in found_functions}}

@cython.embedsignature(True)
def cudaGraphEventWaitNodeGetEvent(node):
    """ Returns the event associated with an event wait node.

    Returns the event of event wait node `hNode` in `event_out`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the event for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    event_out : :py:obj:`~.cudaEvent_t`
        Pointer to return the event

    See Also
    --------
    :py:obj:`~.cudaGraphAddEventWaitNode`, :py:obj:`~.cudaGraphEventWaitNodeSetEvent`, :py:obj:`~.cudaGraphEventRecordNodeGetEvent`, :py:obj:`~.cudaEventRecordWithFlags`, :py:obj:`~.cudaStreamWaitEvent`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cudaEvent_t event_out = cudaEvent_t()
    with nogil:
        err = cyruntime.cudaGraphEventWaitNodeGetEvent(cynode, <cyruntime.cudaEvent_t*>event_out._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), event_out)
{{endif}}

{{if 'cudaGraphEventWaitNodeSetEvent' in found_functions}}

@cython.embedsignature(True)
def cudaGraphEventWaitNodeSetEvent(node, event):
    """ Sets an event wait node's event.

    Sets the event of event wait node `hNode` to `event`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the event for
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to use

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaGraphNodeSetParams`, :py:obj:`~.cudaGraphAddEventWaitNode`, :py:obj:`~.cudaGraphEventWaitNodeGetEvent`, :py:obj:`~.cudaGraphEventRecordNodeSetEvent`, :py:obj:`~.cudaEventRecordWithFlags`, :py:obj:`~.cudaStreamWaitEvent`
    """
    cdef cyruntime.cudaEvent_t cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (cudaEvent_t,driver.CUevent)):
        pevent = int(event)
    else:
        pevent = int(cudaEvent_t(event))
    cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    with nogil:
        err = cyruntime.cudaGraphEventWaitNodeSetEvent(cynode, cyevent)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphAddExternalSemaphoresSignalNode' in found_functions}}

@cython.embedsignature(True)
def cudaGraphAddExternalSemaphoresSignalNode(graph, pDependencies : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], size_t numDependencies, nodeParams : Optional[cudaExternalSemaphoreSignalNodeParams]):
    """ Creates an external semaphore signal node and adds it to a graph.

    Creates a new external semaphore signal node and adds it to `graph`
    with `numDependencies` dependencies specified via `dependencies` and
    arguments specified in `nodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `dependencies` may not have any duplicate entries. A
    handle to the new node will be returned in `pGraphNode`.

    Performs a signal operation on a set of externally allocated semaphore
    objects when the node is launched. The operation(s) will occur after
    all of the node's dependencies have completed.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    pDependencies : list[:py:obj:`~.cudaGraphNode_t`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    nodeParams : :py:obj:`~.cudaExternalSemaphoreSignalNodeParams`
        Parameters for the node

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pGraphNode : :py:obj:`~.cudaGraphNode_t`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cudaGraphAddNode`, :py:obj:`~.cudaGraphExternalSemaphoresSignalNodeGetParams`, :py:obj:`~.cudaGraphExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cudaGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cudaGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cudaImportExternalSemaphore`, :py:obj:`~.cudaSignalExternalSemaphoresAsync`, :py:obj:`~.cudaWaitExternalSemaphoresAsync`, :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphDestroyNode`, :py:obj:`~.cudaGraphAddEventRecordNode`, :py:obj:`~.cudaGraphAddEventWaitNode`, :py:obj:`~.cudaGraphAddChildGraphNode`, :py:obj:`~.cudaGraphAddEmptyNode`, :py:obj:`~.cudaGraphAddKernelNode`, :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphAddMemsetNode`
    """
    pDependencies = [] if pDependencies is None else pDependencies
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in pDependencies):
        raise TypeError("Argument 'pDependencies' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphNode_t pGraphNode = cudaGraphNode_t()
    cdef cyruntime.cudaGraphNode_t* cypDependencies = NULL
    if len(pDependencies) > 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*> calloc(len(pDependencies), sizeof(cyruntime.cudaGraphNode_t))
        if cypDependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(pDependencies)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(pDependencies)):
                cypDependencies[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>pDependencies[idx])._pvt_ptr[0]
    elif len(pDependencies) == 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>pDependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(pDependencies): raise RuntimeError("List is too small: " + str(len(pDependencies)) + " < " + str(numDependencies))
    cdef cyruntime.cudaExternalSemaphoreSignalNodeParams* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphAddExternalSemaphoresSignalNode(<cyruntime.cudaGraphNode_t*>pGraphNode._pvt_ptr, cygraph, cypDependencies, numDependencies, cynodeParams_ptr)
    if len(pDependencies) > 1 and cypDependencies is not NULL:
        free(cypDependencies)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphNode)
{{endif}}

{{if 'cudaGraphExternalSemaphoresSignalNodeGetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExternalSemaphoresSignalNodeGetParams(hNode):
    """ Returns an external semaphore signal node's parameters.

    Returns the parameters of an external semaphore signal node `hNode` in
    `params_out`. The `extSemArray` and `paramsArray` returned in
    `params_out`, are owned by the node. This memory remains valid until
    the node is destroyed or its parameters are modified, and should not be
    modified directly. Use
    :py:obj:`~.cudaGraphExternalSemaphoresSignalNodeSetParams` to update
    the parameters of this node.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    params_out : :py:obj:`~.cudaExternalSemaphoreSignalNodeParams`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cudaLaunchKernel`, :py:obj:`~.cudaGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cudaGraphExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cudaGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cudaSignalExternalSemaphoresAsync`, :py:obj:`~.cudaWaitExternalSemaphoresAsync`
    """
    cdef cyruntime.cudaGraphNode_t cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (cudaGraphNode_t,driver.CUgraphNode)):
        phNode = int(hNode)
    else:
        phNode = int(cudaGraphNode_t(hNode))
    cyhNode = <cyruntime.cudaGraphNode_t><void_ptr>phNode
    cdef cudaExternalSemaphoreSignalNodeParams params_out = cudaExternalSemaphoreSignalNodeParams()
    with nogil:
        err = cyruntime.cudaGraphExternalSemaphoresSignalNodeGetParams(cyhNode, <cyruntime.cudaExternalSemaphoreSignalNodeParams*>params_out._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), params_out)
{{endif}}

{{if 'cudaGraphExternalSemaphoresSignalNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExternalSemaphoresSignalNodeSetParams(hNode, nodeParams : Optional[cudaExternalSemaphoreSignalNodeParams]):
    """ Sets an external semaphore signal node's parameters.

    Sets the parameters of an external semaphore signal node `hNode` to
    `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.cudaExternalSemaphoreSignalNodeParams`
        Parameters to copy

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaGraphNodeSetParams`, :py:obj:`~.cudaGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cudaGraphExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cudaGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cudaSignalExternalSemaphoresAsync`, :py:obj:`~.cudaWaitExternalSemaphoresAsync`
    """
    cdef cyruntime.cudaGraphNode_t cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (cudaGraphNode_t,driver.CUgraphNode)):
        phNode = int(hNode)
    else:
        phNode = int(cudaGraphNode_t(hNode))
    cyhNode = <cyruntime.cudaGraphNode_t><void_ptr>phNode
    cdef cyruntime.cudaExternalSemaphoreSignalNodeParams* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphExternalSemaphoresSignalNodeSetParams(cyhNode, cynodeParams_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphAddExternalSemaphoresWaitNode' in found_functions}}

@cython.embedsignature(True)
def cudaGraphAddExternalSemaphoresWaitNode(graph, pDependencies : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], size_t numDependencies, nodeParams : Optional[cudaExternalSemaphoreWaitNodeParams]):
    """ Creates an external semaphore wait node and adds it to a graph.

    Creates a new external semaphore wait node and adds it to `graph` with
    `numDependencies` dependencies specified via `dependencies` and
    arguments specified in `nodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `dependencies` may not have any duplicate entries. A
    handle to the new node will be returned in `pGraphNode`.

    Performs a wait operation on a set of externally allocated semaphore
    objects when the node is launched. The node's dependencies will not be
    launched until the wait operation has completed.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    pDependencies : list[:py:obj:`~.cudaGraphNode_t`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    nodeParams : :py:obj:`~.cudaExternalSemaphoreWaitNodeParams`
        Parameters for the node

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pGraphNode : :py:obj:`~.cudaGraphNode_t`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cudaGraphAddNode`, :py:obj:`~.cudaGraphExternalSemaphoresWaitNodeGetParams`, :py:obj:`~.cudaGraphExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cudaGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cudaGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cudaImportExternalSemaphore`, :py:obj:`~.cudaSignalExternalSemaphoresAsync`, :py:obj:`~.cudaWaitExternalSemaphoresAsync`, :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphDestroyNode`, :py:obj:`~.cudaGraphAddEventRecordNode`, :py:obj:`~.cudaGraphAddEventWaitNode`, :py:obj:`~.cudaGraphAddChildGraphNode`, :py:obj:`~.cudaGraphAddEmptyNode`, :py:obj:`~.cudaGraphAddKernelNode`, :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphAddMemsetNode`
    """
    pDependencies = [] if pDependencies is None else pDependencies
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in pDependencies):
        raise TypeError("Argument 'pDependencies' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphNode_t pGraphNode = cudaGraphNode_t()
    cdef cyruntime.cudaGraphNode_t* cypDependencies = NULL
    if len(pDependencies) > 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*> calloc(len(pDependencies), sizeof(cyruntime.cudaGraphNode_t))
        if cypDependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(pDependencies)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(pDependencies)):
                cypDependencies[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>pDependencies[idx])._pvt_ptr[0]
    elif len(pDependencies) == 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>pDependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(pDependencies): raise RuntimeError("List is too small: " + str(len(pDependencies)) + " < " + str(numDependencies))
    cdef cyruntime.cudaExternalSemaphoreWaitNodeParams* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphAddExternalSemaphoresWaitNode(<cyruntime.cudaGraphNode_t*>pGraphNode._pvt_ptr, cygraph, cypDependencies, numDependencies, cynodeParams_ptr)
    if len(pDependencies) > 1 and cypDependencies is not NULL:
        free(cypDependencies)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphNode)
{{endif}}

{{if 'cudaGraphExternalSemaphoresWaitNodeGetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExternalSemaphoresWaitNodeGetParams(hNode):
    """ Returns an external semaphore wait node's parameters.

    Returns the parameters of an external semaphore wait node `hNode` in
    `params_out`. The `extSemArray` and `paramsArray` returned in
    `params_out`, are owned by the node. This memory remains valid until
    the node is destroyed or its parameters are modified, and should not be
    modified directly. Use
    :py:obj:`~.cudaGraphExternalSemaphoresSignalNodeSetParams` to update
    the parameters of this node.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    params_out : :py:obj:`~.cudaExternalSemaphoreWaitNodeParams`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cudaLaunchKernel`, :py:obj:`~.cudaGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cudaGraphExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cudaGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cudaSignalExternalSemaphoresAsync`, :py:obj:`~.cudaWaitExternalSemaphoresAsync`
    """
    cdef cyruntime.cudaGraphNode_t cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (cudaGraphNode_t,driver.CUgraphNode)):
        phNode = int(hNode)
    else:
        phNode = int(cudaGraphNode_t(hNode))
    cyhNode = <cyruntime.cudaGraphNode_t><void_ptr>phNode
    cdef cudaExternalSemaphoreWaitNodeParams params_out = cudaExternalSemaphoreWaitNodeParams()
    with nogil:
        err = cyruntime.cudaGraphExternalSemaphoresWaitNodeGetParams(cyhNode, <cyruntime.cudaExternalSemaphoreWaitNodeParams*>params_out._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), params_out)
{{endif}}

{{if 'cudaGraphExternalSemaphoresWaitNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExternalSemaphoresWaitNodeSetParams(hNode, nodeParams : Optional[cudaExternalSemaphoreWaitNodeParams]):
    """ Sets an external semaphore wait node's parameters.

    Sets the parameters of an external semaphore wait node `hNode` to
    `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.cudaExternalSemaphoreWaitNodeParams`
        Parameters to copy

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaGraphNodeSetParams`, :py:obj:`~.cudaGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cudaGraphExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cudaGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cudaSignalExternalSemaphoresAsync`, :py:obj:`~.cudaWaitExternalSemaphoresAsync`
    """
    cdef cyruntime.cudaGraphNode_t cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (cudaGraphNode_t,driver.CUgraphNode)):
        phNode = int(hNode)
    else:
        phNode = int(cudaGraphNode_t(hNode))
    cyhNode = <cyruntime.cudaGraphNode_t><void_ptr>phNode
    cdef cyruntime.cudaExternalSemaphoreWaitNodeParams* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphExternalSemaphoresWaitNodeSetParams(cyhNode, cynodeParams_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphAddMemAllocNode' in found_functions}}

@cython.embedsignature(True)
def cudaGraphAddMemAllocNode(graph, pDependencies : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], size_t numDependencies, nodeParams : Optional[cudaMemAllocNodeParams]):
    """ Creates an allocation node and adds it to a graph.

    Creates a new allocation node and adds it to `graph` with
    `numDependencies` dependencies specified via `pDependencies` and
    arguments specified in `nodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `pDependencies` may not have any duplicate entries.
    A handle to the new node will be returned in `pGraphNode`.

    When :py:obj:`~.cudaGraphAddMemAllocNode` creates an allocation node,
    it returns the address of the allocation in `nodeParams.dptr`. The
    allocation's address remains fixed across instantiations and launches.

    If the allocation is freed in the same graph, by creating a free node
    using :py:obj:`~.cudaGraphAddMemFreeNode`, the allocation can be
    accessed by nodes ordered after the allocation node but before the free
    node. These allocations cannot be freed outside the owning graph, and
    they can only be freed once in the owning graph.

    If the allocation is not freed in the same graph, then it can be
    accessed not only by nodes in the graph which are ordered after the
    allocation node, but also by stream operations ordered after the
    graph's execution but before the allocation is freed.

    Allocations which are not freed in the same graph can be freed by:

    - passing the allocation to :py:obj:`~.cudaMemFreeAsync` or
      :py:obj:`~.cudaMemFree`;

    - launching a graph with a free node for that allocation; or

    - specifying :py:obj:`~.cudaGraphInstantiateFlagAutoFreeOnLaunch`
      during instantiation, which makes each launch behave as though it
      called :py:obj:`~.cudaMemFreeAsync` for every unfreed allocation.

    It is not possible to free an allocation in both the owning graph and
    another graph. If the allocation is freed in the same graph, a free
    node cannot be added to another graph. If the allocation is freed in
    another graph, a free node can no longer be added to the owning graph.

    The following restrictions apply to graphs which contain allocation
    and/or memory free nodes:

    - Nodes and edges of the graph cannot be deleted.

    - The graph can only be used in a child node if the ownership is moved
      to the parent.

    - Only one instantiation of the graph may exist at any point in time.

    - The graph cannot be cloned.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    pDependencies : list[:py:obj:`~.cudaGraphNode_t`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    nodeParams : :py:obj:`~.cudaMemAllocNodeParams`
        Parameters for the node

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorNotSupported`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorOutOfMemory`
    pGraphNode : :py:obj:`~.cudaGraphNode_t`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cudaGraphAddNode`, :py:obj:`~.cudaGraphAddMemFreeNode`, :py:obj:`~.cudaGraphMemAllocNodeGetParams`, :py:obj:`~.cudaDeviceGraphMemTrim`, :py:obj:`~.cudaDeviceGetGraphMemAttribute`, :py:obj:`~.cudaDeviceSetGraphMemAttribute`, :py:obj:`~.cudaMallocAsync`, :py:obj:`~.cudaFreeAsync`, :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphDestroyNode`, :py:obj:`~.cudaGraphAddChildGraphNode`, :py:obj:`~.cudaGraphAddEmptyNode`, :py:obj:`~.cudaGraphAddEventRecordNode`, :py:obj:`~.cudaGraphAddEventWaitNode`, :py:obj:`~.cudaGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cudaGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cudaGraphAddKernelNode`, :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphAddMemsetNode`
    """
    pDependencies = [] if pDependencies is None else pDependencies
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in pDependencies):
        raise TypeError("Argument 'pDependencies' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphNode_t pGraphNode = cudaGraphNode_t()
    cdef cyruntime.cudaGraphNode_t* cypDependencies = NULL
    if len(pDependencies) > 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*> calloc(len(pDependencies), sizeof(cyruntime.cudaGraphNode_t))
        if cypDependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(pDependencies)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(pDependencies)):
                cypDependencies[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>pDependencies[idx])._pvt_ptr[0]
    elif len(pDependencies) == 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>pDependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(pDependencies): raise RuntimeError("List is too small: " + str(len(pDependencies)) + " < " + str(numDependencies))
    cdef cyruntime.cudaMemAllocNodeParams* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphAddMemAllocNode(<cyruntime.cudaGraphNode_t*>pGraphNode._pvt_ptr, cygraph, cypDependencies, numDependencies, cynodeParams_ptr)
    if len(pDependencies) > 1 and cypDependencies is not NULL:
        free(cypDependencies)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphNode)
{{endif}}

{{if 'cudaGraphMemAllocNodeGetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphMemAllocNodeGetParams(node):
    """ Returns a memory alloc node's parameters.

    Returns the parameters of a memory alloc node `hNode` in `params_out`.
    The `poolProps` and `accessDescs` returned in `params_out`, are owned
    by the node. This memory remains valid until the node is destroyed. The
    returned parameters must not be modified.

    Parameters
    ----------
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    params_out : :py:obj:`~.cudaMemAllocNodeParams`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cudaGraphAddMemAllocNode`, :py:obj:`~.cudaGraphMemFreeNodeGetParams`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cudaMemAllocNodeParams params_out = cudaMemAllocNodeParams()
    with nogil:
        err = cyruntime.cudaGraphMemAllocNodeGetParams(cynode, <cyruntime.cudaMemAllocNodeParams*>params_out._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), params_out)
{{endif}}

{{if 'cudaGraphAddMemFreeNode' in found_functions}}

@cython.embedsignature(True)
def cudaGraphAddMemFreeNode(graph, pDependencies : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], size_t numDependencies, dptr):
    """ Creates a memory free node and adds it to a graph.

    Creates a new memory free node and adds it to `graph` with
    `numDependencies` dependencies specified via `pDependencies` and
    address specified in `dptr`. It is possible for `numDependencies` to be
    0, in which case the node will be placed at the root of the graph.
    `pDependencies` may not have any duplicate entries. A handle to the new
    node will be returned in `pGraphNode`.

    :py:obj:`~.cudaGraphAddMemFreeNode` will return
    :py:obj:`~.cudaErrorInvalidValue` if the user attempts to free:

    - an allocation twice in the same graph.

    - an address that was not returned by an allocation node.

    - an invalid address.

    The following restrictions apply to graphs which contain allocation
    and/or memory free nodes:

    - Nodes and edges of the graph cannot be deleted.

    - The graph can only be used in a child node if the ownership is moved
      to the parent.

    - Only one instantiation of the graph may exist at any point in time.

    - The graph cannot be cloned.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    pDependencies : list[:py:obj:`~.cudaGraphNode_t`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    dptr : Any
        Address of memory to free

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorNotSupported`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorOutOfMemory`
    pGraphNode : :py:obj:`~.cudaGraphNode_t`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cudaGraphAddNode`, :py:obj:`~.cudaGraphAddMemAllocNode`, :py:obj:`~.cudaGraphMemFreeNodeGetParams`, :py:obj:`~.cudaDeviceGraphMemTrim`, :py:obj:`~.cudaDeviceGetGraphMemAttribute`, :py:obj:`~.cudaDeviceSetGraphMemAttribute`, :py:obj:`~.cudaMallocAsync`, :py:obj:`~.cudaFreeAsync`, :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphDestroyNode`, :py:obj:`~.cudaGraphAddChildGraphNode`, :py:obj:`~.cudaGraphAddEmptyNode`, :py:obj:`~.cudaGraphAddEventRecordNode`, :py:obj:`~.cudaGraphAddEventWaitNode`, :py:obj:`~.cudaGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cudaGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cudaGraphAddKernelNode`, :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphAddMemsetNode`
    """
    pDependencies = [] if pDependencies is None else pDependencies
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in pDependencies):
        raise TypeError("Argument 'pDependencies' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphNode_t pGraphNode = cudaGraphNode_t()
    cdef cyruntime.cudaGraphNode_t* cypDependencies = NULL
    if len(pDependencies) > 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*> calloc(len(pDependencies), sizeof(cyruntime.cudaGraphNode_t))
        if cypDependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(pDependencies)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(pDependencies)):
                cypDependencies[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>pDependencies[idx])._pvt_ptr[0]
    elif len(pDependencies) == 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>pDependencies[0])._pvt_ptr
    if numDependencies > <size_t>len(pDependencies): raise RuntimeError("List is too small: " + str(len(pDependencies)) + " < " + str(numDependencies))
    cdef _HelperInputVoidPtrStruct cydptrHelper
    cdef void* cydptr = _helper_input_void_ptr(dptr, &cydptrHelper)
    with nogil:
        err = cyruntime.cudaGraphAddMemFreeNode(<cyruntime.cudaGraphNode_t*>pGraphNode._pvt_ptr, cygraph, cypDependencies, numDependencies, cydptr)
    if len(pDependencies) > 1 and cypDependencies is not NULL:
        free(cypDependencies)
    _helper_input_void_ptr_free(&cydptrHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphNode)
{{endif}}

{{if 'cudaGraphMemFreeNodeGetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphMemFreeNodeGetParams(node):
    """ Returns a memory free node's parameters.

    Returns the address of a memory free node `hNode` in `dptr_out`.

    Parameters
    ----------
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    dptr_out : Any
        Pointer to return the device address

    See Also
    --------
    :py:obj:`~.cudaGraphAddMemFreeNode`, :py:obj:`~.cudaGraphMemFreeNodeGetParams`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef void_ptr dptr_out = 0
    cdef void* cydptr_out_ptr = <void*>&dptr_out
    with nogil:
        err = cyruntime.cudaGraphMemFreeNodeGetParams(cynode, cydptr_out_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), dptr_out)
{{endif}}

{{if 'cudaDeviceGraphMemTrim' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGraphMemTrim(int device):
    """ Free unused memory that was cached on the specified device for use with graphs back to the OS.

    Blocks which are not in use by a graph that is either currently
    executing or scheduled to execute are freed back to the operating
    system.

    Parameters
    ----------
    device : int
        The device for which cached memory should be freed.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaGraphAddMemAllocNode`, :py:obj:`~.cudaGraphAddMemFreeNode`, :py:obj:`~.cudaDeviceGetGraphMemAttribute`, :py:obj:`~.cudaDeviceSetGraphMemAttribute`, :py:obj:`~.cudaMallocAsync`, :py:obj:`~.cudaFreeAsync`
    """
    with nogil:
        err = cyruntime.cudaDeviceGraphMemTrim(device)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaDeviceGetGraphMemAttribute' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGetGraphMemAttribute(int device, attr not None : cudaGraphMemAttributeType):
    """ Query asynchronous allocation attributes related to graphs.

    Valid attributes are:

    - :py:obj:`~.cudaGraphMemAttrUsedMemCurrent`: Amount of memory, in
      bytes, currently associated with graphs

    - :py:obj:`~.cudaGraphMemAttrUsedMemHigh`: High watermark of memory, in
      bytes, associated with graphs since the last time it was reset. High
      watermark can only be reset to zero.

    - :py:obj:`~.cudaGraphMemAttrReservedMemCurrent`: Amount of memory, in
      bytes, currently allocated for use by the CUDA graphs asynchronous
      allocator.

    - :py:obj:`~.cudaGraphMemAttrReservedMemHigh`: High watermark of
      memory, in bytes, currently allocated for use by the CUDA graphs
      asynchronous allocator.

    Parameters
    ----------
    device : int
        Specifies the scope of the query
    attr : :py:obj:`~.cudaGraphMemAttributeType`
        attribute to get

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`
    value : Any
        retrieved value

    See Also
    --------
    :py:obj:`~.cudaDeviceSetGraphMemAttribute`, :py:obj:`~.cudaGraphAddMemAllocNode`, :py:obj:`~.cudaGraphAddMemFreeNode`, :py:obj:`~.cudaDeviceGraphMemTrim`, :py:obj:`~.cudaMallocAsync`, :py:obj:`~.cudaFreeAsync`
    """
    cdef cyruntime.cudaGraphMemAttributeType cyattr = int(attr)
    cdef _HelperCUgraphMem_attribute cyvalue = _HelperCUgraphMem_attribute(attr, 0, is_getter=True)
    cdef void* cyvalue_ptr = <void*><void_ptr>cyvalue.cptr
    with nogil:
        err = cyruntime.cudaDeviceGetGraphMemAttribute(device, cyattr, cyvalue_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), cyvalue.pyObj())
{{endif}}

{{if 'cudaDeviceSetGraphMemAttribute' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceSetGraphMemAttribute(int device, attr not None : cudaGraphMemAttributeType, value):
    """ Set asynchronous allocation attributes related to graphs.

    Valid attributes are:

    - :py:obj:`~.cudaGraphMemAttrUsedMemHigh`: High watermark of memory, in
      bytes, associated with graphs since the last time it was reset. High
      watermark can only be reset to zero.

    - :py:obj:`~.cudaGraphMemAttrReservedMemHigh`: High watermark of
      memory, in bytes, currently allocated for use by the CUDA graphs
      asynchronous allocator.

    Parameters
    ----------
    device : int
        Specifies the scope of the query
    attr : :py:obj:`~.cudaGraphMemAttributeType`
        attribute to get
    value : Any
        pointer to value to set

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`

    See Also
    --------
    :py:obj:`~.cudaDeviceGetGraphMemAttribute`, :py:obj:`~.cudaGraphAddMemAllocNode`, :py:obj:`~.cudaGraphAddMemFreeNode`, :py:obj:`~.cudaDeviceGraphMemTrim`, :py:obj:`~.cudaMallocAsync`, :py:obj:`~.cudaFreeAsync`
    """
    cdef cyruntime.cudaGraphMemAttributeType cyattr = int(attr)
    cdef _HelperCUgraphMem_attribute cyvalue = _HelperCUgraphMem_attribute(attr, value, is_getter=False)
    cdef void* cyvalue_ptr = <void*><void_ptr>cyvalue.cptr
    with nogil:
        err = cyruntime.cudaDeviceSetGraphMemAttribute(device, cyattr, cyvalue_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphClone' in found_functions}}

@cython.embedsignature(True)
def cudaGraphClone(originalGraph):
    """ Clones a graph.

    This function creates a copy of `originalGraph` and returns it in
    `pGraphClone`. All parameters are copied into the cloned graph. The
    original graph may be modified after this call without affecting the
    clone.

    Child graph nodes in the original graph are recursively copied into the
    clone.

    Parameters
    ----------
    originalGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to clone

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorMemoryAllocation`
    pGraphClone : :py:obj:`~.cudaGraph_t`
        Returns newly created cloned graph

    See Also
    --------
    :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphNodeFindInClone`

    Notes
    -----
    : Cloning is not supported for graphs which contain memory allocation nodes, memory free nodes, or conditional nodes.
    """
    cdef cyruntime.cudaGraph_t cyoriginalGraph
    if originalGraph is None:
        poriginalGraph = 0
    elif isinstance(originalGraph, (cudaGraph_t,driver.CUgraph)):
        poriginalGraph = int(originalGraph)
    else:
        poriginalGraph = int(cudaGraph_t(originalGraph))
    cyoriginalGraph = <cyruntime.cudaGraph_t><void_ptr>poriginalGraph
    cdef cudaGraph_t pGraphClone = cudaGraph_t()
    with nogil:
        err = cyruntime.cudaGraphClone(<cyruntime.cudaGraph_t*>pGraphClone._pvt_ptr, cyoriginalGraph)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphClone)
{{endif}}

{{if 'cudaGraphNodeFindInClone' in found_functions}}

@cython.embedsignature(True)
def cudaGraphNodeFindInClone(originalNode, clonedGraph):
    """ Finds a cloned version of a node.

    This function returns the node in `clonedGraph` corresponding to
    `originalNode` in the original graph.

    `clonedGraph` must have been cloned from `originalGraph` via
    :py:obj:`~.cudaGraphClone`. `originalNode` must have been in
    `originalGraph` at the time of the call to :py:obj:`~.cudaGraphClone`,
    and the corresponding cloned node in `clonedGraph` must not have been
    removed. The cloned node is then returned via `pClonedNode`.

    Parameters
    ----------
    originalNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Handle to the original node
    clonedGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Cloned graph to query

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pNode : :py:obj:`~.cudaGraphNode_t`
        Returns handle to the cloned node

    See Also
    --------
    :py:obj:`~.cudaGraphClone`
    """
    cdef cyruntime.cudaGraph_t cyclonedGraph
    if clonedGraph is None:
        pclonedGraph = 0
    elif isinstance(clonedGraph, (cudaGraph_t,driver.CUgraph)):
        pclonedGraph = int(clonedGraph)
    else:
        pclonedGraph = int(cudaGraph_t(clonedGraph))
    cyclonedGraph = <cyruntime.cudaGraph_t><void_ptr>pclonedGraph
    cdef cyruntime.cudaGraphNode_t cyoriginalNode
    if originalNode is None:
        poriginalNode = 0
    elif isinstance(originalNode, (cudaGraphNode_t,driver.CUgraphNode)):
        poriginalNode = int(originalNode)
    else:
        poriginalNode = int(cudaGraphNode_t(originalNode))
    cyoriginalNode = <cyruntime.cudaGraphNode_t><void_ptr>poriginalNode
    cdef cudaGraphNode_t pNode = cudaGraphNode_t()
    with nogil:
        err = cyruntime.cudaGraphNodeFindInClone(<cyruntime.cudaGraphNode_t*>pNode._pvt_ptr, cyoriginalNode, cyclonedGraph)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pNode)
{{endif}}

{{if 'cudaGraphNodeGetType' in found_functions}}

@cython.embedsignature(True)
def cudaGraphNodeGetType(node):
    """ Returns a node's type.

    Returns the node type of `node` in `pType`.

    Parameters
    ----------
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to query

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pType : :py:obj:`~.cudaGraphNodeType`
        Pointer to return the node type

    See Also
    --------
    :py:obj:`~.cudaGraphGetNodes`, :py:obj:`~.cudaGraphGetRootNodes`, :py:obj:`~.cudaGraphChildGraphNodeGetGraph`, :py:obj:`~.cudaGraphKernelNodeGetParams`, :py:obj:`~.cudaGraphKernelNodeSetParams`, :py:obj:`~.cudaGraphHostNodeGetParams`, :py:obj:`~.cudaGraphHostNodeSetParams`, :py:obj:`~.cudaGraphMemcpyNodeGetParams`, :py:obj:`~.cudaGraphMemcpyNodeSetParams`, :py:obj:`~.cudaGraphMemsetNodeGetParams`, :py:obj:`~.cudaGraphMemsetNodeSetParams`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cyruntime.cudaGraphNodeType pType
    with nogil:
        err = cyruntime.cudaGraphNodeGetType(cynode, &pType)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), cudaGraphNodeType(pType))
{{endif}}

{{if 'cudaGraphNodeGetContainingGraph' in found_functions}}

@cython.embedsignature(True)
def cudaGraphNodeGetContainingGraph(hNode):
    """ Returns the graph that contains a given graph node.

    Returns the graph that contains `hNode` in `*phGraph`. If hNode is in a
    child graph, the child graph it is in is returned.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to query

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess` :py:obj:`~.cudaErrorInvalidValue`
    phGraph : :py:obj:`~.cudaGraph_t`
        Pointer to return the containing graph

    See Also
    --------
    :py:obj:`~.cudaGraphGetNodes`, :py:obj:`~.cudaGraphDebugDotPrint` :py:obj:`~.cudaGraphNodeGetLocalId` :py:obj:`~.cudaGraphNodeGetToolsId` :py:obj:`~.cudaGraphGetId` :py:obj:`~.cudaGraphExecGetId`
    """
    cdef cyruntime.cudaGraphNode_t cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (cudaGraphNode_t,driver.CUgraphNode)):
        phNode = int(hNode)
    else:
        phNode = int(cudaGraphNode_t(hNode))
    cyhNode = <cyruntime.cudaGraphNode_t><void_ptr>phNode
    cdef cudaGraph_t phGraph = cudaGraph_t()
    with nogil:
        err = cyruntime.cudaGraphNodeGetContainingGraph(cyhNode, <cyruntime.cudaGraph_t*>phGraph._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), phGraph)
{{endif}}

{{if 'cudaGraphNodeGetLocalId' in found_functions}}

@cython.embedsignature(True)
def cudaGraphNodeGetLocalId(hNode):
    """ Returns the node id of a given graph node.

    Returns the node id of `hNode` in `*nodeId`. The nodeId matches that
    referenced by :py:obj:`~.cudaGraphDebugDotPrint`. The local nodeId and
    graphId together can uniquely identify the node.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to query

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess` :py:obj:`~.cudaErrorInvalidValue`
    nodeId : unsigned int
        Pointer to return the nodeId

    See Also
    --------
    :py:obj:`~.cudaGraphGetNodes`, :py:obj:`~.cudaGraphDebugDotPrint` :py:obj:`~.cudaGraphNodeGetContainingGraph` :py:obj:`~.cudaGraphNodeGetToolsId` :py:obj:`~.cudaGraphGetId` :py:obj:`~.cudaGraphExecGetId`
    """
    cdef cyruntime.cudaGraphNode_t cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (cudaGraphNode_t,driver.CUgraphNode)):
        phNode = int(hNode)
    else:
        phNode = int(cudaGraphNode_t(hNode))
    cyhNode = <cyruntime.cudaGraphNode_t><void_ptr>phNode
    cdef unsigned int nodeId = 0
    with nogil:
        err = cyruntime.cudaGraphNodeGetLocalId(cyhNode, &nodeId)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), nodeId)
{{endif}}

{{if 'cudaGraphNodeGetToolsId' in found_functions}}

@cython.embedsignature(True)
def cudaGraphNodeGetToolsId(hNode):
    """ Returns an id used by tools to identify a given node.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to query

    Returns
    -------
    cudaError_t
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.cudaErrorInvalidValue`
    *toolsNodeId : unsigned long long
        Pointer to return the id used by tools

    See Also
    --------
    :py:obj:`~.cudaGraphGetNodes`, :py:obj:`~.cudaGraphDebugDotPrint` :py:obj:`~.cudaGraphNodeGetContainingGraph` :py:obj:`~.cudaGraphNodeGetLocalId` :py:obj:`~.cudaGraphGetId` :py:obj:`~.cudaGraphExecGetId`
    """
    cdef cyruntime.cudaGraphNode_t cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (cudaGraphNode_t,driver.CUgraphNode)):
        phNode = int(hNode)
    else:
        phNode = int(cudaGraphNode_t(hNode))
    cyhNode = <cyruntime.cudaGraphNode_t><void_ptr>phNode
    cdef unsigned long long toolsNodeId = 0
    with nogil:
        err = cyruntime.cudaGraphNodeGetToolsId(cyhNode, &toolsNodeId)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), toolsNodeId)
{{endif}}

{{if 'cudaGraphGetId' in found_functions}}

@cython.embedsignature(True)
def cudaGraphGetId(hGraph):
    """ Returns the id of a given graph.

    Returns the id of `hGraph` in `*graphId`. The value in `*graphId`
    matches that referenced by :py:obj:`~.cudaGraphDebugDotPrint`.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to query

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    graphId : unsigned int
        Pointer to return the graphId

    See Also
    --------
    :py:obj:`~.cudaGraphGetNodes`, :py:obj:`~.cudaGraphDebugDotPrint` :py:obj:`~.cudaGraphNodeGetContainingGraph` :py:obj:`~.cudaGraphNodeGetLocalId` :py:obj:`~.cudaGraphNodeGetToolsId` :py:obj:`~.cudaGraphExecGetId`
    """
    cdef cyruntime.cudaGraph_t cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (cudaGraph_t,driver.CUgraph)):
        phGraph = int(hGraph)
    else:
        phGraph = int(cudaGraph_t(hGraph))
    cyhGraph = <cyruntime.cudaGraph_t><void_ptr>phGraph
    cdef unsigned int graphID = 0
    with nogil:
        err = cyruntime.cudaGraphGetId(cyhGraph, &graphID)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), graphID)
{{endif}}

{{if 'cudaGraphExecGetId' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExecGetId(hGraphExec):
    """ Returns the id of a given graph exec.

    Returns the id of `hGraphExec` in `*graphId`. The value in `*graphId`
    matches that referenced by :py:obj:`~.cudaGraphDebugDotPrint`.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        Graph to query

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    graphId : unsigned int
        Pointer to return the graphId

    See Also
    --------
    :py:obj:`~.cudaGraphGetNodes`, :py:obj:`~.cudaGraphDebugDotPrint` :py:obj:`~.cudaGraphNodeGetContainingGraph` :py:obj:`~.cudaGraphNodeGetLocalId` :py:obj:`~.cudaGraphNodeGetToolsId` :py:obj:`~.cudaGraphGetId`
    """
    cdef cyruntime.cudaGraphExec_t cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(cudaGraphExec_t(hGraphExec))
    cyhGraphExec = <cyruntime.cudaGraphExec_t><void_ptr>phGraphExec
    cdef unsigned int graphID = 0
    with nogil:
        err = cyruntime.cudaGraphExecGetId(cyhGraphExec, &graphID)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), graphID)
{{endif}}

{{if 'cudaGraphGetNodes' in found_functions}}

@cython.embedsignature(True)
def cudaGraphGetNodes(graph, size_t numNodes = 0):
    """ Returns a graph's nodes.

    Returns a list of `graph's` nodes. `nodes` may be NULL, in which case
    this function will return the number of nodes in `numNodes`. Otherwise,
    `numNodes` entries will be filled in. If `numNodes` is higher than the
    actual number of nodes, the remaining entries in `nodes` will be set to
    NULL, and the number of nodes actually obtained will be returned in
    `numNodes`.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to query
    numNodes : int
        See description

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    nodes : list[:py:obj:`~.cudaGraphNode_t`]
        Pointer to return the nodes
    numNodes : int
        See description

    See Also
    --------
    :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphGetRootNodes`, :py:obj:`~.cudaGraphGetEdges`, :py:obj:`~.cudaGraphNodeGetType`, :py:obj:`~.cudaGraphNodeGetDependencies`, :py:obj:`~.cudaGraphNodeGetDependentNodes`
    """
    cdef size_t _graph_length = numNodes
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cyruntime.cudaGraphNode_t* cynodes = NULL
    pynodes = []
    if _graph_length != 0:
        cynodes = <cyruntime.cudaGraphNode_t*>calloc(_graph_length, sizeof(cyruntime.cudaGraphNode_t))
        if cynodes is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
    with nogil:
        err = cyruntime.cudaGraphGetNodes(cygraph, cynodes, &numNodes)
    if cudaError_t(err) == cudaError_t(0):
        pynodes = [cudaGraphNode_t(init_value=<void_ptr>cynodes[idx]) for idx in range(_graph_length)]
    if cynodes is not NULL:
        free(cynodes)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None)
    return (cudaError_t(err), pynodes, numNodes)
{{endif}}

{{if 'cudaGraphGetRootNodes' in found_functions}}

@cython.embedsignature(True)
def cudaGraphGetRootNodes(graph, size_t pNumRootNodes = 0):
    """ Returns a graph's root nodes.

    Returns a list of `graph's` root nodes. `pRootNodes` may be NULL, in
    which case this function will return the number of root nodes in
    `pNumRootNodes`. Otherwise, `pNumRootNodes` entries will be filled in.
    If `pNumRootNodes` is higher than the actual number of root nodes, the
    remaining entries in `pRootNodes` will be set to NULL, and the number
    of nodes actually obtained will be returned in `pNumRootNodes`.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to query
    pNumRootNodes : int
        See description

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pRootNodes : list[:py:obj:`~.cudaGraphNode_t`]
        Pointer to return the root nodes
    pNumRootNodes : int
        See description

    See Also
    --------
    :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphGetNodes`, :py:obj:`~.cudaGraphGetEdges`, :py:obj:`~.cudaGraphNodeGetType`, :py:obj:`~.cudaGraphNodeGetDependencies`, :py:obj:`~.cudaGraphNodeGetDependentNodes`
    """
    cdef size_t _graph_length = pNumRootNodes
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cyruntime.cudaGraphNode_t* cypRootNodes = NULL
    pypRootNodes = []
    if _graph_length != 0:
        cypRootNodes = <cyruntime.cudaGraphNode_t*>calloc(_graph_length, sizeof(cyruntime.cudaGraphNode_t))
        if cypRootNodes is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
    with nogil:
        err = cyruntime.cudaGraphGetRootNodes(cygraph, cypRootNodes, &pNumRootNodes)
    if cudaError_t(err) == cudaError_t(0):
        pypRootNodes = [cudaGraphNode_t(init_value=<void_ptr>cypRootNodes[idx]) for idx in range(_graph_length)]
    if cypRootNodes is not NULL:
        free(cypRootNodes)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None)
    return (cudaError_t(err), pypRootNodes, pNumRootNodes)
{{endif}}

{{if 'cudaGraphGetEdges' in found_functions}}

@cython.embedsignature(True)
def cudaGraphGetEdges(graph, size_t numEdges = 0):
    """ Returns a graph's dependency edges.

    Returns a list of `graph's` dependency edges. Edges are returned via
    corresponding indices in `from`, `to` and `edgeData`; that is, the node
    in `to`[i] has a dependency on the node in `from`[i] with data
    `edgeData`[i]. `from` and `to` may both be NULL, in which case this
    function only returns the number of edges in `numEdges`. Otherwise,
    `numEdges` entries will be filled in. If `numEdges` is higher than the
    actual number of edges, the remaining entries in `from` and `to` will
    be set to NULL, and the number of edges actually returned will be
    written to `numEdges`. `edgeData` may alone be NULL, in which case the
    edges must all have default (zeroed) edge data. Attempting a losst
    query via NULL `edgeData` will result in
    :py:obj:`~.cudaErrorLossyQuery`. If `edgeData` is non-NULL then `from`
    and `to` must be as well.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to get the edges from
    numEdges : int
        See description

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorLossyQuery`, :py:obj:`~.cudaErrorInvalidValue`
    from : list[:py:obj:`~.cudaGraphNode_t`]
        Location to return edge endpoints
    to : list[:py:obj:`~.cudaGraphNode_t`]
        Location to return edge endpoints
    edgeData : list[:py:obj:`~.cudaGraphEdgeData`]
        Optional location to return edge data
    numEdges : int
        See description

    See Also
    --------
    :py:obj:`~.cudaGraphGetNodes`, :py:obj:`~.cudaGraphGetRootNodes`, :py:obj:`~.cudaGraphAddDependencies`, :py:obj:`~.cudaGraphRemoveDependencies`, :py:obj:`~.cudaGraphNodeGetDependencies`, :py:obj:`~.cudaGraphNodeGetDependentNodes`
    """
    cdef size_t _graph_length = numEdges
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cyruntime.cudaGraphNode_t* cyfrom_ = NULL
    pyfrom_ = []
    if _graph_length != 0:
        cyfrom_ = <cyruntime.cudaGraphNode_t*>calloc(_graph_length, sizeof(cyruntime.cudaGraphNode_t))
        if cyfrom_ is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
    cdef cyruntime.cudaGraphNode_t* cyto = NULL
    pyto = []
    if _graph_length != 0:
        cyto = <cyruntime.cudaGraphNode_t*>calloc(_graph_length, sizeof(cyruntime.cudaGraphNode_t))
        if cyto is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
    cdef cyruntime.cudaGraphEdgeData* cyedgeData = NULL
    pyedgeData = []
    if _graph_length != 0:
        cyedgeData = <cyruntime.cudaGraphEdgeData*>calloc(_graph_length, sizeof(cyruntime.cudaGraphEdgeData))
        if cyedgeData is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cyruntime.cudaGraphEdgeData)))
    with nogil:
        err = cyruntime.cudaGraphGetEdges(cygraph, cyfrom_, cyto, cyedgeData, &numEdges)
    if cudaError_t(err) == cudaError_t(0):
        pyfrom_ = [cudaGraphNode_t(init_value=<void_ptr>cyfrom_[idx]) for idx in range(_graph_length)]
    if cyfrom_ is not NULL:
        free(cyfrom_)
    if cudaError_t(err) == cudaError_t(0):
        pyto = [cudaGraphNode_t(init_value=<void_ptr>cyto[idx]) for idx in range(_graph_length)]
    if cyto is not NULL:
        free(cyto)
    if cudaError_t(err) == cudaError_t(0):
        pyedgeData = [cudaGraphEdgeData(_ptr=<void_ptr>&cyedgeData[idx]) for idx in range(_graph_length)]
    if cyedgeData is not NULL:
        free(cyedgeData)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None, None, None)
    return (cudaError_t(err), pyfrom_, pyto, pyedgeData, numEdges)
{{endif}}

{{if 'cudaGraphNodeGetDependencies' in found_functions}}

@cython.embedsignature(True)
def cudaGraphNodeGetDependencies(node, size_t pNumDependencies = 0):
    """ Returns a node's dependencies.

    Returns a list of `node's` dependencies. `pDependencies` may be NULL,
    in which case this function will return the number of dependencies in
    `pNumDependencies`. Otherwise, `pNumDependencies` entries will be
    filled in. If `pNumDependencies` is higher than the actual number of
    dependencies, the remaining entries in `pDependencies` will be set to
    NULL, and the number of nodes actually obtained will be returned in
    `pNumDependencies`.

    Note that if an edge has non-zero (non-default) edge data and
    `edgeData` is NULL, this API will return
    :py:obj:`~.cudaErrorLossyQuery`. If `edgeData` is non-NULL, then
    `pDependencies` must be as well.

    Parameters
    ----------
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to query
    pNumDependencies : int
        See description

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorLossyQuery`, :py:obj:`~.cudaErrorInvalidValue`
    pDependencies : list[:py:obj:`~.cudaGraphNode_t`]
        Pointer to return the dependencies
    edgeData : list[:py:obj:`~.cudaGraphEdgeData`]
        Optional array to return edge data for each dependency
    pNumDependencies : int
        See description

    See Also
    --------
    :py:obj:`~.cudaGraphNodeGetDependentNodes`, :py:obj:`~.cudaGraphGetNodes`, :py:obj:`~.cudaGraphGetRootNodes`, :py:obj:`~.cudaGraphGetEdges`, :py:obj:`~.cudaGraphAddDependencies`, :py:obj:`~.cudaGraphRemoveDependencies`
    """
    cdef size_t _graph_length = pNumDependencies
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cyruntime.cudaGraphNode_t* cypDependencies = NULL
    pypDependencies = []
    if _graph_length != 0:
        cypDependencies = <cyruntime.cudaGraphNode_t*>calloc(_graph_length, sizeof(cyruntime.cudaGraphNode_t))
        if cypDependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
    cdef cyruntime.cudaGraphEdgeData* cyedgeData = NULL
    pyedgeData = []
    if _graph_length != 0:
        cyedgeData = <cyruntime.cudaGraphEdgeData*>calloc(_graph_length, sizeof(cyruntime.cudaGraphEdgeData))
        if cyedgeData is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cyruntime.cudaGraphEdgeData)))
    with nogil:
        err = cyruntime.cudaGraphNodeGetDependencies(cynode, cypDependencies, cyedgeData, &pNumDependencies)
    if cudaError_t(err) == cudaError_t(0):
        pypDependencies = [cudaGraphNode_t(init_value=<void_ptr>cypDependencies[idx]) for idx in range(_graph_length)]
    if cypDependencies is not NULL:
        free(cypDependencies)
    if cudaError_t(err) == cudaError_t(0):
        pyedgeData = [cudaGraphEdgeData(_ptr=<void_ptr>&cyedgeData[idx]) for idx in range(_graph_length)]
    if cyedgeData is not NULL:
        free(cyedgeData)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None, None)
    return (cudaError_t(err), pypDependencies, pyedgeData, pNumDependencies)
{{endif}}

{{if 'cudaGraphNodeGetDependentNodes' in found_functions}}

@cython.embedsignature(True)
def cudaGraphNodeGetDependentNodes(node, size_t pNumDependentNodes = 0):
    """ Returns a node's dependent nodes.

    Returns a list of `node's` dependent nodes. `pDependentNodes` may be
    NULL, in which case this function will return the number of dependent
    nodes in `pNumDependentNodes`. Otherwise, `pNumDependentNodes` entries
    will be filled in. If `pNumDependentNodes` is higher than the actual
    number of dependent nodes, the remaining entries in `pDependentNodes`
    will be set to NULL, and the number of nodes actually obtained will be
    returned in `pNumDependentNodes`.

    Note that if an edge has non-zero (non-default) edge data and
    `edgeData` is NULL, this API will return
    :py:obj:`~.cudaErrorLossyQuery`. If `edgeData` is non-NULL, then
    `pDependentNodes` must be as well.

    Parameters
    ----------
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to query
    pNumDependentNodes : int
        See description

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorLossyQuery`, :py:obj:`~.cudaErrorInvalidValue`
    pDependentNodes : list[:py:obj:`~.cudaGraphNode_t`]
        Pointer to return the dependent nodes
    edgeData : list[:py:obj:`~.cudaGraphEdgeData`]
        Optional pointer to return edge data for dependent nodes
    pNumDependentNodes : int
        See description

    See Also
    --------
    :py:obj:`~.cudaGraphNodeGetDependencies`, :py:obj:`~.cudaGraphGetNodes`, :py:obj:`~.cudaGraphGetRootNodes`, :py:obj:`~.cudaGraphGetEdges`, :py:obj:`~.cudaGraphAddDependencies`, :py:obj:`~.cudaGraphRemoveDependencies`
    """
    cdef size_t _graph_length = pNumDependentNodes
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cyruntime.cudaGraphNode_t* cypDependentNodes = NULL
    pypDependentNodes = []
    if _graph_length != 0:
        cypDependentNodes = <cyruntime.cudaGraphNode_t*>calloc(_graph_length, sizeof(cyruntime.cudaGraphNode_t))
        if cypDependentNodes is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
    cdef cyruntime.cudaGraphEdgeData* cyedgeData = NULL
    pyedgeData = []
    if _graph_length != 0:
        cyedgeData = <cyruntime.cudaGraphEdgeData*>calloc(_graph_length, sizeof(cyruntime.cudaGraphEdgeData))
        if cyedgeData is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(cyruntime.cudaGraphEdgeData)))
    with nogil:
        err = cyruntime.cudaGraphNodeGetDependentNodes(cynode, cypDependentNodes, cyedgeData, &pNumDependentNodes)
    if cudaError_t(err) == cudaError_t(0):
        pypDependentNodes = [cudaGraphNode_t(init_value=<void_ptr>cypDependentNodes[idx]) for idx in range(_graph_length)]
    if cypDependentNodes is not NULL:
        free(cypDependentNodes)
    if cudaError_t(err) == cudaError_t(0):
        pyedgeData = [cudaGraphEdgeData(_ptr=<void_ptr>&cyedgeData[idx]) for idx in range(_graph_length)]
    if cyedgeData is not NULL:
        free(cyedgeData)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None, None)
    return (cudaError_t(err), pypDependentNodes, pyedgeData, pNumDependentNodes)
{{endif}}

{{if 'cudaGraphAddDependencies' in found_functions}}

@cython.embedsignature(True)
def cudaGraphAddDependencies(graph, from_ : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], to : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], edgeData : Optional[tuple[cudaGraphEdgeData] | list[cudaGraphEdgeData]], size_t numDependencies):
    """ Adds dependency edges to a graph.

    The number of dependencies to be added is defined by `numDependencies`
    Elements in `pFrom` and `pTo` at corresponding indices define a
    dependency. Each node in `pFrom` and `pTo` must belong to `graph`.

    If `numDependencies` is 0, elements in `pFrom` and `pTo` will be
    ignored. Specifying an existing dependency will return an error.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which dependencies are added
    from : list[:py:obj:`~.cudaGraphNode_t`]
        Array of nodes that provide the dependencies
    to : list[:py:obj:`~.cudaGraphNode_t`]
        Array of dependent nodes
    edgeData : list[:py:obj:`~.cudaGraphEdgeData`]
        Optional array of edge data. If NULL, default (zeroed) edge data is
        assumed.
    numDependencies : size_t
        Number of dependencies to be added

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaGraphRemoveDependencies`, :py:obj:`~.cudaGraphGetEdges`, :py:obj:`~.cudaGraphNodeGetDependencies`, :py:obj:`~.cudaGraphNodeGetDependentNodes`
    """
    edgeData = [] if edgeData is None else edgeData
    if not all(isinstance(_x, (cudaGraphEdgeData,)) for _x in edgeData):
        raise TypeError("Argument 'edgeData' is not instance of type (expected tuple[cyruntime.cudaGraphEdgeData,] or list[cyruntime.cudaGraphEdgeData,]")
    to = [] if to is None else to
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in to):
        raise TypeError("Argument 'to' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    from_ = [] if from_ is None else from_
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in from_):
        raise TypeError("Argument 'from_' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cyruntime.cudaGraphNode_t* cyfrom_ = NULL
    if len(from_) > 1:
        cyfrom_ = <cyruntime.cudaGraphNode_t*> calloc(len(from_), sizeof(cyruntime.cudaGraphNode_t))
        if cyfrom_ is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(from_)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(from_)):
                cyfrom_[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>from_[idx])._pvt_ptr[0]
    elif len(from_) == 1:
        cyfrom_ = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>from_[0])._pvt_ptr
    cdef cyruntime.cudaGraphNode_t* cyto = NULL
    if len(to) > 1:
        cyto = <cyruntime.cudaGraphNode_t*> calloc(len(to), sizeof(cyruntime.cudaGraphNode_t))
        if cyto is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(to)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(to)):
                cyto[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>to[idx])._pvt_ptr[0]
    elif len(to) == 1:
        cyto = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>to[0])._pvt_ptr
    cdef cyruntime.cudaGraphEdgeData* cyedgeData = NULL
    if len(edgeData) > 1:
        cyedgeData = <cyruntime.cudaGraphEdgeData*> calloc(len(edgeData), sizeof(cyruntime.cudaGraphEdgeData))
        if cyedgeData is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(edgeData)) + 'x' + str(sizeof(cyruntime.cudaGraphEdgeData)))
        for idx in range(len(edgeData)):
            string.memcpy(&cyedgeData[idx], (<cudaGraphEdgeData>edgeData[idx])._pvt_ptr, sizeof(cyruntime.cudaGraphEdgeData))
    elif len(edgeData) == 1:
        cyedgeData = (<cudaGraphEdgeData>edgeData[0])._pvt_ptr
    with nogil:
        err = cyruntime.cudaGraphAddDependencies(cygraph, cyfrom_, cyto, cyedgeData, numDependencies)
    if len(from_) > 1 and cyfrom_ is not NULL:
        free(cyfrom_)
    if len(to) > 1 and cyto is not NULL:
        free(cyto)
    if len(edgeData) > 1 and cyedgeData is not NULL:
        free(cyedgeData)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphRemoveDependencies' in found_functions}}

@cython.embedsignature(True)
def cudaGraphRemoveDependencies(graph, from_ : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], to : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], edgeData : Optional[tuple[cudaGraphEdgeData] | list[cudaGraphEdgeData]], size_t numDependencies):
    """ Removes dependency edges from a graph.

    The number of `pDependencies` to be removed is defined by
    `numDependencies`. Elements in `pFrom` and `pTo` at corresponding
    indices define a dependency. Each node in `pFrom` and `pTo` must belong
    to `graph`.

    If `numDependencies` is 0, elements in `pFrom` and `pTo` will be
    ignored. Specifying an edge that does not exist in the graph, with data
    matching `edgeData`, results in an error. `edgeData` is nullable, which
    is equivalent to passing default (zeroed) data for each edge.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph from which to remove dependencies
    from : list[:py:obj:`~.cudaGraphNode_t`]
        Array of nodes that provide the dependencies
    to : list[:py:obj:`~.cudaGraphNode_t`]
        Array of dependent nodes
    edgeData : list[:py:obj:`~.cudaGraphEdgeData`]
        Optional array of edge data. If NULL, edge data is assumed to be
        default (zeroed).
    numDependencies : size_t
        Number of dependencies to be removed

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaGraphAddDependencies`, :py:obj:`~.cudaGraphGetEdges`, :py:obj:`~.cudaGraphNodeGetDependencies`, :py:obj:`~.cudaGraphNodeGetDependentNodes`
    """
    edgeData = [] if edgeData is None else edgeData
    if not all(isinstance(_x, (cudaGraphEdgeData,)) for _x in edgeData):
        raise TypeError("Argument 'edgeData' is not instance of type (expected tuple[cyruntime.cudaGraphEdgeData,] or list[cyruntime.cudaGraphEdgeData,]")
    to = [] if to is None else to
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in to):
        raise TypeError("Argument 'to' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    from_ = [] if from_ is None else from_
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in from_):
        raise TypeError("Argument 'from_' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cyruntime.cudaGraphNode_t* cyfrom_ = NULL
    if len(from_) > 1:
        cyfrom_ = <cyruntime.cudaGraphNode_t*> calloc(len(from_), sizeof(cyruntime.cudaGraphNode_t))
        if cyfrom_ is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(from_)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(from_)):
                cyfrom_[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>from_[idx])._pvt_ptr[0]
    elif len(from_) == 1:
        cyfrom_ = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>from_[0])._pvt_ptr
    cdef cyruntime.cudaGraphNode_t* cyto = NULL
    if len(to) > 1:
        cyto = <cyruntime.cudaGraphNode_t*> calloc(len(to), sizeof(cyruntime.cudaGraphNode_t))
        if cyto is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(to)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(to)):
                cyto[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>to[idx])._pvt_ptr[0]
    elif len(to) == 1:
        cyto = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>to[0])._pvt_ptr
    cdef cyruntime.cudaGraphEdgeData* cyedgeData = NULL
    if len(edgeData) > 1:
        cyedgeData = <cyruntime.cudaGraphEdgeData*> calloc(len(edgeData), sizeof(cyruntime.cudaGraphEdgeData))
        if cyedgeData is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(edgeData)) + 'x' + str(sizeof(cyruntime.cudaGraphEdgeData)))
        for idx in range(len(edgeData)):
            string.memcpy(&cyedgeData[idx], (<cudaGraphEdgeData>edgeData[idx])._pvt_ptr, sizeof(cyruntime.cudaGraphEdgeData))
    elif len(edgeData) == 1:
        cyedgeData = (<cudaGraphEdgeData>edgeData[0])._pvt_ptr
    with nogil:
        err = cyruntime.cudaGraphRemoveDependencies(cygraph, cyfrom_, cyto, cyedgeData, numDependencies)
    if len(from_) > 1 and cyfrom_ is not NULL:
        free(cyfrom_)
    if len(to) > 1 and cyto is not NULL:
        free(cyto)
    if len(edgeData) > 1 and cyedgeData is not NULL:
        free(cyedgeData)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphDestroyNode' in found_functions}}

@cython.embedsignature(True)
def cudaGraphDestroyNode(node):
    """ Remove a node from the graph.

    Removes `node` from its graph. This operation also severs any
    dependencies of other nodes on `node` and vice versa.

    Dependencies cannot be removed from graphs which contain allocation or
    free nodes. Any attempt to do so will return an error.

    Parameters
    ----------
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to remove

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaGraphAddChildGraphNode`, :py:obj:`~.cudaGraphAddEmptyNode`, :py:obj:`~.cudaGraphAddKernelNode`, :py:obj:`~.cudaGraphAddHostNode`, :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphAddMemsetNode`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    with nogil:
        err = cyruntime.cudaGraphDestroyNode(cynode)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphInstantiate' in found_functions}}

@cython.embedsignature(True)
def cudaGraphInstantiate(graph, unsigned long long flags):
    """ Creates an executable graph from a graph.

    Instantiates `graph` as an executable graph. The graph is validated for
    any structural constraints or intra-node constraints which were not
    previously validated. If instantiation is successful, a handle to the
    instantiated graph is returned in `pGraphExec`.

    The `flags` parameter controls the behavior of instantiation and
    subsequent graph launches. Valid flags are:

    - :py:obj:`~.cudaGraphInstantiateFlagAutoFreeOnLaunch`, which
      configures a graph containing memory allocation nodes to
      automatically free any unfreed memory allocations before the graph is
      relaunched.

    - :py:obj:`~.cudaGraphInstantiateFlagDeviceLaunch`, which configures
      the graph for launch from the device. If this flag is passed, the
      executable graph handle returned can be used to launch the graph from
      both the host and device. This flag cannot be used in conjunction
      with :py:obj:`~.cudaGraphInstantiateFlagAutoFreeOnLaunch`.

    - :py:obj:`~.cudaGraphInstantiateFlagUseNodePriority`, which causes the
      graph to use the priorities from the per-node attributes rather than
      the priority of the launch stream during execution. Note that
      priorities are only available on kernel nodes, and are copied from
      stream priority during stream capture.

    If `graph` contains any allocation or free nodes, there can be at most
    one executable graph in existence for that graph at a time. An attempt
    to instantiate a second executable graph before destroying the first
    with :py:obj:`~.cudaGraphExecDestroy` will result in an error. The same
    also applies if `graph` contains any device-updatable kernel nodes.

    Graphs instantiated for launch on the device have additional
    restrictions which do not apply to host graphs:

    - The graph's nodes must reside on a single device.

    - The graph can only contain kernel nodes, memcpy nodes, memset nodes,
      and child graph nodes.

    - The graph cannot be empty and must contain at least one kernel,
      memcpy, or memset node. Operation-specific restrictions are outlined
      below.

    - Kernel nodes:

      - Use of CUDA Dynamic Parallelism is not permitted.

      - Cooperative launches are permitted as long as MPS is not in use.

    - Memcpy nodes:

      - Only copies involving device memory and/or pinned device-mapped
        host memory are permitted.

      - Copies involving CUDA arrays are not permitted.

      - Both operands must be accessible from the current device, and the
        current device must match the device of other nodes in the graph.

    If `graph` is not instantiated for launch on the device but contains
    kernels which call device-side :py:obj:`~.cudaGraphLaunch()` from
    multiple devices, this will result in an error.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to instantiate
    flags : unsigned long long
        Flags to control instantiation. See
        :py:obj:`~.CUgraphInstantiate_flags`.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pGraphExec : :py:obj:`~.cudaGraphExec_t`
        Returns instantiated graph

    See Also
    --------
    :py:obj:`~.cudaGraphInstantiateWithFlags`, :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphUpload`, :py:obj:`~.cudaGraphLaunch`, :py:obj:`~.cudaGraphExecDestroy`
    """
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphExec_t pGraphExec = cudaGraphExec_t()
    with nogil:
        err = cyruntime.cudaGraphInstantiate(<cyruntime.cudaGraphExec_t*>pGraphExec._pvt_ptr, cygraph, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphExec)
{{endif}}

{{if 'cudaGraphInstantiateWithFlags' in found_functions}}

@cython.embedsignature(True)
def cudaGraphInstantiateWithFlags(graph, unsigned long long flags):
    """ Creates an executable graph from a graph.

    Instantiates `graph` as an executable graph. The graph is validated for
    any structural constraints or intra-node constraints which were not
    previously validated. If instantiation is successful, a handle to the
    instantiated graph is returned in `pGraphExec`.

    The `flags` parameter controls the behavior of instantiation and
    subsequent graph launches. Valid flags are:

    - :py:obj:`~.cudaGraphInstantiateFlagAutoFreeOnLaunch`, which
      configures a graph containing memory allocation nodes to
      automatically free any unfreed memory allocations before the graph is
      relaunched.

    - :py:obj:`~.cudaGraphInstantiateFlagDeviceLaunch`, which configures
      the graph for launch from the device. If this flag is passed, the
      executable graph handle returned can be used to launch the graph from
      both the host and device. This flag can only be used on platforms
      which support unified addressing. This flag cannot be used in
      conjunction with
      :py:obj:`~.cudaGraphInstantiateFlagAutoFreeOnLaunch`.

    - :py:obj:`~.cudaGraphInstantiateFlagUseNodePriority`, which causes the
      graph to use the priorities from the per-node attributes rather than
      the priority of the launch stream during execution. Note that
      priorities are only available on kernel nodes, and are copied from
      stream priority during stream capture.

    If `graph` contains any allocation or free nodes, there can be at most
    one executable graph in existence for that graph at a time. An attempt
    to instantiate a second executable graph before destroying the first
    with :py:obj:`~.cudaGraphExecDestroy` will result in an error. The same
    also applies if `graph` contains any device-updatable kernel nodes.

    If `graph` contains kernels which call device-side
    :py:obj:`~.cudaGraphLaunch()` from multiple devices, this will result
    in an error.

    Graphs instantiated for launch on the device have additional
    restrictions which do not apply to host graphs:

    - The graph's nodes must reside on a single device.

    - The graph can only contain kernel nodes, memcpy nodes, memset nodes,
      and child graph nodes.

    - The graph cannot be empty and must contain at least one kernel,
      memcpy, or memset node. Operation-specific restrictions are outlined
      below.

    - Kernel nodes:

      - Use of CUDA Dynamic Parallelism is not permitted.

      - Cooperative launches are permitted as long as MPS is not in use.

    - Memcpy nodes:

      - Only copies involving device memory and/or pinned device-mapped
        host memory are permitted.

      - Copies involving CUDA arrays are not permitted.

      - Both operands must be accessible from the current device, and the
        current device must match the device of other nodes in the graph.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to instantiate
    flags : unsigned long long
        Flags to control instantiation. See
        :py:obj:`~.CUgraphInstantiate_flags`.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pGraphExec : :py:obj:`~.cudaGraphExec_t`
        Returns instantiated graph

    See Also
    --------
    :py:obj:`~.cudaGraphInstantiate`, :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphUpload`, :py:obj:`~.cudaGraphLaunch`, :py:obj:`~.cudaGraphExecDestroy`
    """
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphExec_t pGraphExec = cudaGraphExec_t()
    with nogil:
        err = cyruntime.cudaGraphInstantiateWithFlags(<cyruntime.cudaGraphExec_t*>pGraphExec._pvt_ptr, cygraph, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphExec)
{{endif}}

{{if 'cudaGraphInstantiateWithParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphInstantiateWithParams(graph, instantiateParams : Optional[cudaGraphInstantiateParams]):
    """ Creates an executable graph from a graph.

    Instantiates `graph` as an executable graph according to the
    `instantiateParams` structure. The graph is validated for any
    structural constraints or intra-node constraints which were not
    previously validated. If instantiation is successful, a handle to the
    instantiated graph is returned in `pGraphExec`.

    `instantiateParams` controls the behavior of instantiation and
    subsequent graph launches, as well as returning more detailed
    information in the event of an error.
    :py:obj:`~.cudaGraphInstantiateParams` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    The `flags` field controls the behavior of instantiation and subsequent
    graph launches. Valid flags are:

    - :py:obj:`~.cudaGraphInstantiateFlagAutoFreeOnLaunch`, which
      configures a graph containing memory allocation nodes to
      automatically free any unfreed memory allocations before the graph is
      relaunched.

    - :py:obj:`~.cudaGraphInstantiateFlagUpload`, which will perform an
      upload of the graph into `uploadStream` once the graph has been
      instantiated.

    - :py:obj:`~.cudaGraphInstantiateFlagDeviceLaunch`, which configures
      the graph for launch from the device. If this flag is passed, the
      executable graph handle returned can be used to launch the graph from
      both the host and device. This flag can only be used on platforms
      which support unified addressing. This flag cannot be used in
      conjunction with
      :py:obj:`~.cudaGraphInstantiateFlagAutoFreeOnLaunch`.

    - :py:obj:`~.cudaGraphInstantiateFlagUseNodePriority`, which causes the
      graph to use the priorities from the per-node attributes rather than
      the priority of the launch stream during execution. Note that
      priorities are only available on kernel nodes, and are copied from
      stream priority during stream capture.

    If `graph` contains any allocation or free nodes, there can be at most
    one executable graph in existence for that graph at a time. An attempt
    to instantiate a second executable graph before destroying the first
    with :py:obj:`~.cudaGraphExecDestroy` will result in an error. The same
    also applies if `graph` contains any device-updatable kernel nodes.

    If `graph` contains kernels which call device-side
    :py:obj:`~.cudaGraphLaunch()` from multiple devices, this will result
    in an error.

    Graphs instantiated for launch on the device have additional
    restrictions which do not apply to host graphs:

    - The graph's nodes must reside on a single device.

    - The graph can only contain kernel nodes, memcpy nodes, memset nodes,
      and child graph nodes.

    - The graph cannot be empty and must contain at least one kernel,
      memcpy, or memset node. Operation-specific restrictions are outlined
      below.

    - Kernel nodes:

      - Use of CUDA Dynamic Parallelism is not permitted.

      - Cooperative launches are permitted as long as MPS is not in use.

    - Memcpy nodes:

      - Only copies involving device memory and/or pinned device-mapped
        host memory are permitted.

      - Copies involving CUDA arrays are not permitted.

      - Both operands must be accessible from the current device, and the
        current device must match the device of other nodes in the graph.

    In the event of an error, the `result_out` and `errNode_out` fields
    will contain more information about the nature of the error. Possible
    error reporting includes:

    - :py:obj:`~.cudaGraphInstantiateError`, if passed an invalid value or
      if an unexpected error occurred which is described by the return
      value of the function. `errNode_out` will be set to NULL.

    - :py:obj:`~.cudaGraphInstantiateInvalidStructure`, if the graph
      structure is invalid. `errNode_out` will be set to one of the
      offending nodes.

    - :py:obj:`~.cudaGraphInstantiateNodeOperationNotSupported`, if the
      graph is instantiated for device launch but contains a node of an
      unsupported node type, or a node which performs unsupported
      operations, such as use of CUDA dynamic parallelism within a kernel
      node. `errNode_out` will be set to this node.

    - :py:obj:`~.cudaGraphInstantiateMultipleDevicesNotSupported`, if the
      graph is instantiated for device launch but a nodes device differs
      from that of another node. This error can also be returned if a graph
      is not instantiated for device launch and it contains kernels which
      call device-side :py:obj:`~.cudaGraphLaunch()` from multiple devices.
      `errNode_out` will be set to this node.

    If instantiation is successful, `result_out` will be set to
    :py:obj:`~.cudaGraphInstantiateSuccess`, and `hErrNode_out` will be set
    to NULL.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to instantiate
    instantiateParams : :py:obj:`~.cudaGraphInstantiateParams`
        Instantiation parameters

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    pGraphExec : :py:obj:`~.cudaGraphExec_t`
        Returns instantiated graph

    See Also
    --------
    :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphInstantiate`, :py:obj:`~.cudaGraphInstantiateWithFlags`, :py:obj:`~.cudaGraphExecDestroy`
    """
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphExec_t pGraphExec = cudaGraphExec_t()
    cdef cyruntime.cudaGraphInstantiateParams* cyinstantiateParams_ptr = instantiateParams._pvt_ptr if instantiateParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphInstantiateWithParams(<cyruntime.cudaGraphExec_t*>pGraphExec._pvt_ptr, cygraph, cyinstantiateParams_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphExec)
{{endif}}

{{if 'cudaGraphExecGetFlags' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExecGetFlags(graphExec):
    """ Query the instantiation flags of an executable graph.

    Returns the flags that were passed to instantiation for the given
    executable graph. :py:obj:`~.cudaGraphInstantiateFlagUpload` will not
    be returned by this API as it does not affect the resulting executable
    graph.

    Parameters
    ----------
    graphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph to query

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    flags : unsigned long long
        Returns the instantiation flags

    See Also
    --------
    :py:obj:`~.cudaGraphInstantiate`, :py:obj:`~.cudaGraphInstantiateWithFlags`, :py:obj:`~.cudaGraphInstantiateWithParams`
    """
    cdef cyruntime.cudaGraphExec_t cygraphExec
    if graphExec is None:
        pgraphExec = 0
    elif isinstance(graphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        pgraphExec = int(graphExec)
    else:
        pgraphExec = int(cudaGraphExec_t(graphExec))
    cygraphExec = <cyruntime.cudaGraphExec_t><void_ptr>pgraphExec
    cdef unsigned long long flags = 0
    with nogil:
        err = cyruntime.cudaGraphExecGetFlags(cygraphExec, &flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), flags)
{{endif}}

{{if 'cudaGraphExecKernelNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExecKernelNodeSetParams(hGraphExec, node, pNodeParams : Optional[cudaKernelNodeParams]):
    """ Sets the parameters for a kernel node in the given graphExec.

    Sets the parameters of a kernel node in an executable graph
    `hGraphExec`. The node is identified by the corresponding node `node`
    in the non-executable graph, from which the executable graph was
    instantiated.

    `node` must not have been removed from the original graph. All
    `nodeParams` fields may change, but the following restrictions apply to
    `func` updates:

    - The owning device of the function cannot change.

    - A node whose function originally did not use CUDA dynamic parallelism
      cannot be updated to a function which uses CDP

    - A node whose function originally did not make device-side update
      calls cannot be updated to a function which makes device-side update
      calls.

    - If `hGraphExec` was not instantiated for device launch, a node whose
      function originally did not use device-side
      :py:obj:`~.cudaGraphLaunch()` cannot be updated to a function which
      uses device-side :py:obj:`~.cudaGraphLaunch()` unless the node
      resides on the same device as nodes which contained such calls at
      instantiate-time. If no such calls were present at instantiation,
      these updates cannot be performed at all.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `node` is also not modified by this call.

    If `node` is a device-updatable kernel node, the next upload/launch of
    `hGraphExec` will overwrite any previous device-side updates.
    Additionally, applying host updates to a device-updatable kernel node
    while it is being updated from the device will result in undefined
    behavior.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        kernel node from the graph from which graphExec was instantiated
    pNodeParams : :py:obj:`~.cudaKernelNodeParams`
        Updated Parameters to set

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cudaGraphExecNodeSetParams`, :py:obj:`~.cudaGraphAddKernelNode`, :py:obj:`~.cudaGraphKernelNodeSetParams`, :py:obj:`~.cudaGraphExecMemcpyNodeSetParams`, :py:obj:`~.cudaGraphExecMemsetNodeSetParams`, :py:obj:`~.cudaGraphExecHostNodeSetParams`, :py:obj:`~.cudaGraphExecChildGraphNodeSetParams`, :py:obj:`~.cudaGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cudaGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cudaGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cudaGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cudaGraphExecUpdate`, :py:obj:`~.cudaGraphInstantiate`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cyruntime.cudaGraphExec_t cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(cudaGraphExec_t(hGraphExec))
    cyhGraphExec = <cyruntime.cudaGraphExec_t><void_ptr>phGraphExec
    cdef cyruntime.cudaKernelNodeParams* cypNodeParams_ptr = pNodeParams._pvt_ptr if pNodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphExecKernelNodeSetParams(cyhGraphExec, cynode, cypNodeParams_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphExecMemcpyNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExecMemcpyNodeSetParams(hGraphExec, node, pNodeParams : Optional[cudaMemcpy3DParms]):
    """ Sets the parameters for a memcpy node in the given graphExec.

    Updates the work represented by `node` in `hGraphExec` as though `node`
    had contained `pNodeParams` at instantiation. `node` must remain in the
    graph which was used to instantiate `hGraphExec`. Changed edges to and
    from `node` are ignored.

    The source and destination memory in `pNodeParams` must be allocated
    from the same contexts as the original source and destination memory.
    Both the instantiation-time memory operands and the memory operands in
    `pNodeParams` must be 1-dimensional. Zero-length operations are not
    supported.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `node` is also not modified by this call.

    Returns :py:obj:`~.cudaErrorInvalidValue` if the memory operands'
    mappings changed or either the original or new memory operands are
    multidimensional.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Memcpy node from the graph which was used to instantiate graphExec
    pNodeParams : :py:obj:`~.cudaMemcpy3DParms`
        Updated Parameters to set

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cudaGraphExecNodeSetParams`, :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphMemcpyNodeSetParams`, :py:obj:`~.cudaGraphExecMemcpyNodeSetParamsToSymbol`, :py:obj:`~.cudaGraphExecMemcpyNodeSetParamsFromSymbol`, :py:obj:`~.cudaGraphExecMemcpyNodeSetParams1D`, :py:obj:`~.cudaGraphExecKernelNodeSetParams`, :py:obj:`~.cudaGraphExecMemsetNodeSetParams`, :py:obj:`~.cudaGraphExecHostNodeSetParams`, :py:obj:`~.cudaGraphExecChildGraphNodeSetParams`, :py:obj:`~.cudaGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cudaGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cudaGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cudaGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cudaGraphExecUpdate`, :py:obj:`~.cudaGraphInstantiate`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cyruntime.cudaGraphExec_t cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(cudaGraphExec_t(hGraphExec))
    cyhGraphExec = <cyruntime.cudaGraphExec_t><void_ptr>phGraphExec
    cdef cyruntime.cudaMemcpy3DParms* cypNodeParams_ptr = pNodeParams._pvt_ptr if pNodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphExecMemcpyNodeSetParams(cyhGraphExec, cynode, cypNodeParams_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphExecMemcpyNodeSetParams1D' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExecMemcpyNodeSetParams1D(hGraphExec, node, dst, src, size_t count, kind not None : cudaMemcpyKind):
    """ Sets the parameters for a memcpy node in the given graphExec to perform a 1-dimensional copy.

    Updates the work represented by `node` in `hGraphExec` as though `node`
    had contained the given params at instantiation. `node` must remain in
    the graph which was used to instantiate `hGraphExec`. Changed edges to
    and from `node` are ignored.

    `src` and `dst` must be allocated from the same contexts as the
    original source and destination memory. The instantiation-time memory
    operands must be 1-dimensional. Zero-length operations are not
    supported.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `node` is also not modified by this call.

    Returns :py:obj:`~.cudaErrorInvalidValue` if the memory operands'
    mappings changed or the original memory operands are multidimensional.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Memcpy node from the graph which was used to instantiate graphExec
    dst : Any
        Destination memory address
    src : Any
        Source memory address
    count : size_t
        Size in bytes to copy
    kind : :py:obj:`~.cudaMemcpyKind`
        Type of transfer

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaGraphAddMemcpyNode`, :py:obj:`~.cudaGraphAddMemcpyNode1D`, :py:obj:`~.cudaGraphMemcpyNodeSetParams`, :py:obj:`~.cudaGraphMemcpyNodeSetParams1D`, :py:obj:`~.cudaGraphExecMemcpyNodeSetParams`, :py:obj:`~.cudaGraphExecKernelNodeSetParams`, :py:obj:`~.cudaGraphExecMemsetNodeSetParams`, :py:obj:`~.cudaGraphExecHostNodeSetParams`, :py:obj:`~.cudaGraphExecChildGraphNodeSetParams`, :py:obj:`~.cudaGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cudaGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cudaGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cudaGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cudaGraphExecUpdate`, :py:obj:`~.cudaGraphInstantiate`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cyruntime.cudaGraphExec_t cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(cudaGraphExec_t(hGraphExec))
    cyhGraphExec = <cyruntime.cudaGraphExec_t><void_ptr>phGraphExec
    cdef _HelperInputVoidPtrStruct cydstHelper
    cdef void* cydst = _helper_input_void_ptr(dst, &cydstHelper)
    cdef _HelperInputVoidPtrStruct cysrcHelper
    cdef void* cysrc = _helper_input_void_ptr(src, &cysrcHelper)
    cdef cyruntime.cudaMemcpyKind cykind = int(kind)
    with nogil:
        err = cyruntime.cudaGraphExecMemcpyNodeSetParams1D(cyhGraphExec, cynode, cydst, cysrc, count, cykind)
    _helper_input_void_ptr_free(&cydstHelper)
    _helper_input_void_ptr_free(&cysrcHelper)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphExecMemsetNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExecMemsetNodeSetParams(hGraphExec, node, pNodeParams : Optional[cudaMemsetParams]):
    """ Sets the parameters for a memset node in the given graphExec.

    Updates the work represented by `node` in `hGraphExec` as though `node`
    had contained `pNodeParams` at instantiation. `node` must remain in the
    graph which was used to instantiate `hGraphExec`. Changed edges to and
    from `node` are ignored.

    Zero sized operations are not supported.

    The new destination pointer in `pNodeParams` must be to the same kind
    of allocation as the original destination pointer and have the same
    context association and device mapping as the original destination
    pointer.

    Both the value and pointer address may be updated.   Changing other
    aspects of the memset (width, height, element size or pitch) may cause
    the update to be rejected. Specifically, for 2d memsets, all dimension
    changes are rejected. For 1d memsets, changes in height are explicitly
    rejected and other changes are opportunistically allowed if the
    resulting work maps onto the work resources already allocated for the
    node.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `node` is also not modified by this call.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Memset node from the graph which was used to instantiate graphExec
    pNodeParams : :py:obj:`~.cudaMemsetParams`
        Updated Parameters to set

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cudaGraphExecNodeSetParams`, :py:obj:`~.cudaGraphAddMemsetNode`, :py:obj:`~.cudaGraphMemsetNodeSetParams`, :py:obj:`~.cudaGraphExecKernelNodeSetParams`, :py:obj:`~.cudaGraphExecMemcpyNodeSetParams`, :py:obj:`~.cudaGraphExecHostNodeSetParams`, :py:obj:`~.cudaGraphExecChildGraphNodeSetParams`, :py:obj:`~.cudaGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cudaGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cudaGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cudaGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cudaGraphExecUpdate`, :py:obj:`~.cudaGraphInstantiate`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cyruntime.cudaGraphExec_t cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(cudaGraphExec_t(hGraphExec))
    cyhGraphExec = <cyruntime.cudaGraphExec_t><void_ptr>phGraphExec
    cdef cyruntime.cudaMemsetParams* cypNodeParams_ptr = pNodeParams._pvt_ptr if pNodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphExecMemsetNodeSetParams(cyhGraphExec, cynode, cypNodeParams_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphExecHostNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExecHostNodeSetParams(hGraphExec, node, pNodeParams : Optional[cudaHostNodeParams]):
    """ Sets the parameters for a host node in the given graphExec.

    Updates the work represented by `node` in `hGraphExec` as though `node`
    had contained `pNodeParams` at instantiation. `node` must remain in the
    graph which was used to instantiate `hGraphExec`. Changed edges to and
    from `node` are ignored.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `node` is also not modified by this call.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Host node from the graph which was used to instantiate graphExec
    pNodeParams : :py:obj:`~.cudaHostNodeParams`
        Updated Parameters to set

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cudaGraphExecNodeSetParams`, :py:obj:`~.cudaGraphAddHostNode`, :py:obj:`~.cudaGraphHostNodeSetParams`, :py:obj:`~.cudaGraphExecKernelNodeSetParams`, :py:obj:`~.cudaGraphExecMemcpyNodeSetParams`, :py:obj:`~.cudaGraphExecMemsetNodeSetParams`, :py:obj:`~.cudaGraphExecChildGraphNodeSetParams`, :py:obj:`~.cudaGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cudaGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cudaGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cudaGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cudaGraphExecUpdate`, :py:obj:`~.cudaGraphInstantiate`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cyruntime.cudaGraphExec_t cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(cudaGraphExec_t(hGraphExec))
    cyhGraphExec = <cyruntime.cudaGraphExec_t><void_ptr>phGraphExec
    cdef cyruntime.cudaHostNodeParams* cypNodeParams_ptr = pNodeParams._pvt_ptr if pNodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphExecHostNodeSetParams(cyhGraphExec, cynode, cypNodeParams_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphExecChildGraphNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExecChildGraphNodeSetParams(hGraphExec, node, childGraph):
    """ Updates node parameters in the child graph node in the given graphExec.

    Updates the work represented by `node` in `hGraphExec` as though the
    nodes contained in `node's` graph had the parameters contained in
    `childGraph's` nodes at instantiation. `node` must remain in the graph
    which was used to instantiate `hGraphExec`. Changed edges to and from
    `node` are ignored.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `node` is also not modified by this call.

    The topology of `childGraph`, as well as the node insertion order, must
    match that of the graph contained in `node`. See
    :py:obj:`~.cudaGraphExecUpdate()` for a list of restrictions on what
    can be updated in an instantiated graph. The update is recursive, so
    child graph nodes contained within the top level child graph will also
    be updated.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Host node from the graph which was used to instantiate graphExec
    childGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph supplying the updated parameters

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cudaGraphExecNodeSetParams`, :py:obj:`~.cudaGraphAddChildGraphNode`, :py:obj:`~.cudaGraphChildGraphNodeGetGraph`, :py:obj:`~.cudaGraphExecKernelNodeSetParams`, :py:obj:`~.cudaGraphExecMemcpyNodeSetParams`, :py:obj:`~.cudaGraphExecMemsetNodeSetParams`, :py:obj:`~.cudaGraphExecHostNodeSetParams`, :py:obj:`~.cudaGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cudaGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cudaGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cudaGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cudaGraphExecUpdate`, :py:obj:`~.cudaGraphInstantiate`
    """
    cdef cyruntime.cudaGraph_t cychildGraph
    if childGraph is None:
        pchildGraph = 0
    elif isinstance(childGraph, (cudaGraph_t,driver.CUgraph)):
        pchildGraph = int(childGraph)
    else:
        pchildGraph = int(cudaGraph_t(childGraph))
    cychildGraph = <cyruntime.cudaGraph_t><void_ptr>pchildGraph
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cyruntime.cudaGraphExec_t cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(cudaGraphExec_t(hGraphExec))
    cyhGraphExec = <cyruntime.cudaGraphExec_t><void_ptr>phGraphExec
    with nogil:
        err = cyruntime.cudaGraphExecChildGraphNodeSetParams(cyhGraphExec, cynode, cychildGraph)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphExecEventRecordNodeSetEvent' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExecEventRecordNodeSetEvent(hGraphExec, hNode, event):
    """ Sets the event for an event record node in the given graphExec.

    Sets the event of an event record node in an executable graph
    `hGraphExec`. The node is identified by the corresponding node `hNode`
    in the non-executable graph, from which the executable graph was
    instantiated.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Event record node from the graph from which graphExec was
        instantiated
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Updated event to use

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cudaGraphExecNodeSetParams`, :py:obj:`~.cudaGraphAddEventRecordNode`, :py:obj:`~.cudaGraphEventRecordNodeGetEvent`, :py:obj:`~.cudaGraphEventWaitNodeSetEvent`, :py:obj:`~.cudaEventRecordWithFlags`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaGraphExecKernelNodeSetParams`, :py:obj:`~.cudaGraphExecMemcpyNodeSetParams`, :py:obj:`~.cudaGraphExecMemsetNodeSetParams`, :py:obj:`~.cudaGraphExecHostNodeSetParams`, :py:obj:`~.cudaGraphExecChildGraphNodeSetParams`, :py:obj:`~.cudaGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cudaGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cudaGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cudaGraphExecUpdate`, :py:obj:`~.cudaGraphInstantiate`
    """
    cdef cyruntime.cudaEvent_t cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (cudaEvent_t,driver.CUevent)):
        pevent = int(event)
    else:
        pevent = int(cudaEvent_t(event))
    cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
    cdef cyruntime.cudaGraphNode_t cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (cudaGraphNode_t,driver.CUgraphNode)):
        phNode = int(hNode)
    else:
        phNode = int(cudaGraphNode_t(hNode))
    cyhNode = <cyruntime.cudaGraphNode_t><void_ptr>phNode
    cdef cyruntime.cudaGraphExec_t cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(cudaGraphExec_t(hGraphExec))
    cyhGraphExec = <cyruntime.cudaGraphExec_t><void_ptr>phGraphExec
    with nogil:
        err = cyruntime.cudaGraphExecEventRecordNodeSetEvent(cyhGraphExec, cyhNode, cyevent)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphExecEventWaitNodeSetEvent' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExecEventWaitNodeSetEvent(hGraphExec, hNode, event):
    """ Sets the event for an event wait node in the given graphExec.

    Sets the event of an event wait node in an executable graph
    `hGraphExec`. The node is identified by the corresponding node `hNode`
    in the non-executable graph, from which the executable graph was
    instantiated.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Event wait node from the graph from which graphExec was
        instantiated
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Updated event to use

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cudaGraphExecNodeSetParams`, :py:obj:`~.cudaGraphAddEventWaitNode`, :py:obj:`~.cudaGraphEventWaitNodeGetEvent`, :py:obj:`~.cudaGraphEventRecordNodeSetEvent`, :py:obj:`~.cudaEventRecordWithFlags`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaGraphExecKernelNodeSetParams`, :py:obj:`~.cudaGraphExecMemcpyNodeSetParams`, :py:obj:`~.cudaGraphExecMemsetNodeSetParams`, :py:obj:`~.cudaGraphExecHostNodeSetParams`, :py:obj:`~.cudaGraphExecChildGraphNodeSetParams`, :py:obj:`~.cudaGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cudaGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cudaGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cudaGraphExecUpdate`, :py:obj:`~.cudaGraphInstantiate`
    """
    cdef cyruntime.cudaEvent_t cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (cudaEvent_t,driver.CUevent)):
        pevent = int(event)
    else:
        pevent = int(cudaEvent_t(event))
    cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
    cdef cyruntime.cudaGraphNode_t cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (cudaGraphNode_t,driver.CUgraphNode)):
        phNode = int(hNode)
    else:
        phNode = int(cudaGraphNode_t(hNode))
    cyhNode = <cyruntime.cudaGraphNode_t><void_ptr>phNode
    cdef cyruntime.cudaGraphExec_t cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(cudaGraphExec_t(hGraphExec))
    cyhGraphExec = <cyruntime.cudaGraphExec_t><void_ptr>phGraphExec
    with nogil:
        err = cyruntime.cudaGraphExecEventWaitNodeSetEvent(cyhGraphExec, cyhNode, cyevent)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphExecExternalSemaphoresSignalNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExecExternalSemaphoresSignalNodeSetParams(hGraphExec, hNode, nodeParams : Optional[cudaExternalSemaphoreSignalNodeParams]):
    """ Sets the parameters for an external semaphore signal node in the given graphExec.

    Sets the parameters of an external semaphore signal node in an
    executable graph `hGraphExec`. The node is identified by the
    corresponding node `hNode` in the non-executable graph, from which the
    executable graph was instantiated.

    `hNode` must not have been removed from the original graph.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    Changing `nodeParams->numExtSems` is not supported.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        semaphore signal node from the graph from which graphExec was
        instantiated
    nodeParams : :py:obj:`~.cudaExternalSemaphoreSignalNodeParams`
        Updated Parameters to set

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cudaGraphExecNodeSetParams`, :py:obj:`~.cudaGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cudaImportExternalSemaphore`, :py:obj:`~.cudaSignalExternalSemaphoresAsync`, :py:obj:`~.cudaWaitExternalSemaphoresAsync`, :py:obj:`~.cudaGraphExecKernelNodeSetParams`, :py:obj:`~.cudaGraphExecMemcpyNodeSetParams`, :py:obj:`~.cudaGraphExecMemsetNodeSetParams`, :py:obj:`~.cudaGraphExecHostNodeSetParams`, :py:obj:`~.cudaGraphExecChildGraphNodeSetParams`, :py:obj:`~.cudaGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cudaGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cudaGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cudaGraphExecUpdate`, :py:obj:`~.cudaGraphInstantiate`
    """
    cdef cyruntime.cudaGraphNode_t cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (cudaGraphNode_t,driver.CUgraphNode)):
        phNode = int(hNode)
    else:
        phNode = int(cudaGraphNode_t(hNode))
    cyhNode = <cyruntime.cudaGraphNode_t><void_ptr>phNode
    cdef cyruntime.cudaGraphExec_t cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(cudaGraphExec_t(hGraphExec))
    cyhGraphExec = <cyruntime.cudaGraphExec_t><void_ptr>phGraphExec
    cdef cyruntime.cudaExternalSemaphoreSignalNodeParams* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphExecExternalSemaphoresSignalNodeSetParams(cyhGraphExec, cyhNode, cynodeParams_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphExecExternalSemaphoresWaitNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExecExternalSemaphoresWaitNodeSetParams(hGraphExec, hNode, nodeParams : Optional[cudaExternalSemaphoreWaitNodeParams]):
    """ Sets the parameters for an external semaphore wait node in the given graphExec.

    Sets the parameters of an external semaphore wait node in an executable
    graph `hGraphExec`. The node is identified by the corresponding node
    `hNode` in the non-executable graph, from which the executable graph
    was instantiated.

    `hNode` must not have been removed from the original graph.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    Changing `nodeParams->numExtSems` is not supported.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        semaphore wait node from the graph from which graphExec was
        instantiated
    nodeParams : :py:obj:`~.cudaExternalSemaphoreWaitNodeParams`
        Updated Parameters to set

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cudaGraphExecNodeSetParams`, :py:obj:`~.cudaGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cudaImportExternalSemaphore`, :py:obj:`~.cudaSignalExternalSemaphoresAsync`, :py:obj:`~.cudaWaitExternalSemaphoresAsync`, :py:obj:`~.cudaGraphExecKernelNodeSetParams`, :py:obj:`~.cudaGraphExecMemcpyNodeSetParams`, :py:obj:`~.cudaGraphExecMemsetNodeSetParams`, :py:obj:`~.cudaGraphExecHostNodeSetParams`, :py:obj:`~.cudaGraphExecChildGraphNodeSetParams`, :py:obj:`~.cudaGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cudaGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cudaGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cudaGraphExecUpdate`, :py:obj:`~.cudaGraphInstantiate`
    """
    cdef cyruntime.cudaGraphNode_t cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (cudaGraphNode_t,driver.CUgraphNode)):
        phNode = int(hNode)
    else:
        phNode = int(cudaGraphNode_t(hNode))
    cyhNode = <cyruntime.cudaGraphNode_t><void_ptr>phNode
    cdef cyruntime.cudaGraphExec_t cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(cudaGraphExec_t(hGraphExec))
    cyhGraphExec = <cyruntime.cudaGraphExec_t><void_ptr>phGraphExec
    cdef cyruntime.cudaExternalSemaphoreWaitNodeParams* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphExecExternalSemaphoresWaitNodeSetParams(cyhGraphExec, cyhNode, cynodeParams_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphNodeSetEnabled' in found_functions}}

@cython.embedsignature(True)
def cudaGraphNodeSetEnabled(hGraphExec, hNode, unsigned int isEnabled):
    """ Enables or disables the specified node in the given graphExec.

    Sets `hNode` to be either enabled or disabled. Disabled nodes are
    functionally equivalent to empty nodes until they are reenabled.
    Existing node parameters are not affected by disabling/enabling the
    node.

    The node is identified by the corresponding node `hNode` in the non-
    executable graph, from which the executable graph was instantiated.

    `hNode` must not have been removed from the original graph.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node from the graph from which graphExec was instantiated
    isEnabled : unsigned int
        Node is enabled if != 0, otherwise the node is disabled

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cudaGraphNodeGetEnabled`, :py:obj:`~.cudaGraphExecUpdate`, :py:obj:`~.cudaGraphInstantiate` :py:obj:`~.cudaGraphLaunch`

    Notes
    -----
    Currently only kernel, memset and memcpy nodes are supported.
    """
    cdef cyruntime.cudaGraphNode_t cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (cudaGraphNode_t,driver.CUgraphNode)):
        phNode = int(hNode)
    else:
        phNode = int(cudaGraphNode_t(hNode))
    cyhNode = <cyruntime.cudaGraphNode_t><void_ptr>phNode
    cdef cyruntime.cudaGraphExec_t cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(cudaGraphExec_t(hGraphExec))
    cyhGraphExec = <cyruntime.cudaGraphExec_t><void_ptr>phGraphExec
    with nogil:
        err = cyruntime.cudaGraphNodeSetEnabled(cyhGraphExec, cyhNode, isEnabled)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphNodeGetEnabled' in found_functions}}

@cython.embedsignature(True)
def cudaGraphNodeGetEnabled(hGraphExec, hNode):
    """ Query whether a node in the given graphExec is enabled.

    Sets isEnabled to 1 if `hNode` is enabled, or 0 if `hNode` is disabled.

    The node is identified by the corresponding node `hNode` in the non-
    executable graph, from which the executable graph was instantiated.

    `hNode` must not have been removed from the original graph.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node from the graph from which graphExec was instantiated

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,
    isEnabled : unsigned int
        Location to return the enabled status of the node

    See Also
    --------
    :py:obj:`~.cudaGraphNodeSetEnabled`, :py:obj:`~.cudaGraphExecUpdate`, :py:obj:`~.cudaGraphInstantiate` :py:obj:`~.cudaGraphLaunch`

    Notes
    -----
    Currently only kernel, memset and memcpy nodes are supported.
    """
    cdef cyruntime.cudaGraphNode_t cyhNode
    if hNode is None:
        phNode = 0
    elif isinstance(hNode, (cudaGraphNode_t,driver.CUgraphNode)):
        phNode = int(hNode)
    else:
        phNode = int(cudaGraphNode_t(hNode))
    cyhNode = <cyruntime.cudaGraphNode_t><void_ptr>phNode
    cdef cyruntime.cudaGraphExec_t cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(cudaGraphExec_t(hGraphExec))
    cyhGraphExec = <cyruntime.cudaGraphExec_t><void_ptr>phGraphExec
    cdef unsigned int isEnabled = 0
    with nogil:
        err = cyruntime.cudaGraphNodeGetEnabled(cyhGraphExec, cyhNode, &isEnabled)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), isEnabled)
{{endif}}

{{if 'cudaGraphExecUpdate' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExecUpdate(hGraphExec, hGraph):
    """ Check whether an executable graph can be updated with a graph and perform the update if possible.

    Updates the node parameters in the instantiated graph specified by
    `hGraphExec` with the node parameters in a topologically identical
    graph specified by `hGraph`.

    Limitations:

    - Kernel nodes:

      - The owning context of the function cannot change.

      - A node whose function originally did not use CUDA dynamic
        parallelism cannot be updated to a function which uses CDP.

      - A node whose function originally did not make device-side update
        calls cannot be updated to a function which makes device-side
        update calls.

      - A cooperative node cannot be updated to a non-cooperative node, and
        vice-versa.

      - If the graph was instantiated with
        cudaGraphInstantiateFlagUseNodePriority, the priority attribute
        cannot change. Equality is checked on the originally requested
        priority values, before they are clamped to the device's supported
        range.

      - If `hGraphExec` was not instantiated for device launch, a node
        whose function originally did not use device-side
        :py:obj:`~.cudaGraphLaunch()` cannot be updated to a function which
        uses device-side :py:obj:`~.cudaGraphLaunch()` unless the node
        resides on the same device as nodes which contained such calls at
        instantiate-time. If no such calls were present at instantiation,
        these updates cannot be performed at all.

      - Neither `hGraph` nor `hGraphExec` may contain device-updatable
        kernel nodes.

    - Memset and memcpy nodes:

      - The CUDA device(s) to which the operand(s) was allocated/mapped
        cannot change.

      - The source/destination memory must be allocated from the same
        contexts as the original source/destination memory.

      - For 2d memsets, only address and assigned value may be updated.

      - For 1d memsets, updating dimensions is also allowed, but may fail
        if the resulting operation doesn't map onto the work resources
        already allocated for the node.

    - Additional memcpy node restrictions:

      - Changing either the source or destination memory type(i.e.
        CU_MEMORYTYPE_DEVICE, CU_MEMORYTYPE_ARRAY, etc.) is not supported.

    - Conditional nodes:

      - Changing node parameters is not supported.

      - Changing parameters of nodes within the conditional body graph is
        subject to the rules above.

      - Conditional handle flags and default values are updated as part of
        the graph update.

    Note: The API may add further restrictions in future releases. The
    return code should always be checked.

    cudaGraphExecUpdate sets the result member of `resultInfo` to
    cudaGraphExecUpdateErrorTopologyChanged under the following conditions:

    - The count of nodes directly in `hGraphExec` and `hGraph` differ, in
      which case resultInfo->errorNode is set to NULL.

    - `hGraph` has more exit nodes than `hGraph`, in which case
      resultInfo->errorNode is set to one of the exit nodes in hGraph.

    - A node in `hGraph` has a different number of dependencies than the
      node from `hGraphExec` it is paired with, in which case
      resultInfo->errorNode is set to the node from `hGraph`.

    - A node in `hGraph` has a dependency that does not match with the
      corresponding dependency of the paired node from `hGraphExec`.
      resultInfo->errorNode will be set to the node from `hGraph`.
      resultInfo->errorFromNode will be set to the mismatched dependency.
      The dependencies are paired based on edge order and a dependency does
      not match when the nodes are already paired based on other edges
      examined in the graph.

    cudaGraphExecUpdate sets `the` result member of `resultInfo` to:

    - cudaGraphExecUpdateError if passed an invalid value.

    - cudaGraphExecUpdateErrorTopologyChanged if the graph topology changed

    - cudaGraphExecUpdateErrorNodeTypeChanged if the type of a node
      changed, in which case `hErrorNode_out` is set to the node from
      `hGraph`.

    - cudaGraphExecUpdateErrorFunctionChanged if the function of a kernel
      node changed (CUDA driver < 11.2)

    - cudaGraphExecUpdateErrorUnsupportedFunctionChange if the func field
      of a kernel changed in an unsupported way(see note above), in which
      case `hErrorNode_out` is set to the node from `hGraph`

    - cudaGraphExecUpdateErrorParametersChanged if any parameters to a node
      changed in a way that is not supported, in which case
      `hErrorNode_out` is set to the node from `hGraph`

    - cudaGraphExecUpdateErrorAttributesChanged if any attributes of a node
      changed in a way that is not supported, in which case
      `hErrorNode_out` is set to the node from `hGraph`

    - cudaGraphExecUpdateErrorNotSupported if something about a node is
      unsupported, like the node's type or configuration, in which case
      `hErrorNode_out` is set to the node from `hGraph`

    If the update fails for a reason not listed above, the result member of
    `resultInfo` will be set to cudaGraphExecUpdateError. If the update
    succeeds, the result member will be set to cudaGraphExecUpdateSuccess.

    cudaGraphExecUpdate returns cudaSuccess when the updated was performed
    successfully. It returns cudaErrorGraphExecUpdateFailure if the graph
    update was not performed because it included changes which violated
    constraints specific to instantiated graph update.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The instantiated graph to be updated
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph containing the updated parameters

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorGraphExecUpdateFailure`,
    resultInfo : :py:obj:`~.cudaGraphExecUpdateResultInfo`
        the error info structure

    See Also
    --------
    :py:obj:`~.cudaGraphInstantiate`
    """
    cdef cyruntime.cudaGraph_t cyhGraph
    if hGraph is None:
        phGraph = 0
    elif isinstance(hGraph, (cudaGraph_t,driver.CUgraph)):
        phGraph = int(hGraph)
    else:
        phGraph = int(cudaGraph_t(hGraph))
    cyhGraph = <cyruntime.cudaGraph_t><void_ptr>phGraph
    cdef cyruntime.cudaGraphExec_t cyhGraphExec
    if hGraphExec is None:
        phGraphExec = 0
    elif isinstance(hGraphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        phGraphExec = int(hGraphExec)
    else:
        phGraphExec = int(cudaGraphExec_t(hGraphExec))
    cyhGraphExec = <cyruntime.cudaGraphExec_t><void_ptr>phGraphExec
    cdef cudaGraphExecUpdateResultInfo resultInfo = cudaGraphExecUpdateResultInfo()
    with nogil:
        err = cyruntime.cudaGraphExecUpdate(cyhGraphExec, cyhGraph, <cyruntime.cudaGraphExecUpdateResultInfo*>resultInfo._pvt_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), resultInfo)
{{endif}}

{{if 'cudaGraphUpload' in found_functions}}

@cython.embedsignature(True)
def cudaGraphUpload(graphExec, stream):
    """ Uploads an executable graph in a stream.

    Uploads `hGraphExec` to the device in `hStream` without executing it.
    Uploads of the same `hGraphExec` will be serialized. Each upload is
    ordered behind both any previous work in `hStream` and any previous
    launches of `hGraphExec`. Uses memory cached by `stream` to back the
    allocations owned by `graphExec`.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        Executable graph to upload
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream in which to upload the graph

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`,

    See Also
    --------
    :py:obj:`~.cudaGraphInstantiate`, :py:obj:`~.cudaGraphLaunch`, :py:obj:`~.cudaGraphExecDestroy`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaGraphExec_t cygraphExec
    if graphExec is None:
        pgraphExec = 0
    elif isinstance(graphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        pgraphExec = int(graphExec)
    else:
        pgraphExec = int(cudaGraphExec_t(graphExec))
    cygraphExec = <cyruntime.cudaGraphExec_t><void_ptr>pgraphExec
    with nogil:
        err = cyruntime.cudaGraphUpload(cygraphExec, cystream)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphLaunch' in found_functions}}

@cython.embedsignature(True)
def cudaGraphLaunch(graphExec, stream):
    """ Launches an executable graph in a stream.

    Executes `graphExec` in `stream`. Only one instance of `graphExec` may
    be executing at a time. Each launch is ordered behind both any previous
    work in `stream` and any previous launches of `graphExec`. To execute a
    graph concurrently, it must be instantiated multiple times into
    multiple executable graphs.

    If any allocations created by `graphExec` remain unfreed (from a
    previous launch) and `graphExec` was not instantiated with
    :py:obj:`~.cudaGraphInstantiateFlagAutoFreeOnLaunch`, the launch will
    fail with :py:obj:`~.cudaErrorInvalidValue`.

    Parameters
    ----------
    graphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        Executable graph to launch
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream in which to launch the graph

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaGraphInstantiate`, :py:obj:`~.cudaGraphUpload`, :py:obj:`~.cudaGraphExecDestroy`
    """
    cdef cyruntime.cudaStream_t cystream
    if stream is None:
        pstream = 0
    elif isinstance(stream, (cudaStream_t,driver.CUstream)):
        pstream = int(stream)
    else:
        pstream = int(cudaStream_t(stream))
    cystream = <cyruntime.cudaStream_t><void_ptr>pstream
    cdef cyruntime.cudaGraphExec_t cygraphExec
    if graphExec is None:
        pgraphExec = 0
    elif isinstance(graphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        pgraphExec = int(graphExec)
    else:
        pgraphExec = int(cudaGraphExec_t(graphExec))
    cygraphExec = <cyruntime.cudaGraphExec_t><void_ptr>pgraphExec
    with nogil:
        err = cyruntime.cudaGraphLaunch(cygraphExec, cystream)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphExecDestroy' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExecDestroy(graphExec):
    """ Destroys an executable graph.

    Destroys the executable graph specified by `graphExec`.

    Parameters
    ----------
    graphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        Executable graph to destroy

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaGraphInstantiate`, :py:obj:`~.cudaGraphUpload`, :py:obj:`~.cudaGraphLaunch`
    """
    cdef cyruntime.cudaGraphExec_t cygraphExec
    if graphExec is None:
        pgraphExec = 0
    elif isinstance(graphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        pgraphExec = int(graphExec)
    else:
        pgraphExec = int(cudaGraphExec_t(graphExec))
    cygraphExec = <cyruntime.cudaGraphExec_t><void_ptr>pgraphExec
    with nogil:
        err = cyruntime.cudaGraphExecDestroy(cygraphExec)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphDestroy' in found_functions}}

@cython.embedsignature(True)
def cudaGraphDestroy(graph):
    """ Destroys a graph.

    Destroys the graph specified by `graph`, as well as all of its nodes.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to destroy

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaGraphCreate`
    """
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    with nogil:
        err = cyruntime.cudaGraphDestroy(cygraph)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphDebugDotPrint' in found_functions}}

@cython.embedsignature(True)
def cudaGraphDebugDotPrint(graph, char* path, unsigned int flags):
    """ Write a DOT file describing graph structure.

    Using the provided `graph`, write to `path` a DOT formatted description
    of the graph. By default this includes the graph topology, node types,
    node id, kernel names and memcpy direction. `flags` can be specified to
    write more detailed information about each node type such as parameter
    values, kernel attributes, node and function handles.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph to create a DOT file from
    path : bytes
        The path to write the DOT file to
    flags : unsigned int
        Flags from cudaGraphDebugDotFlags for specifying which additional
        node information to write

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorOperatingSystem`
    """
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    with nogil:
        err = cyruntime.cudaGraphDebugDotPrint(cygraph, path, flags)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaUserObjectCreate' in found_functions}}

@cython.embedsignature(True)
def cudaUserObjectCreate(ptr, destroy, unsigned int initialRefcount, unsigned int flags):
    """ Create a user object.

    Create a user object with the specified destructor callback and initial
    reference count. The initial references are owned by the caller.

    Destructor callbacks cannot make CUDA API calls and should avoid
    blocking behavior, as they are executed by a shared internal thread.
    Another thread may be signaled to perform such actions, if it does not
    block forward progress of tasks scheduled through CUDA.

    See CUDA User Objects in the CUDA C++ Programming Guide for more
    information on user objects.

    Parameters
    ----------
    ptr : Any
        The pointer to pass to the destroy function
    destroy : :py:obj:`~.cudaHostFn_t`
        Callback to free the user object when it is no longer in use
    initialRefcount : unsigned int
        The initial refcount to create the object with, typically 1. The
        initial references are owned by the calling thread.
    flags : unsigned int
        Currently it is required to pass
        :py:obj:`~.cudaUserObjectNoDestructorSync`, which is the only
        defined flag. This indicates that the destroy callback cannot be
        waited on by any CUDA API. Users requiring synchronization of the
        callback should signal its completion manually.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    object_out : :py:obj:`~.cudaUserObject_t`
        Location to return the user object handle

    See Also
    --------
    :py:obj:`~.cudaUserObjectRetain`, :py:obj:`~.cudaUserObjectRelease`, :py:obj:`~.cudaGraphRetainUserObject`, :py:obj:`~.cudaGraphReleaseUserObject`, :py:obj:`~.cudaGraphCreate`
    """
    cdef cyruntime.cudaHostFn_t cydestroy
    if destroy is None:
        pdestroy = 0
    elif isinstance(destroy, (cudaHostFn_t,)):
        pdestroy = int(destroy)
    else:
        pdestroy = int(cudaHostFn_t(destroy))
    cydestroy = <cyruntime.cudaHostFn_t><void_ptr>pdestroy
    cdef cudaUserObject_t object_out = cudaUserObject_t()
    cdef _HelperInputVoidPtrStruct cyptrHelper
    cdef void* cyptr = _helper_input_void_ptr(ptr, &cyptrHelper)
    with nogil:
        err = cyruntime.cudaUserObjectCreate(<cyruntime.cudaUserObject_t*>object_out._pvt_ptr, cyptr, cydestroy, initialRefcount, flags)
    _helper_input_void_ptr_free(&cyptrHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), object_out)
{{endif}}

{{if 'cudaUserObjectRetain' in found_functions}}

@cython.embedsignature(True)
def cudaUserObjectRetain(object, unsigned int count):
    """ Retain a reference to a user object.

    Retains new references to a user object. The new references are owned
    by the caller.

    See CUDA User Objects in the CUDA C++ Programming Guide for more
    information on user objects.

    Parameters
    ----------
    object : :py:obj:`~.cudaUserObject_t`
        The object to retain
    count : unsigned int
        The number of references to retain, typically 1. Must be nonzero
        and not larger than INT_MAX.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaUserObjectCreate`, :py:obj:`~.cudaUserObjectRelease`, :py:obj:`~.cudaGraphRetainUserObject`, :py:obj:`~.cudaGraphReleaseUserObject`, :py:obj:`~.cudaGraphCreate`
    """
    cdef cyruntime.cudaUserObject_t cyobject
    if object is None:
        pobject = 0
    elif isinstance(object, (cudaUserObject_t,driver.CUuserObject)):
        pobject = int(object)
    else:
        pobject = int(cudaUserObject_t(object))
    cyobject = <cyruntime.cudaUserObject_t><void_ptr>pobject
    with nogil:
        err = cyruntime.cudaUserObjectRetain(cyobject, count)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaUserObjectRelease' in found_functions}}

@cython.embedsignature(True)
def cudaUserObjectRelease(object, unsigned int count):
    """ Release a reference to a user object.

    Releases user object references owned by the caller. The object's
    destructor is invoked if the reference count reaches zero.

    It is undefined behavior to release references not owned by the caller,
    or to use a user object handle after all references are released.

    See CUDA User Objects in the CUDA C++ Programming Guide for more
    information on user objects.

    Parameters
    ----------
    object : :py:obj:`~.cudaUserObject_t`
        The object to release
    count : unsigned int
        The number of references to release, typically 1. Must be nonzero
        and not larger than INT_MAX.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaUserObjectCreate`, :py:obj:`~.cudaUserObjectRetain`, :py:obj:`~.cudaGraphRetainUserObject`, :py:obj:`~.cudaGraphReleaseUserObject`, :py:obj:`~.cudaGraphCreate`
    """
    cdef cyruntime.cudaUserObject_t cyobject
    if object is None:
        pobject = 0
    elif isinstance(object, (cudaUserObject_t,driver.CUuserObject)):
        pobject = int(object)
    else:
        pobject = int(cudaUserObject_t(object))
    cyobject = <cyruntime.cudaUserObject_t><void_ptr>pobject
    with nogil:
        err = cyruntime.cudaUserObjectRelease(cyobject, count)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphRetainUserObject' in found_functions}}

@cython.embedsignature(True)
def cudaGraphRetainUserObject(graph, object, unsigned int count, unsigned int flags):
    """ Retain a reference to a user object from a graph.

    Creates or moves user object references that will be owned by a CUDA
    graph.

    See CUDA User Objects in the CUDA C++ Programming Guide for more
    information on user objects.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph to associate the reference with
    object : :py:obj:`~.cudaUserObject_t`
        The user object to retain a reference for
    count : unsigned int
        The number of references to add to the graph, typically 1. Must be
        nonzero and not larger than INT_MAX.
    flags : unsigned int
        The optional flag :py:obj:`~.cudaGraphUserObjectMove` transfers
        references from the calling thread, rather than create new
        references. Pass 0 to create new references.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaUserObjectCreate` :py:obj:`~.cudaUserObjectRetain`, :py:obj:`~.cudaUserObjectRelease`, :py:obj:`~.cudaGraphReleaseUserObject`, :py:obj:`~.cudaGraphCreate`
    """
    cdef cyruntime.cudaUserObject_t cyobject
    if object is None:
        pobject = 0
    elif isinstance(object, (cudaUserObject_t,driver.CUuserObject)):
        pobject = int(object)
    else:
        pobject = int(cudaUserObject_t(object))
    cyobject = <cyruntime.cudaUserObject_t><void_ptr>pobject
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    with nogil:
        err = cyruntime.cudaGraphRetainUserObject(cygraph, cyobject, count, flags)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphReleaseUserObject' in found_functions}}

@cython.embedsignature(True)
def cudaGraphReleaseUserObject(graph, object, unsigned int count):
    """ Release a user object reference from a graph.

    Releases user object references owned by a graph.

    See CUDA User Objects in the CUDA C++ Programming Guide for more
    information on user objects.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph that will release the reference
    object : :py:obj:`~.cudaUserObject_t`
        The user object to release a reference for
    count : unsigned int
        The number of references to release, typically 1. Must be nonzero
        and not larger than INT_MAX.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaUserObjectCreate` :py:obj:`~.cudaUserObjectRetain`, :py:obj:`~.cudaUserObjectRelease`, :py:obj:`~.cudaGraphRetainUserObject`, :py:obj:`~.cudaGraphCreate`
    """
    cdef cyruntime.cudaUserObject_t cyobject
    if object is None:
        pobject = 0
    elif isinstance(object, (cudaUserObject_t,driver.CUuserObject)):
        pobject = int(object)
    else:
        pobject = int(cudaUserObject_t(object))
    cyobject = <cyruntime.cudaUserObject_t><void_ptr>pobject
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    with nogil:
        err = cyruntime.cudaGraphReleaseUserObject(cygraph, cyobject, count)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphAddNode' in found_functions}}

@cython.embedsignature(True)
def cudaGraphAddNode(graph, pDependencies : Optional[tuple[cudaGraphNode_t] | list[cudaGraphNode_t]], dependencyData : Optional[tuple[cudaGraphEdgeData] | list[cudaGraphEdgeData]], size_t numDependencies, nodeParams : Optional[cudaGraphNodeParams]):
    """ Adds a node of arbitrary type to a graph.

    Creates a new node in `graph` described by `nodeParams` with
    `numDependencies` dependencies specified via `pDependencies`.
    `numDependencies` may be 0. `pDependencies` may be null if
    `numDependencies` is 0. `pDependencies` may not have any duplicate
    entries.

    `nodeParams` is a tagged union. The node type should be specified in
    the `typename` field, and type-specific parameters in the corresponding
    union member. All unused bytes - that is, `reserved0` and all bytes
    past the utilized union member - must be set to zero. It is recommended
    to use brace initialization or memset to ensure all bytes are
    initialized.

    Note that for some node types, `nodeParams` may contain "out
    parameters" which are modified during the call, such as
    `nodeParams->alloc.dptr`.

    A handle to the new node will be returned in `phGraphNode`.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    pDependencies : list[:py:obj:`~.cudaGraphNode_t`]
        Dependencies of the node
    dependencyData : list[:py:obj:`~.cudaGraphEdgeData`]
        Optional edge data for the dependencies. If NULL, the data is
        assumed to be default (zeroed) for all dependencies.
    numDependencies : size_t
        Number of dependencies
    nodeParams : :py:obj:`~.cudaGraphNodeParams`
        Specification of the node

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidDeviceFunction`, :py:obj:`~.cudaErrorNotSupported`
    pGraphNode : :py:obj:`~.cudaGraphNode_t`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cudaGraphCreate`, :py:obj:`~.cudaGraphNodeSetParams`, :py:obj:`~.cudaGraphExecNodeSetParams`
    """
    dependencyData = [] if dependencyData is None else dependencyData
    if not all(isinstance(_x, (cudaGraphEdgeData,)) for _x in dependencyData):
        raise TypeError("Argument 'dependencyData' is not instance of type (expected tuple[cyruntime.cudaGraphEdgeData,] or list[cyruntime.cudaGraphEdgeData,]")
    pDependencies = [] if pDependencies is None else pDependencies
    if not all(isinstance(_x, (cudaGraphNode_t,driver.CUgraphNode)) for _x in pDependencies):
        raise TypeError("Argument 'pDependencies' is not instance of type (expected tuple[cyruntime.cudaGraphNode_t,driver.CUgraphNode] or list[cyruntime.cudaGraphNode_t,driver.CUgraphNode]")
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphNode_t pGraphNode = cudaGraphNode_t()
    cdef cyruntime.cudaGraphNode_t* cypDependencies = NULL
    if len(pDependencies) > 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*> calloc(len(pDependencies), sizeof(cyruntime.cudaGraphNode_t))
        if cypDependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(pDependencies)) + 'x' + str(sizeof(cyruntime.cudaGraphNode_t)))
        else:
            for idx in range(len(pDependencies)):
                cypDependencies[idx] = <cyruntime.cudaGraphNode_t>(<cudaGraphNode_t>pDependencies[idx])._pvt_ptr[0]
    elif len(pDependencies) == 1:
        cypDependencies = <cyruntime.cudaGraphNode_t*>(<cudaGraphNode_t>pDependencies[0])._pvt_ptr
    cdef cyruntime.cudaGraphEdgeData* cydependencyData = NULL
    if len(dependencyData) > 1:
        cydependencyData = <cyruntime.cudaGraphEdgeData*> calloc(len(dependencyData), sizeof(cyruntime.cudaGraphEdgeData))
        if cydependencyData is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencyData)) + 'x' + str(sizeof(cyruntime.cudaGraphEdgeData)))
        for idx in range(len(dependencyData)):
            string.memcpy(&cydependencyData[idx], (<cudaGraphEdgeData>dependencyData[idx])._pvt_ptr, sizeof(cyruntime.cudaGraphEdgeData))
    elif len(dependencyData) == 1:
        cydependencyData = (<cudaGraphEdgeData>dependencyData[0])._pvt_ptr
    cdef cyruntime.cudaGraphNodeParams* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphAddNode(<cyruntime.cudaGraphNode_t*>pGraphNode._pvt_ptr, cygraph, cypDependencies, cydependencyData, numDependencies, cynodeParams_ptr)
    if len(pDependencies) > 1 and cypDependencies is not NULL:
        free(cypDependencies)
    if len(dependencyData) > 1 and cydependencyData is not NULL:
        free(cydependencyData)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pGraphNode)
{{endif}}

{{if 'cudaGraphNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphNodeSetParams(node, nodeParams : Optional[cudaGraphNodeParams]):
    """ Update's a graph node's parameters.

    Sets the parameters of graph node `node` to `nodeParams`. The node type
    specified by `nodeParams->type` must match the type of `node`.
    `nodeParams` must be fully initialized and all unused bytes (reserved,
    padding) zeroed.

    Modifying parameters is not supported for node types
    cudaGraphNodeTypeMemAlloc and cudaGraphNodeTypeMemFree.

    Parameters
    ----------
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.cudaGraphNodeParams`
        Parameters to copy

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidDeviceFunction`, :py:obj:`~.cudaErrorNotSupported`

    See Also
    --------
    :py:obj:`~.cudaGraphAddNode`, :py:obj:`~.cudaGraphExecNodeSetParams`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cyruntime.cudaGraphNodeParams* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphNodeSetParams(cynode, cynodeParams_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphExecNodeSetParams' in found_functions}}

@cython.embedsignature(True)
def cudaGraphExecNodeSetParams(graphExec, node, nodeParams : Optional[cudaGraphNodeParams]):
    """ Update's a graph node's parameters in an instantiated graph.

    Sets the parameters of a node in an executable graph `graphExec`. The
    node is identified by the corresponding node `node` in the non-
    executable graph from which the executable graph was instantiated.
    `node` must not have been removed from the original graph.

    The modifications only affect future launches of `graphExec`. Already
    enqueued or running launches of `graphExec` are not affected by this
    call. `node` is also not modified by this call.

    Allowed changes to parameters on executable graphs are as follows:

    **View CUDA Toolkit Documentation for a table example**

    Parameters
    ----------
    graphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to update the specified node
    node : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Corresponding node from the graph from which graphExec was
        instantiated
    nodeParams : :py:obj:`~.cudaGraphNodeParams`
        Updated Parameters to set

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidDeviceFunction`, :py:obj:`~.cudaErrorNotSupported`

    See Also
    --------
    :py:obj:`~.cudaGraphAddNode`, :py:obj:`~.cudaGraphNodeSetParams` :py:obj:`~.cudaGraphExecUpdate`, :py:obj:`~.cudaGraphInstantiate`
    """
    cdef cyruntime.cudaGraphNode_t cynode
    if node is None:
        pnode = 0
    elif isinstance(node, (cudaGraphNode_t,driver.CUgraphNode)):
        pnode = int(node)
    else:
        pnode = int(cudaGraphNode_t(node))
    cynode = <cyruntime.cudaGraphNode_t><void_ptr>pnode
    cdef cyruntime.cudaGraphExec_t cygraphExec
    if graphExec is None:
        pgraphExec = 0
    elif isinstance(graphExec, (cudaGraphExec_t,driver.CUgraphExec)):
        pgraphExec = int(graphExec)
    else:
        pgraphExec = int(cudaGraphExec_t(graphExec))
    cygraphExec = <cyruntime.cudaGraphExec_t><void_ptr>pgraphExec
    cdef cyruntime.cudaGraphNodeParams* cynodeParams_ptr = nodeParams._pvt_ptr if nodeParams is not None else NULL
    with nogil:
        err = cyruntime.cudaGraphExecNodeSetParams(cygraphExec, cynode, cynodeParams_ptr)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaGraphConditionalHandleCreate' in found_functions}}

@cython.embedsignature(True)
def cudaGraphConditionalHandleCreate(graph, unsigned int defaultLaunchValue, unsigned int flags):
    """ Create a conditional handle.

    Creates a conditional handle associated with `hGraph`.

    The conditional handle must be associated with a conditional node in
    this graph or one of its children.

    Handles not associated with a conditional node may cause graph
    instantiation to fail.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph which will contain the conditional node using this handle.
    defaultLaunchValue : unsigned int
        Optional initial value for the conditional variable. Applied at the
        beginning of each graph execution if cudaGraphCondAssignDefault is
        set in `flags`.
    flags : unsigned int
        Currently must be cudaGraphCondAssignDefault or 0.

    Returns
    -------
    cudaError_t
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    pHandle_out : :py:obj:`~.cudaGraphConditionalHandle`
        Pointer used to return the handle to the caller.

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`,
    """
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphConditionalHandle pHandle_out = cudaGraphConditionalHandle()
    with nogil:
        err = cyruntime.cudaGraphConditionalHandleCreate(<cyruntime.cudaGraphConditionalHandle*>pHandle_out._pvt_ptr, cygraph, defaultLaunchValue, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pHandle_out)
{{endif}}

{{if 'cudaGraphConditionalHandleCreate_v2' in found_functions}}

@cython.embedsignature(True)
def cudaGraphConditionalHandleCreate_v2(graph, ctx, unsigned int defaultLaunchValue, unsigned int flags):
    """ Create a conditional handle.

    Creates a conditional handle associated with `hGraph`.

    The conditional handle must be associated with a conditional node in
    this graph or one of its children.

    Handles not associated with a conditional node may cause graph
    instantiation to fail.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph which will contain the conditional node using this handle.
    ctx : :py:obj:`~.cudaExecutionContext_t`
        Execution context for the handle and associated conditional node.
        If NULL, current context will be used.
    defaultLaunchValue : unsigned int
        Optional initial value for the conditional variable. Applied at the
        beginning of each graph execution if cudaGraphCondAssignDefault is
        set in `flags`.
    flags : unsigned int
        Currently must be cudaGraphCondAssignDefault or 0.

    Returns
    -------
    cudaError_t
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    pHandle_out : :py:obj:`~.cudaGraphConditionalHandle`
        Pointer used to return the handle to the caller.

    See Also
    --------
    :py:obj:`~.cuGraphAddNode`,
    """
    cdef cyruntime.cudaExecutionContext_t cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (cudaExecutionContext_t,)):
        pctx = int(ctx)
    else:
        pctx = int(cudaExecutionContext_t(ctx))
    cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>pctx
    cdef cyruntime.cudaGraph_t cygraph
    if graph is None:
        pgraph = 0
    elif isinstance(graph, (cudaGraph_t,driver.CUgraph)):
        pgraph = int(graph)
    else:
        pgraph = int(cudaGraph_t(graph))
    cygraph = <cyruntime.cudaGraph_t><void_ptr>pgraph
    cdef cudaGraphConditionalHandle pHandle_out = cudaGraphConditionalHandle()
    with nogil:
        err = cyruntime.cudaGraphConditionalHandleCreate_v2(<cyruntime.cudaGraphConditionalHandle*>pHandle_out._pvt_ptr, cygraph, cyctx, defaultLaunchValue, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pHandle_out)
{{endif}}

{{if 'cudaGetDriverEntryPoint' in found_functions}}

@cython.embedsignature(True)
def cudaGetDriverEntryPoint(char* symbol, unsigned long long flags):
    """ Returns the requested driver API function pointer.

    [Deprecated]

    Returns in `**funcPtr` the address of the CUDA driver function for the
    requested flags.

    For a requested driver symbol, if the CUDA version in which the driver
    symbol was introduced is less than or equal to the CUDA runtime
    version, the API will return the function pointer to the corresponding
    versioned driver function.

    The pointer returned by the API should be cast to a function pointer
    matching the requested driver function's definition in the API header
    file. The function pointer typedef can be picked up from the
    corresponding typedefs header file. For example, cudaTypedefs.h
    consists of function pointer typedefs for driver APIs defined in
    cuda.h.

    The API will return :py:obj:`~.cudaSuccess` and set the returned
    `funcPtr` if the requested driver function is valid and supported on
    the platform.

    The API will return :py:obj:`~.cudaSuccess` and set the returned
    `funcPtr` to NULL if the requested driver function is not supported on
    the platform, no ABI compatible driver function exists for the CUDA
    runtime version or if the driver symbol is invalid.

    It will also set the optional `driverStatus` to one of the values in
    :py:obj:`~.cudaDriverEntryPointQueryResult` with the following
    meanings:

    - :py:obj:`~.cudaDriverEntryPointSuccess` - The requested symbol was
      succesfully found based on input arguments and `pfn` is valid

    - :py:obj:`~.cudaDriverEntryPointSymbolNotFound` - The requested symbol
      was not found

    - :py:obj:`~.cudaDriverEntryPointVersionNotSufficent` - The requested
      symbol was found but is not supported by the current runtime version
      (CUDART_VERSION)

    The requested flags can be:

    - :py:obj:`~.cudaEnableDefault`: This is the default mode. This is
      equivalent to :py:obj:`~.cudaEnablePerThreadDefaultStream` if the
      code is compiled with --default-stream per-thread compilation flag or
      the macro CUDA_API_PER_THREAD_DEFAULT_STREAM is defined;
      :py:obj:`~.cudaEnableLegacyStream` otherwise.

    - :py:obj:`~.cudaEnableLegacyStream`: This will enable the search for
      all driver symbols that match the requested driver symbol name except
      the corresponding per-thread versions.

    - :py:obj:`~.cudaEnablePerThreadDefaultStream`: This will enable the
      search for all driver symbols that match the requested driver symbol
      name including the per-thread versions. If a per-thread version is
      not found, the API will return the legacy version of the driver
      function.

    Parameters
    ----------
    symbol : bytes
        The base name of the driver API function to look for. As an
        example, for the driver API :py:obj:`~.cuMemAlloc_v2`, `symbol`
        would be cuMemAlloc. Note that the API will use the CUDA runtime
        version to return the address to the most recent ABI compatible
        driver symbol, :py:obj:`~.cuMemAlloc` or :py:obj:`~.cuMemAlloc_v2`.
    flags : unsigned long long
        Flags to specify search options.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotSupported`
    funcPtr : Any
        Location to return the function pointer to the requested driver
        function
    driverStatus : :py:obj:`~.cudaDriverEntryPointQueryResult`
        Optional location to store the status of finding the symbol from
        the driver. See :py:obj:`~.cudaDriverEntryPointQueryResult` for
        possible values.

    See Also
    --------
    :py:obj:`~.cuGetProcAddress`

    Notes
    -----
    This API is deprecated and :py:obj:`~.cudaGetDriverEntryPointByVersion` (with a hardcoded :py:obj:`~.cudaVersion`) should be used instead.
    """
    cdef void_ptr funcPtr = 0
    cdef cyruntime.cudaDriverEntryPointQueryResult driverStatus
    with nogil:
        err = cyruntime.cudaGetDriverEntryPoint(symbol, <void**>&funcPtr, flags, &driverStatus)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None)
    return (cudaError_t(err), funcPtr, cudaDriverEntryPointQueryResult(driverStatus))
{{endif}}

{{if 'cudaGetDriverEntryPointByVersion' in found_functions}}

@cython.embedsignature(True)
def cudaGetDriverEntryPointByVersion(char* symbol, unsigned int cudaVersion, unsigned long long flags):
    """ Returns the requested driver API function pointer by CUDA version.

    Returns in `**funcPtr` the address of the CUDA driver function for the
    requested flags and CUDA driver version.

    The CUDA version is specified as (1000 * major + 10 * minor), so CUDA
    11.2 should be specified as 11020. For a requested driver symbol, if
    the specified CUDA version is greater than or equal to the CUDA version
    in which the driver symbol was introduced, this API will return the
    function pointer to the corresponding versioned function. If the
    specified CUDA version is greater than the driver version, the API will
    return :py:obj:`~.cudaErrorInvalidValue`.

    The pointer returned by the API should be cast to a function pointer
    matching the requested driver function's definition in the API header
    file. The function pointer typedef can be picked up from the
    corresponding typedefs header file. For example, cudaTypedefs.h
    consists of function pointer typedefs for driver APIs defined in
    cuda.h.

    For the case where the CUDA version requested is greater than the CUDA
    Toolkit installed, there may not be an appropriate function pointer
    typedef in the corresponding header file and may need a custom typedef
    to match the driver function signature returned. This can be done by
    getting the typedefs from a later toolkit or creating appropriately
    matching custom function typedefs.

    The API will return :py:obj:`~.cudaSuccess` and set the returned
    `funcPtr` if the requested driver function is valid and supported on
    the platform.

    The API will return :py:obj:`~.cudaSuccess` and set the returned
    `funcPtr` to NULL if the requested driver function is not supported on
    the platform, no ABI compatible driver function exists for the
    requested version or if the driver symbol is invalid.

    It will also set the optional `driverStatus` to one of the values in
    :py:obj:`~.cudaDriverEntryPointQueryResult` with the following
    meanings:

    - :py:obj:`~.cudaDriverEntryPointSuccess` - The requested symbol was
      succesfully found based on input arguments and `pfn` is valid

    - :py:obj:`~.cudaDriverEntryPointSymbolNotFound` - The requested symbol
      was not found

    - :py:obj:`~.cudaDriverEntryPointVersionNotSufficent` - The requested
      symbol was found but is not supported by the specified version
      `cudaVersion`

    The requested flags can be:

    - :py:obj:`~.cudaEnableDefault`: This is the default mode. This is
      equivalent to :py:obj:`~.cudaEnablePerThreadDefaultStream` if the
      code is compiled with --default-stream per-thread compilation flag or
      the macro CUDA_API_PER_THREAD_DEFAULT_STREAM is defined;
      :py:obj:`~.cudaEnableLegacyStream` otherwise.

    - :py:obj:`~.cudaEnableLegacyStream`: This will enable the search for
      all driver symbols that match the requested driver symbol name except
      the corresponding per-thread versions.

    - :py:obj:`~.cudaEnablePerThreadDefaultStream`: This will enable the
      search for all driver symbols that match the requested driver symbol
      name including the per-thread versions. If a per-thread version is
      not found, the API will return the legacy version of the driver
      function.

    Parameters
    ----------
    symbol : bytes
        The base name of the driver API function to look for. As an
        example, for the driver API :py:obj:`~.cuMemAlloc_v2`, `symbol`
        would be cuMemAlloc.
    cudaVersion : unsigned int
        The CUDA version to look for the requested driver symbol
    flags : unsigned long long
        Flags to specify search options.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotSupported`
    funcPtr : Any
        Location to return the function pointer to the requested driver
        function
    driverStatus : :py:obj:`~.cudaDriverEntryPointQueryResult`
        Optional location to store the status of finding the symbol from
        the driver. See :py:obj:`~.cudaDriverEntryPointQueryResult` for
        possible values.

    See Also
    --------
    :py:obj:`~.cuGetProcAddress`
    """
    cdef void_ptr funcPtr = 0
    cdef cyruntime.cudaDriverEntryPointQueryResult driverStatus
    with nogil:
        err = cyruntime.cudaGetDriverEntryPointByVersion(symbol, <void**>&funcPtr, cudaVersion, flags, &driverStatus)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None)
    return (cudaError_t(err), funcPtr, cudaDriverEntryPointQueryResult(driverStatus))
{{endif}}

{{if 'cudaLibraryLoadData' in found_functions}}

@cython.embedsignature(True)
def cudaLibraryLoadData(code, jitOptions : Optional[tuple[cudaJitOption] | list[cudaJitOption]], jitOptionsValues : Optional[tuple[Any] | list[Any]], unsigned int numJitOptions, libraryOptions : Optional[tuple[cudaLibraryOption] | list[cudaLibraryOption]], libraryOptionValues : Optional[tuple[Any] | list[Any]], unsigned int numLibraryOptions):
    """ Load a library with specified code and options.

    Takes a pointer `code` and loads the corresponding library `library`
    based on the application defined library loading mode:

    - If module loading is set to EAGER, via the environment variables
      described in "Module loading", `library` is loaded eagerly into all
      contexts at the time of the call and future contexts at the time of
      creation until the library is unloaded with
      :py:obj:`~.cudaLibraryUnload()`.

    - If the environment variables are set to LAZY, `library` is not
      immediately loaded onto all existent contexts and will only be loaded
      when a function is needed for that context, such as a kernel launch.

    These environment variables are described in the CUDA programming guide
    under the "CUDA environment variables" section.

    The `code` may be a `cubin` or `fatbin` as output by nvcc, or a NULL-
    terminated `PTX`, either as output by nvcc or hand-written, or `Tile`
    IR data. A fatbin should also contain relocatable code when doing
    separate compilation. Please also see the documentation for nvrtc
    (https://docs.nvidia.com/cuda/nvrtc/index.html), nvjitlink
    (https://docs.nvidia.com/cuda/nvjitlink/index.html), and nvfatbin
    (https://docs.nvidia.com/cuda/nvfatbin/index.html) for more information
    on generating loadable code at runtime.

    Options are passed as an array via `jitOptions` and any corresponding
    parameters are passed in `jitOptionsValues`. The number of total JIT
    options is supplied via `numJitOptions`. Any outputs will be returned
    via `jitOptionsValues`.

    Library load options are passed as an array via `libraryOptions` and
    any corresponding parameters are passed in `libraryOptionValues`. The
    number of total library load options is supplied via
    `numLibraryOptions`.

    Parameters
    ----------
    code : Any
        Code to load
    jitOptions : list[:py:obj:`~.cudaJitOption`]
        Options for JIT
    jitOptionsValues : list[Any]
        Option values for JIT
    numJitOptions : unsigned int
        Number of options
    libraryOptions : list[:py:obj:`~.cudaLibraryOption`]
        Options for loading
    libraryOptionValues : list[Any]
        Option values for loading
    numLibraryOptions : unsigned int
        Number of options for loading

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorMemoryAllocation`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInvalidPtx`, :py:obj:`~.cudaErrorUnsupportedPtxVersion`, :py:obj:`~.cudaErrorNoKernelImageForDevice`, :py:obj:`~.cudaErrorSharedObjectSymbolNotFound`, :py:obj:`~.cudaErrorSharedObjectInitFailed`, :py:obj:`~.cudaErrorJitCompilerNotFound`
    library : :py:obj:`~.cudaLibrary_t`
        Returned library

    See Also
    --------
    :py:obj:`~.cudaLibraryLoadFromFile`, :py:obj:`~.cudaLibraryUnload`, :py:obj:`~.cuLibraryLoadData`
    """
    libraryOptionValues = [] if libraryOptionValues is None else libraryOptionValues
    libraryOptions = [] if libraryOptions is None else libraryOptions
    if not all(isinstance(_x, (cudaLibraryOption)) for _x in libraryOptions):
        raise TypeError("Argument 'libraryOptions' is not instance of type (expected tuple[cyruntime.cudaLibraryOption] or list[cyruntime.cudaLibraryOption]")
    jitOptionsValues = [] if jitOptionsValues is None else jitOptionsValues
    jitOptions = [] if jitOptions is None else jitOptions
    if not all(isinstance(_x, (cudaJitOption)) for _x in jitOptions):
        raise TypeError("Argument 'jitOptions' is not instance of type (expected tuple[cyruntime.cudaJitOption] or list[cyruntime.cudaJitOption]")
    cdef cudaLibrary_t library = cudaLibrary_t()
    cdef _HelperInputVoidPtrStruct cycodeHelper
    cdef void* cycode = _helper_input_void_ptr(code, &cycodeHelper)
    cdef vector[cyruntime.cudaJitOption] cyjitOptions = [int(pyjitOptions) for pyjitOptions in (jitOptions)]
    pylist = [_HelperCudaJitOption(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(jitOptions, jitOptionsValues)]
    cdef _InputVoidPtrPtrHelper voidStarHelperjitOptionsValues = _InputVoidPtrPtrHelper(pylist)
    cdef void** cyjitOptionsValues_ptr = <void**><void_ptr>voidStarHelperjitOptionsValues.cptr
    if numJitOptions > len(jitOptions): raise RuntimeError("List is too small: " + str(len(jitOptions)) + " < " + str(numJitOptions))
    if numJitOptions > len(jitOptionsValues): raise RuntimeError("List is too small: " + str(len(jitOptionsValues)) + " < " + str(numJitOptions))
    cdef vector[cyruntime.cudaLibraryOption] cylibraryOptions = [int(pylibraryOptions) for pylibraryOptions in (libraryOptions)]
    pylist = [_HelperCudaLibraryOption(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(libraryOptions, libraryOptionValues)]
    cdef _InputVoidPtrPtrHelper voidStarHelperlibraryOptionValues = _InputVoidPtrPtrHelper(pylist)
    cdef void** cylibraryOptionValues_ptr = <void**><void_ptr>voidStarHelperlibraryOptionValues.cptr
    if numLibraryOptions > len(libraryOptions): raise RuntimeError("List is too small: " + str(len(libraryOptions)) + " < " + str(numLibraryOptions))
    if numLibraryOptions > len(libraryOptionValues): raise RuntimeError("List is too small: " + str(len(libraryOptionValues)) + " < " + str(numLibraryOptions))
    with nogil:
        err = cyruntime.cudaLibraryLoadData(<cyruntime.cudaLibrary_t*>library._pvt_ptr, cycode, cyjitOptions.data(), cyjitOptionsValues_ptr, numJitOptions, cylibraryOptions.data(), cylibraryOptionValues_ptr, numLibraryOptions)
    _helper_input_void_ptr_free(&cycodeHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), library)
{{endif}}

{{if 'cudaLibraryLoadFromFile' in found_functions}}

@cython.embedsignature(True)
def cudaLibraryLoadFromFile(char* fileName, jitOptions : Optional[tuple[cudaJitOption] | list[cudaJitOption]], jitOptionsValues : Optional[tuple[Any] | list[Any]], unsigned int numJitOptions, libraryOptions : Optional[tuple[cudaLibraryOption] | list[cudaLibraryOption]], libraryOptionValues : Optional[tuple[Any] | list[Any]], unsigned int numLibraryOptions):
    """ Load a library with specified file and options.

    Takes a pointer `code` and loads the corresponding library `library`
    based on the application defined library loading mode:

    - If module loading is set to EAGER, via the environment variables
      described in "Module loading", `library` is loaded eagerly into all
      contexts at the time of the call and future contexts at the time of
      creation until the library is unloaded with
      :py:obj:`~.cudaLibraryUnload()`.

    - If the environment variables are set to LAZY, `library` is not
      immediately loaded onto all existent contexts and will only be loaded
      when a function is needed for that context, such as a kernel launch.

    These environment variables are described in the CUDA programming guide
    under the "CUDA environment variables" section.

    The file should be a `cubin` file as output by nvcc, or a `PTX` file
    either as output by nvcc or handwritten, or a `fatbin` file as output
    by nvcc or hand-written, or `Tile` IR file. A fatbin should also
    contain relocatable code when doing separate compilation. Please also
    see the documentation for nvrtc
    (https://docs.nvidia.com/cuda/nvrtc/index.html), nvjitlink
    (https://docs.nvidia.com/cuda/nvjitlink/index.html), and nvfatbin
    (https://docs.nvidia.com/cuda/nvfatbin/index.html) for more information
    on generating loadable code at runtime.

    Options are passed as an array via `jitOptions` and any corresponding
    parameters are passed in `jitOptionsValues`. The number of total
    options is supplied via `numJitOptions`. Any outputs will be returned
    via `jitOptionsValues`.

    Library load options are passed as an array via `libraryOptions` and
    any corresponding parameters are passed in `libraryOptionValues`. The
    number of total library load options is supplied via
    `numLibraryOptions`.

    Parameters
    ----------
    fileName : bytes
        File to load from
    jitOptions : list[:py:obj:`~.cudaJitOption`]
        Options for JIT
    jitOptionsValues : list[Any]
        Option values for JIT
    numJitOptions : unsigned int
        Number of options
    libraryOptions : list[:py:obj:`~.cudaLibraryOption`]
        Options for loading
    libraryOptionValues : list[Any]
        Option values for loading
    numLibraryOptions : unsigned int
        Number of options for loading

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorMemoryAllocation`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInvalidPtx`, :py:obj:`~.cudaErrorUnsupportedPtxVersion`, :py:obj:`~.cudaErrorNoKernelImageForDevice`, :py:obj:`~.cudaErrorSharedObjectSymbolNotFound`, :py:obj:`~.cudaErrorSharedObjectInitFailed`, :py:obj:`~.cudaErrorJitCompilerNotFound`
    library : :py:obj:`~.cudaLibrary_t`
        Returned library

    See Also
    --------
    :py:obj:`~.cudaLibraryLoadData`, :py:obj:`~.cudaLibraryUnload`, :py:obj:`~.cuLibraryLoadFromFile`
    """
    libraryOptionValues = [] if libraryOptionValues is None else libraryOptionValues
    libraryOptions = [] if libraryOptions is None else libraryOptions
    if not all(isinstance(_x, (cudaLibraryOption)) for _x in libraryOptions):
        raise TypeError("Argument 'libraryOptions' is not instance of type (expected tuple[cyruntime.cudaLibraryOption] or list[cyruntime.cudaLibraryOption]")
    jitOptionsValues = [] if jitOptionsValues is None else jitOptionsValues
    jitOptions = [] if jitOptions is None else jitOptions
    if not all(isinstance(_x, (cudaJitOption)) for _x in jitOptions):
        raise TypeError("Argument 'jitOptions' is not instance of type (expected tuple[cyruntime.cudaJitOption] or list[cyruntime.cudaJitOption]")
    cdef cudaLibrary_t library = cudaLibrary_t()
    cdef vector[cyruntime.cudaJitOption] cyjitOptions = [int(pyjitOptions) for pyjitOptions in (jitOptions)]
    pylist = [_HelperCudaJitOption(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(jitOptions, jitOptionsValues)]
    cdef _InputVoidPtrPtrHelper voidStarHelperjitOptionsValues = _InputVoidPtrPtrHelper(pylist)
    cdef void** cyjitOptionsValues_ptr = <void**><void_ptr>voidStarHelperjitOptionsValues.cptr
    if numJitOptions > len(jitOptions): raise RuntimeError("List is too small: " + str(len(jitOptions)) + " < " + str(numJitOptions))
    if numJitOptions > len(jitOptionsValues): raise RuntimeError("List is too small: " + str(len(jitOptionsValues)) + " < " + str(numJitOptions))
    cdef vector[cyruntime.cudaLibraryOption] cylibraryOptions = [int(pylibraryOptions) for pylibraryOptions in (libraryOptions)]
    pylist = [_HelperCudaLibraryOption(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(libraryOptions, libraryOptionValues)]
    cdef _InputVoidPtrPtrHelper voidStarHelperlibraryOptionValues = _InputVoidPtrPtrHelper(pylist)
    cdef void** cylibraryOptionValues_ptr = <void**><void_ptr>voidStarHelperlibraryOptionValues.cptr
    if numLibraryOptions > len(libraryOptions): raise RuntimeError("List is too small: " + str(len(libraryOptions)) + " < " + str(numLibraryOptions))
    if numLibraryOptions > len(libraryOptionValues): raise RuntimeError("List is too small: " + str(len(libraryOptionValues)) + " < " + str(numLibraryOptions))
    with nogil:
        err = cyruntime.cudaLibraryLoadFromFile(<cyruntime.cudaLibrary_t*>library._pvt_ptr, fileName, cyjitOptions.data(), cyjitOptionsValues_ptr, numJitOptions, cylibraryOptions.data(), cylibraryOptionValues_ptr, numLibraryOptions)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), library)
{{endif}}

{{if 'cudaLibraryUnload' in found_functions}}

@cython.embedsignature(True)
def cudaLibraryUnload(library):
    """ Unloads a library.

    Unloads the library specified with `library`

    Parameters
    ----------
    library : :py:obj:`~.cudaLibrary_t`
        Library to unload

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaLibraryLoadData`, :py:obj:`~.cudaLibraryLoadFromFile`, :py:obj:`~.cuLibraryUnload`
    """
    cdef cyruntime.cudaLibrary_t cylibrary
    if library is None:
        plibrary = 0
    elif isinstance(library, (cudaLibrary_t,)):
        plibrary = int(library)
    else:
        plibrary = int(cudaLibrary_t(library))
    cylibrary = <cyruntime.cudaLibrary_t><void_ptr>plibrary
    with nogil:
        err = cyruntime.cudaLibraryUnload(cylibrary)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaLibraryGetKernel' in found_functions}}

@cython.embedsignature(True)
def cudaLibraryGetKernel(library, char* name):
    """ Returns a kernel handle.

    Returns in `pKernel` the handle of the kernel with name `name` located
    in library `library`. If kernel handle is not found, the call returns
    :py:obj:`~.cudaErrorSymbolNotFound`.

    Parameters
    ----------
    library : :py:obj:`~.cudaLibrary_t`
        Library to retrieve kernel from
    name : bytes
        Name of kernel to retrieve

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorSymbolNotFound`
    pKernel : :py:obj:`~.cudaKernel_t`
        Returned kernel handle

    See Also
    --------
    :py:obj:`~.cudaLibraryLoadData`, :py:obj:`~.cudaLibraryLoadFromFile`, :py:obj:`~.cudaLibraryUnload`, :py:obj:`~.cuLibraryGetKernel`
    """
    cdef cyruntime.cudaLibrary_t cylibrary
    if library is None:
        plibrary = 0
    elif isinstance(library, (cudaLibrary_t,)):
        plibrary = int(library)
    else:
        plibrary = int(cudaLibrary_t(library))
    cylibrary = <cyruntime.cudaLibrary_t><void_ptr>plibrary
    cdef cudaKernel_t pKernel = cudaKernel_t()
    with nogil:
        err = cyruntime.cudaLibraryGetKernel(<cyruntime.cudaKernel_t*>pKernel._pvt_ptr, cylibrary, name)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pKernel)
{{endif}}

{{if 'cudaLibraryGetGlobal' in found_functions}}

@cython.embedsignature(True)
def cudaLibraryGetGlobal(library, char* name):
    """ Returns a global device pointer.

    Returns in `*dptr` and `*bytes` the base pointer and size of the global
    with name `name` for the requested library `library` and the current
    device. If no global for the requested name `name` exists, the call
    returns :py:obj:`~.cudaErrorSymbolNotFound`. One of the parameters
    `dptr` or `numbytes` (not both) can be NULL in which case it is
    ignored. The returned `dptr` cannot be passed to the Symbol APIs such
    as :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`,
    :py:obj:`~.cudaGetSymbolAddress`, or :py:obj:`~.cudaGetSymbolSize`.

    Parameters
    ----------
    library : :py:obj:`~.cudaLibrary_t`
        Library to retrieve global from
    name : bytes
        Name of global to retrieve

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorSymbolNotFound` :py:obj:`~.cudaErrorDeviceUninitialized`, :py:obj:`~.cudaErrorContextIsDestroyed`
    dptr : Any
        Returned global device pointer for the requested library
    numbytes : int
        Returned global size in bytes

    See Also
    --------
    :py:obj:`~.cudaLibraryLoadData`, :py:obj:`~.cudaLibraryLoadFromFile`, :py:obj:`~.cudaLibraryUnload`, :py:obj:`~.cudaLibraryGetManaged`, :py:obj:`~.cuLibraryGetGlobal`
    """
    cdef cyruntime.cudaLibrary_t cylibrary
    if library is None:
        plibrary = 0
    elif isinstance(library, (cudaLibrary_t,)):
        plibrary = int(library)
    else:
        plibrary = int(cudaLibrary_t(library))
    cylibrary = <cyruntime.cudaLibrary_t><void_ptr>plibrary
    cdef void_ptr dptr = 0
    cdef size_t numbytes = 0
    with nogil:
        err = cyruntime.cudaLibraryGetGlobal(<void**>&dptr, &numbytes, cylibrary, name)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None)
    return (cudaError_t(err), dptr, numbytes)
{{endif}}

{{if 'cudaLibraryGetManaged' in found_functions}}

@cython.embedsignature(True)
def cudaLibraryGetManaged(library, char* name):
    """ Returns a pointer to managed memory.

    Returns in `*dptr` and `*bytes` the base pointer and size of the
    managed memory with name `name` for the requested library `library`. If
    no managed memory with the requested name `name` exists, the call
    returns :py:obj:`~.cudaErrorSymbolNotFound`. One of the parameters
    `dptr` or `numbytes` (not both) can be NULL in which case it is
    ignored. Note that managed memory for library `library` is shared
    across devices and is registered when the library is loaded. The
    returned `dptr` cannot be passed to the Symbol APIs such as
    :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`,
    :py:obj:`~.cudaGetSymbolAddress`, or :py:obj:`~.cudaGetSymbolSize`.

    Parameters
    ----------
    library : :py:obj:`~.cudaLibrary_t`
        Library to retrieve managed memory from
    name : bytes
        Name of managed memory to retrieve

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorSymbolNotFound`
    dptr : Any
        Returned pointer to the managed memory
    numbytes : int
        Returned memory size in bytes

    See Also
    --------
    :py:obj:`~.cudaLibraryLoadData`, :py:obj:`~.cudaLibraryLoadFromFile`, :py:obj:`~.cudaLibraryUnload`, :py:obj:`~.cudaLibraryGetGlobal`, :py:obj:`~.cuLibraryGetManaged`
    """
    cdef cyruntime.cudaLibrary_t cylibrary
    if library is None:
        plibrary = 0
    elif isinstance(library, (cudaLibrary_t,)):
        plibrary = int(library)
    else:
        plibrary = int(cudaLibrary_t(library))
    cylibrary = <cyruntime.cudaLibrary_t><void_ptr>plibrary
    cdef void_ptr dptr = 0
    cdef size_t numbytes = 0
    with nogil:
        err = cyruntime.cudaLibraryGetManaged(<void**>&dptr, &numbytes, cylibrary, name)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None)
    return (cudaError_t(err), dptr, numbytes)
{{endif}}

{{if 'cudaLibraryGetUnifiedFunction' in found_functions}}

@cython.embedsignature(True)
def cudaLibraryGetUnifiedFunction(library, char* symbol):
    """ Returns a pointer to a unified function.

    Returns in `*fptr` the function pointer to a unified function denoted
    by `symbol`. If no unified function with name `symbol` exists, the call
    returns :py:obj:`~.cudaErrorSymbolNotFound`. If there is no device with
    attribute :py:obj:`~.cudaDeviceProp.unifiedFunctionPointers` present in
    the system, the call may return :py:obj:`~.cudaErrorSymbolNotFound`.

    Parameters
    ----------
    library : :py:obj:`~.cudaLibrary_t`
        Library to retrieve function pointer memory from
    symbol : bytes
        Name of function pointer to retrieve

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorSymbolNotFound`
    fptr : Any
        Returned pointer to a unified function

    See Also
    --------
    :py:obj:`~.cudaLibraryLoadData`, :py:obj:`~.cudaLibraryLoadFromFile`, :py:obj:`~.cudaLibraryUnload`, :py:obj:`~.cuLibraryGetUnifiedFunction`
    """
    cdef cyruntime.cudaLibrary_t cylibrary
    if library is None:
        plibrary = 0
    elif isinstance(library, (cudaLibrary_t,)):
        plibrary = int(library)
    else:
        plibrary = int(cudaLibrary_t(library))
    cylibrary = <cyruntime.cudaLibrary_t><void_ptr>plibrary
    cdef void_ptr fptr = 0
    with nogil:
        err = cyruntime.cudaLibraryGetUnifiedFunction(<void**>&fptr, cylibrary, symbol)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), fptr)
{{endif}}

{{if 'cudaLibraryGetKernelCount' in found_functions}}

@cython.embedsignature(True)
def cudaLibraryGetKernelCount(lib):
    """ Returns the number of kernels within a library.

    Returns in `count` the number of kernels in `lib`.

    Parameters
    ----------
    lib : :py:obj:`~.cudaLibrary_t`
        Library to query

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`
    count : unsigned int
        Number of kernels found within the library

    See Also
    --------
    :py:obj:`~.cudaLibraryEnumerateKernels`, :py:obj:`~.cudaLibraryLoadFromFile`, :py:obj:`~.cudaLibraryLoadData`, :py:obj:`~.cuLibraryGetKernelCount`
    """
    cdef cyruntime.cudaLibrary_t cylib
    if lib is None:
        plib = 0
    elif isinstance(lib, (cudaLibrary_t,)):
        plib = int(lib)
    else:
        plib = int(cudaLibrary_t(lib))
    cylib = <cyruntime.cudaLibrary_t><void_ptr>plib
    cdef unsigned int count = 0
    with nogil:
        err = cyruntime.cudaLibraryGetKernelCount(&count, cylib)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), count)
{{endif}}

{{if 'cudaLibraryEnumerateKernels' in found_functions}}

@cython.embedsignature(True)
def cudaLibraryEnumerateKernels(unsigned int numKernels, lib):
    """ Retrieve the kernel handles within a library.

    Returns in `kernels` a maximum number of `numKernels` kernel handles
    within `lib`. The returned kernel handle becomes invalid when the
    library is unloaded.

    Parameters
    ----------
    numKernels : unsigned int
        Maximum number of kernel handles may be returned to the buffer
    lib : :py:obj:`~.cudaLibrary_t`
        Library to query from

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`
    kernels : list[:py:obj:`~.cudaKernel_t`]
        Buffer where the kernel handles are returned to

    See Also
    --------
    :py:obj:`~.cudaLibraryGetKernelCount`, :py:obj:`~.cuLibraryEnumerateKernels`
    """
    cdef cyruntime.cudaLibrary_t cylib
    if lib is None:
        plib = 0
    elif isinstance(lib, (cudaLibrary_t,)):
        plib = int(lib)
    else:
        plib = int(cudaLibrary_t(lib))
    cylib = <cyruntime.cudaLibrary_t><void_ptr>plib
    cdef cyruntime.cudaKernel_t* cykernels = NULL
    pykernels = []
    if numKernels != 0:
        cykernels = <cyruntime.cudaKernel_t*>calloc(numKernels, sizeof(cyruntime.cudaKernel_t))
        if cykernels is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(numKernels) + 'x' + str(sizeof(cyruntime.cudaKernel_t)))
    with nogil:
        err = cyruntime.cudaLibraryEnumerateKernels(cykernels, numKernels, cylib)
    if cudaError_t(err) == cudaError_t(0):
        pykernels = [cudaKernel_t(init_value=<void_ptr>cykernels[idx]) for idx in range(numKernels)]
    if cykernels is not NULL:
        free(cykernels)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pykernels)
{{endif}}

{{if 'cudaKernelSetAttributeForDevice' in found_functions}}

@cython.embedsignature(True)
def cudaKernelSetAttributeForDevice(kernel, attr not None : cudaFuncAttribute, int value, int device):
    """ Sets information about a kernel.

    This call sets the value of a specified attribute `attr` on the kernel
    `kernel` for the requested device `device` to an integer value
    specified by `value`. This function returns :py:obj:`~.cudaSuccess` if
    the new value of the attribute could be successfully set. If the set
    fails, this call will return an error. Not all attributes can have
    values set. Attempting to set a value on a read-only attribute will
    result in an error (:py:obj:`~.cudaErrorInvalidValue`)

    Note that attributes set using :py:obj:`~.cudaFuncSetAttribute()` will
    override the attribute set by this API irrespective of whether the call
    to :py:obj:`~.cudaFuncSetAttribute()` is made before or after this API
    call. Because of this and the stricter locking requirements mentioned
    below it is suggested that this call be used during the initialization
    path and not on each thread accessing `kernel` such as on kernel
    launches or on the critical path.

    Valid values for `attr` are:

    - :py:obj:`~.cudaFuncAttributeMaxDynamicSharedMemorySize` - The
      requested maximum size in bytes of dynamically-allocated shared
      memory. The sum of this value and the function attribute
      :py:obj:`~.sharedSizeBytes` cannot exceed the device attribute
      :py:obj:`~.cudaDevAttrMaxSharedMemoryPerBlockOptin`. The maximal size
      of requestable dynamic shared memory may differ by GPU architecture.

    - :py:obj:`~.cudaFuncAttributePreferredSharedMemoryCarveout` - On
      devices where the L1 cache and shared memory use the same hardware
      resources, this sets the shared memory carveout preference, in
      percent of the total shared memory. See
      :py:obj:`~.cudaDevAttrMaxSharedMemoryPerMultiprocessor`. This is only
      a hint, and the driver can choose a different ratio if required to
      execute the function.

    - :py:obj:`~.cudaFuncAttributeRequiredClusterWidth`: The required
      cluster width in blocks. The width, height, and depth values must
      either all be 0 or all be positive. The validity of the cluster
      dimensions is checked at launch time. If the value is set during
      compile time, it cannot be set at runtime. Setting it at runtime will
      return cudaErrorNotPermitted.

    - :py:obj:`~.cudaFuncAttributeRequiredClusterHeight`: The required
      cluster height in blocks. The width, height, and depth values must
      either all be 0 or all be positive. The validity of the cluster
      dimensions is checked at launch time. If the value is set during
      compile time, it cannot be set at runtime. Setting it at runtime will
      return cudaErrorNotPermitted.

    - :py:obj:`~.cudaFuncAttributeRequiredClusterDepth`: The required
      cluster depth in blocks. The width, height, and depth values must
      either all be 0 or all be positive. The validity of the cluster
      dimensions is checked at launch time. If the value is set during
      compile time, it cannot be set at runtime. Setting it at runtime will
      return cudaErrorNotPermitted.

    - :py:obj:`~.cudaFuncAttributeNonPortableClusterSizeAllowed`: Indicates
      whether the function can be launched with non-portable cluster size.
      1 is allowed, 0 is disallowed.

    - :py:obj:`~.cudaFuncAttributeClusterSchedulingPolicyPreference`: The
      block scheduling policy of a function. The value type is
      cudaClusterSchedulingPolicy.

    Parameters
    ----------
    kernel : :py:obj:`~.cudaKernel_t`
        Kernel to set attribute of
    attr : :py:obj:`~.cudaFuncAttribute`
        Attribute requested
    value : int
        Value to set
    device : int
        Device to set attribute of

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDeviceFunction`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaLibraryLoadData`, :py:obj:`~.cudaLibraryLoadFromFile`, :py:obj:`~.cudaLibraryUnload`, :py:obj:`~.cudaLibraryGetKernel`, :py:obj:`~.cudaLaunchKernel`, :py:obj:`~.cudaFuncSetAttribute`, :py:obj:`~.cuKernelSetAttribute`

    Notes
    -----
    The API has stricter locking requirements in comparison to its legacy counterpart :py:obj:`~.cudaFuncSetAttribute()` due to device-wide semantics. If multiple threads are trying to set the same attribute on the same device simultaneously, the attribute setting will depend on the interleavings chosen by the OS scheduler and memory consistency.
    """
    cdef cyruntime.cudaKernel_t cykernel
    if kernel is None:
        pkernel = 0
    elif isinstance(kernel, (cudaKernel_t,)):
        pkernel = int(kernel)
    else:
        pkernel = int(cudaKernel_t(kernel))
    cykernel = <cyruntime.cudaKernel_t><void_ptr>pkernel
    cdef cyruntime.cudaFuncAttribute cyattr = int(attr)
    with nogil:
        err = cyruntime.cudaKernelSetAttributeForDevice(cykernel, cyattr, value, device)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaDeviceGetDevResource' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGetDevResource(int device, typename not None : cudaDevResourceType):
    """ Get device resources.

    Get the `typename` resources available to the `device`. This may often
    be the starting point for further partitioning or configuring of
    resources.

    Note: The API is not supported on 32-bit platforms.

    Parameters
    ----------
    device : int
        Device to get resource for
    typename : :py:obj:`~.cudaDevResourceType`
        Type of resource to retrieve

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotPermitted`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidResourceType`, :py:obj:`~.cudaErrorNotSupported`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`
    resource : :py:obj:`~.cudaDevResource`
        Output pointer to a cudaDevResource structure

    See Also
    --------
    :py:obj:`~.cuDeviceGetDevResource`, :py:obj:`~.cudaExecutionCtxGetDevResource`, :py:obj:`~.cudaDevSmResourceSplit`, :py:obj:`~.cudaDevResourceGenerateDesc`
    """
    cdef cudaDevResource resource = cudaDevResource()
    cdef cyruntime.cudaDevResourceType cytypename = int(typename)
    with nogil:
        err = cyruntime.cudaDeviceGetDevResource(device, <cyruntime.cudaDevResource*>resource._pvt_ptr, cytypename)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), resource)
{{endif}}

{{if 'cudaDevSmResourceSplitByCount' in found_functions}}

@cython.embedsignature(True)
def cudaDevSmResourceSplitByCount(unsigned int nbGroups, input_ : Optional[cudaDevResource], unsigned int flags, unsigned int minCount):
    """ Splits `cudaDevResourceTypeSm` resources.

    Splits `cudaDevResourceTypeSm` resources into `nbGroups`, adhering to
    the minimum SM count specified in `minCount` and the usage flags in
    `flags`. If `result` is NULL, the API simulates a split and provides
    the amount of groups that would be created in `nbGroups`. Otherwise,
    `nbGroups` must point to the amount of elements in `result` and on
    return, the API will overwrite `nbGroups` with the amount actually
    created. The groups are written to the array in `result`. `nbGroups`
    can be less than the total amount if a smaller number of groups is
    needed.

    This API is used to spatially partition the input resource. The input
    resource needs to come from one of
    :py:obj:`~.cudaDeviceGetDevResource`, or
    :py:obj:`~.cudaExecutionCtxGetDevResource`. A limitation of the API is
    that the output results cannot be split again without first creating a
    descriptor and a green context with that descriptor.

    When creating the groups, the API will take into account the
    performance and functional characteristics of the input resource, and
    guarantee a split that will create a disjoint set of symmetrical
    partitions. This may lead to fewer groups created than purely dividing
    the total SM count by the `minCount` due to cluster requirements or
    alignment and granularity requirements for the minCount. These
    requirements can be queried with :py:obj:`~.cudaDeviceGetDevResource`,
    or :py:obj:`~.cudaExecutionCtxGetDevResource` for
    :py:obj:`~.cudaDevResourceTypeSm`, using the `minSmPartitionSize` and
    `smCoscheduledAlignment` fields to determine minimum partition size and
    alignment granularity, respectively.

    The `remainder` set does not have the same functional or performance
    guarantees as the groups in `result`. Its use should be carefully
    planned and future partitions of the `remainder` set are discouraged.

    The following flags are supported:

    - `cudaDevSmResourceSplitIgnoreSmCoscheduling` : Lower the minimum SM
      count and alignment, and treat each SM independent of its hierarchy.
      This allows more fine grained partitions but at the cost of advanced
      features (such as large clusters on compute capability 9.0+).

    - `cudaDevSmResourceSplitMaxPotentialClusterSize` : Compute Capability
      9.0+ only. Attempt to create groups that may allow for maximally
      sized thread clusters. This can be queried post green context
      creation using :py:obj:`~.cudaOccupancyMaxPotentialClusterSize`.

    A successful API call must either have:

    - A valid array of `result` pointers of size passed in `nbGroups`, with
      `input` of type `cudaDevResourceTypeSm`. Value of `minCount` must be
      between 0 and the SM count specified in `input`. `remaining` may be
      NULL.

    - NULL passed in for `result`, with a valid integer pointer in
      `nbGroups` and `input` of type `cudaDevResourceTypeSm`. Value of
      `minCount` must be between 0 and the SM count specified in `input`.
      `remaining` may be NULL. This queries the number of groups that would
      be created by the API.

    Note: The API is not supported on 32-bit platforms.

    Parameters
    ----------
    nbGroups : unsigned int
        This is a pointer, specifying the number of groups that would be or
        should be created as described below.
    input : :py:obj:`~.cudaDevResource`
        Input SM resource to be split. Must be a valid `None` resource.
    flags : unsigned int
        Flags specifying how these partitions are used or which constraints
        to abide by when splitting the input. Zero is valid for default
        behavior.
    minCount : unsigned int
        Minimum number of SMs required

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotPermitted`, :py:obj:`~.cudaErrorInvalidResourceType`, :py:obj:`~.cudaErrorInvalidResourceConfiguration`, :py:obj:`~.cudaErrorNotSupported`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`
    result : list[:py:obj:`~.cudaDevResource`]
        Output array of `cudaDevResource` resources. Can be NULL to query
        the number of groups.
    nbGroups : unsigned int
        This is a pointer, specifying the number of groups that would be or
        should be created as described below.
    remaining : :py:obj:`~.cudaDevResource`
        If the input resource cannot be cleanly split among `nbGroups`, the
        remaining is placed in here. Can be ommitted (NULL) if the user
        does not need the remaining set.

    See Also
    --------
    :py:obj:`~.cuDevSmResourceSplitByCount`, :py:obj:`~.cudaDeviceGetDevResource`, :py:obj:`~.cudaExecutionCtxGetDevResource`, :py:obj:`~.cudaDevResourceGenerateDesc`
    """
    cdef cyruntime.cudaDevResource* cyresult = NULL
    pyresult = [cudaDevResource() for idx in range(nbGroups)]
    if nbGroups != 0:
        cyresult = <cyruntime.cudaDevResource*>calloc(nbGroups, sizeof(cyruntime.cudaDevResource))
        if cyresult is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(nbGroups) + 'x' + str(sizeof(cyruntime.cudaDevResource)))
    cdef unsigned int cynbGroups = nbGroups
    cdef cyruntime.cudaDevResource* cyinput__ptr = input_._pvt_ptr if input_ is not None else NULL
    cdef cudaDevResource remaining = cudaDevResource()
    with nogil:
        err = cyruntime.cudaDevSmResourceSplitByCount(cyresult, &cynbGroups, cyinput__ptr, <cyruntime.cudaDevResource*>remaining._pvt_ptr, flags, minCount)
    if cudaError_t(err) == cudaError_t(0):
        for idx in range(nbGroups):
            string.memcpy((<cudaDevResource>pyresult[idx])._pvt_ptr, &cyresult[idx], sizeof(cyruntime.cudaDevResource))
    if cyresult is not NULL:
        free(cyresult)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None, None)
    return (cudaError_t(err), pyresult, cynbGroups, remaining)
{{endif}}

{{if 'cudaDevSmResourceSplit' in found_functions}}

@cython.embedsignature(True)
def cudaDevSmResourceSplit(unsigned int nbGroups, input_ : Optional[cudaDevResource], unsigned int flags, groupParams : Optional[cudaDevSmResourceGroupParams]):
    """ Splits a `cudaDevResourceTypeSm` resource into structured groups.

    This API will split a resource of :py:obj:`~.cudaDevResourceTypeSm`
    into `nbGroups` structured device resource groups (the `result` array),
    as well as an optional `remainder`, according to a set of requirements
    specified in the `groupParams` array. The term structured is a trait
    that specifies the `result` has SMs that are co-scheduled together.
    This co-scheduling can be specified via the `coscheduledSmCount` field
    of the `groupParams` structure, while the `smCount` will specify how
    many SMs are required in total for that result. The remainder is always
    unstructured, it does not have any set guarantees with respect to co-
    scheduling and those properties will need to either be queried via the
    occupancy set of APIs or further split into structured groups by this
    API.

    The API has a discovery mode for use cases where it is difficult to
    know ahead of time what the SM count should be. Discovery happens when
    the `smCount` field of a given `groupParams` array entry is set to 0 -
    the smCount will be filled in by the API with the derived SM count
    according to the provided `groupParams` fields and constraints.
    Discovery can be used with both a valid result array and with a NULL
    `result` pointer value. The latter is useful in situations where the
    smCount will end up being zero, which is an invalid value to create a
    result entry with, but allowed for discovery purposes when the `result`
    is NULL.

    The `groupParams` array is evaluated from index 0 to `nbGroups` - 1.
    For each index in the `groupParams` array, the API will evaluate which
    SMs may be a good fit based on constraints and assign those SMs to
    `result`. This evaluation order is important to consider when using
    discovery mode, as it helps discover the remaining SMs.

    For a valid call:

    - `result` should point to a `cudaDevResource` array of size
      `nbGroups`, or alternatively, may be NULL, if the developer wishes
      for only the groupParams entries to be updated

    - `input` should be a valid :py:obj:`~.cudaDevResourceTypeSm` resource
      that originates from querying the execution context, or device.

    - The `remainder` group may be NULL.

    - There are no API `flags` at this time, so the value passed in should
      be 0.

    - A :py:obj:`~.cudaDevSmResourceGroupParams` array of size `nbGroups`.
      Each entry must be zero-initialized.

      - `smCount:` must be either 0 or in the range of [2,inputSmCount]
        where inputSmCount is the amount of SMs the `input` resource has.
        `smCount` must be a multiple of 2, as well as a multiple of
        `coscheduledSmCount`. When assigning SMs to a group (and if results
        are expected by having the `result` parameter set), `smCount`
        cannot end up with 0 or a value less than `coscheduledSmCount`
        otherwise :py:obj:`~.cudaErrorInvalidResourceConfiguration` will be
        returned.

      - `coscheduledSmCount:` allows grouping SMs together in order to be
        able to launch clusters on Compute Architecture 9.0+. The default
        value may be queried from the devices
        :py:obj:`~.cudaDevResourceTypeSm` resource (8 on Compute
        Architecture 9.0+ and 2 otherwise). The maximum is 32 on Compute
        Architecture 9.0+ and 2 otherwise.

      - `preferredCoscheduledSmCount:` Attempts to merge
        `coscheduledSmCount` groups into larger groups, in order to make
        use of `preferredClusterDimensions` on Compute Architecture 10.0+.
        The default value is set to `coscheduledSmCount`.

      - `flags:`

    - `cudaDevSmResourceGroupBackfill:` lets `smCount` be a non-multiple of
    `coscheduledSmCount`, filling the difference between SM count and
    already assigned co-scheduled groupings with other SMs. This lets any
    resulting group behave similar to the `remainder` group for example.

    Example params and their effect:

    A groupParams array element is defined in the following order:

    **View CUDA Toolkit Documentation for a C++ code example**

    **View CUDA Toolkit Documentation for a C++ code example**

    **View CUDA Toolkit Documentation for a C++ code example**

    **View CUDA Toolkit Documentation for a C++ code example**

    The difference between a catch-all param group as the last entry and
    the remainder is in two aspects:

    - The remainder may be NULL / _TYPE_INVALID (if there are no SMs
      remaining), while a result group must always be valid.

    - The remainder does not have a structure, while the result group will
      always need to adhere to a structure of coscheduledSmCount (even if
      its just 2), and therefore must always have enough coscheduled SMs to
      cover that requirement (even with the
      `cudaDevSmResourceGroupBackfill` flag enabled).

    Splitting an input into N groups, can be accomplished by repeatedly
    splitting off 1 group and re-splitting the remainder (a bisect
    operation). However, it's recommended to accomplish this with a single
    call wherever possible.

    Parameters
    ----------
    nbGroups : unsigned int
        Specifies the number of groups in `result` and `groupParams`
    input : :py:obj:`~.cudaDevResource`
        Input SM resource to be split. Must be a valid
        `cudaDevResourceTypeSm` resource.
    flags : unsigned int
        Flags specifying how the API should behave. The value should be 0
        for now.
    groupParams : :py:obj:`~.cudaDevSmResourceGroupParams`
        Description of how the SMs should be split and assigned to the
        corresponding result entry.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotPermitted`, :py:obj:`~.cudaErrorInvalidResourceType`, :py:obj:`~.cudaErrorInvalidResourceConfiguration`, :py:obj:`~.cudaErrorNotSupported`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`
    result : list[:py:obj:`~.cudaDevResource`]
        Output array of `cudaDevResource` resources. Can be NULL, alongside
        an smCount of 0, for discovery purpose.
    remainder : :py:obj:`~.cudaDevResource`
        If splitting the input resource leaves any SMs, the remainder is
        placed in here.

    See Also
    --------
    :py:obj:`~.cuDevSmResourceSplit`, :py:obj:`~.cudaDeviceGetDevResource`, :py:obj:`~.cudaExecutionCtxGetDevResource`, :py:obj:`~.cudaDevResourceGenerateDesc`
    """
    cdef cyruntime.cudaDevResource* cyresult = NULL
    pyresult = [cudaDevResource() for idx in range(nbGroups)]
    if nbGroups != 0:
        cyresult = <cyruntime.cudaDevResource*>calloc(nbGroups, sizeof(cyruntime.cudaDevResource))
        if cyresult is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(nbGroups) + 'x' + str(sizeof(cyruntime.cudaDevResource)))
    cdef cyruntime.cudaDevResource* cyinput__ptr = input_._pvt_ptr if input_ is not None else NULL
    cdef cudaDevResource remainder = cudaDevResource()
    cdef cyruntime.cudaDevSmResourceGroupParams* cygroupParams_ptr = groupParams._pvt_ptr if groupParams is not None else NULL
    with nogil:
        err = cyruntime.cudaDevSmResourceSplit(cyresult, nbGroups, cyinput__ptr, <cyruntime.cudaDevResource*>remainder._pvt_ptr, flags, cygroupParams_ptr)
    if cudaError_t(err) == cudaError_t(0):
        for idx in range(nbGroups):
            string.memcpy((<cudaDevResource>pyresult[idx])._pvt_ptr, &cyresult[idx], sizeof(cyruntime.cudaDevResource))
    if cyresult is not NULL:
        free(cyresult)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None)
    return (cudaError_t(err), pyresult, remainder)
{{endif}}

{{if 'cudaDevResourceGenerateDesc' in found_functions}}

@cython.embedsignature(True)
def cudaDevResourceGenerateDesc(resources : Optional[tuple[cudaDevResource] | list[cudaDevResource]], unsigned int nbResources):
    """ Generate a resource descriptor.

    Generates a single resource descriptor with the set of resources
    specified in `resources`. The generated resource descriptor is
    necessary for the creation of green contexts via the
    :py:obj:`~.cudaGreenCtxCreate` API. Resources of the same type can be
    passed in, provided they meet the requirements as noted below.

    A successful API call must have:

    - A valid output pointer for the `phDesc` descriptor as well as a valid
      array of `resources` pointers, with the array size passed in
      `nbResources`. If multiple resources are provided in `resources`, the
      device they came from must be the same, otherwise
      :py:obj:`~.cudaErrorInvalidResourceConfiguration` is returned. If
      multiple resources are provided in `resources` and they are of type
      :py:obj:`~.cudaDevResourceTypeSm`, they must be outputs (whether
      `result` or `remaining`) from the same split API instance and have
      the same smCoscheduledAlignment values, otherwise
      :py:obj:`~.cudaErrorInvalidResourceConfiguration` is returned.

    Note: The API is not supported on 32-bit platforms.

    Parameters
    ----------
    resources : list[:py:obj:`~.cudaDevResource`]
        Array of resources to be included in the descriptor
    nbResources : unsigned int
        Number of resources passed in `resources`

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotPermitted`, :py:obj:`~.cudaErrorInvalidResourceType`, :py:obj:`~.cudaErrorInvalidResourceConfiguration`, :py:obj:`~.cudaErrorNotSupported`, :py:obj:`~.cudaErrorOutOfMemory`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`
    phDesc : :py:obj:`~.cudaDevResourceDesc_t`
        Output descriptor

    See Also
    --------
    :py:obj:`~.cuDevResourceGenerateDesc`, :py:obj:`~.cudaDeviceGetDevResource`, :py:obj:`~.cudaExecutionCtxGetDevResource`, :py:obj:`~.cudaDevSmResourceSplit`, :py:obj:`~.cudaGreenCtxCreate`
    """
    resources = [] if resources is None else resources
    if not all(isinstance(_x, (cudaDevResource,)) for _x in resources):
        raise TypeError("Argument 'resources' is not instance of type (expected tuple[cyruntime.cudaDevResource,] or list[cyruntime.cudaDevResource,]")
    cdef cudaDevResourceDesc_t phDesc = cudaDevResourceDesc_t()
    cdef cyruntime.cudaDevResource* cyresources = NULL
    if len(resources) > 1:
        cyresources = <cyruntime.cudaDevResource*> calloc(len(resources), sizeof(cyruntime.cudaDevResource))
        if cyresources is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(resources)) + 'x' + str(sizeof(cyruntime.cudaDevResource)))
        for idx in range(len(resources)):
            string.memcpy(&cyresources[idx], (<cudaDevResource>resources[idx])._pvt_ptr, sizeof(cyruntime.cudaDevResource))
    elif len(resources) == 1:
        cyresources = (<cudaDevResource>resources[0])._pvt_ptr
    with nogil:
        err = cyruntime.cudaDevResourceGenerateDesc(<cyruntime.cudaDevResourceDesc_t*>phDesc._pvt_ptr, cyresources, nbResources)
    if len(resources) > 1 and cyresources is not NULL:
        free(cyresources)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), phDesc)
{{endif}}

{{if 'cudaGreenCtxCreate' in found_functions}}

@cython.embedsignature(True)
def cudaGreenCtxCreate(desc, int device, unsigned int flags):
    """ Creates a green context with a specified set of resources.

    This API creates a green context with the resources specified in the
    descriptor `desc` and returns it in the handle represented by `phCtx`.

    This API retains the devices primary context for the lifetime of the
    green context. The primary context will be released when the green
    context is destroyed. To avoid the overhead of repeated initialization
    and teardown, it is recommended to explicitly initialize the device's
    primary context ahead of time using :py:obj:`~.cudaInitDevice`. This
    ensures that the primary context remains initialized throughout the
    programs lifetime, minimizing overhead during green context creation
    and destruction.

    The API does not create a default stream for the green context.
    Developers are expected to create streams explicitly using
    :py:obj:`~.cudaExecutionCtxStreamCreate` to submit work to the green
    context.

    Note: The API is not supported on 32-bit platforms.

    Parameters
    ----------
    desc : :py:obj:`~.cudaDevResourceDesc_t`
        Descriptor generated via :py:obj:`~.cudaDevResourceGenerateDesc`
        which contains the set of resources to be used
    device : int
        Device on which to create the green context.
    flags : unsigned int
        Green context creation flags. Must be 0, currently reserved for
        future use.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorNotPermitted`, :py:obj:`~.cudaErrorNotSupported`, :py:obj:`~.cudaErrorOutOfMemory`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`
    phCtx : :py:obj:`~.cudaExecutionContext_t`
        Pointer for the output handle to the green context

    See Also
    --------
    :py:obj:`~.cudaDeviceGetDevResource`, :py:obj:`~.cudaDevSmResourceSplit`, :py:obj:`~.cudaDevResourceGenerateDesc`, :py:obj:`~.cudaExecutionCtxGetDevResource`, :py:obj:`~.cudaExecutionCtxDestroy`, :py:obj:`~.cudaInitDevice`, :py:obj:`~.cudaExecutionCtxStreamCreate`
    """
    cdef cyruntime.cudaDevResourceDesc_t cydesc
    if desc is None:
        pdesc = 0
    elif isinstance(desc, (cudaDevResourceDesc_t,)):
        pdesc = int(desc)
    else:
        pdesc = int(cudaDevResourceDesc_t(desc))
    cydesc = <cyruntime.cudaDevResourceDesc_t><void_ptr>pdesc
    cdef cudaExecutionContext_t phCtx = cudaExecutionContext_t()
    with nogil:
        err = cyruntime.cudaGreenCtxCreate(<cyruntime.cudaExecutionContext_t*>phCtx._pvt_ptr, cydesc, device, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), phCtx)
{{endif}}

{{if 'cudaExecutionCtxDestroy' in found_functions}}

@cython.embedsignature(True)
def cudaExecutionCtxDestroy(ctx):
    """ Destroy a execution context.

    Destroys the specified execution context `ctx`. It is the
    responsibility of the caller to ensure that no API call issues using
    `ctx` while :py:obj:`~.cudaExecutionCtxDestroy()` is executing or
    subsequently.

    If `ctx` is a green context, any resources provisioned for it (that
    were initially available via the resource descriptor) are released as
    well.

    The API does not destroy streams created via
    :py:obj:`~.cudaExecutionCtxStreamCreate`. Users are expected to destroy
    these streams explicitly using :py:obj:`~.cudaStreamDestroy` to avoid
    resource leaks. Once the execution context is destroyed, any subsequent
    API calls involving these streams will return
    :py:obj:`~.cudaErrorStreamDetached` with the exception of the following
    APIs:

    - :py:obj:`~.cudaStreamDestroy`. Note this is only supported on CUDA
      drivers 13.1 and above.

    Additionally, the API will invalidate all active captures on these
    streams.

    Passing in a `ctx` that was not explicitly created via CUDA Runtime
    APIs is not allowed and will result in undefined behavior.

    Parameters
    ----------
    ctx : :py:obj:`~.cudaExecutionContext_t`
        Execution context to destroy (required parameter, see note below)

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotPermitted`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`

    See Also
    --------
    :py:obj:`~.cudaGreenCtxCreate`
    """
    cdef cyruntime.cudaExecutionContext_t cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (cudaExecutionContext_t,)):
        pctx = int(ctx)
    else:
        pctx = int(cudaExecutionContext_t(ctx))
    cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>pctx
    with nogil:
        err = cyruntime.cudaExecutionCtxDestroy(cyctx)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaExecutionCtxGetDevResource' in found_functions}}

@cython.embedsignature(True)
def cudaExecutionCtxGetDevResource(ctx, typename not None : cudaDevResourceType):
    """ Get context resources.

    Get the `typename` resources available to context represented by `ctx`.

    Note: The API is not supported on 32-bit platforms.

    Parameters
    ----------
    ctx : :py:obj:`~.cudaExecutionContext_t`
        Execution context to get resource for (required parameter, see note
        below)
    typename : :py:obj:`~.cudaDevResourceType`
        Type of resource to retrieve

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotSupported`, :py:obj:`~.cudaErrorNotPermitted`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`
    resource : :py:obj:`~.cudaDevResource`
        Output pointer to a cudaDevResource structure

    See Also
    --------
    :py:obj:`~.cudaDeviceGetDevResource`, :py:obj:`~.cudaDevSmResourceSplit`, :py:obj:`~.cudaDevResourceGenerateDesc`, :py:obj:`~.cudaGreenCtxCreate`
    """
    cdef cyruntime.cudaExecutionContext_t cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (cudaExecutionContext_t,)):
        pctx = int(ctx)
    else:
        pctx = int(cudaExecutionContext_t(ctx))
    cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>pctx
    cdef cudaDevResource resource = cudaDevResource()
    cdef cyruntime.cudaDevResourceType cytypename = int(typename)
    with nogil:
        err = cyruntime.cudaExecutionCtxGetDevResource(cyctx, <cyruntime.cudaDevResource*>resource._pvt_ptr, cytypename)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), resource)
{{endif}}

{{if 'cudaExecutionCtxGetDevice' in found_functions}}

@cython.embedsignature(True)
def cudaExecutionCtxGetDevice(ctx):
    """ Returns the device handle for the execution context.

    Returns in `*device` the handle of the specified execution context's
    device. The execution context should not be NULL.

    Parameters
    ----------
    ctx : :py:obj:`~.cudaExecutionContext_t`
        Execution context for which to obtain the device (required
        parameter, see note below)

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotPermitted`
    device : int
        Returned device handle for the specified execution context

    See Also
    --------
    :py:obj:`~.cudaGreenCtxCreate`, :py:obj:`~.cudaExecutionCtxDestroy`, :py:obj:`~.cuCtxGetDevice`
    """
    cdef cyruntime.cudaExecutionContext_t cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (cudaExecutionContext_t,)):
        pctx = int(ctx)
    else:
        pctx = int(cudaExecutionContext_t(ctx))
    cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>pctx
    cdef int device = 0
    with nogil:
        err = cyruntime.cudaExecutionCtxGetDevice(&device, cyctx)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), device)
{{endif}}

{{if 'cudaExecutionCtxGetId' in found_functions}}

@cython.embedsignature(True)
def cudaExecutionCtxGetId(ctx):
    """ Returns the unique Id associated with the execution context supplied.

    Returns in `ctxId` the unique Id which is associated with a given
    context. The Id is unique for the life of the program for this instance
    of CUDA. The execution context should not be NULL.

    Parameters
    ----------
    ctx : :py:obj:`~.cudaExecutionContext_t`
        Context for which to obtain the Id (required parameter, see note
        below)

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotPermitted`
    ctxId : unsigned long long
        Pointer to store the Id of the context

    See Also
    --------
    :py:obj:`~.cudaGreenCtxCreate`, :py:obj:`~.cudaExecutionCtxDestroy`, :py:obj:`~.cudaExecutionCtxGetDevice`, :py:obj:`~.cuCtxGetId`
    """
    cdef cyruntime.cudaExecutionContext_t cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (cudaExecutionContext_t,)):
        pctx = int(ctx)
    else:
        pctx = int(cudaExecutionContext_t(ctx))
    cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>pctx
    cdef unsigned long long ctxId = 0
    with nogil:
        err = cyruntime.cudaExecutionCtxGetId(cyctx, &ctxId)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), ctxId)
{{endif}}

{{if 'cudaExecutionCtxStreamCreate' in found_functions}}

@cython.embedsignature(True)
def cudaExecutionCtxStreamCreate(ctx, unsigned int flags, int priority):
    """ Creates a stream and initializes it for the given execution context.

    The API creates a CUDA stream with the specified `flags` and
    `priority`, initializing it with resources as defined at the time of
    creating the specified `ctx`. Additionally, the API also enables work
    submitted to to the stream to be tracked under `ctx`.

    The supported values for `flags` are:

    - :py:obj:`~.cudaStreamDefault`: Default stream creation flag. This
      would be :py:obj:`~.cudaStreamNonBlocking` for streams created on a
      green context.

    - :py:obj:`~.cudaStreamNonBlocking`: Specifies that work running in the
      created stream may run concurrently with work in stream 0 (the NULL
      stream), and that the created stream should perform no implicit
      synchronization with stream 0

    Specifying `priority` affects the scheduling priority of work in the
    stream. Priorities provide a hint to preferentially run work with
    higher priority when possible, but do not preempt already-running work
    or provide any other functional guarantee on execution order.
    `priority` follows a convention where lower numbers represent higher
    priorities. '0' represents default priority. The range of meaningful
    numerical priorities can be queried using
    :py:obj:`~.cudaDeviceGetStreamPriorityRange`. If the specified priority
    is outside the numerical range returned by
    :py:obj:`~.cudaDeviceGetStreamPriorityRange`, it will automatically be
    clamped to the lowest or the highest number in the range.

    Parameters
    ----------
    ctx : :py:obj:`~.cudaExecutionContext_t`
        Execution context to initialize the stream with (required
        parameter, see note below)
    flags : unsigned int
        Flags for stream creation
    priority : int
        Stream priority

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorNotPermitted`, :py:obj:`~.cudaErrorOutOfMemory`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`
    phStream : :py:obj:`~.cudaStream_t`
        Returned stream handle

    See Also
    --------
    :py:obj:`~.cudaStreamDestroy`, :py:obj:`~.cudaGreenCtxCreate`, :py:obj:`~.cudaDeviceGetStreamPriorityRange`, :py:obj:`~.cudaStreamGetFlags`, :py:obj:`~.cudaStreamGetPriority`, :py:obj:`~.cudaStreamGetDevice`, :py:obj:`~.cudaStreamGetDevResource`, :py:obj:`~.cudaLaunchKernel`, :py:obj:`~.cudaEventRecord`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cudaStreamQuery`, :py:obj:`~.cudaStreamSynchronize`, :py:obj:`~.cudaStreamAddCallback`

    Notes
    -----
    In the current implementation, only compute kernels launched in priority streams are affected by the stream's priority. Stream priorities have no effect on host-to-device and device-to-host memory operations.
    """
    cdef cyruntime.cudaExecutionContext_t cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (cudaExecutionContext_t,)):
        pctx = int(ctx)
    else:
        pctx = int(cudaExecutionContext_t(ctx))
    cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>pctx
    cdef cudaStream_t phStream = cudaStream_t()
    with nogil:
        err = cyruntime.cudaExecutionCtxStreamCreate(<cyruntime.cudaStream_t*>phStream._pvt_ptr, cyctx, flags, priority)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), phStream)
{{endif}}

{{if 'cudaExecutionCtxSynchronize' in found_functions}}

@cython.embedsignature(True)
def cudaExecutionCtxSynchronize(ctx):
    """ Block for the specified execution context's tasks to complete.

    Blocks until the specified execution context has completed all
    preceding requested tasks. If the specified execution context is the
    device (primary) context obtained via
    :py:obj:`~.cudaDeviceGetExecutionCtx`, green contexts that have been
    created on the device will also be synchronized.

    The API returns an error if one of the preceding tasks failed.

    Parameters
    ----------
    ctx : :py:obj:`~.cudaExecutionContext_t`
        Execution context to synchronize (required parameter, see note
        below)

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorDeviceUninitialized`, :py:obj:`~.cudaErrorInvalidValue`

    See Also
    --------
    :py:obj:`~.cudaGreenCtxCreate`, :py:obj:`~.cudaExecutionCtxDestroy`, :py:obj:`~.cudaDeviceSynchronize`, :py:obj:`~.cuCtxSynchronize_v2`
    """
    cdef cyruntime.cudaExecutionContext_t cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (cudaExecutionContext_t,)):
        pctx = int(ctx)
    else:
        pctx = int(cudaExecutionContext_t(ctx))
    cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>pctx
    with nogil:
        err = cyruntime.cudaExecutionCtxSynchronize(cyctx)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaStreamGetDevResource' in found_functions}}

@cython.embedsignature(True)
def cudaStreamGetDevResource(hStream, typename not None : cudaDevResourceType):
    """ Get stream resources.

    Get the `typename` resources available to the `hStream` and store them
    in `resource`.

    Note: The API will return :py:obj:`~.cudaErrorInvalidResourceType` is
    `typename` is `cudaDevResourceTypeWorkqueueConfig` or
    `cudaDevResourceTypeWorkqueue`.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to get resource for
    typename : :py:obj:`~.cudaDevResourceType`
        Type of resource to retrieve

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorDeviceUninitialized`, :py:obj:`~.cudaErrorInvalidResourceType`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidHandle`, :py:obj:`~.cudaErrorNotPermitted`, :py:obj:`~.cudaErrorCallRequiresNewerDriver`,
    resource : :py:obj:`~.cudaDevResource`
        Output pointer to a cudaDevResource structure

    See Also
    --------
    :py:obj:`~.cudaGreenCtxCreate`, :py:obj:`~.cudaExecutionCtxStreamCreate`, :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaDevSmResourceSplit`, :py:obj:`~.cudaDevResourceGenerateDesc`, :py:obj:`~.cuStreamGetDevResource`
    """
    cdef cyruntime.cudaStream_t cyhStream
    if hStream is None:
        phStream = 0
    elif isinstance(hStream, (cudaStream_t,driver.CUstream)):
        phStream = int(hStream)
    else:
        phStream = int(cudaStream_t(hStream))
    cyhStream = <cyruntime.cudaStream_t><void_ptr>phStream
    cdef cudaDevResource resource = cudaDevResource()
    cdef cyruntime.cudaDevResourceType cytypename = int(typename)
    with nogil:
        err = cyruntime.cudaStreamGetDevResource(cyhStream, <cyruntime.cudaDevResource*>resource._pvt_ptr, cytypename)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), resource)
{{endif}}

{{if 'cudaExecutionCtxRecordEvent' in found_functions}}

@cython.embedsignature(True)
def cudaExecutionCtxRecordEvent(ctx, event):
    """ Records an event for the specified execution context.

    Captures in `event` all the activities of the execution context `ctx`
    at the time of this call. `event` and `ctx` must be from the same CUDA
    device, otherwise :py:obj:`~.cudaErrorInvalidHandle` will be returned.
    Calls such as :py:obj:`~.cudaEventQuery()` or
    :py:obj:`~.cudaExecutionCtxWaitEvent()` will then examine or wait for
    completion of the work that was captured. Uses of `ctx` after this call
    do not modify `event`. If the execution context passed to `ctx` is the
    device (primary) context obtained via
    :py:obj:`~.cudaDeviceGetExecutionCtx()`, `event` will capture all the
    activities of the green contexts created on the device as well.

    Parameters
    ----------
    ctx : :py:obj:`~.cudaExecutionContext_t`
        Execution context to record event for (required parameter, see note
        below)
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to record

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorInvalidHandle`, :py:obj:`~.cudaErrorStreamCaptureUnsupported`

    See Also
    --------
    :py:obj:`~.cudaEventRecord`, :py:obj:`~.cudaExecutionCtxWaitEvent`, :py:obj:`~.cuCtxRecordEvent`, :py:obj:`~.cuGreenCtxRecordEvent`

    Notes
    -----
    The API will return :py:obj:`~.cudaErrorStreamCaptureUnsupported` if the specified execution context `ctx` has a stream in the capture mode. In such a case, the call will invalidate all the conflicting captures.
    """
    cdef cyruntime.cudaEvent_t cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (cudaEvent_t,driver.CUevent)):
        pevent = int(event)
    else:
        pevent = int(cudaEvent_t(event))
    cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
    cdef cyruntime.cudaExecutionContext_t cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (cudaExecutionContext_t,)):
        pctx = int(ctx)
    else:
        pctx = int(cudaExecutionContext_t(ctx))
    cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>pctx
    with nogil:
        err = cyruntime.cudaExecutionCtxRecordEvent(cyctx, cyevent)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaExecutionCtxWaitEvent' in found_functions}}

@cython.embedsignature(True)
def cudaExecutionCtxWaitEvent(ctx, event):
    """ Make an execution context wait on an event.

    Makes all future work submitted to execution context `ctx` wait for all
    work captured in `event`. The synchronization will be performed on the
    device and will not block the calling CPU thread. See
    :py:obj:`~.cudaExecutionCtxRecordEvent()` for details on what is
    captured by an event. If the execution context passed to `ctx` is the
    device (primary) context obtained via
    :py:obj:`~.cudaDeviceGetExecutionCtx()`, all green contexts created on
    the device will wait for `event` as well.

    Parameters
    ----------
    ctx : :py:obj:`~.cudaExecutionContext_t`
        Execution context to wait for (required parameter, see note below)
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to wait on

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorCudartUnloading`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorInvalidHandle`, :py:obj:`~.cudaErrorStreamCaptureUnsupported`

    See Also
    --------
    :py:obj:`~.cudaExecutionCtxRecordEvent`, :py:obj:`~.cudaStreamWaitEvent`, :py:obj:`~.cuCtxWaitEvent`, :py:obj:`~.cuGreenCtxWaitEvent`

    Notes
    -----
    `event` may be from a different execution context or device than `ctx`.

    The API will return :py:obj:`~.cudaErrorStreamCaptureUnsupported` and invalidate the capture if the specified event `event` is part of an ongoing capture sequence or if the specified execution context `ctx` has a stream in the capture mode.
    """
    cdef cyruntime.cudaEvent_t cyevent
    if event is None:
        pevent = 0
    elif isinstance(event, (cudaEvent_t,driver.CUevent)):
        pevent = int(event)
    else:
        pevent = int(cudaEvent_t(event))
    cyevent = <cyruntime.cudaEvent_t><void_ptr>pevent
    cdef cyruntime.cudaExecutionContext_t cyctx
    if ctx is None:
        pctx = 0
    elif isinstance(ctx, (cudaExecutionContext_t,)):
        pctx = int(ctx)
    else:
        pctx = int(cudaExecutionContext_t(ctx))
    cyctx = <cyruntime.cudaExecutionContext_t><void_ptr>pctx
    with nogil:
        err = cyruntime.cudaExecutionCtxWaitEvent(cyctx, cyevent)
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaDeviceGetExecutionCtx' in found_functions}}

@cython.embedsignature(True)
def cudaDeviceGetExecutionCtx(int device):
    """ Returns the execution context for a device.

    Returns in `ctx` the execution context for the specified device. This
    is the device's primary context. The returned context can then be
    passed to APIs that take in a cudaExecutionContext_t enabling explicit
    context-based programming without relying on thread-local state.

    Passing the returned execution context to
    :py:obj:`~.cudaExecutionCtxDestroy()` is not allowed and will result in
    undefined behavior.

    Parameters
    ----------
    device : int
        Device to get the execution context for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidDevice`
    ctx : :py:obj:`~.cudaExecutionContext_t`
        Returns the device execution context

    See Also
    --------
    :py:obj:`~.cudaExecutionCtxGetDevice`, :py:obj:`~.cudaExecutionCtxGetId`
    """
    cdef cudaExecutionContext_t ctx = cudaExecutionContext_t()
    with nogil:
        err = cyruntime.cudaDeviceGetExecutionCtx(<cyruntime.cudaExecutionContext_t*>ctx._pvt_ptr, device)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), ctx)
{{endif}}

{{if 'cudaGetExportTable' in found_functions}}

@cython.embedsignature(True)
def cudaGetExportTable(pExportTableId : Optional[cudaUUID_t]):
    """"""
    cdef void_ptr ppExportTable = 0
    cdef cyruntime.cudaUUID_t* cypExportTableId_ptr = pExportTableId._pvt_ptr if pExportTableId is not None else NULL
    with nogil:
        err = cyruntime.cudaGetExportTable(<const void**>&ppExportTable, cypExportTableId_ptr)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), ppExportTable)
{{endif}}

{{if 'cudaGetKernel' in found_functions}}

@cython.embedsignature(True)
def cudaGetKernel(entryFuncAddr):
    """ Get pointer to device kernel that matches entry function `entryFuncAddr`.

    Returns in `kernelPtr` the device kernel corresponding to the entry
    function `entryFuncAddr`.

    Note that it is possible that there are multiple symbols belonging to
    different translation units with the same `entryFuncAddr` registered
    with this CUDA Runtime and so the order which the translation units are
    loaded and registered with the CUDA Runtime can lead to differing
    return pointers in `kernelPtr` . Suggested methods of ensuring
    uniqueness are to limit visibility of global device functions by using
    static or hidden visibility attribute in the respective translation
    units.

    Parameters
    ----------
    entryFuncAddr : Any
        Address of device entry function to search kernel for

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`
    kernelPtr : :py:obj:`~.cudaKernel_t`
        Returns the device kernel

    See Also
    --------
    cudaGetKernel (C++ API)
    """
    cdef cudaKernel_t kernelPtr = cudaKernel_t()
    cdef _HelperInputVoidPtrStruct cyentryFuncAddrHelper
    cdef void* cyentryFuncAddr = _helper_input_void_ptr(entryFuncAddr, &cyentryFuncAddrHelper)
    with nogil:
        err = cyruntime.cudaGetKernel(<cyruntime.cudaKernel_t*>kernelPtr._pvt_ptr, cyentryFuncAddr)
    _helper_input_void_ptr_free(&cyentryFuncAddrHelper)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), kernelPtr)
{{endif}}

{{if 'make_cudaPitchedPtr' in found_functions}}

@cython.embedsignature(True)
def make_cudaPitchedPtr(d, size_t p, size_t xsz, size_t ysz):
    """ Returns a :py:obj:`~.cudaPitchedPtr` based on input parameters.

    Returns a :py:obj:`~.cudaPitchedPtr` based on the specified input
    parameters `d`, `p`, `xsz`, and `ysz`.

    Parameters
    ----------
    d : Any
        Pointer to allocated memory
    p : size_t
        Pitch of allocated memory in bytes
    xsz : size_t
        Logical width of allocation in elements
    ysz : size_t
        Logical height of allocation in elements

    Returns
    -------
    cudaError_t.cudaSuccess
        cudaError_t.cudaSuccess
    :py:obj:`~.cudaPitchedPtr`
        :py:obj:`~.cudaPitchedPtr` specified by `d`, `p`, `xsz`, and `ysz`

    See Also
    --------
    make_cudaExtent, make_cudaPos
    """
    cdef _HelperInputVoidPtrStruct cydHelper
    cdef void* cyd = _helper_input_void_ptr(d, &cydHelper)
    with nogil:
        err = cyruntime.make_cudaPitchedPtr(cyd, p, xsz, ysz)
    _helper_input_void_ptr_free(&cydHelper)
    cdef cudaPitchedPtr wrapper = cudaPitchedPtr()
    wrapper._pvt_ptr[0] = err
    return wrapper
{{endif}}

{{if 'make_cudaPos' in found_functions}}

@cython.embedsignature(True)
def make_cudaPos(size_t x, size_t y, size_t z):
    """ Returns a :py:obj:`~.cudaPos` based on input parameters.

    Returns a :py:obj:`~.cudaPos` based on the specified input parameters
    `x`, `y`, and `z`.

    Parameters
    ----------
    x : size_t
        X position
    y : size_t
        Y position
    z : size_t
        Z position

    Returns
    -------
    cudaError_t.cudaSuccess
        cudaError_t.cudaSuccess
    :py:obj:`~.cudaPos`
        :py:obj:`~.cudaPos` specified by `x`, `y`, and `z`

    See Also
    --------
    make_cudaExtent, make_cudaPitchedPtr
    """
    with nogil:
        err = cyruntime.make_cudaPos(x, y, z)
    cdef cudaPos wrapper = cudaPos()
    wrapper._pvt_ptr[0] = err
    return wrapper
{{endif}}

{{if 'make_cudaExtent' in found_functions}}

@cython.embedsignature(True)
def make_cudaExtent(size_t w, size_t h, size_t d):
    """ Returns a :py:obj:`~.cudaExtent` based on input parameters.

    Returns a :py:obj:`~.cudaExtent` based on the specified input
    parameters `w`, `h`, and `d`.

    Parameters
    ----------
    w : size_t
        Width in elements when referring to array memory, in bytes when
        referring to linear memory
    h : size_t
        Height in elements
    d : size_t
        Depth in elements

    Returns
    -------
    cudaError_t.cudaSuccess
        cudaError_t.cudaSuccess
    :py:obj:`~.cudaExtent`
        :py:obj:`~.cudaExtent` specified by `w`, `h`, and `d`

    See Also
    --------
    make_cudaPitchedPtr, make_cudaPos
    """
    with nogil:
        err = cyruntime.make_cudaExtent(w, h, d)
    cdef cudaExtent wrapper = cudaExtent()
    wrapper._pvt_ptr[0] = err
    return wrapper
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaGraphicsEGLRegisterImage(image, unsigned int flags):
    """ Registers an EGL image.

    Registers the EGLImageKHR specified by `image` for access by CUDA. A
    handle to the registered object is returned as `pCudaResource`.
    Additional Mapping/Unmapping is not required for the registered
    resource and :py:obj:`~.cudaGraphicsResourceGetMappedEglFrame` can be
    directly called on the `pCudaResource`.

    The application will be responsible for synchronizing access to shared
    objects. The application must ensure that any pending operation which
    access the objects have completed before passing control to CUDA. This
    may be accomplished by issuing and waiting for glFinish command on all
    GLcontexts (for OpenGL and likewise for other APIs). The application
    will be also responsible for ensuring that any pending operation on the
    registered CUDA resource has completed prior to executing subsequent
    commands in other APIs accesing the same memory objects. This can be
    accomplished by calling cuCtxSynchronize or cuEventSynchronize
    (preferably).

    The surface's intended usage is specified using `flags`, as follows:

    - :py:obj:`~.cudaGraphicsRegisterFlagsNone`: Specifies no hints about
      how this resource will be used. It is therefore assumed that this
      resource will be read from and written to by CUDA. This is the
      default value.

    - :py:obj:`~.cudaGraphicsRegisterFlagsReadOnly`: Specifies that CUDA
      will not write to this resource.

    - :py:obj:`~.cudaGraphicsRegisterFlagsWriteDiscard`: Specifies that
      CUDA will not read from this resource and will write over the entire
      contents of the resource, so none of the data previously stored in
      the resource will be preserved.

    The EGLImageKHR is an object which can be used to create EGLImage
    target resource. It is defined as a void pointer. typedef void*
    EGLImageKHR

    Parameters
    ----------
    image : :py:obj:`~.EGLImageKHR`
        An EGLImageKHR image which can be used to create target resource.
    flags : unsigned int
        Map flags

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorUnknown`
    pCudaResource : :py:obj:`~.cudaGraphicsResource`
        Pointer to the returned object handle

    See Also
    --------
    :py:obj:`~.cudaGraphicsUnregisterResource`, :py:obj:`~.cudaGraphicsResourceGetMappedEglFrame`, :py:obj:`~.cuGraphicsEGLRegisterImage`
    """
    cdef cyruntime.EGLImageKHR cyimage
    if image is None:
        pimage = 0
    elif isinstance(image, (EGLImageKHR,)):
        pimage = int(image)
    else:
        pimage = int(EGLImageKHR(image))
    cyimage = <cyruntime.EGLImageKHR><void_ptr>pimage
    cdef cudaGraphicsResource_t pCudaResource = cudaGraphicsResource_t()
    with nogil:
        err = cyruntime.cudaGraphicsEGLRegisterImage(pCudaResource._pvt_ptr, cyimage, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), pCudaResource)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaEGLStreamConsumerConnect(eglStream):
    """ Connect CUDA to EGLStream as a consumer.

    Connect CUDA as a consumer to EGLStreamKHR specified by `eglStream`.

    The EGLStreamKHR is an EGL object that transfers a sequence of image
    frames from one API to another.

    Parameters
    ----------
    eglStream : :py:obj:`~.EGLStreamKHR`
        EGLStreamKHR handle

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorUnknown`
    conn : :py:obj:`~.cudaEglStreamConnection`
        Pointer to the returned connection handle

    See Also
    --------
    :py:obj:`~.cudaEGLStreamConsumerDisconnect`, :py:obj:`~.cudaEGLStreamConsumerAcquireFrame`, :py:obj:`~.cudaEGLStreamConsumerReleaseFrame`, :py:obj:`~.cuEGLStreamConsumerConnect`
    """
    cdef cyruntime.EGLStreamKHR cyeglStream
    if eglStream is None:
        peglStream = 0
    elif isinstance(eglStream, (EGLStreamKHR,)):
        peglStream = int(eglStream)
    else:
        peglStream = int(EGLStreamKHR(eglStream))
    cyeglStream = <cyruntime.EGLStreamKHR><void_ptr>peglStream
    cdef cudaEglStreamConnection conn = cudaEglStreamConnection()
    with nogil:
        err = cyruntime.cudaEGLStreamConsumerConnect(<cyruntime.cudaEglStreamConnection*>conn._pvt_ptr, cyeglStream)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), conn)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaEGLStreamConsumerConnectWithFlags(eglStream, unsigned int flags):
    """ Connect CUDA to EGLStream as a consumer with given flags.

    Connect CUDA as a consumer to EGLStreamKHR specified by `stream` with
    specified `flags` defined by :py:obj:`~.cudaEglResourceLocationFlags`.

    The flags specify whether the consumer wants to access frames from
    system memory or video memory. Default is
    :py:obj:`~.cudaEglResourceLocationVidmem`.

    Parameters
    ----------
    eglStream : :py:obj:`~.EGLStreamKHR`
        EGLStreamKHR handle
    flags : unsigned int
        Flags denote intended location - system or video.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorUnknown`
    conn : :py:obj:`~.cudaEglStreamConnection`
        Pointer to the returned connection handle

    See Also
    --------
    :py:obj:`~.cudaEGLStreamConsumerDisconnect`, :py:obj:`~.cudaEGLStreamConsumerAcquireFrame`, :py:obj:`~.cudaEGLStreamConsumerReleaseFrame`, :py:obj:`~.cuEGLStreamConsumerConnectWithFlags`
    """
    cdef cyruntime.EGLStreamKHR cyeglStream
    if eglStream is None:
        peglStream = 0
    elif isinstance(eglStream, (EGLStreamKHR,)):
        peglStream = int(eglStream)
    else:
        peglStream = int(EGLStreamKHR(eglStream))
    cyeglStream = <cyruntime.EGLStreamKHR><void_ptr>peglStream
    cdef cudaEglStreamConnection conn = cudaEglStreamConnection()
    with nogil:
        err = cyruntime.cudaEGLStreamConsumerConnectWithFlags(<cyruntime.cudaEglStreamConnection*>conn._pvt_ptr, cyeglStream, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), conn)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaEGLStreamConsumerDisconnect(conn):
    """ Disconnect CUDA as a consumer to EGLStream .

    Disconnect CUDA as a consumer to EGLStreamKHR.

    Parameters
    ----------
    conn : :py:obj:`~.cudaEglStreamConnection`
        Conection to disconnect.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorUnknown`

    See Also
    --------
    :py:obj:`~.cudaEGLStreamConsumerConnect`, :py:obj:`~.cudaEGLStreamConsumerAcquireFrame`, :py:obj:`~.cudaEGLStreamConsumerReleaseFrame`, :py:obj:`~.cuEGLStreamConsumerDisconnect`
    """
    cdef cyruntime.cudaEglStreamConnection *cyconn
    if conn is None:
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (cudaEglStreamConnection,driver.CUeglStreamConnection)):
        pconn = conn.getPtr()
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, runtime.cudaEglStreamConnection'>, found " + str(type(conn)))
    with nogil:
        err = cyruntime.cudaEGLStreamConsumerDisconnect(cyconn)
    return (cudaError_t(err),)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaEGLStreamConsumerAcquireFrame(conn, pCudaResource, pStream, unsigned int timeout):
    """ Acquire an image frame from the EGLStream with CUDA as a consumer.

    Acquire an image frame from EGLStreamKHR.
    :py:obj:`~.cudaGraphicsResourceGetMappedEglFrame` can be called on
    `pCudaResource` to get :py:obj:`~.cudaEglFrame`.

    Parameters
    ----------
    conn : :py:obj:`~.cudaEglStreamConnection`
        Connection on which to acquire
    pCudaResource : :py:obj:`~.cudaGraphicsResource_t`
        CUDA resource on which the EGLStream frame will be mapped for use.
    pStream : :py:obj:`~.cudaStream_t`
        CUDA stream for synchronization and any data migrations implied by
        :py:obj:`~.cudaEglResourceLocationFlags`.
    timeout : unsigned int
        Desired timeout in usec.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorUnknown`, :py:obj:`~.cudaErrorLaunchTimeout`

    See Also
    --------
    :py:obj:`~.cudaEGLStreamConsumerConnect`, :py:obj:`~.cudaEGLStreamConsumerDisconnect`, :py:obj:`~.cudaEGLStreamConsumerReleaseFrame`, :py:obj:`~.cuEGLStreamConsumerAcquireFrame`
    """
    cdef cyruntime.cudaStream_t *cypStream
    if pStream is None:
        cypStream = <cyruntime.cudaStream_t*><void_ptr>NULL
    elif isinstance(pStream, (cudaStream_t,driver.CUstream)):
        ppStream = pStream.getPtr()
        cypStream = <cyruntime.cudaStream_t*><void_ptr>ppStream
    elif isinstance(pStream, (int)):
        cypStream = <cyruntime.cudaStream_t*><void_ptr>pStream
    else:
        raise TypeError("Argument 'pStream' is not instance of type (expected <class 'int, runtime.cudaStream_t'>, found " + str(type(pStream)))
    cdef cyruntime.cudaGraphicsResource_t *cypCudaResource
    if pCudaResource is None:
        cypCudaResource = <cyruntime.cudaGraphicsResource_t*><void_ptr>NULL
    elif isinstance(pCudaResource, (cudaGraphicsResource_t,)):
        ppCudaResource = pCudaResource.getPtr()
        cypCudaResource = <cyruntime.cudaGraphicsResource_t*><void_ptr>ppCudaResource
    elif isinstance(pCudaResource, (int)):
        cypCudaResource = <cyruntime.cudaGraphicsResource_t*><void_ptr>pCudaResource
    else:
        raise TypeError("Argument 'pCudaResource' is not instance of type (expected <class 'int, runtime.cudaGraphicsResource_t'>, found " + str(type(pCudaResource)))
    cdef cyruntime.cudaEglStreamConnection *cyconn
    if conn is None:
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (cudaEglStreamConnection,driver.CUeglStreamConnection)):
        pconn = conn.getPtr()
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, runtime.cudaEglStreamConnection'>, found " + str(type(conn)))
    with nogil:
        err = cyruntime.cudaEGLStreamConsumerAcquireFrame(cyconn, cypCudaResource, cypStream, timeout)
    return (cudaError_t(err),)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaEGLStreamConsumerReleaseFrame(conn, pCudaResource, pStream):
    """ Releases the last frame acquired from the EGLStream.

    Release the acquired image frame specified by `pCudaResource` to
    EGLStreamKHR.

    Parameters
    ----------
    conn : :py:obj:`~.cudaEglStreamConnection`
        Connection on which to release
    pCudaResource : :py:obj:`~.cudaGraphicsResource_t`
        CUDA resource whose corresponding frame is to be released
    pStream : :py:obj:`~.cudaStream_t`
        CUDA stream on which release will be done.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorUnknown`

    See Also
    --------
    :py:obj:`~.cudaEGLStreamConsumerConnect`, :py:obj:`~.cudaEGLStreamConsumerDisconnect`, :py:obj:`~.cudaEGLStreamConsumerAcquireFrame`, :py:obj:`~.cuEGLStreamConsumerReleaseFrame`
    """
    cdef cyruntime.cudaStream_t *cypStream
    if pStream is None:
        cypStream = <cyruntime.cudaStream_t*><void_ptr>NULL
    elif isinstance(pStream, (cudaStream_t,driver.CUstream)):
        ppStream = pStream.getPtr()
        cypStream = <cyruntime.cudaStream_t*><void_ptr>ppStream
    elif isinstance(pStream, (int)):
        cypStream = <cyruntime.cudaStream_t*><void_ptr>pStream
    else:
        raise TypeError("Argument 'pStream' is not instance of type (expected <class 'int, runtime.cudaStream_t'>, found " + str(type(pStream)))
    cdef cyruntime.cudaGraphicsResource_t cypCudaResource
    if pCudaResource is None:
        ppCudaResource = 0
    elif isinstance(pCudaResource, (cudaGraphicsResource_t,)):
        ppCudaResource = int(pCudaResource)
    else:
        ppCudaResource = int(cudaGraphicsResource_t(pCudaResource))
    cypCudaResource = <cyruntime.cudaGraphicsResource_t><void_ptr>ppCudaResource
    cdef cyruntime.cudaEglStreamConnection *cyconn
    if conn is None:
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (cudaEglStreamConnection,driver.CUeglStreamConnection)):
        pconn = conn.getPtr()
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, runtime.cudaEglStreamConnection'>, found " + str(type(conn)))
    with nogil:
        err = cyruntime.cudaEGLStreamConsumerReleaseFrame(cyconn, cypCudaResource, cypStream)
    return (cudaError_t(err),)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaEGLStreamProducerConnect(eglStream, width, height):
    """ Connect CUDA to EGLStream as a producer.

    Connect CUDA as a producer to EGLStreamKHR specified by `stream`.

    The EGLStreamKHR is an EGL object that transfers a sequence of image
    frames from one API to another.

    Parameters
    ----------
    eglStream : :py:obj:`~.EGLStreamKHR`
        EGLStreamKHR handle
    width : :py:obj:`~.EGLint`
        width of the image to be submitted to the stream
    height : :py:obj:`~.EGLint`
        height of the image to be submitted to the stream

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorUnknown`
    conn : :py:obj:`~.cudaEglStreamConnection`
        Pointer to the returned connection handle

    See Also
    --------
    :py:obj:`~.cudaEGLStreamProducerDisconnect`, :py:obj:`~.cudaEGLStreamProducerPresentFrame`, :py:obj:`~.cudaEGLStreamProducerReturnFrame`, :py:obj:`~.cuEGLStreamProducerConnect`
    """
    cdef cyruntime.EGLint cyheight
    if height is None:
        pheight = 0
    elif isinstance(height, (EGLint,)):
        pheight = int(height)
    else:
        pheight = int(EGLint(height))
    cyheight = <cyruntime.EGLint><void_ptr>pheight
    cdef cyruntime.EGLint cywidth
    if width is None:
        pwidth = 0
    elif isinstance(width, (EGLint,)):
        pwidth = int(width)
    else:
        pwidth = int(EGLint(width))
    cywidth = <cyruntime.EGLint><void_ptr>pwidth
    cdef cyruntime.EGLStreamKHR cyeglStream
    if eglStream is None:
        peglStream = 0
    elif isinstance(eglStream, (EGLStreamKHR,)):
        peglStream = int(eglStream)
    else:
        peglStream = int(EGLStreamKHR(eglStream))
    cyeglStream = <cyruntime.EGLStreamKHR><void_ptr>peglStream
    cdef cudaEglStreamConnection conn = cudaEglStreamConnection()
    with nogil:
        err = cyruntime.cudaEGLStreamProducerConnect(<cyruntime.cudaEglStreamConnection*>conn._pvt_ptr, cyeglStream, cywidth, cyheight)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), conn)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaEGLStreamProducerDisconnect(conn):
    """ Disconnect CUDA as a producer to EGLStream .

    Disconnect CUDA as a producer to EGLStreamKHR.

    Parameters
    ----------
    conn : :py:obj:`~.cudaEglStreamConnection`
        Conection to disconnect.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorUnknown`

    See Also
    --------
    :py:obj:`~.cudaEGLStreamProducerConnect`, :py:obj:`~.cudaEGLStreamProducerPresentFrame`, :py:obj:`~.cudaEGLStreamProducerReturnFrame`, :py:obj:`~.cuEGLStreamProducerDisconnect`
    """
    cdef cyruntime.cudaEglStreamConnection *cyconn
    if conn is None:
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (cudaEglStreamConnection,driver.CUeglStreamConnection)):
        pconn = conn.getPtr()
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, runtime.cudaEglStreamConnection'>, found " + str(type(conn)))
    with nogil:
        err = cyruntime.cudaEGLStreamProducerDisconnect(cyconn)
    return (cudaError_t(err),)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaEGLStreamProducerPresentFrame(conn, eglframe not None : cudaEglFrame, pStream):
    """ Present a CUDA eglFrame to the EGLStream with CUDA as a producer.

    The :py:obj:`~.cudaEglFrame` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    For :py:obj:`~.cudaEglFrame` of type :py:obj:`~.cudaEglFrameTypePitch`,
    the application may present sub-region of a memory allocation. In that
    case, :py:obj:`~.cudaPitchedPtr.ptr` will specify the start address of
    the sub-region in the allocation and :py:obj:`~.cudaEglPlaneDesc` will
    specify the dimensions of the sub-region.

    Parameters
    ----------
    conn : :py:obj:`~.cudaEglStreamConnection`
        Connection on which to present the CUDA array
    eglframe : :py:obj:`~.cudaEglFrame`
        CUDA Eglstream Proucer Frame handle to be sent to the consumer over
        EglStream.
    pStream : :py:obj:`~.cudaStream_t`
        CUDA stream on which to present the frame.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorUnknown`

    See Also
    --------
    :py:obj:`~.cudaEGLStreamProducerConnect`, :py:obj:`~.cudaEGLStreamProducerDisconnect`, :py:obj:`~.cudaEGLStreamProducerReturnFrame`, :py:obj:`~.cuEGLStreamProducerPresentFrame`
    """
    cdef cyruntime.cudaStream_t *cypStream
    if pStream is None:
        cypStream = <cyruntime.cudaStream_t*><void_ptr>NULL
    elif isinstance(pStream, (cudaStream_t,driver.CUstream)):
        ppStream = pStream.getPtr()
        cypStream = <cyruntime.cudaStream_t*><void_ptr>ppStream
    elif isinstance(pStream, (int)):
        cypStream = <cyruntime.cudaStream_t*><void_ptr>pStream
    else:
        raise TypeError("Argument 'pStream' is not instance of type (expected <class 'int, runtime.cudaStream_t'>, found " + str(type(pStream)))
    cdef cyruntime.cudaEglStreamConnection *cyconn
    if conn is None:
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (cudaEglStreamConnection,driver.CUeglStreamConnection)):
        pconn = conn.getPtr()
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, runtime.cudaEglStreamConnection'>, found " + str(type(conn)))
    with nogil:
        err = cyruntime.cudaEGLStreamProducerPresentFrame(cyconn, eglframe._pvt_ptr[0], cypStream)
    return (cudaError_t(err),)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaEGLStreamProducerReturnFrame(conn, eglframe : Optional[cudaEglFrame], pStream):
    """ Return the CUDA eglFrame to the EGLStream last released by the consumer.

    This API can potentially return cudaErrorLaunchTimeout if the consumer
    has not returned a frame to EGL stream. If timeout is returned the
    application can retry.

    Parameters
    ----------
    conn : :py:obj:`~.cudaEglStreamConnection`
        Connection on which to present the CUDA array
    eglframe : :py:obj:`~.cudaEglFrame`
        CUDA Eglstream Proucer Frame handle returned from the consumer over
        EglStream.
    pStream : :py:obj:`~.cudaStream_t`
        CUDA stream on which to return the frame.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorLaunchTimeout`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorUnknown`

    See Also
    --------
    :py:obj:`~.cudaEGLStreamProducerConnect`, :py:obj:`~.cudaEGLStreamProducerDisconnect`, :py:obj:`~.cudaEGLStreamProducerPresentFrame`, :py:obj:`~.cuEGLStreamProducerReturnFrame`
    """
    cdef cyruntime.cudaStream_t *cypStream
    if pStream is None:
        cypStream = <cyruntime.cudaStream_t*><void_ptr>NULL
    elif isinstance(pStream, (cudaStream_t,driver.CUstream)):
        ppStream = pStream.getPtr()
        cypStream = <cyruntime.cudaStream_t*><void_ptr>ppStream
    elif isinstance(pStream, (int)):
        cypStream = <cyruntime.cudaStream_t*><void_ptr>pStream
    else:
        raise TypeError("Argument 'pStream' is not instance of type (expected <class 'int, runtime.cudaStream_t'>, found " + str(type(pStream)))
    cdef cyruntime.cudaEglStreamConnection *cyconn
    if conn is None:
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (cudaEglStreamConnection,driver.CUeglStreamConnection)):
        pconn = conn.getPtr()
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cyconn = <cyruntime.cudaEglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, runtime.cudaEglStreamConnection'>, found " + str(type(conn)))
    cdef cyruntime.cudaEglFrame* cyeglframe_ptr = eglframe._pvt_ptr if eglframe is not None else NULL
    with nogil:
        err = cyruntime.cudaEGLStreamProducerReturnFrame(cyconn, cyeglframe_ptr, cypStream)
    return (cudaError_t(err),)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaGraphicsResourceGetMappedEglFrame(resource, unsigned int index, unsigned int mipLevel):
    """ Get an eglFrame through which to access a registered EGL graphics resource.

    Returns in `*eglFrame` an eglFrame pointer through which the registered
    graphics resource `resource` may be accessed. This API can only be
    called for EGL graphics resources.

    The :py:obj:`~.cudaEglFrame` is defined as

    **View CUDA Toolkit Documentation for a C++ code example**

    Parameters
    ----------
    resource : :py:obj:`~.cudaGraphicsResource_t`
        Registered resource to access.
    index : unsigned int
        Index for cubemap surfaces.
    mipLevel : unsigned int
        Mipmap level for the subresource to access.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorUnknown`
    eglFrame : :py:obj:`~.cudaEglFrame`
        Returned eglFrame.

    See Also
    --------
    :py:obj:`~.cudaGraphicsSubResourceGetMappedArray`, :py:obj:`~.cudaGraphicsResourceGetMappedPointer`, :py:obj:`~.cuGraphicsResourceGetMappedEglFrame`

    Notes
    -----
    Note that in case of multiplanar `*eglFrame`, pitch of only first plane (unsigned int :py:obj:`~.cudaEglPlaneDesc.pitch`) is to be considered by the application.
    """
    cdef cyruntime.cudaGraphicsResource_t cyresource
    if resource is None:
        presource = 0
    elif isinstance(resource, (cudaGraphicsResource_t,)):
        presource = int(resource)
    else:
        presource = int(cudaGraphicsResource_t(resource))
    cyresource = <cyruntime.cudaGraphicsResource_t><void_ptr>presource
    cdef cudaEglFrame eglFrame = cudaEglFrame()
    with nogil:
        err = cyruntime.cudaGraphicsResourceGetMappedEglFrame(<cyruntime.cudaEglFrame*>eglFrame._pvt_ptr, cyresource, index, mipLevel)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), eglFrame)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaEventCreateFromEGLSync(eglSync, unsigned int flags):
    """ Creates an event from EGLSync object.

    Creates an event *phEvent from an EGLSyncKHR eglSync with the flages
    specified via `flags`. Valid flags include:

    - :py:obj:`~.cudaEventDefault`: Default event creation flag.

    - :py:obj:`~.cudaEventBlockingSync`: Specifies that the created event
      should use blocking synchronization. A CPU thread that uses
      :py:obj:`~.cudaEventSynchronize()` to wait on an event created with
      this flag will block until the event has actually been completed.

    :py:obj:`~.cudaEventRecord` and TimingData are not supported for events
    created from EGLSync.

    The EGLSyncKHR is an opaque handle to an EGL sync object. typedef void*
    EGLSyncKHR

    Parameters
    ----------
    eglSync : :py:obj:`~.EGLSyncKHR`
        Opaque handle to EGLSync object
    flags : unsigned int
        Event creation flags

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInitializationError`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorLaunchFailure`, :py:obj:`~.cudaErrorMemoryAllocation`
    phEvent : :py:obj:`~.cudaEvent_t`
        Returns newly created event

    See Also
    --------
    :py:obj:`~.cudaEventQuery`, :py:obj:`~.cudaEventSynchronize`, :py:obj:`~.cudaEventDestroy`
    """
    cdef cyruntime.EGLSyncKHR cyeglSync
    if eglSync is None:
        peglSync = 0
    elif isinstance(eglSync, (EGLSyncKHR,)):
        peglSync = int(eglSync)
    else:
        peglSync = int(EGLSyncKHR(eglSync))
    cyeglSync = <cyruntime.EGLSyncKHR><void_ptr>peglSync
    cdef cudaEvent_t phEvent = cudaEvent_t()
    with nogil:
        err = cyruntime.cudaEventCreateFromEGLSync(<cyruntime.cudaEvent_t*>phEvent._pvt_ptr, cyeglSync, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), phEvent)
{{endif}}

{{if 'cudaProfilerStart' in found_functions}}

@cython.embedsignature(True)
def cudaProfilerStart():
    """ Enable profiling.

    Enables profile collection by the active profiling tool for the current
    context. If profiling is already enabled, then
    :py:obj:`~.cudaProfilerStart()` has no effect.

    cudaProfilerStart and cudaProfilerStop APIs are used to
    programmatically control the profiling granularity by allowing
    profiling to be done only on selective pieces of code.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`

    See Also
    --------
    :py:obj:`~.cudaProfilerStop`, :py:obj:`~.cuProfilerStart`
    """
    with nogil:
        err = cyruntime.cudaProfilerStart()
    return (cudaError_t(err),)
{{endif}}

{{if 'cudaProfilerStop' in found_functions}}

@cython.embedsignature(True)
def cudaProfilerStop():
    """ Disable profiling.

    Disables profile collection by the active profiling tool for the
    current context. If profiling is already disabled, then
    :py:obj:`~.cudaProfilerStop()` has no effect.

    cudaProfilerStart and cudaProfilerStop APIs are used to
    programmatically control the profiling granularity by allowing
    profiling to be done only on selective pieces of code.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`

    See Also
    --------
    :py:obj:`~.cudaProfilerStart`, :py:obj:`~.cuProfilerStop`
    """
    with nogil:
        err = cyruntime.cudaProfilerStop()
    return (cudaError_t(err),)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaGLGetDevices(unsigned int cudaDeviceCount, deviceList not None : cudaGLDeviceList):
    """ Gets the CUDA devices associated with the current OpenGL context.

    Returns in `*pCudaDeviceCount` the number of CUDA-compatible devices
    corresponding to the current OpenGL context. Also returns in
    `*pCudaDevices` at most `cudaDeviceCount` of the CUDA-compatible
    devices corresponding to the current OpenGL context. If any of the GPUs
    being used by the current OpenGL context are not CUDA capable then the
    call will return cudaErrorNoDevice.

    Parameters
    ----------
    cudaDeviceCount : unsigned int
        The size of the output device array `pCudaDevices`
    deviceList : cudaGLDeviceList
        The set of devices to return. This set may be cudaGLDeviceListAll
        for all devices, cudaGLDeviceListCurrentFrame for the devices used
        to render the current frame (in SLI), or cudaGLDeviceListNextFrame
        for the devices used to render the next frame (in SLI).

    Returns
    -------
    cudaError_t
        cudaSuccess
        cudaErrorNoDevice
        cudaErrorInvalidGraphicsContext
        cudaErrorUnknown
    pCudaDeviceCount : unsigned int
        Returned number of CUDA devices corresponding to the current OpenGL
        context
    pCudaDevices : list[int]
        Returned CUDA devices corresponding to the current OpenGL context

    See Also
    --------
    ~.cudaGraphicsUnregisterResource
    ~.cudaGraphicsMapResources
    ~.cudaGraphicsSubResourceGetMappedArray
    ~.cudaGraphicsResourceGetMappedPointer
    ~.cuGLGetDevices

    Notes
    -----
    This function is not supported on Mac OS X.

    """
    cdef unsigned int pCudaDeviceCount = 0
    cdef int* cypCudaDevices = NULL
    pypCudaDevices = []
    if cudaDeviceCount != 0:
        cypCudaDevices = <int*>calloc(cudaDeviceCount, sizeof(int))
        if cypCudaDevices is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(cudaDeviceCount) + 'x' + str(sizeof(int)))
    cdef cyruntime.cudaGLDeviceList cydeviceList = int(deviceList)
    with nogil:
        err = cyruntime.cudaGLGetDevices(&pCudaDeviceCount, cypCudaDevices, cudaDeviceCount, cydeviceList)
    if cudaError_t(err) == cudaError_t(0):
        pypCudaDevices = [<void_ptr>cypCudaDevices[idx] for idx in range(cudaDeviceCount)]
    if cypCudaDevices is not NULL:
        free(cypCudaDevices)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None, None)
    return (cudaError_t(err), pCudaDeviceCount, pypCudaDevices)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaGraphicsGLRegisterImage(image, target, unsigned int flags):
    """ Register an OpenGL texture or renderbuffer object.

    Registers the texture or renderbuffer object specified by `image` for
    access by CUDA. A handle to the registered object is returned as
    `resource`.

    `target` must match the type of the object, and must be one of
    :py:obj:`~.GL_TEXTURE_2D`, :py:obj:`~.GL_TEXTURE_RECTANGLE`,
    :py:obj:`~.GL_TEXTURE_CUBE_MAP`, :py:obj:`~.GL_TEXTURE_3D`,
    :py:obj:`~.GL_TEXTURE_2D_ARRAY`, or :py:obj:`~.GL_RENDERBUFFER`.

    The register flags `flags` specify the intended usage, as follows:

    - :py:obj:`~.cudaGraphicsRegisterFlagsNone`: Specifies no hints about
      how this resource will be used. It is therefore assumed that this
      resource will be read from and written to by CUDA. This is the
      default value.

    - :py:obj:`~.cudaGraphicsRegisterFlagsReadOnly`: Specifies that CUDA
      will not write to this resource.

    - :py:obj:`~.cudaGraphicsRegisterFlagsWriteDiscard`: Specifies that
      CUDA will not read from this resource and will write over the entire
      contents of the resource, so none of the data previously stored in
      the resource will be preserved.

    - :py:obj:`~.cudaGraphicsRegisterFlagsSurfaceLoadStore`: Specifies that
      CUDA will bind this resource to a surface reference.

    - :py:obj:`~.cudaGraphicsRegisterFlagsTextureGather`: Specifies that
      CUDA will perform texture gather operations on this resource.

    The following image formats are supported. For brevity's sake, the list
    is abbreviated. For ex., {GL_R, GL_RG} X {8, 16} would expand to the
    following 4 formats {GL_R8, GL_R16, GL_RG8, GL_RG16} :

    - GL_RED, GL_RG, GL_RGBA, GL_LUMINANCE, GL_ALPHA, GL_LUMINANCE_ALPHA,
      GL_INTENSITY

    - {GL_R, GL_RG, GL_RGBA} X {8, 16, 16F, 32F, 8UI, 16UI, 32UI, 8I, 16I,
      32I}

    - {GL_LUMINANCE, GL_ALPHA, GL_LUMINANCE_ALPHA, GL_INTENSITY} X {8, 16,
      16F_ARB, 32F_ARB, 8UI_EXT, 16UI_EXT, 32UI_EXT, 8I_EXT, 16I_EXT,
      32I_EXT}

    The following image classes are currently disallowed:

    - Textures with borders

    - Multisampled renderbuffers

    Parameters
    ----------
    image : :py:obj:`~.GLuint`
        name of texture or renderbuffer object to be registered
    target : :py:obj:`~.GLenum`
        Identifies the type of object specified by `image`
    flags : unsigned int
        Register flags

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorOperatingSystem`, :py:obj:`~.cudaErrorUnknown`
    resource : :py:obj:`~.cudaGraphicsResource`
        Pointer to the returned object handle

    See Also
    --------
    :py:obj:`~.cudaGraphicsUnregisterResource`, :py:obj:`~.cudaGraphicsMapResources`, :py:obj:`~.cudaGraphicsSubResourceGetMappedArray`, :py:obj:`~.cuGraphicsGLRegisterImage`
    """
    cdef cyruntime.GLenum cytarget
    if target is None:
        ptarget = 0
    elif isinstance(target, (GLenum,)):
        ptarget = int(target)
    else:
        ptarget = int(GLenum(target))
    cytarget = <cyruntime.GLenum><void_ptr>ptarget
    cdef cyruntime.GLuint cyimage
    if image is None:
        pimage = 0
    elif isinstance(image, (GLuint,)):
        pimage = int(image)
    else:
        pimage = int(GLuint(image))
    cyimage = <cyruntime.GLuint><void_ptr>pimage
    cdef cudaGraphicsResource_t resource = cudaGraphicsResource_t()
    with nogil:
        err = cyruntime.cudaGraphicsGLRegisterImage(resource._pvt_ptr, cyimage, cytarget, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), resource)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaGraphicsGLRegisterBuffer(buffer, unsigned int flags):
    """ Registers an OpenGL buffer object.

    Registers the buffer object specified by `buffer` for access by CUDA. A
    handle to the registered object is returned as `resource`. The register
    flags `flags` specify the intended usage, as follows:

    - :py:obj:`~.cudaGraphicsRegisterFlagsNone`: Specifies no hints about
      how this resource will be used. It is therefore assumed that this
      resource will be read from and written to by CUDA. This is the
      default value.

    - :py:obj:`~.cudaGraphicsRegisterFlagsReadOnly`: Specifies that CUDA
      will not write to this resource.

    - :py:obj:`~.cudaGraphicsRegisterFlagsWriteDiscard`: Specifies that
      CUDA will not read from this resource and will write over the entire
      contents of the resource, so none of the data previously stored in
      the resource will be preserved.

    Parameters
    ----------
    buffer : :py:obj:`~.GLuint`
        name of buffer object to be registered
    flags : unsigned int
        Register flags

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorOperatingSystem`, :py:obj:`~.cudaErrorUnknown`
    resource : :py:obj:`~.cudaGraphicsResource`
        Pointer to the returned object handle

    See Also
    --------
    :py:obj:`~.cudaGraphicsUnregisterResource`, :py:obj:`~.cudaGraphicsMapResources`, :py:obj:`~.cudaGraphicsResourceGetMappedPointer`, :py:obj:`~.cuGraphicsGLRegisterBuffer`
    """
    cdef cyruntime.GLuint cybuffer
    if buffer is None:
        pbuffer = 0
    elif isinstance(buffer, (GLuint,)):
        pbuffer = int(buffer)
    else:
        pbuffer = int(GLuint(buffer))
    cybuffer = <cyruntime.GLuint><void_ptr>pbuffer
    cdef cudaGraphicsResource_t resource = cudaGraphicsResource_t()
    with nogil:
        err = cyruntime.cudaGraphicsGLRegisterBuffer(resource._pvt_ptr, cybuffer, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), resource)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaVDPAUGetDevice(vdpDevice, vdpGetProcAddress):
    """ Gets the CUDA device associated with a VdpDevice.

    Returns the CUDA device associated with a VdpDevice, if applicable.

    Parameters
    ----------
    vdpDevice : :py:obj:`~.VdpDevice`
        A VdpDevice handle
    vdpGetProcAddress : :py:obj:`~.VdpGetProcAddress`
        VDPAU's VdpGetProcAddress function pointer

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`
    device : int
        Returns the device associated with vdpDevice, or -1 if the device
        associated with vdpDevice is not a compute device.

    See Also
    --------
    :py:obj:`~.cudaVDPAUSetVDPAUDevice`, :py:obj:`~.cuVDPAUGetDevice`
    """
    cdef cyruntime.VdpGetProcAddress *cyvdpGetProcAddress
    if vdpGetProcAddress is None:
        cyvdpGetProcAddress = <cyruntime.VdpGetProcAddress*><void_ptr>NULL
    elif isinstance(vdpGetProcAddress, (VdpGetProcAddress,)):
        pvdpGetProcAddress = vdpGetProcAddress.getPtr()
        cyvdpGetProcAddress = <cyruntime.VdpGetProcAddress*><void_ptr>pvdpGetProcAddress
    elif isinstance(vdpGetProcAddress, (int)):
        cyvdpGetProcAddress = <cyruntime.VdpGetProcAddress*><void_ptr>vdpGetProcAddress
    else:
        raise TypeError("Argument 'vdpGetProcAddress' is not instance of type (expected <class 'int, runtime.VdpGetProcAddress'>, found " + str(type(vdpGetProcAddress)))
    cdef cyruntime.VdpDevice cyvdpDevice
    if vdpDevice is None:
        pvdpDevice = 0
    elif isinstance(vdpDevice, (VdpDevice,)):
        pvdpDevice = int(vdpDevice)
    else:
        pvdpDevice = int(VdpDevice(vdpDevice))
    cyvdpDevice = <cyruntime.VdpDevice><void_ptr>pvdpDevice
    cdef int device = 0
    with nogil:
        err = cyruntime.cudaVDPAUGetDevice(&device, cyvdpDevice, cyvdpGetProcAddress)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), device)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaVDPAUSetVDPAUDevice(int device, vdpDevice, vdpGetProcAddress):
    """ Sets a CUDA device to use VDPAU interoperability.

    Records `vdpDevice` as the VdpDevice for VDPAU interoperability with
    the CUDA device `device` and sets `device` as the current device for
    the calling host thread.

    This function will immediately initialize the primary context on
    `device` if needed.

    If `device` has already been initialized then this call will fail with
    the error :py:obj:`~.cudaErrorSetOnActiveProcess`. In this case it is
    necessary to reset `device` using :py:obj:`~.cudaDeviceReset()` before
    VDPAU interoperability on `device` may be enabled.

    Parameters
    ----------
    device : int
        Device to use for VDPAU interoperability
    vdpDevice : :py:obj:`~.VdpDevice`
        The VdpDevice to interoperate with
    vdpGetProcAddress : :py:obj:`~.VdpGetProcAddress`
        VDPAU's VdpGetProcAddress function pointer

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorSetOnActiveProcess`

    See Also
    --------
    :py:obj:`~.cudaGraphicsVDPAURegisterVideoSurface`, :py:obj:`~.cudaGraphicsVDPAURegisterOutputSurface`, :py:obj:`~.cudaDeviceReset`
    """
    cdef cyruntime.VdpGetProcAddress *cyvdpGetProcAddress
    if vdpGetProcAddress is None:
        cyvdpGetProcAddress = <cyruntime.VdpGetProcAddress*><void_ptr>NULL
    elif isinstance(vdpGetProcAddress, (VdpGetProcAddress,)):
        pvdpGetProcAddress = vdpGetProcAddress.getPtr()
        cyvdpGetProcAddress = <cyruntime.VdpGetProcAddress*><void_ptr>pvdpGetProcAddress
    elif isinstance(vdpGetProcAddress, (int)):
        cyvdpGetProcAddress = <cyruntime.VdpGetProcAddress*><void_ptr>vdpGetProcAddress
    else:
        raise TypeError("Argument 'vdpGetProcAddress' is not instance of type (expected <class 'int, runtime.VdpGetProcAddress'>, found " + str(type(vdpGetProcAddress)))
    cdef cyruntime.VdpDevice cyvdpDevice
    if vdpDevice is None:
        pvdpDevice = 0
    elif isinstance(vdpDevice, (VdpDevice,)):
        pvdpDevice = int(vdpDevice)
    else:
        pvdpDevice = int(VdpDevice(vdpDevice))
    cyvdpDevice = <cyruntime.VdpDevice><void_ptr>pvdpDevice
    with nogil:
        err = cyruntime.cudaVDPAUSetVDPAUDevice(device, cyvdpDevice, cyvdpGetProcAddress)
    return (cudaError_t(err),)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaGraphicsVDPAURegisterVideoSurface(vdpSurface, unsigned int flags):
    """ Register a VdpVideoSurface object.

    Registers the VdpVideoSurface specified by `vdpSurface` for access by
    CUDA. A handle to the registered object is returned as `resource`. The
    surface's intended usage is specified using `flags`, as follows:

    - :py:obj:`~.cudaGraphicsMapFlagsNone`: Specifies no hints about how
      this resource will be used. It is therefore assumed that this
      resource will be read from and written to by CUDA. This is the
      default value.

    - :py:obj:`~.cudaGraphicsMapFlagsReadOnly`: Specifies that CUDA will
      not write to this resource.

    - :py:obj:`~.cudaGraphicsMapFlagsWriteDiscard`: Specifies that CUDA
      will not read from this resource and will write over the entire
      contents of the resource, so none of the data previously stored in
      the resource will be preserved.

    Parameters
    ----------
    vdpSurface : :py:obj:`~.VdpVideoSurface`
        VDPAU object to be registered
    flags : unsigned int
        Map flags

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorUnknown`
    resource : :py:obj:`~.cudaGraphicsResource`
        Pointer to the returned object handle

    See Also
    --------
    :py:obj:`~.cudaVDPAUSetVDPAUDevice`, :py:obj:`~.cudaGraphicsUnregisterResource`, :py:obj:`~.cudaGraphicsSubResourceGetMappedArray`, :py:obj:`~.cuGraphicsVDPAURegisterVideoSurface`
    """
    cdef cyruntime.VdpVideoSurface cyvdpSurface
    if vdpSurface is None:
        pvdpSurface = 0
    elif isinstance(vdpSurface, (VdpVideoSurface,)):
        pvdpSurface = int(vdpSurface)
    else:
        pvdpSurface = int(VdpVideoSurface(vdpSurface))
    cyvdpSurface = <cyruntime.VdpVideoSurface><void_ptr>pvdpSurface
    cdef cudaGraphicsResource_t resource = cudaGraphicsResource_t()
    with nogil:
        err = cyruntime.cudaGraphicsVDPAURegisterVideoSurface(resource._pvt_ptr, cyvdpSurface, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), resource)
{{endif}}

{{if True}}

@cython.embedsignature(True)
def cudaGraphicsVDPAURegisterOutputSurface(vdpSurface, unsigned int flags):
    """ Register a VdpOutputSurface object.

    Registers the VdpOutputSurface specified by `vdpSurface` for access by
    CUDA. A handle to the registered object is returned as `resource`. The
    surface's intended usage is specified using `flags`, as follows:

    - :py:obj:`~.cudaGraphicsMapFlagsNone`: Specifies no hints about how
      this resource will be used. It is therefore assumed that this
      resource will be read from and written to by CUDA. This is the
      default value.

    - :py:obj:`~.cudaGraphicsMapFlagsReadOnly`: Specifies that CUDA will
      not write to this resource.

    - :py:obj:`~.cudaGraphicsMapFlagsWriteDiscard`: Specifies that CUDA
      will not read from this resource and will write over the entire
      contents of the resource, so none of the data previously stored in
      the resource will be preserved.

    Parameters
    ----------
    vdpSurface : :py:obj:`~.VdpOutputSurface`
        VDPAU object to be registered
    flags : unsigned int
        Map flags

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidDevice`, :py:obj:`~.cudaErrorInvalidValue`, :py:obj:`~.cudaErrorInvalidResourceHandle`, :py:obj:`~.cudaErrorUnknown`
    resource : :py:obj:`~.cudaGraphicsResource`
        Pointer to the returned object handle

    See Also
    --------
    :py:obj:`~.cudaVDPAUSetVDPAUDevice`, :py:obj:`~.cudaGraphicsUnregisterResource`, :py:obj:`~.cudaGraphicsSubResourceGetMappedArray`, :py:obj:`~.cuGraphicsVDPAURegisterOutputSurface`
    """
    cdef cyruntime.VdpOutputSurface cyvdpSurface
    if vdpSurface is None:
        pvdpSurface = 0
    elif isinstance(vdpSurface, (VdpOutputSurface,)):
        pvdpSurface = int(vdpSurface)
    else:
        pvdpSurface = int(VdpOutputSurface(vdpSurface))
    cyvdpSurface = <cyruntime.VdpOutputSurface><void_ptr>pvdpSurface
    cdef cudaGraphicsResource_t resource = cudaGraphicsResource_t()
    with nogil:
        err = cyruntime.cudaGraphicsVDPAURegisterOutputSurface(resource._pvt_ptr, cyvdpSurface, flags)
    if err != cyruntime.cudaSuccess:
        return (cudaError_t(err), None)
    return (cudaError_t(err), resource)
{{endif}}


@cython.embedsignature(True)
def getLocalRuntimeVersion():
    """ Returns the CUDA Runtime version of local shared library.

    Returns in `*runtimeVersion` the version number of the current CUDA
    Runtime instance. The version is returned as (1000 * major + 10 *
    minor). For example, CUDA 9.2 would be represented by 9020.

    As of CUDA 12.0, this function no longer initializes CUDA. The purpose
    of this API is solely to return a compile-time constant stating the
    CUDA Toolkit version in the above format.

    This function automatically returns :py:obj:`~.cudaErrorInvalidValue`
    if the `runtimeVersion` argument is NULL.

    Returns
    -------
    cudaError_t
        :py:obj:`~.cudaSuccess`, :py:obj:`~.cudaErrorInvalidValue`
    runtimeVersion : int
        Returns the CUDA Runtime version.

    See Also
    --------
    :py:obj:`~.cudaDriverGetVersion`, :py:obj:`~.cuDriverGetVersion`
    """
    cdef int runtimeVersion = 0
    err = cyruntime.getLocalRuntimeVersion(&runtimeVersion)
    return (cudaError_t(err), runtimeVersion)


cdef class cudaBindingsRuntimeGlobal:
    cdef map[void_ptr, void*] _allocated

    def __dealloc__(self):
        for item in self._allocated:
            free(item.second)
        self._allocated.clear()

cdef cudaBindingsRuntimeGlobal m_global = cudaBindingsRuntimeGlobal()


@cython.embedsignature(True)
def sizeof(objType):
    """ Returns the size of provided CUDA Python structure in bytes

    Parameters
    ----------
    objType : Any
        CUDA Python object

    Returns
    -------
    lowered_name : int
        The size of `objType` in bytes
    """
    {{if 'dim3' in found_struct}}
    if objType == dim3:
        return sizeof(cyruntime.dim3){{endif}}
    {{if 'cudaDevResourceDesc_t' in found_types}}
    if objType == cudaDevResourceDesc_t:
        return sizeof(cyruntime.cudaDevResourceDesc_t){{endif}}
    {{if 'cudaExecutionContext_t' in found_types}}
    if objType == cudaExecutionContext_t:
        return sizeof(cyruntime.cudaExecutionContext_t){{endif}}
    {{if 'cudaChannelFormatDesc' in found_struct}}
    if objType == cudaChannelFormatDesc:
        return sizeof(cyruntime.cudaChannelFormatDesc){{endif}}
    {{if 'cudaArray_t' in found_types}}
    if objType == cudaArray_t:
        return sizeof(cyruntime.cudaArray_t){{endif}}
    {{if 'cudaArray_const_t' in found_types}}
    if objType == cudaArray_const_t:
        return sizeof(cyruntime.cudaArray_const_t){{endif}}
    {{if 'cudaMipmappedArray_t' in found_types}}
    if objType == cudaMipmappedArray_t:
        return sizeof(cyruntime.cudaMipmappedArray_t){{endif}}
    {{if 'cudaMipmappedArray_const_t' in found_types}}
    if objType == cudaMipmappedArray_const_t:
        return sizeof(cyruntime.cudaMipmappedArray_const_t){{endif}}
    {{if 'cudaArraySparseProperties' in found_struct}}
    if objType == cudaArraySparseProperties:
        return sizeof(cyruntime.cudaArraySparseProperties){{endif}}
    {{if 'cudaArrayMemoryRequirements' in found_struct}}
    if objType == cudaArrayMemoryRequirements:
        return sizeof(cyruntime.cudaArrayMemoryRequirements){{endif}}
    {{if 'cudaPitchedPtr' in found_struct}}
    if objType == cudaPitchedPtr:
        return sizeof(cyruntime.cudaPitchedPtr){{endif}}
    {{if 'cudaExtent' in found_struct}}
    if objType == cudaExtent:
        return sizeof(cyruntime.cudaExtent){{endif}}
    {{if 'cudaPos' in found_struct}}
    if objType == cudaPos:
        return sizeof(cyruntime.cudaPos){{endif}}
    {{if 'cudaMemcpy3DParms' in found_struct}}
    if objType == cudaMemcpy3DParms:
        return sizeof(cyruntime.cudaMemcpy3DParms){{endif}}
    {{if 'cudaMemcpyNodeParams' in found_struct}}
    if objType == cudaMemcpyNodeParams:
        return sizeof(cyruntime.cudaMemcpyNodeParams){{endif}}
    {{if 'cudaMemcpy3DPeerParms' in found_struct}}
    if objType == cudaMemcpy3DPeerParms:
        return sizeof(cyruntime.cudaMemcpy3DPeerParms){{endif}}
    {{if 'cudaMemsetParams' in found_struct}}
    if objType == cudaMemsetParams:
        return sizeof(cyruntime.cudaMemsetParams){{endif}}
    {{if 'cudaMemsetParamsV2' in found_struct}}
    if objType == cudaMemsetParamsV2:
        return sizeof(cyruntime.cudaMemsetParamsV2){{endif}}
    {{if 'cudaAccessPolicyWindow' in found_struct}}
    if objType == cudaAccessPolicyWindow:
        return sizeof(cyruntime.cudaAccessPolicyWindow){{endif}}
    {{if 'cudaHostFn_t' in found_types}}
    if objType == cudaHostFn_t:
        return sizeof(cyruntime.cudaHostFn_t){{endif}}
    {{if 'cudaHostNodeParams' in found_struct}}
    if objType == cudaHostNodeParams:
        return sizeof(cyruntime.cudaHostNodeParams){{endif}}
    {{if 'cudaHostNodeParamsV2' in found_struct}}
    if objType == cudaHostNodeParamsV2:
        return sizeof(cyruntime.cudaHostNodeParamsV2){{endif}}
    {{if 'cudaResourceDesc' in found_struct}}
    if objType == cudaResourceDesc:
        return sizeof(cyruntime.cudaResourceDesc){{endif}}
    {{if 'cudaResourceViewDesc' in found_struct}}
    if objType == cudaResourceViewDesc:
        return sizeof(cyruntime.cudaResourceViewDesc){{endif}}
    {{if 'cudaPointerAttributes' in found_struct}}
    if objType == cudaPointerAttributes:
        return sizeof(cyruntime.cudaPointerAttributes){{endif}}
    {{if 'cudaFuncAttributes' in found_struct}}
    if objType == cudaFuncAttributes:
        return sizeof(cyruntime.cudaFuncAttributes){{endif}}
    {{if 'cudaMemLocation' in found_struct}}
    if objType == cudaMemLocation:
        return sizeof(cyruntime.cudaMemLocation){{endif}}
    {{if 'cudaMemAccessDesc' in found_struct}}
    if objType == cudaMemAccessDesc:
        return sizeof(cyruntime.cudaMemAccessDesc){{endif}}
    {{if 'cudaMemPoolProps' in found_struct}}
    if objType == cudaMemPoolProps:
        return sizeof(cyruntime.cudaMemPoolProps){{endif}}
    {{if 'cudaMemPoolPtrExportData' in found_struct}}
    if objType == cudaMemPoolPtrExportData:
        return sizeof(cyruntime.cudaMemPoolPtrExportData){{endif}}
    {{if 'cudaMemAllocNodeParams' in found_struct}}
    if objType == cudaMemAllocNodeParams:
        return sizeof(cyruntime.cudaMemAllocNodeParams){{endif}}
    {{if 'cudaMemAllocNodeParamsV2' in found_struct}}
    if objType == cudaMemAllocNodeParamsV2:
        return sizeof(cyruntime.cudaMemAllocNodeParamsV2){{endif}}
    {{if 'cudaMemFreeNodeParams' in found_struct}}
    if objType == cudaMemFreeNodeParams:
        return sizeof(cyruntime.cudaMemFreeNodeParams){{endif}}
    {{if 'cudaMemcpyAttributes' in found_struct}}
    if objType == cudaMemcpyAttributes:
        return sizeof(cyruntime.cudaMemcpyAttributes){{endif}}
    {{if 'cudaOffset3D' in found_struct}}
    if objType == cudaOffset3D:
        return sizeof(cyruntime.cudaOffset3D){{endif}}
    {{if 'cudaMemcpy3DOperand' in found_struct}}
    if objType == cudaMemcpy3DOperand:
        return sizeof(cyruntime.cudaMemcpy3DOperand){{endif}}
    {{if 'cudaMemcpy3DBatchOp' in found_struct}}
    if objType == cudaMemcpy3DBatchOp:
        return sizeof(cyruntime.cudaMemcpy3DBatchOp){{endif}}
    {{if 'CUuuid_st' in found_struct}}
    if objType == CUuuid_st:
        return sizeof(cyruntime.CUuuid_st){{endif}}
    {{if 'CUuuid' in found_types}}
    if objType == CUuuid:
        return sizeof(cyruntime.CUuuid){{endif}}
    {{if 'cudaUUID_t' in found_types}}
    if objType == cudaUUID_t:
        return sizeof(cyruntime.cudaUUID_t){{endif}}
    {{if 'cudaDeviceProp' in found_struct}}
    if objType == cudaDeviceProp:
        return sizeof(cyruntime.cudaDeviceProp){{endif}}
    {{if 'cudaIpcEventHandle_st' in found_struct}}
    if objType == cudaIpcEventHandle_st:
        return sizeof(cyruntime.cudaIpcEventHandle_st){{endif}}
    {{if 'cudaIpcEventHandle_t' in found_types}}
    if objType == cudaIpcEventHandle_t:
        return sizeof(cyruntime.cudaIpcEventHandle_t){{endif}}
    {{if 'cudaIpcMemHandle_st' in found_struct}}
    if objType == cudaIpcMemHandle_st:
        return sizeof(cyruntime.cudaIpcMemHandle_st){{endif}}
    {{if 'cudaIpcMemHandle_t' in found_types}}
    if objType == cudaIpcMemHandle_t:
        return sizeof(cyruntime.cudaIpcMemHandle_t){{endif}}
    {{if 'cudaMemFabricHandle_st' in found_struct}}
    if objType == cudaMemFabricHandle_st:
        return sizeof(cyruntime.cudaMemFabricHandle_st){{endif}}
    {{if 'cudaMemFabricHandle_t' in found_types}}
    if objType == cudaMemFabricHandle_t:
        return sizeof(cyruntime.cudaMemFabricHandle_t){{endif}}
    {{if 'cudaExternalMemoryHandleDesc' in found_struct}}
    if objType == cudaExternalMemoryHandleDesc:
        return sizeof(cyruntime.cudaExternalMemoryHandleDesc){{endif}}
    {{if 'cudaExternalMemoryBufferDesc' in found_struct}}
    if objType == cudaExternalMemoryBufferDesc:
        return sizeof(cyruntime.cudaExternalMemoryBufferDesc){{endif}}
    {{if 'cudaExternalMemoryMipmappedArrayDesc' in found_struct}}
    if objType == cudaExternalMemoryMipmappedArrayDesc:
        return sizeof(cyruntime.cudaExternalMemoryMipmappedArrayDesc){{endif}}
    {{if 'cudaExternalSemaphoreHandleDesc' in found_struct}}
    if objType == cudaExternalSemaphoreHandleDesc:
        return sizeof(cyruntime.cudaExternalSemaphoreHandleDesc){{endif}}
    {{if 'cudaExternalSemaphoreSignalParams' in found_struct}}
    if objType == cudaExternalSemaphoreSignalParams:
        return sizeof(cyruntime.cudaExternalSemaphoreSignalParams){{endif}}
    {{if 'cudaExternalSemaphoreWaitParams' in found_struct}}
    if objType == cudaExternalSemaphoreWaitParams:
        return sizeof(cyruntime.cudaExternalSemaphoreWaitParams){{endif}}
    {{if 'cudaDevSmResource' in found_struct}}
    if objType == cudaDevSmResource:
        return sizeof(cyruntime.cudaDevSmResource){{endif}}
    {{if 'cudaDevWorkqueueConfigResource' in found_struct}}
    if objType == cudaDevWorkqueueConfigResource:
        return sizeof(cyruntime.cudaDevWorkqueueConfigResource){{endif}}
    {{if 'cudaDevWorkqueueResource' in found_struct}}
    if objType == cudaDevWorkqueueResource:
        return sizeof(cyruntime.cudaDevWorkqueueResource){{endif}}
    {{if 'cudaDevSmResourceGroupParams_st' in found_struct}}
    if objType == cudaDevSmResourceGroupParams_st:
        return sizeof(cyruntime.cudaDevSmResourceGroupParams_st){{endif}}
    {{if 'cudaDevSmResourceGroupParams' in found_types}}
    if objType == cudaDevSmResourceGroupParams:
        return sizeof(cyruntime.cudaDevSmResourceGroupParams){{endif}}
    {{if 'cudaDevResource_st' in found_struct}}
    if objType == cudaDevResource_st:
        return sizeof(cyruntime.cudaDevResource_st){{endif}}
    {{if 'cudaDevResource' in found_types}}
    if objType == cudaDevResource:
        return sizeof(cyruntime.cudaDevResource){{endif}}
    {{if 'cudaStream_t' in found_types}}
    if objType == cudaStream_t:
        return sizeof(cyruntime.cudaStream_t){{endif}}
    {{if 'cudaEvent_t' in found_types}}
    if objType == cudaEvent_t:
        return sizeof(cyruntime.cudaEvent_t){{endif}}
    {{if 'cudaGraphicsResource_t' in found_types}}
    if objType == cudaGraphicsResource_t:
        return sizeof(cyruntime.cudaGraphicsResource_t){{endif}}
    {{if 'cudaExternalMemory_t' in found_types}}
    if objType == cudaExternalMemory_t:
        return sizeof(cyruntime.cudaExternalMemory_t){{endif}}
    {{if 'cudaExternalSemaphore_t' in found_types}}
    if objType == cudaExternalSemaphore_t:
        return sizeof(cyruntime.cudaExternalSemaphore_t){{endif}}
    {{if 'cudaGraph_t' in found_types}}
    if objType == cudaGraph_t:
        return sizeof(cyruntime.cudaGraph_t){{endif}}
    {{if 'cudaGraphNode_t' in found_types}}
    if objType == cudaGraphNode_t:
        return sizeof(cyruntime.cudaGraphNode_t){{endif}}
    {{if 'cudaUserObject_t' in found_types}}
    if objType == cudaUserObject_t:
        return sizeof(cyruntime.cudaUserObject_t){{endif}}
    {{if 'cudaGraphConditionalHandle' in found_types}}
    if objType == cudaGraphConditionalHandle:
        return sizeof(cyruntime.cudaGraphConditionalHandle){{endif}}
    {{if 'cudaFunction_t' in found_types}}
    if objType == cudaFunction_t:
        return sizeof(cyruntime.cudaFunction_t){{endif}}
    {{if 'cudaKernel_t' in found_types}}
    if objType == cudaKernel_t:
        return sizeof(cyruntime.cudaKernel_t){{endif}}
    {{if 'cudalibraryHostUniversalFunctionAndDataTable' in found_struct}}
    if objType == cudalibraryHostUniversalFunctionAndDataTable:
        return sizeof(cyruntime.cudalibraryHostUniversalFunctionAndDataTable){{endif}}
    {{if 'cudaLibrary_t' in found_types}}
    if objType == cudaLibrary_t:
        return sizeof(cyruntime.cudaLibrary_t){{endif}}
    {{if 'cudaMemPool_t' in found_types}}
    if objType == cudaMemPool_t:
        return sizeof(cyruntime.cudaMemPool_t){{endif}}
    {{if 'cudaKernelNodeParams' in found_struct}}
    if objType == cudaKernelNodeParams:
        return sizeof(cyruntime.cudaKernelNodeParams){{endif}}
    {{if 'cudaKernelNodeParamsV2' in found_struct}}
    if objType == cudaKernelNodeParamsV2:
        return sizeof(cyruntime.cudaKernelNodeParamsV2){{endif}}
    {{if 'cudaExternalSemaphoreSignalNodeParams' in found_struct}}
    if objType == cudaExternalSemaphoreSignalNodeParams:
        return sizeof(cyruntime.cudaExternalSemaphoreSignalNodeParams){{endif}}
    {{if 'cudaExternalSemaphoreSignalNodeParamsV2' in found_struct}}
    if objType == cudaExternalSemaphoreSignalNodeParamsV2:
        return sizeof(cyruntime.cudaExternalSemaphoreSignalNodeParamsV2){{endif}}
    {{if 'cudaExternalSemaphoreWaitNodeParams' in found_struct}}
    if objType == cudaExternalSemaphoreWaitNodeParams:
        return sizeof(cyruntime.cudaExternalSemaphoreWaitNodeParams){{endif}}
    {{if 'cudaExternalSemaphoreWaitNodeParamsV2' in found_struct}}
    if objType == cudaExternalSemaphoreWaitNodeParamsV2:
        return sizeof(cyruntime.cudaExternalSemaphoreWaitNodeParamsV2){{endif}}
    {{if 'cudaConditionalNodeParams' in found_struct}}
    if objType == cudaConditionalNodeParams:
        return sizeof(cyruntime.cudaConditionalNodeParams){{endif}}
    {{if 'cudaChildGraphNodeParams' in found_struct}}
    if objType == cudaChildGraphNodeParams:
        return sizeof(cyruntime.cudaChildGraphNodeParams){{endif}}
    {{if 'cudaEventRecordNodeParams' in found_struct}}
    if objType == cudaEventRecordNodeParams:
        return sizeof(cyruntime.cudaEventRecordNodeParams){{endif}}
    {{if 'cudaEventWaitNodeParams' in found_struct}}
    if objType == cudaEventWaitNodeParams:
        return sizeof(cyruntime.cudaEventWaitNodeParams){{endif}}
    {{if 'cudaGraphNodeParams' in found_struct}}
    if objType == cudaGraphNodeParams:
        return sizeof(cyruntime.cudaGraphNodeParams){{endif}}
    {{if 'cudaGraphEdgeData_st' in found_struct}}
    if objType == cudaGraphEdgeData_st:
        return sizeof(cyruntime.cudaGraphEdgeData_st){{endif}}
    {{if 'cudaGraphEdgeData' in found_types}}
    if objType == cudaGraphEdgeData:
        return sizeof(cyruntime.cudaGraphEdgeData){{endif}}
    {{if 'cudaGraphExec_t' in found_types}}
    if objType == cudaGraphExec_t:
        return sizeof(cyruntime.cudaGraphExec_t){{endif}}
    {{if 'cudaGraphInstantiateParams_st' in found_struct}}
    if objType == cudaGraphInstantiateParams_st:
        return sizeof(cyruntime.cudaGraphInstantiateParams_st){{endif}}
    {{if 'cudaGraphInstantiateParams' in found_types}}
    if objType == cudaGraphInstantiateParams:
        return sizeof(cyruntime.cudaGraphInstantiateParams){{endif}}
    {{if 'cudaGraphExecUpdateResultInfo_st' in found_struct}}
    if objType == cudaGraphExecUpdateResultInfo_st:
        return sizeof(cyruntime.cudaGraphExecUpdateResultInfo_st){{endif}}
    {{if 'cudaGraphExecUpdateResultInfo' in found_types}}
    if objType == cudaGraphExecUpdateResultInfo:
        return sizeof(cyruntime.cudaGraphExecUpdateResultInfo){{endif}}
    {{if 'cudaGraphDeviceNode_t' in found_types}}
    if objType == cudaGraphDeviceNode_t:
        return sizeof(cyruntime.cudaGraphDeviceNode_t){{endif}}
    {{if 'cudaGraphKernelNodeUpdate' in found_struct}}
    if objType == cudaGraphKernelNodeUpdate:
        return sizeof(cyruntime.cudaGraphKernelNodeUpdate){{endif}}
    {{if 'cudaLaunchMemSyncDomainMap_st' in found_struct}}
    if objType == cudaLaunchMemSyncDomainMap_st:
        return sizeof(cyruntime.cudaLaunchMemSyncDomainMap_st){{endif}}
    {{if 'cudaLaunchMemSyncDomainMap' in found_types}}
    if objType == cudaLaunchMemSyncDomainMap:
        return sizeof(cyruntime.cudaLaunchMemSyncDomainMap){{endif}}
    {{if 'cudaLaunchAttributeValue' in found_struct}}
    if objType == cudaLaunchAttributeValue:
        return sizeof(cyruntime.cudaLaunchAttributeValue){{endif}}
    {{if 'cudaLaunchAttribute_st' in found_struct}}
    if objType == cudaLaunchAttribute_st:
        return sizeof(cyruntime.cudaLaunchAttribute_st){{endif}}
    {{if 'cudaLaunchAttribute' in found_types}}
    if objType == cudaLaunchAttribute:
        return sizeof(cyruntime.cudaLaunchAttribute){{endif}}
    {{if 'cudaAsyncCallbackHandle_t' in found_types}}
    if objType == cudaAsyncCallbackHandle_t:
        return sizeof(cyruntime.cudaAsyncCallbackHandle_t){{endif}}
    {{if 'cudaAsyncNotificationInfo' in found_struct}}
    if objType == cudaAsyncNotificationInfo:
        return sizeof(cyruntime.cudaAsyncNotificationInfo){{endif}}
    {{if 'cudaAsyncNotificationInfo_t' in found_types}}
    if objType == cudaAsyncNotificationInfo_t:
        return sizeof(cyruntime.cudaAsyncNotificationInfo_t){{endif}}
    {{if 'cudaAsyncCallback' in found_types}}
    if objType == cudaAsyncCallback:
        return sizeof(cyruntime.cudaAsyncCallback){{endif}}
    {{if 'cudaLogsCallbackHandle' in found_types}}
    if objType == cudaLogsCallbackHandle:
        return sizeof(cyruntime.cudaLogsCallbackHandle){{endif}}
    {{if 'cudaLogIterator' in found_types}}
    if objType == cudaLogIterator:
        return sizeof(cyruntime.cudaLogIterator){{endif}}
    {{if 'cudaSurfaceObject_t' in found_types}}
    if objType == cudaSurfaceObject_t:
        return sizeof(cyruntime.cudaSurfaceObject_t){{endif}}
    {{if 'cudaTextureDesc' in found_struct}}
    if objType == cudaTextureDesc:
        return sizeof(cyruntime.cudaTextureDesc){{endif}}
    {{if 'cudaTextureObject_t' in found_types}}
    if objType == cudaTextureObject_t:
        return sizeof(cyruntime.cudaTextureObject_t){{endif}}
    {{if 'cudaStreamCallback_t' in found_types}}
    if objType == cudaStreamCallback_t:
        return sizeof(cyruntime.cudaStreamCallback_t){{endif}}
    {{if 'cudaLogsCallback_t' in found_types}}
    if objType == cudaLogsCallback_t:
        return sizeof(cyruntime.cudaLogsCallback_t){{endif}}
    {{if True}}
    if objType == GLenum:
        return sizeof(cyruntime.GLenum){{endif}}
    {{if True}}
    if objType == GLuint:
        return sizeof(cyruntime.GLuint){{endif}}
    {{if True}}
    if objType == EGLImageKHR:
        return sizeof(cyruntime.EGLImageKHR){{endif}}
    {{if True}}
    if objType == EGLStreamKHR:
        return sizeof(cyruntime.EGLStreamKHR){{endif}}
    {{if True}}
    if objType == EGLint:
        return sizeof(cyruntime.EGLint){{endif}}
    {{if True}}
    if objType == EGLSyncKHR:
        return sizeof(cyruntime.EGLSyncKHR){{endif}}
    {{if True}}
    if objType == VdpDevice:
        return sizeof(cyruntime.VdpDevice){{endif}}
    {{if True}}
    if objType == VdpGetProcAddress:
        return sizeof(cyruntime.VdpGetProcAddress){{endif}}
    {{if True}}
    if objType == VdpVideoSurface:
        return sizeof(cyruntime.VdpVideoSurface){{endif}}
    {{if True}}
    if objType == VdpOutputSurface:
        return sizeof(cyruntime.VdpOutputSurface){{endif}}
    {{if 'cudaStreamAttrValue' in found_types}}
    if objType == cudaStreamAttrValue:
        return sizeof(cyruntime.cudaStreamAttrValue){{endif}}
    {{if 'cudaKernelNodeAttrValue' in found_types}}
    if objType == cudaKernelNodeAttrValue:
        return sizeof(cyruntime.cudaKernelNodeAttrValue){{endif}}
    {{if True}}
    if objType == cudaEglPlaneDesc_st:
        return sizeof(cyruntime.cudaEglPlaneDesc_st){{endif}}
    {{if True}}
    if objType == cudaEglPlaneDesc:
        return sizeof(cyruntime.cudaEglPlaneDesc){{endif}}
    {{if True}}
    if objType == cudaEglFrame_st:
        return sizeof(cyruntime.cudaEglFrame_st){{endif}}
    {{if True}}
    if objType == cudaEglFrame:
        return sizeof(cyruntime.cudaEglFrame){{endif}}
    {{if True}}
    if objType == cudaEglStreamConnection:
        return sizeof(cyruntime.cudaEglStreamConnection){{endif}}
    raise TypeError("Unknown type: " + str(objType))

cdef int _add_native_handle_getters() except?-1:
    from cuda.bindings.utils import _add_cuda_native_handle_getter
    {{if 'cudaDevResourceDesc_t' in found_types}}
    def cudaDevResourceDesc_t_getter(cudaDevResourceDesc_t x): return <uintptr_t><void*><cyruntime.cudaDevResourceDesc_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaDevResourceDesc_t, cudaDevResourceDesc_t_getter)
    {{endif}}
    {{if 'cudaExecutionContext_t' in found_types}}
    def cudaExecutionContext_t_getter(cudaExecutionContext_t x): return <uintptr_t><void*><cyruntime.cudaExecutionContext_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaExecutionContext_t, cudaExecutionContext_t_getter)
    {{endif}}
    {{if 'cudaArray_t' in found_types}}
    def cudaArray_t_getter(cudaArray_t x): return <uintptr_t><void*><cyruntime.cudaArray_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaArray_t, cudaArray_t_getter)
    {{endif}}
    {{if 'cudaArray_const_t' in found_types}}
    def cudaArray_const_t_getter(cudaArray_const_t x): return <uintptr_t><void*><cyruntime.cudaArray_const_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaArray_const_t, cudaArray_const_t_getter)
    {{endif}}
    {{if 'cudaMipmappedArray_t' in found_types}}
    def cudaMipmappedArray_t_getter(cudaMipmappedArray_t x): return <uintptr_t><void*><cyruntime.cudaMipmappedArray_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaMipmappedArray_t, cudaMipmappedArray_t_getter)
    {{endif}}
    {{if 'cudaMipmappedArray_const_t' in found_types}}
    def cudaMipmappedArray_const_t_getter(cudaMipmappedArray_const_t x): return <uintptr_t><void*><cyruntime.cudaMipmappedArray_const_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaMipmappedArray_const_t, cudaMipmappedArray_const_t_getter)
    {{endif}}
    {{if 'cudaStream_t' in found_types}}
    def cudaStream_t_getter(cudaStream_t x): return <uintptr_t><void*><cyruntime.cudaStream_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaStream_t, cudaStream_t_getter)
    {{endif}}
    {{if 'cudaEvent_t' in found_types}}
    def cudaEvent_t_getter(cudaEvent_t x): return <uintptr_t><void*><cyruntime.cudaEvent_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaEvent_t, cudaEvent_t_getter)
    {{endif}}
    {{if 'cudaGraphicsResource_t' in found_types}}
    def cudaGraphicsResource_t_getter(cudaGraphicsResource_t x): return <uintptr_t><void*><cyruntime.cudaGraphicsResource_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaGraphicsResource_t, cudaGraphicsResource_t_getter)
    {{endif}}
    {{if 'cudaExternalMemory_t' in found_types}}
    def cudaExternalMemory_t_getter(cudaExternalMemory_t x): return <uintptr_t><void*><cyruntime.cudaExternalMemory_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaExternalMemory_t, cudaExternalMemory_t_getter)
    {{endif}}
    {{if 'cudaExternalSemaphore_t' in found_types}}
    def cudaExternalSemaphore_t_getter(cudaExternalSemaphore_t x): return <uintptr_t><void*><cyruntime.cudaExternalSemaphore_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaExternalSemaphore_t, cudaExternalSemaphore_t_getter)
    {{endif}}
    {{if 'cudaGraph_t' in found_types}}
    def cudaGraph_t_getter(cudaGraph_t x): return <uintptr_t><void*><cyruntime.cudaGraph_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaGraph_t, cudaGraph_t_getter)
    {{endif}}
    {{if 'cudaGraphNode_t' in found_types}}
    def cudaGraphNode_t_getter(cudaGraphNode_t x): return <uintptr_t><void*><cyruntime.cudaGraphNode_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaGraphNode_t, cudaGraphNode_t_getter)
    {{endif}}
    {{if 'cudaUserObject_t' in found_types}}
    def cudaUserObject_t_getter(cudaUserObject_t x): return <uintptr_t><void*><cyruntime.cudaUserObject_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaUserObject_t, cudaUserObject_t_getter)
    {{endif}}
    {{if 'cudaFunction_t' in found_types}}
    def cudaFunction_t_getter(cudaFunction_t x): return <uintptr_t><void*><cyruntime.cudaFunction_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaFunction_t, cudaFunction_t_getter)
    {{endif}}
    {{if 'cudaKernel_t' in found_types}}
    def cudaKernel_t_getter(cudaKernel_t x): return <uintptr_t><void*><cyruntime.cudaKernel_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaKernel_t, cudaKernel_t_getter)
    {{endif}}
    {{if 'cudaLibrary_t' in found_types}}
    def cudaLibrary_t_getter(cudaLibrary_t x): return <uintptr_t><void*><cyruntime.cudaLibrary_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaLibrary_t, cudaLibrary_t_getter)
    {{endif}}
    {{if 'cudaMemPool_t' in found_types}}
    def cudaMemPool_t_getter(cudaMemPool_t x): return <uintptr_t><void*><cyruntime.cudaMemPool_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaMemPool_t, cudaMemPool_t_getter)
    {{endif}}
    {{if 'cudaGraphExec_t' in found_types}}
    def cudaGraphExec_t_getter(cudaGraphExec_t x): return <uintptr_t><void*><cyruntime.cudaGraphExec_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaGraphExec_t, cudaGraphExec_t_getter)
    {{endif}}
    {{if 'cudaGraphDeviceNode_t' in found_types}}
    def cudaGraphDeviceNode_t_getter(cudaGraphDeviceNode_t x): return <uintptr_t><void*><cyruntime.cudaGraphDeviceNode_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaGraphDeviceNode_t, cudaGraphDeviceNode_t_getter)
    {{endif}}
    {{if 'cudaAsyncCallbackHandle_t' in found_types}}
    def cudaAsyncCallbackHandle_t_getter(cudaAsyncCallbackHandle_t x): return <uintptr_t><void*><cyruntime.cudaAsyncCallbackHandle_t>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaAsyncCallbackHandle_t, cudaAsyncCallbackHandle_t_getter)
    {{endif}}
    {{if 'cudaLogsCallbackHandle' in found_types}}
    def cudaLogsCallbackHandle_getter(cudaLogsCallbackHandle x): return <uintptr_t><void*><cyruntime.cudaLogsCallbackHandle>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaLogsCallbackHandle, cudaLogsCallbackHandle_getter)
    {{endif}}
    {{if True}}
    def EGLImageKHR_getter(EGLImageKHR x): return <uintptr_t><void*><cyruntime.EGLImageKHR>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(EGLImageKHR, EGLImageKHR_getter)
    {{endif}}
    {{if True}}
    def EGLStreamKHR_getter(EGLStreamKHR x): return <uintptr_t><void*><cyruntime.EGLStreamKHR>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(EGLStreamKHR, EGLStreamKHR_getter)
    {{endif}}
    {{if True}}
    def EGLSyncKHR_getter(EGLSyncKHR x): return <uintptr_t><void*><cyruntime.EGLSyncKHR>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(EGLSyncKHR, EGLSyncKHR_getter)
    {{endif}}
    {{if True}}
    def cudaEglStreamConnection_getter(cudaEglStreamConnection x): return <uintptr_t><void*><cyruntime.cudaEglStreamConnection>(x._pvt_ptr[0])
    _add_cuda_native_handle_getter(cudaEglStreamConnection, cudaEglStreamConnection_getter)
    {{endif}}
    return 0
_add_native_handle_getters()

