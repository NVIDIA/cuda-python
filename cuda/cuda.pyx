# Copyright 2021-2022 NVIDIA Corporation.  All rights reserved.
#
# Please refer to the NVIDIA end user license agreement (EULA) associated
# with this source code for terms and conditions that govern your use of
# this software. Any use, reproduction, disclosure, or distribution of
# this software and related documentation outside the terms of the EULA
# is strictly prohibited.
from typing import List, Tuple, Any
from enum import IntEnum
import cython
import ctypes
from libc.stdlib cimport calloc, free
from libc.string cimport memcpy
from libc.stdint cimport int32_t, uint32_t, int64_t, uint64_t
from libc.stddef cimport wchar_t
from libc.limits cimport CHAR_MIN
from libcpp.vector cimport vector
from cpython.buffer cimport PyObject_CheckBuffer, PyObject_GetBuffer, PyBuffer_Release, PyBUF_SIMPLE, PyBUF_ANY_CONTIGUOUS
from cpython.bytes cimport PyBytes_FromStringAndSize

ctypedef unsigned long long signed_char_ptr
ctypedef unsigned long long unsigned_char_ptr
ctypedef unsigned long long char_ptr
ctypedef unsigned long long short_ptr
ctypedef unsigned long long unsigned_short_ptr
ctypedef unsigned long long int_ptr
ctypedef unsigned long long long_int_ptr
ctypedef unsigned long long long_long_int_ptr
ctypedef unsigned long long unsigned_int_ptr
ctypedef unsigned long long unsigned_long_int_ptr
ctypedef unsigned long long unsigned_long_long_int_ptr
ctypedef unsigned long long uint32_t_ptr
ctypedef unsigned long long uint64_t_ptr
ctypedef unsigned long long int32_t_ptr
ctypedef unsigned long long int64_t_ptr
ctypedef unsigned long long unsigned_ptr
ctypedef unsigned long long unsigned_long_long_ptr
ctypedef unsigned long long size_t_ptr
ctypedef unsigned long long float_ptr
ctypedef unsigned long long double_ptr
ctypedef unsigned long long void_ptr

#: CUDA API version number
CUDA_VERSION = ccuda.CUDA_VERSION

#: CUDA IPC handle size
CU_IPC_HANDLE_SIZE = ccuda.CU_IPC_HANDLE_SIZE

#: Legacy stream handle
#:
#: Stream handle that can be passed as a CUstream to use an implicit stream
#: with legacy synchronization behavior.
#:
#: See details of the \link_sync_behavior
CU_STREAM_LEGACY = ccuda.CU_STREAM_LEGACY

#: Per-thread stream handle
#:
#: Stream handle that can be passed as a CUstream to use an implicit stream
#: with per-thread synchronization behavior.
#:
#: See details of the \link_sync_behavior
CU_STREAM_PER_THREAD = ccuda.CU_STREAM_PER_THREAD

#: If set, host memory is portable between CUDA contexts. Flag for
#: :py:obj:`~.cuMemHostAlloc()`
CU_MEMHOSTALLOC_PORTABLE = ccuda.CU_MEMHOSTALLOC_PORTABLE

#: If set, host memory is mapped into CUDA address space and
#: :py:obj:`~.cuMemHostGetDevicePointer()` may be called on the host
#: pointer. Flag for :py:obj:`~.cuMemHostAlloc()`
CU_MEMHOSTALLOC_DEVICEMAP = ccuda.CU_MEMHOSTALLOC_DEVICEMAP

#: If set, host memory is allocated as write-combined - fast to write,
#: faster to DMA, slow to read except via SSE4 streaming load instruction
#: (MOVNTDQA). Flag for :py:obj:`~.cuMemHostAlloc()`
CU_MEMHOSTALLOC_WRITECOMBINED = ccuda.CU_MEMHOSTALLOC_WRITECOMBINED

#: If set, host memory is portable between CUDA contexts. Flag for
#: :py:obj:`~.cuMemHostRegister()`
CU_MEMHOSTREGISTER_PORTABLE = ccuda.CU_MEMHOSTREGISTER_PORTABLE

#: If set, host memory is mapped into CUDA address space and
#: :py:obj:`~.cuMemHostGetDevicePointer()` may be called on the host
#: pointer. Flag for :py:obj:`~.cuMemHostRegister()`
CU_MEMHOSTREGISTER_DEVICEMAP = ccuda.CU_MEMHOSTREGISTER_DEVICEMAP

#: If set, the passed memory pointer is treated as pointing to some memory-
#: mapped I/O space, e.g. belonging to a third-party PCIe device. On
#: Windows the flag is a no-op. On Linux that memory is marked as non
#: cache-coherent for the GPU and is expected to be physically contiguous.
#: It may return :py:obj:`~.CUDA_ERROR_NOT_PERMITTED` if run as an
#: unprivileged user, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED` on older Linux
#: kernel versions. On all other platforms, it is not supported and
#: :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED` is returned. Flag for
#: :py:obj:`~.cuMemHostRegister()`
CU_MEMHOSTREGISTER_IOMEMORY = ccuda.CU_MEMHOSTREGISTER_IOMEMORY

#: If set, the passed memory pointer is treated as pointing to memory that
#: is considered read-only by the device. On platforms without
#: :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
#: this flag is required in order to register memory mapped to the CPU as
#: read-only. Support for the use of this flag can be queried from the
#: device attribute
#: :py:obj:`~.CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED`. Using
#: this flag with a current context associated with a device that does not
#: have this attribute set will cause :py:obj:`~.cuMemHostRegister` to
#: error with :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`.
CU_MEMHOSTREGISTER_READ_ONLY = ccuda.CU_MEMHOSTREGISTER_READ_ONLY

#: Indicates that the layered sparse CUDA array or CUDA mipmapped array has
#: a single mip tail region for all layers
CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL = ccuda.CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL

#: Indicates that the external memory object is a dedicated resource
CUDA_EXTERNAL_MEMORY_DEDICATED = ccuda.CUDA_EXTERNAL_MEMORY_DEDICATED

#: When the `flags` parameter of
#: :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS` contains this flag, it
#: indicates that signaling an external semaphore object should skip
#: performing appropriate memory synchronization operations over all the
#: external memory objects that are imported as
#: :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF`, which otherwise are
#: performed by default to ensure data coherency with other importers of
#: the same NvSciBuf memory objects.
CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC = ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC

#: When the `flags` parameter of
#: :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS` contains this flag, it
#: indicates that waiting on an external semaphore object should skip
#: performing appropriate memory synchronization operations over all the
#: external memory objects that are imported as
#: :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF`, which otherwise are
#: performed by default to ensure data coherency with other importers of
#: the same NvSciBuf memory objects.
CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC = ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC

#: When `flags` of :py:obj:`~.cuDeviceGetNvSciSyncAttributes` is set to
#: this, it indicates that application needs signaler specific
#: NvSciSyncAttr to be filled by
#: :py:obj:`~.cuDeviceGetNvSciSyncAttributes`.
CUDA_NVSCISYNC_ATTR_SIGNAL = ccuda.CUDA_NVSCISYNC_ATTR_SIGNAL

#: When `flags` of :py:obj:`~.cuDeviceGetNvSciSyncAttributes` is set to
#: this, it indicates that application needs waiter specific NvSciSyncAttr
#: to be filled by :py:obj:`~.cuDeviceGetNvSciSyncAttributes`.
CUDA_NVSCISYNC_ATTR_WAIT = ccuda.CUDA_NVSCISYNC_ATTR_WAIT

#: This flag if set indicates that the memory will be used as a tile pool.
CU_MEM_CREATE_USAGE_TILE_POOL = ccuda.CU_MEM_CREATE_USAGE_TILE_POOL

#: If set, each kernel launched as part of
#: :py:obj:`~.cuLaunchCooperativeKernelMultiDevice` only waits for prior
#: work in the stream corresponding to that GPU to complete before the
#: kernel begins execution.
CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC = ccuda.CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC

#: If set, any subsequent work pushed in a stream that participated in a
#: call to :py:obj:`~.cuLaunchCooperativeKernelMultiDevice` will only wait
#: for the kernel launched on the GPU corresponding to that stream to
#: complete before it begins execution.
CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC = ccuda.CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC

#: If set, the CUDA array is a collection of layers, where each layer is
#: either a 1D or a 2D array and the Depth member of
#: CUDA_ARRAY3D_DESCRIPTOR specifies the number of layers, not the depth of
#: a 3D array.
CUDA_ARRAY3D_LAYERED = ccuda.CUDA_ARRAY3D_LAYERED

#: Deprecated, use CUDA_ARRAY3D_LAYERED
CUDA_ARRAY3D_2DARRAY = ccuda.CUDA_ARRAY3D_2DARRAY

#: This flag must be set in order to bind a surface reference to the CUDA
#: array
CUDA_ARRAY3D_SURFACE_LDST = ccuda.CUDA_ARRAY3D_SURFACE_LDST

#: If set, the CUDA array is a collection of six 2D arrays, representing
#: faces of a cube. The width of such a CUDA array must be equal to its
#: height, and Depth must be six. If :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag
#: is also set, then the CUDA array is a collection of cubemaps and Depth
#: must be a multiple of six.
CUDA_ARRAY3D_CUBEMAP = ccuda.CUDA_ARRAY3D_CUBEMAP

#: This flag must be set in order to perform texture gather operations on a
#: CUDA array.
CUDA_ARRAY3D_TEXTURE_GATHER = ccuda.CUDA_ARRAY3D_TEXTURE_GATHER

#: This flag if set indicates that the CUDA array is a DEPTH_TEXTURE.
CUDA_ARRAY3D_DEPTH_TEXTURE = ccuda.CUDA_ARRAY3D_DEPTH_TEXTURE

#: This flag indicates that the CUDA array may be bound as a color target
#: in an external graphics API
CUDA_ARRAY3D_COLOR_ATTACHMENT = ccuda.CUDA_ARRAY3D_COLOR_ATTACHMENT

#: This flag if set indicates that the CUDA array or CUDA mipmapped array
#: is a sparse CUDA array or CUDA mipmapped array respectively
CUDA_ARRAY3D_SPARSE = ccuda.CUDA_ARRAY3D_SPARSE

#: This flag if set indicates that the CUDA array or CUDA mipmapped array
#: will allow deferred memory mapping
CUDA_ARRAY3D_DEFERRED_MAPPING = ccuda.CUDA_ARRAY3D_DEFERRED_MAPPING

#: Override the texref format with a format inferred from the array. Flag
#: for :py:obj:`~.cuTexRefSetArray()`
CU_TRSA_OVERRIDE_FORMAT = ccuda.CU_TRSA_OVERRIDE_FORMAT

#: Read the texture as integers rather than promoting the values to floats
#: in the range [0,1]. Flag for :py:obj:`~.cuTexRefSetFlags()` and
#: :py:obj:`~.cuTexObjectCreate()`
CU_TRSF_READ_AS_INTEGER = ccuda.CU_TRSF_READ_AS_INTEGER

#: Use normalized texture coordinates in the range [0,1) instead of
#: [0,dim). Flag for :py:obj:`~.cuTexRefSetFlags()` and
#: :py:obj:`~.cuTexObjectCreate()`
CU_TRSF_NORMALIZED_COORDINATES = ccuda.CU_TRSF_NORMALIZED_COORDINATES

#: Perform sRGB->linear conversion during texture read. Flag for
#: :py:obj:`~.cuTexRefSetFlags()` and :py:obj:`~.cuTexObjectCreate()`
CU_TRSF_SRGB = ccuda.CU_TRSF_SRGB

#: Disable any trilinear filtering optimizations. Flag for
#: :py:obj:`~.cuTexRefSetFlags()` and :py:obj:`~.cuTexObjectCreate()`
CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION = ccuda.CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION

#: Enable seamless cube map filtering. Flag for
#: :py:obj:`~.cuTexObjectCreate()`
CU_TRSF_SEAMLESS_CUBEMAP = ccuda.CU_TRSF_SEAMLESS_CUBEMAP

#: C++ compile time constant for CU_LAUNCH_PARAM_END
CU_LAUNCH_PARAM_END_AS_INT = ccuda.CU_LAUNCH_PARAM_END_AS_INT

#: End of array terminator for the `extra` parameter to
#: :py:obj:`~.cuLaunchKernel`
CU_LAUNCH_PARAM_END = ccuda.CU_LAUNCH_PARAM_END

#: C++ compile time constant for CU_LAUNCH_PARAM_BUFFER_POINTER
CU_LAUNCH_PARAM_BUFFER_POINTER_AS_INT = ccuda.CU_LAUNCH_PARAM_BUFFER_POINTER_AS_INT

#: Indicator that the next value in the `extra` parameter to
#: :py:obj:`~.cuLaunchKernel` will be a pointer to a buffer containing all
#: kernel parameters used for launching kernel `f`. This buffer needs to
#: honor all alignment/padding requirements of the individual parameters.
#: If :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_SIZE` is not also specified in the
#: `extra` array, then :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER` will have
#: no effect.
CU_LAUNCH_PARAM_BUFFER_POINTER = ccuda.CU_LAUNCH_PARAM_BUFFER_POINTER

#: C++ compile time constant for CU_LAUNCH_PARAM_BUFFER_SIZE
CU_LAUNCH_PARAM_BUFFER_SIZE_AS_INT = ccuda.CU_LAUNCH_PARAM_BUFFER_SIZE_AS_INT

#: Indicator that the next value in the `extra` parameter to
#: :py:obj:`~.cuLaunchKernel` will be a pointer to a size_t which contains
#: the size of the buffer specified with
#: :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER`. It is required that
#: :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER` also be specified in the
#: `extra` array if the value associated with
#: :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_SIZE` is not zero.
CU_LAUNCH_PARAM_BUFFER_SIZE = ccuda.CU_LAUNCH_PARAM_BUFFER_SIZE

#: For texture references loaded into the module, use default texunit from
#: texture reference.
CU_PARAM_TR_DEFAULT = ccuda.CU_PARAM_TR_DEFAULT

#: Device that represents the CPU
CU_DEVICE_CPU = ccuda.CU_DEVICE_CPU

#: Device that represents an invalid device
CU_DEVICE_INVALID = ccuda.CU_DEVICE_INVALID

#: Maximum number of planes per frame
MAX_PLANES = ccuda.MAX_PLANES

#: Indicates that timeout for :py:obj:`~.cuEGLStreamConsumerAcquireFrame`
#: is infinite.
CUDA_EGL_INFINITE_TIMEOUT = ccuda.CUDA_EGL_INFINITE_TIMEOUT

class CUipcMem_flags(IntEnum):
    """
    CUDA Ipc Mem Flags
    """

    #: Automatically enable peer access between remote devices as needed
    CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = ccuda.CUipcMem_flags_enum.CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS

class CUmemAttach_flags(IntEnum):
    """
    CUDA Mem Attach Flags
    """

    #: Memory can be accessed by any stream on any device
    CU_MEM_ATTACH_GLOBAL = ccuda.CUmemAttach_flags_enum.CU_MEM_ATTACH_GLOBAL

    #: Memory cannot be accessed by any stream on any device
    CU_MEM_ATTACH_HOST = ccuda.CUmemAttach_flags_enum.CU_MEM_ATTACH_HOST

    #: Memory can only be accessed by a single stream on the associated
    #: device
    CU_MEM_ATTACH_SINGLE = ccuda.CUmemAttach_flags_enum.CU_MEM_ATTACH_SINGLE

class CUctx_flags(IntEnum):
    """
    Context creation flags
    """

    #: Automatic scheduling
    CU_CTX_SCHED_AUTO = ccuda.CUctx_flags_enum.CU_CTX_SCHED_AUTO

    #: Set spin as default scheduling
    CU_CTX_SCHED_SPIN = ccuda.CUctx_flags_enum.CU_CTX_SCHED_SPIN

    #: Set yield as default scheduling
    CU_CTX_SCHED_YIELD = ccuda.CUctx_flags_enum.CU_CTX_SCHED_YIELD

    #: Set blocking synchronization as default scheduling
    CU_CTX_SCHED_BLOCKING_SYNC = ccuda.CUctx_flags_enum.CU_CTX_SCHED_BLOCKING_SYNC

    #: Set blocking synchronization as default scheduling [Deprecated]
    CU_CTX_BLOCKING_SYNC = ccuda.CUctx_flags_enum.CU_CTX_BLOCKING_SYNC
    CU_CTX_SCHED_MASK = ccuda.CUctx_flags_enum.CU_CTX_SCHED_MASK

    #: [Deprecated]
    CU_CTX_MAP_HOST = ccuda.CUctx_flags_enum.CU_CTX_MAP_HOST

    #: Keep local memory allocation after launch
    CU_CTX_LMEM_RESIZE_TO_MAX = ccuda.CUctx_flags_enum.CU_CTX_LMEM_RESIZE_TO_MAX
    CU_CTX_FLAGS_MASK = ccuda.CUctx_flags_enum.CU_CTX_FLAGS_MASK

class CUstream_flags(IntEnum):
    """
    Stream creation flags
    """

    #: Default stream flag
    CU_STREAM_DEFAULT = ccuda.CUstream_flags_enum.CU_STREAM_DEFAULT

    #: Stream does not synchronize with stream 0 (the NULL stream)
    CU_STREAM_NON_BLOCKING = ccuda.CUstream_flags_enum.CU_STREAM_NON_BLOCKING

class CUevent_flags(IntEnum):
    """
    Event creation flags
    """

    #: Default event flag
    CU_EVENT_DEFAULT = ccuda.CUevent_flags_enum.CU_EVENT_DEFAULT

    #: Event uses blocking synchronization
    CU_EVENT_BLOCKING_SYNC = ccuda.CUevent_flags_enum.CU_EVENT_BLOCKING_SYNC

    #: Event will not record timing data
    CU_EVENT_DISABLE_TIMING = ccuda.CUevent_flags_enum.CU_EVENT_DISABLE_TIMING

    #: Event is suitable for interprocess use. CU_EVENT_DISABLE_TIMING must
    #: be set
    CU_EVENT_INTERPROCESS = ccuda.CUevent_flags_enum.CU_EVENT_INTERPROCESS

class CUevent_record_flags(IntEnum):
    """
    Event record flags
    """

    #: Default event record flag
    CU_EVENT_RECORD_DEFAULT = ccuda.CUevent_record_flags_enum.CU_EVENT_RECORD_DEFAULT

    #: When using stream capture, create an event record node instead of
    #: the default behavior. This flag is invalid when used outside of
    #: capture.
    CU_EVENT_RECORD_EXTERNAL = ccuda.CUevent_record_flags_enum.CU_EVENT_RECORD_EXTERNAL

class CUevent_wait_flags(IntEnum):
    """
    Event wait flags
    """

    #: Default event wait flag
    CU_EVENT_WAIT_DEFAULT = ccuda.CUevent_wait_flags_enum.CU_EVENT_WAIT_DEFAULT

    #: When using stream capture, create an event wait node instead of the
    #: default behavior. This flag is invalid when used outside of capture.
    CU_EVENT_WAIT_EXTERNAL = ccuda.CUevent_wait_flags_enum.CU_EVENT_WAIT_EXTERNAL

class CUstreamWaitValue_flags(IntEnum):
    """
    Flags for :py:obj:`~.cuStreamWaitValue32` and
    :py:obj:`~.cuStreamWaitValue64`
    """

    #: Wait until (int32_t)(*addr - value) >= 0 (or int64_t for 64 bit
    #: values). Note this is a cyclic comparison which ignores wraparound.
    #: (Default behavior.)
    CU_STREAM_WAIT_VALUE_GEQ = ccuda.CUstreamWaitValue_flags_enum.CU_STREAM_WAIT_VALUE_GEQ

    #: Wait until *addr == value.
    CU_STREAM_WAIT_VALUE_EQ = ccuda.CUstreamWaitValue_flags_enum.CU_STREAM_WAIT_VALUE_EQ

    #: Wait until (*addr & value) != 0.
    CU_STREAM_WAIT_VALUE_AND = ccuda.CUstreamWaitValue_flags_enum.CU_STREAM_WAIT_VALUE_AND

    #: Wait until ~(*addr | value) != 0. Support for this operation can be
    #: queried with :py:obj:`~.cuDeviceGetAttribute()` and
    #: :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR`.
    CU_STREAM_WAIT_VALUE_NOR = ccuda.CUstreamWaitValue_flags_enum.CU_STREAM_WAIT_VALUE_NOR

    #: Follow the wait operation with a flush of outstanding remote writes.
    #: This means that, if a remote write operation is guaranteed to have
    #: reached the device before the wait can be satisfied, that write is
    #: guaranteed to be visible to downstream device work. The device is
    #: permitted to reorder remote writes internally. For example, this
    #: flag would be required if two remote writes arrive in a defined
    #: order, the wait is satisfied by the second write, and downstream
    #: work needs to observe the first write. Support for this operation is
    #: restricted to selected platforms and can be queried with
    #: :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_WAIT_VALUE_FLUSH`.
    CU_STREAM_WAIT_VALUE_FLUSH = ccuda.CUstreamWaitValue_flags_enum.CU_STREAM_WAIT_VALUE_FLUSH

class CUstreamWriteValue_flags(IntEnum):
    """
    Flags for :py:obj:`~.cuStreamWriteValue32`
    """

    #: Default behavior
    CU_STREAM_WRITE_VALUE_DEFAULT = ccuda.CUstreamWriteValue_flags_enum.CU_STREAM_WRITE_VALUE_DEFAULT

    #: Permits the write to be reordered with writes which were issued
    #: before it, as a performance optimization. Normally,
    #: :py:obj:`~.cuStreamWriteValue32` will provide a memory fence before
    #: the write, which has similar semantics to __threadfence_system() but
    #: is scoped to the stream rather than a CUDA thread. This flag is not
    #: supported in the v2 API.
    CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER = ccuda.CUstreamWriteValue_flags_enum.CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER

class CUstreamBatchMemOpType(IntEnum):
    """
    Operations for :py:obj:`~.cuStreamBatchMemOp`
    """

    #: Represents a :py:obj:`~.cuStreamWaitValue32` operation
    CU_STREAM_MEM_OP_WAIT_VALUE_32 = ccuda.CUstreamBatchMemOpType_enum.CU_STREAM_MEM_OP_WAIT_VALUE_32

    #: Represents a :py:obj:`~.cuStreamWriteValue32` operation
    CU_STREAM_MEM_OP_WRITE_VALUE_32 = ccuda.CUstreamBatchMemOpType_enum.CU_STREAM_MEM_OP_WRITE_VALUE_32

    #: Represents a :py:obj:`~.cuStreamWaitValue64` operation
    CU_STREAM_MEM_OP_WAIT_VALUE_64 = ccuda.CUstreamBatchMemOpType_enum.CU_STREAM_MEM_OP_WAIT_VALUE_64

    #: Represents a :py:obj:`~.cuStreamWriteValue64` operation
    CU_STREAM_MEM_OP_WRITE_VALUE_64 = ccuda.CUstreamBatchMemOpType_enum.CU_STREAM_MEM_OP_WRITE_VALUE_64

    #: Insert a memory barrier of the specified type
    CU_STREAM_MEM_OP_BARRIER = ccuda.CUstreamBatchMemOpType_enum.CU_STREAM_MEM_OP_BARRIER

    #: This has the same effect as :py:obj:`~.CU_STREAM_WAIT_VALUE_FLUSH`,
    #: but as a standalone operation.
    CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES = ccuda.CUstreamBatchMemOpType_enum.CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES

class CUstreamMemoryBarrier_flags(IntEnum):
    """
    Flags for :py:obj:`~.cuStreamMemoryBarrier`
    """

    #: System-wide memory barrier.
    CU_STREAM_MEMORY_BARRIER_TYPE_SYS = ccuda.CUstreamMemoryBarrier_flags_enum.CU_STREAM_MEMORY_BARRIER_TYPE_SYS

    #: Limit memory barrier scope to the GPU.
    CU_STREAM_MEMORY_BARRIER_TYPE_GPU = ccuda.CUstreamMemoryBarrier_flags_enum.CU_STREAM_MEMORY_BARRIER_TYPE_GPU

class CUoccupancy_flags(IntEnum):
    """
    Occupancy calculator flag
    """

    #: Default behavior
    CU_OCCUPANCY_DEFAULT = ccuda.CUoccupancy_flags_enum.CU_OCCUPANCY_DEFAULT

    #: Assume global caching is enabled and cannot be automatically turned
    #: off
    CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE = ccuda.CUoccupancy_flags_enum.CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE

class CUstreamUpdateCaptureDependencies_flags(IntEnum):
    """
    Flags for :py:obj:`~.cuStreamUpdateCaptureDependencies`
    """

    #: Add new nodes to the dependency set
    CU_STREAM_ADD_CAPTURE_DEPENDENCIES = ccuda.CUstreamUpdateCaptureDependencies_flags_enum.CU_STREAM_ADD_CAPTURE_DEPENDENCIES

    #: Replace the dependency set with the new nodes
    CU_STREAM_SET_CAPTURE_DEPENDENCIES = ccuda.CUstreamUpdateCaptureDependencies_flags_enum.CU_STREAM_SET_CAPTURE_DEPENDENCIES

class CUarray_format(IntEnum):
    """
    Array formats
    """

    #: Unsigned 8-bit integers
    CU_AD_FORMAT_UNSIGNED_INT8 = ccuda.CUarray_format_enum.CU_AD_FORMAT_UNSIGNED_INT8

    #: Unsigned 16-bit integers
    CU_AD_FORMAT_UNSIGNED_INT16 = ccuda.CUarray_format_enum.CU_AD_FORMAT_UNSIGNED_INT16

    #: Unsigned 32-bit integers
    CU_AD_FORMAT_UNSIGNED_INT32 = ccuda.CUarray_format_enum.CU_AD_FORMAT_UNSIGNED_INT32

    #: Signed 8-bit integers
    CU_AD_FORMAT_SIGNED_INT8 = ccuda.CUarray_format_enum.CU_AD_FORMAT_SIGNED_INT8

    #: Signed 16-bit integers
    CU_AD_FORMAT_SIGNED_INT16 = ccuda.CUarray_format_enum.CU_AD_FORMAT_SIGNED_INT16

    #: Signed 32-bit integers
    CU_AD_FORMAT_SIGNED_INT32 = ccuda.CUarray_format_enum.CU_AD_FORMAT_SIGNED_INT32

    #: 16-bit floating point
    CU_AD_FORMAT_HALF = ccuda.CUarray_format_enum.CU_AD_FORMAT_HALF

    #: 32-bit floating point
    CU_AD_FORMAT_FLOAT = ccuda.CUarray_format_enum.CU_AD_FORMAT_FLOAT

    #: 8-bit YUV planar format, with 4:2:0 sampling
    CU_AD_FORMAT_NV12 = ccuda.CUarray_format_enum.CU_AD_FORMAT_NV12

    #: 1 channel unsigned 8-bit normalized integer
    CU_AD_FORMAT_UNORM_INT8X1 = ccuda.CUarray_format_enum.CU_AD_FORMAT_UNORM_INT8X1

    #: 2 channel unsigned 8-bit normalized integer
    CU_AD_FORMAT_UNORM_INT8X2 = ccuda.CUarray_format_enum.CU_AD_FORMAT_UNORM_INT8X2

    #: 4 channel unsigned 8-bit normalized integer
    CU_AD_FORMAT_UNORM_INT8X4 = ccuda.CUarray_format_enum.CU_AD_FORMAT_UNORM_INT8X4

    #: 1 channel unsigned 16-bit normalized integer
    CU_AD_FORMAT_UNORM_INT16X1 = ccuda.CUarray_format_enum.CU_AD_FORMAT_UNORM_INT16X1

    #: 2 channel unsigned 16-bit normalized integer
    CU_AD_FORMAT_UNORM_INT16X2 = ccuda.CUarray_format_enum.CU_AD_FORMAT_UNORM_INT16X2

    #: 4 channel unsigned 16-bit normalized integer
    CU_AD_FORMAT_UNORM_INT16X4 = ccuda.CUarray_format_enum.CU_AD_FORMAT_UNORM_INT16X4

    #: 1 channel signed 8-bit normalized integer
    CU_AD_FORMAT_SNORM_INT8X1 = ccuda.CUarray_format_enum.CU_AD_FORMAT_SNORM_INT8X1

    #: 2 channel signed 8-bit normalized integer
    CU_AD_FORMAT_SNORM_INT8X2 = ccuda.CUarray_format_enum.CU_AD_FORMAT_SNORM_INT8X2

    #: 4 channel signed 8-bit normalized integer
    CU_AD_FORMAT_SNORM_INT8X4 = ccuda.CUarray_format_enum.CU_AD_FORMAT_SNORM_INT8X4

    #: 1 channel signed 16-bit normalized integer
    CU_AD_FORMAT_SNORM_INT16X1 = ccuda.CUarray_format_enum.CU_AD_FORMAT_SNORM_INT16X1

    #: 2 channel signed 16-bit normalized integer
    CU_AD_FORMAT_SNORM_INT16X2 = ccuda.CUarray_format_enum.CU_AD_FORMAT_SNORM_INT16X2

    #: 4 channel signed 16-bit normalized integer
    CU_AD_FORMAT_SNORM_INT16X4 = ccuda.CUarray_format_enum.CU_AD_FORMAT_SNORM_INT16X4

    #: 4 channel unsigned normalized block-compressed (BC1 compression)
    #: format
    CU_AD_FORMAT_BC1_UNORM = ccuda.CUarray_format_enum.CU_AD_FORMAT_BC1_UNORM

    #: 4 channel unsigned normalized block-compressed (BC1 compression)
    #: format with sRGB encoding
    CU_AD_FORMAT_BC1_UNORM_SRGB = ccuda.CUarray_format_enum.CU_AD_FORMAT_BC1_UNORM_SRGB

    #: 4 channel unsigned normalized block-compressed (BC2 compression)
    #: format
    CU_AD_FORMAT_BC2_UNORM = ccuda.CUarray_format_enum.CU_AD_FORMAT_BC2_UNORM

    #: 4 channel unsigned normalized block-compressed (BC2 compression)
    #: format with sRGB encoding
    CU_AD_FORMAT_BC2_UNORM_SRGB = ccuda.CUarray_format_enum.CU_AD_FORMAT_BC2_UNORM_SRGB

    #: 4 channel unsigned normalized block-compressed (BC3 compression)
    #: format
    CU_AD_FORMAT_BC3_UNORM = ccuda.CUarray_format_enum.CU_AD_FORMAT_BC3_UNORM

    #: 4 channel unsigned normalized block-compressed (BC3 compression)
    #: format with sRGB encoding
    CU_AD_FORMAT_BC3_UNORM_SRGB = ccuda.CUarray_format_enum.CU_AD_FORMAT_BC3_UNORM_SRGB

    #: 1 channel unsigned normalized block-compressed (BC4 compression)
    #: format
    CU_AD_FORMAT_BC4_UNORM = ccuda.CUarray_format_enum.CU_AD_FORMAT_BC4_UNORM

    #: 1 channel signed normalized block-compressed (BC4 compression)
    #: format
    CU_AD_FORMAT_BC4_SNORM = ccuda.CUarray_format_enum.CU_AD_FORMAT_BC4_SNORM

    #: 2 channel unsigned normalized block-compressed (BC5 compression)
    #: format
    CU_AD_FORMAT_BC5_UNORM = ccuda.CUarray_format_enum.CU_AD_FORMAT_BC5_UNORM

    #: 2 channel signed normalized block-compressed (BC5 compression)
    #: format
    CU_AD_FORMAT_BC5_SNORM = ccuda.CUarray_format_enum.CU_AD_FORMAT_BC5_SNORM

    #: 3 channel unsigned half-float block-compressed (BC6H compression)
    #: format
    CU_AD_FORMAT_BC6H_UF16 = ccuda.CUarray_format_enum.CU_AD_FORMAT_BC6H_UF16

    #: 3 channel signed half-float block-compressed (BC6H compression)
    #: format
    CU_AD_FORMAT_BC6H_SF16 = ccuda.CUarray_format_enum.CU_AD_FORMAT_BC6H_SF16

    #: 4 channel unsigned normalized block-compressed (BC7 compression)
    #: format
    CU_AD_FORMAT_BC7_UNORM = ccuda.CUarray_format_enum.CU_AD_FORMAT_BC7_UNORM

    #: 4 channel unsigned normalized block-compressed (BC7 compression)
    #: format with sRGB encoding
    CU_AD_FORMAT_BC7_UNORM_SRGB = ccuda.CUarray_format_enum.CU_AD_FORMAT_BC7_UNORM_SRGB

class CUaddress_mode(IntEnum):
    """
    Texture reference addressing modes
    """

    #: Wrapping address mode
    CU_TR_ADDRESS_MODE_WRAP = ccuda.CUaddress_mode_enum.CU_TR_ADDRESS_MODE_WRAP

    #: Clamp to edge address mode
    CU_TR_ADDRESS_MODE_CLAMP = ccuda.CUaddress_mode_enum.CU_TR_ADDRESS_MODE_CLAMP

    #: Mirror address mode
    CU_TR_ADDRESS_MODE_MIRROR = ccuda.CUaddress_mode_enum.CU_TR_ADDRESS_MODE_MIRROR

    #: Border address mode
    CU_TR_ADDRESS_MODE_BORDER = ccuda.CUaddress_mode_enum.CU_TR_ADDRESS_MODE_BORDER

class CUfilter_mode(IntEnum):
    """
    Texture reference filtering modes
    """

    #: Point filter mode
    CU_TR_FILTER_MODE_POINT = ccuda.CUfilter_mode_enum.CU_TR_FILTER_MODE_POINT

    #: Linear filter mode
    CU_TR_FILTER_MODE_LINEAR = ccuda.CUfilter_mode_enum.CU_TR_FILTER_MODE_LINEAR

class CUdevice_attribute(IntEnum):
    """
    Device properties
    """

    #: Maximum number of threads per block
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK

    #: Maximum block dimension X
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X

    #: Maximum block dimension Y
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y

    #: Maximum block dimension Z
    CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z

    #: Maximum grid dimension X
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X

    #: Maximum grid dimension Y
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y

    #: Maximum grid dimension Z
    CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z

    #: Maximum shared memory available per block in bytes
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK

    #: Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK
    CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK

    #: Memory available on device for constant variables in a CUDA C kernel
    #: in bytes
    CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY

    #: Warp size in threads
    CU_DEVICE_ATTRIBUTE_WARP_SIZE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_WARP_SIZE

    #: Maximum pitch in bytes allowed by memory copies
    CU_DEVICE_ATTRIBUTE_MAX_PITCH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_PITCH

    #: Maximum number of 32-bit registers available per block
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK

    #: Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK
    CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK

    #: Typical clock frequency in kilohertz
    CU_DEVICE_ATTRIBUTE_CLOCK_RATE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CLOCK_RATE

    #: Alignment requirement for textures
    CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT

    #: Device can possibly copy memory and execute a kernel concurrently.
    #: Deprecated. Use instead CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT.
    CU_DEVICE_ATTRIBUTE_GPU_OVERLAP = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GPU_OVERLAP

    #: Number of multiprocessors on device
    CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT

    #: Specifies whether there is a run time limit on kernels
    CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT

    #: Device is integrated with host memory
    CU_DEVICE_ATTRIBUTE_INTEGRATED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_INTEGRATED

    #: Device can map host memory into CUDA address space
    CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY

    #: Compute mode (See :py:obj:`~.CUcomputemode` for details)
    CU_DEVICE_ATTRIBUTE_COMPUTE_MODE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COMPUTE_MODE

    #: Maximum 1D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH

    #: Maximum 2D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH

    #: Maximum 2D texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT

    #: Maximum 3D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH

    #: Maximum 3D texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT

    #: Maximum 3D texture depth
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH

    #: Maximum 2D layered texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH

    #: Maximum 2D layered texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT

    #: Maximum layers in a 2D layered texture
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS

    #: Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH

    #: Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT

    #: Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES

    #: Alignment requirement for surfaces
    CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT

    #: Device can possibly execute multiple kernels concurrently
    CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS

    #: Device has ECC support enabled
    CU_DEVICE_ATTRIBUTE_ECC_ENABLED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_ECC_ENABLED

    #: PCI bus ID of the device
    CU_DEVICE_ATTRIBUTE_PCI_BUS_ID = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_PCI_BUS_ID

    #: PCI device ID of the device
    CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID

    #: Device is using TCC driver model
    CU_DEVICE_ATTRIBUTE_TCC_DRIVER = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_TCC_DRIVER

    #: Peak memory clock frequency in kilohertz
    CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE

    #: Global memory bus width in bits
    CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH

    #: Size of L2 cache in bytes
    CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE

    #: Maximum resident threads per multiprocessor
    CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR

    #: Number of asynchronous engines
    CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT

    #: Device shares a unified address space with the host
    CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING

    #: Maximum 1D layered texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH

    #: Maximum layers in a 1D layered texture
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS

    #: Deprecated, do not use.
    CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER

    #: Maximum 2D texture width if CUDA_ARRAY3D_TEXTURE_GATHER is set
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH

    #: Maximum 2D texture height if CUDA_ARRAY3D_TEXTURE_GATHER is set
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT

    #: Alternate maximum 3D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE

    #: Alternate maximum 3D texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE

    #: Alternate maximum 3D texture depth
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE

    #: PCI domain ID of the device
    CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID

    #: Pitch alignment requirement for textures
    CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT

    #: Maximum cubemap texture width/height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH

    #: Maximum cubemap layered texture width/height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH

    #: Maximum layers in a cubemap layered texture
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS

    #: Maximum 1D surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH

    #: Maximum 2D surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH

    #: Maximum 2D surface height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT

    #: Maximum 3D surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH

    #: Maximum 3D surface height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT

    #: Maximum 3D surface depth
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH

    #: Maximum 1D layered surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH

    #: Maximum layers in a 1D layered surface
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS

    #: Maximum 2D layered surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH

    #: Maximum 2D layered surface height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT

    #: Maximum layers in a 2D layered surface
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS

    #: Maximum cubemap surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH

    #: Maximum cubemap layered surface width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH

    #: Maximum layers in a cubemap layered surface
    CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS

    #: Deprecated, do not use. Use cudaDeviceGetTexture1DLinearMaxWidth()
    #: or :py:obj:`~.cuDeviceGetTexture1DLinearMaxWidth()` instead.
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH

    #: Maximum 2D linear texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH

    #: Maximum 2D linear texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT

    #: Maximum 2D linear texture pitch in bytes
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH

    #: Maximum mipmapped 2D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH

    #: Maximum mipmapped 2D texture height
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT

    #: Major compute capability version number
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR

    #: Minor compute capability version number
    CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR

    #: Maximum mipmapped 1D texture width
    CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH

    #: Device supports stream priorities
    CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED

    #: Device supports caching globals in L1
    CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED

    #: Device supports caching locals in L1
    CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED

    #: Maximum shared memory available per multiprocessor in bytes
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR

    #: Maximum number of 32-bit registers available per multiprocessor
    CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR

    #: Device can allocate managed memory on this system
    CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY

    #: Device is on a multi-GPU board
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD

    #: Unique id for a group of devices on the same multi-GPU board
    CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID

    #: Link between the device and the host supports native atomic
    #: operations (this is a placeholder attribute, and is not supported on
    #: any current hardware)
    CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED

    #: Ratio of single precision performance (in floating-point operations
    #: per second) to double precision performance
    CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO

    #: Device supports coherently accessing pageable memory without calling
    #: cudaHostRegister on it
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS

    #: Device can coherently access managed memory concurrently with the
    #: CPU
    CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS

    #: Device supports compute preemption.
    CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED

    #: Device can access host registered memory at the same virtual address
    #: as the CPU
    CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM

    #: :py:obj:`~.cuStreamBatchMemOp` and related APIs are supported.
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS

    #: 64-bit operations are supported in :py:obj:`~.cuStreamBatchMemOp`
    #: and related APIs.
    CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS

    #: :py:obj:`~.CU_STREAM_WAIT_VALUE_NOR` is supported.
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR

    #: Device supports launching cooperative kernels via
    #: :py:obj:`~.cuLaunchCooperativeKernel`
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH

    #: Deprecated, :py:obj:`~.cuLaunchCooperativeKernelMultiDevice` is
    #: deprecated.
    CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH

    #: Maximum optin shared memory per block
    CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN

    #: The :py:obj:`~.CU_STREAM_WAIT_VALUE_FLUSH` flag and the
    #: :py:obj:`~.CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES` MemOp are supported
    #: on the device. See :py:obj:`~.Stream Memory Operations` for
    #: additional details.
    CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES

    #: Device supports host memory registration via
    #: :py:obj:`~.cudaHostRegister`.
    CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED

    #: Device accesses pageable memory via the host's page tables.
    CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES

    #: The host can directly access managed memory on the device without
    #: migration.
    CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST

    #: Deprecated, Use
    #: CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED
    CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED

    #: Device supports virtual memory management APIs like
    #: :py:obj:`~.cuMemAddressReserve`, :py:obj:`~.cuMemCreate`,
    #: :py:obj:`~.cuMemMap` and related APIs
    CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED

    #: Device supports exporting memory to a posix file descriptor with
    #: :py:obj:`~.cuMemExportToShareableHandle`, if requested via
    #: :py:obj:`~.cuMemCreate`
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED

    #: Device supports exporting memory to a Win32 NT handle with
    #: :py:obj:`~.cuMemExportToShareableHandle`, if requested via
    #: :py:obj:`~.cuMemCreate`
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED

    #: Device supports exporting memory to a Win32 KMT handle with
    #: :py:obj:`~.cuMemExportToShareableHandle`, if requested via
    #: :py:obj:`~.cuMemCreate`
    CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED

    #: Maximum number of blocks per multiprocessor
    CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR

    #: Device supports compression of memory
    CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED

    #: Maximum L2 persisting lines capacity setting in bytes.
    CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE

    #: Maximum value of :py:obj:`~.CUaccessPolicyWindow.num_bytes`.
    CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE

    #: Device supports specifying the GPUDirect RDMA flag with
    #: :py:obj:`~.cuMemCreate`
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED

    #: Shared memory reserved by CUDA driver per block in bytes
    CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK

    #: Device supports sparse CUDA arrays and sparse CUDA mipmapped arrays
    CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED

    #: Device supports using the :py:obj:`~.cuMemHostRegister` flag
    #: :py:obj:`~.CU_MEMHOSTERGISTER_READ_ONLY` to register memory that
    #: must be mapped as read-only to the GPU
    CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED

    #: External timeline semaphore interop is supported on the device
    CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED

    #: Device supports using the :py:obj:`~.cuMemAllocAsync` and
    #: :py:obj:`~.cuMemPool` family of APIs
    CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED

    #: Device supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see
    #: https://docs.nvidia.com/cuda/gpudirect-rdma for more information)
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED

    #: The returned attribute shall be interpreted as a bitmask, where the
    #: individual bits are described by the
    #: :py:obj:`~.CUflushGPUDirectRDMAWritesOptions` enum
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS

    #: GPUDirect RDMA writes to the device do not need to be flushed for
    #: consumers within the scope indicated by the returned attribute. See
    #: :py:obj:`~.CUGPUDirectRDMAWritesOrdering` for the numerical values
    #: returned here.
    CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING

    #: Handle types supported with mempool based IPC
    CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES

    #: Device supports deferred mapping CUDA arrays and CUDA mipmapped
    #: arrays
    CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED

    #: 64-bit operations are supported in :py:obj:`~.cuStreamBatchMemOp_v2`
    #: and related v2 MemOp APIs.
    CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V2 = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V2

    #: :py:obj:`~.CU_STREAM_WAIT_VALUE_NOR` is supported by v2 MemOp APIs.
    CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V2 = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V2

    #: Device supports buffer sharing with dma_buf mechanism.
    CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED
    CU_DEVICE_ATTRIBUTE_MAX = ccuda.CUdevice_attribute_enum.CU_DEVICE_ATTRIBUTE_MAX

class CUpointer_attribute(IntEnum):
    """
    Pointer information
    """

    #: The :py:obj:`~.CUcontext` on which a pointer was allocated or
    #: registered
    CU_POINTER_ATTRIBUTE_CONTEXT = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_CONTEXT

    #: The :py:obj:`~.CUmemorytype` describing the physical location of a
    #: pointer
    CU_POINTER_ATTRIBUTE_MEMORY_TYPE = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_MEMORY_TYPE

    #: The address at which a pointer's memory may be accessed on the
    #: device
    CU_POINTER_ATTRIBUTE_DEVICE_POINTER = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_DEVICE_POINTER

    #: The address at which a pointer's memory may be accessed on the host
    CU_POINTER_ATTRIBUTE_HOST_POINTER = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_HOST_POINTER

    #: A pair of tokens for use with the nv-p2p.h Linux kernel interface
    CU_POINTER_ATTRIBUTE_P2P_TOKENS = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_P2P_TOKENS

    #: Synchronize every synchronous memory operation initiated on this
    #: region
    CU_POINTER_ATTRIBUTE_SYNC_MEMOPS = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_SYNC_MEMOPS

    #: A process-wide unique ID for an allocated memory region
    CU_POINTER_ATTRIBUTE_BUFFER_ID = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_BUFFER_ID

    #: Indicates if the pointer points to managed memory
    CU_POINTER_ATTRIBUTE_IS_MANAGED = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_IS_MANAGED

    #: A device ordinal of a device on which a pointer was allocated or
    #: registered
    CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL

    #: 1 if this pointer maps to an allocation that is suitable for
    #: :py:obj:`~.cudaIpcGetMemHandle`, 0 otherwise
    CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE

    #: Starting address for this requested pointer
    CU_POINTER_ATTRIBUTE_RANGE_START_ADDR = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_RANGE_START_ADDR

    #: Size of the address range for this requested pointer
    CU_POINTER_ATTRIBUTE_RANGE_SIZE = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_RANGE_SIZE

    #: 1 if this pointer is in a valid address range that is mapped to a
    #: backing allocation, 0 otherwise
    CU_POINTER_ATTRIBUTE_MAPPED = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_MAPPED

    #: Bitmask of allowed :py:obj:`~.CUmemAllocationHandleType` for this
    #: allocation
    CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES

    #: 1 if the memory this pointer is referencing can be used with the
    #: GPUDirect RDMA API
    CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE

    #: Returns the access flags the device associated with the current
    #: context has on the corresponding memory referenced by the pointer
    #: given
    CU_POINTER_ATTRIBUTE_ACCESS_FLAGS = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_ACCESS_FLAGS

    #: Returns the mempool handle for the allocation if it was allocated
    #: from a mempool. Otherwise returns NULL.
    CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE

    #: Size of the actual underlying mapping that the pointer belongs to
    CU_POINTER_ATTRIBUTE_MAPPING_SIZE = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_MAPPING_SIZE

    #: The start address of the mapping that the pointer belongs to
    CU_POINTER_ATTRIBUTE_MAPPING_BASE_ADDR = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_MAPPING_BASE_ADDR

    #: A process-wide unique id corresponding to the physical allocation
    #: the pointer belongs to
    CU_POINTER_ATTRIBUTE_MEMORY_BLOCK_ID = ccuda.CUpointer_attribute_enum.CU_POINTER_ATTRIBUTE_MEMORY_BLOCK_ID

class CUfunction_attribute(IntEnum):
    """
    Function properties
    """

    #: The maximum number of threads per block, beyond which a launch of
    #: the function would fail. This number depends on both the function
    #: and the device on which the function is currently loaded.
    CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK

    #: The size in bytes of statically-allocated shared memory required by
    #: this function. This does not include dynamically-allocated shared
    #: memory requested by the user at runtime.
    CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES

    #: The size in bytes of user-allocated constant memory required by this
    #: function.
    CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES

    #: The size in bytes of local memory used by each thread of this
    #: function.
    CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES

    #: The number of registers used by each thread of this function.
    CU_FUNC_ATTRIBUTE_NUM_REGS = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_NUM_REGS

    #: The PTX virtual architecture version for which the function was
    #: compiled. This value is the major PTX version * 10 + the minor PTX
    #: version, so a PTX version 1.3 function would return the value 13.
    #: Note that this may return the undefined value of 0 for cubins
    #: compiled prior to CUDA 3.0.
    CU_FUNC_ATTRIBUTE_PTX_VERSION = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_PTX_VERSION

    #: The binary architecture version for which the function was compiled.
    #: This value is the major binary version * 10 + the minor binary
    #: version, so a binary version 1.3 function would return the value 13.
    #: Note that this will return a value of 10 for legacy cubins that do
    #: not have a properly-encoded binary architecture version.
    CU_FUNC_ATTRIBUTE_BINARY_VERSION = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_BINARY_VERSION

    #: The attribute to indicate whether the function has been compiled
    #: with user specified option "-Xptxas --dlcm=ca" set .
    CU_FUNC_ATTRIBUTE_CACHE_MODE_CA = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_CACHE_MODE_CA

    #: The maximum size in bytes of dynamically-allocated shared memory
    #: that can be used by this function. If the user-specified dynamic
    #: shared memory size is larger than this value, the launch will fail.
    #: See :py:obj:`~.cuFuncSetAttribute`
    CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES

    #: On devices where the L1 cache and shared memory use the same
    #: hardware resources, this sets the shared memory carveout preference,
    #: in percent of the total shared memory. Refer to
    #: :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR`.
    #: This is only a hint, and the driver can choose a different ratio if
    #: required to execute the function. See :py:obj:`~.cuFuncSetAttribute`
    CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT
    CU_FUNC_ATTRIBUTE_MAX = ccuda.CUfunction_attribute_enum.CU_FUNC_ATTRIBUTE_MAX

class CUfunc_cache(IntEnum):
    """
    Function cache configurations
    """

    #: no preference for shared memory or L1 (default)
    CU_FUNC_CACHE_PREFER_NONE = ccuda.CUfunc_cache_enum.CU_FUNC_CACHE_PREFER_NONE

    #: prefer larger shared memory and smaller L1 cache
    CU_FUNC_CACHE_PREFER_SHARED = ccuda.CUfunc_cache_enum.CU_FUNC_CACHE_PREFER_SHARED

    #: prefer larger L1 cache and smaller shared memory
    CU_FUNC_CACHE_PREFER_L1 = ccuda.CUfunc_cache_enum.CU_FUNC_CACHE_PREFER_L1

    #: prefer equal sized L1 cache and shared memory
    CU_FUNC_CACHE_PREFER_EQUAL = ccuda.CUfunc_cache_enum.CU_FUNC_CACHE_PREFER_EQUAL

class CUsharedconfig(IntEnum):
    """
    Shared memory configurations
    """

    #: set default shared memory bank size
    CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE = ccuda.CUsharedconfig_enum.CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE

    #: set shared memory bank width to four bytes
    CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE = ccuda.CUsharedconfig_enum.CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE

    #: set shared memory bank width to eight bytes
    CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE = ccuda.CUsharedconfig_enum.CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE

class CUshared_carveout(IntEnum):
    """
    Shared memory carveout configurations. These may be passed to
    :py:obj:`~.cuFuncSetAttribute`
    """

    #: No preference for shared memory or L1 (default)
    CU_SHAREDMEM_CARVEOUT_DEFAULT = ccuda.CUshared_carveout_enum.CU_SHAREDMEM_CARVEOUT_DEFAULT

    #: Prefer maximum available shared memory, minimum L1 cache
    CU_SHAREDMEM_CARVEOUT_MAX_SHARED = ccuda.CUshared_carveout_enum.CU_SHAREDMEM_CARVEOUT_MAX_SHARED

    #: Prefer maximum available L1 cache, minimum shared memory
    CU_SHAREDMEM_CARVEOUT_MAX_L1 = ccuda.CUshared_carveout_enum.CU_SHAREDMEM_CARVEOUT_MAX_L1

class CUmemorytype(IntEnum):
    """
    Memory types
    """

    #: Host memory
    CU_MEMORYTYPE_HOST = ccuda.CUmemorytype_enum.CU_MEMORYTYPE_HOST

    #: Device memory
    CU_MEMORYTYPE_DEVICE = ccuda.CUmemorytype_enum.CU_MEMORYTYPE_DEVICE

    #: Array memory
    CU_MEMORYTYPE_ARRAY = ccuda.CUmemorytype_enum.CU_MEMORYTYPE_ARRAY

    #: Unified device or host memory
    CU_MEMORYTYPE_UNIFIED = ccuda.CUmemorytype_enum.CU_MEMORYTYPE_UNIFIED

class CUcomputemode(IntEnum):
    """
    Compute Modes
    """

    #: Default compute mode (Multiple contexts allowed per device)
    CU_COMPUTEMODE_DEFAULT = ccuda.CUcomputemode_enum.CU_COMPUTEMODE_DEFAULT

    #: Compute-prohibited mode (No contexts can be created on this device
    #: at this time)
    CU_COMPUTEMODE_PROHIBITED = ccuda.CUcomputemode_enum.CU_COMPUTEMODE_PROHIBITED

    #: Compute-exclusive-process mode (Only one context used by a single
    #: process can be present on this device at a time)
    CU_COMPUTEMODE_EXCLUSIVE_PROCESS = ccuda.CUcomputemode_enum.CU_COMPUTEMODE_EXCLUSIVE_PROCESS

class CUmem_advise(IntEnum):
    """
    Memory advise values
    """

    #: Data will mostly be read and only occassionally be written to
    CU_MEM_ADVISE_SET_READ_MOSTLY = ccuda.CUmem_advise_enum.CU_MEM_ADVISE_SET_READ_MOSTLY

    #: Undo the effect of :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY`
    CU_MEM_ADVISE_UNSET_READ_MOSTLY = ccuda.CUmem_advise_enum.CU_MEM_ADVISE_UNSET_READ_MOSTLY

    #: Set the preferred location for the data as the specified device
    CU_MEM_ADVISE_SET_PREFERRED_LOCATION = ccuda.CUmem_advise_enum.CU_MEM_ADVISE_SET_PREFERRED_LOCATION

    #: Clear the preferred location for the data
    CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION = ccuda.CUmem_advise_enum.CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION

    #: Data will be accessed by the specified device, so prevent page
    #: faults as much as possible
    CU_MEM_ADVISE_SET_ACCESSED_BY = ccuda.CUmem_advise_enum.CU_MEM_ADVISE_SET_ACCESSED_BY

    #: Let the Unified Memory subsystem decide on the page faulting policy
    #: for the specified device
    CU_MEM_ADVISE_UNSET_ACCESSED_BY = ccuda.CUmem_advise_enum.CU_MEM_ADVISE_UNSET_ACCESSED_BY

class CUmem_range_attribute(IntEnum):
    """

    """

    #: Whether the range will mostly be read and only occassionally be
    #: written to
    CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY = ccuda.CUmem_range_attribute_enum.CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY

    #: The preferred location of the range
    CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION = ccuda.CUmem_range_attribute_enum.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION

    #: Memory range has :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY` set for
    #: specified device
    CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY = ccuda.CUmem_range_attribute_enum.CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY

    #: The last location to which the range was prefetched
    CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION = ccuda.CUmem_range_attribute_enum.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION

class CUjit_option(IntEnum):
    """
    Online compiler and linker options
    """

    #: Max number of registers that a thread may use.
    #: Option type: unsigned int
    #: Applies to: compiler only
    CU_JIT_MAX_REGISTERS = ccuda.CUjit_option_enum.CU_JIT_MAX_REGISTERS

    #: IN: Specifies minimum number of threads per block to target
    #: compilation for
    #: OUT: Returns the number of threads the compiler actually targeted.
    #: This restricts the resource utilization fo the compiler (e.g. max
    #: registers) such that a block with the given number of threads should
    #: be able to launch based on register limitations. Note, this option
    #: does not currently take into account any other resource limitations,
    #: such as shared memory utilization.
    #: Cannot be combined with :py:obj:`~.CU_JIT_TARGET`.
    #: Option type: unsigned int
    #: Applies to: compiler only
    CU_JIT_THREADS_PER_BLOCK = ccuda.CUjit_option_enum.CU_JIT_THREADS_PER_BLOCK

    #: Overwrites the option value with the total wall clock time, in
    #: milliseconds, spent in the compiler and linker
    #: Option type: float
    #: Applies to: compiler and linker
    CU_JIT_WALL_TIME = ccuda.CUjit_option_enum.CU_JIT_WALL_TIME

    #: Pointer to a buffer in which to print any log messages that are
    #: informational in nature (the buffer size is specified via option
    #: :py:obj:`~.CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES`)
    #: Option type: char *
    #: Applies to: compiler and linker
    CU_JIT_INFO_LOG_BUFFER = ccuda.CUjit_option_enum.CU_JIT_INFO_LOG_BUFFER

    #: IN: Log buffer size in bytes. Log messages will be capped at this
    #: size (including null terminator)
    #: OUT: Amount of log buffer filled with messages
    #: Option type: unsigned int
    #: Applies to: compiler and linker
    CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES = ccuda.CUjit_option_enum.CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES

    #: Pointer to a buffer in which to print any log messages that reflect
    #: errors (the buffer size is specified via option
    #: :py:obj:`~.CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES`)
    #: Option type: char *
    #: Applies to: compiler and linker
    CU_JIT_ERROR_LOG_BUFFER = ccuda.CUjit_option_enum.CU_JIT_ERROR_LOG_BUFFER

    #: IN: Log buffer size in bytes. Log messages will be capped at this
    #: size (including null terminator)
    #: OUT: Amount of log buffer filled with messages
    #: Option type: unsigned int
    #: Applies to: compiler and linker
    CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES = ccuda.CUjit_option_enum.CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES

    #: Level of optimizations to apply to generated code (0 - 4), with 4
    #: being the default and highest level of optimizations.
    #: Option type: unsigned int
    #: Applies to: compiler only
    CU_JIT_OPTIMIZATION_LEVEL = ccuda.CUjit_option_enum.CU_JIT_OPTIMIZATION_LEVEL

    #: No option value required. Determines the target based on the current
    #: attached context (default)
    #: Option type: No option value needed
    #: Applies to: compiler and linker
    CU_JIT_TARGET_FROM_CUCONTEXT = ccuda.CUjit_option_enum.CU_JIT_TARGET_FROM_CUCONTEXT

    #: Target is chosen based on supplied :py:obj:`~.CUjit_target`. Cannot
    #: be combined with :py:obj:`~.CU_JIT_THREADS_PER_BLOCK`.
    #: Option type: unsigned int for enumerated type
    #: :py:obj:`~.CUjit_target`
    #: Applies to: compiler and linker
    CU_JIT_TARGET = ccuda.CUjit_option_enum.CU_JIT_TARGET

    #: Specifies choice of fallback strategy if matching cubin is not
    #: found. Choice is based on supplied :py:obj:`~.CUjit_fallback`. This
    #: option cannot be used with cuLink* APIs as the linker requires exact
    #: matches.
    #: Option type: unsigned int for enumerated type
    #: :py:obj:`~.CUjit_fallback`
    #: Applies to: compiler only
    CU_JIT_FALLBACK_STRATEGY = ccuda.CUjit_option_enum.CU_JIT_FALLBACK_STRATEGY

    #: Specifies whether to create debug information in output (-g) (0:
    #: false, default)
    #: Option type: int
    #: Applies to: compiler and linker
    CU_JIT_GENERATE_DEBUG_INFO = ccuda.CUjit_option_enum.CU_JIT_GENERATE_DEBUG_INFO

    #: Generate verbose log messages (0: false, default)
    #: Option type: int
    #: Applies to: compiler and linker
    CU_JIT_LOG_VERBOSE = ccuda.CUjit_option_enum.CU_JIT_LOG_VERBOSE

    #: Generate line number information (-lineinfo) (0: false, default)
    #: Option type: int
    #: Applies to: compiler only
    CU_JIT_GENERATE_LINE_INFO = ccuda.CUjit_option_enum.CU_JIT_GENERATE_LINE_INFO

    #: Specifies whether to enable caching explicitly (-dlcm)
    #: Choice is based on supplied :py:obj:`~.CUjit_cacheMode_enum`.
    #: Option type: unsigned int for enumerated type
    #: :py:obj:`~.CUjit_cacheMode_enum`
    #: Applies to: compiler only
    CU_JIT_CACHE_MODE = ccuda.CUjit_option_enum.CU_JIT_CACHE_MODE

    #: [Deprecated]
    CU_JIT_NEW_SM3X_OPT = ccuda.CUjit_option_enum.CU_JIT_NEW_SM3X_OPT

    #: This jit option is used for internal purpose only.
    CU_JIT_FAST_COMPILE = ccuda.CUjit_option_enum.CU_JIT_FAST_COMPILE

    #: Array of device symbol names that will be relocated to the
    #: corresponing host addresses stored in
    #: :py:obj:`~.CU_JIT_GLOBAL_SYMBOL_ADDRESSES`.
    #: Must contain :py:obj:`~.CU_JIT_GLOBAL_SYMBOL_COUNT` entries.
    #: When loding a device module, driver will relocate all encountered
    #: unresolved symbols to the host addresses.
    #: It is only allowed to register symbols that correspond to unresolved
    #: global variables.
    #: It is illegal to register the same device symbol at multiple
    #: addresses.
    #: Option type: const char **
    #: Applies to: dynamic linker only
    CU_JIT_GLOBAL_SYMBOL_NAMES = ccuda.CUjit_option_enum.CU_JIT_GLOBAL_SYMBOL_NAMES

    #: Array of host addresses that will be used to relocate corresponding
    #: device symbols stored in :py:obj:`~.CU_JIT_GLOBAL_SYMBOL_NAMES`.
    #: Must contain :py:obj:`~.CU_JIT_GLOBAL_SYMBOL_COUNT` entries.
    #: Option type: void **
    #: Applies to: dynamic linker only
    CU_JIT_GLOBAL_SYMBOL_ADDRESSES = ccuda.CUjit_option_enum.CU_JIT_GLOBAL_SYMBOL_ADDRESSES

    #: Number of entries in :py:obj:`~.CU_JIT_GLOBAL_SYMBOL_NAMES` and
    #: :py:obj:`~.CU_JIT_GLOBAL_SYMBOL_ADDRESSES` arrays.
    #: Option type: unsigned int
    #: Applies to: dynamic linker only
    CU_JIT_GLOBAL_SYMBOL_COUNT = ccuda.CUjit_option_enum.CU_JIT_GLOBAL_SYMBOL_COUNT

    #: Enable link-time optimization (-dlto) for device code (Disabled by
    #: default).
    #: This option is not supported on 32-bit platforms.
    #: Option type: int
    #: Applies to: compiler and linker
    CU_JIT_LTO = ccuda.CUjit_option_enum.CU_JIT_LTO

    #: Control single-precision denormals (-ftz) support (0: false,
    #: default). 1 : flushes denormal values to zero 0 : preserves denormal
    #: values Option type: int
    #: Applies to: link-time optimization specified with CU_JIT_LTO
    CU_JIT_FTZ = ccuda.CUjit_option_enum.CU_JIT_FTZ

    #: Control single-precision floating-point division and reciprocals
    #: (-prec-div) support (1: true, default). 1 : Enables the IEEE round-
    #: to-nearest mode 0 : Enables the fast approximation mode Option type:
    #: int
    #: Applies to: link-time optimization specified with CU_JIT_LTO
    CU_JIT_PREC_DIV = ccuda.CUjit_option_enum.CU_JIT_PREC_DIV

    #: Control single-precision floating-point square root (-prec-sqrt)
    #: support (1: true, default). 1 : Enables the IEEE round-to-nearest
    #: mode 0 : Enables the fast approximation mode Option type: int
    #: Applies to: link-time optimization specified with CU_JIT_LTO
    CU_JIT_PREC_SQRT = ccuda.CUjit_option_enum.CU_JIT_PREC_SQRT

    #: Enable/Disable the contraction of floating-point multiplies and
    #: adds/subtracts into floating-point multiply-add (-fma) operations
    #: (1: Enable, default; 0: Disable). Option type: int
    #: Applies to: link-time optimization specified with CU_JIT_LTO
    CU_JIT_FMA = ccuda.CUjit_option_enum.CU_JIT_FMA

    #: Array of kernel names that should be preserved at link time while
    #: others can be removed.
    #: Must contain :py:obj:`~.CU_JIT_REFERENCED_KERNEL_COUNT` entries.
    #: Note that kernel names can be mangled by the compiler in which case
    #: the mangled name needs to be specified.
    #: Wildcard "*" can be used to represent zero or more characters
    #: instead of specifying the full or mangled name.
    #: It is important to note that the wildcard "*" is also added
    #: implicitly. For example, specifying "foo" will match "foobaz",
    #: "barfoo", "barfoobaz" and thus preserve all kernels with those
    #: names. This can be avoided by providing a more specific name like
    #: "barfoobaz".
    #: Option type: const char **
    #: Applies to: dynamic linker only
    CU_JIT_REFERENCED_KERNEL_NAMES = ccuda.CUjit_option_enum.CU_JIT_REFERENCED_KERNEL_NAMES

    #: Number of entries in :py:obj:`~.CU_JIT_REFERENCED_KERNEL_NAMES`
    #: array.
    #: Option type: unsigned int
    #: Applies to: dynamic linker only
    CU_JIT_REFERENCED_KERNEL_COUNT = ccuda.CUjit_option_enum.CU_JIT_REFERENCED_KERNEL_COUNT

    #: Array of variable names (device and/or constant) that should be
    #: preserved at link time while others can be removed.
    #: Must contain :py:obj:`~.CU_JIT_REFERENCED_VARIABLE_COUNT` entries.
    #: Note that variable names can be mangled by the compiler in which
    #: case the mangled name needs to be specified.
    #: Wildcard "*" can be used to represent zero or more characters
    #: instead of specifying the full or mangled name.
    #: It is important to note that the wildcard "*" is also added
    #: implicitly. For example, specifying "foo" will match "foobaz",
    #: "barfoo", "barfoobaz" and thus preserve all variables with those
    #: names. This can be avoided by providing a more specific name like
    #: "barfoobaz".
    #: Option type: const char **
    #: Applies to: link-time optimization specified with CU_JIT_LTO
    CU_JIT_REFERENCED_VARIABLE_NAMES = ccuda.CUjit_option_enum.CU_JIT_REFERENCED_VARIABLE_NAMES

    #: Number of entries in :py:obj:`~.CU_JIT_REFERENCED_VARIABLE_NAMES`
    #: array.
    #: Option type: unsigned int
    #: Applies to: link-time optimization specified with CU_JIT_LTO
    CU_JIT_REFERENCED_VARIABLE_COUNT = ccuda.CUjit_option_enum.CU_JIT_REFERENCED_VARIABLE_COUNT

    #: This option serves as a hint to enable the JIT compiler/linker to
    #: remove constant (constant) and device (device) variables
    #: unreferenced in device code (Disabled by default).
    #: Note that host references to constant and device variables using
    #: APIs like :py:obj:`~.cuModuleGetGlobal()` with this option specified
    #: may result in undefined behavior unless the variables are explicitly
    #: specified using :py:obj:`~.CU_JIT_REFERENCED_VARIABLE_NAMES`.
    #: Option type: int
    #: Applies to: link-time optimization specified with CU_JIT_LTO
    CU_JIT_OPTIMIZE_UNUSED_DEVICE_VARIABLES = ccuda.CUjit_option_enum.CU_JIT_OPTIMIZE_UNUSED_DEVICE_VARIABLES
    CU_JIT_NUM_OPTIONS = ccuda.CUjit_option_enum.CU_JIT_NUM_OPTIONS

class CUjit_target(IntEnum):
    """
    Online compilation targets
    """

    #: Compute device class 2.0
    CU_TARGET_COMPUTE_20 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_20

    #: Compute device class 2.1
    CU_TARGET_COMPUTE_21 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_21

    #: Compute device class 3.0
    CU_TARGET_COMPUTE_30 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_30

    #: Compute device class 3.2
    CU_TARGET_COMPUTE_32 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_32

    #: Compute device class 3.5
    CU_TARGET_COMPUTE_35 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_35

    #: Compute device class 3.7
    CU_TARGET_COMPUTE_37 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_37

    #: Compute device class 5.0
    CU_TARGET_COMPUTE_50 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_50

    #: Compute device class 5.2
    CU_TARGET_COMPUTE_52 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_52

    #: Compute device class 5.3
    CU_TARGET_COMPUTE_53 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_53

    #: Compute device class 6.0.
    CU_TARGET_COMPUTE_60 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_60

    #: Compute device class 6.1.
    CU_TARGET_COMPUTE_61 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_61

    #: Compute device class 6.2.
    CU_TARGET_COMPUTE_62 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_62

    #: Compute device class 7.0.
    CU_TARGET_COMPUTE_70 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_70

    #: Compute device class 7.2.
    CU_TARGET_COMPUTE_72 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_72

    #: Compute device class 7.5.
    CU_TARGET_COMPUTE_75 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_75

    #: Compute device class 8.0.
    CU_TARGET_COMPUTE_80 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_80

    #: Compute device class 8.6.
    CU_TARGET_COMPUTE_86 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_86
    CU_TARGET_COMPUTE_87 = ccuda.CUjit_target_enum.CU_TARGET_COMPUTE_87

class CUjit_fallback(IntEnum):
    """
    Cubin matching fallback strategies
    """

    #: Prefer to compile ptx if exact binary match not found
    CU_PREFER_PTX = ccuda.CUjit_fallback_enum.CU_PREFER_PTX

    #: Prefer to fall back to compatible binary code if exact match not
    #: found
    CU_PREFER_BINARY = ccuda.CUjit_fallback_enum.CU_PREFER_BINARY

class CUjit_cacheMode(IntEnum):
    """
    Caching modes for dlcm
    """

    #: Compile with no -dlcm flag specified
    CU_JIT_CACHE_OPTION_NONE = ccuda.CUjit_cacheMode_enum.CU_JIT_CACHE_OPTION_NONE

    #: Compile with L1 cache disabled
    CU_JIT_CACHE_OPTION_CG = ccuda.CUjit_cacheMode_enum.CU_JIT_CACHE_OPTION_CG

    #: Compile with L1 cache enabled
    CU_JIT_CACHE_OPTION_CA = ccuda.CUjit_cacheMode_enum.CU_JIT_CACHE_OPTION_CA

class CUjitInputType(IntEnum):
    """
    Device code formats
    """

    #: Compiled device-class-specific device code
    #: Applicable options: none
    CU_JIT_INPUT_CUBIN = ccuda.CUjitInputType_enum.CU_JIT_INPUT_CUBIN

    #: PTX source code
    #: Applicable options: PTX compiler options
    CU_JIT_INPUT_PTX = ccuda.CUjitInputType_enum.CU_JIT_INPUT_PTX

    #: Bundle of multiple cubins and/or PTX of some device code
    #: Applicable options: PTX compiler options,
    #: :py:obj:`~.CU_JIT_FALLBACK_STRATEGY`
    CU_JIT_INPUT_FATBINARY = ccuda.CUjitInputType_enum.CU_JIT_INPUT_FATBINARY

    #: Host object with embedded device code
    #: Applicable options: PTX compiler options,
    #: :py:obj:`~.CU_JIT_FALLBACK_STRATEGY`
    CU_JIT_INPUT_OBJECT = ccuda.CUjitInputType_enum.CU_JIT_INPUT_OBJECT

    #: Archive of host objects with embedded device code
    #: Applicable options: PTX compiler options,
    #: :py:obj:`~.CU_JIT_FALLBACK_STRATEGY`
    CU_JIT_INPUT_LIBRARY = ccuda.CUjitInputType_enum.CU_JIT_INPUT_LIBRARY

    #: High-level intermediate code for link-time optimization
    #: Applicable options: NVVM compiler options, PTX compiler options
    CU_JIT_INPUT_NVVM = ccuda.CUjitInputType_enum.CU_JIT_INPUT_NVVM
    CU_JIT_NUM_INPUT_TYPES = ccuda.CUjitInputType_enum.CU_JIT_NUM_INPUT_TYPES

class CUgraphicsRegisterFlags(IntEnum):
    """
    Flags to register a graphics resource
    """
    CU_GRAPHICS_REGISTER_FLAGS_NONE = ccuda.CUgraphicsRegisterFlags_enum.CU_GRAPHICS_REGISTER_FLAGS_NONE
    CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY = ccuda.CUgraphicsRegisterFlags_enum.CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY
    CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD = ccuda.CUgraphicsRegisterFlags_enum.CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD
    CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST = ccuda.CUgraphicsRegisterFlags_enum.CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST
    CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = ccuda.CUgraphicsRegisterFlags_enum.CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER

class CUgraphicsMapResourceFlags(IntEnum):
    """
    Flags for mapping and unmapping interop resources
    """
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE = ccuda.CUgraphicsMapResourceFlags_enum.CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY = ccuda.CUgraphicsMapResourceFlags_enum.CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY
    CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD = ccuda.CUgraphicsMapResourceFlags_enum.CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD

class CUarray_cubemap_face(IntEnum):
    """
    Array indices for cube faces
    """

    #: Positive X face of cubemap
    CU_CUBEMAP_FACE_POSITIVE_X = ccuda.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_POSITIVE_X

    #: Negative X face of cubemap
    CU_CUBEMAP_FACE_NEGATIVE_X = ccuda.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_NEGATIVE_X

    #: Positive Y face of cubemap
    CU_CUBEMAP_FACE_POSITIVE_Y = ccuda.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_POSITIVE_Y

    #: Negative Y face of cubemap
    CU_CUBEMAP_FACE_NEGATIVE_Y = ccuda.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_NEGATIVE_Y

    #: Positive Z face of cubemap
    CU_CUBEMAP_FACE_POSITIVE_Z = ccuda.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_POSITIVE_Z

    #: Negative Z face of cubemap
    CU_CUBEMAP_FACE_NEGATIVE_Z = ccuda.CUarray_cubemap_face_enum.CU_CUBEMAP_FACE_NEGATIVE_Z

class CUlimit(IntEnum):
    """
    Limits
    """

    #: GPU thread stack size
    CU_LIMIT_STACK_SIZE = ccuda.CUlimit_enum.CU_LIMIT_STACK_SIZE

    #: GPU printf FIFO size
    CU_LIMIT_PRINTF_FIFO_SIZE = ccuda.CUlimit_enum.CU_LIMIT_PRINTF_FIFO_SIZE

    #: GPU malloc heap size
    CU_LIMIT_MALLOC_HEAP_SIZE = ccuda.CUlimit_enum.CU_LIMIT_MALLOC_HEAP_SIZE

    #: GPU device runtime launch synchronize depth
    CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH = ccuda.CUlimit_enum.CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH

    #: GPU device runtime pending launch count
    CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT = ccuda.CUlimit_enum.CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT

    #: A value between 0 and 128 that indicates the maximum fetch
    #: granularity of L2 (in Bytes). This is a hint
    CU_LIMIT_MAX_L2_FETCH_GRANULARITY = ccuda.CUlimit_enum.CU_LIMIT_MAX_L2_FETCH_GRANULARITY

    #: A size in bytes for L2 persisting lines cache size
    CU_LIMIT_PERSISTING_L2_CACHE_SIZE = ccuda.CUlimit_enum.CU_LIMIT_PERSISTING_L2_CACHE_SIZE
    CU_LIMIT_MAX = ccuda.CUlimit_enum.CU_LIMIT_MAX

class CUresourcetype(IntEnum):
    """
    Resource types
    """

    #: Array resoure
    CU_RESOURCE_TYPE_ARRAY = ccuda.CUresourcetype_enum.CU_RESOURCE_TYPE_ARRAY

    #: Mipmapped array resource
    CU_RESOURCE_TYPE_MIPMAPPED_ARRAY = ccuda.CUresourcetype_enum.CU_RESOURCE_TYPE_MIPMAPPED_ARRAY

    #: Linear resource
    CU_RESOURCE_TYPE_LINEAR = ccuda.CUresourcetype_enum.CU_RESOURCE_TYPE_LINEAR

    #: Pitch 2D resource
    CU_RESOURCE_TYPE_PITCH2D = ccuda.CUresourcetype_enum.CU_RESOURCE_TYPE_PITCH2D

class CUaccessProperty(IntEnum):
    """
    Specifies performance hint with :py:obj:`~.CUaccessPolicyWindow`
    for hitProp and missProp members.
    """

    #: Normal cache persistence.
    CU_ACCESS_PROPERTY_NORMAL = ccuda.CUaccessProperty_enum.CU_ACCESS_PROPERTY_NORMAL

    #: Streaming access is less likely to persit from cache.
    CU_ACCESS_PROPERTY_STREAMING = ccuda.CUaccessProperty_enum.CU_ACCESS_PROPERTY_STREAMING

    #: Persisting access is more likely to persist in cache.
    CU_ACCESS_PROPERTY_PERSISTING = ccuda.CUaccessProperty_enum.CU_ACCESS_PROPERTY_PERSISTING

class CUgraphNodeType(IntEnum):
    """
    Graph node types
    """

    #: GPU kernel node
    CU_GRAPH_NODE_TYPE_KERNEL = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_KERNEL

    #: Memcpy node
    CU_GRAPH_NODE_TYPE_MEMCPY = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_MEMCPY

    #: Memset node
    CU_GRAPH_NODE_TYPE_MEMSET = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_MEMSET

    #: Host (executable) node
    CU_GRAPH_NODE_TYPE_HOST = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_HOST

    #: Node which executes an embedded graph
    CU_GRAPH_NODE_TYPE_GRAPH = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_GRAPH

    #: Empty (no-op) node
    CU_GRAPH_NODE_TYPE_EMPTY = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_EMPTY

    #: External event wait node
    CU_GRAPH_NODE_TYPE_WAIT_EVENT = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_WAIT_EVENT

    #: External event record node
    CU_GRAPH_NODE_TYPE_EVENT_RECORD = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_EVENT_RECORD

    #: External semaphore signal node
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL

    #: External semaphore wait node
    CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT

    #: Memory Allocation Node
    CU_GRAPH_NODE_TYPE_MEM_ALLOC = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_MEM_ALLOC

    #: Memory Free Node
    CU_GRAPH_NODE_TYPE_MEM_FREE = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_MEM_FREE

    #: Batch MemOp Node
    CU_GRAPH_NODE_TYPE_BATCH_MEM_OP = ccuda.CUgraphNodeType_enum.CU_GRAPH_NODE_TYPE_BATCH_MEM_OP

class CUsynchronizationPolicy(IntEnum):
    """

    """
    CU_SYNC_POLICY_AUTO = ccuda.CUsynchronizationPolicy_enum.CU_SYNC_POLICY_AUTO
    CU_SYNC_POLICY_SPIN = ccuda.CUsynchronizationPolicy_enum.CU_SYNC_POLICY_SPIN
    CU_SYNC_POLICY_YIELD = ccuda.CUsynchronizationPolicy_enum.CU_SYNC_POLICY_YIELD
    CU_SYNC_POLICY_BLOCKING_SYNC = ccuda.CUsynchronizationPolicy_enum.CU_SYNC_POLICY_BLOCKING_SYNC

class CUkernelNodeAttrID(IntEnum):
    """
    Graph kernel node Attributes
    """

    #: Identifier for :py:obj:`~.CUkernelNodeAttrValue.accessPolicyWindow`.
    CU_KERNEL_NODE_ATTRIBUTE_ACCESS_POLICY_WINDOW = ccuda.CUkernelNodeAttrID_enum.CU_KERNEL_NODE_ATTRIBUTE_ACCESS_POLICY_WINDOW

    #: Allows a kernel node to be cooperative (see
    #: :py:obj:`~.cuLaunchCooperativeKernel`).
    CU_KERNEL_NODE_ATTRIBUTE_COOPERATIVE = ccuda.CUkernelNodeAttrID_enum.CU_KERNEL_NODE_ATTRIBUTE_COOPERATIVE

    #: Sets the priority of the kernel.
    CU_KERNEL_NODE_ATTRIBUTE_PRIORITY = ccuda.CUkernelNodeAttrID_enum.CU_KERNEL_NODE_ATTRIBUTE_PRIORITY

class CUstreamCaptureStatus(IntEnum):
    """
    Possible stream capture statuses returned by
    :py:obj:`~.cuStreamIsCapturing`
    """

    #: Stream is not capturing
    CU_STREAM_CAPTURE_STATUS_NONE = ccuda.CUstreamCaptureStatus_enum.CU_STREAM_CAPTURE_STATUS_NONE

    #: Stream is actively capturing
    CU_STREAM_CAPTURE_STATUS_ACTIVE = ccuda.CUstreamCaptureStatus_enum.CU_STREAM_CAPTURE_STATUS_ACTIVE

    #: Stream is part of a capture sequence that has been invalidated, but
    #: not terminated
    CU_STREAM_CAPTURE_STATUS_INVALIDATED = ccuda.CUstreamCaptureStatus_enum.CU_STREAM_CAPTURE_STATUS_INVALIDATED

class CUstreamCaptureMode(IntEnum):
    """
    Possible modes for stream capture thread interactions. For more
    details see :py:obj:`~.cuStreamBeginCapture` and
    :py:obj:`~.cuThreadExchangeStreamCaptureMode`
    """
    CU_STREAM_CAPTURE_MODE_GLOBAL = ccuda.CUstreamCaptureMode_enum.CU_STREAM_CAPTURE_MODE_GLOBAL
    CU_STREAM_CAPTURE_MODE_THREAD_LOCAL = ccuda.CUstreamCaptureMode_enum.CU_STREAM_CAPTURE_MODE_THREAD_LOCAL
    CU_STREAM_CAPTURE_MODE_RELAXED = ccuda.CUstreamCaptureMode_enum.CU_STREAM_CAPTURE_MODE_RELAXED

class CUstreamAttrID(IntEnum):
    """
    Stream Attributes
    """

    #: Identifier for :py:obj:`~.CUstreamAttrValue.accessPolicyWindow`.
    CU_STREAM_ATTRIBUTE_ACCESS_POLICY_WINDOW = ccuda.CUstreamAttrID_enum.CU_STREAM_ATTRIBUTE_ACCESS_POLICY_WINDOW

    #: :py:obj:`~.CUsynchronizationPolicy` for work queued up in this
    #: stream
    CU_STREAM_ATTRIBUTE_SYNCHRONIZATION_POLICY = ccuda.CUstreamAttrID_enum.CU_STREAM_ATTRIBUTE_SYNCHRONIZATION_POLICY

class CUdriverProcAddress_flags(IntEnum):
    """
    Flags to specify search options. For more details see
    :py:obj:`~.cuGetProcAddress`
    """

    #: Default search mode for driver symbols.
    CU_GET_PROC_ADDRESS_DEFAULT = ccuda.CUdriverProcAddress_flags_enum.CU_GET_PROC_ADDRESS_DEFAULT

    #: Search for legacy versions of driver symbols.
    CU_GET_PROC_ADDRESS_LEGACY_STREAM = ccuda.CUdriverProcAddress_flags_enum.CU_GET_PROC_ADDRESS_LEGACY_STREAM

    #: Search for per-thread versions of driver symbols.
    CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM = ccuda.CUdriverProcAddress_flags_enum.CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM

class CUexecAffinityType(IntEnum):
    """
    Execution Affinity Types
    """

    #: Create a context with limited SMs.
    CU_EXEC_AFFINITY_TYPE_SM_COUNT = ccuda.CUexecAffinityType_enum.CU_EXEC_AFFINITY_TYPE_SM_COUNT
    CU_EXEC_AFFINITY_TYPE_MAX = ccuda.CUexecAffinityType_enum.CU_EXEC_AFFINITY_TYPE_MAX

class CUresult(IntEnum):
    """
    Error codes
    """

    #: The API call returned with no errors. In the case of query calls,
    #: this also means that the operation being queried is complete (see
    #: :py:obj:`~.cuEventQuery()` and :py:obj:`~.cuStreamQuery()`).
    CUDA_SUCCESS = ccuda.cudaError_enum.CUDA_SUCCESS

    #: This indicates that one or more of the parameters passed to the API
    #: call is not within an acceptable range of values.
    CUDA_ERROR_INVALID_VALUE = ccuda.cudaError_enum.CUDA_ERROR_INVALID_VALUE

    #: The API call failed because it was unable to allocate enough memory
    #: to perform the requested operation.
    CUDA_ERROR_OUT_OF_MEMORY = ccuda.cudaError_enum.CUDA_ERROR_OUT_OF_MEMORY

    #: This indicates that the CUDA driver has not been initialized with
    #: :py:obj:`~.cuInit()` or that initialization has failed.
    CUDA_ERROR_NOT_INITIALIZED = ccuda.cudaError_enum.CUDA_ERROR_NOT_INITIALIZED

    #: This indicates that the CUDA driver is in the process of shutting
    #: down.
    CUDA_ERROR_DEINITIALIZED = ccuda.cudaError_enum.CUDA_ERROR_DEINITIALIZED

    #: This indicates profiler is not initialized for this run. This can
    #: happen when the application is running with external profiling tools
    #: like visual profiler.
    CUDA_ERROR_PROFILER_DISABLED = ccuda.cudaError_enum.CUDA_ERROR_PROFILER_DISABLED

    #: [Deprecated]
    CUDA_ERROR_PROFILER_NOT_INITIALIZED = ccuda.cudaError_enum.CUDA_ERROR_PROFILER_NOT_INITIALIZED

    #: [Deprecated]
    CUDA_ERROR_PROFILER_ALREADY_STARTED = ccuda.cudaError_enum.CUDA_ERROR_PROFILER_ALREADY_STARTED

    #: [Deprecated]
    CUDA_ERROR_PROFILER_ALREADY_STOPPED = ccuda.cudaError_enum.CUDA_ERROR_PROFILER_ALREADY_STOPPED

    #: This indicates that the CUDA driver that the application has loaded
    #: is a stub library. Applications that run with the stub rather than a
    #: real driver loaded will result in CUDA API returning this error.
    CUDA_ERROR_STUB_LIBRARY = ccuda.cudaError_enum.CUDA_ERROR_STUB_LIBRARY

    #: This indicates that requested CUDA device is unavailable at the
    #: current time. Devices are often unavailable due to use of
    #: :py:obj:`~.CU_COMPUTEMODE_EXCLUSIVE_PROCESS` or
    #: :py:obj:`~.CU_COMPUTEMODE_PROHIBITED`.
    CUDA_ERROR_DEVICE_UNAVAILABLE = ccuda.cudaError_enum.CUDA_ERROR_DEVICE_UNAVAILABLE

    #: This indicates that no CUDA-capable devices were detected by the
    #: installed CUDA driver.
    CUDA_ERROR_NO_DEVICE = ccuda.cudaError_enum.CUDA_ERROR_NO_DEVICE

    #: This indicates that the device ordinal supplied by the user does not
    #: correspond to a valid CUDA device or that the action requested is
    #: invalid for the specified device.
    CUDA_ERROR_INVALID_DEVICE = ccuda.cudaError_enum.CUDA_ERROR_INVALID_DEVICE

    #: This error indicates that the Grid license is not applied.
    CUDA_ERROR_DEVICE_NOT_LICENSED = ccuda.cudaError_enum.CUDA_ERROR_DEVICE_NOT_LICENSED

    #: This indicates that the device kernel image is invalid. This can
    #: also indicate an invalid CUDA module.
    CUDA_ERROR_INVALID_IMAGE = ccuda.cudaError_enum.CUDA_ERROR_INVALID_IMAGE

    #: This most frequently indicates that there is no context bound to the
    #: current thread. This can also be returned if the context passed to
    #: an API call is not a valid handle (such as a context that has had
    #: :py:obj:`~.cuCtxDestroy()` invoked on it). This can also be returned
    #: if a user mixes different API versions (i.e. 3010 context with 3020
    #: API calls). See :py:obj:`~.cuCtxGetApiVersion()` for more details.
    CUDA_ERROR_INVALID_CONTEXT = ccuda.cudaError_enum.CUDA_ERROR_INVALID_CONTEXT

    #: This indicated that the context being supplied as a parameter to the
    #: API call was already the active context. [Deprecated]
    CUDA_ERROR_CONTEXT_ALREADY_CURRENT = ccuda.cudaError_enum.CUDA_ERROR_CONTEXT_ALREADY_CURRENT

    #: This indicates that a map or register operation has failed.
    CUDA_ERROR_MAP_FAILED = ccuda.cudaError_enum.CUDA_ERROR_MAP_FAILED

    #: This indicates that an unmap or unregister operation has failed.
    CUDA_ERROR_UNMAP_FAILED = ccuda.cudaError_enum.CUDA_ERROR_UNMAP_FAILED

    #: This indicates that the specified array is currently mapped and thus
    #: cannot be destroyed.
    CUDA_ERROR_ARRAY_IS_MAPPED = ccuda.cudaError_enum.CUDA_ERROR_ARRAY_IS_MAPPED

    #: This indicates that the resource is already mapped.
    CUDA_ERROR_ALREADY_MAPPED = ccuda.cudaError_enum.CUDA_ERROR_ALREADY_MAPPED

    #: This indicates that there is no kernel image available that is
    #: suitable for the device. This can occur when a user specifies code
    #: generation options for a particular CUDA source file that do not
    #: include the corresponding device configuration.
    CUDA_ERROR_NO_BINARY_FOR_GPU = ccuda.cudaError_enum.CUDA_ERROR_NO_BINARY_FOR_GPU

    #: This indicates that a resource has already been acquired.
    CUDA_ERROR_ALREADY_ACQUIRED = ccuda.cudaError_enum.CUDA_ERROR_ALREADY_ACQUIRED

    #: This indicates that a resource is not mapped.
    CUDA_ERROR_NOT_MAPPED = ccuda.cudaError_enum.CUDA_ERROR_NOT_MAPPED

    #: This indicates that a mapped resource is not available for access as
    #: an array.
    CUDA_ERROR_NOT_MAPPED_AS_ARRAY = ccuda.cudaError_enum.CUDA_ERROR_NOT_MAPPED_AS_ARRAY

    #: This indicates that a mapped resource is not available for access as
    #: a pointer.
    CUDA_ERROR_NOT_MAPPED_AS_POINTER = ccuda.cudaError_enum.CUDA_ERROR_NOT_MAPPED_AS_POINTER

    #: This indicates that an uncorrectable ECC error was detected during
    #: execution.
    CUDA_ERROR_ECC_UNCORRECTABLE = ccuda.cudaError_enum.CUDA_ERROR_ECC_UNCORRECTABLE

    #: This indicates that the :py:obj:`~.CUlimit` passed to the API call
    #: is not supported by the active device.
    CUDA_ERROR_UNSUPPORTED_LIMIT = ccuda.cudaError_enum.CUDA_ERROR_UNSUPPORTED_LIMIT

    #: This indicates that the :py:obj:`~.CUcontext` passed to the API call
    #: can only be bound to a single CPU thread at a time but is already
    #: bound to a CPU thread.
    CUDA_ERROR_CONTEXT_ALREADY_IN_USE = ccuda.cudaError_enum.CUDA_ERROR_CONTEXT_ALREADY_IN_USE

    #: This indicates that peer access is not supported across the given
    #: devices.
    CUDA_ERROR_PEER_ACCESS_UNSUPPORTED = ccuda.cudaError_enum.CUDA_ERROR_PEER_ACCESS_UNSUPPORTED

    #: This indicates that a PTX JIT compilation failed.
    CUDA_ERROR_INVALID_PTX = ccuda.cudaError_enum.CUDA_ERROR_INVALID_PTX

    #: This indicates an error with OpenGL or DirectX context.
    CUDA_ERROR_INVALID_GRAPHICS_CONTEXT = ccuda.cudaError_enum.CUDA_ERROR_INVALID_GRAPHICS_CONTEXT

    #: This indicates that an uncorrectable NVLink error was detected
    #: during the execution.
    CUDA_ERROR_NVLINK_UNCORRECTABLE = ccuda.cudaError_enum.CUDA_ERROR_NVLINK_UNCORRECTABLE

    #: This indicates that the PTX JIT compiler library was not found.
    CUDA_ERROR_JIT_COMPILER_NOT_FOUND = ccuda.cudaError_enum.CUDA_ERROR_JIT_COMPILER_NOT_FOUND

    #: This indicates that the provided PTX was compiled with an
    #: unsupported toolchain.
    CUDA_ERROR_UNSUPPORTED_PTX_VERSION = ccuda.cudaError_enum.CUDA_ERROR_UNSUPPORTED_PTX_VERSION

    #: This indicates that the PTX JIT compilation was disabled.
    CUDA_ERROR_JIT_COMPILATION_DISABLED = ccuda.cudaError_enum.CUDA_ERROR_JIT_COMPILATION_DISABLED

    #: This indicates that the :py:obj:`~.CUexecAffinityType` passed to the
    #: API call is not supported by the active device.
    CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY = ccuda.cudaError_enum.CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY

    #: This indicates that the device kernel source is invalid. This
    #: includes compilation/linker errors encountered in device code or
    #: user error.
    CUDA_ERROR_INVALID_SOURCE = ccuda.cudaError_enum.CUDA_ERROR_INVALID_SOURCE

    #: This indicates that the file specified was not found.
    CUDA_ERROR_FILE_NOT_FOUND = ccuda.cudaError_enum.CUDA_ERROR_FILE_NOT_FOUND

    #: This indicates that a link to a shared object failed to resolve.
    CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND = ccuda.cudaError_enum.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND

    #: This indicates that initialization of a shared object failed.
    CUDA_ERROR_SHARED_OBJECT_INIT_FAILED = ccuda.cudaError_enum.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED

    #: This indicates that an OS call failed.
    CUDA_ERROR_OPERATING_SYSTEM = ccuda.cudaError_enum.CUDA_ERROR_OPERATING_SYSTEM

    #: This indicates that a resource handle passed to the API call was not
    #: valid. Resource handles are opaque types like :py:obj:`~.CUstream`
    #: and :py:obj:`~.CUevent`.
    CUDA_ERROR_INVALID_HANDLE = ccuda.cudaError_enum.CUDA_ERROR_INVALID_HANDLE

    #: This indicates that a resource required by the API call is not in a
    #: valid state to perform the requested operation.
    CUDA_ERROR_ILLEGAL_STATE = ccuda.cudaError_enum.CUDA_ERROR_ILLEGAL_STATE

    #: This indicates that a named symbol was not found. Examples of
    #: symbols are global/constant variable names, driver function names,
    #: texture names, and surface names.
    CUDA_ERROR_NOT_FOUND = ccuda.cudaError_enum.CUDA_ERROR_NOT_FOUND

    #: This indicates that asynchronous operations issued previously have
    #: not completed yet. This result is not actually an error, but must be
    #: indicated differently than :py:obj:`~.CUDA_SUCCESS` (which indicates
    #: completion). Calls that may return this value include
    #: :py:obj:`~.cuEventQuery()` and :py:obj:`~.cuStreamQuery()`.
    CUDA_ERROR_NOT_READY = ccuda.cudaError_enum.CUDA_ERROR_NOT_READY

    #: While executing a kernel, the device encountered a load or store
    #: instruction on an invalid memory address. This leaves the process in
    #: an inconsistent state and any further CUDA work will return the same
    #: error. To continue using CUDA, the process must be terminated and
    #: relaunched.
    CUDA_ERROR_ILLEGAL_ADDRESS = ccuda.cudaError_enum.CUDA_ERROR_ILLEGAL_ADDRESS

    #: This indicates that a launch did not occur because it did not have
    #: appropriate resources. This error usually indicates that the user
    #: has attempted to pass too many arguments to the device kernel, or
    #: the kernel launch specifies too many threads for the kernel's
    #: register count. Passing arguments of the wrong size (i.e. a 64-bit
    #: pointer when a 32-bit int is expected) is equivalent to passing too
    #: many arguments and can also result in this error.
    CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES = ccuda.cudaError_enum.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES

    #: This indicates that the device kernel took too long to execute. This
    #: can only occur if timeouts are enabled - see the device attribute
    #: :py:obj:`~.CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT` for more
    #: information. This leaves the process in an inconsistent state and
    #: any further CUDA work will return the same error. To continue using
    #: CUDA, the process must be terminated and relaunched.
    CUDA_ERROR_LAUNCH_TIMEOUT = ccuda.cudaError_enum.CUDA_ERROR_LAUNCH_TIMEOUT

    #: This error indicates a kernel launch that uses an incompatible
    #: texturing mode.
    CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING = ccuda.cudaError_enum.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING

    #: This error indicates that a call to
    #: :py:obj:`~.cuCtxEnablePeerAccess()` is trying to re-enable peer
    #: access to a context which has already had peer access to it enabled.
    CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED = ccuda.cudaError_enum.CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED

    #: This error indicates that :py:obj:`~.cuCtxDisablePeerAccess()` is
    #: trying to disable peer access which has not been enabled yet via
    #: :py:obj:`~.cuCtxEnablePeerAccess()`.
    CUDA_ERROR_PEER_ACCESS_NOT_ENABLED = ccuda.cudaError_enum.CUDA_ERROR_PEER_ACCESS_NOT_ENABLED

    #: This error indicates that the primary context for the specified
    #: device has already been initialized.
    CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE = ccuda.cudaError_enum.CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE

    #: This error indicates that the context current to the calling thread
    #: has been destroyed using :py:obj:`~.cuCtxDestroy`, or is a primary
    #: context which has not yet been initialized.
    CUDA_ERROR_CONTEXT_IS_DESTROYED = ccuda.cudaError_enum.CUDA_ERROR_CONTEXT_IS_DESTROYED

    #: A device-side assert triggered during kernel execution. The context
    #: cannot be used anymore, and must be destroyed. All existing device
    #: memory allocations from this context are invalid and must be
    #: reconstructed if the program is to continue using CUDA.
    CUDA_ERROR_ASSERT = ccuda.cudaError_enum.CUDA_ERROR_ASSERT

    #: This error indicates that the hardware resources required to enable
    #: peer access have been exhausted for one or more of the devices
    #: passed to :py:obj:`~.cuCtxEnablePeerAccess()`.
    CUDA_ERROR_TOO_MANY_PEERS = ccuda.cudaError_enum.CUDA_ERROR_TOO_MANY_PEERS

    #: This error indicates that the memory range passed to
    #: :py:obj:`~.cuMemHostRegister()` has already been registered.
    CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED = ccuda.cudaError_enum.CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED

    #: This error indicates that the pointer passed to
    #: :py:obj:`~.cuMemHostUnregister()` does not correspond to any
    #: currently registered memory region.
    CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED = ccuda.cudaError_enum.CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED

    #: While executing a kernel, the device encountered a stack error. This
    #: can be due to stack corruption or exceeding the stack size limit.
    #: This leaves the process in an inconsistent state and any further
    #: CUDA work will return the same error. To continue using CUDA, the
    #: process must be terminated and relaunched.
    CUDA_ERROR_HARDWARE_STACK_ERROR = ccuda.cudaError_enum.CUDA_ERROR_HARDWARE_STACK_ERROR

    #: While executing a kernel, the device encountered an illegal
    #: instruction. This leaves the process in an inconsistent state and
    #: any further CUDA work will return the same error. To continue using
    #: CUDA, the process must be terminated and relaunched.
    CUDA_ERROR_ILLEGAL_INSTRUCTION = ccuda.cudaError_enum.CUDA_ERROR_ILLEGAL_INSTRUCTION

    #: While executing a kernel, the device encountered a load or store
    #: instruction on a memory address which is not aligned. This leaves
    #: the process in an inconsistent state and any further CUDA work will
    #: return the same error. To continue using CUDA, the process must be
    #: terminated and relaunched.
    CUDA_ERROR_MISALIGNED_ADDRESS = ccuda.cudaError_enum.CUDA_ERROR_MISALIGNED_ADDRESS

    #: While executing a kernel, the device encountered an instruction
    #: which can only operate on memory locations in certain address spaces
    #: (global, shared, or local), but was supplied a memory address not
    #: belonging to an allowed address space. This leaves the process in an
    #: inconsistent state and any further CUDA work will return the same
    #: error. To continue using CUDA, the process must be terminated and
    #: relaunched.
    CUDA_ERROR_INVALID_ADDRESS_SPACE = ccuda.cudaError_enum.CUDA_ERROR_INVALID_ADDRESS_SPACE

    #: While executing a kernel, the device program counter wrapped its
    #: address space. This leaves the process in an inconsistent state and
    #: any further CUDA work will return the same error. To continue using
    #: CUDA, the process must be terminated and relaunched.
    CUDA_ERROR_INVALID_PC = ccuda.cudaError_enum.CUDA_ERROR_INVALID_PC

    #: An exception occurred on the device while executing a kernel. Common
    #: causes include dereferencing an invalid device pointer and accessing
    #: out of bounds shared memory. Less common cases can be system
    #: specific - more information about these cases can be found in the
    #: system specific user guide. This leaves the process in an
    #: inconsistent state and any further CUDA work will return the same
    #: error. To continue using CUDA, the process must be terminated and
    #: relaunched.
    CUDA_ERROR_LAUNCH_FAILED = ccuda.cudaError_enum.CUDA_ERROR_LAUNCH_FAILED

    #: This error indicates that the number of blocks launched per grid for
    #: a kernel that was launched via either
    #: :py:obj:`~.cuLaunchCooperativeKernel` or
    #: :py:obj:`~.cuLaunchCooperativeKernelMultiDevice` exceeds the maximum
    #: number of blocks as allowed by
    #: :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessor` or
    #: :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags`
    #: times the number of multiprocessors as specified by the device
    #: attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT`.
    CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE = ccuda.cudaError_enum.CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE

    #: This error indicates that the attempted operation is not permitted.
    CUDA_ERROR_NOT_PERMITTED = ccuda.cudaError_enum.CUDA_ERROR_NOT_PERMITTED

    #: This error indicates that the attempted operation is not supported
    #: on the current system or device.
    CUDA_ERROR_NOT_SUPPORTED = ccuda.cudaError_enum.CUDA_ERROR_NOT_SUPPORTED

    #: This error indicates that the system is not yet ready to start any
    #: CUDA work. To continue using CUDA, verify the system configuration
    #: is in a valid state and all required driver daemons are actively
    #: running. More information about this error can be found in the
    #: system specific user guide.
    CUDA_ERROR_SYSTEM_NOT_READY = ccuda.cudaError_enum.CUDA_ERROR_SYSTEM_NOT_READY

    #: This error indicates that there is a mismatch between the versions
    #: of the display driver and the CUDA driver. Refer to the
    #: compatibility documentation for supported versions.
    CUDA_ERROR_SYSTEM_DRIVER_MISMATCH = ccuda.cudaError_enum.CUDA_ERROR_SYSTEM_DRIVER_MISMATCH

    #: This error indicates that the system was upgraded to run with
    #: forward compatibility but the visible hardware detected by CUDA does
    #: not support this configuration. Refer to the compatibility
    #: documentation for the supported hardware matrix or ensure that only
    #: supported hardware is visible during initialization via the
    #: CUDA_VISIBLE_DEVICES environment variable.
    CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE = ccuda.cudaError_enum.CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE

    #: This error indicates that the MPS client failed to connect to the
    #: MPS control daemon or the MPS server.
    CUDA_ERROR_MPS_CONNECTION_FAILED = ccuda.cudaError_enum.CUDA_ERROR_MPS_CONNECTION_FAILED

    #: This error indicates that the remote procedural call between the MPS
    #: server and the MPS client failed.
    CUDA_ERROR_MPS_RPC_FAILURE = ccuda.cudaError_enum.CUDA_ERROR_MPS_RPC_FAILURE

    #: This error indicates that the MPS server is not ready to accept new
    #: MPS client requests. This error can be returned when the MPS server
    #: is in the process of recovering from a fatal failure.
    CUDA_ERROR_MPS_SERVER_NOT_READY = ccuda.cudaError_enum.CUDA_ERROR_MPS_SERVER_NOT_READY

    #: This error indicates that the hardware resources required to create
    #: MPS client have been exhausted.
    CUDA_ERROR_MPS_MAX_CLIENTS_REACHED = ccuda.cudaError_enum.CUDA_ERROR_MPS_MAX_CLIENTS_REACHED

    #: This error indicates the the hardware resources required to support
    #: device connections have been exhausted.
    CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED = ccuda.cudaError_enum.CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED

    #: This error indicates that the operation is not permitted when the
    #: stream is capturing.
    CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED = ccuda.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED

    #: This error indicates that the current capture sequence on the stream
    #: has been invalidated due to a previous error.
    CUDA_ERROR_STREAM_CAPTURE_INVALIDATED = ccuda.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_INVALIDATED

    #: This error indicates that the operation would have resulted in a
    #: merge of two independent capture sequences.
    CUDA_ERROR_STREAM_CAPTURE_MERGE = ccuda.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_MERGE

    #: This error indicates that the capture was not initiated in this
    #: stream.
    CUDA_ERROR_STREAM_CAPTURE_UNMATCHED = ccuda.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_UNMATCHED

    #: This error indicates that the capture sequence contains a fork that
    #: was not joined to the primary stream.
    CUDA_ERROR_STREAM_CAPTURE_UNJOINED = ccuda.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_UNJOINED

    #: This error indicates that a dependency would have been created which
    #: crosses the capture sequence boundary. Only implicit in-stream
    #: ordering dependencies are allowed to cross the boundary.
    CUDA_ERROR_STREAM_CAPTURE_ISOLATION = ccuda.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_ISOLATION

    #: This error indicates a disallowed implicit dependency on a current
    #: capture sequence from cudaStreamLegacy.
    CUDA_ERROR_STREAM_CAPTURE_IMPLICIT = ccuda.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT

    #: This error indicates that the operation is not permitted on an event
    #: which was last recorded in a capturing stream.
    CUDA_ERROR_CAPTURED_EVENT = ccuda.cudaError_enum.CUDA_ERROR_CAPTURED_EVENT

    #: A stream capture sequence not initiated with the
    #: :py:obj:`~.CU_STREAM_CAPTURE_MODE_RELAXED` argument to
    #: :py:obj:`~.cuStreamBeginCapture` was passed to
    #: :py:obj:`~.cuStreamEndCapture` in a different thread.
    CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD = ccuda.cudaError_enum.CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD

    #: This error indicates that the timeout specified for the wait
    #: operation has lapsed.
    CUDA_ERROR_TIMEOUT = ccuda.cudaError_enum.CUDA_ERROR_TIMEOUT

    #: This error indicates that the graph update was not performed because
    #: it included changes which violated constraints specific to
    #: instantiated graph update.
    CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE = ccuda.cudaError_enum.CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE

    #: This indicates that an async error has occurred in a device outside
    #: of CUDA. If CUDA was waiting for an external device's signal before
    #: consuming shared data, the external device signaled an error
    #: indicating that the data is not valid for consumption. This leaves
    #: the process in an inconsistent state and any further CUDA work will
    #: return the same error. To continue using CUDA, the process must be
    #: terminated and relaunched.
    CUDA_ERROR_EXTERNAL_DEVICE = ccuda.cudaError_enum.CUDA_ERROR_EXTERNAL_DEVICE

    #: This indicates that an unknown internal error has occurred.
    CUDA_ERROR_UNKNOWN = ccuda.cudaError_enum.CUDA_ERROR_UNKNOWN

class CUdevice_P2PAttribute(IntEnum):
    """
    P2P Attributes
    """

    #: A relative value indicating the performance of the link between two
    #: devices
    CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK = ccuda.CUdevice_P2PAttribute_enum.CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK

    #: P2P Access is enable
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED = ccuda.CUdevice_P2PAttribute_enum.CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED

    #: Atomic operation over the link supported
    CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED = ccuda.CUdevice_P2PAttribute_enum.CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED

    #: [Deprecated]
    CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED = ccuda.CUdevice_P2PAttribute_enum.CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED

    #: Accessing CUDA arrays over the link supported
    CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED = ccuda.CUdevice_P2PAttribute_enum.CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED

class CUresourceViewFormat(IntEnum):
    """
    Resource view format
    """

    #: No resource view format (use underlying resource format)
    CU_RES_VIEW_FORMAT_NONE = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_NONE

    #: 1 channel unsigned 8-bit integers
    CU_RES_VIEW_FORMAT_UINT_1X8 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_1X8

    #: 2 channel unsigned 8-bit integers
    CU_RES_VIEW_FORMAT_UINT_2X8 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_2X8

    #: 4 channel unsigned 8-bit integers
    CU_RES_VIEW_FORMAT_UINT_4X8 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_4X8

    #: 1 channel signed 8-bit integers
    CU_RES_VIEW_FORMAT_SINT_1X8 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_1X8

    #: 2 channel signed 8-bit integers
    CU_RES_VIEW_FORMAT_SINT_2X8 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_2X8

    #: 4 channel signed 8-bit integers
    CU_RES_VIEW_FORMAT_SINT_4X8 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_4X8

    #: 1 channel unsigned 16-bit integers
    CU_RES_VIEW_FORMAT_UINT_1X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_1X16

    #: 2 channel unsigned 16-bit integers
    CU_RES_VIEW_FORMAT_UINT_2X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_2X16

    #: 4 channel unsigned 16-bit integers
    CU_RES_VIEW_FORMAT_UINT_4X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_4X16

    #: 1 channel signed 16-bit integers
    CU_RES_VIEW_FORMAT_SINT_1X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_1X16

    #: 2 channel signed 16-bit integers
    CU_RES_VIEW_FORMAT_SINT_2X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_2X16

    #: 4 channel signed 16-bit integers
    CU_RES_VIEW_FORMAT_SINT_4X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_4X16

    #: 1 channel unsigned 32-bit integers
    CU_RES_VIEW_FORMAT_UINT_1X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_1X32

    #: 2 channel unsigned 32-bit integers
    CU_RES_VIEW_FORMAT_UINT_2X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_2X32

    #: 4 channel unsigned 32-bit integers
    CU_RES_VIEW_FORMAT_UINT_4X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UINT_4X32

    #: 1 channel signed 32-bit integers
    CU_RES_VIEW_FORMAT_SINT_1X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_1X32

    #: 2 channel signed 32-bit integers
    CU_RES_VIEW_FORMAT_SINT_2X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_2X32

    #: 4 channel signed 32-bit integers
    CU_RES_VIEW_FORMAT_SINT_4X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SINT_4X32

    #: 1 channel 16-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_1X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_1X16

    #: 2 channel 16-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_2X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_2X16

    #: 4 channel 16-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_4X16 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_4X16

    #: 1 channel 32-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_1X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_1X32

    #: 2 channel 32-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_2X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_2X32

    #: 4 channel 32-bit floating point
    CU_RES_VIEW_FORMAT_FLOAT_4X32 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_FLOAT_4X32

    #: Block compressed 1
    CU_RES_VIEW_FORMAT_UNSIGNED_BC1 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC1

    #: Block compressed 2
    CU_RES_VIEW_FORMAT_UNSIGNED_BC2 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC2

    #: Block compressed 3
    CU_RES_VIEW_FORMAT_UNSIGNED_BC3 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC3

    #: Block compressed 4 unsigned
    CU_RES_VIEW_FORMAT_UNSIGNED_BC4 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC4

    #: Block compressed 4 signed
    CU_RES_VIEW_FORMAT_SIGNED_BC4 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SIGNED_BC4

    #: Block compressed 5 unsigned
    CU_RES_VIEW_FORMAT_UNSIGNED_BC5 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC5

    #: Block compressed 5 signed
    CU_RES_VIEW_FORMAT_SIGNED_BC5 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SIGNED_BC5

    #: Block compressed 6 unsigned half-float
    CU_RES_VIEW_FORMAT_UNSIGNED_BC6H = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC6H

    #: Block compressed 6 signed half-float
    CU_RES_VIEW_FORMAT_SIGNED_BC6H = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_SIGNED_BC6H

    #: Block compressed 7
    CU_RES_VIEW_FORMAT_UNSIGNED_BC7 = ccuda.CUresourceViewFormat_enum.CU_RES_VIEW_FORMAT_UNSIGNED_BC7

class CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS(IntEnum):
    """
    Access flags that specify the level of access the current context's
    device has on the memory referenced.
    """

    #: No access, meaning the device cannot access this memory at all, thus
    #: must be staged through accessible memory in order to complete
    #: certain operations
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE = ccuda.CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum.CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE

    #: Read-only access, meaning writes to this memory are considered
    #: invalid accesses and thus return error in that case.
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ = ccuda.CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum.CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ

    #: Read-write access, the device has full read-write access to the
    #: memory
    CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE = ccuda.CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS_enum.CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE

class CUexternalMemoryHandleType(IntEnum):
    """
    External memory handle types
    """

    #: Handle is an opaque file descriptor
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD = ccuda.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD

    #: Handle is an opaque shared NT handle
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32 = ccuda.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32

    #: Handle is an opaque, globally shared handle
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT = ccuda.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT

    #: Handle is a D3D12 heap object
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP = ccuda.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP

    #: Handle is a D3D12 committed resource
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE = ccuda.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE

    #: Handle is a shared NT handle to a D3D11 resource
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE = ccuda.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE

    #: Handle is a globally shared handle to a D3D11 resource
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT = ccuda.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT

    #: Handle is an NvSciBuf object
    CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF = ccuda.CUexternalMemoryHandleType_enum.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF

class CUexternalSemaphoreHandleType(IntEnum):
    """
    External semaphore handle types
    """

    #: Handle is an opaque file descriptor
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD

    #: Handle is an opaque shared NT handle
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32 = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32

    #: Handle is an opaque, globally shared handle
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT

    #: Handle is a shared NT handle referencing a D3D12 fence object
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE

    #: Handle is a shared NT handle referencing a D3D11 fence object
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE

    #: Opaque handle to NvSciSync Object
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC

    #: Handle is a shared NT handle referencing a D3D11 keyed mutex object
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX

    #: Handle is a globally shared handle referencing a D3D11 keyed mutex
    #: object
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT

    #: Handle is an opaque file descriptor referencing a timeline semaphore
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD

    #: Handle is an opaque shared NT handle referencing a timeline
    #: semaphore
    CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32 = ccuda.CUexternalSemaphoreHandleType_enum.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32

class CUmemAllocationHandleType(IntEnum):
    """
    Flags for specifying particular handle types
    """

    #: Does not allow any export mechanism. >
    CU_MEM_HANDLE_TYPE_NONE = ccuda.CUmemAllocationHandleType_enum.CU_MEM_HANDLE_TYPE_NONE

    #: Allows a file descriptor to be used for exporting. Permitted only on
    #: POSIX systems. (int)
    CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR = ccuda.CUmemAllocationHandleType_enum.CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR

    #: Allows a Win32 NT handle to be used for exporting. (HANDLE)
    CU_MEM_HANDLE_TYPE_WIN32 = ccuda.CUmemAllocationHandleType_enum.CU_MEM_HANDLE_TYPE_WIN32

    #: Allows a Win32 KMT handle to be used for exporting. (D3DKMT_HANDLE)
    CU_MEM_HANDLE_TYPE_WIN32_KMT = ccuda.CUmemAllocationHandleType_enum.CU_MEM_HANDLE_TYPE_WIN32_KMT
    CU_MEM_HANDLE_TYPE_MAX = ccuda.CUmemAllocationHandleType_enum.CU_MEM_HANDLE_TYPE_MAX

class CUmemAccess_flags(IntEnum):
    """
    Specifies the memory protection flags for mapping.
    """

    #: Default, make the address range not accessible
    CU_MEM_ACCESS_FLAGS_PROT_NONE = ccuda.CUmemAccess_flags_enum.CU_MEM_ACCESS_FLAGS_PROT_NONE

    #: Make the address range read accessible
    CU_MEM_ACCESS_FLAGS_PROT_READ = ccuda.CUmemAccess_flags_enum.CU_MEM_ACCESS_FLAGS_PROT_READ

    #: Make the address range read-write accessible
    CU_MEM_ACCESS_FLAGS_PROT_READWRITE = ccuda.CUmemAccess_flags_enum.CU_MEM_ACCESS_FLAGS_PROT_READWRITE
    CU_MEM_ACCESS_FLAGS_PROT_MAX = ccuda.CUmemAccess_flags_enum.CU_MEM_ACCESS_FLAGS_PROT_MAX

class CUmemLocationType(IntEnum):
    """
    Specifies the type of location
    """
    CU_MEM_LOCATION_TYPE_INVALID = ccuda.CUmemLocationType_enum.CU_MEM_LOCATION_TYPE_INVALID

    #: Location is a device location, thus id is a device ordinal
    CU_MEM_LOCATION_TYPE_DEVICE = ccuda.CUmemLocationType_enum.CU_MEM_LOCATION_TYPE_DEVICE
    CU_MEM_LOCATION_TYPE_MAX = ccuda.CUmemLocationType_enum.CU_MEM_LOCATION_TYPE_MAX

class CUmemAllocationType(IntEnum):
    """
    Defines the allocation types available
    """
    CU_MEM_ALLOCATION_TYPE_INVALID = ccuda.CUmemAllocationType_enum.CU_MEM_ALLOCATION_TYPE_INVALID

    #: This allocation type is 'pinned', i.e. cannot migrate from its
    #: current location while the application is actively using it
    CU_MEM_ALLOCATION_TYPE_PINNED = ccuda.CUmemAllocationType_enum.CU_MEM_ALLOCATION_TYPE_PINNED
    CU_MEM_ALLOCATION_TYPE_MAX = ccuda.CUmemAllocationType_enum.CU_MEM_ALLOCATION_TYPE_MAX

class CUmemAllocationGranularity_flags(IntEnum):
    """
    Flag for requesting different optimal and required granularities
    for an allocation.
    """

    #: Minimum required granularity for allocation
    CU_MEM_ALLOC_GRANULARITY_MINIMUM = ccuda.CUmemAllocationGranularity_flags_enum.CU_MEM_ALLOC_GRANULARITY_MINIMUM

    #: Recommended granularity for allocation for best performance
    CU_MEM_ALLOC_GRANULARITY_RECOMMENDED = ccuda.CUmemAllocationGranularity_flags_enum.CU_MEM_ALLOC_GRANULARITY_RECOMMENDED

class CUmemRangeHandleType(IntEnum):
    """
    Specifies the handle type for address range
    """
    CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD = ccuda.CUmemRangeHandleType_enum.CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD
    CU_MEM_RANGE_HANDLE_TYPE_MAX = ccuda.CUmemRangeHandleType_enum.CU_MEM_RANGE_HANDLE_TYPE_MAX

class CUarraySparseSubresourceType(IntEnum):
    """
    Sparse subresource types
    """
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL = ccuda.CUarraySparseSubresourceType_enum.CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL
    CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL = ccuda.CUarraySparseSubresourceType_enum.CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL

class CUmemOperationType(IntEnum):
    """
    Memory operation types
    """
    CU_MEM_OPERATION_TYPE_MAP = ccuda.CUmemOperationType_enum.CU_MEM_OPERATION_TYPE_MAP
    CU_MEM_OPERATION_TYPE_UNMAP = ccuda.CUmemOperationType_enum.CU_MEM_OPERATION_TYPE_UNMAP

class CUmemHandleType(IntEnum):
    """
    Memory handle types
    """
    CU_MEM_HANDLE_TYPE_GENERIC = ccuda.CUmemHandleType_enum.CU_MEM_HANDLE_TYPE_GENERIC

class CUmemAllocationCompType(IntEnum):
    """
    Specifies compression attribute for an allocation.
    """

    #: Allocating non-compressible memory
    CU_MEM_ALLOCATION_COMP_NONE = ccuda.CUmemAllocationCompType_enum.CU_MEM_ALLOCATION_COMP_NONE

    #: Allocating compressible memory
    CU_MEM_ALLOCATION_COMP_GENERIC = ccuda.CUmemAllocationCompType_enum.CU_MEM_ALLOCATION_COMP_GENERIC

class CUgraphExecUpdateResult(IntEnum):
    """

    """

    #: The update succeeded
    CU_GRAPH_EXEC_UPDATE_SUCCESS = ccuda.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_SUCCESS

    #: The update failed for an unexpected reason which is described in the
    #: return value of the function
    CU_GRAPH_EXEC_UPDATE_ERROR = ccuda.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR

    #: The update failed because the topology changed
    CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED = ccuda.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED

    #: The update failed because a node type changed
    CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED = ccuda.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED

    #: The update failed because the function of a kernel node changed
    #: (CUDA driver < 11.2)
    CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED = ccuda.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED

    #: The update failed because the parameters changed in a way that is
    #: not supported
    CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED = ccuda.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED

    #: The update failed because something about the node is not supported
    CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED = ccuda.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED

    #: The update failed because the function of a kernel node changed in
    #: an unsupported way
    CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE = ccuda.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE

    #: The update failed because the node attributes changed in a way that
    #: is not supported
    CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED = ccuda.CUgraphExecUpdateResult_enum.CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED

class CUmemPool_attribute(IntEnum):
    """
    CUDA memory pool attributes
    """

    #: (value type = int) Allow cuMemAllocAsync to use memory
    #: asynchronously freed in another streams as long as a stream ordering
    #: dependency of the allocating stream on the free action exists. Cuda
    #: events and null stream interactions can create the required stream
    #: ordered dependencies. (default enabled)
    CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES = ccuda.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES

    #: (value type = int) Allow reuse of already completed frees when there
    #: is no dependency between the free and allocation. (default enabled)
    CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC = ccuda.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC

    #: (value type = int) Allow cuMemAllocAsync to insert new stream
    #: dependencies in order to establish the stream ordering required to
    #: reuse a piece of memory released by cuFreeAsync (default enabled).
    CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES = ccuda.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES

    #: (value type = cuuint64_t) Amount of reserved memory in bytes to hold
    #: onto before trying to release memory back to the OS. When more than
    #: the release threshold bytes of memory are held by the memory pool,
    #: the allocator will try to release memory back to the OS on the next
    #: call to stream, event or context synchronize. (default 0)
    CU_MEMPOOL_ATTR_RELEASE_THRESHOLD = ccuda.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_RELEASE_THRESHOLD

    #: (value type = cuuint64_t) Amount of backing memory currently
    #: allocated for the mempool.
    CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT = ccuda.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT

    #: (value type = cuuint64_t) High watermark of backing memory allocated
    #: for the mempool since the last time it was reset. High watermark can
    #: only be reset to zero.
    CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH = ccuda.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH

    #: (value type = cuuint64_t) Amount of memory from the pool that is
    #: currently in use by the application.
    CU_MEMPOOL_ATTR_USED_MEM_CURRENT = ccuda.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_USED_MEM_CURRENT

    #: (value type = cuuint64_t) High watermark of the amount of memory
    #: from the pool that was in use by the application since the last time
    #: it was reset. High watermark can only be reset to zero.
    CU_MEMPOOL_ATTR_USED_MEM_HIGH = ccuda.CUmemPool_attribute_enum.CU_MEMPOOL_ATTR_USED_MEM_HIGH

class CUgraphMem_attribute(IntEnum):
    """

    """

    #: (value type = cuuint64_t) Amount of memory, in bytes, currently
    #: associated with graphs
    CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT = ccuda.CUgraphMem_attribute_enum.CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT

    #: (value type = cuuint64_t) High watermark of memory, in bytes,
    #: associated with graphs since the last time it was reset. High
    #: watermark can only be reset to zero.
    CU_GRAPH_MEM_ATTR_USED_MEM_HIGH = ccuda.CUgraphMem_attribute_enum.CU_GRAPH_MEM_ATTR_USED_MEM_HIGH

    #: (value type = cuuint64_t) Amount of memory, in bytes, currently
    #: allocated for use by the CUDA graphs asynchronous allocator.
    CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT = ccuda.CUgraphMem_attribute_enum.CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT

    #: (value type = cuuint64_t) High watermark of memory, in bytes,
    #: currently allocated for use by the CUDA graphs asynchronous
    #: allocator.
    CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH = ccuda.CUgraphMem_attribute_enum.CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH

class CUflushGPUDirectRDMAWritesOptions(IntEnum):
    """
    Bitmasks for
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS`
    """

    #: :py:obj:`~.cuFlushGPUDirectRDMAWrites()` and its CUDA Runtime API
    #: counterpart are supported on the device.
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST = ccuda.CUflushGPUDirectRDMAWritesOptions_enum.CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST

    #: The :py:obj:`~.CU_STREAM_WAIT_VALUE_FLUSH` flag and the
    #: :py:obj:`~.CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES` MemOp are supported
    #: on the device.
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS = ccuda.CUflushGPUDirectRDMAWritesOptions_enum.CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS

class CUGPUDirectRDMAWritesOrdering(IntEnum):
    """
    Platform native ordering for GPUDirect RDMA writes
    """

    #: The device does not natively support ordering of remote writes.
    #: :py:obj:`~.cuFlushGPUDirectRDMAWrites()` can be leveraged if
    #: supported.
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE = ccuda.CUGPUDirectRDMAWritesOrdering_enum.CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE

    #: Natively, the device can consistently consume remote writes,
    #: although other CUDA devices may not.
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER = ccuda.CUGPUDirectRDMAWritesOrdering_enum.CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER

    #: Any CUDA device in the system can consistently consume remote writes
    #: to this device.
    CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES = ccuda.CUGPUDirectRDMAWritesOrdering_enum.CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES

class CUflushGPUDirectRDMAWritesScope(IntEnum):
    """
    The scopes for :py:obj:`~.cuFlushGPUDirectRDMAWrites`
    """

    #: Blocks until remote writes are visible to the CUDA device context
    #: owning the data.
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER = ccuda.CUflushGPUDirectRDMAWritesScope_enum.CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER

    #: Blocks until remote writes are visible to all CUDA device contexts.
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES = ccuda.CUflushGPUDirectRDMAWritesScope_enum.CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES

class CUflushGPUDirectRDMAWritesTarget(IntEnum):
    """
    The targets for :py:obj:`~.cuFlushGPUDirectRDMAWrites`
    """

    #: Sets the target for :py:obj:`~.cuFlushGPUDirectRDMAWrites()` to the
    #: currently active CUDA device context.
    CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX = ccuda.CUflushGPUDirectRDMAWritesTarget_enum.CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX

class CUgraphDebugDot_flags(IntEnum):
    """
    The additional write options for :py:obj:`~.cuGraphDebugDotPrint`
    """
    CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE

    #: Output all debug data as if every debug flag is enabled
    CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES

    #: Use CUDA Runtime structures for output
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS

    #: Adds CUDA_KERNEL_NODE_PARAMS values to output
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS

    #: Adds CUDA_MEMCPY3D values to output
    CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS

    #: Adds CUDA_MEMSET_NODE_PARAMS values to output
    CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS

    #: Adds CUDA_HOST_NODE_PARAMS values to output
    CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS

    #: Adds CUevent handle from record and wait nodes to output
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS

    #: Adds CUDA_EXT_SEM_SIGNAL_NODE_PARAMS values to output
    CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS

    #: Adds CUDA_EXT_SEM_WAIT_NODE_PARAMS values to output
    CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES

    #: Adds CUkernelNodeAttrValue values to output
    CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES

    #: Adds node handles and every kernel function handle to output
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS

    #: Adds memory alloc node parameters to output
    CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS
    CU_GRAPH_DEBUG_DOT_FLAGS_BATCH_MEM_OP_NODE_PARAMS = ccuda.CUgraphDebugDot_flags_enum.CU_GRAPH_DEBUG_DOT_FLAGS_BATCH_MEM_OP_NODE_PARAMS

class CUuserObject_flags(IntEnum):
    """
    Flags for user objects for graphs
    """

    #: Indicates the destructor execution is not synchronized by any CUDA
    #: handle.
    CU_USER_OBJECT_NO_DESTRUCTOR_SYNC = ccuda.CUuserObject_flags_enum.CU_USER_OBJECT_NO_DESTRUCTOR_SYNC

class CUuserObjectRetain_flags(IntEnum):
    """
    Flags for retaining user object references for graphs
    """

    #: Transfer references from the caller rather than creating new
    #: references.
    CU_GRAPH_USER_OBJECT_MOVE = ccuda.CUuserObjectRetain_flags_enum.CU_GRAPH_USER_OBJECT_MOVE

class CUgraphInstantiate_flags(IntEnum):
    """
    Flags for instantiating a graph
    """

    #: Automatically free memory allocated in a graph before relaunching.
    CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH = ccuda.CUgraphInstantiate_flags_enum.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH

    #: Run the graph using the per-node priority attributes rather than the
    #: priority of the stream it is launched into.
    CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY = ccuda.CUgraphInstantiate_flags_enum.CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY

class CUmoduleLoadingMode(IntEnum):
    """
    CUDA Lazy Loading status
    """
    CU_MODULE_EAGER_LOADING = ccuda.CUmoduleLoadingMode_enum.CU_MODULE_EAGER_LOADING
    CU_MODULE_LAZY_LOADING = ccuda.CUmoduleLoadingMode_enum.CU_MODULE_LAZY_LOADING

class CUoutput_mode(IntEnum):
    """
    Profiler Output Modes
    """

    #: Output mode Key-Value pair format.
    CU_OUT_KEY_VALUE_PAIR = ccuda.CUoutput_mode_enum.CU_OUT_KEY_VALUE_PAIR

    #: Output mode Comma separated values format.
    CU_OUT_CSV = ccuda.CUoutput_mode_enum.CU_OUT_CSV

class CUeglFrameType(IntEnum):
    """
    CUDA EglFrame type - array or pointer
    """

    #: Frame type CUDA array
    CU_EGL_FRAME_TYPE_ARRAY = ccuda.CUeglFrameType_enum.CU_EGL_FRAME_TYPE_ARRAY

    #: Frame type pointer
    CU_EGL_FRAME_TYPE_PITCH = ccuda.CUeglFrameType_enum.CU_EGL_FRAME_TYPE_PITCH

class CUeglResourceLocationFlags(IntEnum):
    """
    Resource location flags- sysmem or vidmem  For CUDA context on
    iGPU, since video and system memory are equivalent - these flags
    will not have an effect on the execution.  For CUDA context on
    dGPU, applications can use the flag
    :py:obj:`~.CUeglResourceLocationFlags` to give a hint about the
    desired location.  :py:obj:`~.CU_EGL_RESOURCE_LOCATION_SYSMEM` -
    the frame data is made resident on the system memory to be accessed
    by CUDA.  :py:obj:`~.CU_EGL_RESOURCE_LOCATION_VIDMEM` - the frame
    data is made resident on the dedicated video memory to be accessed
    by CUDA.  There may be an additional latency due to new allocation
    and data migration, if the frame is produced on a different memory.
    """

    #: Resource location sysmem
    CU_EGL_RESOURCE_LOCATION_SYSMEM = ccuda.CUeglResourceLocationFlags_enum.CU_EGL_RESOURCE_LOCATION_SYSMEM

    #: Resource location vidmem
    CU_EGL_RESOURCE_LOCATION_VIDMEM = ccuda.CUeglResourceLocationFlags_enum.CU_EGL_RESOURCE_LOCATION_VIDMEM

class CUeglColorFormat(IntEnum):
    """
    CUDA EGL Color Format - The different planar and multiplanar
    formats currently supported for CUDA_EGL interops. Three channel
    formats are currently not supported for
    :py:obj:`~.CU_EGL_FRAME_TYPE_ARRAY`
    """

    #: Y, U, V in three surfaces, each in a separate surface, U/V width =
    #: 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YUV420_PLANAR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV420_PLANAR

    #: Y, UV in two surfaces (UV as one surface) with VU byte ordering,
    #: width, height ratio same as YUV420Planar.
    CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR

    #: Y, U, V each in a separate surface, U/V width = 1/2 Y width, U/V
    #: height = Y height.
    CU_EGL_COLOR_FORMAT_YUV422_PLANAR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV422_PLANAR

    #: Y, UV in two surfaces with VU byte ordering, width, height ratio
    #: same as YUV422Planar.
    CU_EGL_COLOR_FORMAT_YUV422_SEMIPLANAR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV422_SEMIPLANAR

    #: R/G/B three channels in one surface with BGR byte ordering. Only
    #: pitch linear format supported.
    CU_EGL_COLOR_FORMAT_RGB = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_RGB

    #: R/G/B three channels in one surface with RGB byte ordering. Only
    #: pitch linear format supported.
    CU_EGL_COLOR_FORMAT_BGR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BGR

    #: R/G/B/A four channels in one surface with BGRA byte ordering.
    CU_EGL_COLOR_FORMAT_ARGB = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_ARGB

    #: R/G/B/A four channels in one surface with ABGR byte ordering.
    CU_EGL_COLOR_FORMAT_RGBA = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_RGBA

    #: single luminance channel in one surface.
    CU_EGL_COLOR_FORMAT_L = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_L

    #: single color channel in one surface.
    CU_EGL_COLOR_FORMAT_R = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_R

    #: Y, U, V in three surfaces, each in a separate surface, U/V width = Y
    #: width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YUV444_PLANAR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV444_PLANAR

    #: Y, UV in two surfaces (UV as one surface) with VU byte ordering,
    #: width, height ratio same as YUV444Planar.
    CU_EGL_COLOR_FORMAT_YUV444_SEMIPLANAR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV444_SEMIPLANAR

    #: Y, U, V in one surface, interleaved as UYVY in one channel.
    CU_EGL_COLOR_FORMAT_YUYV_422 = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUYV_422

    #: Y, U, V in one surface, interleaved as YUYV in one channel.
    CU_EGL_COLOR_FORMAT_UYVY_422 = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_UYVY_422

    #: R/G/B/A four channels in one surface with RGBA byte ordering.
    CU_EGL_COLOR_FORMAT_ABGR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_ABGR

    #: R/G/B/A four channels in one surface with ARGB byte ordering.
    CU_EGL_COLOR_FORMAT_BGRA = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BGRA

    #: Alpha color format - one channel in one surface.
    CU_EGL_COLOR_FORMAT_A = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_A

    #: R/G color format - two channels in one surface with GR byte ordering
    CU_EGL_COLOR_FORMAT_RG = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_RG

    #: Y, U, V, A four channels in one surface, interleaved as VUYA.
    CU_EGL_COLOR_FORMAT_AYUV = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_AYUV

    #: Y, VU in two surfaces (VU as one surface) with UV byte ordering, U/V
    #: width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YVU444_SEMIPLANAR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU444_SEMIPLANAR

    #: Y, VU in two surfaces (VU as one surface) with UV byte ordering, U/V
    #: width = 1/2 Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YVU422_SEMIPLANAR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU422_SEMIPLANAR

    #: Y, VU in two surfaces (VU as one surface) with UV byte ordering, U/V
    #: width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR

    #: Y10, V10U10 in two surfaces (VU as one surface) with UV byte
    #: ordering, U/V width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR

    #: Y10, V10U10 in two surfaces (VU as one surface) with UV byte
    #: ordering, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR

    #: Y12, V12U12 in two surfaces (VU as one surface) with UV byte
    #: ordering, U/V width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR

    #: Y12, V12U12 in two surfaces (VU as one surface) with UV byte
    #: ordering, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR

    #: Extended Range Y, U, V in one surface, interleaved as YVYU in one
    #: channel.
    CU_EGL_COLOR_FORMAT_VYUY_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_VYUY_ER

    #: Extended Range Y, U, V in one surface, interleaved as YUYV in one
    #: channel.
    CU_EGL_COLOR_FORMAT_UYVY_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_UYVY_ER

    #: Extended Range Y, U, V in one surface, interleaved as UYVY in one
    #: channel.
    CU_EGL_COLOR_FORMAT_YUYV_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUYV_ER

    #: Extended Range Y, U, V in one surface, interleaved as VYUY in one
    #: channel.
    CU_EGL_COLOR_FORMAT_YVYU_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVYU_ER

    #: Extended Range Y, U, V three channels in one surface, interleaved as
    #: VUY. Only pitch linear format supported.
    CU_EGL_COLOR_FORMAT_YUV_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV_ER

    #: Extended Range Y, U, V, A four channels in one surface, interleaved
    #: as AVUY.
    CU_EGL_COLOR_FORMAT_YUVA_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUVA_ER

    #: Extended Range Y, U, V, A four channels in one surface, interleaved
    #: as VUYA.
    CU_EGL_COLOR_FORMAT_AYUV_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_AYUV_ER

    #: Extended Range Y, U, V in three surfaces, U/V width = Y width, U/V
    #: height = Y height.
    CU_EGL_COLOR_FORMAT_YUV444_PLANAR_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV444_PLANAR_ER

    #: Extended Range Y, U, V in three surfaces, U/V width = 1/2 Y width,
    #: U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YUV422_PLANAR_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV422_PLANAR_ER

    #: Extended Range Y, U, V in three surfaces, U/V width = 1/2 Y width,
    #: U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YUV420_PLANAR_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV420_PLANAR_ER

    #: Extended Range Y, UV in two surfaces (UV as one surface) with VU
    #: byte ordering, U/V width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YUV444_SEMIPLANAR_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV444_SEMIPLANAR_ER

    #: Extended Range Y, UV in two surfaces (UV as one surface) with VU
    #: byte ordering, U/V width = 1/2 Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YUV422_SEMIPLANAR_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV422_SEMIPLANAR_ER

    #: Extended Range Y, UV in two surfaces (UV as one surface) with VU
    #: byte ordering, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_ER

    #: Extended Range Y, V, U in three surfaces, U/V width = Y width, U/V
    #: height = Y height.
    CU_EGL_COLOR_FORMAT_YVU444_PLANAR_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU444_PLANAR_ER

    #: Extended Range Y, V, U in three surfaces, U/V width = 1/2 Y width,
    #: U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YVU422_PLANAR_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU422_PLANAR_ER

    #: Extended Range Y, V, U in three surfaces, U/V width = 1/2 Y width,
    #: U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YVU420_PLANAR_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU420_PLANAR_ER

    #: Extended Range Y, VU in two surfaces (VU as one surface) with UV
    #: byte ordering, U/V width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YVU444_SEMIPLANAR_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU444_SEMIPLANAR_ER

    #: Extended Range Y, VU in two surfaces (VU as one surface) with UV
    #: byte ordering, U/V width = 1/2 Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YVU422_SEMIPLANAR_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU422_SEMIPLANAR_ER

    #: Extended Range Y, VU in two surfaces (VU as one surface) with UV
    #: byte ordering, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_ER

    #: Bayer format - one channel in one surface with interleaved RGGB
    #: ordering.
    CU_EGL_COLOR_FORMAT_BAYER_RGGB = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_RGGB

    #: Bayer format - one channel in one surface with interleaved BGGR
    #: ordering.
    CU_EGL_COLOR_FORMAT_BAYER_BGGR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_BGGR

    #: Bayer format - one channel in one surface with interleaved GRBG
    #: ordering.
    CU_EGL_COLOR_FORMAT_BAYER_GRBG = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_GRBG

    #: Bayer format - one channel in one surface with interleaved GBRG
    #: ordering.
    CU_EGL_COLOR_FORMAT_BAYER_GBRG = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_GBRG

    #: Bayer10 format - one channel in one surface with interleaved RGGB
    #: ordering. Out of 16 bits, 10 bits used 6 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER10_RGGB = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER10_RGGB

    #: Bayer10 format - one channel in one surface with interleaved BGGR
    #: ordering. Out of 16 bits, 10 bits used 6 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER10_BGGR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER10_BGGR

    #: Bayer10 format - one channel in one surface with interleaved GRBG
    #: ordering. Out of 16 bits, 10 bits used 6 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER10_GRBG = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER10_GRBG

    #: Bayer10 format - one channel in one surface with interleaved GBRG
    #: ordering. Out of 16 bits, 10 bits used 6 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER10_GBRG = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER10_GBRG

    #: Bayer12 format - one channel in one surface with interleaved RGGB
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_RGGB = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_RGGB

    #: Bayer12 format - one channel in one surface with interleaved BGGR
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_BGGR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_BGGR

    #: Bayer12 format - one channel in one surface with interleaved GRBG
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_GRBG = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_GRBG

    #: Bayer12 format - one channel in one surface with interleaved GBRG
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_GBRG = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_GBRG

    #: Bayer14 format - one channel in one surface with interleaved RGGB
    #: ordering. Out of 16 bits, 14 bits used 2 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER14_RGGB = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER14_RGGB

    #: Bayer14 format - one channel in one surface with interleaved BGGR
    #: ordering. Out of 16 bits, 14 bits used 2 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER14_BGGR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER14_BGGR

    #: Bayer14 format - one channel in one surface with interleaved GRBG
    #: ordering. Out of 16 bits, 14 bits used 2 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER14_GRBG = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER14_GRBG

    #: Bayer14 format - one channel in one surface with interleaved GBRG
    #: ordering. Out of 16 bits, 14 bits used 2 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER14_GBRG = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER14_GBRG

    #: Bayer20 format - one channel in one surface with interleaved RGGB
    #: ordering. Out of 32 bits, 20 bits used 12 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER20_RGGB = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER20_RGGB

    #: Bayer20 format - one channel in one surface with interleaved BGGR
    #: ordering. Out of 32 bits, 20 bits used 12 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER20_BGGR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER20_BGGR

    #: Bayer20 format - one channel in one surface with interleaved GRBG
    #: ordering. Out of 32 bits, 20 bits used 12 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER20_GRBG = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER20_GRBG

    #: Bayer20 format - one channel in one surface with interleaved GBRG
    #: ordering. Out of 32 bits, 20 bits used 12 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER20_GBRG = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER20_GBRG

    #: Y, V, U in three surfaces, each in a separate surface, U/V width = Y
    #: width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YVU444_PLANAR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU444_PLANAR

    #: Y, V, U in three surfaces, each in a separate surface, U/V width =
    #: 1/2 Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_YVU422_PLANAR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU422_PLANAR

    #: Y, V, U in three surfaces, each in a separate surface, U/V width =
    #: 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YVU420_PLANAR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU420_PLANAR

    #: Nvidia proprietary Bayer ISP format - one channel in one surface
    #: with interleaved RGGB ordering and mapped to opaque integer
    #: datatype.
    CU_EGL_COLOR_FORMAT_BAYER_ISP_RGGB = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_ISP_RGGB

    #: Nvidia proprietary Bayer ISP format - one channel in one surface
    #: with interleaved BGGR ordering and mapped to opaque integer
    #: datatype.
    CU_EGL_COLOR_FORMAT_BAYER_ISP_BGGR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_ISP_BGGR

    #: Nvidia proprietary Bayer ISP format - one channel in one surface
    #: with interleaved GRBG ordering and mapped to opaque integer
    #: datatype.
    CU_EGL_COLOR_FORMAT_BAYER_ISP_GRBG = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_ISP_GRBG

    #: Nvidia proprietary Bayer ISP format - one channel in one surface
    #: with interleaved GBRG ordering and mapped to opaque integer
    #: datatype.
    CU_EGL_COLOR_FORMAT_BAYER_ISP_GBRG = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_ISP_GBRG

    #: Bayer format - one channel in one surface with interleaved BCCR
    #: ordering.
    CU_EGL_COLOR_FORMAT_BAYER_BCCR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_BCCR

    #: Bayer format - one channel in one surface with interleaved RCCB
    #: ordering.
    CU_EGL_COLOR_FORMAT_BAYER_RCCB = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_RCCB

    #: Bayer format - one channel in one surface with interleaved CRBC
    #: ordering.
    CU_EGL_COLOR_FORMAT_BAYER_CRBC = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_CRBC

    #: Bayer format - one channel in one surface with interleaved CBRC
    #: ordering.
    CU_EGL_COLOR_FORMAT_BAYER_CBRC = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER_CBRC

    #: Bayer10 format - one channel in one surface with interleaved CCCC
    #: ordering. Out of 16 bits, 10 bits used 6 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER10_CCCC = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER10_CCCC

    #: Bayer12 format - one channel in one surface with interleaved BCCR
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_BCCR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_BCCR

    #: Bayer12 format - one channel in one surface with interleaved RCCB
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_RCCB = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_RCCB

    #: Bayer12 format - one channel in one surface with interleaved CRBC
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_CRBC = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_CRBC

    #: Bayer12 format - one channel in one surface with interleaved CBRC
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_CBRC = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_CBRC

    #: Bayer12 format - one channel in one surface with interleaved CCCC
    #: ordering. Out of 16 bits, 12 bits used 4 bits No-op.
    CU_EGL_COLOR_FORMAT_BAYER12_CCCC = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_BAYER12_CCCC

    #: Color format for single Y plane.
    CU_EGL_COLOR_FORMAT_Y = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y

    #: Y, UV in two surfaces (UV as one surface) U/V width = 1/2 Y width,
    #: U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_2020 = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_2020

    #: Y, VU in two surfaces (VU as one surface) U/V width = 1/2 Y width,
    #: U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_2020 = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_2020

    #: Y, U, V each in a separate surface, U/V width = 1/2 Y width, U/V
    #: height= 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YUV420_PLANAR_2020 = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV420_PLANAR_2020

    #: Y, V, U each in a separate surface, U/V width = 1/2 Y width, U/V
    #: height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YVU420_PLANAR_2020 = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU420_PLANAR_2020

    #: Y, UV in two surfaces (UV as one surface) U/V width = 1/2 Y width,
    #: U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_709 = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_709

    #: Y, VU in two surfaces (VU as one surface) U/V width = 1/2 Y width,
    #: U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_709 = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_709

    #: Y, U, V each in a separate surface, U/V width = 1/2 Y width, U/V
    #: height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YUV420_PLANAR_709 = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV420_PLANAR_709

    #: Y, V, U each in a separate surface, U/V width = 1/2 Y width, U/V
    #: height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_YVU420_PLANAR_709 = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVU420_PLANAR_709

    #: Y10, V10U10 in two surfaces (VU as one surface), U/V width = 1/2 Y
    #: width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_709 = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_709

    #: Y10, V10U10 in two surfaces (VU as one surface), U/V width = 1/2 Y
    #: width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_2020 = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_2020

    #: Y10, V10U10 in two surfaces(VU as one surface) U/V width = 1/2 Y
    #: width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR_2020 = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR_2020

    #: Y10, V10U10 in two surfaces(VU as one surface) U/V width = 1/2 Y
    #: width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR

    #: Y10, V10U10 in two surfaces(VU as one surface) U/V width = 1/2 Y
    #: width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR_709 = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR_709

    #: Extended Range Color format for single Y plane.
    CU_EGL_COLOR_FORMAT_Y_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y_ER

    #: Extended Range Color format for single Y plane.
    CU_EGL_COLOR_FORMAT_Y_709_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y_709_ER

    #: Extended Range Color format for single Y10 plane.
    CU_EGL_COLOR_FORMAT_Y10_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10_ER

    #: Extended Range Color format for single Y10 plane.
    CU_EGL_COLOR_FORMAT_Y10_709_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10_709_ER

    #: Extended Range Color format for single Y12 plane.
    CU_EGL_COLOR_FORMAT_Y12_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y12_ER

    #: Extended Range Color format for single Y12 plane.
    CU_EGL_COLOR_FORMAT_Y12_709_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y12_709_ER

    #: Y, U, V, A four channels in one surface, interleaved as AVUY.
    CU_EGL_COLOR_FORMAT_YUVA = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUVA

    #: Y, U, V three channels in one surface, interleaved as VUY. Only
    #: pitch linear format supported.
    CU_EGL_COLOR_FORMAT_YUV = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YUV

    #: Y, U, V in one surface, interleaved as YVYU in one channel.
    CU_EGL_COLOR_FORMAT_YVYU = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_YVYU

    #: Y, U, V in one surface, interleaved as VYUY in one channel.
    CU_EGL_COLOR_FORMAT_VYUY = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_VYUY

    #: Extended Range Y10, V10U10 in two surfaces(VU as one surface) U/V
    #: width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_ER

    #: Extended Range Y10, V10U10 in two surfaces(VU as one surface) U/V
    #: width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_709_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_709_ER

    #: Extended Range Y10, V10U10 in two surfaces (VU as one surface) U/V
    #: width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR_ER

    #: Extended Range Y10, V10U10 in two surfaces (VU as one surface) U/V
    #: width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR_709_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR_709_ER

    #: Extended Range Y12, V12U12 in two surfaces (VU as one surface) U/V
    #: width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR_ER

    #: Extended Range Y12, V12U12 in two surfaces (VU as one surface) U/V
    #: width = 1/2 Y width, U/V height = 1/2 Y height.
    CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR_709_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR_709_ER

    #: Extended Range Y12, V12U12 in two surfaces (VU as one surface) U/V
    #: width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR_ER

    #: Extended Range Y12, V12U12 in two surfaces (VU as one surface) U/V
    #: width = Y width, U/V height = Y height.
    CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR_709_ER = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR_709_ER
    CU_EGL_COLOR_FORMAT_MAX = ccuda.CUeglColorFormat_enum.CU_EGL_COLOR_FORMAT_MAX

class CUGLDeviceList(IntEnum):
    """
    CUDA devices corresponding to an OpenGL device
    """

    #: The CUDA devices for all GPUs used by the current OpenGL context
    CU_GL_DEVICE_LIST_ALL = ccuda.CUGLDeviceList_enum.CU_GL_DEVICE_LIST_ALL

    #: The CUDA devices for the GPUs used by the current OpenGL context in
    #: its currently rendering frame
    CU_GL_DEVICE_LIST_CURRENT_FRAME = ccuda.CUGLDeviceList_enum.CU_GL_DEVICE_LIST_CURRENT_FRAME

    #: The CUDA devices for the GPUs to be used by the current OpenGL
    #: context in the next frame
    CU_GL_DEVICE_LIST_NEXT_FRAME = ccuda.CUGLDeviceList_enum.CU_GL_DEVICE_LIST_NEXT_FRAME

class CUGLmap_flags(IntEnum):
    """
    Flags to map or unmap a resource
    """
    CU_GL_MAP_RESOURCE_FLAGS_NONE = ccuda.CUGLmap_flags_enum.CU_GL_MAP_RESOURCE_FLAGS_NONE
    CU_GL_MAP_RESOURCE_FLAGS_READ_ONLY = ccuda.CUGLmap_flags_enum.CU_GL_MAP_RESOURCE_FLAGS_READ_ONLY
    CU_GL_MAP_RESOURCE_FLAGS_WRITE_DISCARD = ccuda.CUGLmap_flags_enum.CU_GL_MAP_RESOURCE_FLAGS_WRITE_DISCARD

cdef class CUcontext:
    """

    CUDA context

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUcontext>init_value
        else:
            self._ptr = <ccuda.CUcontext *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUcontext ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUmodule:
    """

    CUDA module

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUmodule>init_value
        else:
            self._ptr = <ccuda.CUmodule *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUmodule ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUfunction:
    """

    CUDA function

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUfunction>init_value
        else:
            self._ptr = <ccuda.CUfunction *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUfunction ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUarray:
    """

    CUDA array

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUarray>init_value
        else:
            self._ptr = <ccuda.CUarray *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUarray ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUmipmappedArray:
    """

    CUDA mipmapped array

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUmipmappedArray>init_value
        else:
            self._ptr = <ccuda.CUmipmappedArray *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUmipmappedArray ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUtexref:
    """

    CUDA texture reference

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUtexref>init_value
        else:
            self._ptr = <ccuda.CUtexref *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUtexref ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUsurfref:
    """

    CUDA surface reference

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUsurfref>init_value
        else:
            self._ptr = <ccuda.CUsurfref *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUsurfref ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUevent:
    """

    CUDA event

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUevent>init_value
        else:
            self._ptr = <ccuda.CUevent *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUevent ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUstream:
    """

    CUDA stream

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUstream>init_value
        else:
            self._ptr = <ccuda.CUstream *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUstream ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUgraphicsResource:
    """

    CUDA graphics interop resource

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUgraphicsResource>init_value
        else:
            self._ptr = <ccuda.CUgraphicsResource *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUgraphicsResource ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUexternalMemory:
    """

    CUDA external memory

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUexternalMemory>init_value
        else:
            self._ptr = <ccuda.CUexternalMemory *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUexternalMemory ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUexternalSemaphore:
    """

    CUDA external semaphore

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUexternalSemaphore>init_value
        else:
            self._ptr = <ccuda.CUexternalSemaphore *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUexternalSemaphore ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUgraph:
    """

    CUDA graph

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUgraph>init_value
        else:
            self._ptr = <ccuda.CUgraph *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUgraph ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUgraphNode:
    """

    CUDA graph node

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUgraphNode>init_value
        else:
            self._ptr = <ccuda.CUgraphNode *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUgraphNode ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUgraphExec:
    """

    CUDA executable graph

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUgraphExec>init_value
        else:
            self._ptr = <ccuda.CUgraphExec *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUgraphExec ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUmemoryPool:
    """

    CUDA memory pool

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUmemoryPool>init_value
        else:
            self._ptr = <ccuda.CUmemoryPool *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUmemoryPool ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUuserObject:
    """

    CUDA user object for graphs

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUuserObject>init_value
        else:
            self._ptr = <ccuda.CUuserObject *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUuserObject ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUlinkState:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUlinkState>init_value
        else:
            self._ptr = <ccuda.CUlinkState *>_ptr
    def __init__(self, *args, **kwargs):
        self._keepalive = []
    def __repr__(self):
        return '<CUlinkState ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class EGLImageKHR:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.EGLImageKHR>init_value
        else:
            self._ptr = <ccuda.EGLImageKHR *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<EGLImageKHR ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class EGLStreamKHR:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.EGLStreamKHR>init_value
        else:
            self._ptr = <ccuda.EGLStreamKHR *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<EGLStreamKHR ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class EGLSyncKHR:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.EGLSyncKHR>init_value
        else:
            self._ptr = <ccuda.EGLSyncKHR *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<EGLSyncKHR ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUeglStreamConnection:
    """

    CUDA EGLSream Connection

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUeglStreamConnection>init_value
        else:
            self._ptr = <ccuda.CUeglStreamConnection *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUeglStreamConnection ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUhostFn:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUhostFn>init_value
        else:
            self._ptr = <ccuda.CUhostFn *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUhostFn ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUstreamCallback:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUstreamCallback>init_value
        else:
            self._ptr = <ccuda.CUstreamCallback *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUstreamCallback ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUoccupancyB2DSize:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
            self._ptr[0] = <ccuda.CUoccupancyB2DSize>init_value
        else:
            self._ptr = <ccuda.CUoccupancyB2DSize *>_ptr
    def __init__(self, *args, **kwargs):
        pass
    def __repr__(self):
        return '<CUoccupancyB2DSize ' + str(hex(self.__int__())) + '>'
    def __index__(self):
        return self.__int__()
    def __int__(self):
        return <void_ptr>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUuuid_st:
    """

    Attributes
    ----------
    bytes : bytes
        < CUDA definition of UUID

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUuuid_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['bytes : ' + str(self.bytes.hex())]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def bytes(self):
        return PyBytes_FromStringAndSize(self._ptr[0].bytes, 16)

cdef class CUipcEventHandle_st:
    """
    CUDA IPC event handle

    Attributes
    ----------
    reserved : bytes


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUipcEventHandle_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(self._ptr[0].reserved, 64)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 64:
            raise ValueError("reserved length must be 64, is " + str(len(reserved)))
        if CHAR_MIN == 0:
            for i, b in enumerate(reserved):
                if b < 0 and b > -129:
                    b = b + 256
                self._ptr[0].reserved[i] = b
        else:
            for i, b in enumerate(reserved):
                if b > 127 and b < 256:
                    b = b - 256
                self._ptr[0].reserved[i] = b

cdef class CUipcMemHandle_st:
    """
    CUDA IPC mem handle

    Attributes
    ----------
    reserved : bytes


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUipcMemHandle_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(self._ptr[0].reserved, 64)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 64:
            raise ValueError("reserved length must be 64, is " + str(len(reserved)))
        if CHAR_MIN == 0:
            for i, b in enumerate(reserved):
                if b < 0 and b > -129:
                    b = b + 256
                self._ptr[0].reserved[i] = b
        else:
            for i, b in enumerate(reserved):
                if b > 127 and b < 256:
                    b = b - 256
                self._ptr[0].reserved[i] = b

cdef class CUstreamMemOpWaitValueParams_st:
    """

    Attributes
    ----------
    operation : CUstreamBatchMemOpType

    address : CUdeviceptr

    flags : unsigned int

    value64 : cuuint64_t

    alias : CUdeviceptr
        For driver internal use. Initial value is unimportant.

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUstreamMemOpWaitValueParams_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._address = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].address)
        self._value64 = cuuint64_t(_ptr=<void_ptr>&self._ptr[0].value64)
        self._alias = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].alias)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['operation : ' + str(self.operation)]
            str_list += ['address : ' + str(self.address)]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['value64 : ' + str(self.value64)]
            str_list += ['alias : ' + str(self.alias)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def operation(self):
        return CUstreamBatchMemOpType(self._ptr[0].operation)
    @operation.setter
    def operation(self, operation not None : CUstreamBatchMemOpType):
        pass
        self._ptr[0].operation = operation.value
    @property
    def address(self):
        return self._address
    @address.setter
    def address(self, address):
        cdef ccuda.CUdeviceptr caddress
        if address is None:
            caddress = <ccuda.CUdeviceptr><void_ptr>0
        elif isinstance(address, (CUdeviceptr)):
            paddress = int(address)
            caddress = <ccuda.CUdeviceptr><void_ptr>paddress
        else:
            paddress = int(CUdeviceptr(address))
            caddress = <ccuda.CUdeviceptr><void_ptr>paddress
        self._address._ptr[0] = caddress
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def value64(self):
        return self._value64
    @value64.setter
    def value64(self, value64):
        cdef ccuda.cuuint64_t cvalue64
        if value64 is None:
            cvalue64 = <ccuda.cuuint64_t><void_ptr>0
        elif isinstance(value64, (cuuint64_t)):
            pvalue64 = int(value64)
            cvalue64 = <ccuda.cuuint64_t><void_ptr>pvalue64
        else:
            pvalue64 = int(cuuint64_t(value64))
            cvalue64 = <ccuda.cuuint64_t><void_ptr>pvalue64
        self._value64._ptr[0] = cvalue64
    @property
    def alias(self):
        return self._alias
    @alias.setter
    def alias(self, alias):
        cdef ccuda.CUdeviceptr calias
        if alias is None:
            calias = <ccuda.CUdeviceptr><void_ptr>0
        elif isinstance(alias, (CUdeviceptr)):
            palias = int(alias)
            calias = <ccuda.CUdeviceptr><void_ptr>palias
        else:
            palias = int(CUdeviceptr(alias))
            calias = <ccuda.CUdeviceptr><void_ptr>palias
        self._alias._ptr[0] = calias

cdef class CUstreamMemOpWriteValueParams_st:
    """

    Attributes
    ----------
    operation : CUstreamBatchMemOpType

    address : CUdeviceptr

    flags : unsigned int

    value64 : cuuint64_t

    alias : CUdeviceptr
        For driver internal use. Initial value is unimportant.

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUstreamMemOpWriteValueParams_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._address = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].address)
        self._value64 = cuuint64_t(_ptr=<void_ptr>&self._ptr[0].value64)
        self._alias = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].alias)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['operation : ' + str(self.operation)]
            str_list += ['address : ' + str(self.address)]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['value64 : ' + str(self.value64)]
            str_list += ['alias : ' + str(self.alias)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def operation(self):
        return CUstreamBatchMemOpType(self._ptr[0].operation)
    @operation.setter
    def operation(self, operation not None : CUstreamBatchMemOpType):
        pass
        self._ptr[0].operation = operation.value
    @property
    def address(self):
        return self._address
    @address.setter
    def address(self, address):
        cdef ccuda.CUdeviceptr caddress
        if address is None:
            caddress = <ccuda.CUdeviceptr><void_ptr>0
        elif isinstance(address, (CUdeviceptr)):
            paddress = int(address)
            caddress = <ccuda.CUdeviceptr><void_ptr>paddress
        else:
            paddress = int(CUdeviceptr(address))
            caddress = <ccuda.CUdeviceptr><void_ptr>paddress
        self._address._ptr[0] = caddress
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def value64(self):
        return self._value64
    @value64.setter
    def value64(self, value64):
        cdef ccuda.cuuint64_t cvalue64
        if value64 is None:
            cvalue64 = <ccuda.cuuint64_t><void_ptr>0
        elif isinstance(value64, (cuuint64_t)):
            pvalue64 = int(value64)
            cvalue64 = <ccuda.cuuint64_t><void_ptr>pvalue64
        else:
            pvalue64 = int(cuuint64_t(value64))
            cvalue64 = <ccuda.cuuint64_t><void_ptr>pvalue64
        self._value64._ptr[0] = cvalue64
    @property
    def alias(self):
        return self._alias
    @alias.setter
    def alias(self, alias):
        cdef ccuda.CUdeviceptr calias
        if alias is None:
            calias = <ccuda.CUdeviceptr><void_ptr>0
        elif isinstance(alias, (CUdeviceptr)):
            palias = int(alias)
            calias = <ccuda.CUdeviceptr><void_ptr>palias
        else:
            palias = int(CUdeviceptr(alias))
            calias = <ccuda.CUdeviceptr><void_ptr>palias
        self._alias._ptr[0] = calias

cdef class CUstreamMemOpFlushRemoteWritesParams_st:
    """

    Attributes
    ----------
    operation : CUstreamBatchMemOpType

    flags : unsigned int


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUstreamMemOpFlushRemoteWritesParams_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['operation : ' + str(self.operation)]
            str_list += ['flags : ' + str(self.flags)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def operation(self):
        return CUstreamBatchMemOpType(self._ptr[0].operation)
    @operation.setter
    def operation(self, operation not None : CUstreamBatchMemOpType):
        pass
        self._ptr[0].operation = operation.value
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags

cdef class CUstreamMemOpMemoryBarrierParams_st:
    """

    Attributes
    ----------
    operation : CUstreamBatchMemOpType
        < Only supported in the _v2 API
    flags : unsigned int


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUstreamMemOpMemoryBarrierParams_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['operation : ' + str(self.operation)]
            str_list += ['flags : ' + str(self.flags)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def operation(self):
        return CUstreamBatchMemOpType(self._ptr[0].operation)
    @operation.setter
    def operation(self, operation not None : CUstreamBatchMemOpType):
        pass
        self._ptr[0].operation = operation.value
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags

cdef class CUstreamBatchMemOpParams_union:
    """
    Per-operation parameters for cuStreamBatchMemOp

    Attributes
    ----------
    operation : CUstreamBatchMemOpType

    waitValue : CUstreamMemOpWaitValueParams_st

    writeValue : CUstreamMemOpWriteValueParams_st

    flushRemoteWrites : CUstreamMemOpFlushRemoteWritesParams_st

    memoryBarrier : CUstreamMemOpMemoryBarrierParams_st

    pad : List[cuuint64_t]


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUstreamBatchMemOpParams_union *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._waitValue = CUstreamMemOpWaitValueParams_st(_ptr=<void_ptr>&self._ptr[0].waitValue)
        self._writeValue = CUstreamMemOpWriteValueParams_st(_ptr=<void_ptr>&self._ptr[0].writeValue)
        self._flushRemoteWrites = CUstreamMemOpFlushRemoteWritesParams_st(_ptr=<void_ptr>&self._ptr[0].flushRemoteWrites)
        self._memoryBarrier = CUstreamMemOpMemoryBarrierParams_st(_ptr=<void_ptr>&self._ptr[0].memoryBarrier)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['operation : ' + str(self.operation)]
            str_list += ['waitValue :\n' + '\n'.join(['    ' + line for line in str(self.waitValue).splitlines()])]
            str_list += ['writeValue :\n' + '\n'.join(['    ' + line for line in str(self.writeValue).splitlines()])]
            str_list += ['flushRemoteWrites :\n' + '\n'.join(['    ' + line for line in str(self.flushRemoteWrites).splitlines()])]
            str_list += ['memoryBarrier :\n' + '\n'.join(['    ' + line for line in str(self.memoryBarrier).splitlines()])]
            str_list += ['pad : ' + str(self.pad)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def operation(self):
        return CUstreamBatchMemOpType(self._ptr[0].operation)
    @operation.setter
    def operation(self, operation not None : CUstreamBatchMemOpType):
        pass
        self._ptr[0].operation = operation.value
    @property
    def waitValue(self):
        return self._waitValue
    @waitValue.setter
    def waitValue(self, waitValue not None : CUstreamMemOpWaitValueParams_st):
        pass
        for _attr in dir(waitValue):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._waitValue, _attr, getattr(waitValue, _attr))
    @property
    def writeValue(self):
        return self._writeValue
    @writeValue.setter
    def writeValue(self, writeValue not None : CUstreamMemOpWriteValueParams_st):
        pass
        for _attr in dir(writeValue):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._writeValue, _attr, getattr(writeValue, _attr))
    @property
    def flushRemoteWrites(self):
        return self._flushRemoteWrites
    @flushRemoteWrites.setter
    def flushRemoteWrites(self, flushRemoteWrites not None : CUstreamMemOpFlushRemoteWritesParams_st):
        pass
        for _attr in dir(flushRemoteWrites):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._flushRemoteWrites, _attr, getattr(flushRemoteWrites, _attr))
    @property
    def memoryBarrier(self):
        return self._memoryBarrier
    @memoryBarrier.setter
    def memoryBarrier(self, memoryBarrier not None : CUstreamMemOpMemoryBarrierParams_st):
        pass
        for _attr in dir(memoryBarrier):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._memoryBarrier, _attr, getattr(memoryBarrier, _attr))
    @property
    def pad(self):
        return [cuuint64_t(init_value=_pad) for _pad in self._ptr[0].pad]
    @pad.setter
    def pad(self, pad):
        pass
        self._ptr[0].pad = pad

cdef class CUDA_BATCH_MEM_OP_NODE_PARAMS_st:
    """

    Attributes
    ----------
    ctx : CUcontext

    count : unsigned int

    paramArray : CUstreamBatchMemOpParams

    flags : unsigned int


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_BATCH_MEM_OP_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._ctx = CUcontext(_ptr=<void_ptr>&self._ptr[0].ctx)
    def __dealloc__(self):
        if self._paramArray is not NULL:
            free(self._paramArray)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['ctx : ' + str(self.ctx)]
            str_list += ['count : ' + str(self.count)]
            str_list += ['paramArray : ' + str(self.paramArray)]
            str_list += ['flags : ' + str(self.flags)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def ctx(self):
        return self._ctx
    @ctx.setter
    def ctx(self, ctx):
        cdef ccuda.CUcontext cctx
        if ctx is None:
            cctx = <ccuda.CUcontext><void_ptr>0
        elif isinstance(ctx, (CUcontext)):
            pctx = int(ctx)
            cctx = <ccuda.CUcontext><void_ptr>pctx
        else:
            pctx = int(CUcontext(ctx))
            cctx = <ccuda.CUcontext><void_ptr>pctx
        self._ctx._ptr[0] = cctx
    @property
    def count(self):
        return self._ptr[0].count
    @count.setter
    def count(self, unsigned int count):
        pass
        self._ptr[0].count = count
    @property
    def paramArray(self):
        arrs = [<void_ptr>self._ptr[0].paramArray + x*sizeof(ccuda.CUstreamBatchMemOpParams) for x in range(self._paramArray_length)]
        return [CUstreamBatchMemOpParams(_ptr=arr) for arr in arrs]
    @paramArray.setter
    def paramArray(self, val):
        if len(val) == 0:
            free(self._paramArray)
            self._paramArray_length = 0
            self._ptr[0].paramArray = NULL
        else:
            if self._paramArray_length != <size_t>len(val):
                free(self._paramArray)
                self._paramArray = <ccuda.CUstreamBatchMemOpParams*> calloc(len(val), sizeof(ccuda.CUstreamBatchMemOpParams))
                if self._paramArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(ccuda.CUstreamBatchMemOpParams)))
                self._paramArray_length = <size_t>len(val)
                self._ptr[0].paramArray = self._paramArray
            for idx in range(len(val)):
                memcpy(&self._paramArray[idx], (<CUstreamBatchMemOpParams>val[idx])._ptr, sizeof(ccuda.CUstreamBatchMemOpParams))
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags

cdef class CUdevprop_st:
    """
    Legacy device properties

    Attributes
    ----------
    maxThreadsPerBlock : int
        Maximum number of threads per block
    maxThreadsDim : List[int]
        Maximum size of each dimension of a block
    maxGridSize : List[int]
        Maximum size of each dimension of a grid
    sharedMemPerBlock : int
        Shared memory available per block in bytes
    totalConstantMemory : int
        Constant memory available on device in bytes
    SIMDWidth : int
        Warp size in threads
    memPitch : int
        Maximum pitch in bytes allowed by memory copies
    regsPerBlock : int
        32-bit registers available per block
    clockRate : int
        Clock frequency in kilohertz
    textureAlign : int
        Alignment requirement for textures

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUdevprop_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['maxThreadsPerBlock : ' + str(self.maxThreadsPerBlock)]
            str_list += ['maxThreadsDim : ' + str(self.maxThreadsDim)]
            str_list += ['maxGridSize : ' + str(self.maxGridSize)]
            str_list += ['sharedMemPerBlock : ' + str(self.sharedMemPerBlock)]
            str_list += ['totalConstantMemory : ' + str(self.totalConstantMemory)]
            str_list += ['SIMDWidth : ' + str(self.SIMDWidth)]
            str_list += ['memPitch : ' + str(self.memPitch)]
            str_list += ['regsPerBlock : ' + str(self.regsPerBlock)]
            str_list += ['clockRate : ' + str(self.clockRate)]
            str_list += ['textureAlign : ' + str(self.textureAlign)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def maxThreadsPerBlock(self):
        return self._ptr[0].maxThreadsPerBlock
    @maxThreadsPerBlock.setter
    def maxThreadsPerBlock(self, int maxThreadsPerBlock):
        pass
        self._ptr[0].maxThreadsPerBlock = maxThreadsPerBlock
    @property
    def maxThreadsDim(self):
        return self._ptr[0].maxThreadsDim
    @maxThreadsDim.setter
    def maxThreadsDim(self, maxThreadsDim):
        pass
        self._ptr[0].maxThreadsDim = maxThreadsDim
    @property
    def maxGridSize(self):
        return self._ptr[0].maxGridSize
    @maxGridSize.setter
    def maxGridSize(self, maxGridSize):
        pass
        self._ptr[0].maxGridSize = maxGridSize
    @property
    def sharedMemPerBlock(self):
        return self._ptr[0].sharedMemPerBlock
    @sharedMemPerBlock.setter
    def sharedMemPerBlock(self, int sharedMemPerBlock):
        pass
        self._ptr[0].sharedMemPerBlock = sharedMemPerBlock
    @property
    def totalConstantMemory(self):
        return self._ptr[0].totalConstantMemory
    @totalConstantMemory.setter
    def totalConstantMemory(self, int totalConstantMemory):
        pass
        self._ptr[0].totalConstantMemory = totalConstantMemory
    @property
    def SIMDWidth(self):
        return self._ptr[0].SIMDWidth
    @SIMDWidth.setter
    def SIMDWidth(self, int SIMDWidth):
        pass
        self._ptr[0].SIMDWidth = SIMDWidth
    @property
    def memPitch(self):
        return self._ptr[0].memPitch
    @memPitch.setter
    def memPitch(self, int memPitch):
        pass
        self._ptr[0].memPitch = memPitch
    @property
    def regsPerBlock(self):
        return self._ptr[0].regsPerBlock
    @regsPerBlock.setter
    def regsPerBlock(self, int regsPerBlock):
        pass
        self._ptr[0].regsPerBlock = regsPerBlock
    @property
    def clockRate(self):
        return self._ptr[0].clockRate
    @clockRate.setter
    def clockRate(self, int clockRate):
        pass
        self._ptr[0].clockRate = clockRate
    @property
    def textureAlign(self):
        return self._ptr[0].textureAlign
    @textureAlign.setter
    def textureAlign(self, int textureAlign):
        pass
        self._ptr[0].textureAlign = textureAlign

cdef class CUaccessPolicyWindow_st:
    """
    Specifies an access policy for a window, a contiguous extent of
    memory beginning at base_ptr and ending at base_ptr + num_bytes.
    num_bytes is limited by
    CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE. Partition into
    many segments and assign segments such that: sum of "hit segments"
    / window == approx. ratio. sum of "miss segments" / window ==
    approx 1-ratio. Segments and ratio specifications are fitted to the
    capabilities of the architecture. Accesses in a hit segment apply
    the hitProp access policy. Accesses in a miss segment apply the
    missProp access policy.

    Attributes
    ----------
    base_ptr : Any
        Starting address of the access policy window. CUDA driver may align
        it.
    num_bytes : size_t
        Size in bytes of the window policy. CUDA driver may restrict the
        maximum size and alignment.
    hitRatio : float
        hitRatio specifies percentage of lines assigned hitProp, rest are
        assigned missProp.
    hitProp : CUaccessProperty
        CUaccessProperty set for hit.
    missProp : CUaccessProperty
        CUaccessProperty set for miss. Must be either NORMAL or STREAMING

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUaccessPolicyWindow_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['base_ptr : ' + hex(self.base_ptr)]
            str_list += ['num_bytes : ' + str(self.num_bytes)]
            str_list += ['hitRatio : ' + str(self.hitRatio)]
            str_list += ['hitProp : ' + str(self.hitProp)]
            str_list += ['missProp : ' + str(self.missProp)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def base_ptr(self):
        return <void_ptr>self._ptr[0].base_ptr
    @base_ptr.setter
    def base_ptr(self, base_ptr):
        _cbase_ptr = utils.HelperInputVoidPtr(base_ptr)
        self._ptr[0].base_ptr = <void*><void_ptr>_cbase_ptr.cptr
    @property
    def num_bytes(self):
        return self._ptr[0].num_bytes
    @num_bytes.setter
    def num_bytes(self, size_t num_bytes):
        pass
        self._ptr[0].num_bytes = num_bytes
    @property
    def hitRatio(self):
        return self._ptr[0].hitRatio
    @hitRatio.setter
    def hitRatio(self, float hitRatio):
        pass
        self._ptr[0].hitRatio = hitRatio
    @property
    def hitProp(self):
        return CUaccessProperty(self._ptr[0].hitProp)
    @hitProp.setter
    def hitProp(self, hitProp not None : CUaccessProperty):
        pass
        self._ptr[0].hitProp = hitProp.value
    @property
    def missProp(self):
        return CUaccessProperty(self._ptr[0].missProp)
    @missProp.setter
    def missProp(self, missProp not None : CUaccessProperty):
        pass
        self._ptr[0].missProp = missProp.value

cdef class CUDA_KERNEL_NODE_PARAMS_st:
    """
    GPU kernel node parameters

    Attributes
    ----------
    func : CUfunction
        Kernel to launch
    gridDimX : unsigned int
        Width of grid in blocks
    gridDimY : unsigned int
        Height of grid in blocks
    gridDimZ : unsigned int
        Depth of grid in blocks
    blockDimX : unsigned int
        X dimension of each thread block
    blockDimY : unsigned int
        Y dimension of each thread block
    blockDimZ : unsigned int
        Z dimension of each thread block
    sharedMemBytes : unsigned int
        Dynamic shared-memory size per thread block in bytes
    kernelParams : Any
        Array of pointers to kernel parameters
    extra : Any
        Extra options

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_KERNEL_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._func = CUfunction(_ptr=<void_ptr>&self._ptr[0].func)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['func : ' + str(self.func)]
            str_list += ['gridDimX : ' + str(self.gridDimX)]
            str_list += ['gridDimY : ' + str(self.gridDimY)]
            str_list += ['gridDimZ : ' + str(self.gridDimZ)]
            str_list += ['blockDimX : ' + str(self.blockDimX)]
            str_list += ['blockDimY : ' + str(self.blockDimY)]
            str_list += ['blockDimZ : ' + str(self.blockDimZ)]
            str_list += ['sharedMemBytes : ' + str(self.sharedMemBytes)]
            str_list += ['kernelParams : ' + str(self.kernelParams)]
            str_list += ['extra : ' + str(self.extra)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def func(self):
        return self._func
    @func.setter
    def func(self, func):
        cdef ccuda.CUfunction cfunc
        if func is None:
            cfunc = <ccuda.CUfunction><void_ptr>0
        elif isinstance(func, (CUfunction)):
            pfunc = int(func)
            cfunc = <ccuda.CUfunction><void_ptr>pfunc
        else:
            pfunc = int(CUfunction(func))
            cfunc = <ccuda.CUfunction><void_ptr>pfunc
        self._func._ptr[0] = cfunc
    @property
    def gridDimX(self):
        return self._ptr[0].gridDimX
    @gridDimX.setter
    def gridDimX(self, unsigned int gridDimX):
        pass
        self._ptr[0].gridDimX = gridDimX
    @property
    def gridDimY(self):
        return self._ptr[0].gridDimY
    @gridDimY.setter
    def gridDimY(self, unsigned int gridDimY):
        pass
        self._ptr[0].gridDimY = gridDimY
    @property
    def gridDimZ(self):
        return self._ptr[0].gridDimZ
    @gridDimZ.setter
    def gridDimZ(self, unsigned int gridDimZ):
        pass
        self._ptr[0].gridDimZ = gridDimZ
    @property
    def blockDimX(self):
        return self._ptr[0].blockDimX
    @blockDimX.setter
    def blockDimX(self, unsigned int blockDimX):
        pass
        self._ptr[0].blockDimX = blockDimX
    @property
    def blockDimY(self):
        return self._ptr[0].blockDimY
    @blockDimY.setter
    def blockDimY(self, unsigned int blockDimY):
        pass
        self._ptr[0].blockDimY = blockDimY
    @property
    def blockDimZ(self):
        return self._ptr[0].blockDimZ
    @blockDimZ.setter
    def blockDimZ(self, unsigned int blockDimZ):
        pass
        self._ptr[0].blockDimZ = blockDimZ
    @property
    def sharedMemBytes(self):
        return self._ptr[0].sharedMemBytes
    @sharedMemBytes.setter
    def sharedMemBytes(self, unsigned int sharedMemBytes):
        pass
        self._ptr[0].sharedMemBytes = sharedMemBytes
    @property
    def kernelParams(self):
        return <void_ptr>self._ptr[0].kernelParams
    @kernelParams.setter
    def kernelParams(self, kernelParams):
        self._ckernelParams = utils.HelperKernelParams(kernelParams)
        self._ptr[0].kernelParams = <void**><void_ptr>self._ckernelParams.ckernelParams
    @property
    def extra(self):
        return <void_ptr>self._ptr[0].extra
    @extra.setter
    def extra(self, void_ptr extra):
        self._ptr[0].extra = <void**>extra

cdef class CUDA_MEMSET_NODE_PARAMS_st:
    """
    Memset node parameters

    Attributes
    ----------
    dst : CUdeviceptr
        Destination device pointer
    pitch : size_t
        Pitch of destination device pointer. Unused if height is 1
    value : unsigned int
        Value to be set
    elementSize : unsigned int
        Size of each element in bytes. Must be 1, 2, or 4.
    width : size_t
        Width of the row in elements
    height : size_t
        Number of rows

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_MEMSET_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._dst = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].dst)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['dst : ' + str(self.dst)]
            str_list += ['pitch : ' + str(self.pitch)]
            str_list += ['value : ' + str(self.value)]
            str_list += ['elementSize : ' + str(self.elementSize)]
            str_list += ['width : ' + str(self.width)]
            str_list += ['height : ' + str(self.height)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def dst(self):
        return self._dst
    @dst.setter
    def dst(self, dst):
        cdef ccuda.CUdeviceptr cdst
        if dst is None:
            cdst = <ccuda.CUdeviceptr><void_ptr>0
        elif isinstance(dst, (CUdeviceptr)):
            pdst = int(dst)
            cdst = <ccuda.CUdeviceptr><void_ptr>pdst
        else:
            pdst = int(CUdeviceptr(dst))
            cdst = <ccuda.CUdeviceptr><void_ptr>pdst
        self._dst._ptr[0] = cdst
    @property
    def pitch(self):
        return self._ptr[0].pitch
    @pitch.setter
    def pitch(self, size_t pitch):
        pass
        self._ptr[0].pitch = pitch
    @property
    def value(self):
        return self._ptr[0].value
    @value.setter
    def value(self, unsigned int value):
        pass
        self._ptr[0].value = value
    @property
    def elementSize(self):
        return self._ptr[0].elementSize
    @elementSize.setter
    def elementSize(self, unsigned int elementSize):
        pass
        self._ptr[0].elementSize = elementSize
    @property
    def width(self):
        return self._ptr[0].width
    @width.setter
    def width(self, size_t width):
        pass
        self._ptr[0].width = width
    @property
    def height(self):
        return self._ptr[0].height
    @height.setter
    def height(self, size_t height):
        pass
        self._ptr[0].height = height

cdef class CUDA_HOST_NODE_PARAMS_st:
    """
    Host node parameters

    Attributes
    ----------
    fn : CUhostFn
        The function to call when the node executes
    userData : Any
        Argument to pass to the function

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_HOST_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._fn = CUhostFn(_ptr=<void_ptr>&self._ptr[0].fn)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['fn : ' + str(self.fn)]
            str_list += ['userData : ' + hex(self.userData)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def fn(self):
        return self._fn
    @fn.setter
    def fn(self, fn):
        cdef ccuda.CUhostFn cfn
        if fn is None:
            cfn = <ccuda.CUhostFn><void_ptr>0
        elif isinstance(fn, (CUhostFn)):
            pfn = int(fn)
            cfn = <ccuda.CUhostFn><void_ptr>pfn
        else:
            pfn = int(CUhostFn(fn))
            cfn = <ccuda.CUhostFn><void_ptr>pfn
        self._fn._ptr[0] = cfn
    @property
    def userData(self):
        return <void_ptr>self._ptr[0].userData
    @userData.setter
    def userData(self, userData):
        _cuserData = utils.HelperInputVoidPtr(userData)
        self._ptr[0].userData = <void*><void_ptr>_cuserData.cptr

cdef class CUkernelNodeAttrValue_union:
    """
    Graph kernel node attributes union, used with
    ::cuKernelNodeSetAttribute/::cuKernelNodeGetAttribute

    Attributes
    ----------
    accessPolicyWindow : CUaccessPolicyWindow
        Attribute ::CUaccessPolicyWindow.
    cooperative : int
        Nonzero indicates a cooperative kernel (see
        cuLaunchCooperativeKernel).
    priority : int
        Execution priority of the kernel.

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUkernelNodeAttrValue_union *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._accessPolicyWindow = CUaccessPolicyWindow(_ptr=<void_ptr>&self._ptr[0].accessPolicyWindow)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['accessPolicyWindow :\n' + '\n'.join(['    ' + line for line in str(self.accessPolicyWindow).splitlines()])]
            str_list += ['cooperative : ' + str(self.cooperative)]
            str_list += ['priority : ' + str(self.priority)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def accessPolicyWindow(self):
        return self._accessPolicyWindow
    @accessPolicyWindow.setter
    def accessPolicyWindow(self, accessPolicyWindow not None : CUaccessPolicyWindow):
        pass
        for _attr in dir(accessPolicyWindow):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._accessPolicyWindow, _attr, getattr(accessPolicyWindow, _attr))
    @property
    def cooperative(self):
        return self._ptr[0].cooperative
    @cooperative.setter
    def cooperative(self, int cooperative):
        pass
        self._ptr[0].cooperative = cooperative
    @property
    def priority(self):
        return self._ptr[0].priority
    @priority.setter
    def priority(self, int priority):
        pass
        self._ptr[0].priority = priority

cdef class CUstreamAttrValue_union:
    """
    Stream attributes union, used with
    cuStreamSetAttribute/cuStreamGetAttribute

    Attributes
    ----------
    accessPolicyWindow : CUaccessPolicyWindow
        Attribute ::CUaccessPolicyWindow.
    syncPolicy : CUsynchronizationPolicy
        Value for CU_STREAM_ATTRIBUTE_SYNCHRONIZATION_POLICY.

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUstreamAttrValue_union *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._accessPolicyWindow = CUaccessPolicyWindow(_ptr=<void_ptr>&self._ptr[0].accessPolicyWindow)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['accessPolicyWindow :\n' + '\n'.join(['    ' + line for line in str(self.accessPolicyWindow).splitlines()])]
            str_list += ['syncPolicy : ' + str(self.syncPolicy)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def accessPolicyWindow(self):
        return self._accessPolicyWindow
    @accessPolicyWindow.setter
    def accessPolicyWindow(self, accessPolicyWindow not None : CUaccessPolicyWindow):
        pass
        for _attr in dir(accessPolicyWindow):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._accessPolicyWindow, _attr, getattr(accessPolicyWindow, _attr))
    @property
    def syncPolicy(self):
        return CUsynchronizationPolicy(self._ptr[0].syncPolicy)
    @syncPolicy.setter
    def syncPolicy(self, syncPolicy not None : CUsynchronizationPolicy):
        pass
        self._ptr[0].syncPolicy = syncPolicy.value

cdef class CUexecAffinitySmCount_st:
    """
    Value for CU_EXEC_AFFINITY_TYPE_SM_COUNT

    Attributes
    ----------
    val : unsigned int
        The number of SMs the context is limited to use.

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUexecAffinitySmCount_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['val : ' + str(self.val)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def val(self):
        return self._ptr[0].val
    @val.setter
    def val(self, unsigned int val):
        pass
        self._ptr[0].val = val

cdef class _CUexecAffinityParam_v1_CUexecAffinityParam_v1_CUexecAffinityParam_st_param_u:
    """

    Attributes
    ----------
    smCount : CUexecAffinitySmCount


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUexecAffinityParam_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._smCount = CUexecAffinitySmCount(_ptr=<void_ptr>&self._ptr[0].param.smCount)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['smCount :\n' + '\n'.join(['    ' + line for line in str(self.smCount).splitlines()])]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def smCount(self):
        return self._smCount
    @smCount.setter
    def smCount(self, smCount not None : CUexecAffinitySmCount):
        pass
        for _attr in dir(smCount):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._smCount, _attr, getattr(smCount, _attr))

cdef class CUexecAffinityParam_st:
    """
    Execution Affinity Parameters

    Attributes
    ----------
    type : CUexecAffinityType

    param : _CUexecAffinityParam_v1_CUexecAffinityParam_v1_CUexecAffinityParam_st_param_u


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUexecAffinityParam_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._param = _CUexecAffinityParam_v1_CUexecAffinityParam_v1_CUexecAffinityParam_st_param_u(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['type : ' + str(self.type)]
            str_list += ['param :\n' + '\n'.join(['    ' + line for line in str(self.param).splitlines()])]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def type(self):
        return CUexecAffinityType(self._ptr[0].type)
    @type.setter
    def type(self, type not None : CUexecAffinityType):
        pass
        self._ptr[0].type = type.value
    @property
    def param(self):
        return self._param
    @param.setter
    def param(self, param not None : _CUexecAffinityParam_v1_CUexecAffinityParam_v1_CUexecAffinityParam_st_param_u):
        pass
        for _attr in dir(param):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._param, _attr, getattr(param, _attr))

cdef class CUDA_MEMCPY2D_st:
    """
    2D memory copy parameters

    Attributes
    ----------
    srcXInBytes : size_t
        Source X in bytes
    srcY : size_t
        Source Y
    srcMemoryType : CUmemorytype
        Source memory type (host, device, array)
    srcHost : Any
        Source host pointer
    srcDevice : CUdeviceptr
        Source device pointer
    srcArray : CUarray
        Source array reference
    srcPitch : size_t
        Source pitch (ignored when src is array)
    dstXInBytes : size_t
        Destination X in bytes
    dstY : size_t
        Destination Y
    dstMemoryType : CUmemorytype
        Destination memory type (host, device, array)
    dstHost : Any
        Destination host pointer
    dstDevice : CUdeviceptr
        Destination device pointer
    dstArray : CUarray
        Destination array reference
    dstPitch : size_t
        Destination pitch (ignored when dst is array)
    WidthInBytes : size_t
        Width of 2D memory copy in bytes
    Height : size_t
        Height of 2D memory copy

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_MEMCPY2D_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._srcDevice = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].srcDevice)
        self._srcArray = CUarray(_ptr=<void_ptr>&self._ptr[0].srcArray)
        self._dstDevice = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].dstDevice)
        self._dstArray = CUarray(_ptr=<void_ptr>&self._ptr[0].dstArray)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['srcXInBytes : ' + str(self.srcXInBytes)]
            str_list += ['srcY : ' + str(self.srcY)]
            str_list += ['srcMemoryType : ' + str(self.srcMemoryType)]
            str_list += ['srcHost : ' + hex(self.srcHost)]
            str_list += ['srcDevice : ' + str(self.srcDevice)]
            str_list += ['srcArray : ' + str(self.srcArray)]
            str_list += ['srcPitch : ' + str(self.srcPitch)]
            str_list += ['dstXInBytes : ' + str(self.dstXInBytes)]
            str_list += ['dstY : ' + str(self.dstY)]
            str_list += ['dstMemoryType : ' + str(self.dstMemoryType)]
            str_list += ['dstHost : ' + hex(self.dstHost)]
            str_list += ['dstDevice : ' + str(self.dstDevice)]
            str_list += ['dstArray : ' + str(self.dstArray)]
            str_list += ['dstPitch : ' + str(self.dstPitch)]
            str_list += ['WidthInBytes : ' + str(self.WidthInBytes)]
            str_list += ['Height : ' + str(self.Height)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def srcXInBytes(self):
        return self._ptr[0].srcXInBytes
    @srcXInBytes.setter
    def srcXInBytes(self, size_t srcXInBytes):
        pass
        self._ptr[0].srcXInBytes = srcXInBytes
    @property
    def srcY(self):
        return self._ptr[0].srcY
    @srcY.setter
    def srcY(self, size_t srcY):
        pass
        self._ptr[0].srcY = srcY
    @property
    def srcMemoryType(self):
        return CUmemorytype(self._ptr[0].srcMemoryType)
    @srcMemoryType.setter
    def srcMemoryType(self, srcMemoryType not None : CUmemorytype):
        pass
        self._ptr[0].srcMemoryType = srcMemoryType.value
    @property
    def srcHost(self):
        return <void_ptr>self._ptr[0].srcHost
    @srcHost.setter
    def srcHost(self, srcHost):
        _csrcHost = utils.HelperInputVoidPtr(srcHost)
        self._ptr[0].srcHost = <void*><void_ptr>_csrcHost.cptr
    @property
    def srcDevice(self):
        return self._srcDevice
    @srcDevice.setter
    def srcDevice(self, srcDevice):
        cdef ccuda.CUdeviceptr csrcDevice
        if srcDevice is None:
            csrcDevice = <ccuda.CUdeviceptr><void_ptr>0
        elif isinstance(srcDevice, (CUdeviceptr)):
            psrcDevice = int(srcDevice)
            csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice
        else:
            psrcDevice = int(CUdeviceptr(srcDevice))
            csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice
        self._srcDevice._ptr[0] = csrcDevice
    @property
    def srcArray(self):
        return self._srcArray
    @srcArray.setter
    def srcArray(self, srcArray):
        cdef ccuda.CUarray csrcArray
        if srcArray is None:
            csrcArray = <ccuda.CUarray><void_ptr>0
        elif isinstance(srcArray, (CUarray)):
            psrcArray = int(srcArray)
            csrcArray = <ccuda.CUarray><void_ptr>psrcArray
        else:
            psrcArray = int(CUarray(srcArray))
            csrcArray = <ccuda.CUarray><void_ptr>psrcArray
        self._srcArray._ptr[0] = csrcArray
    @property
    def srcPitch(self):
        return self._ptr[0].srcPitch
    @srcPitch.setter
    def srcPitch(self, size_t srcPitch):
        pass
        self._ptr[0].srcPitch = srcPitch
    @property
    def dstXInBytes(self):
        return self._ptr[0].dstXInBytes
    @dstXInBytes.setter
    def dstXInBytes(self, size_t dstXInBytes):
        pass
        self._ptr[0].dstXInBytes = dstXInBytes
    @property
    def dstY(self):
        return self._ptr[0].dstY
    @dstY.setter
    def dstY(self, size_t dstY):
        pass
        self._ptr[0].dstY = dstY
    @property
    def dstMemoryType(self):
        return CUmemorytype(self._ptr[0].dstMemoryType)
    @dstMemoryType.setter
    def dstMemoryType(self, dstMemoryType not None : CUmemorytype):
        pass
        self._ptr[0].dstMemoryType = dstMemoryType.value
    @property
    def dstHost(self):
        return <void_ptr>self._ptr[0].dstHost
    @dstHost.setter
    def dstHost(self, dstHost):
        _cdstHost = utils.HelperInputVoidPtr(dstHost)
        self._ptr[0].dstHost = <void*><void_ptr>_cdstHost.cptr
    @property
    def dstDevice(self):
        return self._dstDevice
    @dstDevice.setter
    def dstDevice(self, dstDevice):
        cdef ccuda.CUdeviceptr cdstDevice
        if dstDevice is None:
            cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
        elif isinstance(dstDevice, (CUdeviceptr)):
            pdstDevice = int(dstDevice)
            cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
        else:
            pdstDevice = int(CUdeviceptr(dstDevice))
            cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
        self._dstDevice._ptr[0] = cdstDevice
    @property
    def dstArray(self):
        return self._dstArray
    @dstArray.setter
    def dstArray(self, dstArray):
        cdef ccuda.CUarray cdstArray
        if dstArray is None:
            cdstArray = <ccuda.CUarray><void_ptr>0
        elif isinstance(dstArray, (CUarray)):
            pdstArray = int(dstArray)
            cdstArray = <ccuda.CUarray><void_ptr>pdstArray
        else:
            pdstArray = int(CUarray(dstArray))
            cdstArray = <ccuda.CUarray><void_ptr>pdstArray
        self._dstArray._ptr[0] = cdstArray
    @property
    def dstPitch(self):
        return self._ptr[0].dstPitch
    @dstPitch.setter
    def dstPitch(self, size_t dstPitch):
        pass
        self._ptr[0].dstPitch = dstPitch
    @property
    def WidthInBytes(self):
        return self._ptr[0].WidthInBytes
    @WidthInBytes.setter
    def WidthInBytes(self, size_t WidthInBytes):
        pass
        self._ptr[0].WidthInBytes = WidthInBytes
    @property
    def Height(self):
        return self._ptr[0].Height
    @Height.setter
    def Height(self, size_t Height):
        pass
        self._ptr[0].Height = Height

cdef class CUDA_MEMCPY3D_st:
    """
    3D memory copy parameters

    Attributes
    ----------
    srcXInBytes : size_t
        Source X in bytes
    srcY : size_t
        Source Y
    srcZ : size_t
        Source Z
    srcLOD : size_t
        Source LOD
    srcMemoryType : CUmemorytype
        Source memory type (host, device, array)
    srcHost : Any
        Source host pointer
    srcDevice : CUdeviceptr
        Source device pointer
    srcArray : CUarray
        Source array reference
    reserved0 : Any
        Must be NULL
    srcPitch : size_t
        Source pitch (ignored when src is array)
    srcHeight : size_t
        Source height (ignored when src is array; may be 0 if Depth==1)
    dstXInBytes : size_t
        Destination X in bytes
    dstY : size_t
        Destination Y
    dstZ : size_t
        Destination Z
    dstLOD : size_t
        Destination LOD
    dstMemoryType : CUmemorytype
        Destination memory type (host, device, array)
    dstHost : Any
        Destination host pointer
    dstDevice : CUdeviceptr
        Destination device pointer
    dstArray : CUarray
        Destination array reference
    reserved1 : Any
        Must be NULL
    dstPitch : size_t
        Destination pitch (ignored when dst is array)
    dstHeight : size_t
        Destination height (ignored when dst is array; may be 0 if
        Depth==1)
    WidthInBytes : size_t
        Width of 3D memory copy in bytes
    Height : size_t
        Height of 3D memory copy
    Depth : size_t
        Depth of 3D memory copy

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_MEMCPY3D_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._srcDevice = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].srcDevice)
        self._srcArray = CUarray(_ptr=<void_ptr>&self._ptr[0].srcArray)
        self._dstDevice = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].dstDevice)
        self._dstArray = CUarray(_ptr=<void_ptr>&self._ptr[0].dstArray)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['srcXInBytes : ' + str(self.srcXInBytes)]
            str_list += ['srcY : ' + str(self.srcY)]
            str_list += ['srcZ : ' + str(self.srcZ)]
            str_list += ['srcLOD : ' + str(self.srcLOD)]
            str_list += ['srcMemoryType : ' + str(self.srcMemoryType)]
            str_list += ['srcHost : ' + hex(self.srcHost)]
            str_list += ['srcDevice : ' + str(self.srcDevice)]
            str_list += ['srcArray : ' + str(self.srcArray)]
            str_list += ['reserved0 : ' + hex(self.reserved0)]
            str_list += ['srcPitch : ' + str(self.srcPitch)]
            str_list += ['srcHeight : ' + str(self.srcHeight)]
            str_list += ['dstXInBytes : ' + str(self.dstXInBytes)]
            str_list += ['dstY : ' + str(self.dstY)]
            str_list += ['dstZ : ' + str(self.dstZ)]
            str_list += ['dstLOD : ' + str(self.dstLOD)]
            str_list += ['dstMemoryType : ' + str(self.dstMemoryType)]
            str_list += ['dstHost : ' + hex(self.dstHost)]
            str_list += ['dstDevice : ' + str(self.dstDevice)]
            str_list += ['dstArray : ' + str(self.dstArray)]
            str_list += ['reserved1 : ' + hex(self.reserved1)]
            str_list += ['dstPitch : ' + str(self.dstPitch)]
            str_list += ['dstHeight : ' + str(self.dstHeight)]
            str_list += ['WidthInBytes : ' + str(self.WidthInBytes)]
            str_list += ['Height : ' + str(self.Height)]
            str_list += ['Depth : ' + str(self.Depth)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def srcXInBytes(self):
        return self._ptr[0].srcXInBytes
    @srcXInBytes.setter
    def srcXInBytes(self, size_t srcXInBytes):
        pass
        self._ptr[0].srcXInBytes = srcXInBytes
    @property
    def srcY(self):
        return self._ptr[0].srcY
    @srcY.setter
    def srcY(self, size_t srcY):
        pass
        self._ptr[0].srcY = srcY
    @property
    def srcZ(self):
        return self._ptr[0].srcZ
    @srcZ.setter
    def srcZ(self, size_t srcZ):
        pass
        self._ptr[0].srcZ = srcZ
    @property
    def srcLOD(self):
        return self._ptr[0].srcLOD
    @srcLOD.setter
    def srcLOD(self, size_t srcLOD):
        pass
        self._ptr[0].srcLOD = srcLOD
    @property
    def srcMemoryType(self):
        return CUmemorytype(self._ptr[0].srcMemoryType)
    @srcMemoryType.setter
    def srcMemoryType(self, srcMemoryType not None : CUmemorytype):
        pass
        self._ptr[0].srcMemoryType = srcMemoryType.value
    @property
    def srcHost(self):
        return <void_ptr>self._ptr[0].srcHost
    @srcHost.setter
    def srcHost(self, srcHost):
        _csrcHost = utils.HelperInputVoidPtr(srcHost)
        self._ptr[0].srcHost = <void*><void_ptr>_csrcHost.cptr
    @property
    def srcDevice(self):
        return self._srcDevice
    @srcDevice.setter
    def srcDevice(self, srcDevice):
        cdef ccuda.CUdeviceptr csrcDevice
        if srcDevice is None:
            csrcDevice = <ccuda.CUdeviceptr><void_ptr>0
        elif isinstance(srcDevice, (CUdeviceptr)):
            psrcDevice = int(srcDevice)
            csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice
        else:
            psrcDevice = int(CUdeviceptr(srcDevice))
            csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice
        self._srcDevice._ptr[0] = csrcDevice
    @property
    def srcArray(self):
        return self._srcArray
    @srcArray.setter
    def srcArray(self, srcArray):
        cdef ccuda.CUarray csrcArray
        if srcArray is None:
            csrcArray = <ccuda.CUarray><void_ptr>0
        elif isinstance(srcArray, (CUarray)):
            psrcArray = int(srcArray)
            csrcArray = <ccuda.CUarray><void_ptr>psrcArray
        else:
            psrcArray = int(CUarray(srcArray))
            csrcArray = <ccuda.CUarray><void_ptr>psrcArray
        self._srcArray._ptr[0] = csrcArray
    @property
    def reserved0(self):
        return <void_ptr>self._ptr[0].reserved0
    @reserved0.setter
    def reserved0(self, reserved0):
        _creserved0 = utils.HelperInputVoidPtr(reserved0)
        self._ptr[0].reserved0 = <void*><void_ptr>_creserved0.cptr
    @property
    def srcPitch(self):
        return self._ptr[0].srcPitch
    @srcPitch.setter
    def srcPitch(self, size_t srcPitch):
        pass
        self._ptr[0].srcPitch = srcPitch
    @property
    def srcHeight(self):
        return self._ptr[0].srcHeight
    @srcHeight.setter
    def srcHeight(self, size_t srcHeight):
        pass
        self._ptr[0].srcHeight = srcHeight
    @property
    def dstXInBytes(self):
        return self._ptr[0].dstXInBytes
    @dstXInBytes.setter
    def dstXInBytes(self, size_t dstXInBytes):
        pass
        self._ptr[0].dstXInBytes = dstXInBytes
    @property
    def dstY(self):
        return self._ptr[0].dstY
    @dstY.setter
    def dstY(self, size_t dstY):
        pass
        self._ptr[0].dstY = dstY
    @property
    def dstZ(self):
        return self._ptr[0].dstZ
    @dstZ.setter
    def dstZ(self, size_t dstZ):
        pass
        self._ptr[0].dstZ = dstZ
    @property
    def dstLOD(self):
        return self._ptr[0].dstLOD
    @dstLOD.setter
    def dstLOD(self, size_t dstLOD):
        pass
        self._ptr[0].dstLOD = dstLOD
    @property
    def dstMemoryType(self):
        return CUmemorytype(self._ptr[0].dstMemoryType)
    @dstMemoryType.setter
    def dstMemoryType(self, dstMemoryType not None : CUmemorytype):
        pass
        self._ptr[0].dstMemoryType = dstMemoryType.value
    @property
    def dstHost(self):
        return <void_ptr>self._ptr[0].dstHost
    @dstHost.setter
    def dstHost(self, dstHost):
        _cdstHost = utils.HelperInputVoidPtr(dstHost)
        self._ptr[0].dstHost = <void*><void_ptr>_cdstHost.cptr
    @property
    def dstDevice(self):
        return self._dstDevice
    @dstDevice.setter
    def dstDevice(self, dstDevice):
        cdef ccuda.CUdeviceptr cdstDevice
        if dstDevice is None:
            cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
        elif isinstance(dstDevice, (CUdeviceptr)):
            pdstDevice = int(dstDevice)
            cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
        else:
            pdstDevice = int(CUdeviceptr(dstDevice))
            cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
        self._dstDevice._ptr[0] = cdstDevice
    @property
    def dstArray(self):
        return self._dstArray
    @dstArray.setter
    def dstArray(self, dstArray):
        cdef ccuda.CUarray cdstArray
        if dstArray is None:
            cdstArray = <ccuda.CUarray><void_ptr>0
        elif isinstance(dstArray, (CUarray)):
            pdstArray = int(dstArray)
            cdstArray = <ccuda.CUarray><void_ptr>pdstArray
        else:
            pdstArray = int(CUarray(dstArray))
            cdstArray = <ccuda.CUarray><void_ptr>pdstArray
        self._dstArray._ptr[0] = cdstArray
    @property
    def reserved1(self):
        return <void_ptr>self._ptr[0].reserved1
    @reserved1.setter
    def reserved1(self, reserved1):
        _creserved1 = utils.HelperInputVoidPtr(reserved1)
        self._ptr[0].reserved1 = <void*><void_ptr>_creserved1.cptr
    @property
    def dstPitch(self):
        return self._ptr[0].dstPitch
    @dstPitch.setter
    def dstPitch(self, size_t dstPitch):
        pass
        self._ptr[0].dstPitch = dstPitch
    @property
    def dstHeight(self):
        return self._ptr[0].dstHeight
    @dstHeight.setter
    def dstHeight(self, size_t dstHeight):
        pass
        self._ptr[0].dstHeight = dstHeight
    @property
    def WidthInBytes(self):
        return self._ptr[0].WidthInBytes
    @WidthInBytes.setter
    def WidthInBytes(self, size_t WidthInBytes):
        pass
        self._ptr[0].WidthInBytes = WidthInBytes
    @property
    def Height(self):
        return self._ptr[0].Height
    @Height.setter
    def Height(self, size_t Height):
        pass
        self._ptr[0].Height = Height
    @property
    def Depth(self):
        return self._ptr[0].Depth
    @Depth.setter
    def Depth(self, size_t Depth):
        pass
        self._ptr[0].Depth = Depth

cdef class CUDA_MEMCPY3D_PEER_st:
    """
    3D memory cross-context copy parameters

    Attributes
    ----------
    srcXInBytes : size_t
        Source X in bytes
    srcY : size_t
        Source Y
    srcZ : size_t
        Source Z
    srcLOD : size_t
        Source LOD
    srcMemoryType : CUmemorytype
        Source memory type (host, device, array)
    srcHost : Any
        Source host pointer
    srcDevice : CUdeviceptr
        Source device pointer
    srcArray : CUarray
        Source array reference
    srcContext : CUcontext
        Source context (ignored with srcMemoryType is CU_MEMORYTYPE_ARRAY)
    srcPitch : size_t
        Source pitch (ignored when src is array)
    srcHeight : size_t
        Source height (ignored when src is array; may be 0 if Depth==1)
    dstXInBytes : size_t
        Destination X in bytes
    dstY : size_t
        Destination Y
    dstZ : size_t
        Destination Z
    dstLOD : size_t
        Destination LOD
    dstMemoryType : CUmemorytype
        Destination memory type (host, device, array)
    dstHost : Any
        Destination host pointer
    dstDevice : CUdeviceptr
        Destination device pointer
    dstArray : CUarray
        Destination array reference
    dstContext : CUcontext
        Destination context (ignored with dstMemoryType is
        CU_MEMORYTYPE_ARRAY)
    dstPitch : size_t
        Destination pitch (ignored when dst is array)
    dstHeight : size_t
        Destination height (ignored when dst is array; may be 0 if
        Depth==1)
    WidthInBytes : size_t
        Width of 3D memory copy in bytes
    Height : size_t
        Height of 3D memory copy
    Depth : size_t
        Depth of 3D memory copy

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_MEMCPY3D_PEER_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._srcDevice = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].srcDevice)
        self._srcArray = CUarray(_ptr=<void_ptr>&self._ptr[0].srcArray)
        self._srcContext = CUcontext(_ptr=<void_ptr>&self._ptr[0].srcContext)
        self._dstDevice = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].dstDevice)
        self._dstArray = CUarray(_ptr=<void_ptr>&self._ptr[0].dstArray)
        self._dstContext = CUcontext(_ptr=<void_ptr>&self._ptr[0].dstContext)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['srcXInBytes : ' + str(self.srcXInBytes)]
            str_list += ['srcY : ' + str(self.srcY)]
            str_list += ['srcZ : ' + str(self.srcZ)]
            str_list += ['srcLOD : ' + str(self.srcLOD)]
            str_list += ['srcMemoryType : ' + str(self.srcMemoryType)]
            str_list += ['srcHost : ' + hex(self.srcHost)]
            str_list += ['srcDevice : ' + str(self.srcDevice)]
            str_list += ['srcArray : ' + str(self.srcArray)]
            str_list += ['srcContext : ' + str(self.srcContext)]
            str_list += ['srcPitch : ' + str(self.srcPitch)]
            str_list += ['srcHeight : ' + str(self.srcHeight)]
            str_list += ['dstXInBytes : ' + str(self.dstXInBytes)]
            str_list += ['dstY : ' + str(self.dstY)]
            str_list += ['dstZ : ' + str(self.dstZ)]
            str_list += ['dstLOD : ' + str(self.dstLOD)]
            str_list += ['dstMemoryType : ' + str(self.dstMemoryType)]
            str_list += ['dstHost : ' + hex(self.dstHost)]
            str_list += ['dstDevice : ' + str(self.dstDevice)]
            str_list += ['dstArray : ' + str(self.dstArray)]
            str_list += ['dstContext : ' + str(self.dstContext)]
            str_list += ['dstPitch : ' + str(self.dstPitch)]
            str_list += ['dstHeight : ' + str(self.dstHeight)]
            str_list += ['WidthInBytes : ' + str(self.WidthInBytes)]
            str_list += ['Height : ' + str(self.Height)]
            str_list += ['Depth : ' + str(self.Depth)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def srcXInBytes(self):
        return self._ptr[0].srcXInBytes
    @srcXInBytes.setter
    def srcXInBytes(self, size_t srcXInBytes):
        pass
        self._ptr[0].srcXInBytes = srcXInBytes
    @property
    def srcY(self):
        return self._ptr[0].srcY
    @srcY.setter
    def srcY(self, size_t srcY):
        pass
        self._ptr[0].srcY = srcY
    @property
    def srcZ(self):
        return self._ptr[0].srcZ
    @srcZ.setter
    def srcZ(self, size_t srcZ):
        pass
        self._ptr[0].srcZ = srcZ
    @property
    def srcLOD(self):
        return self._ptr[0].srcLOD
    @srcLOD.setter
    def srcLOD(self, size_t srcLOD):
        pass
        self._ptr[0].srcLOD = srcLOD
    @property
    def srcMemoryType(self):
        return CUmemorytype(self._ptr[0].srcMemoryType)
    @srcMemoryType.setter
    def srcMemoryType(self, srcMemoryType not None : CUmemorytype):
        pass
        self._ptr[0].srcMemoryType = srcMemoryType.value
    @property
    def srcHost(self):
        return <void_ptr>self._ptr[0].srcHost
    @srcHost.setter
    def srcHost(self, srcHost):
        _csrcHost = utils.HelperInputVoidPtr(srcHost)
        self._ptr[0].srcHost = <void*><void_ptr>_csrcHost.cptr
    @property
    def srcDevice(self):
        return self._srcDevice
    @srcDevice.setter
    def srcDevice(self, srcDevice):
        cdef ccuda.CUdeviceptr csrcDevice
        if srcDevice is None:
            csrcDevice = <ccuda.CUdeviceptr><void_ptr>0
        elif isinstance(srcDevice, (CUdeviceptr)):
            psrcDevice = int(srcDevice)
            csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice
        else:
            psrcDevice = int(CUdeviceptr(srcDevice))
            csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice
        self._srcDevice._ptr[0] = csrcDevice
    @property
    def srcArray(self):
        return self._srcArray
    @srcArray.setter
    def srcArray(self, srcArray):
        cdef ccuda.CUarray csrcArray
        if srcArray is None:
            csrcArray = <ccuda.CUarray><void_ptr>0
        elif isinstance(srcArray, (CUarray)):
            psrcArray = int(srcArray)
            csrcArray = <ccuda.CUarray><void_ptr>psrcArray
        else:
            psrcArray = int(CUarray(srcArray))
            csrcArray = <ccuda.CUarray><void_ptr>psrcArray
        self._srcArray._ptr[0] = csrcArray
    @property
    def srcContext(self):
        return self._srcContext
    @srcContext.setter
    def srcContext(self, srcContext):
        cdef ccuda.CUcontext csrcContext
        if srcContext is None:
            csrcContext = <ccuda.CUcontext><void_ptr>0
        elif isinstance(srcContext, (CUcontext)):
            psrcContext = int(srcContext)
            csrcContext = <ccuda.CUcontext><void_ptr>psrcContext
        else:
            psrcContext = int(CUcontext(srcContext))
            csrcContext = <ccuda.CUcontext><void_ptr>psrcContext
        self._srcContext._ptr[0] = csrcContext
    @property
    def srcPitch(self):
        return self._ptr[0].srcPitch
    @srcPitch.setter
    def srcPitch(self, size_t srcPitch):
        pass
        self._ptr[0].srcPitch = srcPitch
    @property
    def srcHeight(self):
        return self._ptr[0].srcHeight
    @srcHeight.setter
    def srcHeight(self, size_t srcHeight):
        pass
        self._ptr[0].srcHeight = srcHeight
    @property
    def dstXInBytes(self):
        return self._ptr[0].dstXInBytes
    @dstXInBytes.setter
    def dstXInBytes(self, size_t dstXInBytes):
        pass
        self._ptr[0].dstXInBytes = dstXInBytes
    @property
    def dstY(self):
        return self._ptr[0].dstY
    @dstY.setter
    def dstY(self, size_t dstY):
        pass
        self._ptr[0].dstY = dstY
    @property
    def dstZ(self):
        return self._ptr[0].dstZ
    @dstZ.setter
    def dstZ(self, size_t dstZ):
        pass
        self._ptr[0].dstZ = dstZ
    @property
    def dstLOD(self):
        return self._ptr[0].dstLOD
    @dstLOD.setter
    def dstLOD(self, size_t dstLOD):
        pass
        self._ptr[0].dstLOD = dstLOD
    @property
    def dstMemoryType(self):
        return CUmemorytype(self._ptr[0].dstMemoryType)
    @dstMemoryType.setter
    def dstMemoryType(self, dstMemoryType not None : CUmemorytype):
        pass
        self._ptr[0].dstMemoryType = dstMemoryType.value
    @property
    def dstHost(self):
        return <void_ptr>self._ptr[0].dstHost
    @dstHost.setter
    def dstHost(self, dstHost):
        _cdstHost = utils.HelperInputVoidPtr(dstHost)
        self._ptr[0].dstHost = <void*><void_ptr>_cdstHost.cptr
    @property
    def dstDevice(self):
        return self._dstDevice
    @dstDevice.setter
    def dstDevice(self, dstDevice):
        cdef ccuda.CUdeviceptr cdstDevice
        if dstDevice is None:
            cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
        elif isinstance(dstDevice, (CUdeviceptr)):
            pdstDevice = int(dstDevice)
            cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
        else:
            pdstDevice = int(CUdeviceptr(dstDevice))
            cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
        self._dstDevice._ptr[0] = cdstDevice
    @property
    def dstArray(self):
        return self._dstArray
    @dstArray.setter
    def dstArray(self, dstArray):
        cdef ccuda.CUarray cdstArray
        if dstArray is None:
            cdstArray = <ccuda.CUarray><void_ptr>0
        elif isinstance(dstArray, (CUarray)):
            pdstArray = int(dstArray)
            cdstArray = <ccuda.CUarray><void_ptr>pdstArray
        else:
            pdstArray = int(CUarray(dstArray))
            cdstArray = <ccuda.CUarray><void_ptr>pdstArray
        self._dstArray._ptr[0] = cdstArray
    @property
    def dstContext(self):
        return self._dstContext
    @dstContext.setter
    def dstContext(self, dstContext):
        cdef ccuda.CUcontext cdstContext
        if dstContext is None:
            cdstContext = <ccuda.CUcontext><void_ptr>0
        elif isinstance(dstContext, (CUcontext)):
            pdstContext = int(dstContext)
            cdstContext = <ccuda.CUcontext><void_ptr>pdstContext
        else:
            pdstContext = int(CUcontext(dstContext))
            cdstContext = <ccuda.CUcontext><void_ptr>pdstContext
        self._dstContext._ptr[0] = cdstContext
    @property
    def dstPitch(self):
        return self._ptr[0].dstPitch
    @dstPitch.setter
    def dstPitch(self, size_t dstPitch):
        pass
        self._ptr[0].dstPitch = dstPitch
    @property
    def dstHeight(self):
        return self._ptr[0].dstHeight
    @dstHeight.setter
    def dstHeight(self, size_t dstHeight):
        pass
        self._ptr[0].dstHeight = dstHeight
    @property
    def WidthInBytes(self):
        return self._ptr[0].WidthInBytes
    @WidthInBytes.setter
    def WidthInBytes(self, size_t WidthInBytes):
        pass
        self._ptr[0].WidthInBytes = WidthInBytes
    @property
    def Height(self):
        return self._ptr[0].Height
    @Height.setter
    def Height(self, size_t Height):
        pass
        self._ptr[0].Height = Height
    @property
    def Depth(self):
        return self._ptr[0].Depth
    @Depth.setter
    def Depth(self, size_t Depth):
        pass
        self._ptr[0].Depth = Depth

cdef class CUDA_ARRAY_DESCRIPTOR_st:
    """
    Array descriptor

    Attributes
    ----------
    Width : size_t
        Width of array
    Height : size_t
        Height of array
    Format : CUarray_format
        Array format
    NumChannels : unsigned int
        Channels per array element

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_ARRAY_DESCRIPTOR_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['Width : ' + str(self.Width)]
            str_list += ['Height : ' + str(self.Height)]
            str_list += ['Format : ' + str(self.Format)]
            str_list += ['NumChannels : ' + str(self.NumChannels)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def Width(self):
        return self._ptr[0].Width
    @Width.setter
    def Width(self, size_t Width):
        pass
        self._ptr[0].Width = Width
    @property
    def Height(self):
        return self._ptr[0].Height
    @Height.setter
    def Height(self, size_t Height):
        pass
        self._ptr[0].Height = Height
    @property
    def Format(self):
        return CUarray_format(self._ptr[0].Format)
    @Format.setter
    def Format(self, Format not None : CUarray_format):
        pass
        self._ptr[0].Format = Format.value
    @property
    def NumChannels(self):
        return self._ptr[0].NumChannels
    @NumChannels.setter
    def NumChannels(self, unsigned int NumChannels):
        pass
        self._ptr[0].NumChannels = NumChannels

cdef class CUDA_ARRAY3D_DESCRIPTOR_st:
    """
    3D array descriptor

    Attributes
    ----------
    Width : size_t
        Width of 3D array
    Height : size_t
        Height of 3D array
    Depth : size_t
        Depth of 3D array
    Format : CUarray_format
        Array format
    NumChannels : unsigned int
        Channels per array element
    Flags : unsigned int
        Flags

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_ARRAY3D_DESCRIPTOR_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['Width : ' + str(self.Width)]
            str_list += ['Height : ' + str(self.Height)]
            str_list += ['Depth : ' + str(self.Depth)]
            str_list += ['Format : ' + str(self.Format)]
            str_list += ['NumChannels : ' + str(self.NumChannels)]
            str_list += ['Flags : ' + str(self.Flags)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def Width(self):
        return self._ptr[0].Width
    @Width.setter
    def Width(self, size_t Width):
        pass
        self._ptr[0].Width = Width
    @property
    def Height(self):
        return self._ptr[0].Height
    @Height.setter
    def Height(self, size_t Height):
        pass
        self._ptr[0].Height = Height
    @property
    def Depth(self):
        return self._ptr[0].Depth
    @Depth.setter
    def Depth(self, size_t Depth):
        pass
        self._ptr[0].Depth = Depth
    @property
    def Format(self):
        return CUarray_format(self._ptr[0].Format)
    @Format.setter
    def Format(self, Format not None : CUarray_format):
        pass
        self._ptr[0].Format = Format.value
    @property
    def NumChannels(self):
        return self._ptr[0].NumChannels
    @NumChannels.setter
    def NumChannels(self, unsigned int NumChannels):
        pass
        self._ptr[0].NumChannels = NumChannels
    @property
    def Flags(self):
        return self._ptr[0].Flags
    @Flags.setter
    def Flags(self, unsigned int Flags):
        pass
        self._ptr[0].Flags = Flags

cdef class _CUDA_ARRAY_SPARSE_PROPERTIES_v1_CUDA_ARRAY_SPARSE_PROPERTIES_v1_CUDA_ARRAY_SPARSE_PROPERTIES_st_tileExtent_s:
    """

    Attributes
    ----------
    width : unsigned int

    height : unsigned int

    depth : unsigned int


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_ARRAY_SPARSE_PROPERTIES_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['width : ' + str(self.width)]
            str_list += ['height : ' + str(self.height)]
            str_list += ['depth : ' + str(self.depth)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def width(self):
        return self._ptr[0].tileExtent.width
    @width.setter
    def width(self, unsigned int width):
        pass
        self._ptr[0].tileExtent.width = width
    @property
    def height(self):
        return self._ptr[0].tileExtent.height
    @height.setter
    def height(self, unsigned int height):
        pass
        self._ptr[0].tileExtent.height = height
    @property
    def depth(self):
        return self._ptr[0].tileExtent.depth
    @depth.setter
    def depth(self, unsigned int depth):
        pass
        self._ptr[0].tileExtent.depth = depth

cdef class CUDA_ARRAY_SPARSE_PROPERTIES_st:
    """
    CUDA array sparse properties

    Attributes
    ----------
    tileExtent : _CUDA_ARRAY_SPARSE_PROPERTIES_v1_CUDA_ARRAY_SPARSE_PROPERTIES_v1_CUDA_ARRAY_SPARSE_PROPERTIES_st_tileExtent_s

    miptailFirstLevel : unsigned int
        First mip level at which the mip tail begins.
    miptailSize : unsigned long long
        Total size of the mip tail.
    flags : unsigned int
        Flags will either be zero or
        CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL
    reserved : List[unsigned int]


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_ARRAY_SPARSE_PROPERTIES_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._tileExtent = _CUDA_ARRAY_SPARSE_PROPERTIES_v1_CUDA_ARRAY_SPARSE_PROPERTIES_v1_CUDA_ARRAY_SPARSE_PROPERTIES_st_tileExtent_s(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['tileExtent :\n' + '\n'.join(['    ' + line for line in str(self.tileExtent).splitlines()])]
            str_list += ['miptailFirstLevel : ' + str(self.miptailFirstLevel)]
            str_list += ['miptailSize : ' + str(self.miptailSize)]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def tileExtent(self):
        return self._tileExtent
    @tileExtent.setter
    def tileExtent(self, tileExtent not None : _CUDA_ARRAY_SPARSE_PROPERTIES_v1_CUDA_ARRAY_SPARSE_PROPERTIES_v1_CUDA_ARRAY_SPARSE_PROPERTIES_st_tileExtent_s):
        pass
        for _attr in dir(tileExtent):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._tileExtent, _attr, getattr(tileExtent, _attr))
    @property
    def miptailFirstLevel(self):
        return self._ptr[0].miptailFirstLevel
    @miptailFirstLevel.setter
    def miptailFirstLevel(self, unsigned int miptailFirstLevel):
        pass
        self._ptr[0].miptailFirstLevel = miptailFirstLevel
    @property
    def miptailSize(self):
        return self._ptr[0].miptailSize
    @miptailSize.setter
    def miptailSize(self, unsigned long long miptailSize):
        pass
        self._ptr[0].miptailSize = miptailSize
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class CUDA_ARRAY_MEMORY_REQUIREMENTS_st:
    """
    CUDA array memory requirements

    Attributes
    ----------
    size : size_t
        Total required memory size
    alignment : size_t
        alignment requirement
    reserved : List[unsigned int]


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_ARRAY_MEMORY_REQUIREMENTS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['size : ' + str(self.size)]
            str_list += ['alignment : ' + str(self.alignment)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def size(self):
        return self._ptr[0].size
    @size.setter
    def size(self, size_t size):
        pass
        self._ptr[0].size = size
    @property
    def alignment(self):
        return self._ptr[0].alignment
    @alignment.setter
    def alignment(self, size_t alignment):
        pass
        self._ptr[0].alignment = alignment
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_array_s:
    """

    Attributes
    ----------
    hArray : CUarray


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_RESOURCE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._hArray = CUarray(_ptr=<void_ptr>&self._ptr[0].res.array.hArray)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['hArray : ' + str(self.hArray)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def hArray(self):
        return self._hArray
    @hArray.setter
    def hArray(self, hArray):
        cdef ccuda.CUarray chArray
        if hArray is None:
            chArray = <ccuda.CUarray><void_ptr>0
        elif isinstance(hArray, (CUarray)):
            phArray = int(hArray)
            chArray = <ccuda.CUarray><void_ptr>phArray
        else:
            phArray = int(CUarray(hArray))
            chArray = <ccuda.CUarray><void_ptr>phArray
        self._hArray._ptr[0] = chArray

cdef class _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_mipmap_s:
    """

    Attributes
    ----------
    hMipmappedArray : CUmipmappedArray


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_RESOURCE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._hMipmappedArray = CUmipmappedArray(_ptr=<void_ptr>&self._ptr[0].res.mipmap.hMipmappedArray)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['hMipmappedArray : ' + str(self.hMipmappedArray)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def hMipmappedArray(self):
        return self._hMipmappedArray
    @hMipmappedArray.setter
    def hMipmappedArray(self, hMipmappedArray):
        cdef ccuda.CUmipmappedArray chMipmappedArray
        if hMipmappedArray is None:
            chMipmappedArray = <ccuda.CUmipmappedArray><void_ptr>0
        elif isinstance(hMipmappedArray, (CUmipmappedArray)):
            phMipmappedArray = int(hMipmappedArray)
            chMipmappedArray = <ccuda.CUmipmappedArray><void_ptr>phMipmappedArray
        else:
            phMipmappedArray = int(CUmipmappedArray(hMipmappedArray))
            chMipmappedArray = <ccuda.CUmipmappedArray><void_ptr>phMipmappedArray
        self._hMipmappedArray._ptr[0] = chMipmappedArray

cdef class _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_linear_s:
    """

    Attributes
    ----------
    devPtr : CUdeviceptr

    format : CUarray_format

    numChannels : unsigned int

    sizeInBytes : size_t


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_RESOURCE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._devPtr = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].res.linear.devPtr)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['devPtr : ' + str(self.devPtr)]
            str_list += ['format : ' + str(self.format)]
            str_list += ['numChannels : ' + str(self.numChannels)]
            str_list += ['sizeInBytes : ' + str(self.sizeInBytes)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def devPtr(self):
        return self._devPtr
    @devPtr.setter
    def devPtr(self, devPtr):
        cdef ccuda.CUdeviceptr cdevPtr
        if devPtr is None:
            cdevPtr = <ccuda.CUdeviceptr><void_ptr>0
        elif isinstance(devPtr, (CUdeviceptr)):
            pdevPtr = int(devPtr)
            cdevPtr = <ccuda.CUdeviceptr><void_ptr>pdevPtr
        else:
            pdevPtr = int(CUdeviceptr(devPtr))
            cdevPtr = <ccuda.CUdeviceptr><void_ptr>pdevPtr
        self._devPtr._ptr[0] = cdevPtr
    @property
    def format(self):
        return CUarray_format(self._ptr[0].res.linear.format)
    @format.setter
    def format(self, format not None : CUarray_format):
        pass
        self._ptr[0].res.linear.format = format.value
    @property
    def numChannels(self):
        return self._ptr[0].res.linear.numChannels
    @numChannels.setter
    def numChannels(self, unsigned int numChannels):
        pass
        self._ptr[0].res.linear.numChannels = numChannels
    @property
    def sizeInBytes(self):
        return self._ptr[0].res.linear.sizeInBytes
    @sizeInBytes.setter
    def sizeInBytes(self, size_t sizeInBytes):
        pass
        self._ptr[0].res.linear.sizeInBytes = sizeInBytes

cdef class _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_pitch2D_s:
    """

    Attributes
    ----------
    devPtr : CUdeviceptr

    format : CUarray_format

    numChannels : unsigned int

    width : size_t

    height : size_t

    pitchInBytes : size_t


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_RESOURCE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._devPtr = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].res.pitch2D.devPtr)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['devPtr : ' + str(self.devPtr)]
            str_list += ['format : ' + str(self.format)]
            str_list += ['numChannels : ' + str(self.numChannels)]
            str_list += ['width : ' + str(self.width)]
            str_list += ['height : ' + str(self.height)]
            str_list += ['pitchInBytes : ' + str(self.pitchInBytes)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def devPtr(self):
        return self._devPtr
    @devPtr.setter
    def devPtr(self, devPtr):
        cdef ccuda.CUdeviceptr cdevPtr
        if devPtr is None:
            cdevPtr = <ccuda.CUdeviceptr><void_ptr>0
        elif isinstance(devPtr, (CUdeviceptr)):
            pdevPtr = int(devPtr)
            cdevPtr = <ccuda.CUdeviceptr><void_ptr>pdevPtr
        else:
            pdevPtr = int(CUdeviceptr(devPtr))
            cdevPtr = <ccuda.CUdeviceptr><void_ptr>pdevPtr
        self._devPtr._ptr[0] = cdevPtr
    @property
    def format(self):
        return CUarray_format(self._ptr[0].res.pitch2D.format)
    @format.setter
    def format(self, format not None : CUarray_format):
        pass
        self._ptr[0].res.pitch2D.format = format.value
    @property
    def numChannels(self):
        return self._ptr[0].res.pitch2D.numChannels
    @numChannels.setter
    def numChannels(self, unsigned int numChannels):
        pass
        self._ptr[0].res.pitch2D.numChannels = numChannels
    @property
    def width(self):
        return self._ptr[0].res.pitch2D.width
    @width.setter
    def width(self, size_t width):
        pass
        self._ptr[0].res.pitch2D.width = width
    @property
    def height(self):
        return self._ptr[0].res.pitch2D.height
    @height.setter
    def height(self, size_t height):
        pass
        self._ptr[0].res.pitch2D.height = height
    @property
    def pitchInBytes(self):
        return self._ptr[0].res.pitch2D.pitchInBytes
    @pitchInBytes.setter
    def pitchInBytes(self, size_t pitchInBytes):
        pass
        self._ptr[0].res.pitch2D.pitchInBytes = pitchInBytes

cdef class _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_reserved_s:
    """

    Attributes
    ----------
    reserved : List[int]


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_RESOURCE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def reserved(self):
        return self._ptr[0].res.reserved.reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].res.reserved.reserved = reserved

cdef class _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_u:
    """

    Attributes
    ----------
    array : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_array_s

    mipmap : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_mipmap_s

    linear : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_linear_s

    pitch2D : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_pitch2D_s

    reserved : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_reserved_s


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_RESOURCE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._array = _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_array_s(_ptr=<void_ptr>self._ptr)
        self._mipmap = _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_mipmap_s(_ptr=<void_ptr>self._ptr)
        self._linear = _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_linear_s(_ptr=<void_ptr>self._ptr)
        self._pitch2D = _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_pitch2D_s(_ptr=<void_ptr>self._ptr)
        self._reserved = _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_reserved_s(_ptr=<void_ptr>self._ptr)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['array :\n' + '\n'.join(['    ' + line for line in str(self.array).splitlines()])]
            str_list += ['mipmap :\n' + '\n'.join(['    ' + line for line in str(self.mipmap).splitlines()])]
            str_list += ['linear :\n' + '\n'.join(['    ' + line for line in str(self.linear).splitlines()])]
            str_list += ['pitch2D :\n' + '\n'.join(['    ' + line for line in str(self.pitch2D).splitlines()])]
            str_list += ['reserved :\n' + '\n'.join(['    ' + line for line in str(self.reserved).splitlines()])]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def array(self):
        return self._array
    @array.setter
    def array(self, array not None : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_array_s):
        pass
        for _attr in dir(array):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._array, _attr, getattr(array, _attr))
    @property
    def mipmap(self):
        return self._mipmap
    @mipmap.setter
    def mipmap(self, mipmap not None : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_mipmap_s):
        pass
        for _attr in dir(mipmap):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._mipmap, _attr, getattr(mipmap, _attr))
    @property
    def linear(self):
        return self._linear
    @linear.setter
    def linear(self, linear not None : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_linear_s):
        pass
        for _attr in dir(linear):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._linear, _attr, getattr(linear, _attr))
    @property
    def pitch2D(self):
        return self._pitch2D
    @pitch2D.setter
    def pitch2D(self, pitch2D not None : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_pitch2D_s):
        pass
        for _attr in dir(pitch2D):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._pitch2D, _attr, getattr(pitch2D, _attr))
    @property
    def reserved(self):
        return self._reserved
    @reserved.setter
    def reserved(self, reserved not None : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_res_reserved_s):
        pass
        for _attr in dir(reserved):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._reserved, _attr, getattr(reserved, _attr))

cdef class CUDA_RESOURCE_DESC_st:
    """
    CUDA Resource descriptor

    Attributes
    ----------
    resType : CUresourcetype
        Resource type
    res : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_u

    flags : unsigned int
        Flags (must be zero)

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_RESOURCE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._res = _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_u(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['resType : ' + str(self.resType)]
            str_list += ['res :\n' + '\n'.join(['    ' + line for line in str(self.res).splitlines()])]
            str_list += ['flags : ' + str(self.flags)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def resType(self):
        return CUresourcetype(self._ptr[0].resType)
    @resType.setter
    def resType(self, resType not None : CUresourcetype):
        pass
        self._ptr[0].resType = resType.value
    @property
    def res(self):
        return self._res
    @res.setter
    def res(self, res not None : _CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_v1_CUDA_RESOURCE_DESC_st_res_u):
        pass
        for _attr in dir(res):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._res, _attr, getattr(res, _attr))
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags

cdef class CUDA_TEXTURE_DESC_st:
    """
    Texture descriptor

    Attributes
    ----------
    addressMode : List[CUaddress_mode]
        Address modes
    filterMode : CUfilter_mode
        Filter mode
    flags : unsigned int
        Flags
    maxAnisotropy : unsigned int
        Maximum anisotropy ratio
    mipmapFilterMode : CUfilter_mode
        Mipmap filter mode
    mipmapLevelBias : float
        Mipmap level bias
    minMipmapLevelClamp : float
        Mipmap minimum level clamp
    maxMipmapLevelClamp : float
        Mipmap maximum level clamp
    borderColor : List[float]
        Border Color
    reserved : List[int]


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_TEXTURE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['addressMode : ' + str(self.addressMode)]
            str_list += ['filterMode : ' + str(self.filterMode)]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['maxAnisotropy : ' + str(self.maxAnisotropy)]
            str_list += ['mipmapFilterMode : ' + str(self.mipmapFilterMode)]
            str_list += ['mipmapLevelBias : ' + str(self.mipmapLevelBias)]
            str_list += ['minMipmapLevelClamp : ' + str(self.minMipmapLevelClamp)]
            str_list += ['maxMipmapLevelClamp : ' + str(self.maxMipmapLevelClamp)]
            str_list += ['borderColor : ' + str(self.borderColor)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def addressMode(self):
        return [CUaddress_mode(_x) for _x in list(self._ptr[0].addressMode)]
    @addressMode.setter
    def addressMode(self, addressMode):
        self._ptr[0].addressMode = [_x.value for _x in addressMode]
    @property
    def filterMode(self):
        return CUfilter_mode(self._ptr[0].filterMode)
    @filterMode.setter
    def filterMode(self, filterMode not None : CUfilter_mode):
        pass
        self._ptr[0].filterMode = filterMode.value
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def maxAnisotropy(self):
        return self._ptr[0].maxAnisotropy
    @maxAnisotropy.setter
    def maxAnisotropy(self, unsigned int maxAnisotropy):
        pass
        self._ptr[0].maxAnisotropy = maxAnisotropy
    @property
    def mipmapFilterMode(self):
        return CUfilter_mode(self._ptr[0].mipmapFilterMode)
    @mipmapFilterMode.setter
    def mipmapFilterMode(self, mipmapFilterMode not None : CUfilter_mode):
        pass
        self._ptr[0].mipmapFilterMode = mipmapFilterMode.value
    @property
    def mipmapLevelBias(self):
        return self._ptr[0].mipmapLevelBias
    @mipmapLevelBias.setter
    def mipmapLevelBias(self, float mipmapLevelBias):
        pass
        self._ptr[0].mipmapLevelBias = mipmapLevelBias
    @property
    def minMipmapLevelClamp(self):
        return self._ptr[0].minMipmapLevelClamp
    @minMipmapLevelClamp.setter
    def minMipmapLevelClamp(self, float minMipmapLevelClamp):
        pass
        self._ptr[0].minMipmapLevelClamp = minMipmapLevelClamp
    @property
    def maxMipmapLevelClamp(self):
        return self._ptr[0].maxMipmapLevelClamp
    @maxMipmapLevelClamp.setter
    def maxMipmapLevelClamp(self, float maxMipmapLevelClamp):
        pass
        self._ptr[0].maxMipmapLevelClamp = maxMipmapLevelClamp
    @property
    def borderColor(self):
        return self._ptr[0].borderColor
    @borderColor.setter
    def borderColor(self, borderColor):
        pass
        self._ptr[0].borderColor = borderColor
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class CUDA_RESOURCE_VIEW_DESC_st:
    """
    Resource view descriptor

    Attributes
    ----------
    format : CUresourceViewFormat
        Resource view format
    width : size_t
        Width of the resource view
    height : size_t
        Height of the resource view
    depth : size_t
        Depth of the resource view
    firstMipmapLevel : unsigned int
        First defined mipmap level
    lastMipmapLevel : unsigned int
        Last defined mipmap level
    firstLayer : unsigned int
        First layer index
    lastLayer : unsigned int
        Last layer index
    reserved : List[unsigned int]


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_RESOURCE_VIEW_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['format : ' + str(self.format)]
            str_list += ['width : ' + str(self.width)]
            str_list += ['height : ' + str(self.height)]
            str_list += ['depth : ' + str(self.depth)]
            str_list += ['firstMipmapLevel : ' + str(self.firstMipmapLevel)]
            str_list += ['lastMipmapLevel : ' + str(self.lastMipmapLevel)]
            str_list += ['firstLayer : ' + str(self.firstLayer)]
            str_list += ['lastLayer : ' + str(self.lastLayer)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def format(self):
        return CUresourceViewFormat(self._ptr[0].format)
    @format.setter
    def format(self, format not None : CUresourceViewFormat):
        pass
        self._ptr[0].format = format.value
    @property
    def width(self):
        return self._ptr[0].width
    @width.setter
    def width(self, size_t width):
        pass
        self._ptr[0].width = width
    @property
    def height(self):
        return self._ptr[0].height
    @height.setter
    def height(self, size_t height):
        pass
        self._ptr[0].height = height
    @property
    def depth(self):
        return self._ptr[0].depth
    @depth.setter
    def depth(self, size_t depth):
        pass
        self._ptr[0].depth = depth
    @property
    def firstMipmapLevel(self):
        return self._ptr[0].firstMipmapLevel
    @firstMipmapLevel.setter
    def firstMipmapLevel(self, unsigned int firstMipmapLevel):
        pass
        self._ptr[0].firstMipmapLevel = firstMipmapLevel
    @property
    def lastMipmapLevel(self):
        return self._ptr[0].lastMipmapLevel
    @lastMipmapLevel.setter
    def lastMipmapLevel(self, unsigned int lastMipmapLevel):
        pass
        self._ptr[0].lastMipmapLevel = lastMipmapLevel
    @property
    def firstLayer(self):
        return self._ptr[0].firstLayer
    @firstLayer.setter
    def firstLayer(self, unsigned int firstLayer):
        pass
        self._ptr[0].firstLayer = firstLayer
    @property
    def lastLayer(self):
        return self._ptr[0].lastLayer
    @lastLayer.setter
    def lastLayer(self, unsigned int lastLayer):
        pass
        self._ptr[0].lastLayer = lastLayer
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st:
    """
    GPU Direct v3 tokens

    Attributes
    ----------
    p2pToken : unsigned long long

    vaSpaceToken : unsigned int


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['p2pToken : ' + str(self.p2pToken)]
            str_list += ['vaSpaceToken : ' + str(self.vaSpaceToken)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def p2pToken(self):
        return self._ptr[0].p2pToken
    @p2pToken.setter
    def p2pToken(self, unsigned long long p2pToken):
        pass
        self._ptr[0].p2pToken = p2pToken
    @property
    def vaSpaceToken(self):
        return self._ptr[0].vaSpaceToken
    @vaSpaceToken.setter
    def vaSpaceToken(self, unsigned int vaSpaceToken):
        pass
        self._ptr[0].vaSpaceToken = vaSpaceToken

cdef class CUDA_LAUNCH_PARAMS_st:
    """
    Kernel launch parameters

    Attributes
    ----------
    function : CUfunction
        Kernel to launch
    gridDimX : unsigned int
        Width of grid in blocks
    gridDimY : unsigned int
        Height of grid in blocks
    gridDimZ : unsigned int
        Depth of grid in blocks
    blockDimX : unsigned int
        X dimension of each thread block
    blockDimY : unsigned int
        Y dimension of each thread block
    blockDimZ : unsigned int
        Z dimension of each thread block
    sharedMemBytes : unsigned int
        Dynamic shared-memory size per thread block in bytes
    hStream : CUstream
        Stream identifier
    kernelParams : Any
        Array of pointers to kernel parameters

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_LAUNCH_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._function = CUfunction(_ptr=<void_ptr>&self._ptr[0].function)
        self._hStream = CUstream(_ptr=<void_ptr>&self._ptr[0].hStream)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['function : ' + str(self.function)]
            str_list += ['gridDimX : ' + str(self.gridDimX)]
            str_list += ['gridDimY : ' + str(self.gridDimY)]
            str_list += ['gridDimZ : ' + str(self.gridDimZ)]
            str_list += ['blockDimX : ' + str(self.blockDimX)]
            str_list += ['blockDimY : ' + str(self.blockDimY)]
            str_list += ['blockDimZ : ' + str(self.blockDimZ)]
            str_list += ['sharedMemBytes : ' + str(self.sharedMemBytes)]
            str_list += ['hStream : ' + str(self.hStream)]
            str_list += ['kernelParams : ' + str(self.kernelParams)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def function(self):
        return self._function
    @function.setter
    def function(self, function):
        cdef ccuda.CUfunction cfunction
        if function is None:
            cfunction = <ccuda.CUfunction><void_ptr>0
        elif isinstance(function, (CUfunction)):
            pfunction = int(function)
            cfunction = <ccuda.CUfunction><void_ptr>pfunction
        else:
            pfunction = int(CUfunction(function))
            cfunction = <ccuda.CUfunction><void_ptr>pfunction
        self._function._ptr[0] = cfunction
    @property
    def gridDimX(self):
        return self._ptr[0].gridDimX
    @gridDimX.setter
    def gridDimX(self, unsigned int gridDimX):
        pass
        self._ptr[0].gridDimX = gridDimX
    @property
    def gridDimY(self):
        return self._ptr[0].gridDimY
    @gridDimY.setter
    def gridDimY(self, unsigned int gridDimY):
        pass
        self._ptr[0].gridDimY = gridDimY
    @property
    def gridDimZ(self):
        return self._ptr[0].gridDimZ
    @gridDimZ.setter
    def gridDimZ(self, unsigned int gridDimZ):
        pass
        self._ptr[0].gridDimZ = gridDimZ
    @property
    def blockDimX(self):
        return self._ptr[0].blockDimX
    @blockDimX.setter
    def blockDimX(self, unsigned int blockDimX):
        pass
        self._ptr[0].blockDimX = blockDimX
    @property
    def blockDimY(self):
        return self._ptr[0].blockDimY
    @blockDimY.setter
    def blockDimY(self, unsigned int blockDimY):
        pass
        self._ptr[0].blockDimY = blockDimY
    @property
    def blockDimZ(self):
        return self._ptr[0].blockDimZ
    @blockDimZ.setter
    def blockDimZ(self, unsigned int blockDimZ):
        pass
        self._ptr[0].blockDimZ = blockDimZ
    @property
    def sharedMemBytes(self):
        return self._ptr[0].sharedMemBytes
    @sharedMemBytes.setter
    def sharedMemBytes(self, unsigned int sharedMemBytes):
        pass
        self._ptr[0].sharedMemBytes = sharedMemBytes
    @property
    def hStream(self):
        return self._hStream
    @hStream.setter
    def hStream(self, hStream):
        cdef ccuda.CUstream chStream
        if hStream is None:
            chStream = <ccuda.CUstream><void_ptr>0
        elif isinstance(hStream, (CUstream)):
            phStream = int(hStream)
            chStream = <ccuda.CUstream><void_ptr>phStream
        else:
            phStream = int(CUstream(hStream))
            chStream = <ccuda.CUstream><void_ptr>phStream
        self._hStream._ptr[0] = chStream
    @property
    def kernelParams(self):
        return <void_ptr>self._ptr[0].kernelParams
    @kernelParams.setter
    def kernelParams(self, kernelParams):
        self._ckernelParams = utils.HelperKernelParams(kernelParams)
        self._ptr[0].kernelParams = <void**><void_ptr>self._ckernelParams.ckernelParams

cdef class _CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st_handle_handle_win32_s:
    """

    Attributes
    ----------
    handle : void

    name : void


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['handle : ' + hex(self.handle)]
            str_list += ['name : ' + hex(self.name)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def handle(self):
        return <void_ptr>self._ptr[0].handle.win32.handle
    @handle.setter
    def handle(self, handle):
        _chandle = utils.HelperInputVoidPtr(handle)
        self._ptr[0].handle.win32.handle = <void*><void_ptr>_chandle.cptr
    @property
    def name(self):
        return <void_ptr>self._ptr[0].handle.win32.name
    @name.setter
    def name(self, name):
        _cname = utils.HelperInputVoidPtr(name)
        self._ptr[0].handle.win32.name = <void*><void_ptr>_cname.cptr

cdef class _CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st_handle_u:
    """

    Attributes
    ----------
    fd : int

    win32 : _CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st_handle_handle_win32_s

    nvSciBufObject : void


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._win32 = _CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st_handle_handle_win32_s(_ptr=<void_ptr>self._ptr)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['fd : ' + str(self.fd)]
            str_list += ['win32 :\n' + '\n'.join(['    ' + line for line in str(self.win32).splitlines()])]
            str_list += ['nvSciBufObject : ' + hex(self.nvSciBufObject)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def fd(self):
        return self._ptr[0].handle.fd
    @fd.setter
    def fd(self, int fd):
        pass
        self._ptr[0].handle.fd = fd
    @property
    def win32(self):
        return self._win32
    @win32.setter
    def win32(self, win32 not None : _CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st_handle_handle_win32_s):
        pass
        for _attr in dir(win32):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._win32, _attr, getattr(win32, _attr))
    @property
    def nvSciBufObject(self):
        return <void_ptr>self._ptr[0].handle.nvSciBufObject
    @nvSciBufObject.setter
    def nvSciBufObject(self, nvSciBufObject):
        _cnvSciBufObject = utils.HelperInputVoidPtr(nvSciBufObject)
        self._ptr[0].handle.nvSciBufObject = <void*><void_ptr>_cnvSciBufObject.cptr

cdef class CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st:
    """
    External memory handle descriptor

    Attributes
    ----------
    type : CUexternalMemoryHandleType
        Type of the handle
    handle : _CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st_handle_u

    size : unsigned long long
        Size of the memory allocation
    flags : unsigned int
        Flags must either be zero or CUDA_EXTERNAL_MEMORY_DEDICATED
    reserved : List[unsigned int]


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._handle = _CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st_handle_u(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['type : ' + str(self.type)]
            str_list += ['handle :\n' + '\n'.join(['    ' + line for line in str(self.handle).splitlines()])]
            str_list += ['size : ' + str(self.size)]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def type(self):
        return CUexternalMemoryHandleType(self._ptr[0].type)
    @type.setter
    def type(self, type not None : CUexternalMemoryHandleType):
        pass
        self._ptr[0].type = type.value
    @property
    def handle(self):
        return self._handle
    @handle.setter
    def handle(self, handle not None : _CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1_CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st_handle_u):
        pass
        for _attr in dir(handle):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._handle, _attr, getattr(handle, _attr))
    @property
    def size(self):
        return self._ptr[0].size
    @size.setter
    def size(self, unsigned long long size):
        pass
        self._ptr[0].size = size
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st:
    """
    External memory buffer descriptor

    Attributes
    ----------
    offset : unsigned long long
        Offset into the memory object where the buffer's base is
    size : unsigned long long
        Size of the buffer
    flags : unsigned int
        Flags reserved for future use. Must be zero.
    reserved : List[unsigned int]


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['offset : ' + str(self.offset)]
            str_list += ['size : ' + str(self.size)]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def offset(self):
        return self._ptr[0].offset
    @offset.setter
    def offset(self, unsigned long long offset):
        pass
        self._ptr[0].offset = offset
    @property
    def size(self):
        return self._ptr[0].size
    @size.setter
    def size(self, unsigned long long size):
        pass
        self._ptr[0].size = size
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st:
    """
    External memory mipmap descriptor

    Attributes
    ----------
    offset : unsigned long long
        Offset into the memory object where the base level of the mipmap
        chain is.
    arrayDesc : CUDA_ARRAY3D_DESCRIPTOR
        Format, dimension and type of base level of the mipmap chain
    numLevels : unsigned int
        Total number of levels in the mipmap chain
    reserved : List[unsigned int]


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._arrayDesc = CUDA_ARRAY3D_DESCRIPTOR(_ptr=<void_ptr>&self._ptr[0].arrayDesc)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['offset : ' + str(self.offset)]
            str_list += ['arrayDesc :\n' + '\n'.join(['    ' + line for line in str(self.arrayDesc).splitlines()])]
            str_list += ['numLevels : ' + str(self.numLevels)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def offset(self):
        return self._ptr[0].offset
    @offset.setter
    def offset(self, unsigned long long offset):
        pass
        self._ptr[0].offset = offset
    @property
    def arrayDesc(self):
        return self._arrayDesc
    @arrayDesc.setter
    def arrayDesc(self, arrayDesc not None : CUDA_ARRAY3D_DESCRIPTOR):
        pass
        for _attr in dir(arrayDesc):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._arrayDesc, _attr, getattr(arrayDesc, _attr))
    @property
    def numLevels(self):
        return self._ptr[0].numLevels
    @numLevels.setter
    def numLevels(self, unsigned int numLevels):
        pass
        self._ptr[0].numLevels = numLevels
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class _CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st_handle_handle_win32_s:
    """

    Attributes
    ----------
    handle : void

    name : void


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['handle : ' + hex(self.handle)]
            str_list += ['name : ' + hex(self.name)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def handle(self):
        return <void_ptr>self._ptr[0].handle.win32.handle
    @handle.setter
    def handle(self, handle):
        _chandle = utils.HelperInputVoidPtr(handle)
        self._ptr[0].handle.win32.handle = <void*><void_ptr>_chandle.cptr
    @property
    def name(self):
        return <void_ptr>self._ptr[0].handle.win32.name
    @name.setter
    def name(self, name):
        _cname = utils.HelperInputVoidPtr(name)
        self._ptr[0].handle.win32.name = <void*><void_ptr>_cname.cptr

cdef class _CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st_handle_u:
    """

    Attributes
    ----------
    fd : int

    win32 : _CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st_handle_handle_win32_s

    nvSciSyncObj : void


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._win32 = _CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st_handle_handle_win32_s(_ptr=<void_ptr>self._ptr)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['fd : ' + str(self.fd)]
            str_list += ['win32 :\n' + '\n'.join(['    ' + line for line in str(self.win32).splitlines()])]
            str_list += ['nvSciSyncObj : ' + hex(self.nvSciSyncObj)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def fd(self):
        return self._ptr[0].handle.fd
    @fd.setter
    def fd(self, int fd):
        pass
        self._ptr[0].handle.fd = fd
    @property
    def win32(self):
        return self._win32
    @win32.setter
    def win32(self, win32 not None : _CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st_handle_handle_win32_s):
        pass
        for _attr in dir(win32):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._win32, _attr, getattr(win32, _attr))
    @property
    def nvSciSyncObj(self):
        return <void_ptr>self._ptr[0].handle.nvSciSyncObj
    @nvSciSyncObj.setter
    def nvSciSyncObj(self, nvSciSyncObj):
        _cnvSciSyncObj = utils.HelperInputVoidPtr(nvSciSyncObj)
        self._ptr[0].handle.nvSciSyncObj = <void*><void_ptr>_cnvSciSyncObj.cptr

cdef class CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st:
    """
    External semaphore handle descriptor

    Attributes
    ----------
    type : CUexternalSemaphoreHandleType
        Type of the handle
    handle : _CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st_handle_u

    flags : unsigned int
        Flags reserved for the future. Must be zero.
    reserved : List[unsigned int]


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._handle = _CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st_handle_u(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['type : ' + str(self.type)]
            str_list += ['handle :\n' + '\n'.join(['    ' + line for line in str(self.handle).splitlines()])]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def type(self):
        return CUexternalSemaphoreHandleType(self._ptr[0].type)
    @type.setter
    def type(self, type not None : CUexternalSemaphoreHandleType):
        pass
        self._ptr[0].type = type.value
    @property
    def handle(self):
        return self._handle
    @handle.setter
    def handle(self, handle not None : _CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1_CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st_handle_u):
        pass
        for _attr in dir(handle):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._handle, _attr, getattr(handle, _attr))
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_fence_s:
    """

    Attributes
    ----------
    value : unsigned long long


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['value : ' + str(self.value)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def value(self):
        return self._ptr[0].params.fence.value
    @value.setter
    def value(self, unsigned long long value):
        pass
        self._ptr[0].params.fence.value = value

cdef class _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_nvSciSync_u:
    """

    Attributes
    ----------
    fence : void

    reserved : unsigned long long


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['fence : ' + hex(self.fence)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def fence(self):
        return <void_ptr>self._ptr[0].params.nvSciSync.fence
    @fence.setter
    def fence(self, fence):
        _cfence = utils.HelperInputVoidPtr(fence)
        self._ptr[0].params.nvSciSync.fence = <void*><void_ptr>_cfence.cptr
    @property
    def reserved(self):
        return self._ptr[0].params.nvSciSync.reserved
    @reserved.setter
    def reserved(self, unsigned long long reserved):
        pass
        self._ptr[0].params.nvSciSync.reserved = reserved

cdef class _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_keyedMutex_s:
    """

    Attributes
    ----------
    key : unsigned long long


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['key : ' + str(self.key)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def key(self):
        return self._ptr[0].params.keyedMutex.key
    @key.setter
    def key(self, unsigned long long key):
        pass
        self._ptr[0].params.keyedMutex.key = key

cdef class _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_s:
    """

    Attributes
    ----------
    fence : _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_fence_s

    nvSciSync : _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_nvSciSync_u

    keyedMutex : _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_keyedMutex_s

    reserved : List[unsigned int]


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._fence = _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_fence_s(_ptr=<void_ptr>self._ptr)
        self._nvSciSync = _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_nvSciSync_u(_ptr=<void_ptr>self._ptr)
        self._keyedMutex = _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_keyedMutex_s(_ptr=<void_ptr>self._ptr)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['fence :\n' + '\n'.join(['    ' + line for line in str(self.fence).splitlines()])]
            str_list += ['nvSciSync :\n' + '\n'.join(['    ' + line for line in str(self.nvSciSync).splitlines()])]
            str_list += ['keyedMutex :\n' + '\n'.join(['    ' + line for line in str(self.keyedMutex).splitlines()])]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def fence(self):
        return self._fence
    @fence.setter
    def fence(self, fence not None : _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_fence_s):
        pass
        for _attr in dir(fence):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._fence, _attr, getattr(fence, _attr))
    @property
    def nvSciSync(self):
        return self._nvSciSync
    @nvSciSync.setter
    def nvSciSync(self, nvSciSync not None : _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_nvSciSync_u):
        pass
        for _attr in dir(nvSciSync):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._nvSciSync, _attr, getattr(nvSciSync, _attr))
    @property
    def keyedMutex(self):
        return self._keyedMutex
    @keyedMutex.setter
    def keyedMutex(self, keyedMutex not None : _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_params_keyedMutex_s):
        pass
        for _attr in dir(keyedMutex):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._keyedMutex, _attr, getattr(keyedMutex, _attr))
    @property
    def reserved(self):
        return self._ptr[0].params.reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].params.reserved = reserved

cdef class CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st:
    """
    External semaphore signal parameters

    Attributes
    ----------
    params : _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_s

    flags : unsigned int
        Only when ::CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS is used to signal
        a CUexternalSemaphore of type
        CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC, the valid flag is
        CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC which
        indicates that while signaling the CUexternalSemaphore, no memory
        synchronization operations should be performed for any external
        memory object imported as CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF.
        For all other types of CUexternalSemaphore, flags must be zero.
    reserved : List[unsigned int]


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._params = _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_s(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['params :\n' + '\n'.join(['    ' + line for line in str(self.params).splitlines()])]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def params(self):
        return self._params
    @params.setter
    def params(self, params not None : _CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st_params_s):
        pass
        for _attr in dir(params):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._params, _attr, getattr(params, _attr))
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_fence_s:
    """

    Attributes
    ----------
    value : unsigned long long


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['value : ' + str(self.value)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def value(self):
        return self._ptr[0].params.fence.value
    @value.setter
    def value(self, unsigned long long value):
        pass
        self._ptr[0].params.fence.value = value

cdef class _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_nvSciSync_u:
    """

    Attributes
    ----------
    fence : void

    reserved : unsigned long long


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['fence : ' + hex(self.fence)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def fence(self):
        return <void_ptr>self._ptr[0].params.nvSciSync.fence
    @fence.setter
    def fence(self, fence):
        _cfence = utils.HelperInputVoidPtr(fence)
        self._ptr[0].params.nvSciSync.fence = <void*><void_ptr>_cfence.cptr
    @property
    def reserved(self):
        return self._ptr[0].params.nvSciSync.reserved
    @reserved.setter
    def reserved(self, unsigned long long reserved):
        pass
        self._ptr[0].params.nvSciSync.reserved = reserved

cdef class _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_keyedMutex_s:
    """

    Attributes
    ----------
    key : unsigned long long

    timeoutMs : unsigned int


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['key : ' + str(self.key)]
            str_list += ['timeoutMs : ' + str(self.timeoutMs)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def key(self):
        return self._ptr[0].params.keyedMutex.key
    @key.setter
    def key(self, unsigned long long key):
        pass
        self._ptr[0].params.keyedMutex.key = key
    @property
    def timeoutMs(self):
        return self._ptr[0].params.keyedMutex.timeoutMs
    @timeoutMs.setter
    def timeoutMs(self, unsigned int timeoutMs):
        pass
        self._ptr[0].params.keyedMutex.timeoutMs = timeoutMs

cdef class _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_s:
    """

    Attributes
    ----------
    fence : _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_fence_s

    nvSciSync : _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_nvSciSync_u

    keyedMutex : _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_keyedMutex_s

    reserved : List[unsigned int]


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._fence = _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_fence_s(_ptr=<void_ptr>self._ptr)
        self._nvSciSync = _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_nvSciSync_u(_ptr=<void_ptr>self._ptr)
        self._keyedMutex = _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_keyedMutex_s(_ptr=<void_ptr>self._ptr)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['fence :\n' + '\n'.join(['    ' + line for line in str(self.fence).splitlines()])]
            str_list += ['nvSciSync :\n' + '\n'.join(['    ' + line for line in str(self.nvSciSync).splitlines()])]
            str_list += ['keyedMutex :\n' + '\n'.join(['    ' + line for line in str(self.keyedMutex).splitlines()])]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def fence(self):
        return self._fence
    @fence.setter
    def fence(self, fence not None : _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_fence_s):
        pass
        for _attr in dir(fence):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._fence, _attr, getattr(fence, _attr))
    @property
    def nvSciSync(self):
        return self._nvSciSync
    @nvSciSync.setter
    def nvSciSync(self, nvSciSync not None : _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_nvSciSync_u):
        pass
        for _attr in dir(nvSciSync):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._nvSciSync, _attr, getattr(nvSciSync, _attr))
    @property
    def keyedMutex(self):
        return self._keyedMutex
    @keyedMutex.setter
    def keyedMutex(self, keyedMutex not None : _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_params_keyedMutex_s):
        pass
        for _attr in dir(keyedMutex):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._keyedMutex, _attr, getattr(keyedMutex, _attr))
    @property
    def reserved(self):
        return self._ptr[0].params.reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].params.reserved = reserved

cdef class CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st:
    """
    External semaphore wait parameters

    Attributes
    ----------
    params : _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_s

    flags : unsigned int
        Only when ::CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS is used to wait on
        a CUexternalSemaphore of type
        CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC, the valid flag is
        CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC which indicates
        that while waiting for the CUexternalSemaphore, no memory
        synchronization operations should be performed for any external
        memory object imported as CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF.
        For all other types of CUexternalSemaphore, flags must be zero.
    reserved : List[unsigned int]


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._params = _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_s(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['params :\n' + '\n'.join(['    ' + line for line in str(self.params).splitlines()])]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def params(self):
        return self._params
    @params.setter
    def params(self, params not None : _CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1_CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st_params_s):
        pass
        for _attr in dir(params):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._params, _attr, getattr(params, _attr))
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st:
    """
    Semaphore signal node parameters

    Attributes
    ----------
    extSemArray : CUexternalSemaphore
        Array of external semaphore handles.
    paramsArray : CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS
        Array of external semaphore signal parameters.
    numExtSems : unsigned int
        Number of handles and parameters supplied in extSemArray and
        paramsArray.

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._extSemArray is not NULL:
            free(self._extSemArray)
        if self._paramsArray is not NULL:
            free(self._paramsArray)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['extSemArray : ' + str(self.extSemArray)]
            str_list += ['paramsArray : ' + str(self.paramsArray)]
            str_list += ['numExtSems : ' + str(self.numExtSems)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def extSemArray(self):
        arrs = [<void_ptr>self._ptr[0].extSemArray + x*sizeof(ccuda.CUexternalSemaphore) for x in range(self._extSemArray_length)]
        return [CUexternalSemaphore(_ptr=arr) for arr in arrs]
    @extSemArray.setter
    def extSemArray(self, val):
        if len(val) == 0:
            free(self._extSemArray)
            self._extSemArray_length = 0
            self._ptr[0].extSemArray = NULL
        else:
            if self._extSemArray_length != <size_t>len(val):
                free(self._extSemArray)
                self._extSemArray = <ccuda.CUexternalSemaphore*> calloc(len(val), sizeof(ccuda.CUexternalSemaphore))
                if self._extSemArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(ccuda.CUexternalSemaphore)))
                self._extSemArray_length = <size_t>len(val)
                self._ptr[0].extSemArray = self._extSemArray
            for idx in range(len(val)):
                self._extSemArray[idx] = (<CUexternalSemaphore>val[idx])._ptr[0]
    @property
    def paramsArray(self):
        arrs = [<void_ptr>self._ptr[0].paramsArray + x*sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS) for x in range(self._paramsArray_length)]
        return [CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS(_ptr=arr) for arr in arrs]
    @paramsArray.setter
    def paramsArray(self, val):
        if len(val) == 0:
            free(self._paramsArray)
            self._paramsArray_length = 0
            self._ptr[0].paramsArray = NULL
        else:
            if self._paramsArray_length != <size_t>len(val):
                free(self._paramsArray)
                self._paramsArray = <ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS*> calloc(len(val), sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS))
                if self._paramsArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS)))
                self._paramsArray_length = <size_t>len(val)
                self._ptr[0].paramsArray = self._paramsArray
            for idx in range(len(val)):
                memcpy(&self._paramsArray[idx], (<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS>val[idx])._ptr, sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS))
    @property
    def numExtSems(self):
        return self._ptr[0].numExtSems
    @numExtSems.setter
    def numExtSems(self, unsigned int numExtSems):
        pass
        self._ptr[0].numExtSems = numExtSems

cdef class CUDA_EXT_SEM_WAIT_NODE_PARAMS_st:
    """
    Semaphore wait node parameters

    Attributes
    ----------
    extSemArray : CUexternalSemaphore
        Array of external semaphore handles.
    paramsArray : CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS
        Array of external semaphore wait parameters.
    numExtSems : unsigned int
        Number of handles and parameters supplied in extSemArray and
        paramsArray.

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_EXT_SEM_WAIT_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        if self._extSemArray is not NULL:
            free(self._extSemArray)
        if self._paramsArray is not NULL:
            free(self._paramsArray)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['extSemArray : ' + str(self.extSemArray)]
            str_list += ['paramsArray : ' + str(self.paramsArray)]
            str_list += ['numExtSems : ' + str(self.numExtSems)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def extSemArray(self):
        arrs = [<void_ptr>self._ptr[0].extSemArray + x*sizeof(ccuda.CUexternalSemaphore) for x in range(self._extSemArray_length)]
        return [CUexternalSemaphore(_ptr=arr) for arr in arrs]
    @extSemArray.setter
    def extSemArray(self, val):
        if len(val) == 0:
            free(self._extSemArray)
            self._extSemArray_length = 0
            self._ptr[0].extSemArray = NULL
        else:
            if self._extSemArray_length != <size_t>len(val):
                free(self._extSemArray)
                self._extSemArray = <ccuda.CUexternalSemaphore*> calloc(len(val), sizeof(ccuda.CUexternalSemaphore))
                if self._extSemArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(ccuda.CUexternalSemaphore)))
                self._extSemArray_length = <size_t>len(val)
                self._ptr[0].extSemArray = self._extSemArray
            for idx in range(len(val)):
                self._extSemArray[idx] = (<CUexternalSemaphore>val[idx])._ptr[0]
    @property
    def paramsArray(self):
        arrs = [<void_ptr>self._ptr[0].paramsArray + x*sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS) for x in range(self._paramsArray_length)]
        return [CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS(_ptr=arr) for arr in arrs]
    @paramsArray.setter
    def paramsArray(self, val):
        if len(val) == 0:
            free(self._paramsArray)
            self._paramsArray_length = 0
            self._ptr[0].paramsArray = NULL
        else:
            if self._paramsArray_length != <size_t>len(val):
                free(self._paramsArray)
                self._paramsArray = <ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS*> calloc(len(val), sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS))
                if self._paramsArray is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS)))
                self._paramsArray_length = <size_t>len(val)
                self._ptr[0].paramsArray = self._paramsArray
            for idx in range(len(val)):
                memcpy(&self._paramsArray[idx], (<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS>val[idx])._ptr, sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS))
    @property
    def numExtSems(self):
        return self._ptr[0].numExtSems
    @numExtSems.setter
    def numExtSems(self, unsigned int numExtSems):
        pass
        self._ptr[0].numExtSems = numExtSems

cdef class _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_resource_u:
    """

    Attributes
    ----------
    mipmap : CUmipmappedArray

    array : CUarray


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUarrayMapInfo_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._mipmap = CUmipmappedArray(_ptr=<void_ptr>&self._ptr[0].resource.mipmap)
        self._array = CUarray(_ptr=<void_ptr>&self._ptr[0].resource.array)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['mipmap : ' + str(self.mipmap)]
            str_list += ['array : ' + str(self.array)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def mipmap(self):
        return self._mipmap
    @mipmap.setter
    def mipmap(self, mipmap):
        cdef ccuda.CUmipmappedArray cmipmap
        if mipmap is None:
            cmipmap = <ccuda.CUmipmappedArray><void_ptr>0
        elif isinstance(mipmap, (CUmipmappedArray)):
            pmipmap = int(mipmap)
            cmipmap = <ccuda.CUmipmappedArray><void_ptr>pmipmap
        else:
            pmipmap = int(CUmipmappedArray(mipmap))
            cmipmap = <ccuda.CUmipmappedArray><void_ptr>pmipmap
        self._mipmap._ptr[0] = cmipmap
    @property
    def array(self):
        return self._array
    @array.setter
    def array(self, array):
        cdef ccuda.CUarray carray
        if array is None:
            carray = <ccuda.CUarray><void_ptr>0
        elif isinstance(array, (CUarray)):
            parray = int(array)
            carray = <ccuda.CUarray><void_ptr>parray
        else:
            parray = int(CUarray(array))
            carray = <ccuda.CUarray><void_ptr>parray
        self._array._ptr[0] = carray

cdef class _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_subresource_sparseLevel_s:
    """

    Attributes
    ----------
    level : unsigned int

    layer : unsigned int

    offsetX : unsigned int

    offsetY : unsigned int

    offsetZ : unsigned int

    extentWidth : unsigned int

    extentHeight : unsigned int

    extentDepth : unsigned int


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUarrayMapInfo_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['level : ' + str(self.level)]
            str_list += ['layer : ' + str(self.layer)]
            str_list += ['offsetX : ' + str(self.offsetX)]
            str_list += ['offsetY : ' + str(self.offsetY)]
            str_list += ['offsetZ : ' + str(self.offsetZ)]
            str_list += ['extentWidth : ' + str(self.extentWidth)]
            str_list += ['extentHeight : ' + str(self.extentHeight)]
            str_list += ['extentDepth : ' + str(self.extentDepth)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def level(self):
        return self._ptr[0].subresource.sparseLevel.level
    @level.setter
    def level(self, unsigned int level):
        pass
        self._ptr[0].subresource.sparseLevel.level = level
    @property
    def layer(self):
        return self._ptr[0].subresource.sparseLevel.layer
    @layer.setter
    def layer(self, unsigned int layer):
        pass
        self._ptr[0].subresource.sparseLevel.layer = layer
    @property
    def offsetX(self):
        return self._ptr[0].subresource.sparseLevel.offsetX
    @offsetX.setter
    def offsetX(self, unsigned int offsetX):
        pass
        self._ptr[0].subresource.sparseLevel.offsetX = offsetX
    @property
    def offsetY(self):
        return self._ptr[0].subresource.sparseLevel.offsetY
    @offsetY.setter
    def offsetY(self, unsigned int offsetY):
        pass
        self._ptr[0].subresource.sparseLevel.offsetY = offsetY
    @property
    def offsetZ(self):
        return self._ptr[0].subresource.sparseLevel.offsetZ
    @offsetZ.setter
    def offsetZ(self, unsigned int offsetZ):
        pass
        self._ptr[0].subresource.sparseLevel.offsetZ = offsetZ
    @property
    def extentWidth(self):
        return self._ptr[0].subresource.sparseLevel.extentWidth
    @extentWidth.setter
    def extentWidth(self, unsigned int extentWidth):
        pass
        self._ptr[0].subresource.sparseLevel.extentWidth = extentWidth
    @property
    def extentHeight(self):
        return self._ptr[0].subresource.sparseLevel.extentHeight
    @extentHeight.setter
    def extentHeight(self, unsigned int extentHeight):
        pass
        self._ptr[0].subresource.sparseLevel.extentHeight = extentHeight
    @property
    def extentDepth(self):
        return self._ptr[0].subresource.sparseLevel.extentDepth
    @extentDepth.setter
    def extentDepth(self, unsigned int extentDepth):
        pass
        self._ptr[0].subresource.sparseLevel.extentDepth = extentDepth

cdef class _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_subresource_miptail_s:
    """

    Attributes
    ----------
    layer : unsigned int

    offset : unsigned long long

    size : unsigned long long


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUarrayMapInfo_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['layer : ' + str(self.layer)]
            str_list += ['offset : ' + str(self.offset)]
            str_list += ['size : ' + str(self.size)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def layer(self):
        return self._ptr[0].subresource.miptail.layer
    @layer.setter
    def layer(self, unsigned int layer):
        pass
        self._ptr[0].subresource.miptail.layer = layer
    @property
    def offset(self):
        return self._ptr[0].subresource.miptail.offset
    @offset.setter
    def offset(self, unsigned long long offset):
        pass
        self._ptr[0].subresource.miptail.offset = offset
    @property
    def size(self):
        return self._ptr[0].subresource.miptail.size
    @size.setter
    def size(self, unsigned long long size):
        pass
        self._ptr[0].subresource.miptail.size = size

cdef class _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_u:
    """

    Attributes
    ----------
    sparseLevel : _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_subresource_sparseLevel_s

    miptail : _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_subresource_miptail_s


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUarrayMapInfo_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._sparseLevel = _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_subresource_sparseLevel_s(_ptr=<void_ptr>self._ptr)
        self._miptail = _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_subresource_miptail_s(_ptr=<void_ptr>self._ptr)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['sparseLevel :\n' + '\n'.join(['    ' + line for line in str(self.sparseLevel).splitlines()])]
            str_list += ['miptail :\n' + '\n'.join(['    ' + line for line in str(self.miptail).splitlines()])]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def sparseLevel(self):
        return self._sparseLevel
    @sparseLevel.setter
    def sparseLevel(self, sparseLevel not None : _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_subresource_sparseLevel_s):
        pass
        for _attr in dir(sparseLevel):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._sparseLevel, _attr, getattr(sparseLevel, _attr))
    @property
    def miptail(self):
        return self._miptail
    @miptail.setter
    def miptail(self, miptail not None : _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_subresource_miptail_s):
        pass
        for _attr in dir(miptail):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._miptail, _attr, getattr(miptail, _attr))

cdef class _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_memHandle_u:
    """

    Attributes
    ----------
    memHandle : CUmemGenericAllocationHandle


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUarrayMapInfo_st *>_ptr
    def __init__(self, void_ptr _ptr):
        self._memHandle = CUmemGenericAllocationHandle(_ptr=<void_ptr>&self._ptr[0].memHandle.memHandle)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['memHandle : ' + str(self.memHandle)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def memHandle(self):
        return self._memHandle
    @memHandle.setter
    def memHandle(self, memHandle):
        cdef ccuda.CUmemGenericAllocationHandle cmemHandle
        if memHandle is None:
            cmemHandle = <ccuda.CUmemGenericAllocationHandle><void_ptr>0
        elif isinstance(memHandle, (CUmemGenericAllocationHandle)):
            pmemHandle = int(memHandle)
            cmemHandle = <ccuda.CUmemGenericAllocationHandle><void_ptr>pmemHandle
        else:
            pmemHandle = int(CUmemGenericAllocationHandle(memHandle))
            cmemHandle = <ccuda.CUmemGenericAllocationHandle><void_ptr>pmemHandle
        self._memHandle._ptr[0] = cmemHandle

cdef class CUarrayMapInfo_st:
    """
    Specifies the CUDA array or CUDA mipmapped array memory mapping
    information

    Attributes
    ----------
    resourceType : CUresourcetype
        Resource type
    resource : _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_resource_u

    subresourceType : CUarraySparseSubresourceType
        Sparse subresource type
    subresource : _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_u

    memOperationType : CUmemOperationType
        Memory operation type
    memHandleType : CUmemHandleType
        Memory handle type
    memHandle : _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_memHandle_u

    offset : unsigned long long
        Offset within mip tail  Offset within the memory
    deviceBitMask : unsigned int
        Device ordinal bit mask
    flags : unsigned int
        flags for future use, must be zero now.
    reserved : List[unsigned int]
        Reserved for future use, must be zero now.

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUarrayMapInfo_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._resource = _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_resource_u(_ptr=<void_ptr>self._ptr)
        self._subresource = _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_u(_ptr=<void_ptr>self._ptr)
        self._memHandle = _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_memHandle_u(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['resourceType : ' + str(self.resourceType)]
            str_list += ['resource :\n' + '\n'.join(['    ' + line for line in str(self.resource).splitlines()])]
            str_list += ['subresourceType : ' + str(self.subresourceType)]
            str_list += ['subresource :\n' + '\n'.join(['    ' + line for line in str(self.subresource).splitlines()])]
            str_list += ['memOperationType : ' + str(self.memOperationType)]
            str_list += ['memHandleType : ' + str(self.memHandleType)]
            str_list += ['memHandle :\n' + '\n'.join(['    ' + line for line in str(self.memHandle).splitlines()])]
            str_list += ['offset : ' + str(self.offset)]
            str_list += ['deviceBitMask : ' + str(self.deviceBitMask)]
            str_list += ['flags : ' + str(self.flags)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def resourceType(self):
        return CUresourcetype(self._ptr[0].resourceType)
    @resourceType.setter
    def resourceType(self, resourceType not None : CUresourcetype):
        pass
        self._ptr[0].resourceType = resourceType.value
    @property
    def resource(self):
        return self._resource
    @resource.setter
    def resource(self, resource not None : _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_resource_u):
        pass
        for _attr in dir(resource):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._resource, _attr, getattr(resource, _attr))
    @property
    def subresourceType(self):
        return CUarraySparseSubresourceType(self._ptr[0].subresourceType)
    @subresourceType.setter
    def subresourceType(self, subresourceType not None : CUarraySparseSubresourceType):
        pass
        self._ptr[0].subresourceType = subresourceType.value
    @property
    def subresource(self):
        return self._subresource
    @subresource.setter
    def subresource(self, subresource not None : _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_subresource_u):
        pass
        for _attr in dir(subresource):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._subresource, _attr, getattr(subresource, _attr))
    @property
    def memOperationType(self):
        return CUmemOperationType(self._ptr[0].memOperationType)
    @memOperationType.setter
    def memOperationType(self, memOperationType not None : CUmemOperationType):
        pass
        self._ptr[0].memOperationType = memOperationType.value
    @property
    def memHandleType(self):
        return CUmemHandleType(self._ptr[0].memHandleType)
    @memHandleType.setter
    def memHandleType(self, memHandleType not None : CUmemHandleType):
        pass
        self._ptr[0].memHandleType = memHandleType.value
    @property
    def memHandle(self):
        return self._memHandle
    @memHandle.setter
    def memHandle(self, memHandle not None : _CUarrayMapInfo_v1_CUarrayMapInfo_v1_CUarrayMapInfo_st_memHandle_u):
        pass
        for _attr in dir(memHandle):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._memHandle, _attr, getattr(memHandle, _attr))
    @property
    def offset(self):
        return self._ptr[0].offset
    @offset.setter
    def offset(self, unsigned long long offset):
        pass
        self._ptr[0].offset = offset
    @property
    def deviceBitMask(self):
        return self._ptr[0].deviceBitMask
    @deviceBitMask.setter
    def deviceBitMask(self, unsigned int deviceBitMask):
        pass
        self._ptr[0].deviceBitMask = deviceBitMask
    @property
    def flags(self):
        return self._ptr[0].flags
    @flags.setter
    def flags(self, unsigned int flags):
        pass
        self._ptr[0].flags = flags
    @property
    def reserved(self):
        return self._ptr[0].reserved
    @reserved.setter
    def reserved(self, reserved):
        pass
        self._ptr[0].reserved = reserved

cdef class CUmemLocation_st:
    """
    Specifies a memory location.

    Attributes
    ----------
    type : CUmemLocationType
        Specifies the location type, which modifies the meaning of id.
    id : int
        identifier for a given this location's CUmemLocationType.

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUmemLocation_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['type : ' + str(self.type)]
            str_list += ['id : ' + str(self.id)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def type(self):
        return CUmemLocationType(self._ptr[0].type)
    @type.setter
    def type(self, type not None : CUmemLocationType):
        pass
        self._ptr[0].type = type.value
    @property
    def id(self):
        return self._ptr[0].id
    @id.setter
    def id(self, int id):
        pass
        self._ptr[0].id = id

cdef class _CUmemAllocationProp_v1_CUmemAllocationProp_v1_CUmemAllocationProp_st_allocFlags_s:
    """

    Attributes
    ----------
    compressionType : unsigned char

    gpuDirectRDMACapable : unsigned char

    usage : unsigned short

    reserved : unsigned char


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUmemAllocationProp_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['compressionType : ' + str(self.compressionType)]
            str_list += ['gpuDirectRDMACapable : ' + str(self.gpuDirectRDMACapable)]
            str_list += ['usage : ' + str(self.usage)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def compressionType(self):
        return self._ptr[0].allocFlags.compressionType
    @compressionType.setter
    def compressionType(self, unsigned char compressionType):
        pass
        self._ptr[0].allocFlags.compressionType = compressionType
    @property
    def gpuDirectRDMACapable(self):
        return self._ptr[0].allocFlags.gpuDirectRDMACapable
    @gpuDirectRDMACapable.setter
    def gpuDirectRDMACapable(self, unsigned char gpuDirectRDMACapable):
        pass
        self._ptr[0].allocFlags.gpuDirectRDMACapable = gpuDirectRDMACapable
    @property
    def usage(self):
        return self._ptr[0].allocFlags.usage
    @usage.setter
    def usage(self, unsigned short usage):
        pass
        self._ptr[0].allocFlags.usage = usage
    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(<char*>self._ptr[0].allocFlags.reserved, 4)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 4:
            raise ValueError("reserved length must be 4, is " + str(len(reserved)))
        for i, b in enumerate(reserved):
            self._ptr[0].allocFlags.reserved[i] = b

cdef class CUmemAllocationProp_st:
    """
    Specifies the allocation properties for a allocation.

    Attributes
    ----------
    type : CUmemAllocationType
        Allocation type
    requestedHandleTypes : CUmemAllocationHandleType
        requested CUmemAllocationHandleType
    location : CUmemLocation
        Location of allocation
    win32HandleMetaData : Any
        Windows-specific POBJECT_ATTRIBUTES required when
        CU_MEM_HANDLE_TYPE_WIN32 is specified. This object atributes
        structure includes security attributes that define the scope of
        which exported allocations may be tranferred to other processes. In
        all other cases, this field is required to be zero.
    allocFlags : _CUmemAllocationProp_v1_CUmemAllocationProp_v1_CUmemAllocationProp_st_allocFlags_s


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUmemAllocationProp_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._location = CUmemLocation(_ptr=<void_ptr>&self._ptr[0].location)
        self._allocFlags = _CUmemAllocationProp_v1_CUmemAllocationProp_v1_CUmemAllocationProp_st_allocFlags_s(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['type : ' + str(self.type)]
            str_list += ['requestedHandleTypes : ' + str(self.requestedHandleTypes)]
            str_list += ['location :\n' + '\n'.join(['    ' + line for line in str(self.location).splitlines()])]
            str_list += ['win32HandleMetaData : ' + hex(self.win32HandleMetaData)]
            str_list += ['allocFlags :\n' + '\n'.join(['    ' + line for line in str(self.allocFlags).splitlines()])]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def type(self):
        return CUmemAllocationType(self._ptr[0].type)
    @type.setter
    def type(self, type not None : CUmemAllocationType):
        pass
        self._ptr[0].type = type.value
    @property
    def requestedHandleTypes(self):
        return CUmemAllocationHandleType(self._ptr[0].requestedHandleTypes)
    @requestedHandleTypes.setter
    def requestedHandleTypes(self, requestedHandleTypes not None : CUmemAllocationHandleType):
        pass
        self._ptr[0].requestedHandleTypes = requestedHandleTypes.value
    @property
    def location(self):
        return self._location
    @location.setter
    def location(self, location not None : CUmemLocation):
        pass
        for _attr in dir(location):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._location, _attr, getattr(location, _attr))
    @property
    def win32HandleMetaData(self):
        return <void_ptr>self._ptr[0].win32HandleMetaData
    @win32HandleMetaData.setter
    def win32HandleMetaData(self, win32HandleMetaData):
        _cwin32HandleMetaData = utils.HelperInputVoidPtr(win32HandleMetaData)
        self._ptr[0].win32HandleMetaData = <void*><void_ptr>_cwin32HandleMetaData.cptr
    @property
    def allocFlags(self):
        return self._allocFlags
    @allocFlags.setter
    def allocFlags(self, allocFlags not None : _CUmemAllocationProp_v1_CUmemAllocationProp_v1_CUmemAllocationProp_st_allocFlags_s):
        pass
        for _attr in dir(allocFlags):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._allocFlags, _attr, getattr(allocFlags, _attr))

cdef class CUmemAccessDesc_st:
    """
    Memory access descriptor

    Attributes
    ----------
    location : CUmemLocation
        Location on which the request is to change it's accessibility
    flags : CUmemAccess_flags
        ::CUmemProt accessibility flags to set on the request

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUmemAccessDesc_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._location = CUmemLocation(_ptr=<void_ptr>&self._ptr[0].location)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['location :\n' + '\n'.join(['    ' + line for line in str(self.location).splitlines()])]
            str_list += ['flags : ' + str(self.flags)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def location(self):
        return self._location
    @location.setter
    def location(self, location not None : CUmemLocation):
        pass
        for _attr in dir(location):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._location, _attr, getattr(location, _attr))
    @property
    def flags(self):
        return CUmemAccess_flags(self._ptr[0].flags)
    @flags.setter
    def flags(self, flags not None : CUmemAccess_flags):
        pass
        self._ptr[0].flags = flags.value

cdef class CUmemPoolProps_st:
    """
    Specifies the properties of allocations made from the pool.

    Attributes
    ----------
    allocType : CUmemAllocationType
        Allocation type. Currently must be specified as
        CU_MEM_ALLOCATION_TYPE_PINNED
    handleTypes : CUmemAllocationHandleType
        Handle types that will be supported by allocations from the pool.
    location : CUmemLocation
        Location where allocations should reside.
    win32SecurityAttributes : Any
        Windows-specific LPSECURITYATTRIBUTES required when
        CU_MEM_HANDLE_TYPE_WIN32 is specified. This security attribute
        defines the scope of which exported allocations may be tranferred
        to other processes. In all other cases, this field is required to
        be zero.
    reserved : bytes
        reserved for future use, must be 0

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUmemPoolProps_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._location = CUmemLocation(_ptr=<void_ptr>&self._ptr[0].location)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['allocType : ' + str(self.allocType)]
            str_list += ['handleTypes : ' + str(self.handleTypes)]
            str_list += ['location :\n' + '\n'.join(['    ' + line for line in str(self.location).splitlines()])]
            str_list += ['win32SecurityAttributes : ' + hex(self.win32SecurityAttributes)]
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def allocType(self):
        return CUmemAllocationType(self._ptr[0].allocType)
    @allocType.setter
    def allocType(self, allocType not None : CUmemAllocationType):
        pass
        self._ptr[0].allocType = allocType.value
    @property
    def handleTypes(self):
        return CUmemAllocationHandleType(self._ptr[0].handleTypes)
    @handleTypes.setter
    def handleTypes(self, handleTypes not None : CUmemAllocationHandleType):
        pass
        self._ptr[0].handleTypes = handleTypes.value
    @property
    def location(self):
        return self._location
    @location.setter
    def location(self, location not None : CUmemLocation):
        pass
        for _attr in dir(location):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._location, _attr, getattr(location, _attr))
    @property
    def win32SecurityAttributes(self):
        return <void_ptr>self._ptr[0].win32SecurityAttributes
    @win32SecurityAttributes.setter
    def win32SecurityAttributes(self, win32SecurityAttributes):
        _cwin32SecurityAttributes = utils.HelperInputVoidPtr(win32SecurityAttributes)
        self._ptr[0].win32SecurityAttributes = <void*><void_ptr>_cwin32SecurityAttributes.cptr
    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(<char*>self._ptr[0].reserved, 64)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 64:
            raise ValueError("reserved length must be 64, is " + str(len(reserved)))
        for i, b in enumerate(reserved):
            self._ptr[0].reserved[i] = b

cdef class CUmemPoolPtrExportData_st:
    """
    Opaque data for exporting a pool allocation

    Attributes
    ----------
    reserved : bytes


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUmemPoolPtrExportData_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        pass
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['reserved : ' + str(self.reserved)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def reserved(self):
        return PyBytes_FromStringAndSize(<char*>self._ptr[0].reserved, 64)
    @reserved.setter
    def reserved(self, reserved):
        if len(reserved) != 64:
            raise ValueError("reserved length must be 64, is " + str(len(reserved)))
        for i, b in enumerate(reserved):
            self._ptr[0].reserved[i] = b

cdef class CUDA_MEM_ALLOC_NODE_PARAMS_st:
    """
    Memory allocation node parameters

    Attributes
    ----------
    poolProps : CUmemPoolProps
        in: location where the allocation should reside (specified in
        ::location). ::handleTypes must be CU_MEM_HANDLE_TYPE_NONE. IPC is
        not supported.
    accessDescs : CUmemAccessDesc
        in: array of memory access descriptors. Used to describe peer GPU
        access
    accessDescCount : size_t
        in: number of memory access descriptors. Must not exceed the number
        of GPUs.
    bytesize : size_t
        in: size in bytes of the requested allocation
    dptr : CUdeviceptr
        out: address of the allocation returned by CUDA

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUDA_MEM_ALLOC_NODE_PARAMS_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._poolProps = CUmemPoolProps(_ptr=<void_ptr>&self._ptr[0].poolProps)
        self._dptr = CUdeviceptr(_ptr=<void_ptr>&self._ptr[0].dptr)
    def __dealloc__(self):
        if self._accessDescs is not NULL:
            free(self._accessDescs)
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['poolProps :\n' + '\n'.join(['    ' + line for line in str(self.poolProps).splitlines()])]
            str_list += ['accessDescs : ' + str(self.accessDescs)]
            str_list += ['accessDescCount : ' + str(self.accessDescCount)]
            str_list += ['bytesize : ' + str(self.bytesize)]
            str_list += ['dptr : ' + str(self.dptr)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def poolProps(self):
        return self._poolProps
    @poolProps.setter
    def poolProps(self, poolProps not None : CUmemPoolProps):
        pass
        for _attr in dir(poolProps):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._poolProps, _attr, getattr(poolProps, _attr))
    @property
    def accessDescs(self):
        arrs = [<void_ptr>self._ptr[0].accessDescs + x*sizeof(ccuda.CUmemAccessDesc) for x in range(self._accessDescs_length)]
        return [CUmemAccessDesc(_ptr=arr) for arr in arrs]
    @accessDescs.setter
    def accessDescs(self, val):
        if len(val) == 0:
            free(self._accessDescs)
            self._accessDescs_length = 0
            self._ptr[0].accessDescs = NULL
        else:
            if self._accessDescs_length != <size_t>len(val):
                free(self._accessDescs)
                self._accessDescs = <ccuda.CUmemAccessDesc*> calloc(len(val), sizeof(ccuda.CUmemAccessDesc))
                if self._accessDescs is NULL:
                    raise MemoryError('Failed to allocate length x size memory: ' + str(len(val)) + 'x' + str(sizeof(ccuda.CUmemAccessDesc)))
                self._accessDescs_length = <size_t>len(val)
                self._ptr[0].accessDescs = self._accessDescs
            for idx in range(len(val)):
                memcpy(&self._accessDescs[idx], (<CUmemAccessDesc>val[idx])._ptr, sizeof(ccuda.CUmemAccessDesc))
    @property
    def accessDescCount(self):
        return self._ptr[0].accessDescCount
    @accessDescCount.setter
    def accessDescCount(self, size_t accessDescCount):
        pass
        self._ptr[0].accessDescCount = accessDescCount
    @property
    def bytesize(self):
        return self._ptr[0].bytesize
    @bytesize.setter
    def bytesize(self, size_t bytesize):
        pass
        self._ptr[0].bytesize = bytesize
    @property
    def dptr(self):
        return self._dptr
    @dptr.setter
    def dptr(self, dptr):
        cdef ccuda.CUdeviceptr cdptr
        if dptr is None:
            cdptr = <ccuda.CUdeviceptr><void_ptr>0
        elif isinstance(dptr, (CUdeviceptr)):
            pdptr = int(dptr)
            cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr
        else:
            pdptr = int(CUdeviceptr(dptr))
            cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr
        self._dptr._ptr[0] = cdptr

cdef class _CUeglFrame_v1_CUeglFrame_v1_CUeglFrame_st_frame_u:
    """

    Attributes
    ----------
    pArray : List[CUarray]

    pPitch : List[void]


    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr):
        self._ptr = <ccuda.CUeglFrame_st *>_ptr
    def __init__(self, void_ptr _ptr):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['pArray : ' + str(self.pArray)]
            str_list += ['pPitch : ' + str(self.pPitch)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def pArray(self):
        return [CUarray(init_value=<void_ptr>_pArray) for _pArray in self._ptr[0].frame.pArray]
    @pArray.setter
    def pArray(self, pArray : List[CUarray]):
        if len(pArray) != 3:
            raise IndexError('not enough values found during array assignment, expected 3, got', len(pArray))
        pArray = [int(_pArray) for _pArray in pArray]
        for _idx, _pArray in enumerate(pArray):
            self._ptr[0].frame.pArray[_idx] = <ccuda.CUarray><void_ptr>_pArray
    @property
    def pPitch(self):
        return [<void_ptr>_pPitch for _pPitch in self._ptr[0].frame.pPitch]
    @pPitch.setter
    def pPitch(self, pPitch : List[int]):
        if len(pPitch) != 3:
            raise IndexError('not enough values found during array assignment, expected 3, got', len(pPitch))
        pPitch = [<void_ptr>_pPitch for _pPitch in pPitch]
        for _idx, _pPitch in enumerate(pPitch):
            self._ptr[0].frame.pPitch[_idx] = <void*><void_ptr>_pPitch

cdef class CUeglFrame_st:
    """
    CUDA EGLFrame structure Descriptor - structure defining one frame
    of EGL.  Each frame may contain one or more planes depending on
    whether the surface * is Multiplanar or not.

    Attributes
    ----------
    frame : _CUeglFrame_v1_CUeglFrame_v1_CUeglFrame_st_frame_u

    width : unsigned int
        Width of first plane
    height : unsigned int
        Height of first plane
    depth : unsigned int
        Depth of first plane
    pitch : unsigned int
        Pitch of first plane
    planeCount : unsigned int
        Number of planes
    numChannels : unsigned int
        Number of channels for the plane
    frameType : CUeglFrameType
        Array or Pitch
    eglColorFormat : CUeglColorFormat
        CUDA EGL Color Format
    cuFormat : CUarray_format
        CUDA Array Format

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUeglFrame_st *>_ptr
    def __init__(self, void_ptr _ptr = 0):
        self._frame = _CUeglFrame_v1_CUeglFrame_v1_CUeglFrame_st_frame_u(_ptr=<void_ptr>self._ptr)
    def __dealloc__(self):
        pass
    def getPtr(self):
        return <void_ptr>self._ptr
    def __repr__(self):
        if self._ptr is not NULL:
            str_list = []
            str_list += ['frame :\n' + '\n'.join(['    ' + line for line in str(self.frame).splitlines()])]
            str_list += ['width : ' + str(self.width)]
            str_list += ['height : ' + str(self.height)]
            str_list += ['depth : ' + str(self.depth)]
            str_list += ['pitch : ' + str(self.pitch)]
            str_list += ['planeCount : ' + str(self.planeCount)]
            str_list += ['numChannels : ' + str(self.numChannels)]
            str_list += ['frameType : ' + str(self.frameType)]
            str_list += ['eglColorFormat : ' + str(self.eglColorFormat)]
            str_list += ['cuFormat : ' + str(self.cuFormat)]
            return '\n'.join(str_list)
        else:
            return ''

    @property
    def frame(self):
        return self._frame
    @frame.setter
    def frame(self, frame not None : _CUeglFrame_v1_CUeglFrame_v1_CUeglFrame_st_frame_u):
        pass
        for _attr in dir(frame):
            if _attr == 'getPtr':
                continue
            if not _attr.startswith('_'):
                setattr(self._frame, _attr, getattr(frame, _attr))
    @property
    def width(self):
        return self._ptr[0].width
    @width.setter
    def width(self, unsigned int width):
        pass
        self._ptr[0].width = width
    @property
    def height(self):
        return self._ptr[0].height
    @height.setter
    def height(self, unsigned int height):
        pass
        self._ptr[0].height = height
    @property
    def depth(self):
        return self._ptr[0].depth
    @depth.setter
    def depth(self, unsigned int depth):
        pass
        self._ptr[0].depth = depth
    @property
    def pitch(self):
        return self._ptr[0].pitch
    @pitch.setter
    def pitch(self, unsigned int pitch):
        pass
        self._ptr[0].pitch = pitch
    @property
    def planeCount(self):
        return self._ptr[0].planeCount
    @planeCount.setter
    def planeCount(self, unsigned int planeCount):
        pass
        self._ptr[0].planeCount = planeCount
    @property
    def numChannels(self):
        return self._ptr[0].numChannels
    @numChannels.setter
    def numChannels(self, unsigned int numChannels):
        pass
        self._ptr[0].numChannels = numChannels
    @property
    def frameType(self):
        return CUeglFrameType(self._ptr[0].frameType)
    @frameType.setter
    def frameType(self, frameType not None : CUeglFrameType):
        pass
        self._ptr[0].frameType = frameType.value
    @property
    def eglColorFormat(self):
        return CUeglColorFormat(self._ptr[0].eglColorFormat)
    @eglColorFormat.setter
    def eglColorFormat(self, eglColorFormat not None : CUeglColorFormat):
        pass
        self._ptr[0].eglColorFormat = eglColorFormat.value
    @property
    def cuFormat(self):
        return CUarray_format(self._ptr[0].cuFormat)
    @cuFormat.setter
    def cuFormat(self, cuFormat not None : CUarray_format):
        pass
        self._ptr[0].cuFormat = cuFormat.value

cdef class cuuint32_t:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, uint32_t init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.cuuint32_t *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<cuuint32_t ' + str(self.__int__()) + '>'
    def __int__(self):
        return <uint32_t>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class cuuint64_t:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, uint64_t init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.cuuint64_t *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<cuuint64_t ' + str(self.__int__()) + '>'
    def __int__(self):
        return <uint64_t>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUdeviceptr_v2:
    """

    CUDA device pointer CUdeviceptr is defined as an unsigned integer type whose size matches the size of a pointer on the target platform.

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUdeviceptr_v2 *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUdeviceptr_v2 ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUdeviceptr:
    """

    CUDA device pointer

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUdeviceptr *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUdeviceptr ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUdevice_v1:
    """

    CUDA device

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, int init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUdevice_v1 *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUdevice_v1 ' + str(self.__int__()) + '>'
    def __int__(self):
        return <int>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUdevice:
    """

    CUDA device

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, int init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUdevice *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUdevice ' + str(self.__int__()) + '>'
    def __int__(self):
        return <int>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUtexObject_v1:
    """

    An opaque value that represents a CUDA texture object

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUtexObject_v1 *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUtexObject_v1 ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUtexObject:
    """

    An opaque value that represents a CUDA texture object

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUtexObject *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUtexObject ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUsurfObject_v1:
    """

    An opaque value that represents a CUDA surface object

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUsurfObject_v1 *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUsurfObject_v1 ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUsurfObject:
    """

    An opaque value that represents a CUDA surface object

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUsurfObject *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUsurfObject ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUmemGenericAllocationHandle_v1:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUmemGenericAllocationHandle_v1 *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUmemGenericAllocationHandle_v1 ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class CUmemGenericAllocationHandle:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.CUmemGenericAllocationHandle *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<CUmemGenericAllocationHandle ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class GLenum:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned int init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.GLenum *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<GLenum ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned int>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class GLuint:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned int init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.GLuint *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<GLuint ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned int>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class EGLint:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned int init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.EGLint *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<EGLint ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned int>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class VdpDevice:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, uint32_t init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.VdpDevice *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<VdpDevice ' + str(self.__int__()) + '>'
    def __int__(self):
        return <uint32_t>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class VdpGetProcAddress:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, unsigned long long init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.VdpGetProcAddress *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<VdpGetProcAddress ' + str(self.__int__()) + '>'
    def __int__(self):
        return <unsigned long long>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class VdpVideoSurface:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, uint32_t init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.VdpVideoSurface *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<VdpVideoSurface ' + str(self.__int__()) + '>'
    def __int__(self):
        return <uint32_t>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr

cdef class VdpOutputSurface:
    """

    Methods
    -------
    getPtr()
        Get memory address of class instance

    """
    def __cinit__(self, uint32_t init_value = 0, void_ptr _ptr = 0):
        if _ptr == 0:
            self._ptr = &self._val
        else:
            self._ptr = <ccuda.VdpOutputSurface *>_ptr
        if init_value:
            self._ptr[0] = init_value
    def __dealloc__(self):
        pass
    def __repr__(self):
        return '<VdpOutputSurface ' + str(self.__int__()) + '>'
    def __int__(self):
        return <uint32_t>self._ptr[0]
    def getPtr(self):
        return <void_ptr>self._ptr


@cython.embedsignature(True)
def cuGetErrorString(error not None : CUresult):
    """ Gets the string description of an error code.

    Sets `*pStr` to the address of a NULL-terminated string description of
    the error code `error`. If the error code is not recognized,
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned and `*pStr` will
    be set to the NULL address.

    Parameters
    ----------
    error : :py:obj:`~.CUresult`
        Error code to convert to string

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pStr : bytes
        Address of the string pointer.

    See Also
    --------
    :py:obj:`~.CUresult`, :py:obj:`~.cudaGetErrorString`
    """
    cdef ccuda.CUresult cerror = error.value
    cdef const char* pStr = NULL
    err = ccuda.cuGetErrorString(cerror, &pStr)
    return (CUresult(err), <bytes>pStr)

@cython.embedsignature(True)
def cuGetErrorName(error not None : CUresult):
    """ Gets the string representation of an error code enum name.

    Sets `*pStr` to the address of a NULL-terminated string representation
    of the name of the enum error code `error`. If the error code is not
    recognized, :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned and
    `*pStr` will be set to the NULL address.

    Parameters
    ----------
    error : :py:obj:`~.CUresult`
        Error code to convert to string

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pStr : bytes
        Address of the string pointer.

    See Also
    --------
    :py:obj:`~.CUresult`, :py:obj:`~.cudaGetErrorName`
    """
    cdef ccuda.CUresult cerror = error.value
    cdef const char* pStr = NULL
    err = ccuda.cuGetErrorName(cerror, &pStr)
    return (CUresult(err), <bytes>pStr)

@cython.embedsignature(True)
def cuInit(unsigned int Flags):
    """ Initialize the CUDA driver API.

    Initializes the driver API and must be called before any other function
    from the driver API. Currently, the `Flags` parameter must be 0. If
    :py:obj:`~.cuInit()` has not been called, any function from the driver
    API will return :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`.

    Parameters
    ----------
    Flags : unsigned int
        Initialization flag for CUDA.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_SYSTEM_DRIVER_MISMATCH`, :py:obj:`~.CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE`
    """
    err = ccuda.cuInit(Flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuDriverGetVersion():
    """ Returns the latest CUDA version supported by driver.

    Returns in `*driverVersion` the version of CUDA supported by the
    driver. The version is returned as (1000 * major + 10 * minor). For
    example, CUDA 9.2 would be represented by 9020.

    This function automatically returns
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if `driverVersion` is NULL.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    driverVersion : int
        Returns the CUDA driver version

    See Also
    --------
    :py:obj:`~.cudaDriverGetVersion`, :py:obj:`~.cudaRuntimeGetVersion`
    """
    cdef int driverVersion = 0
    err = ccuda.cuDriverGetVersion(&driverVersion)
    return (CUresult(err), driverVersion)

@cython.embedsignature(True)
def cuDeviceGet(int ordinal):
    """ Returns a handle to a compute device.

    Returns in `*device` a device handle given an ordinal in the range [0,
    :py:obj:`~.cuDeviceGetCount()`-1].

    Parameters
    ----------
    ordinal : int
        Device number to get handle for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    device : :py:obj:`~.CUdevice`
        Returned device handle

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGetLuid`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cuDeviceGetExecAffinitySupport`
    """
    cdef CUdevice device = CUdevice()
    err = ccuda.cuDeviceGet(device._ptr, ordinal)
    return (CUresult(err), device)

@cython.embedsignature(True)
def cuDeviceGetCount():
    """ Returns the number of compute-capable devices.

    Returns in `*count` the number of devices with compute capability
    greater than or equal to 2.0 that are available for execution. If there
    is no such device, :py:obj:`~.cuDeviceGetCount()` returns 0.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    count : int
        Returned number of compute-capable devices

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGetLuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cuDeviceGetExecAffinitySupport`, :py:obj:`~.cudaGetDeviceCount`
    """
    cdef int count = 0
    err = ccuda.cuDeviceGetCount(&count)
    return (CUresult(err), count)

@cython.embedsignature(True)
def cuDeviceGetName(int length, dev):
    """ Returns an identifer string for the device.

    Returns an ASCII string identifying the device `dev` in the NULL-
    terminated string pointed to by `name`. `length` specifies the maximum
    length of the string that may be returned.

    Parameters
    ----------
    length : int
        Maximum length of string to store in `name`
    dev : :py:obj:`~.CUdevice`
        Device to get identifier string for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    name : bytes
        Returned identifier string for the device

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGetLuid`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cuDeviceGetExecAffinitySupport`, :py:obj:`~.cudaGetDeviceProperties`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    pyname = b" " * length
    cdef char* name = pyname
    err = ccuda.cuDeviceGetName(name, length, cdev)
    return (CUresult(err), pyname)

@cython.embedsignature(True)
def cuDeviceGetUuid(dev):
    """ Return an UUID for the device.

    Note there is a later version of this API,
    :py:obj:`~.cuDeviceGetUuid_v2`. It will supplant this version in 12.0,
    which is retained for minor version compatibility.

    Returns 16-octets identifing the device `dev` in the structure pointed
    by the `uuid`.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device to get identifier string for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    uuid : :py:obj:`~.CUuuid`
        Returned UUID

    See Also
    --------
    :py:obj:`~.cuDeviceGetUuid_v2` :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetLuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cuDeviceGetExecAffinitySupport`, :py:obj:`~.cudaGetDeviceProperties`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    cdef CUuuid uuid = CUuuid()
    err = ccuda.cuDeviceGetUuid(uuid._ptr, cdev)
    return (CUresult(err), uuid)

@cython.embedsignature(True)
def cuDeviceGetUuid_v2(dev):
    """ Return an UUID for the device (11.4+)

    Returns 16-octets identifing the device `dev` in the structure pointed
    by the `uuid`. If the device is in MIG mode, returns its MIG UUID which
    uniquely identifies the subscribed MIG compute instance.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device to get identifier string for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    uuid : :py:obj:`~.CUuuid`
        Returned UUID

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetLuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cudaGetDeviceProperties`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    cdef CUuuid uuid = CUuuid()
    err = ccuda.cuDeviceGetUuid_v2(uuid._ptr, cdev)
    return (CUresult(err), uuid)

@cython.embedsignature(True)
def cuDeviceGetLuid(dev):
    """ Return an LUID and device node mask for the device.

    Return identifying information (`luid` and `deviceNodeMask`) to allow
    matching device with graphics APIs.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device to get identifier string for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    luid : bytes
        Returned LUID
    deviceNodeMask : unsigned int
        Returned device node mask

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cuDeviceGetExecAffinitySupport`, :py:obj:`~.cudaGetDeviceProperties`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    cdef char luid[8]
    cdef unsigned int deviceNodeMask = 0
    err = ccuda.cuDeviceGetLuid(luid, &deviceNodeMask, cdev)
    return (CUresult(err), <bytes>luid, deviceNodeMask)

@cython.embedsignature(True)
def cuDeviceTotalMem(dev):
    """ Returns the total amount of memory on the device.

    Returns in `*bytes` the total amount of memory available on the device
    `dev` in bytes.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device handle

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    numbytes : int
        Returned memory available on device in bytes

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceGetExecAffinitySupport`, :py:obj:`~.cudaMemGetInfo`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    cdef size_t numbytes = 0
    err = ccuda.cuDeviceTotalMem(&numbytes, cdev)
    return (CUresult(err), numbytes)

@cython.embedsignature(True)
def cuDeviceGetTexture1DLinearMaxWidth(pformat not None : CUarray_format, unsigned numChannels, dev):
    """ Returns the maximum number of elements allocatable in a 1D linear texture for a given texture element size.

    Returns in `maxWidthInElements` the maximum number of texture elements
    allocatable in a 1D linear texture for given `pformat` and
    `numChannels`.

    Parameters
    ----------
    pformat : :py:obj:`~.CUarray_format`
        Texture format.
    numChannels : unsigned
        Number of channels per texture element.
    dev : :py:obj:`~.CUdevice`
        Device handle.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    maxWidthInElements : int
        Returned maximum number of texture elements allocatable for given
        `pformat` and `numChannels`.

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cudaMemGetInfo`, :py:obj:`~.cuDeviceTotalMem`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    cdef size_t maxWidthInElements = 0
    cdef ccuda.CUarray_format cpformat = pformat.value
    err = ccuda.cuDeviceGetTexture1DLinearMaxWidth(&maxWidthInElements, cpformat, numChannels, cdev)
    return (CUresult(err), maxWidthInElements)

@cython.embedsignature(True)
def cuDeviceGetAttribute(attrib not None : CUdevice_attribute, dev):
    """ Returns information about the device.

    Returns in `*pi` the integer value of the attribute `attrib` on device
    `dev`. The supported attributes are:

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK`: Maximum number
      of threads per block;

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X`: Maximum x-dimension
      of a block

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y`: Maximum y-dimension
      of a block

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z`: Maximum z-dimension
      of a block

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X`: Maximum x-dimension
      of a grid

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y`: Maximum y-dimension
      of a grid

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z`: Maximum z-dimension
      of a grid

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK`: Maximum
      amount of shared memory available to a thread block in bytes

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY`: Memory
      available on device for constant variables in a CUDA C kernel in
      bytes

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_WARP_SIZE`: Warp size in threads

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PITCH`: Maximum pitch in bytes
      allowed by the memory copy functions that involve memory regions
      allocated through :py:obj:`~.cuMemAllocPitch()`

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH`: Maximum 1D
      texture width

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH`:
      Maximum width for a 1D texture bound to linear memory

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH`:
      Maximum mipmapped 1D texture width

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH`: Maximum 2D
      texture width

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT`: Maximum 2D
      texture height

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH`:
      Maximum width for a 2D texture bound to linear memory

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT`:
      Maximum height for a 2D texture bound to linear memory

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH`:
      Maximum pitch in bytes for a 2D texture bound to linear memory

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH`:
      Maximum mipmapped 2D texture width

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT`:
      Maximum mipmapped 2D texture height

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH`: Maximum 3D
      texture width

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT`: Maximum 3D
      texture height

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH`: Maximum 3D
      texture depth

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE`:
      Alternate maximum 3D texture width, 0 if no alternate maximum 3D
      texture size is supported

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE`:
      Alternate maximum 3D texture height, 0 if no alternate maximum 3D
      texture size is supported

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE`:
      Alternate maximum 3D texture depth, 0 if no alternate maximum 3D
      texture size is supported

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH`: Maximum
      cubemap texture width or height

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH`:
      Maximum 1D layered texture width

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS`:
      Maximum layers in a 1D layered texture

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH`:
      Maximum 2D layered texture width

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT`:
      Maximum 2D layered texture height

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS`:
      Maximum layers in a 2D layered texture

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH`:
      Maximum cubemap layered texture width or height

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS`:
      Maximum layers in a cubemap layered texture

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH`: Maximum 1D
      surface width

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH`: Maximum 2D
      surface width

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT`: Maximum 2D
      surface height

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH`: Maximum 3D
      surface width

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT`: Maximum 3D
      surface height

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH`: Maximum 3D
      surface depth

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH`:
      Maximum 1D layered surface width

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS`:
      Maximum layers in a 1D layered surface

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH`:
      Maximum 2D layered surface width

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT`:
      Maximum 2D layered surface height

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS`:
      Maximum layers in a 2D layered surface

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH`: Maximum
      cubemap surface width

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH`:
      Maximum cubemap layered surface width

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS`:
      Maximum layers in a cubemap layered surface

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK`: Maximum
      number of 32-bit registers available to a thread block

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_CLOCK_RATE`: The typical clock
      frequency in kilohertz

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT`: Alignment
      requirement; texture base addresses aligned to
      :py:obj:`~.textureAlign` bytes do not need an offset applied to
      texture fetches

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT`: Pitch
      alignment requirement for 2D texture references bound to pitched
      memory

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GPU_OVERLAP`: 1 if the device can
      concurrently copy memory between host and device while executing a
      kernel, or 0 if not

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT`: Number of
      multiprocessors on the device

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT`: 1 if there is a
      run time limit for kernels executed on the device, or 0 if not

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_INTEGRATED`: 1 if the device is
      integrated with the memory subsystem, or 0 if not

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY`: 1 if the device
      can map host memory into the CUDA address space, or 0 if not

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_COMPUTE_MODE`: Compute mode that
      device is currently in. Available modes are as follows:

      - :py:obj:`~.CU_COMPUTEMODE_DEFAULT`: Default mode - Device is not
        restricted and can have multiple CUDA contexts present at a single
        time.

      - :py:obj:`~.CU_COMPUTEMODE_PROHIBITED`: Compute-prohibited mode -
        Device is prohibited from creating new CUDA contexts.

      - :py:obj:`~.CU_COMPUTEMODE_EXCLUSIVE_PROCESS`: Compute-exclusive-
        process mode - Device can have only one context used by a single
        process at a time.

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS`: 1 if the device
      supports executing multiple kernels within the same context
      simultaneously, or 0 if not. It is not guaranteed that multiple
      kernels will be resident on the device concurrently so this feature
      should not be relied upon for correctness.

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_ECC_ENABLED`: 1 if error correction is
      enabled on the device, 0 if error correction is disabled or not
      supported by the device

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_PCI_BUS_ID`: PCI bus identifier of the
      device

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID`: PCI device (also known
      as slot) identifier of the device

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID`: PCI domain identifier
      of the device

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_TCC_DRIVER`: 1 if the device is using
      a TCC driver. TCC is only available on Tesla hardware running Windows
      Vista or later

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE`: Peak memory clock
      frequency in kilohertz

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH`: Global
      memory bus width in bits

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE`: Size of L2 cache in
      bytes. 0 if the device doesn't have L2 cache

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR`:
      Maximum resident threads per multiprocessor

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING`: 1 if the device
      shares a unified address space with the host, or 0 if not

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR`: Major
      compute capability version number

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR`: Minor
      compute capability version number

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED`: 1 if
      device supports caching globals in L1 cache, 0 if caching globals in
      L1 cache is not supported by the device

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED`: 1 if device
      supports caching locals in L1 cache, 0 if caching locals in L1 cache
      is not supported by the device

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR`:
      Maximum amount of shared memory available to a multiprocessor in
      bytes; this amount is shared by all thread blocks simultaneously
      resident on a multiprocessor

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR`:
      Maximum number of 32-bit registers available to a multiprocessor;
      this number is shared by all thread blocks simultaneously resident on
      a multiprocessor

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY`: 1 if device supports
      allocating managed memory on this system, 0 if allocating managed
      memory is not supported by the device on this system.

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD`: 1 if device is on a
      multi-GPU board, 0 if not.

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID`: Unique
      identifier for a group of devices associated with the same board.
      Devices on the same multi-GPU board will share the same identifier.

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED`: 1 if
      Link between the device and the host supports native atomic
      operations.

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO`:
      Ratio of single precision performance (in floating-point operations
      per second) to double precision performance.

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`: Device
      suppports coherently accessing pageable memory without calling
      cudaHostRegister on it.

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`: Device can
      coherently access managed memory concurrently with the CPU.

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED`: Device
      supports Compute Preemption.

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM`:
      Device can access host registered memory at the same virtual address
      as the CPU.

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN`:
      The maximum per block shared memory size suported on this device.
      This is the maximum value that can be opted into when using the
      :py:obj:`~.cuFuncSetAttribute()` call. For more details see
      :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES`

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`:
      Device accesses pageable memory via the host's page tables.

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST`:
      The host can directly access managed memory on the device without
      migration.

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED`:
      Device supports virtual memory management APIs like
      :py:obj:`~.cuMemAddressReserve`, :py:obj:`~.cuMemCreate`,
      :py:obj:`~.cuMemMap` and related APIs

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED`:
      Device supports exporting memory to a posix file descriptor with
      :py:obj:`~.cuMemExportToShareableHandle`, if requested via
      :py:obj:`~.cuMemCreate`

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED`:
      Device supports exporting memory to a Win32 NT handle with
      :py:obj:`~.cuMemExportToShareableHandle`, if requested via
      :py:obj:`~.cuMemCreate`

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED`:
      Device supports exporting memory to a Win32 KMT handle with
      :py:obj:`~.cuMemExportToShareableHandle`, if requested via
      :py:obj:`~.cuMemCreate`

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR`:
      Maximum number of thread blocks that can reside on a multiprocessor

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED`: Device
      supports compressible memory allocation via :py:obj:`~.cuMemCreate`

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE`: Maximum
      L2 persisting lines capacity setting in bytes

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE`:
      Maximum value of :py:obj:`~.CUaccessPolicyWindow.num_bytes`

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED`:
      Device supports specifying the GPUDirect RDMA flag with
      :py:obj:`~.cuMemCreate`.

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK`:
      Amount of shared memory per block reserved by CUDA driver in bytes

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED`: Device
      supports sparse CUDA arrays and sparse CUDA mipmapped arrays.

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED`:
      Device supports using the :py:obj:`~.cuMemHostRegister` flag
      :py:obj:`~.CU_MEMHOSTERGISTER_READ_ONLY` to register memory that must
      be mapped as read-only to the GPU

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED`: Device
      supports using the :py:obj:`~.cuMemAllocAsync` and
      :py:obj:`~.cuMemPool` family of APIs

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED`: Device
      supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see
      https://docs.nvidia.com/cuda/gpudirect-rdma for more information)

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS`:
      The returned attribute shall be interpreted as a bitmask, where the
      individual bits are described by the
      :py:obj:`~.CUflushGPUDirectRDMAWritesOptions` enum

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING`:
      GPUDirect RDMA writes to the device do not need to be flushed for
      consumers within the scope indicated by the returned attribute. See
      :py:obj:`~.CUGPUDirectRDMAWritesOrdering` for the numerical values
      returned here.

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES`:
      Bitmask of handle types supported with mempool based IPC

    - :py:obj:`~.CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED`:
      Device supports deferred mapping CUDA arrays and CUDA mipmapped
      arrays.

    Parameters
    ----------
    attrib : :py:obj:`~.CUdevice_attribute`
        Device attribute to query
    dev : :py:obj:`~.CUdevice`
        Device handle

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    pi : int
        Returned device attribute value

    See Also
    --------
    :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`, :py:obj:`~.cuDeviceGetExecAffinitySupport`, :py:obj:`~.cudaDeviceGetAttribute`, :py:obj:`~.cudaGetDeviceProperties`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    cdef int pi = 0
    cdef ccuda.CUdevice_attribute cattrib = attrib.value
    err = ccuda.cuDeviceGetAttribute(&pi, cattrib, cdev)
    return (CUresult(err), pi)

@cython.embedsignature(True)
def cuDeviceGetNvSciSyncAttributes(dev, int flags):
    """ Return NvSciSync attributes that this device can support.

    Returns in `nvSciSyncAttrList`, the properties of NvSciSync that this
    CUDA device, `dev` can support. The returned `nvSciSyncAttrList` can be
    used to create an NvSciSync object that matches this device's
    capabilities.

    If NvSciSyncAttrKey_RequiredPerm field in `nvSciSyncAttrList` is
    already set this API will return :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

    The applications should set `nvSciSyncAttrList` to a valid
    NvSciSyncAttrList failing which this API will return
    :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`.

    The `flags` controls how applications intends to use the NvSciSync
    created from the `nvSciSyncAttrList`. The valid flags are:

    - :py:obj:`~.CUDA_NVSCISYNC_ATTR_SIGNAL`, specifies that the
      applications intends to signal an NvSciSync on this CUDA device.

    - :py:obj:`~.CUDA_NVSCISYNC_ATTR_WAIT`, specifies that the applications
      intends to wait on an NvSciSync on this CUDA device.

    At least one of these flags must be set, failing which the API returns
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE`. Both the flags are orthogonal to
    one another: a developer may set both these flags that allows to set
    both wait and signal specific attributes in the same
    `nvSciSyncAttrList`.

    :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`,
    :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`,
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`,
    :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`,
    :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`,
    :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Valid Cuda Device to get NvSciSync attributes for.
    flags : int
        flags describing NvSciSync usage.

    Returns
    -------
    CUresult

    nvSciSyncAttrList : Any
        Return NvSciSync attributes supported.

    See Also
    --------
    :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuDestroyExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    cdef void_ptr nvSciSyncAttrList = 0
    cdef void* cnvSciSyncAttrList_ptr = <void*>nvSciSyncAttrList
    err = ccuda.cuDeviceGetNvSciSyncAttributes(cnvSciSyncAttrList_ptr, cdev, flags)
    return (CUresult(err), nvSciSyncAttrList)

@cython.embedsignature(True)
def cuDeviceSetMemPool(dev, pool):
    """ Sets the current memory pool of a device.

    The memory pool must be local to the specified device.
    :py:obj:`~.cuMemAllocAsync` allocates from the current mempool of the
    provided stream's device. By default, a device's current memory pool is
    its default memory pool.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        None
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        None

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuMemPoolDestroy`, :py:obj:`~.cuMemAllocFromPoolAsync`

    Notes
    -----
    Use :py:obj:`~.cuMemAllocFromPoolAsync` to specify asynchronous allocations from a device different than the one the stream runs on.
    """
    cdef ccuda.CUmemoryPool cpool
    if pool is None:
        cpool = <ccuda.CUmemoryPool><void_ptr>0
    elif isinstance(pool, (CUmemoryPool)):
        ppool = int(pool)
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool
    else:
        ppool = int(CUmemoryPool(pool))
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool

    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    err = ccuda.cuDeviceSetMemPool(cdev, cpool)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuDeviceGetMemPool(dev):
    """ Gets the current mempool for a device.

    Returns the last pool provided to :py:obj:`~.cuDeviceSetMemPool` for
    this device or the device's default memory pool if
    :py:obj:`~.cuDeviceSetMemPool` has never been called. By default the
    current mempool is the default mempool for a device. Otherwise the
    returned pool must have been set with :py:obj:`~.cuDeviceSetMemPool`.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        None

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pool : :py:obj:`~.CUmemoryPool`
        None

    See Also
    --------
    :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuDeviceSetMemPool`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    cdef CUmemoryPool pool = CUmemoryPool()
    err = ccuda.cuDeviceGetMemPool(pool._ptr, cdev)
    return (CUresult(err), pool)

@cython.embedsignature(True)
def cuDeviceGetDefaultMemPool(dev):
    """ Returns the default mempool of a device.

    The default mempool of a device contains device memory from that
    device.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        None

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED` :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    pool_out : :py:obj:`~.CUmemoryPool`
        None

    See Also
    --------
    :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemPoolTrimTo`, :py:obj:`~.cuMemPoolGetAttribute`, :py:obj:`~.cuMemPoolSetAttribute`, :py:obj:`~.cuMemPoolSetAccess`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    cdef CUmemoryPool pool_out = CUmemoryPool()
    err = ccuda.cuDeviceGetDefaultMemPool(pool_out._ptr, cdev)
    return (CUresult(err), pool_out)

@cython.embedsignature(True)
def cuFlushGPUDirectRDMAWrites(target not None : CUflushGPUDirectRDMAWritesTarget, scope not None : CUflushGPUDirectRDMAWritesScope):
    """ Blocks until remote writes are visible to the specified scope.

    Blocks until GPUDirect RDMA writes to the target context via mappings
    created through APIs like nvidia_p2p_get_pages (see
    https://docs.nvidia.com/cuda/gpudirect-rdma for more information), are
    visible to the specified scope.

    If the scope equals or lies within the scope indicated by
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING`, the
    call will be a no-op and can be safely omitted for performance. This
    can be determined by comparing the numerical values between the two
    enums, with smaller scopes having smaller values.

    Users may query support for this API via
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_FLUSH_FLUSH_GPU_DIRECT_RDMA_OPTIONS`.

    Parameters
    ----------
    target : :py:obj:`~.CUflushGPUDirectRDMAWritesTarget`
        The target of the operation, see
        :py:obj:`~.CUflushGPUDirectRDMAWritesTarget`
    scope : :py:obj:`~.CUflushGPUDirectRDMAWritesScope`
        The scope of the operation, see
        :py:obj:`~.CUflushGPUDirectRDMAWritesScope`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    """
    cdef ccuda.CUflushGPUDirectRDMAWritesTarget ctarget = target.value
    cdef ccuda.CUflushGPUDirectRDMAWritesScope cscope = scope.value
    err = ccuda.cuFlushGPUDirectRDMAWrites(ctarget, cscope)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuDeviceGetProperties(dev):
    """ Returns properties for a selected device.

    [Deprecated]

    This function was deprecated as of CUDA 5.0 and replaced by
    :py:obj:`~.cuDeviceGetAttribute()`.

    Returns in `*prop` the properties of device `dev`. The
    :py:obj:`~.CUdevprop` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.maxThreadsPerBlock` is the maximum number of threads per
      block;

    - :py:obj:`~.maxThreadsDim`[3] is the maximum sizes of each dimension
      of a block;

    - :py:obj:`~.maxGridSize`[3] is the maximum sizes of each dimension of
      a grid;

    - :py:obj:`~.sharedMemPerBlock` is the total amount of shared memory
      available per block in bytes;

    - :py:obj:`~.totalConstantMemory` is the total amount of constant
      memory available on the device in bytes;

    - :py:obj:`~.SIMDWidth` is the warp size;

    - :py:obj:`~.memPitch` is the maximum pitch allowed by the memory copy
      functions that involve memory regions allocated through
      :py:obj:`~.cuMemAllocPitch()`;

    - :py:obj:`~.regsPerBlock` is the total number of registers available
      per block;

    - :py:obj:`~.clockRate` is the clock frequency in kilohertz;

    - :py:obj:`~.textureAlign` is the alignment requirement; texture base
      addresses that are aligned to :py:obj:`~.textureAlign` bytes do not
      need an offset applied to texture fetches.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device to get properties for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    prop : :py:obj:`~.CUdevprop`
        Returned properties of device

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    cdef CUdevprop prop = CUdevprop()
    err = ccuda.cuDeviceGetProperties(prop._ptr, cdev)
    return (CUresult(err), prop)

@cython.embedsignature(True)
def cuDeviceComputeCapability(dev):
    """ Returns the compute capability of the device.

    [Deprecated]

    This function was deprecated as of CUDA 5.0 and its functionality
    superceded by :py:obj:`~.cuDeviceGetAttribute()`.

    Returns in `*major` and `*minor` the major and minor revision numbers
    that define the compute capability of the device `dev`.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device handle

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    major : int
        Major revision number
    minor : int
        Minor revision number

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    cdef int major = 0
    cdef int minor = 0
    err = ccuda.cuDeviceComputeCapability(&major, &minor, cdev)
    return (CUresult(err), major, minor)

@cython.embedsignature(True)
def cuDevicePrimaryCtxRetain(dev):
    """ Retain the primary context on the GPU.

    Retains the primary context on the device. Once the user successfully
    retains the primary context, the primary context will be active and
    available to the user until the user releases it with
    :py:obj:`~.cuDevicePrimaryCtxRelease()` or resets it with
    :py:obj:`~.cuDevicePrimaryCtxReset()`. Unlike :py:obj:`~.cuCtxCreate()`
    the newly retained context is not pushed onto the stack.

    Retaining the primary context for the first time will fail with
    :py:obj:`~.CUDA_ERROR_UNKNOWN` if the compute mode of the device is
    :py:obj:`~.CU_COMPUTEMODE_PROHIBITED`. The function
    :py:obj:`~.cuDeviceGetAttribute()` can be used with
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_COMPUTE_MODE` to determine the compute
    mode of the device. The `nvidia-smi` tool can be used to set the
    compute mode for devices. Documentation for `nvidia-smi` can be
    obtained by passing a -h option to it.

    Please note that the primary context always supports pinned
    allocations. Other flags can be specified by
    :py:obj:`~.cuDevicePrimaryCtxSetFlags()`.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device for which primary context is requested

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    pctx : :py:obj:`~.CUcontext`
        Returned context handle of the new context

    See Also
    --------
    :py:obj:`~.cuDevicePrimaryCtxRelease`, :py:obj:`~.cuDevicePrimaryCtxSetFlags`, :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    cdef CUcontext pctx = CUcontext()
    err = ccuda.cuDevicePrimaryCtxRetain(pctx._ptr, cdev)
    return (CUresult(err), pctx)

@cython.embedsignature(True)
def cuDevicePrimaryCtxRelease(dev):
    """ Release the primary context on the GPU.

    Releases the primary context interop on the device. A retained context
    should always be released once the user is done using it. The context
    is automatically reset once the last reference to it is released. This
    behavior is different when the primary context was retained by the CUDA
    runtime from CUDA 4.0 and earlier. In this case, the primary context
    remains always active.

    Releasing a primary context that has not been previously retained will
    fail with :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`.

    Please note that unlike :py:obj:`~.cuCtxDestroy()` this method does not
    pop the context from stack in any circumstances.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device which primary context is released

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuDevicePrimaryCtxRetain`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    err = ccuda.cuDevicePrimaryCtxRelease(cdev)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuDevicePrimaryCtxSetFlags(dev, unsigned int flags):
    """ Set flags for the primary context.

    Sets the flags for the primary context on the device overwriting
    perviously set ones.

    The three LSBs of the `flags` parameter can be used to control how the
    OS thread, which owns the CUDA context at the time of an API call,
    interacts with the OS scheduler when waiting for results from the GPU.
    Only one of the scheduling flags can be set when creating a context.

    - :py:obj:`~.CU_CTX_SCHED_SPIN`: Instruct CUDA to actively spin when
      waiting for results from the GPU. This can decrease latency when
      waiting for the GPU, but may lower the performance of CPU threads if
      they are performing work in parallel with the CUDA thread.

    - :py:obj:`~.CU_CTX_SCHED_YIELD`: Instruct CUDA to yield its thread
      when waiting for results from the GPU. This can increase latency when
      waiting for the GPU, but can increase the performance of CPU threads
      performing work in parallel with the GPU.

    - :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`: Instruct CUDA to block the
      CPU thread on a synchronization primitive when waiting for the GPU to
      finish work.

    - :py:obj:`~.CU_CTX_BLOCKING_SYNC`: Instruct CUDA to block the CPU
      thread on a synchronization primitive when waiting for the GPU to
      finish work.   Deprecated: This flag was deprecated as of CUDA 4.0
      and was replaced with :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`.

    - :py:obj:`~.CU_CTX_SCHED_AUTO`: The default value if the `flags`
      parameter is zero, uses a heuristic based on the number of active
      CUDA contexts in the process `C` and the number of logical processors
      in the system `P`. If `C` > `P`, then CUDA will yield to other OS
      threads when waiting for the GPU (:py:obj:`~.CU_CTX_SCHED_YIELD`),
      otherwise CUDA will not yield while waiting for results and actively
      spin on the processor (:py:obj:`~.CU_CTX_SCHED_SPIN`). Additionally,
      on Tegra devices, :py:obj:`~.CU_CTX_SCHED_AUTO` uses a heuristic
      based on the power profile of the platform and may choose
      :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC` for low-powered devices.

    - :py:obj:`~.CU_CTX_LMEM_RESIZE_TO_MAX`: Instruct CUDA to not reduce
      local memory after resizing local memory for a kernel. This can
      prevent thrashing by local memory allocations when launching many
      kernels with high local memory usage at the cost of potentially
      increased memory usage.   Deprecated: This flag is deprecated and the
      behavior enabled by this flag is now the default and cannot be
      disabled.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device for which the primary context flags are set
    flags : unsigned int
        New flags for the device

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuDevicePrimaryCtxRetain`, :py:obj:`~.cuDevicePrimaryCtxGetState`, :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cudaSetDeviceFlags`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    err = ccuda.cuDevicePrimaryCtxSetFlags(cdev, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuDevicePrimaryCtxGetState(dev):
    """ Get the state of the primary context.

    Returns in `*flags` the flags for the primary context of `dev`, and in
    `*active` whether it is active. See
    :py:obj:`~.cuDevicePrimaryCtxSetFlags` for flag values.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device to get primary context flags for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    flags : unsigned int
        Pointer to store flags
    active : int
        Pointer to store context state; 0 = inactive, 1 = active

    See Also
    --------
    :py:obj:`~.cuDevicePrimaryCtxSetFlags`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cudaGetDeviceFlags`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    cdef unsigned int flags = 0
    cdef int active = 0
    err = ccuda.cuDevicePrimaryCtxGetState(cdev, &flags, &active)
    return (CUresult(err), flags, active)

@cython.embedsignature(True)
def cuDevicePrimaryCtxReset(dev):
    """ Destroy all allocations and reset all state on the primary context.

    Explicitly destroys and cleans up all resources associated with the
    current device in the current process.

    Note that it is responsibility of the calling function to ensure that
    no other module in the process is using the device any more. For that
    reason it is recommended to use :py:obj:`~.cuDevicePrimaryCtxRelease()`
    in most cases. However it is safe for other modules to call
    :py:obj:`~.cuDevicePrimaryCtxRelease()` even after resetting the
    device. Resetting the primary context does not release it, an
    application that has retained the primary context should explicitly
    release its usage.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device for which primary context is destroyed

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE`

    See Also
    --------
    :py:obj:`~.cuDevicePrimaryCtxRetain`, :py:obj:`~.cuDevicePrimaryCtxRelease`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cudaDeviceReset`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    err = ccuda.cuDevicePrimaryCtxReset(cdev)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuDeviceGetExecAffinitySupport(typename not None : CUexecAffinityType, dev):
    """ Returns information about the execution affinity support of the device.

    Returns in `*pi` whether execution affinity type `typename` is
    supported by device `dev`. The supported types are:

    - :py:obj:`~.CU_EXEC_AFFINITY_TYPE_SM_COUNT`: 1 if context with limited
      SMs is supported by the device, or 0 if not;

    Parameters
    ----------
    typename : :py:obj:`~.CUexecAffinityType`
        Execution affinity type to query
    dev : :py:obj:`~.CUdevice`
        Device handle

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    pi : int
        1 if the execution affinity type `typename` is supported by the
        device, or 0 if not

    See Also
    --------
    :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetCount`, :py:obj:`~.cuDeviceGetName`, :py:obj:`~.cuDeviceGetUuid`, :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceTotalMem`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    cdef int pi = 0
    cdef ccuda.CUexecAffinityType ctypename = typename.value
    err = ccuda.cuDeviceGetExecAffinitySupport(&pi, ctypename, cdev)
    return (CUresult(err), pi)

@cython.embedsignature(True)
def cuCtxCreate(unsigned int flags, dev):
    """ Create a CUDA context.

    Creates a new CUDA context and associates it with the calling thread.
    The `flags` parameter is described below. The context is created with a
    usage count of 1 and the caller of :py:obj:`~.cuCtxCreate()` must call
    :py:obj:`~.cuCtxDestroy()` or when done using the context. If a context
    is already current to the thread, it is supplanted by the newly created
    context and may be restored by a subsequent call to
    :py:obj:`~.cuCtxPopCurrent()`.

    The three LSBs of the `flags` parameter can be used to control how the
    OS thread, which owns the CUDA context at the time of an API call,
    interacts with the OS scheduler when waiting for results from the GPU.
    Only one of the scheduling flags can be set when creating a context.

    - :py:obj:`~.CU_CTX_SCHED_SPIN`: Instruct CUDA to actively spin when
      waiting for results from the GPU. This can decrease latency when
      waiting for the GPU, but may lower the performance of CPU threads if
      they are performing work in parallel with the CUDA thread.

    - :py:obj:`~.CU_CTX_SCHED_YIELD`: Instruct CUDA to yield its thread
      when waiting for results from the GPU. This can increase latency when
      waiting for the GPU, but can increase the performance of CPU threads
      performing work in parallel with the GPU.

    - :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`: Instruct CUDA to block the
      CPU thread on a synchronization primitive when waiting for the GPU to
      finish work.

    - :py:obj:`~.CU_CTX_BLOCKING_SYNC`: Instruct CUDA to block the CPU
      thread on a synchronization primitive when waiting for the GPU to
      finish work.   Deprecated: This flag was deprecated as of CUDA 4.0
      and was replaced with :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`.

    - :py:obj:`~.CU_CTX_SCHED_AUTO`: The default value if the `flags`
      parameter is zero, uses a heuristic based on the number of active
      CUDA contexts in the process `C` and the number of logical processors
      in the system `P`. If `C` > `P`, then CUDA will yield to other OS
      threads when waiting for the GPU (:py:obj:`~.CU_CTX_SCHED_YIELD`),
      otherwise CUDA will not yield while waiting for results and actively
      spin on the processor (:py:obj:`~.CU_CTX_SCHED_SPIN`). Additionally,
      on Tegra devices, :py:obj:`~.CU_CTX_SCHED_AUTO` uses a heuristic
      based on the power profile of the platform and may choose
      :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC` for low-powered devices.

    - :py:obj:`~.CU_CTX_MAP_HOST`: Instruct CUDA to support mapped pinned
      allocations. This flag must be set in order to allocate pinned host
      memory that is accessible to the GPU.

    - :py:obj:`~.CU_CTX_LMEM_RESIZE_TO_MAX`: Instruct CUDA to not reduce
      local memory after resizing local memory for a kernel. This can
      prevent thrashing by local memory allocations when launching many
      kernels with high local memory usage at the cost of potentially
      increased memory usage.   Deprecated: This flag is deprecated and the
      behavior enabled by this flag is now the default and cannot be
      disabled. Instead, the per-thread stack size can be controlled with
      :py:obj:`~.cuCtxSetLimit()`.

    Context creation will fail with :py:obj:`~.CUDA_ERROR_UNKNOWN` if the
    compute mode of the device is :py:obj:`~.CU_COMPUTEMODE_PROHIBITED`.
    The function :py:obj:`~.cuDeviceGetAttribute()` can be used with
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_COMPUTE_MODE` to determine the compute
    mode of the device. The `nvidia-smi` tool can be used to set the
    compute mode for * devices. Documentation for `nvidia-smi` can be
    obtained by passing a -h option to it.

    Parameters
    ----------
    flags : unsigned int
        Context creation flags
    dev : :py:obj:`~.CUdevice`
        Device to create context on

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    pctx : :py:obj:`~.CUcontext`
        Returned context handle of the new context

    See Also
    --------
    :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`

    Notes
    -----
    In most cases it is recommended to use :py:obj:`~.cuDevicePrimaryCtxRetain`.
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    cdef CUcontext pctx = CUcontext()
    err = ccuda.cuCtxCreate(pctx._ptr, flags, cdev)
    return (CUresult(err), pctx)

@cython.embedsignature(True)
def cuCtxCreate_v3(paramsArray : List[CUexecAffinityParam], int numParams, unsigned int flags, dev):
    """ Create a CUDA context with execution affinity.

    Creates a new CUDA context with execution affinity and associates it
    with the calling thread. The `paramsArray` and `flags` parameter are
    described below. The context is created with a usage count of 1 and the
    caller of :py:obj:`~.cuCtxCreate()` must call
    :py:obj:`~.cuCtxDestroy()` or when done using the context. If a context
    is already current to the thread, it is supplanted by the newly created
    context and may be restored by a subsequent call to
    :py:obj:`~.cuCtxPopCurrent()`.

    The type and the amount of execution resource the context can use is
    limited by `paramsArray` and `numParams`. The `paramsArray` is an array
    of `CUexecAffinityParam` and the `numParams` describes the size of the
    array. If two `CUexecAffinityParam` in the array have the same type,
    the latter execution affinity parameter overrides the former execution
    affinity parameter. The supported execution affinity types are:

    - :py:obj:`~.CU_EXEC_AFFINITY_TYPE_SM_COUNT` limits the portion of SMs
      that the context can use. The portion of SMs is specified as the
      number of SMs via `CUexecAffinitySmCount`. This limit will be
      internally rounded up to the next hardware-supported amount. Hence,
      it is imperative to query the actual execution affinity of the
      context via `cuCtxGetExecAffinity` after context creation. Currently,
      this attribute is only supported under Volta+ MPS.

    The three LSBs of the `flags` parameter can be used to control how the
    OS thread, which owns the CUDA context at the time of an API call,
    interacts with the OS scheduler when waiting for results from the GPU.
    Only one of the scheduling flags can be set when creating a context.

    - :py:obj:`~.CU_CTX_SCHED_SPIN`: Instruct CUDA to actively spin when
      waiting for results from the GPU. This can decrease latency when
      waiting for the GPU, but may lower the performance of CPU threads if
      they are performing work in parallel with the CUDA thread.

    - :py:obj:`~.CU_CTX_SCHED_YIELD`: Instruct CUDA to yield its thread
      when waiting for results from the GPU. This can increase latency when
      waiting for the GPU, but can increase the performance of CPU threads
      performing work in parallel with the GPU.

    - :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`: Instruct CUDA to block the
      CPU thread on a synchronization primitive when waiting for the GPU to
      finish work.

    - :py:obj:`~.CU_CTX_BLOCKING_SYNC`: Instruct CUDA to block the CPU
      thread on a synchronization primitive when waiting for the GPU to
      finish work.   Deprecated: This flag was deprecated as of CUDA 4.0
      and was replaced with :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC`.

    - :py:obj:`~.CU_CTX_SCHED_AUTO`: The default value if the `flags`
      parameter is zero, uses a heuristic based on the number of active
      CUDA contexts in the process `C` and the number of logical processors
      in the system `P`. If `C` > `P`, then CUDA will yield to other OS
      threads when waiting for the GPU (:py:obj:`~.CU_CTX_SCHED_YIELD`),
      otherwise CUDA will not yield while waiting for results and actively
      spin on the processor (:py:obj:`~.CU_CTX_SCHED_SPIN`). Additionally,
      on Tegra devices, :py:obj:`~.CU_CTX_SCHED_AUTO` uses a heuristic
      based on the power profile of the platform and may choose
      :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC` for low-powered devices.

    - :py:obj:`~.CU_CTX_MAP_HOST`: Instruct CUDA to support mapped pinned
      allocations. This flag must be set in order to allocate pinned host
      memory that is accessible to the GPU.

    - :py:obj:`~.CU_CTX_LMEM_RESIZE_TO_MAX`: Instruct CUDA to not reduce
      local memory after resizing local memory for a kernel. This can
      prevent thrashing by local memory allocations when launching many
      kernels with high local memory usage at the cost of potentially
      increased memory usage.   Deprecated: This flag is deprecated and the
      behavior enabled by this flag is now the default and cannot be
      disabled. Instead, the per-thread stack size can be controlled with
      :py:obj:`~.cuCtxSetLimit()`.

    Context creation will fail with :py:obj:`~.CUDA_ERROR_UNKNOWN` if the
    compute mode of the device is :py:obj:`~.CU_COMPUTEMODE_PROHIBITED`.
    The function :py:obj:`~.cuDeviceGetAttribute()` can be used with
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_COMPUTE_MODE` to determine the compute
    mode of the device. The `nvidia-smi` tool can be used to set the
    compute mode for * devices. Documentation for `nvidia-smi` can be
    obtained by passing a -h option to it.

    Parameters
    ----------
    paramsArray : List[:py:obj:`~.CUexecAffinityParam`]
        Execution affinity parameters
    numParams : int
        Number of execution affinity parameters
    flags : unsigned int
        Context creation flags
    dev : :py:obj:`~.CUdevice`
        Device to create context on

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    pctx : :py:obj:`~.CUcontext`
        Returned context handle of the new context

    See Also
    --------
    :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.CUexecAffinityParam`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    paramsArray = [] if paramsArray is None else paramsArray
    if not all(isinstance(_x, (CUexecAffinityParam)) for _x in paramsArray):
        raise TypeError("Argument 'paramsArray' is not instance of type (expected List[ccuda.CUexecAffinityParam]")

    cdef CUcontext pctx = CUcontext()
    cdef ccuda.CUexecAffinityParam* cparamsArray = NULL
    if len(paramsArray) > 0:
        cparamsArray = <ccuda.CUexecAffinityParam*> calloc(len(paramsArray), sizeof(ccuda.CUexecAffinityParam))
        if cparamsArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(paramsArray)) + 'x' + str(sizeof(ccuda.CUexecAffinityParam)))
        for idx in range(len(paramsArray)):
            memcpy(&cparamsArray[idx], (<CUexecAffinityParam>paramsArray[idx])._ptr, sizeof(ccuda.CUexecAffinityParam))

    err = ccuda.cuCtxCreate_v3(pctx._ptr, (<CUexecAffinityParam>paramsArray[0])._ptr if len(paramsArray) == 1 else cparamsArray, numParams, flags, cdev)
    if cparamsArray is not NULL:
        free(cparamsArray)
    return (CUresult(err), pctx)

@cython.embedsignature(True)
def cuCtxDestroy(ctx):
    """ Destroy a CUDA context.

    Destroys the CUDA context specified by `ctx`. The context `ctx` will be
    destroyed regardless of how many threads it is current to. It is the
    responsibility of the calling function to ensure that no API call
    issues using `ctx` while :py:obj:`~.cuCtxDestroy()` is executing.

    Destroys and cleans up all resources associated with the context. It is
    the caller's responsibility to ensure that the context or its resources
    are not accessed or passed in subsequent API calls and doing so will
    result in undefined behavior. These resources include CUDA types such
    as :py:obj:`~.CUmodule`, :py:obj:`~.CUfunction`, :py:obj:`~.CUstream`,
    :py:obj:`~.CUevent`, :py:obj:`~.CUarray`, :py:obj:`~.CUmipmappedArray`,
    :py:obj:`~.CUtexObject`, :py:obj:`~.CUsurfObject`,
    :py:obj:`~.CUtexref`, :py:obj:`~.CUsurfref`,
    :py:obj:`~.CUgraphicsResource`, :py:obj:`~.CUlinkState`,
    :py:obj:`~.CUexternalMemory` and :py:obj:`~.CUexternalSemaphore`.

    If `ctx` is current to the calling thread then `ctx` will also be
    popped from the current thread's context stack (as though
    :py:obj:`~.cuCtxPopCurrent()` were called). If `ctx` is current to
    other threads, then `ctx` will remain current to those threads, and
    attempting to access `ctx` from those threads will result in the error
    :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`.

    Parameters
    ----------
    ctx : :py:obj:`~.CUcontext`
        Context to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """
    cdef ccuda.CUcontext cctx
    if ctx is None:
        cctx = <ccuda.CUcontext><void_ptr>0
    elif isinstance(ctx, (CUcontext)):
        pctx = int(ctx)
        cctx = <ccuda.CUcontext><void_ptr>pctx
    else:
        pctx = int(CUcontext(ctx))
        cctx = <ccuda.CUcontext><void_ptr>pctx

    err = ccuda.cuCtxDestroy(cctx)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxPushCurrent(ctx):
    """ Pushes a context on the current CPU thread.

    Pushes the given context `ctx` onto the CPU thread's stack of current
    contexts. The specified context becomes the CPU thread's current
    context, so all CUDA functions that operate on the current context are
    affected.

    The previous current context may be made current again by calling
    :py:obj:`~.cuCtxDestroy()` or :py:obj:`~.cuCtxPopCurrent()`.

    Parameters
    ----------
    ctx : :py:obj:`~.CUcontext`
        Context to push

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """
    cdef ccuda.CUcontext cctx
    if ctx is None:
        cctx = <ccuda.CUcontext><void_ptr>0
    elif isinstance(ctx, (CUcontext)):
        pctx = int(ctx)
        cctx = <ccuda.CUcontext><void_ptr>pctx
    else:
        pctx = int(CUcontext(ctx))
        cctx = <ccuda.CUcontext><void_ptr>pctx

    err = ccuda.cuCtxPushCurrent(cctx)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxPopCurrent():
    """ Pops the current CUDA context from the current CPU thread.

    Pops the current CUDA context from the CPU thread and passes back the
    old context handle in `*pctx`. That context may then be made current to
    a different CPU thread by calling :py:obj:`~.cuCtxPushCurrent()`.

    If a context was current to the CPU thread before
    :py:obj:`~.cuCtxCreate()` or :py:obj:`~.cuCtxPushCurrent()` was called,
    this function makes that context current to the CPU thread again.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`
    pctx : :py:obj:`~.CUcontext`
        Returned popped context handle

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """
    cdef CUcontext pctx = CUcontext()
    err = ccuda.cuCtxPopCurrent(pctx._ptr)
    return (CUresult(err), pctx)

@cython.embedsignature(True)
def cuCtxSetCurrent(ctx):
    """ Binds the specified CUDA context to the calling CPU thread.

    Binds the specified CUDA context to the calling CPU thread. If `ctx` is
    NULL then the CUDA context previously bound to the calling CPU thread
    is unbound and :py:obj:`~.CUDA_SUCCESS` is returned.

    If there exists a CUDA context stack on the calling CPU thread, this
    will replace the top of that stack with `ctx`. If `ctx` is NULL then
    this will be equivalent to popping the top of the calling CPU thread's
    CUDA context stack (or a no-op if the calling CPU thread's CUDA context
    stack is empty).

    Parameters
    ----------
    ctx : :py:obj:`~.CUcontext`
        Context to bind to the calling CPU thread

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuCtxGetCurrent`, :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cudaSetDevice`
    """
    cdef ccuda.CUcontext cctx
    if ctx is None:
        cctx = <ccuda.CUcontext><void_ptr>0
    elif isinstance(ctx, (CUcontext)):
        pctx = int(ctx)
        cctx = <ccuda.CUcontext><void_ptr>pctx
    else:
        pctx = int(CUcontext(ctx))
        cctx = <ccuda.CUcontext><void_ptr>pctx

    err = ccuda.cuCtxSetCurrent(cctx)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxGetCurrent():
    """ Returns the CUDA context bound to the calling CPU thread.

    Returns in `*pctx` the CUDA context bound to the calling CPU thread. If
    no context is bound to the calling CPU thread then `*pctx` is set to
    NULL and :py:obj:`~.CUDA_SUCCESS` is returned.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`,
    pctx : :py:obj:`~.CUcontext`
        Returned context handle

    See Also
    --------
    :py:obj:`~.cuCtxSetCurrent`, :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cudaGetDevice`
    """
    cdef CUcontext pctx = CUcontext()
    err = ccuda.cuCtxGetCurrent(pctx._ptr)
    return (CUresult(err), pctx)

@cython.embedsignature(True)
def cuCtxGetDevice():
    """ Returns the device ID for the current context.

    Returns in `*device` the ordinal of the current context's device.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    device : :py:obj:`~.CUdevice`
        Returned device ID for the current context

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cudaGetDevice`
    """
    cdef CUdevice device = CUdevice()
    err = ccuda.cuCtxGetDevice(device._ptr)
    return (CUresult(err), device)

@cython.embedsignature(True)
def cuCtxGetFlags():
    """ Returns the flags for the current context.

    Returns in `*flags` the flags of the current context. See
    :py:obj:`~.cuCtxCreate` for flag values.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    flags : unsigned int
        Pointer to store flags of current context

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetCurrent`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxGetSharedMemConfig`, :py:obj:`~.cuCtxGetStreamPriorityRange`, :py:obj:`~.cudaGetDeviceFlags`
    """
    cdef unsigned int flags = 0
    err = ccuda.cuCtxGetFlags(&flags)
    return (CUresult(err), flags)

@cython.embedsignature(True)
def cuCtxSynchronize():
    """ Block for a context's tasks to complete.

    Blocks until the device has completed all preceding requested tasks.
    :py:obj:`~.cuCtxSynchronize()` returns an error if one of the preceding
    tasks failed. If the context was created with the
    :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC` flag, the CPU thread will block
    until the GPU context has finished its work.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cudaDeviceSynchronize`
    """
    err = ccuda.cuCtxSynchronize()
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxSetLimit(limit not None : CUlimit, size_t value):
    """ Set resource limits.

    Setting `limit` to `value` is a request by the application to update
    the current limit maintained by the context. The driver is free to
    modify the requested value to meet h/w requirements (this could be
    clamping to minimum or maximum values, rounding up to nearest element
    size, etc). The application can use :py:obj:`~.cuCtxGetLimit()` to find
    out exactly what the limit has been set to.

    Setting each :py:obj:`~.CUlimit` has its own specific restrictions, so
    each is discussed here.

    - :py:obj:`~.CU_LIMIT_STACK_SIZE` controls the stack size in bytes of
      each GPU thread. The driver automatically increases the per-thread
      stack size for each kernel launch as needed. This size isn't reset
      back to the original value after each launch. Setting this value will
      take effect immediately, and if necessary, the device will block
      until all preceding requested tasks are complete.

    - :py:obj:`~.CU_LIMIT_PRINTF_FIFO_SIZE` controls the size in bytes of
      the FIFO used by the :py:obj:`~.printf()` device system call. Setting
      :py:obj:`~.CU_LIMIT_PRINTF_FIFO_SIZE` must be performed before
      launching any kernel that uses the :py:obj:`~.printf()` device system
      call, otherwise :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be
      returned.

    - :py:obj:`~.CU_LIMIT_MALLOC_HEAP_SIZE` controls the size in bytes of
      the heap used by the :py:obj:`~.malloc()` and :py:obj:`~.free()`
      device system calls. Setting :py:obj:`~.CU_LIMIT_MALLOC_HEAP_SIZE`
      must be performed before launching any kernel that uses the
      :py:obj:`~.malloc()` or :py:obj:`~.free()` device system calls,
      otherwise :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned.

    - :py:obj:`~.CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH` controls the maximum
      nesting depth of a grid at which a thread can safely call
      :py:obj:`~.cudaDeviceSynchronize()`. Setting this limit must be
      performed before any launch of a kernel that uses the device runtime
      and calls :py:obj:`~.cudaDeviceSynchronize()` above the default sync
      depth, two levels of grids. Calls to
      :py:obj:`~.cudaDeviceSynchronize()` will fail with error code
      :py:obj:`~.cudaErrorSyncDepthExceeded` if the limitation is violated.
      This limit can be set smaller than the default or up the maximum
      launch depth of 24. When setting this limit, keep in mind that
      additional levels of sync depth require the driver to reserve large
      amounts of device memory which can no longer be used for user
      allocations. If these reservations of device memory fail,
      :py:obj:`~.cuCtxSetLimit()` will return
      :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, and the limit can be reset to a
      lower value. This limit is only applicable to devices of compute
      capability 3.5 and higher. Attempting to set this limit on devices of
      compute capability less than 3.5 will result in the error
      :py:obj:`~.CUDA_ERROR_UNSUPPORTED_LIMIT` being returned.

    - :py:obj:`~.CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT` controls the
      maximum number of outstanding device runtime launches that can be
      made from the current context. A grid is outstanding from the point
      of launch up until the grid is known to have been completed. Device
      runtime launches which violate this limitation fail and return
      :py:obj:`~.cudaErrorLaunchPendingCountExceeded` when
      :py:obj:`~.cudaGetLastError()` is called after launch. If more
      pending launches than the default (2048 launches) are needed for a
      module using the device runtime, this limit can be increased. Keep in
      mind that being able to sustain additional pending launches will
      require the driver to reserve larger amounts of device memory upfront
      which can no longer be used for allocations. If these reservations
      fail, :py:obj:`~.cuCtxSetLimit()` will return
      :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, and the limit can be reset to a
      lower value. This limit is only applicable to devices of compute
      capability 3.5 and higher. Attempting to set this limit on devices of
      compute capability less than 3.5 will result in the error
      :py:obj:`~.CUDA_ERROR_UNSUPPORTED_LIMIT` being returned.

    - :py:obj:`~.CU_LIMIT_MAX_L2_FETCH_GRANULARITY` controls the L2 cache
      fetch granularity. Values can range from 0B to 128B. This is purely a
      performence hint and it can be ignored or clamped depending on the
      platform.

    - :py:obj:`~.CU_LIMIT_PERSISTING_L2_CACHE_SIZE` controls size in bytes
      availabe for persisting L2 cache. This is purely a performance hint
      and it can be ignored or clamped depending on the platform.

    Parameters
    ----------
    limit : :py:obj:`~.CUlimit`
        Limit to set
    value : size_t
        Size of limit

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_LIMIT`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cudaDeviceSetLimit`
    """
    cdef ccuda.CUlimit climit = limit.value
    err = ccuda.cuCtxSetLimit(climit, value)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxGetLimit(limit not None : CUlimit):
    """ Returns resource limits.

    Returns in `*pvalue` the current size of `limit`. The supported
    :py:obj:`~.CUlimit` values are:

    - :py:obj:`~.CU_LIMIT_STACK_SIZE`: stack size in bytes of each GPU
      thread.

    - :py:obj:`~.CU_LIMIT_PRINTF_FIFO_SIZE`: size in bytes of the FIFO used
      by the :py:obj:`~.printf()` device system call.

    - :py:obj:`~.CU_LIMIT_MALLOC_HEAP_SIZE`: size in bytes of the heap used
      by the :py:obj:`~.malloc()` and :py:obj:`~.free()` device system
      calls.

    - :py:obj:`~.CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH`: maximum grid depth at
      which a thread can issue the device runtime call
      :py:obj:`~.cudaDeviceSynchronize()` to wait on child grid launches to
      complete.

    - :py:obj:`~.CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT`: maximum number
      of outstanding device runtime launches that can be made from this
      context.

    - :py:obj:`~.CU_LIMIT_MAX_L2_FETCH_GRANULARITY`: L2 cache fetch
      granularity.

    - :py:obj:`~.CU_LIMIT_PERSISTING_L2_CACHE_SIZE`: Persisting L2 cache
      size in bytes

    Parameters
    ----------
    limit : :py:obj:`~.CUlimit`
        Limit to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_LIMIT`
    pvalue : int
        Returned size of limit

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cudaDeviceGetLimit`
    """
    cdef size_t pvalue = 0
    cdef ccuda.CUlimit climit = limit.value
    err = ccuda.cuCtxGetLimit(&pvalue, climit)
    return (CUresult(err), pvalue)

@cython.embedsignature(True)
def cuCtxGetCacheConfig():
    """ Returns the preferred cache configuration for the current context.

    On devices where the L1 cache and shared memory use the same hardware
    resources, this function returns through `pconfig` the preferred cache
    configuration for the current context. This is only a preference. The
    driver will use the requested configuration if possible, but it is free
    to choose a different configuration if required to execute functions.

    This will return a `pconfig` of :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE`
    on devices where the size of the L1 cache and shared memory are fixed.

    The supported cache configurations are:

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE`: no preference for shared
      memory or L1 (default)

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_SHARED`: prefer larger shared memory
      and smaller L1 cache

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_L1`: prefer larger L1 cache and
      smaller shared memory

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_EQUAL`: prefer equal sized L1 cache
      and shared memory

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pconfig : :py:obj:`~.CUfunc_cache`
        Returned cache configuration

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cudaDeviceGetCacheConfig`
    """
    cdef ccuda.CUfunc_cache pconfig
    err = ccuda.cuCtxGetCacheConfig(&pconfig)
    return (CUresult(err), CUfunc_cache(pconfig))

@cython.embedsignature(True)
def cuCtxSetCacheConfig(config not None : CUfunc_cache):
    """ Sets the preferred cache configuration for the current context.

    On devices where the L1 cache and shared memory use the same hardware
    resources, this sets through `config` the preferred cache configuration
    for the current context. This is only a preference. The driver will use
    the requested configuration if possible, but it is free to choose a
    different configuration if required to execute the function. Any
    function preference set via :py:obj:`~.cuFuncSetCacheConfig()` will be
    preferred over this context-wide setting. Setting the context-wide
    cache configuration to :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE` will cause
    subsequent kernel launches to prefer to not change the cache
    configuration unless required to launch the kernel.

    This setting does nothing on devices where the size of the L1 cache and
    shared memory are fixed.

    Launching a kernel with a different preference than the most recent
    preference setting may insert a device-side synchronization point.

    The supported cache configurations are:

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE`: no preference for shared
      memory or L1 (default)

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_SHARED`: prefer larger shared memory
      and smaller L1 cache

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_L1`: prefer larger L1 cache and
      smaller shared memory

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_EQUAL`: prefer equal sized L1 cache
      and shared memory

    Parameters
    ----------
    config : :py:obj:`~.CUfunc_cache`
        Requested cache configuration

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cudaDeviceSetCacheConfig`
    """
    cdef ccuda.CUfunc_cache cconfig = config.value
    err = ccuda.cuCtxSetCacheConfig(cconfig)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxGetSharedMemConfig():
    """ Returns the current shared memory configuration for the current context.

    This function will return in `pConfig` the current size of shared
    memory banks in the current context. On devices with configurable
    shared memory banks, :py:obj:`~.cuCtxSetSharedMemConfig` can be used to
    change this setting, so that all subsequent kernel launches will by
    default use the new bank size. When :py:obj:`~.cuCtxGetSharedMemConfig`
    is called on devices without configurable shared memory, it will return
    the fixed bank size of the hardware.

    The returned bank configurations can be either:

    - :py:obj:`~.CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE`: shared memory
      bank width is four bytes.

    - :py:obj:`~.CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE`: shared memory
      bank width will eight bytes.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pConfig : :py:obj:`~.CUsharedconfig`
        returned shared memory configuration

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cuCtxGetSharedMemConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cudaDeviceGetSharedMemConfig`
    """
    cdef ccuda.CUsharedconfig pConfig
    err = ccuda.cuCtxGetSharedMemConfig(&pConfig)
    return (CUresult(err), CUsharedconfig(pConfig))

@cython.embedsignature(True)
def cuCtxSetSharedMemConfig(config not None : CUsharedconfig):
    """ Sets the shared memory configuration for the current context.

    On devices with configurable shared memory banks, this function will
    set the context's shared memory bank size which is used for subsequent
    kernel launches.

    Changed the shared memory configuration between launches may insert a
    device side synchronization point between those launches.

    Changing the shared memory bank size will not increase shared memory
    usage or affect occupancy of kernels, but may have major effects on
    performance. Larger bank sizes will allow for greater potential
    bandwidth to shared memory, but will change what kinds of accesses to
    shared memory will result in bank conflicts.

    This function will do nothing on devices with fixed shared memory bank
    size.

    The supported bank configurations are:

    - :py:obj:`~.CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE`: set bank width to
      the default initial setting (currently, four bytes).

    - :py:obj:`~.CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE`: set shared
      memory bank width to be natively four bytes.

    - :py:obj:`~.CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE`: set shared
      memory bank width to be natively eight bytes.

    Parameters
    ----------
    config : :py:obj:`~.CUsharedconfig`
        requested shared memory configuration

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cuCtxGetSharedMemConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cudaDeviceSetSharedMemConfig`
    """
    cdef ccuda.CUsharedconfig cconfig = config.value
    err = ccuda.cuCtxSetSharedMemConfig(cconfig)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxGetApiVersion(ctx):
    """ Gets the context's API version.

    Returns a version number in `version` corresponding to the capabilities
    of the context (e.g. 3010 or 3020), which library developers can use to
    direct callers to a specific API version. If `ctx` is NULL, returns the
    API version used to create the currently bound context.

    Note that new API versions are only introduced when context
    capabilities are changed that break binary compatibility, so the API
    version and driver version may be different. For example, it is valid
    for the API version to be 3020 while the driver version is 4020.

    Parameters
    ----------
    ctx : :py:obj:`~.CUcontext`
        Context to check

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    version : unsigned int
        Pointer to version

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """
    cdef ccuda.CUcontext cctx
    if ctx is None:
        cctx = <ccuda.CUcontext><void_ptr>0
    elif isinstance(ctx, (CUcontext)):
        pctx = int(ctx)
        cctx = <ccuda.CUcontext><void_ptr>pctx
    else:
        pctx = int(CUcontext(ctx))
        cctx = <ccuda.CUcontext><void_ptr>pctx

    cdef unsigned int version = 0
    err = ccuda.cuCtxGetApiVersion(cctx, &version)
    return (CUresult(err), version)

@cython.embedsignature(True)
def cuCtxGetStreamPriorityRange():
    """ Returns numerical values that correspond to the least and greatest stream priorities.

    Returns in `*leastPriority` and `*greatestPriority` the numerical
    values that correspond to the least and greatest stream priorities
    respectively. Stream priorities follow a convention where lower numbers
    imply greater priorities. The range of meaningful stream priorities is
    given by [`*greatestPriority`, `*leastPriority`]. If the user attempts
    to create a stream with a priority value that is outside the meaningful
    range as specified by this API, the priority is automatically clamped
    down or up to either `*leastPriority` or `*greatestPriority`
    respectively. See :py:obj:`~.cuStreamCreateWithPriority` for details on
    creating a priority stream. A NULL may be passed in for
    `*leastPriority` or `*greatestPriority` if the value is not desired.

    This function will return '0' in both `*leastPriority` and
    `*greatestPriority` if the current context's device does not support
    stream priorities (see :py:obj:`~.cuDeviceGetAttribute`).

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    leastPriority : int
        Pointer to an int in which the numerical value for least stream
        priority is returned
    greatestPriority : int
        Pointer to an int in which the numerical value for greatest stream
        priority is returned

    See Also
    --------
    :py:obj:`~.cuStreamCreateWithPriority`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`, :py:obj:`~.cudaDeviceGetStreamPriorityRange`
    """
    cdef int leastPriority = 0
    cdef int greatestPriority = 0
    err = ccuda.cuCtxGetStreamPriorityRange(&leastPriority, &greatestPriority)
    return (CUresult(err), leastPriority, greatestPriority)

@cython.embedsignature(True)
def cuCtxResetPersistingL2Cache():
    """ Resets all persisting lines in cache to normal status.

    :py:obj:`~.cuCtxResetPersistingL2Cache` Resets all persisting lines in
    cache to normal status. Takes effect on function return.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.CUaccessPolicyWindow`
    """
    err = ccuda.cuCtxResetPersistingL2Cache()
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxGetExecAffinity(typename not None : CUexecAffinityType):
    """ Returns the execution affinity setting for the current context.

    Returns in `*pExecAffinity` the current value of `typename`. The
    supported :py:obj:`~.CUexecAffinityType` values are:

    - :py:obj:`~.CU_EXEC_AFFINITY_TYPE_SM_COUNT`: number of SMs the context
      is limited to use.

    Parameters
    ----------
    typename : :py:obj:`~.CUexecAffinityType`
        Execution affinity type to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY`
    pExecAffinity : :py:obj:`~.CUexecAffinityParam`
        Returned execution affinity

    See Also
    --------
    :py:obj:`~.CUexecAffinityParam`
    """
    cdef CUexecAffinityParam pExecAffinity = CUexecAffinityParam()
    cdef ccuda.CUexecAffinityType ctypename = typename.value
    err = ccuda.cuCtxGetExecAffinity(pExecAffinity._ptr, ctypename)
    return (CUresult(err), pExecAffinity)

@cython.embedsignature(True)
def cuCtxAttach(unsigned int flags):
    """ Increment a context's usage-count.

    [Deprecated]

    Note that this function is deprecated and should not be used.

    Increments the usage count of the context and passes back a context
    handle in `*pctx` that must be passed to :py:obj:`~.cuCtxDetach()` when
    the application is done with the context. :py:obj:`~.cuCtxAttach()`
    fails if there is no context current to the thread.

    Currently, the `flags` parameter must be 0.

    Parameters
    ----------
    flags : unsigned int
        Context attach flags (must be 0)

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pctx : :py:obj:`~.CUcontext`
        Returned context handle of the current context

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxDetach`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """
    cdef CUcontext pctx = CUcontext()
    err = ccuda.cuCtxAttach(pctx._ptr, flags)
    return (CUresult(err), pctx)

@cython.embedsignature(True)
def cuCtxDetach(ctx):
    """ Decrement a context's usage-count.

    [Deprecated]

    Note that this function is deprecated and should not be used.

    Decrements the usage count of the context `ctx`, and destroys the
    context if the usage count goes to 0. The context must be a handle that
    was passed back by :py:obj:`~.cuCtxCreate()` or
    :py:obj:`~.cuCtxAttach()`, and must be current to the calling thread.

    Parameters
    ----------
    ctx : :py:obj:`~.CUcontext`
        Context to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuCtxDestroy`, :py:obj:`~.cuCtxGetApiVersion`, :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxGetDevice`, :py:obj:`~.cuCtxGetFlags`, :py:obj:`~.cuCtxGetLimit`, :py:obj:`~.cuCtxPopCurrent`, :py:obj:`~.cuCtxPushCurrent`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxSetLimit`, :py:obj:`~.cuCtxSynchronize`
    """
    cdef ccuda.CUcontext cctx
    if ctx is None:
        cctx = <ccuda.CUcontext><void_ptr>0
    elif isinstance(ctx, (CUcontext)):
        pctx = int(ctx)
        cctx = <ccuda.CUcontext><void_ptr>pctx
    else:
        pctx = int(CUcontext(ctx))
        cctx = <ccuda.CUcontext><void_ptr>pctx

    err = ccuda.cuCtxDetach(cctx)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuModuleLoad(char* fname):
    """ Loads a compute module.

    Takes a filename `fname` and loads the corresponding module `module`
    into the current context. The CUDA driver API does not attempt to
    lazily allocate the resources needed by a module; if the memory for
    functions and data (constant and global) needed by the module cannot be
    allocated, :py:obj:`~.cuModuleLoad()` fails. The file should be a
    `cubin` file as output by nvcc, or a `PTX` file either as output by
    nvcc or handwritten, or a `fatbin` file as output by nvcc from
    toolchain 4.0 or later.

    Parameters
    ----------
    fname : bytes
        Filename of module to load

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_FILE_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`
    module : :py:obj:`~.CUmodule`
        Returned module

    See Also
    --------
    :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`
    """
    cdef CUmodule module = CUmodule()
    err = ccuda.cuModuleLoad(module._ptr, fname)
    return (CUresult(err), module)

@cython.embedsignature(True)
def cuModuleLoadData(image):
    """ Load a module's data.

    Takes a pointer `image` and loads the corresponding module `module`
    into the current context. The pointer may be obtained by mapping a
    `cubin` or `PTX` or `fatbin` file, passing a `cubin` or `PTX` or
    `fatbin` file as a NULL-terminated text string, or incorporating a
    `cubin` or `fatbin` object into the executable resources and using
    operating system calls such as Windows `FindResource()` to obtain the
    pointer.

    Parameters
    ----------
    image : Any
        Module data to load

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`
    module : :py:obj:`~.CUmodule`
        Returned module

    See Also
    --------
    :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`
    """
    cdef CUmodule module = CUmodule()
    cimage = utils.HelperInputVoidPtr(image)
    cdef void* cimage_ptr = <void*><void_ptr>cimage.cptr
    err = ccuda.cuModuleLoadData(module._ptr, cimage_ptr)
    return (CUresult(err), module)

@cython.embedsignature(True)
def cuModuleLoadDataEx(image, unsigned int numOptions, options : List[CUjit_option], optionValues : List[Any]):
    """ Load a module's data with options.

    Takes a pointer `image` and loads the corresponding module `module`
    into the current context. The pointer may be obtained by mapping a
    `cubin` or `PTX` or `fatbin` file, passing a `cubin` or `PTX` or
    `fatbin` file as a NULL-terminated text string, or incorporating a
    `cubin` or `fatbin` object into the executable resources and using
    operating system calls such as Windows `FindResource()` to obtain the
    pointer. Options are passed as an array via `options` and any
    corresponding parameters are passed in `optionValues`. The number of
    total options is supplied via `numOptions`. Any outputs will be
    returned via `optionValues`.

    Parameters
    ----------
    image : Any
        Module data to load
    numOptions : unsigned int
        Number of options
    options : List[:py:obj:`~.CUjit_option`]
        Options for JIT
    optionValues : List[Any]
        Option values for JIT

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`
    module : :py:obj:`~.CUmodule`
        Returned module

    See Also
    --------
    :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`
    """
    options = [] if options is None else options
    if not all(isinstance(_x, (CUjit_option)) for _x in options):
        raise TypeError("Argument 'options' is not instance of type (expected List[ccuda.CUjit_option]")

    cdef CUmodule module = CUmodule()
    cimage = utils.HelperInputVoidPtr(image)
    cdef void* cimage_ptr = <void*><void_ptr>cimage.cptr
    if numOptions > len(options): raise RuntimeError("List is too small: " + str(len(options)) + " < " + str(numOptions))
    if numOptions > len(optionValues): raise RuntimeError("List is too small: " + str(len(optionValues)) + " < " + str(numOptions))
    cdef vector[ccuda.CUjit_option] coptions = [pyoptions.value for pyoptions in (options)]
    pylist = [utils.HelperCUjit_option(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(options, optionValues)]
    cdef utils.InputVoidPtrPtrHelper voidStarHelper = utils.InputVoidPtrPtrHelper(pylist)
    err = ccuda.cuModuleLoadDataEx(module._ptr, cimage_ptr, numOptions, coptions.data(), <void**><void_ptr>voidStarHelper.cptr)
    return (CUresult(err), module)

@cython.embedsignature(True)
def cuModuleLoadFatBinary(fatCubin):
    """ Load a module's data.

    Takes a pointer `fatCubin` and loads the corresponding module `module`
    into the current context. The pointer represents a `fat binary` object,
    which is a collection of different `cubin` and/or `PTX` files, all
    representing the same device code, but compiled and optimized for
    different architectures.

    Prior to CUDA 4.0, there was no documented API for constructing and
    using fat binary objects by programmers. Starting with CUDA 4.0, fat
    binary objects can be constructed by providing the `-fatbin option` to
    nvcc. More information can be found in the nvcc document.

    Parameters
    ----------
    fatCubin : Any
        Fat binary to load

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`
    module : :py:obj:`~.CUmodule`
        Returned module

    See Also
    --------
    :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleUnload`
    """
    cdef CUmodule module = CUmodule()
    cfatCubin = utils.HelperInputVoidPtr(fatCubin)
    cdef void* cfatCubin_ptr = <void*><void_ptr>cfatCubin.cptr
    err = ccuda.cuModuleLoadFatBinary(module._ptr, cfatCubin_ptr)
    return (CUresult(err), module)

@cython.embedsignature(True)
def cuModuleUnload(hmod):
    """ Unloads a module.

    Unloads a module `hmod` from the current context.

    Parameters
    ----------
    hmod : :py:obj:`~.CUmodule`
        Module to unload

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`
    """
    cdef ccuda.CUmodule chmod
    if hmod is None:
        chmod = <ccuda.CUmodule><void_ptr>0
    elif isinstance(hmod, (CUmodule)):
        phmod = int(hmod)
        chmod = <ccuda.CUmodule><void_ptr>phmod
    else:
        phmod = int(CUmodule(hmod))
        chmod = <ccuda.CUmodule><void_ptr>phmod

    err = ccuda.cuModuleUnload(chmod)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuModuleGetFunction(hmod, char* name):
    """ Returns a function handle.

    Returns in `*hfunc` the handle of the function of name `name` located
    in module `hmod`. If no function of that name exists,
    :py:obj:`~.cuModuleGetFunction()` returns
    :py:obj:`~.CUDA_ERROR_NOT_FOUND`.

    Parameters
    ----------
    hmod : :py:obj:`~.CUmodule`
        Module to retrieve function from
    name : bytes
        Name of function to retrieve

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
    hfunc : :py:obj:`~.CUfunction`
        Returned function handle

    See Also
    --------
    :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`
    """
    cdef ccuda.CUmodule chmod
    if hmod is None:
        chmod = <ccuda.CUmodule><void_ptr>0
    elif isinstance(hmod, (CUmodule)):
        phmod = int(hmod)
        chmod = <ccuda.CUmodule><void_ptr>phmod
    else:
        phmod = int(CUmodule(hmod))
        chmod = <ccuda.CUmodule><void_ptr>phmod

    cdef CUfunction hfunc = CUfunction()
    err = ccuda.cuModuleGetFunction(hfunc._ptr, chmod, name)
    return (CUresult(err), hfunc)

@cython.embedsignature(True)
def cuModuleGetGlobal(hmod, char* name):
    """ Returns a global pointer from a module.

    Returns in `*dptr` and `*bytes` the base pointer and size of the global
    of name `name` located in module `hmod`. If no variable of that name
    exists, :py:obj:`~.cuModuleGetGlobal()` returns
    :py:obj:`~.CUDA_ERROR_NOT_FOUND`. Both parameters `dptr` and `numbytes`
    are optional. If one of them is NULL, it is ignored.

    Parameters
    ----------
    hmod : :py:obj:`~.CUmodule`
        Module to retrieve global from
    name : bytes
        Name of global to retrieve

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
    dptr : :py:obj:`~.CUdeviceptr`
        Returned global device pointer
    numbytes : int
        Returned global size in bytes

    See Also
    --------
    :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`, :py:obj:`~.cudaGetSymbolAddress`, :py:obj:`~.cudaGetSymbolSize`
    """
    cdef ccuda.CUmodule chmod
    if hmod is None:
        chmod = <ccuda.CUmodule><void_ptr>0
    elif isinstance(hmod, (CUmodule)):
        phmod = int(hmod)
        chmod = <ccuda.CUmodule><void_ptr>phmod
    else:
        phmod = int(CUmodule(hmod))
        chmod = <ccuda.CUmodule><void_ptr>phmod

    cdef CUdeviceptr dptr = CUdeviceptr()
    cdef size_t numbytes = 0
    err = ccuda.cuModuleGetGlobal(dptr._ptr, &numbytes, chmod, name)
    return (CUresult(err), dptr, numbytes)

@cython.embedsignature(True)
def cuModuleGetTexRef(hmod, char* name):
    """ Returns a handle to a texture reference.

    Returns in `*pTexRef` the handle of the texture reference of name
    `name` in the module `hmod`. If no texture reference of that name
    exists, :py:obj:`~.cuModuleGetTexRef()` returns
    :py:obj:`~.CUDA_ERROR_NOT_FOUND`. This texture reference handle should
    not be destroyed, since it will be destroyed when the module is
    unloaded.

    Parameters
    ----------
    hmod : :py:obj:`~.CUmodule`
        Module to retrieve texture reference from
    name : bytes
        Name of texture reference to retrieve

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
    pTexRef : :py:obj:`~.CUtexref`
        Returned texture reference

    See Also
    --------
    :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetSurfRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`, :py:obj:`~.cudaGetTextureReference`
    """
    cdef ccuda.CUmodule chmod
    if hmod is None:
        chmod = <ccuda.CUmodule><void_ptr>0
    elif isinstance(hmod, (CUmodule)):
        phmod = int(hmod)
        chmod = <ccuda.CUmodule><void_ptr>phmod
    else:
        phmod = int(CUmodule(hmod))
        chmod = <ccuda.CUmodule><void_ptr>phmod

    cdef CUtexref pTexRef = CUtexref()
    err = ccuda.cuModuleGetTexRef(pTexRef._ptr, chmod, name)
    return (CUresult(err), pTexRef)

@cython.embedsignature(True)
def cuModuleGetSurfRef(hmod, char* name):
    """ Returns a handle to a surface reference.

    Returns in `*pSurfRef` the handle of the surface reference of name
    `name` in the module `hmod`. If no surface reference of that name
    exists, :py:obj:`~.cuModuleGetSurfRef()` returns
    :py:obj:`~.CUDA_ERROR_NOT_FOUND`.

    Parameters
    ----------
    hmod : :py:obj:`~.CUmodule`
        Module to retrieve surface reference from
    name : bytes
        Name of surface reference to retrieve

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
    pSurfRef : :py:obj:`~.CUsurfref`
        Returned surface reference

    See Also
    --------
    :py:obj:`~.cuModuleGetFunction`, :py:obj:`~.cuModuleGetGlobal`, :py:obj:`~.cuModuleGetTexRef`, :py:obj:`~.cuModuleLoad`, :py:obj:`~.cuModuleLoadData`, :py:obj:`~.cuModuleLoadDataEx`, :py:obj:`~.cuModuleLoadFatBinary`, :py:obj:`~.cuModuleUnload`, :py:obj:`~.cudaGetSurfaceReference`
    """
    cdef ccuda.CUmodule chmod
    if hmod is None:
        chmod = <ccuda.CUmodule><void_ptr>0
    elif isinstance(hmod, (CUmodule)):
        phmod = int(hmod)
        chmod = <ccuda.CUmodule><void_ptr>phmod
    else:
        phmod = int(CUmodule(hmod))
        chmod = <ccuda.CUmodule><void_ptr>phmod

    cdef CUsurfref pSurfRef = CUsurfref()
    err = ccuda.cuModuleGetSurfRef(pSurfRef._ptr, chmod, name)
    return (CUresult(err), pSurfRef)

@cython.embedsignature(True)
def cuLinkCreate(unsigned int numOptions, options : List[CUjit_option], optionValues : List[Any]):
    """ Creates a pending JIT linker invocation.

    If the call is successful, the caller owns the returned CUlinkState,
    which should eventually be destroyed with :py:obj:`~.cuLinkDestroy`.
    The device code machine size (32 or 64 bit) will match the calling
    application.

    Both linker and compiler options may be specified. Compiler options
    will be applied to inputs to this linker action which must be compiled
    from PTX. The options :py:obj:`~.CU_JIT_WALL_TIME`,
    :py:obj:`~.CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES`, and
    :py:obj:`~.CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES` will accumulate data
    until the CUlinkState is destroyed.

    `optionValues` must remain valid for the life of the CUlinkState if
    output options are used. No other references to inputs are maintained
    after this call returns.

    Parameters
    ----------
    numOptions : unsigned int
        Size of options arrays
    options : List[:py:obj:`~.CUjit_option`]
        Array of linker and compiler options
    optionValues : List[Any]
        Array of option values, each cast to void *

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_JIT_COMPILER_NOT_FOUND`
    stateOut : :py:obj:`~.CUlinkState`
        On success, this will contain a CUlinkState to specify and complete
        this action

    See Also
    --------
    :py:obj:`~.cuLinkAddData`, :py:obj:`~.cuLinkAddFile`, :py:obj:`~.cuLinkComplete`, :py:obj:`~.cuLinkDestroy`
    """
    options = [] if options is None else options
    if not all(isinstance(_x, (CUjit_option)) for _x in options):
        raise TypeError("Argument 'options' is not instance of type (expected List[ccuda.CUjit_option]")

    if numOptions > len(options): raise RuntimeError("List is too small: " + str(len(options)) + " < " + str(numOptions))
    if numOptions > len(optionValues): raise RuntimeError("List is too small: " + str(len(optionValues)) + " < " + str(numOptions))
    cdef vector[ccuda.CUjit_option] coptions = [pyoptions.value for pyoptions in (options)]
    pylist = [utils.HelperCUjit_option(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(options, optionValues)]
    cdef utils.InputVoidPtrPtrHelper voidStarHelper = utils.InputVoidPtrPtrHelper(pylist)
    cdef CUlinkState stateOut = CUlinkState()
    err = ccuda.cuLinkCreate(numOptions, coptions.data(), <void**><void_ptr>voidStarHelper.cptr, stateOut._ptr)
    stateOut._keepalive.append(voidStarHelper)
    for option in pylist:
        stateOut._keepalive.append(option)
    return (CUresult(err), stateOut)

@cython.embedsignature(True)
def cuLinkAddData(state, typename not None : CUjitInputType, data, size_t size, char* name, unsigned int numOptions, options : List[CUjit_option], optionValues : List[Any]):
    """ Add an input to a pending linker invocation.

    Ownership of `data` is retained by the caller. No reference is retained
    to any inputs after this call returns.

    This method accepts only compiler options, which are used if the data
    must be compiled from PTX, and does not accept any of
    :py:obj:`~.CU_JIT_WALL_TIME`, :py:obj:`~.CU_JIT_INFO_LOG_BUFFER`,
    :py:obj:`~.CU_JIT_ERROR_LOG_BUFFER`,
    :py:obj:`~.CU_JIT_TARGET_FROM_CUCONTEXT`, or :py:obj:`~.CU_JIT_TARGET`.

    Parameters
    ----------
    state : :py:obj:`~.CUlinkState`
        A pending linker action.
    typename : :py:obj:`~.CUjitInputType`
        The type of the input data.
    data : Any
        The input data. PTX must be NULL-terminated.
    size : size_t
        The length of the input data.
    name : bytes
        An optional name for this input in log messages.
    numOptions : unsigned int
        Size of options.
    options : List[:py:obj:`~.CUjit_option`]
        Options to be applied only for this input (overrides options from
        :py:obj:`~.cuLinkCreate`).
    optionValues : List[Any]
        Array of option values, each cast to void *.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`

    See Also
    --------
    :py:obj:`~.cuLinkCreate`, :py:obj:`~.cuLinkAddFile`, :py:obj:`~.cuLinkComplete`, :py:obj:`~.cuLinkDestroy`
    """
    options = [] if options is None else options
    if not all(isinstance(_x, (CUjit_option)) for _x in options):
        raise TypeError("Argument 'options' is not instance of type (expected List[ccuda.CUjit_option]")

    cdef ccuda.CUlinkState cstate
    if state is None:
        cstate = <ccuda.CUlinkState><void_ptr>0
    elif isinstance(state, (CUlinkState)):
        pstate = int(state)
        cstate = <ccuda.CUlinkState><void_ptr>pstate
    else:
        pstate = int(CUlinkState(state))
        cstate = <ccuda.CUlinkState><void_ptr>pstate

    cdef ccuda.CUjitInputType ctypename = typename.value
    cdata = utils.HelperInputVoidPtr(data)
    cdef void* cdata_ptr = <void*><void_ptr>cdata.cptr
    if numOptions > len(options): raise RuntimeError("List is too small: " + str(len(options)) + " < " + str(numOptions))
    if numOptions > len(optionValues): raise RuntimeError("List is too small: " + str(len(optionValues)) + " < " + str(numOptions))
    cdef vector[ccuda.CUjit_option] coptions = [pyoptions.value for pyoptions in (options)]
    pylist = [utils.HelperCUjit_option(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(options, optionValues)]
    cdef utils.InputVoidPtrPtrHelper voidStarHelper = utils.InputVoidPtrPtrHelper(pylist)
    err = ccuda.cuLinkAddData(cstate, ctypename, cdata_ptr, size, name, numOptions, coptions.data(), <void**><void_ptr>voidStarHelper.cptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuLinkAddFile(state, typename not None : CUjitInputType, char* path, unsigned int numOptions, options : List[CUjit_option], optionValues : List[Any]):
    """ Add a file input to a pending linker invocation.

    No reference is retained to any inputs after this call returns.

    This method accepts only compiler options, which are used if the input
    must be compiled from PTX, and does not accept any of
    :py:obj:`~.CU_JIT_WALL_TIME`, :py:obj:`~.CU_JIT_INFO_LOG_BUFFER`,
    :py:obj:`~.CU_JIT_ERROR_LOG_BUFFER`,
    :py:obj:`~.CU_JIT_TARGET_FROM_CUCONTEXT`, or :py:obj:`~.CU_JIT_TARGET`.

    This method is equivalent to invoking :py:obj:`~.cuLinkAddData` on the
    contents of the file.

    Parameters
    ----------
    state : :py:obj:`~.CUlinkState`
        A pending linker action
    typename : :py:obj:`~.CUjitInputType`
        The type of the input data
    path : bytes
        Path to the input file
    numOptions : unsigned int
        Size of options
    options : List[:py:obj:`~.CUjit_option`]
        Options to be applied only for this input (overrides options from
        :py:obj:`~.cuLinkCreate`)
    optionValues : List[Any]
        Array of option values, each cast to void *

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_FILE_NOT_FOUND` :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`, :py:obj:`~.CUDA_ERROR_INVALID_PTX`, :py:obj:`~.CUDA_ERROR_UNSUPPORTED_PTX_VERSION`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NO_BINARY_FOR_GPU`

    See Also
    --------
    :py:obj:`~.cuLinkCreate`, :py:obj:`~.cuLinkAddData`, :py:obj:`~.cuLinkComplete`, :py:obj:`~.cuLinkDestroy`
    """
    options = [] if options is None else options
    if not all(isinstance(_x, (CUjit_option)) for _x in options):
        raise TypeError("Argument 'options' is not instance of type (expected List[ccuda.CUjit_option]")

    cdef ccuda.CUlinkState cstate
    if state is None:
        cstate = <ccuda.CUlinkState><void_ptr>0
    elif isinstance(state, (CUlinkState)):
        pstate = int(state)
        cstate = <ccuda.CUlinkState><void_ptr>pstate
    else:
        pstate = int(CUlinkState(state))
        cstate = <ccuda.CUlinkState><void_ptr>pstate

    cdef ccuda.CUjitInputType ctypename = typename.value
    if numOptions > len(options): raise RuntimeError("List is too small: " + str(len(options)) + " < " + str(numOptions))
    if numOptions > len(optionValues): raise RuntimeError("List is too small: " + str(len(optionValues)) + " < " + str(numOptions))
    cdef vector[ccuda.CUjit_option] coptions = [pyoptions.value for pyoptions in (options)]
    pylist = [utils.HelperCUjit_option(pyoptions, pyoptionValues) for pyoptions, pyoptionValues in zip(options, optionValues)]
    cdef utils.InputVoidPtrPtrHelper voidStarHelper = utils.InputVoidPtrPtrHelper(pylist)
    err = ccuda.cuLinkAddFile(cstate, ctypename, path, numOptions, coptions.data(), <void**><void_ptr>voidStarHelper.cptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuLinkComplete(state):
    """ Complete a pending linker invocation.

    Completes the pending linker action and returns the cubin image for the
    linked device code, which can be used with
    :py:obj:`~.cuModuleLoadData`. The cubin is owned by `state`, so it
    should be loaded before `state` is destroyed via
    :py:obj:`~.cuLinkDestroy`. This call does not destroy `state`.

    Parameters
    ----------
    state : :py:obj:`~.CUlinkState`
        A pending linker invocation

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    cubinOut : Any
        On success, this will point to the output image
    sizeOut : int
        Optional parameter to receive the size of the generated image

    See Also
    --------
    :py:obj:`~.cuLinkCreate`, :py:obj:`~.cuLinkAddData`, :py:obj:`~.cuLinkAddFile`, :py:obj:`~.cuLinkDestroy`, :py:obj:`~.cuModuleLoadData`
    """
    cdef ccuda.CUlinkState cstate
    if state is None:
        cstate = <ccuda.CUlinkState><void_ptr>0
    elif isinstance(state, (CUlinkState)):
        pstate = int(state)
        cstate = <ccuda.CUlinkState><void_ptr>pstate
    else:
        pstate = int(CUlinkState(state))
        cstate = <ccuda.CUlinkState><void_ptr>pstate

    cdef void_ptr cubinOut = 0
    cdef size_t sizeOut = 0
    err = ccuda.cuLinkComplete(cstate, <void**>&cubinOut, &sizeOut)
    return (CUresult(err), cubinOut, sizeOut)

@cython.embedsignature(True)
def cuLinkDestroy(state):
    """ Destroys state for a JIT linker invocation.

    Parameters
    ----------
    state : :py:obj:`~.CUlinkState`
        State object for the linker invocation

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuLinkCreate`
    """
    cdef ccuda.CUlinkState cstate
    if state is None:
        cstate = <ccuda.CUlinkState><void_ptr>0
    elif isinstance(state, (CUlinkState)):
        pstate = int(state)
        cstate = <ccuda.CUlinkState><void_ptr>pstate
    else:
        pstate = int(CUlinkState(state))
        cstate = <ccuda.CUlinkState><void_ptr>pstate

    err = ccuda.cuLinkDestroy(cstate)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemGetInfo():
    """ Gets free and total memory.

    Returns in `*total` the total amount of memory available to the the
    current context. Returns in `*free` the amount of memory on the device
    that is free according to the OS. CUDA is not guaranteed to be able to
    allocate all of the memory that the OS reports as free. In a multi-
    tenet situation, free estimate returned is prone to race condition
    where a new allocation/free done by a different process or a different
    thread in the same process between the time when free memory was
    estimated and reported, will result in deviation in free value reported
    and actual free memory.

    The integrated GPU on Tegra shares memory with CPU and other component
    of the SoC. The free and total values returned by the API excludes the
    SWAP memory space maintained by the OS on some platforms. The OS may
    move some of the memory pages into swap area as the GPU or CPU allocate
    or access memory. See Tegra app note on how to calculate total and free
    memory on Tegra.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    free : int
        Returned free memory in bytes
    total : int
        Returned total memory in bytes

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemGetInfo`
    """
    cdef size_t free = 0
    cdef size_t total = 0
    err = ccuda.cuMemGetInfo(&free, &total)
    return (CUresult(err), free, total)

@cython.embedsignature(True)
def cuMemAlloc(size_t bytesize):
    """ Allocates device memory.

    Allocates `bytesize` bytes of linear memory on the device and returns
    in `*dptr` a pointer to the allocated memory. The allocated memory is
    suitably aligned for any kind of variable. The memory is not cleared.
    If `bytesize` is 0, :py:obj:`~.cuMemAlloc()` returns
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

    Parameters
    ----------
    bytesize : size_t
        Requested allocation size in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    dptr : :py:obj:`~.CUdeviceptr`
        Returned device pointer

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMalloc`
    """
    cdef CUdeviceptr dptr = CUdeviceptr()
    err = ccuda.cuMemAlloc(dptr._ptr, bytesize)
    return (CUresult(err), dptr)

@cython.embedsignature(True)
def cuMemAllocPitch(size_t WidthInBytes, size_t Height, unsigned int ElementSizeBytes):
    """ Allocates pitched device memory.

    Allocates at least `WidthInBytes` * `Height` bytes of linear memory on
    the device and returns in `*dptr` a pointer to the allocated memory.
    The function may pad the allocation to ensure that corresponding
    pointers in any given row will continue to meet the alignment
    requirements for coalescing as the address is updated from row to row.
    `ElementSizeBytes` specifies the size of the largest reads and writes
    that will be performed on the memory range. `ElementSizeBytes` may be
    4, 8 or 16 (since coalesced memory transactions are not possible on
    other data sizes). If `ElementSizeBytes` is smaller than the actual
    read/write size of a kernel, the kernel will run correctly, but
    possibly at reduced speed. The pitch returned in `*pPitch` by
    :py:obj:`~.cuMemAllocPitch()` is the width in bytes of the allocation.
    The intended usage of pitch is as a separate parameter of the
    allocation, used to compute addresses within the 2D array. Given the
    row and column of an array element of type T, the address is computed
    as:

    **View CUDA Toolkit Documentation for a C++ code example**

    The pitch returned by :py:obj:`~.cuMemAllocPitch()` is guaranteed to
    work with :py:obj:`~.cuMemcpy2D()` under all circumstances. For
    allocations of 2D arrays, it is recommended that programmers consider
    performing pitch allocations using :py:obj:`~.cuMemAllocPitch()`. Due
    to alignment restrictions in the hardware, this is especially true if
    the application will be performing 2D memory copies between different
    regions of device memory (whether linear memory or CUDA arrays).

    The byte alignment of the pitch returned by
    :py:obj:`~.cuMemAllocPitch()` is guaranteed to match or exceed the
    alignment requirement for texture binding with
    :py:obj:`~.cuTexRefSetAddress2D()`.

    Parameters
    ----------
    WidthInBytes : size_t
        Requested allocation width in bytes
    Height : size_t
        Requested allocation height in rows
    ElementSizeBytes : unsigned int
        Size of largest reads/writes for range

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    dptr : :py:obj:`~.CUdeviceptr`
        Returned device pointer
    pPitch : int
        Returned pitch of allocation in bytes

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMallocPitch`
    """
    cdef CUdeviceptr dptr = CUdeviceptr()
    cdef size_t pPitch = 0
    err = ccuda.cuMemAllocPitch(dptr._ptr, &pPitch, WidthInBytes, Height, ElementSizeBytes)
    return (CUresult(err), dptr, pPitch)

@cython.embedsignature(True)
def cuMemFree(dptr):
    """ Frees device memory.

    Frees the memory space pointed to by `dptr`, which must have been
    returned by a previous call to one of the following memory allocation
    APIs - :py:obj:`~.cuMemAlloc()`, :py:obj:`~.cuMemAllocPitch()`,
    :py:obj:`~.cuMemAllocManaged()`, :py:obj:`~.cuMemAllocAsync()`,
    :py:obj:`~.cuMemAllocFromPoolAsync()`

    Note - This API will not perform any implict synchronization when the
    pointer was allocated with :py:obj:`~.cuMemAllocAsync` or
    :py:obj:`~.cuMemAllocFromPoolAsync`. Callers must ensure that all
    accesses to the pointer have completed before invoking
    :py:obj:`~.cuMemFree`. For best performance and memory reuse, users
    should use :py:obj:`~.cuMemFreeAsync` to free memory allocated via the
    stream ordered memory allocator.

    Parameters
    ----------
    dptr : :py:obj:`~.CUdeviceptr`
        Pointer to memory to free

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemAllocManaged`, :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemAllocFromPoolAsync`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaFree`
    """
    cdef ccuda.CUdeviceptr cdptr
    if dptr is None:
        cdptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dptr, (CUdeviceptr)):
        pdptr = int(dptr)
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr
    else:
        pdptr = int(CUdeviceptr(dptr))
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr

    err = ccuda.cuMemFree(cdptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemGetAddressRange(dptr):
    """ Get information on memory allocations.

    Returns the base address in `*pbase` and size in `*psize` of the
    allocation by :py:obj:`~.cuMemAlloc()` or :py:obj:`~.cuMemAllocPitch()`
    that contains the input pointer `dptr`. Both parameters `pbase` and
    `psize` are optional. If one of them is NULL, it is ignored.

    Parameters
    ----------
    dptr : :py:obj:`~.CUdeviceptr`
        Device pointer to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pbase : :py:obj:`~.CUdeviceptr`
        Returned base address
    psize : int
        Returned size of device memory allocation

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`
    """
    cdef ccuda.CUdeviceptr cdptr
    if dptr is None:
        cdptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dptr, (CUdeviceptr)):
        pdptr = int(dptr)
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr
    else:
        pdptr = int(CUdeviceptr(dptr))
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr

    cdef CUdeviceptr pbase = CUdeviceptr()
    cdef size_t psize = 0
    err = ccuda.cuMemGetAddressRange(pbase._ptr, &psize, cdptr)
    return (CUresult(err), pbase, psize)

@cython.embedsignature(True)
def cuMemAllocHost(size_t bytesize):
    """ Allocates page-locked host memory.

    Allocates `bytesize` bytes of host memory that is page-locked and
    accessible to the device. The driver tracks the virtual memory ranges
    allocated with this function and automatically accelerates calls to
    functions such as :py:obj:`~.cuMemcpy()`. Since the memory can be
    accessed directly by the device, it can be read or written with much
    higher bandwidth than pageable memory obtained with functions such as
    :py:obj:`~.malloc()`. Allocating excessive amounts of memory with
    :py:obj:`~.cuMemAllocHost()` may degrade system performance, since it
    reduces the amount of memory available to the system for paging. As a
    result, this function is best used sparingly to allocate staging areas
    for data exchange between host and device.

    Note all host memory allocated using :py:obj:`~.cuMemHostAlloc()` will
    automatically be immediately accessible to all contexts on all devices
    which support unified addressing (as may be queried using
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING`). The device pointer
    that may be used to access this host memory from those contexts is
    always equal to the returned host pointer `*pp`. See :py:obj:`~.Unified
    Addressing` for additional details.

    Parameters
    ----------
    bytesize : size_t
        Requested allocation size in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    pp : Any
        Returned host pointer to page-locked memory

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMallocHost`
    """
    cdef void_ptr pp = 0
    err = ccuda.cuMemAllocHost(<void**>&pp, bytesize)
    return (CUresult(err), pp)

@cython.embedsignature(True)
def cuMemFreeHost(p):
    """ Frees page-locked host memory.

    Frees the memory space pointed to by `p`, which must have been returned
    by a previous call to :py:obj:`~.cuMemAllocHost()`.

    Parameters
    ----------
    p : Any
        Pointer to memory to free

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaFreeHost`
    """
    cp = utils.HelperInputVoidPtr(p)
    cdef void* cp_ptr = <void*><void_ptr>cp.cptr
    err = ccuda.cuMemFreeHost(cp_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemHostAlloc(size_t bytesize, unsigned int Flags):
    """ Allocates page-locked host memory.

    Allocates `bytesize` bytes of host memory that is page-locked and
    accessible to the device. The driver tracks the virtual memory ranges
    allocated with this function and automatically accelerates calls to
    functions such as :py:obj:`~.cuMemcpyHtoD()`. Since the memory can be
    accessed directly by the device, it can be read or written with much
    higher bandwidth than pageable memory obtained with functions such as
    :py:obj:`~.malloc()`. Allocating excessive amounts of pinned memory may
    degrade system performance, since it reduces the amount of memory
    available to the system for paging. As a result, this function is best
    used sparingly to allocate staging areas for data exchange between host
    and device.

    The `Flags` parameter enables different options to be specified that
    affect the allocation, as follows.

    - :py:obj:`~.CU_MEMHOSTALLOC_PORTABLE`: The memory returned by this
      call will be considered as pinned memory by all CUDA contexts, not
      just the one that performed the allocation.

    - :py:obj:`~.CU_MEMHOSTALLOC_DEVICEMAP`: Maps the allocation into the
      CUDA address space. The device pointer to the memory may be obtained
      by calling :py:obj:`~.cuMemHostGetDevicePointer()`.

    - :py:obj:`~.CU_MEMHOSTALLOC_WRITECOMBINED`: Allocates the memory as
      write-combined (WC). WC memory can be transferred across the PCI
      Express bus more quickly on some system configurations, but cannot be
      read efficiently by most CPUs. WC memory is a good option for buffers
      that will be written by the CPU and read by the GPU via mapped pinned
      memory or host->device transfers.

    All of these flags are orthogonal to one another: a developer may
    allocate memory that is portable, mapped and/or write-combined with no
    restrictions.

    The :py:obj:`~.CU_MEMHOSTALLOC_DEVICEMAP` flag may be specified on CUDA
    contexts for devices that do not support mapped pinned memory. The
    failure is deferred to :py:obj:`~.cuMemHostGetDevicePointer()` because
    the memory may be mapped into other CUDA contexts via the
    :py:obj:`~.CU_MEMHOSTALLOC_PORTABLE` flag.

    The memory allocated by this function must be freed with
    :py:obj:`~.cuMemFreeHost()`.

    Note all host memory allocated using :py:obj:`~.cuMemHostAlloc()` will
    automatically be immediately accessible to all contexts on all devices
    which support unified addressing (as may be queried using
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING`). Unless the flag
    :py:obj:`~.CU_MEMHOSTALLOC_WRITECOMBINED` is specified, the device
    pointer that may be used to access this host memory from those contexts
    is always equal to the returned host pointer `*pp`. If the flag
    :py:obj:`~.CU_MEMHOSTALLOC_WRITECOMBINED` is specified, then the
    function :py:obj:`~.cuMemHostGetDevicePointer()` must be used to query
    the device pointer, even if the context supports unified addressing.
    See :py:obj:`~.Unified Addressing` for additional details.

    Parameters
    ----------
    bytesize : size_t
        Requested allocation size in bytes
    Flags : unsigned int
        Flags for allocation request

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    pp : Any
        Returned host pointer to page-locked memory

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaHostAlloc`
    """
    cdef void_ptr pp = 0
    err = ccuda.cuMemHostAlloc(<void**>&pp, bytesize, Flags)
    return (CUresult(err), pp)

@cython.embedsignature(True)
def cuMemHostGetDevicePointer(p, unsigned int Flags):
    """ Passes back device pointer of mapped pinned memory.

    Passes back the device pointer `pdptr` corresponding to the mapped,
    pinned host buffer `p` allocated by :py:obj:`~.cuMemHostAlloc`.

    :py:obj:`~.cuMemHostGetDevicePointer()` will fail if the
    :py:obj:`~.CU_MEMHOSTALLOC_DEVICEMAP` flag was not specified at the
    time the memory was allocated, or if the function is called on a GPU
    that does not support mapped pinned memory.

    For devices that have a non-zero value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM`,
    the memory can also be accessed from the device using the host pointer
    `p`. The device pointer returned by
    :py:obj:`~.cuMemHostGetDevicePointer()` may or may not match the
    original host pointer `p` and depends on the devices visible to the
    application. If all devices visible to the application have a non-zero
    value for the device attribute, the device pointer returned by
    :py:obj:`~.cuMemHostGetDevicePointer()` will match the original pointer
    `p`. If any device visible to the application has a zero value for the
    device attribute, the device pointer returned by
    :py:obj:`~.cuMemHostGetDevicePointer()` will not match the original
    host pointer `p`, but it will be suitable for use on all devices
    provided Unified Virtual Addressing is enabled. In such systems, it is
    valid to access the memory using either pointer on devices that have a
    non-zero value for the device attribute. Note however that such devices
    should access the memory using only one of the two pointers and not
    both.

    `Flags` provides for future releases. For now, it must be set to 0.

    Parameters
    ----------
    p : Any
        Host pointer
    Flags : unsigned int
        Options (must be 0)

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pdptr : :py:obj:`~.CUdeviceptr`
        Returned device pointer

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaHostGetDevicePointer`
    """
    cdef CUdeviceptr pdptr = CUdeviceptr()
    cp = utils.HelperInputVoidPtr(p)
    cdef void* cp_ptr = <void*><void_ptr>cp.cptr
    err = ccuda.cuMemHostGetDevicePointer(pdptr._ptr, cp_ptr, Flags)
    return (CUresult(err), pdptr)

@cython.embedsignature(True)
def cuMemHostGetFlags(p):
    """ Passes back flags that were used for a pinned allocation.

    Passes back the flags `pFlags` that were specified when allocating the
    pinned host buffer `p` allocated by :py:obj:`~.cuMemHostAlloc`.

    :py:obj:`~.cuMemHostGetFlags()` will fail if the pointer does not
    reside in an allocation performed by :py:obj:`~.cuMemAllocHost()` or
    :py:obj:`~.cuMemHostAlloc()`.

    Parameters
    ----------
    p : Any
        Host pointer

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pFlags : unsigned int
        Returned flags word

    See Also
    --------
    :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cudaHostGetFlags`
    """
    cdef unsigned int pFlags = 0
    cp = utils.HelperInputVoidPtr(p)
    cdef void* cp_ptr = <void*><void_ptr>cp.cptr
    err = ccuda.cuMemHostGetFlags(&pFlags, cp_ptr)
    return (CUresult(err), pFlags)

@cython.embedsignature(True)
def cuMemAllocManaged(size_t bytesize, unsigned int flags):
    """ Allocates memory that will be automatically managed by the Unified Memory system.

    Allocates `bytesize` bytes of managed memory on the device and returns
    in `*dptr` a pointer to the allocated memory. If the device doesn't
    support allocating managed memory, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    is returned. Support for managed memory can be queried using the device
    attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY`. The allocated
    memory is suitably aligned for any kind of variable. The memory is not
    cleared. If `bytesize` is 0, :py:obj:`~.cuMemAllocManaged` returns
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE`. The pointer is valid on the CPU
    and on all GPUs in the system that support managed memory. All accesses
    to this pointer must obey the Unified Memory programming model.

    `flags` specifies the default stream association for this allocation.
    `flags` must be one of :py:obj:`~.CU_MEM_ATTACH_GLOBAL` or
    :py:obj:`~.CU_MEM_ATTACH_HOST`. If :py:obj:`~.CU_MEM_ATTACH_GLOBAL` is
    specified, then this memory is accessible from any stream on any
    device. If :py:obj:`~.CU_MEM_ATTACH_HOST` is specified, then the
    allocation should not be accessed from devices that have a zero value
    for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`; an explicit
    call to :py:obj:`~.cuStreamAttachMemAsync` will be required to enable
    access on such devices.

    If the association is later changed via
    :py:obj:`~.cuStreamAttachMemAsync` to a single stream, the default
    association as specifed during :py:obj:`~.cuMemAllocManaged` is
    restored when that stream is destroyed. For managed variables, the
    default association is always :py:obj:`~.CU_MEM_ATTACH_GLOBAL`. Note
    that destroying a stream is an asynchronous operation, and as a result,
    the change to default association won't happen until all work in the
    stream has completed.

    Memory allocated with :py:obj:`~.cuMemAllocManaged` should be released
    with :py:obj:`~.cuMemFree`.

    Device memory oversubscription is possible for GPUs that have a non-
    zero value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. Managed
    memory on such GPUs may be evicted from device memory to host memory at
    any time by the Unified Memory driver in order to make room for other
    allocations.

    In a multi-GPU system where all GPUs have a non-zero value for the
    device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`, managed
    memory may not be populated when this API returns and instead may be
    populated on access. In such systems, managed memory can migrate to any
    processor's memory at any time. The Unified Memory driver will employ
    heuristics to maintain data locality and prevent excessive page faults
    to the extent possible. The application can also guide the driver about
    memory usage patterns via :py:obj:`~.cuMemAdvise`. The application can
    also explicitly migrate memory to a desired processor's memory via
    :py:obj:`~.cuMemPrefetchAsync`.

    In a multi-GPU system where all of the GPUs have a zero value for the
    device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` and all the
    GPUs have peer-to-peer support with each other, the physical storage
    for managed memory is created on the GPU which is active at the time
    :py:obj:`~.cuMemAllocManaged` is called. All other GPUs will reference
    the data at reduced bandwidth via peer mappings over the PCIe bus. The
    Unified Memory driver does not migrate memory among such GPUs.

    In a multi-GPU system where not all GPUs have peer-to-peer support with
    each other and where the value of the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` is zero for
    at least one of those GPUs, the location chosen for physical storage of
    managed memory is system-dependent.

    - On Linux, the location chosen will be device memory as long as the
      current set of active contexts are on devices that either have peer-
      to-peer support with each other or have a non-zero value for the
      device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. If there
      is an active context on a GPU that does not have a non-zero value for
      that device attribute and it does not have peer-to-peer support with
      the other devices that have active contexts on them, then the
      location for physical storage will be 'zero-copy' or host memory.
      Note that this means that managed memory that is located in device
      memory is migrated to host memory if a new context is created on a
      GPU that doesn't have a non-zero value for the device attribute and
      does not support peer-to-peer with at least one of the other devices
      that has an active context. This in turn implies that context
      creation may fail if there is insufficient host memory to migrate all
      managed allocations.

    - On Windows, the physical storage is always created in 'zero-copy' or
      host memory. All GPUs will reference the data at reduced bandwidth
      over the PCIe bus. In these circumstances, use of the environment
      variable CUDA_VISIBLE_DEVICES is recommended to restrict CUDA to only
      use those GPUs that have peer-to-peer support. Alternatively, users
      can also set CUDA_MANAGED_FORCE_DEVICE_ALLOC to a non-zero value to
      force the driver to always use device memory for physical storage.
      When this environment variable is set to a non-zero value, all
      contexts created in that process on devices that support managed
      memory have to be peer-to-peer compatible with each other. Context
      creation will fail if a context is created on a device that supports
      managed memory and is not peer-to-peer compatible with any of the
      other managed memory supporting devices on which contexts were
      previously created, even if those contexts have been destroyed. These
      environment variables are described in the CUDA programming guide
      under the "CUDA environment variables" section.

    - On ARM, managed memory is not available on discrete gpu with Drive
      PX-2.

    Parameters
    ----------
    bytesize : size_t
        Requested allocation size in bytes
    flags : unsigned int
        Must be one of :py:obj:`~.CU_MEM_ATTACH_GLOBAL` or
        :py:obj:`~.CU_MEM_ATTACH_HOST`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    dptr : :py:obj:`~.CUdeviceptr`
        Returned device pointer

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuStreamAttachMemAsync`, :py:obj:`~.cudaMallocManaged`
    """
    cdef CUdeviceptr dptr = CUdeviceptr()
    err = ccuda.cuMemAllocManaged(dptr._ptr, bytesize, flags)
    return (CUresult(err), dptr)

@cython.embedsignature(True)
def cuDeviceGetByPCIBusId(char* pciBusId):
    """ Returns a handle to a compute device.

    Returns in `*device` a device handle given a PCI bus ID string.

    where `domain`, `bus`, `device`, and `function` are all hexadecimal
    values

    Parameters
    ----------
    pciBusId : bytes
        String in one of the following forms:

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    dev : :py:obj:`~.CUdevice`
        Returned device handle

    See Also
    --------
    :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetPCIBusId`, :py:obj:`~.cudaDeviceGetByPCIBusId`
    """
    cdef CUdevice dev = CUdevice()
    err = ccuda.cuDeviceGetByPCIBusId(dev._ptr, pciBusId)
    return (CUresult(err), dev)

@cython.embedsignature(True)
def cuDeviceGetPCIBusId(int length, dev):
    """ Returns a PCI Bus Id string for the device.

    Returns an ASCII string identifying the device `dev` in the NULL-
    terminated string pointed to by `pciBusId`. `length` specifies the
    maximum length of the string that may be returned.

    where `domain`, `bus`, `device`, and `function` are all hexadecimal
    values. pciBusId should be large enough to store 13 characters
    including the NULL-terminator.

    Parameters
    ----------
    length : int
        Maximum length of string to store in `name`
    dev : :py:obj:`~.CUdevice`
        Device to get identifier string for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    pciBusId : bytes
        Returned identifier string for the device in the following format

    See Also
    --------
    :py:obj:`~.cuDeviceGet`, :py:obj:`~.cuDeviceGetAttribute`, :py:obj:`~.cuDeviceGetByPCIBusId`, :py:obj:`~.cudaDeviceGetPCIBusId`
    """
    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    pypciBusId = b" " * length
    cdef char* pciBusId = pypciBusId
    err = ccuda.cuDeviceGetPCIBusId(pciBusId, length, cdev)
    return (CUresult(err), pypciBusId)

@cython.embedsignature(True)
def cuIpcGetEventHandle(event):
    """ Gets an interprocess handle for a previously allocated event.

    Takes as input a previously allocated event. This event must have been
    created with the :py:obj:`~.CU_EVENT_INTERPROCESS` and
    :py:obj:`~.CU_EVENT_DISABLE_TIMING` flags set. This opaque handle may
    be copied into other processes and opened with
    :py:obj:`~.cuIpcOpenEventHandle` to allow efficient hardware
    synchronization between GPU work in different processes.

    After the event has been opened in the importing process,
    :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventSynchronize`,
    :py:obj:`~.cuStreamWaitEvent` and :py:obj:`~.cuEventQuery` may be used
    in either process. Performing operations on the imported event after
    the exported event has been freed with :py:obj:`~.cuEventDestroy` will
    result in undefined behavior.

    IPC functionality is restricted to devices with support for unified
    addressing on Linux and Windows operating systems. IPC functionality on
    Windows is restricted to GPUs in TCC mode

    Parameters
    ----------
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event allocated with :py:obj:`~.CU_EVENT_INTERPROCESS` and
        :py:obj:`~.CU_EVENT_DISABLE_TIMING` flags.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_MAP_FAILED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pHandle : :py:obj:`~.CUipcEventHandle`
        Pointer to a user allocated CUipcEventHandle in which to return the
        opaque event handle

    See Also
    --------
    :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuIpcOpenEventHandle`, :py:obj:`~.cuIpcGetMemHandle`, :py:obj:`~.cuIpcOpenMemHandle`, :py:obj:`~.cuIpcCloseMemHandle`, :py:obj:`~.cudaIpcGetEventHandle`
    """
    cdef ccuda.CUevent cevent
    if event is None:
        cevent = <ccuda.CUevent><void_ptr>0
    elif isinstance(event, (CUevent)):
        pevent = int(event)
        cevent = <ccuda.CUevent><void_ptr>pevent
    else:
        pevent = int(CUevent(event))
        cevent = <ccuda.CUevent><void_ptr>pevent

    cdef CUipcEventHandle pHandle = CUipcEventHandle()
    err = ccuda.cuIpcGetEventHandle(pHandle._ptr, cevent)
    return (CUresult(err), pHandle)

@cython.embedsignature(True)
def cuIpcOpenEventHandle(handle not None : CUipcEventHandle):
    """ Opens an interprocess event handle for use in the current process.

    Opens an interprocess event handle exported from another process with
    :py:obj:`~.cuIpcGetEventHandle`. This function returns a
    :py:obj:`~.CUevent` that behaves like a locally created event with the
    :py:obj:`~.CU_EVENT_DISABLE_TIMING` flag specified. This event must be
    freed with :py:obj:`~.cuEventDestroy`.

    Performing operations on the imported event after the exported event
    has been freed with :py:obj:`~.cuEventDestroy` will result in undefined
    behavior.

    IPC functionality is restricted to devices with support for unified
    addressing on Linux and Windows operating systems. IPC functionality on
    Windows is restricted to GPUs in TCC mode

    Parameters
    ----------
    handle : :py:obj:`~.CUipcEventHandle`
        Interprocess handle to open

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_MAP_FAILED`, :py:obj:`~.CUDA_ERROR_PEER_ACCESS_UNSUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phEvent : :py:obj:`~.CUevent`
        Returns the imported event

    See Also
    --------
    :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuIpcGetEventHandle`, :py:obj:`~.cuIpcGetMemHandle`, :py:obj:`~.cuIpcOpenMemHandle`, :py:obj:`~.cuIpcCloseMemHandle`, :py:obj:`~.cudaIpcOpenEventHandle`
    """
    cdef CUevent phEvent = CUevent()
    err = ccuda.cuIpcOpenEventHandle(phEvent._ptr, handle._ptr[0])
    return (CUresult(err), phEvent)

@cython.embedsignature(True)
def cuIpcGetMemHandle(dptr):
    """ Gets an interprocess memory handle for an existing device memory allocation.

    Takes a pointer to the base of an existing device memory allocation
    created with :py:obj:`~.cuMemAlloc` and exports it for use in another
    process. This is a lightweight operation and may be called multiple
    times on an allocation without adverse effects.

    If a region of memory is freed with :py:obj:`~.cuMemFree` and a
    subsequent call to :py:obj:`~.cuMemAlloc` returns memory with the same
    device address, :py:obj:`~.cuIpcGetMemHandle` will return a unique
    handle for the new memory.

    IPC functionality is restricted to devices with support for unified
    addressing on Linux and Windows operating systems. IPC functionality on
    Windows is restricted to GPUs in TCC mode

    Parameters
    ----------
    dptr : :py:obj:`~.CUdeviceptr`
        Base pointer to previously allocated device memory

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_MAP_FAILED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pHandle : :py:obj:`~.CUipcMemHandle`
        Pointer to user allocated :py:obj:`~.CUipcMemHandle` to return the
        handle in.

    See Also
    --------
    :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuIpcGetEventHandle`, :py:obj:`~.cuIpcOpenEventHandle`, :py:obj:`~.cuIpcOpenMemHandle`, :py:obj:`~.cuIpcCloseMemHandle`, :py:obj:`~.cudaIpcGetMemHandle`
    """
    cdef ccuda.CUdeviceptr cdptr
    if dptr is None:
        cdptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dptr, (CUdeviceptr)):
        pdptr = int(dptr)
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr
    else:
        pdptr = int(CUdeviceptr(dptr))
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr

    cdef CUipcMemHandle pHandle = CUipcMemHandle()
    err = ccuda.cuIpcGetMemHandle(pHandle._ptr, cdptr)
    return (CUresult(err), pHandle)

@cython.embedsignature(True)
def cuIpcOpenMemHandle(handle not None : CUipcMemHandle, unsigned int Flags):
    """ Opens an interprocess memory handle exported from another process and returns a device pointer usable in the local process.

    Maps memory exported from another process with
    :py:obj:`~.cuIpcGetMemHandle` into the current device address space.
    For contexts on different devices :py:obj:`~.cuIpcOpenMemHandle` can
    attempt to enable peer access between the devices as if the user called
    :py:obj:`~.cuCtxEnablePeerAccess`. This behavior is controlled by the
    :py:obj:`~.CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS` flag.
    :py:obj:`~.cuDeviceCanAccessPeer` can determine if a mapping is
    possible.

    Contexts that may open :py:obj:`~.CUipcMemHandles` are restricted in
    the following way. :py:obj:`~.CUipcMemHandles` from each
    :py:obj:`~.CUdevice` in a given process may only be opened by one
    :py:obj:`~.CUcontext` per :py:obj:`~.CUdevice` per other process.

    If the memory handle has already been opened by the current context,
    the reference count on the handle is incremented by 1 and the existing
    device pointer is returned.

    Memory returned from :py:obj:`~.cuIpcOpenMemHandle` must be freed with
    :py:obj:`~.cuIpcCloseMemHandle`.

    Calling :py:obj:`~.cuMemFree` on an exported memory region before
    calling :py:obj:`~.cuIpcCloseMemHandle` in the importing context will
    result in undefined behavior.

    IPC functionality is restricted to devices with support for unified
    addressing on Linux and Windows operating systems. IPC functionality on
    Windows is restricted to GPUs in TCC mode

    Parameters
    ----------
    handle : :py:obj:`~.CUipcMemHandle`
        :py:obj:`~.CUipcMemHandle` to open
    Flags : unsigned int
        Flags for this operation. Must be specified as
        :py:obj:`~.CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_MAP_FAILED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_TOO_MANY_PEERS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pdptr : :py:obj:`~.CUdeviceptr`
        Returned device pointer

    See Also
    --------
    :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuIpcGetEventHandle`, :py:obj:`~.cuIpcOpenEventHandle`, :py:obj:`~.cuIpcGetMemHandle`, :py:obj:`~.cuIpcCloseMemHandle`, :py:obj:`~.cuCtxEnablePeerAccess`, :py:obj:`~.cuDeviceCanAccessPeer`, :py:obj:`~.cudaIpcOpenMemHandle`

    Notes
    -----
    No guarantees are made about the address returned in `*pdptr`. In particular, multiple processes may not receive the same address for the same `handle`.
    """
    cdef CUdeviceptr pdptr = CUdeviceptr()
    err = ccuda.cuIpcOpenMemHandle(pdptr._ptr, handle._ptr[0], Flags)
    return (CUresult(err), pdptr)

@cython.embedsignature(True)
def cuIpcCloseMemHandle(dptr):
    """ Attempts to close memory mapped with :py:obj:`~.cuIpcOpenMemHandle`.

    Decrements the reference count of the memory returned by
    :py:obj:`~.cuIpcOpenMemHandle` by 1. When the reference count reaches
    0, this API unmaps the memory. The original allocation in the exporting
    process as well as imported mappings in other processes will be
    unaffected.

    Any resources used to enable peer access will be freed if this is the
    last mapping using them.

    IPC functionality is restricted to devices with support for unified
    addressing on Linux and Windows operating systems. IPC functionality on
    Windows is restricted to GPUs in TCC mode

    Parameters
    ----------
    dptr : :py:obj:`~.CUdeviceptr`
        Device pointer returned by :py:obj:`~.cuIpcOpenMemHandle`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_MAP_FAILED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuIpcGetEventHandle`, :py:obj:`~.cuIpcOpenEventHandle`, :py:obj:`~.cuIpcGetMemHandle`, :py:obj:`~.cuIpcOpenMemHandle`, :py:obj:`~.cudaIpcCloseMemHandle`
    """
    cdef ccuda.CUdeviceptr cdptr
    if dptr is None:
        cdptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dptr, (CUdeviceptr)):
        pdptr = int(dptr)
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr
    else:
        pdptr = int(CUdeviceptr(dptr))
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr

    err = ccuda.cuIpcCloseMemHandle(cdptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemHostRegister(p, size_t bytesize, unsigned int Flags):
    """ Registers an existing host memory range for use by CUDA.

    Page-locks the memory range specified by `p` and `bytesize` and maps it
    for the device(s) as specified by `Flags`. This memory range also is
    added to the same tracking mechanism as :py:obj:`~.cuMemHostAlloc` to
    automatically accelerate calls to functions such as
    :py:obj:`~.cuMemcpyHtoD()`. Since the memory can be accessed directly
    by the device, it can be read or written with much higher bandwidth
    than pageable memory that has not been registered. Page-locking
    excessive amounts of memory may degrade system performance, since it
    reduces the amount of memory available to the system for paging. As a
    result, this function is best used sparingly to register staging areas
    for data exchange between host and device.

    The `Flags` parameter enables different options to be specified that
    affect the allocation, as follows.

    - :py:obj:`~.CU_MEMHOSTREGISTER_PORTABLE`: The memory returned by this
      call will be considered as pinned memory by all CUDA contexts, not
      just the one that performed the allocation.

    - :py:obj:`~.CU_MEMHOSTREGISTER_DEVICEMAP`: Maps the allocation into
      the CUDA address space. The device pointer to the memory may be
      obtained by calling :py:obj:`~.cuMemHostGetDevicePointer()`.

    - :py:obj:`~.CU_MEMHOSTREGISTER_IOMEMORY`: The pointer is treated as
      pointing to some I/O memory space, e.g. the PCI Express resource of a
      3rd party device.

    - :py:obj:`~.CU_MEMHOSTREGISTER_READ_ONLY`: The pointer is treated as
      pointing to memory that is considered read-only by the device. On
      platforms without
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
      this flag is required in order to register memory mapped to the CPU
      as read-only. Support for the use of this flag can be queried from
      the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED`.
      Using this flag with a current context associated with a device that
      does not have this attribute set will cause
      :py:obj:`~.cuMemHostRegister` to error with CUDA_ERROR_NOT_SUPPORTED.

    All of these flags are orthogonal to one another: a developer may page-
    lock memory that is portable or mapped with no restrictions.

    The :py:obj:`~.CU_MEMHOSTREGISTER_DEVICEMAP` flag may be specified on
    CUDA contexts for devices that do not support mapped pinned memory. The
    failure is deferred to :py:obj:`~.cuMemHostGetDevicePointer()` because
    the memory may be mapped into other CUDA contexts via the
    :py:obj:`~.CU_MEMHOSTREGISTER_PORTABLE` flag.

    For devices that have a non-zero value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM`,
    the memory can also be accessed from the device using the host pointer
    `p`. The device pointer returned by
    :py:obj:`~.cuMemHostGetDevicePointer()` may or may not match the
    original host pointer `ptr` and depends on the devices visible to the
    application. If all devices visible to the application have a non-zero
    value for the device attribute, the device pointer returned by
    :py:obj:`~.cuMemHostGetDevicePointer()` will match the original pointer
    `ptr`. If any device visible to the application has a zero value for
    the device attribute, the device pointer returned by
    :py:obj:`~.cuMemHostGetDevicePointer()` will not match the original
    host pointer `ptr`, but it will be suitable for use on all devices
    provided Unified Virtual Addressing is enabled. In such systems, it is
    valid to access the memory using either pointer on devices that have a
    non-zero value for the device attribute. Note however that such devices
    should access the memory using only of the two pointers and not both.

    The memory page-locked by this function must be unregistered with
    :py:obj:`~.cuMemHostUnregister()`.

    Parameters
    ----------
    p : Any
        Host pointer to memory to page-lock
    bytesize : size_t
        Size in bytes of the address range to page-lock
    Flags : unsigned int
        Flags for allocation request

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuMemHostUnregister`, :py:obj:`~.cuMemHostGetFlags`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cudaHostRegister`
    """
    cp = utils.HelperInputVoidPtr(p)
    cdef void* cp_ptr = <void*><void_ptr>cp.cptr
    err = ccuda.cuMemHostRegister(cp_ptr, bytesize, Flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemHostUnregister(p):
    """ Unregisters a memory range that was registered with cuMemHostRegister.

    Unmaps the memory range whose base address is specified by `p`, and
    makes it pageable again.

    The base address must be the same one specified to
    :py:obj:`~.cuMemHostRegister()`.

    Parameters
    ----------
    p : Any
        Host pointer to memory to unregister

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED`,

    See Also
    --------
    :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cudaHostUnregister`
    """
    cp = utils.HelperInputVoidPtr(p)
    cdef void* cp_ptr = <void*><void_ptr>cp.cptr
    err = ccuda.cuMemHostUnregister(cp_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpy(dst, src, size_t ByteCount):
    """ Copies memory.

    Copies data between two pointers. `dst` and `src` are base pointers of
    the destination and source, respectively. `ByteCount` specifies the
    number of bytes to copy. Note that this function infers the type of the
    transfer (host to host, host to device, device to device, or device to
    host) from the pointer values. This function is only allowed in
    contexts which support unified addressing.

    Parameters
    ----------
    dst : :py:obj:`~.CUdeviceptr`
        Destination unified virtual address space pointer
    src : :py:obj:`~.CUdeviceptr`
        Source unified virtual address space pointer
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`
    """
    cdef ccuda.CUdeviceptr csrc
    if src is None:
        csrc = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(src, (CUdeviceptr)):
        psrc = int(src)
        csrc = <ccuda.CUdeviceptr><void_ptr>psrc
    else:
        psrc = int(CUdeviceptr(src))
        csrc = <ccuda.CUdeviceptr><void_ptr>psrc

    cdef ccuda.CUdeviceptr cdst
    if dst is None:
        cdst = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dst, (CUdeviceptr)):
        pdst = int(dst)
        cdst = <ccuda.CUdeviceptr><void_ptr>pdst
    else:
        pdst = int(CUdeviceptr(dst))
        cdst = <ccuda.CUdeviceptr><void_ptr>pdst

    err = ccuda.cuMemcpy(cdst, csrc, ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyPeer(dstDevice, dstContext, srcDevice, srcContext, size_t ByteCount):
    """ Copies device memory between two contexts.

    Copies from device memory in one context to device memory in another
    context. `dstDevice` is the base device pointer of the destination
    memory and `dstContext` is the destination context. `srcDevice` is the
    base device pointer of the source memory and `srcContext` is the source
    pointer. `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    dstContext : :py:obj:`~.CUcontext`
        Destination context
    srcDevice : :py:obj:`~.CUdeviceptr`
        Source device pointer
    srcContext : :py:obj:`~.CUcontext`
        Source context
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpy3DPeer`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyPeerAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cudaMemcpyPeer`
    """
    cdef ccuda.CUcontext csrcContext
    if srcContext is None:
        csrcContext = <ccuda.CUcontext><void_ptr>0
    elif isinstance(srcContext, (CUcontext)):
        psrcContext = int(srcContext)
        csrcContext = <ccuda.CUcontext><void_ptr>psrcContext
    else:
        psrcContext = int(CUcontext(srcContext))
        csrcContext = <ccuda.CUcontext><void_ptr>psrcContext

    cdef ccuda.CUdeviceptr csrcDevice
    if srcDevice is None:
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(srcDevice, (CUdeviceptr)):
        psrcDevice = int(srcDevice)
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice
    else:
        psrcDevice = int(CUdeviceptr(srcDevice))
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice

    cdef ccuda.CUcontext cdstContext
    if dstContext is None:
        cdstContext = <ccuda.CUcontext><void_ptr>0
    elif isinstance(dstContext, (CUcontext)):
        pdstContext = int(dstContext)
        cdstContext = <ccuda.CUcontext><void_ptr>pdstContext
    else:
        pdstContext = int(CUcontext(dstContext))
        cdstContext = <ccuda.CUcontext><void_ptr>pdstContext

    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    err = ccuda.cuMemcpyPeer(cdstDevice, cdstContext, csrcDevice, csrcContext, ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyHtoD(dstDevice, srcHost, size_t ByteCount):
    """ Copies memory from Host to Device.

    Copies from host memory to device memory. `dstDevice` and `srcHost` are
    the base addresses of the destination and source, respectively.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    srcHost : Any
        Source host pointer
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyToSymbol`
    """
    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    csrcHost = utils.HelperInputVoidPtr(srcHost)
    cdef void* csrcHost_ptr = <void*><void_ptr>csrcHost.cptr
    err = ccuda.cuMemcpyHtoD(cdstDevice, csrcHost_ptr, ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyDtoH(dstHost, srcDevice, size_t ByteCount):
    """ Copies memory from Device to Host.

    Copies from device to host memory. `dstHost` and `srcDevice` specify
    the base pointers of the destination and source, respectively.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstHost : Any
        Destination host pointer
    srcDevice : :py:obj:`~.CUdeviceptr`
        Source device pointer
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyFromSymbol`
    """
    cdef ccuda.CUdeviceptr csrcDevice
    if srcDevice is None:
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(srcDevice, (CUdeviceptr)):
        psrcDevice = int(srcDevice)
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice
    else:
        psrcDevice = int(CUdeviceptr(srcDevice))
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice

    cdstHost = utils.HelperInputVoidPtr(dstHost)
    cdef void* cdstHost_ptr = <void*><void_ptr>cdstHost.cptr
    err = ccuda.cuMemcpyDtoH(cdstHost_ptr, csrcDevice, ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyDtoD(dstDevice, srcDevice, size_t ByteCount):
    """ Copies memory from Device to Device.

    Copies from device memory to device memory. `dstDevice` and `srcDevice`
    are the base pointers of the destination and source, respectively.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    srcDevice : :py:obj:`~.CUdeviceptr`
        Source device pointer
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy`, :py:obj:`~.cudaMemcpyToSymbol`, :py:obj:`~.cudaMemcpyFromSymbol`
    """
    cdef ccuda.CUdeviceptr csrcDevice
    if srcDevice is None:
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(srcDevice, (CUdeviceptr)):
        psrcDevice = int(srcDevice)
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice
    else:
        psrcDevice = int(CUdeviceptr(srcDevice))
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice

    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    err = ccuda.cuMemcpyDtoD(cdstDevice, csrcDevice, ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyDtoA(dstArray, size_t dstOffset, srcDevice, size_t ByteCount):
    """ Copies memory from Device to Array.

    Copies from device memory to a 1D CUDA array. `dstArray` and
    `dstOffset` specify the CUDA array handle and starting index of the
    destination data. `srcDevice` specifies the base pointer of the source.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstArray : :py:obj:`~.CUarray`
        Destination array
    dstOffset : size_t
        Offset in bytes of destination array
    srcDevice : :py:obj:`~.CUdeviceptr`
        Source device pointer
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpyToArray`
    """
    cdef ccuda.CUdeviceptr csrcDevice
    if srcDevice is None:
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(srcDevice, (CUdeviceptr)):
        psrcDevice = int(srcDevice)
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice
    else:
        psrcDevice = int(CUdeviceptr(srcDevice))
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice

    cdef ccuda.CUarray cdstArray
    if dstArray is None:
        cdstArray = <ccuda.CUarray><void_ptr>0
    elif isinstance(dstArray, (CUarray)):
        pdstArray = int(dstArray)
        cdstArray = <ccuda.CUarray><void_ptr>pdstArray
    else:
        pdstArray = int(CUarray(dstArray))
        cdstArray = <ccuda.CUarray><void_ptr>pdstArray

    err = ccuda.cuMemcpyDtoA(cdstArray, dstOffset, csrcDevice, ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyAtoD(dstDevice, srcArray, size_t srcOffset, size_t ByteCount):
    """ Copies memory from Array to Device.

    Copies from one 1D CUDA array to device memory. `dstDevice` specifies
    the base pointer of the destination and must be naturally aligned with
    the CUDA array elements. `srcArray` and `srcOffset` specify the CUDA
    array handle and the offset in bytes into the array where the copy is
    to begin. `ByteCount` specifies the number of bytes to copy and must be
    evenly divisible by the array element size.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    srcArray : :py:obj:`~.CUarray`
        Source array
    srcOffset : size_t
        Offset in bytes of source array
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpyFromArray`
    """
    cdef ccuda.CUarray csrcArray
    if srcArray is None:
        csrcArray = <ccuda.CUarray><void_ptr>0
    elif isinstance(srcArray, (CUarray)):
        psrcArray = int(srcArray)
        csrcArray = <ccuda.CUarray><void_ptr>psrcArray
    else:
        psrcArray = int(CUarray(srcArray))
        csrcArray = <ccuda.CUarray><void_ptr>psrcArray

    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    err = ccuda.cuMemcpyAtoD(cdstDevice, csrcArray, srcOffset, ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyHtoA(dstArray, size_t dstOffset, srcHost, size_t ByteCount):
    """ Copies memory from Host to Array.

    Copies from host memory to a 1D CUDA array. `dstArray` and `dstOffset`
    specify the CUDA array handle and starting offset in bytes of the
    destination data. `pSrc` specifies the base address of the source.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstArray : :py:obj:`~.CUarray`
        Destination array
    dstOffset : size_t
        Offset in bytes of destination array
    srcHost : Any
        Source host pointer
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpyToArray`
    """
    cdef ccuda.CUarray cdstArray
    if dstArray is None:
        cdstArray = <ccuda.CUarray><void_ptr>0
    elif isinstance(dstArray, (CUarray)):
        pdstArray = int(dstArray)
        cdstArray = <ccuda.CUarray><void_ptr>pdstArray
    else:
        pdstArray = int(CUarray(dstArray))
        cdstArray = <ccuda.CUarray><void_ptr>pdstArray

    csrcHost = utils.HelperInputVoidPtr(srcHost)
    cdef void* csrcHost_ptr = <void*><void_ptr>csrcHost.cptr
    err = ccuda.cuMemcpyHtoA(cdstArray, dstOffset, csrcHost_ptr, ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyAtoH(dstHost, srcArray, size_t srcOffset, size_t ByteCount):
    """ Copies memory from Array to Host.

    Copies from one 1D CUDA array to host memory. `dstHost` specifies the
    base pointer of the destination. `srcArray` and `srcOffset` specify the
    CUDA array handle and starting offset in bytes of the source data.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstHost : Any
        Destination device pointer
    srcArray : :py:obj:`~.CUarray`
        Source array
    srcOffset : size_t
        Offset in bytes of source array
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpyFromArray`
    """
    cdef ccuda.CUarray csrcArray
    if srcArray is None:
        csrcArray = <ccuda.CUarray><void_ptr>0
    elif isinstance(srcArray, (CUarray)):
        psrcArray = int(srcArray)
        csrcArray = <ccuda.CUarray><void_ptr>psrcArray
    else:
        psrcArray = int(CUarray(srcArray))
        csrcArray = <ccuda.CUarray><void_ptr>psrcArray

    cdstHost = utils.HelperInputVoidPtr(dstHost)
    cdef void* cdstHost_ptr = <void*><void_ptr>cdstHost.cptr
    err = ccuda.cuMemcpyAtoH(cdstHost_ptr, csrcArray, srcOffset, ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyAtoA(dstArray, size_t dstOffset, srcArray, size_t srcOffset, size_t ByteCount):
    """ Copies memory from Array to Array.

    Copies from one 1D CUDA array to another. `dstArray` and `srcArray`
    specify the handles of the destination and source CUDA arrays for the
    copy, respectively. `dstOffset` and `srcOffset` specify the destination
    and source offsets in bytes into the CUDA arrays. `ByteCount` is the
    number of bytes to be copied. The size of the elements in the CUDA
    arrays need not be the same format, but the elements must be the same
    size; and count must be evenly divisible by that size.

    Parameters
    ----------
    dstArray : :py:obj:`~.CUarray`
        Destination array
    dstOffset : size_t
        Offset in bytes of destination array
    srcArray : :py:obj:`~.CUarray`
        Source array
    srcOffset : size_t
        Offset in bytes of source array
    ByteCount : size_t
        Size of memory copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpyArrayToArray`
    """
    cdef ccuda.CUarray csrcArray
    if srcArray is None:
        csrcArray = <ccuda.CUarray><void_ptr>0
    elif isinstance(srcArray, (CUarray)):
        psrcArray = int(srcArray)
        csrcArray = <ccuda.CUarray><void_ptr>psrcArray
    else:
        psrcArray = int(CUarray(srcArray))
        csrcArray = <ccuda.CUarray><void_ptr>psrcArray

    cdef ccuda.CUarray cdstArray
    if dstArray is None:
        cdstArray = <ccuda.CUarray><void_ptr>0
    elif isinstance(dstArray, (CUarray)):
        pdstArray = int(dstArray)
        cdstArray = <ccuda.CUarray><void_ptr>pdstArray
    else:
        pdstArray = int(CUarray(dstArray))
        cdstArray = <ccuda.CUarray><void_ptr>pdstArray

    err = ccuda.cuMemcpyAtoA(cdstArray, dstOffset, csrcArray, srcOffset, ByteCount)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpy2D(pCopy : CUDA_MEMCPY2D):
    """ Copies memory for 2D arrays.

    Perform a 2D memory copy according to the parameters specified in
    `pCopy`. The :py:obj:`~.CUDA_MEMCPY2D` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.srcMemoryType` and :py:obj:`~.dstMemoryType` specify the
      type of memory of the source and destination, respectively;
      :py:obj:`~.CUmemorytype_enum` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.srcArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.srcHost` and :py:obj:`~.srcPitch` specify the (host) base
    address of the source data and the bytes per row to apply.
    :py:obj:`~.srcArray` is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (device)
    base address of the source data and the bytes per row to apply.
    :py:obj:`~.srcArray` is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.srcArray` specifies the handle of the source data.
    :py:obj:`~.srcHost`, :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` are
    ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.dstHost` and :py:obj:`~.dstPitch` specify the (host) base
    address of the destination data and the bytes per row to apply.
    :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.dstArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (device)
    base address of the destination data and the bytes per row to apply.
    :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.dstArray` specifies the handle of the destination data.
    :py:obj:`~.dstHost`, :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` are
    ignored.

    - :py:obj:`~.srcXInBytes` and :py:obj:`~.srcY` specify the base address
      of the source data for the copy.

    For host pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.srcXInBytes` must be evenly divisible by
    the array element size.

    - :py:obj:`~.dstXInBytes` and :py:obj:`~.dstY` specify the base address
      of the destination data for the copy.

    For host pointers, the base address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.dstXInBytes` must be evenly divisible by
    the array element size.

    - :py:obj:`~.WidthInBytes` and :py:obj:`~.Height` specify the width (in
      bytes) and height of the 2D copy being performed.

    - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
      :py:obj:`~.dstPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + dstXInBytes.

    :py:obj:`~.cuMemcpy2D()` returns an error if any pitch is greater than
    the maximum allowed (:py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PITCH`).
    :py:obj:`~.cuMemAllocPitch()` passes back pitches that always work with
    :py:obj:`~.cuMemcpy2D()`. On intra-device memory copies (device to
    device, CUDA array to device, CUDA array to CUDA array),
    :py:obj:`~.cuMemcpy2D()` may fail for pitches not computed by
    :py:obj:`~.cuMemAllocPitch()`. :py:obj:`~.cuMemcpy2DUnaligned()` does
    not have this restriction, but may run significantly slower in the
    cases where :py:obj:`~.cuMemcpy2D()` would have returned an error code.

    Parameters
    ----------
    pCopy : :py:obj:`~.CUDA_MEMCPY2D`
        Parameters for the memory copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpy2DFromArray`
    """
    cdef ccuda.CUDA_MEMCPY2D* cpCopy_ptr = pCopy._ptr if pCopy != None else NULL
    err = ccuda.cuMemcpy2D(cpCopy_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpy2DUnaligned(pCopy : CUDA_MEMCPY2D):
    """ Copies memory for 2D arrays.

    Perform a 2D memory copy according to the parameters specified in
    `pCopy`. The :py:obj:`~.CUDA_MEMCPY2D` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.srcMemoryType` and :py:obj:`~.dstMemoryType` specify the
      type of memory of the source and destination, respectively;
      :py:obj:`~.CUmemorytype_enum` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.srcArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.srcHost` and :py:obj:`~.srcPitch` specify the (host) base
    address of the source data and the bytes per row to apply.
    :py:obj:`~.srcArray` is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (device)
    base address of the source data and the bytes per row to apply.
    :py:obj:`~.srcArray` is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.srcArray` specifies the handle of the source data.
    :py:obj:`~.srcHost`, :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` are
    ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.dstArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.dstHost` and :py:obj:`~.dstPitch` specify the (host) base
    address of the destination data and the bytes per row to apply.
    :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (device)
    base address of the destination data and the bytes per row to apply.
    :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.dstArray` specifies the handle of the destination data.
    :py:obj:`~.dstHost`, :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` are
    ignored.

    - :py:obj:`~.srcXInBytes` and :py:obj:`~.srcY` specify the base address
      of the source data for the copy.

    For host pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.srcXInBytes` must be evenly divisible by
    the array element size.

    - :py:obj:`~.dstXInBytes` and :py:obj:`~.dstY` specify the base address
      of the destination data for the copy.

    For host pointers, the base address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.dstXInBytes` must be evenly divisible by
    the array element size.

    - :py:obj:`~.WidthInBytes` and :py:obj:`~.Height` specify the width (in
      bytes) and height of the 2D copy being performed.

    - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
      :py:obj:`~.dstPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + dstXInBytes.

    :py:obj:`~.cuMemcpy2D()` returns an error if any pitch is greater than
    the maximum allowed (:py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PITCH`).
    :py:obj:`~.cuMemAllocPitch()` passes back pitches that always work with
    :py:obj:`~.cuMemcpy2D()`. On intra-device memory copies (device to
    device, CUDA array to device, CUDA array to CUDA array),
    :py:obj:`~.cuMemcpy2D()` may fail for pitches not computed by
    :py:obj:`~.cuMemAllocPitch()`. :py:obj:`~.cuMemcpy2DUnaligned()` does
    not have this restriction, but may run significantly slower in the
    cases where :py:obj:`~.cuMemcpy2D()` would have returned an error code.

    Parameters
    ----------
    pCopy : :py:obj:`~.CUDA_MEMCPY2D`
        Parameters for the memory copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy2D`, :py:obj:`~.cudaMemcpy2DToArray`, :py:obj:`~.cudaMemcpy2DFromArray`
    """
    cdef ccuda.CUDA_MEMCPY2D* cpCopy_ptr = pCopy._ptr if pCopy != None else NULL
    err = ccuda.cuMemcpy2DUnaligned(cpCopy_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpy3D(pCopy : CUDA_MEMCPY3D):
    """ Copies memory for 3D arrays.

    Perform a 3D memory copy according to the parameters specified in
    `pCopy`. The :py:obj:`~.CUDA_MEMCPY3D` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.srcMemoryType` and :py:obj:`~.dstMemoryType` specify the
      type of memory of the source and destination, respectively;
      :py:obj:`~.CUmemorytype_enum` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.srcArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.srcHost`, :py:obj:`~.srcPitch` and :py:obj:`~.srcHeight`
    specify the (host) base address of the source data, the bytes per row,
    and the height of each 2D slice of the 3D array. :py:obj:`~.srcArray`
    is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.srcDevice`, :py:obj:`~.srcPitch` and :py:obj:`~.srcHeight`
    specify the (device) base address of the source data, the bytes per
    row, and the height of each 2D slice of the 3D array.
    :py:obj:`~.srcArray` is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.srcArray` specifies the handle of the source data.
    :py:obj:`~.srcHost`, :py:obj:`~.srcDevice`, :py:obj:`~.srcPitch` and
    :py:obj:`~.srcHeight` are ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.dstArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.dstHost` and :py:obj:`~.dstPitch` specify the (host) base
    address of the destination data, the bytes per row, and the height of
    each 2D slice of the 3D array. :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (device)
    base address of the destination data, the bytes per row, and the height
    of each 2D slice of the 3D array. :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.dstArray` specifies the handle of the destination data.
    :py:obj:`~.dstHost`, :py:obj:`~.dstDevice`, :py:obj:`~.dstPitch` and
    :py:obj:`~.dstHeight` are ignored.

    - :py:obj:`~.srcXInBytes`, :py:obj:`~.srcY` and :py:obj:`~.srcZ`
      specify the base address of the source data for the copy.

    For host pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.srcXInBytes` must be evenly divisible by
    the array element size.

    - dstXInBytes, :py:obj:`~.dstY` and :py:obj:`~.dstZ` specify the base
      address of the destination data for the copy.

    For host pointers, the base address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.dstXInBytes` must be evenly divisible by
    the array element size.

    - :py:obj:`~.WidthInBytes`, :py:obj:`~.Height` and :py:obj:`~.Depth`
      specify the width (in bytes), height and depth of the 3D copy being
      performed.

    - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
      :py:obj:`~.dstPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + dstXInBytes.

    - If specified, :py:obj:`~.srcHeight` must be greater than or equal to
      :py:obj:`~.Height` + :py:obj:`~.srcY`, and :py:obj:`~.dstHeight` must
      be greater than or equal to :py:obj:`~.Height` + :py:obj:`~.dstY`.

    :py:obj:`~.cuMemcpy3D()` returns an error if any pitch is greater than
    the maximum allowed (:py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PITCH`).

    The :py:obj:`~.srcLOD` and :py:obj:`~.dstLOD` members of the
    :py:obj:`~.CUDA_MEMCPY3D` structure must be set to 0.

    Parameters
    ----------
    pCopy : :py:obj:`~.CUDA_MEMCPY3D`
        Parameters for the memory copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemcpy3D`
    """
    cdef ccuda.CUDA_MEMCPY3D* cpCopy_ptr = pCopy._ptr if pCopy != None else NULL
    err = ccuda.cuMemcpy3D(cpCopy_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpy3DPeer(pCopy : CUDA_MEMCPY3D_PEER):
    """ Copies memory between contexts.

    Perform a 3D memory copy according to the parameters specified in
    `pCopy`. See the definition of the :py:obj:`~.CUDA_MEMCPY3D_PEER`
    structure for documentation of its parameters.

    Parameters
    ----------
    pCopy : :py:obj:`~.CUDA_MEMCPY3D_PEER`
        Parameters for the memory copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyPeer`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyPeerAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cudaMemcpy3DPeer`
    """
    cdef ccuda.CUDA_MEMCPY3D_PEER* cpCopy_ptr = pCopy._ptr if pCopy != None else NULL
    err = ccuda.cuMemcpy3DPeer(cpCopy_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyAsync(dst, src, size_t ByteCount, hStream):
    """ Copies memory asynchronously.

    Copies data between two pointers. `dst` and `src` are base pointers of
    the destination and source, respectively. `ByteCount` specifies the
    number of bytes to copy. Note that this function infers the type of the
    transfer (host to host, host to device, device to device, or device to
    host) from the pointer values. This function is only allowed in
    contexts which support unified addressing.

    Parameters
    ----------
    dst : :py:obj:`~.CUdeviceptr`
        Destination unified virtual address space pointer
    src : :py:obj:`~.CUdeviceptr`
        Source unified virtual address space pointer
    ByteCount : size_t
        Size of memory copy in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUdeviceptr csrc
    if src is None:
        csrc = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(src, (CUdeviceptr)):
        psrc = int(src)
        csrc = <ccuda.CUdeviceptr><void_ptr>psrc
    else:
        psrc = int(CUdeviceptr(src))
        csrc = <ccuda.CUdeviceptr><void_ptr>psrc

    cdef ccuda.CUdeviceptr cdst
    if dst is None:
        cdst = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dst, (CUdeviceptr)):
        pdst = int(dst)
        cdst = <ccuda.CUdeviceptr><void_ptr>pdst
    else:
        pdst = int(CUdeviceptr(dst))
        cdst = <ccuda.CUdeviceptr><void_ptr>pdst

    err = ccuda.cuMemcpyAsync(cdst, csrc, ByteCount, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyPeerAsync(dstDevice, dstContext, srcDevice, srcContext, size_t ByteCount, hStream):
    """ Copies device memory between two contexts asynchronously.

    Copies from device memory in one context to device memory in another
    context. `dstDevice` is the base device pointer of the destination
    memory and `dstContext` is the destination context. `srcDevice` is the
    base device pointer of the source memory and `srcContext` is the source
    pointer. `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    dstContext : :py:obj:`~.CUcontext`
        Destination context
    srcDevice : :py:obj:`~.CUdeviceptr`
        Source device pointer
    srcContext : :py:obj:`~.CUcontext`
        Source context
    ByteCount : size_t
        Size of memory copy in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyPeer`, :py:obj:`~.cuMemcpy3DPeer`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cudaMemcpyPeerAsync`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUcontext csrcContext
    if srcContext is None:
        csrcContext = <ccuda.CUcontext><void_ptr>0
    elif isinstance(srcContext, (CUcontext)):
        psrcContext = int(srcContext)
        csrcContext = <ccuda.CUcontext><void_ptr>psrcContext
    else:
        psrcContext = int(CUcontext(srcContext))
        csrcContext = <ccuda.CUcontext><void_ptr>psrcContext

    cdef ccuda.CUdeviceptr csrcDevice
    if srcDevice is None:
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(srcDevice, (CUdeviceptr)):
        psrcDevice = int(srcDevice)
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice
    else:
        psrcDevice = int(CUdeviceptr(srcDevice))
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice

    cdef ccuda.CUcontext cdstContext
    if dstContext is None:
        cdstContext = <ccuda.CUcontext><void_ptr>0
    elif isinstance(dstContext, (CUcontext)):
        pdstContext = int(dstContext)
        cdstContext = <ccuda.CUcontext><void_ptr>pdstContext
    else:
        pdstContext = int(CUcontext(dstContext))
        cdstContext = <ccuda.CUcontext><void_ptr>pdstContext

    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    err = ccuda.cuMemcpyPeerAsync(cdstDevice, cdstContext, csrcDevice, csrcContext, ByteCount, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyHtoDAsync(dstDevice, srcHost, size_t ByteCount, hStream):
    """ Copies memory from Host to Device.

    Copies from host memory to device memory. `dstDevice` and `srcHost` are
    the base addresses of the destination and source, respectively.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    srcHost : Any
        Source host pointer
    ByteCount : size_t
        Size of memory copy in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    csrcHost = utils.HelperInputVoidPtr(srcHost)
    cdef void* csrcHost_ptr = <void*><void_ptr>csrcHost.cptr
    err = ccuda.cuMemcpyHtoDAsync(cdstDevice, csrcHost_ptr, ByteCount, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyDtoHAsync(dstHost, srcDevice, size_t ByteCount, hStream):
    """ Copies memory from Device to Host.

    Copies from device to host memory. `dstHost` and `srcDevice` specify
    the base pointers of the destination and source, respectively.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstHost : Any
        Destination host pointer
    srcDevice : :py:obj:`~.CUdeviceptr`
        Source device pointer
    ByteCount : size_t
        Size of memory copy in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUdeviceptr csrcDevice
    if srcDevice is None:
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(srcDevice, (CUdeviceptr)):
        psrcDevice = int(srcDevice)
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice
    else:
        psrcDevice = int(CUdeviceptr(srcDevice))
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice

    cdstHost = utils.HelperInputVoidPtr(dstHost)
    cdef void* cdstHost_ptr = <void*><void_ptr>cdstHost.cptr
    err = ccuda.cuMemcpyDtoHAsync(cdstHost_ptr, csrcDevice, ByteCount, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyDtoDAsync(dstDevice, srcDevice, size_t ByteCount, hStream):
    """ Copies memory from Device to Device.

    Copies from device memory to device memory. `dstDevice` and `srcDevice`
    are the base pointers of the destination and source, respectively.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    srcDevice : :py:obj:`~.CUdeviceptr`
        Source device pointer
    ByteCount : size_t
        Size of memory copy in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyAsync`, :py:obj:`~.cudaMemcpyToSymbolAsync`, :py:obj:`~.cudaMemcpyFromSymbolAsync`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUdeviceptr csrcDevice
    if srcDevice is None:
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(srcDevice, (CUdeviceptr)):
        psrcDevice = int(srcDevice)
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice
    else:
        psrcDevice = int(CUdeviceptr(srcDevice))
        csrcDevice = <ccuda.CUdeviceptr><void_ptr>psrcDevice

    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    err = ccuda.cuMemcpyDtoDAsync(cdstDevice, csrcDevice, ByteCount, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyHtoAAsync(dstArray, size_t dstOffset, srcHost, size_t ByteCount, hStream):
    """ Copies memory from Host to Array.

    Copies from host memory to a 1D CUDA array. `dstArray` and `dstOffset`
    specify the CUDA array handle and starting offset in bytes of the
    destination data. `srcHost` specifies the base address of the source.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstArray : :py:obj:`~.CUarray`
        Destination array
    dstOffset : size_t
        Offset in bytes of destination array
    srcHost : Any
        Source host pointer
    ByteCount : size_t
        Size of memory copy in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyToArrayAsync`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUarray cdstArray
    if dstArray is None:
        cdstArray = <ccuda.CUarray><void_ptr>0
    elif isinstance(dstArray, (CUarray)):
        pdstArray = int(dstArray)
        cdstArray = <ccuda.CUarray><void_ptr>pdstArray
    else:
        pdstArray = int(CUarray(dstArray))
        cdstArray = <ccuda.CUarray><void_ptr>pdstArray

    csrcHost = utils.HelperInputVoidPtr(srcHost)
    cdef void* csrcHost_ptr = <void*><void_ptr>csrcHost.cptr
    err = ccuda.cuMemcpyHtoAAsync(cdstArray, dstOffset, csrcHost_ptr, ByteCount, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpyAtoHAsync(dstHost, srcArray, size_t srcOffset, size_t ByteCount, hStream):
    """ Copies memory from Array to Host.

    Copies from one 1D CUDA array to host memory. `dstHost` specifies the
    base pointer of the destination. `srcArray` and `srcOffset` specify the
    CUDA array handle and starting offset in bytes of the source data.
    `ByteCount` specifies the number of bytes to copy.

    Parameters
    ----------
    dstHost : Any
        Destination pointer
    srcArray : :py:obj:`~.CUarray`
        Source array
    srcOffset : size_t
        Offset in bytes of source array
    ByteCount : size_t
        Size of memory copy in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpyFromArrayAsync`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUarray csrcArray
    if srcArray is None:
        csrcArray = <ccuda.CUarray><void_ptr>0
    elif isinstance(srcArray, (CUarray)):
        psrcArray = int(srcArray)
        csrcArray = <ccuda.CUarray><void_ptr>psrcArray
    else:
        psrcArray = int(CUarray(srcArray))
        csrcArray = <ccuda.CUarray><void_ptr>psrcArray

    cdstHost = utils.HelperInputVoidPtr(dstHost)
    cdef void* cdstHost_ptr = <void*><void_ptr>cdstHost.cptr
    err = ccuda.cuMemcpyAtoHAsync(cdstHost_ptr, csrcArray, srcOffset, ByteCount, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpy2DAsync(pCopy : CUDA_MEMCPY2D, hStream):
    """ Copies memory for 2D arrays.

    Perform a 2D memory copy according to the parameters specified in
    `pCopy`. The :py:obj:`~.CUDA_MEMCPY2D` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.srcMemoryType` and :py:obj:`~.dstMemoryType` specify the
      type of memory of the source and destination, respectively;
      :py:obj:`~.CUmemorytype_enum` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.srcHost` and :py:obj:`~.srcPitch` specify the (host) base
    address of the source data and the bytes per row to apply.
    :py:obj:`~.srcArray` is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.srcArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (device)
    base address of the source data and the bytes per row to apply.
    :py:obj:`~.srcArray` is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.srcArray` specifies the handle of the source data.
    :py:obj:`~.srcHost`, :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` are
    ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.dstArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.dstHost` and :py:obj:`~.dstPitch` specify the (host) base
    address of the destination data and the bytes per row to apply.
    :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (device)
    base address of the destination data and the bytes per row to apply.
    :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.dstArray` specifies the handle of the destination data.
    :py:obj:`~.dstHost`, :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` are
    ignored.

    - :py:obj:`~.srcXInBytes` and :py:obj:`~.srcY` specify the base address
      of the source data for the copy.

    For host pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.srcXInBytes` must be evenly divisible by
    the array element size.

    - :py:obj:`~.dstXInBytes` and :py:obj:`~.dstY` specify the base address
      of the destination data for the copy.

    For host pointers, the base address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.dstXInBytes` must be evenly divisible by
    the array element size.

    - :py:obj:`~.WidthInBytes` and :py:obj:`~.Height` specify the width (in
      bytes) and height of the 2D copy being performed.

    - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
      :py:obj:`~.dstPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + dstXInBytes.

    - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
      :py:obj:`~.dstPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + dstXInBytes.

    - If specified, :py:obj:`~.srcHeight` must be greater than or equal to
      :py:obj:`~.Height` + :py:obj:`~.srcY`, and :py:obj:`~.dstHeight` must
      be greater than or equal to :py:obj:`~.Height` + :py:obj:`~.dstY`.

    :py:obj:`~.cuMemcpy2DAsync()` returns an error if any pitch is greater
    than the maximum allowed (:py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PITCH`).
    :py:obj:`~.cuMemAllocPitch()` passes back pitches that always work with
    :py:obj:`~.cuMemcpy2D()`. On intra-device memory copies (device to
    device, CUDA array to device, CUDA array to CUDA array),
    :py:obj:`~.cuMemcpy2DAsync()` may fail for pitches not computed by
    :py:obj:`~.cuMemAllocPitch()`.

    Parameters
    ----------
    pCopy : :py:obj:`~.CUDA_MEMCPY2D`
        Parameters for the memory copy
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpy2DAsync`, :py:obj:`~.cudaMemcpy2DToArrayAsync`, :py:obj:`~.cudaMemcpy2DFromArrayAsync`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUDA_MEMCPY2D* cpCopy_ptr = pCopy._ptr if pCopy != None else NULL
    err = ccuda.cuMemcpy2DAsync(cpCopy_ptr, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpy3DAsync(pCopy : CUDA_MEMCPY3D, hStream):
    """ Copies memory for 3D arrays.

    Perform a 3D memory copy according to the parameters specified in
    `pCopy`. The :py:obj:`~.CUDA_MEMCPY3D` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.srcMemoryType` and :py:obj:`~.dstMemoryType` specify the
      type of memory of the source and destination, respectively;
      :py:obj:`~.CUmemorytype_enum` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.srcDevice` and :py:obj:`~.srcPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.srcArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.srcHost`, :py:obj:`~.srcPitch` and :py:obj:`~.srcHeight`
    specify the (host) base address of the source data, the bytes per row,
    and the height of each 2D slice of the 3D array. :py:obj:`~.srcArray`
    is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.srcDevice`, :py:obj:`~.srcPitch` and :py:obj:`~.srcHeight`
    specify the (device) base address of the source data, the bytes per
    row, and the height of each 2D slice of the 3D array.
    :py:obj:`~.srcArray` is ignored.

    If :py:obj:`~.srcMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.srcArray` specifies the handle of the source data.
    :py:obj:`~.srcHost`, :py:obj:`~.srcDevice`, :py:obj:`~.srcPitch` and
    :py:obj:`~.srcHeight` are ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_UNIFIED`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (unified
    virtual address space) base address of the source data and the bytes
    per row to apply. :py:obj:`~.dstArray` is ignored. This value may be
    used only if unified addressing is supported in the calling context.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_HOST`,
    :py:obj:`~.dstHost` and :py:obj:`~.dstPitch` specify the (host) base
    address of the destination data, the bytes per row, and the height of
    each 2D slice of the 3D array. :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_DEVICE`,
    :py:obj:`~.dstDevice` and :py:obj:`~.dstPitch` specify the (device)
    base address of the destination data, the bytes per row, and the height
    of each 2D slice of the 3D array. :py:obj:`~.dstArray` is ignored.

    If :py:obj:`~.dstMemoryType` is :py:obj:`~.CU_MEMORYTYPE_ARRAY`,
    :py:obj:`~.dstArray` specifies the handle of the destination data.
    :py:obj:`~.dstHost`, :py:obj:`~.dstDevice`, :py:obj:`~.dstPitch` and
    :py:obj:`~.dstHeight` are ignored.

    - :py:obj:`~.srcXInBytes`, :py:obj:`~.srcY` and :py:obj:`~.srcZ`
      specify the base address of the source data for the copy.

    For host pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.srcXInBytes` must be evenly divisible by
    the array element size.

    - dstXInBytes, :py:obj:`~.dstY` and :py:obj:`~.dstZ` specify the base
      address of the destination data for the copy.

    For host pointers, the base address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For device pointers, the starting address is

    **View CUDA Toolkit Documentation for a C++ code example**

    For CUDA arrays, :py:obj:`~.dstXInBytes` must be evenly divisible by
    the array element size.

    - :py:obj:`~.WidthInBytes`, :py:obj:`~.Height` and :py:obj:`~.Depth`
      specify the width (in bytes), height and depth of the 3D copy being
      performed.

    - If specified, :py:obj:`~.srcPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + :py:obj:`~.srcXInBytes`, and
      :py:obj:`~.dstPitch` must be greater than or equal to
      :py:obj:`~.WidthInBytes` + dstXInBytes.

    - If specified, :py:obj:`~.srcHeight` must be greater than or equal to
      :py:obj:`~.Height` + :py:obj:`~.srcY`, and :py:obj:`~.dstHeight` must
      be greater than or equal to :py:obj:`~.Height` + :py:obj:`~.dstY`.

    :py:obj:`~.cuMemcpy3DAsync()` returns an error if any pitch is greater
    than the maximum allowed (:py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_PITCH`).

    The :py:obj:`~.srcLOD` and :py:obj:`~.dstLOD` members of the
    :py:obj:`~.CUDA_MEMCPY3D` structure must be set to 0.

    Parameters
    ----------
    pCopy : :py:obj:`~.CUDA_MEMCPY3D`
        Parameters for the memory copy
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemcpy3DAsync`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUDA_MEMCPY3D* cpCopy_ptr = pCopy._ptr if pCopy != None else NULL
    err = ccuda.cuMemcpy3DAsync(cpCopy_ptr, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemcpy3DPeerAsync(pCopy : CUDA_MEMCPY3D_PEER, hStream):
    """ Copies memory between contexts asynchronously.

    Perform a 3D memory copy according to the parameters specified in
    `pCopy`. See the definition of the :py:obj:`~.CUDA_MEMCPY3D_PEER`
    structure for documentation of its parameters.

    Parameters
    ----------
    pCopy : :py:obj:`~.CUDA_MEMCPY3D_PEER`
        Parameters for the memory copy
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyPeer`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyPeerAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cudaMemcpy3DPeerAsync`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUDA_MEMCPY3D_PEER* cpCopy_ptr = pCopy._ptr if pCopy != None else NULL
    err = ccuda.cuMemcpy3DPeerAsync(cpCopy_ptr, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD8(dstDevice, unsigned char uc, size_t N):
    """ Initializes device memory.

    Sets the memory range of `N` 8-bit values to the specified value `uc`.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    uc : unsigned char
        Value to set
    N : size_t
        Number of elements

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset`
    """
    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    err = ccuda.cuMemsetD8(cdstDevice, uc, N)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD16(dstDevice, unsigned short us, size_t N):
    """ Initializes device memory.

    Sets the memory range of `N` 16-bit values to the specified value `us`.
    The `dstDevice` pointer must be two byte aligned.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    us : unsigned short
        Value to set
    N : size_t
        Number of elements

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset`
    """
    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    err = ccuda.cuMemsetD16(cdstDevice, us, N)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD32(dstDevice, unsigned int ui, size_t N):
    """ Initializes device memory.

    Sets the memory range of `N` 32-bit values to the specified value `ui`.
    The `dstDevice` pointer must be four byte aligned.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    ui : unsigned int
        Value to set
    N : size_t
        Number of elements

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset`
    """
    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    err = ccuda.cuMemsetD32(cdstDevice, ui, N)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD2D8(dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height):
    """ Initializes device memory.

    Sets the 2D memory range of `Width` 8-bit values to the specified value
    `uc`. `Height` specifies the number of rows to set, and `dstPitch`
    specifies the number of bytes between each row. This function performs
    fastest when the pitch is one that has been passed back by
    :py:obj:`~.cuMemAllocPitch()`.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    dstPitch : size_t
        Pitch of destination device pointer(Unused if `Height` is 1)
    uc : unsigned char
        Value to set
    Width : size_t
        Width of row
    Height : size_t
        Number of rows

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2D`
    """
    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    err = ccuda.cuMemsetD2D8(cdstDevice, dstPitch, uc, Width, Height)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD2D16(dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height):
    """ Initializes device memory.

    Sets the 2D memory range of `Width` 16-bit values to the specified
    value `us`. `Height` specifies the number of rows to set, and
    `dstPitch` specifies the number of bytes between each row. The
    `dstDevice` pointer and `dstPitch` offset must be two byte aligned.
    This function performs fastest when the pitch is one that has been
    passed back by :py:obj:`~.cuMemAllocPitch()`.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    dstPitch : size_t
        Pitch of destination device pointer(Unused if `Height` is 1)
    us : unsigned short
        Value to set
    Width : size_t
        Width of row
    Height : size_t
        Number of rows

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2D`
    """
    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    err = ccuda.cuMemsetD2D16(cdstDevice, dstPitch, us, Width, Height)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD2D32(dstDevice, size_t dstPitch, unsigned int ui, size_t Width, size_t Height):
    """ Initializes device memory.

    Sets the 2D memory range of `Width` 32-bit values to the specified
    value `ui`. `Height` specifies the number of rows to set, and
    `dstPitch` specifies the number of bytes between each row. The
    `dstDevice` pointer and `dstPitch` offset must be four byte aligned.
    This function performs fastest when the pitch is one that has been
    passed back by :py:obj:`~.cuMemAllocPitch()`.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    dstPitch : size_t
        Pitch of destination device pointer(Unused if `Height` is 1)
    ui : unsigned int
        Value to set
    Width : size_t
        Width of row
    Height : size_t
        Number of rows

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2D`
    """
    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    err = ccuda.cuMemsetD2D32(cdstDevice, dstPitch, ui, Width, Height)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD8Async(dstDevice, unsigned char uc, size_t N, hStream):
    """ Sets device memory.

    Sets the memory range of `N` 8-bit values to the specified value `uc`.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    uc : unsigned char
        Value to set
    N : size_t
        Number of elements
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemsetAsync`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    err = ccuda.cuMemsetD8Async(cdstDevice, uc, N, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD16Async(dstDevice, unsigned short us, size_t N, hStream):
    """ Sets device memory.

    Sets the memory range of `N` 16-bit values to the specified value `us`.
    The `dstDevice` pointer must be two byte aligned.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    us : unsigned short
        Value to set
    N : size_t
        Number of elements
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemsetAsync`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    err = ccuda.cuMemsetD16Async(cdstDevice, us, N, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD32Async(dstDevice, unsigned int ui, size_t N, hStream):
    """ Sets device memory.

    Sets the memory range of `N` 32-bit values to the specified value `ui`.
    The `dstDevice` pointer must be four byte aligned.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    ui : unsigned int
        Value to set
    N : size_t
        Number of elements
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMemsetAsync`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    err = ccuda.cuMemsetD32Async(cdstDevice, ui, N, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD2D8Async(dstDevice, size_t dstPitch, unsigned char uc, size_t Width, size_t Height, hStream):
    """ Sets device memory.

    Sets the 2D memory range of `Width` 8-bit values to the specified value
    `uc`. `Height` specifies the number of rows to set, and `dstPitch`
    specifies the number of bytes between each row. This function performs
    fastest when the pitch is one that has been passed back by
    :py:obj:`~.cuMemAllocPitch()`.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    dstPitch : size_t
        Pitch of destination device pointer(Unused if `Height` is 1)
    uc : unsigned char
        Value to set
    Width : size_t
        Width of row
    Height : size_t
        Number of rows
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2DAsync`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    err = ccuda.cuMemsetD2D8Async(cdstDevice, dstPitch, uc, Width, Height, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD2D16Async(dstDevice, size_t dstPitch, unsigned short us, size_t Width, size_t Height, hStream):
    """ Sets device memory.

    Sets the 2D memory range of `Width` 16-bit values to the specified
    value `us`. `Height` specifies the number of rows to set, and
    `dstPitch` specifies the number of bytes between each row. The
    `dstDevice` pointer and `dstPitch` offset must be two byte aligned.
    This function performs fastest when the pitch is one that has been
    passed back by :py:obj:`~.cuMemAllocPitch()`.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    dstPitch : size_t
        Pitch of destination device pointer(Unused if `Height` is 1)
    us : unsigned short
        Value to set
    Width : size_t
        Width of row
    Height : size_t
        Number of rows
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD2D32Async`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2DAsync`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    err = ccuda.cuMemsetD2D16Async(cdstDevice, dstPitch, us, Width, Height, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemsetD2D32Async(dstDevice, size_t dstPitch, unsigned int ui, size_t Width, size_t Height, hStream):
    """ Sets device memory.

    Sets the 2D memory range of `Width` 32-bit values to the specified
    value `ui`. `Height` specifies the number of rows to set, and
    `dstPitch` specifies the number of bytes between each row. The
    `dstDevice` pointer and `dstPitch` offset must be four byte aligned.
    This function performs fastest when the pitch is one that has been
    passed back by :py:obj:`~.cuMemAllocPitch()`.

    Parameters
    ----------
    dstDevice : :py:obj:`~.CUdeviceptr`
        Destination device pointer
    dstPitch : size_t
        Pitch of destination device pointer(Unused if `Height` is 1)
    ui : unsigned int
        Value to set
    Width : size_t
        Width of row
    Height : size_t
        Number of rows
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D8Async`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D16Async`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD8Async`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD16Async`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cuMemsetD32Async`, :py:obj:`~.cudaMemset2DAsync`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUdeviceptr cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dstDevice, (CUdeviceptr)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice
    else:
        pdstDevice = int(CUdeviceptr(dstDevice))
        cdstDevice = <ccuda.CUdeviceptr><void_ptr>pdstDevice

    err = ccuda.cuMemsetD2D32Async(cdstDevice, dstPitch, ui, Width, Height, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuArrayCreate(pAllocateArray : CUDA_ARRAY_DESCRIPTOR):
    """ Creates a 1D or 2D CUDA array.

    Creates a CUDA array according to the :py:obj:`~.CUDA_ARRAY_DESCRIPTOR`
    structure `pAllocateArray` and returns a handle to the new CUDA array
    in `*pHandle`. The :py:obj:`~.CUDA_ARRAY_DESCRIPTOR` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - `Width`, and `Height` are the width, and height of the CUDA array (in
      elements); the CUDA array is one-dimensional if height is 0, two-
      dimensional otherwise;

    - :py:obj:`~.Format` specifies the format of the elements;
      :py:obj:`~.CUarray_format` is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - `NumChannels` specifies the number of packed components per CUDA
      array element; it may be 1, 2, or 4;

    Here are examples of CUDA array descriptions:

    Description for a CUDA array of 2048 floats:

    **View CUDA Toolkit Documentation for a C++ code example**

    Description for a 64 x 64 CUDA array of floats:

    **View CUDA Toolkit Documentation for a C++ code example**

    Description for a `width` x `height` CUDA array of 64-bit, 4x16-bit
    float16's:

    **View CUDA Toolkit Documentation for a C++ code example**

    Description for a `width` x `height` CUDA array of 16-bit elements,
    each of which is two 8-bit unsigned chars:

    **View CUDA Toolkit Documentation for a C++ code example**

    Parameters
    ----------
    pAllocateArray : :py:obj:`~.CUDA_ARRAY_DESCRIPTOR`
        Array descriptor

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    pHandle : :py:obj:`~.CUarray`
        Returned array

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMallocArray`
    """
    cdef CUarray pHandle = CUarray()
    cdef ccuda.CUDA_ARRAY_DESCRIPTOR* cpAllocateArray_ptr = pAllocateArray._ptr if pAllocateArray != None else NULL
    err = ccuda.cuArrayCreate(pHandle._ptr, cpAllocateArray_ptr)
    return (CUresult(err), pHandle)

@cython.embedsignature(True)
def cuArrayGetDescriptor(hArray):
    """ Get a 1D or 2D CUDA array descriptor.

    Returns in `*pArrayDescriptor` a descriptor containing information on
    the format and dimensions of the CUDA array `hArray`. It is useful for
    subroutines that have been passed a CUDA array, but need to know the
    CUDA array parameters for validation or other purposes.

    Parameters
    ----------
    hArray : :py:obj:`~.CUarray`
        Array to get descriptor of

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    pArrayDescriptor : :py:obj:`~.CUDA_ARRAY_DESCRIPTOR`
        Returned array descriptor

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaArrayGetInfo`
    """
    cdef ccuda.CUarray chArray
    if hArray is None:
        chArray = <ccuda.CUarray><void_ptr>0
    elif isinstance(hArray, (CUarray)):
        phArray = int(hArray)
        chArray = <ccuda.CUarray><void_ptr>phArray
    else:
        phArray = int(CUarray(hArray))
        chArray = <ccuda.CUarray><void_ptr>phArray

    cdef CUDA_ARRAY_DESCRIPTOR pArrayDescriptor = CUDA_ARRAY_DESCRIPTOR()
    err = ccuda.cuArrayGetDescriptor(pArrayDescriptor._ptr, chArray)
    return (CUresult(err), pArrayDescriptor)

@cython.embedsignature(True)
def cuArrayGetSparseProperties(array):
    """ Returns the layout properties of a sparse CUDA array.

    Returns the layout properties of a sparse CUDA array in
    `sparseProperties` If the CUDA array is not allocated with flag
    :py:obj:`~.CUDA_ARRAY3D_SPARSE` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    will be returned.

    If the returned value in :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.flags`
    contains :py:obj:`~.CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL`, then
    :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailSize` represents the
    total size of the array. Otherwise, it will be zero. Also, the returned
    value in :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailFirstLevel` is
    always zero. Note that the `array` must have been allocated using
    :py:obj:`~.cuArrayCreate` or :py:obj:`~.cuArray3DCreate`. For CUDA
    arrays obtained using :py:obj:`~.cuMipmappedArrayGetLevel`,
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned. Instead,
    :py:obj:`~.cuMipmappedArrayGetSparseProperties` must be used to obtain
    the sparse properties of the entire CUDA mipmapped array to which
    `array` belongs to.

    Parameters
    ----------
    array : :py:obj:`~.CUarray`
        CUDA array to get the sparse properties of

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    sparseProperties : :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES`
        Pointer to :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES`

    See Also
    --------
    :py:obj:`~.cuMipmappedArrayGetSparseProperties`, :py:obj:`~.cuMemMapArrayAsync`
    """
    cdef ccuda.CUarray carray
    if array is None:
        carray = <ccuda.CUarray><void_ptr>0
    elif isinstance(array, (CUarray)):
        parray = int(array)
        carray = <ccuda.CUarray><void_ptr>parray
    else:
        parray = int(CUarray(array))
        carray = <ccuda.CUarray><void_ptr>parray

    cdef CUDA_ARRAY_SPARSE_PROPERTIES sparseProperties = CUDA_ARRAY_SPARSE_PROPERTIES()
    err = ccuda.cuArrayGetSparseProperties(sparseProperties._ptr, carray)
    return (CUresult(err), sparseProperties)

@cython.embedsignature(True)
def cuMipmappedArrayGetSparseProperties(mipmap):
    """ Returns the layout properties of a sparse CUDA mipmapped array.

    Returns the sparse array layout properties in `sparseProperties` If the
    CUDA mipmapped array is not allocated with flag
    :py:obj:`~.CUDA_ARRAY3D_SPARSE` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    will be returned.

    For non-layered CUDA mipmapped arrays,
    :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailSize` returns the size
    of the mip tail region. The mip tail region includes all mip levels
    whose width, height or depth is less than that of the tile. For layered
    CUDA mipmapped arrays, if
    :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.flags` contains
    :py:obj:`~.CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL`, then
    :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailSize` specifies the size
    of the mip tail of all layers combined. Otherwise,
    :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailSize` specifies mip tail
    size per layer. The returned value of
    :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailFirstLevel` is valid
    only if :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.miptailSize` is non-
    zero.

    Parameters
    ----------
    mipmap : :py:obj:`~.CUmipmappedArray`
        CUDA mipmapped array to get the sparse properties of

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    sparseProperties : :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES`
        Pointer to :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES`

    See Also
    --------
    :py:obj:`~.cuArrayGetSparseProperties`, :py:obj:`~.cuMemMapArrayAsync`
    """
    cdef ccuda.CUmipmappedArray cmipmap
    if mipmap is None:
        cmipmap = <ccuda.CUmipmappedArray><void_ptr>0
    elif isinstance(mipmap, (CUmipmappedArray)):
        pmipmap = int(mipmap)
        cmipmap = <ccuda.CUmipmappedArray><void_ptr>pmipmap
    else:
        pmipmap = int(CUmipmappedArray(mipmap))
        cmipmap = <ccuda.CUmipmappedArray><void_ptr>pmipmap

    cdef CUDA_ARRAY_SPARSE_PROPERTIES sparseProperties = CUDA_ARRAY_SPARSE_PROPERTIES()
    err = ccuda.cuMipmappedArrayGetSparseProperties(sparseProperties._ptr, cmipmap)
    return (CUresult(err), sparseProperties)

@cython.embedsignature(True)
def cuArrayGetMemoryRequirements(array, device):
    """ Returns the memory requirements of a CUDA array.

    Returns the memory requirements of a CUDA array in `memoryRequirements`
    If the CUDA array is not allocated with flag
    :py:obj:`~.CUDA_ARRAY3D_DEFERRED_MAPPING`
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned.

    The returned value in :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS.size`
    represents the total size of the CUDA array. The returned value in
    :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS.alignment` represents the
    alignment necessary for mapping the CUDA array.

    Parameters
    ----------
    array : :py:obj:`~.CUarray`
        CUDA array to get the memory requirements of
    device : :py:obj:`~.CUdevice`
        Device to get the memory requirements for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    memoryRequirements : :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS`
        Pointer to :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS`

    See Also
    --------
    :py:obj:`~.cuMipmappedArrayGetMemoryRequirements`, :py:obj:`~.cuMemMapArrayAsync`
    """
    cdef ccuda.CUdevice cdevice
    if device is None:
        cdevice = <ccuda.CUdevice>0
    elif isinstance(device, (CUdevice)):
        pdevice = int(device)
        cdevice = <ccuda.CUdevice>pdevice
    else:
        pdevice = int(CUdevice(device))
        cdevice = <ccuda.CUdevice>pdevice

    cdef ccuda.CUarray carray
    if array is None:
        carray = <ccuda.CUarray><void_ptr>0
    elif isinstance(array, (CUarray)):
        parray = int(array)
        carray = <ccuda.CUarray><void_ptr>parray
    else:
        parray = int(CUarray(array))
        carray = <ccuda.CUarray><void_ptr>parray

    cdef CUDA_ARRAY_MEMORY_REQUIREMENTS memoryRequirements = CUDA_ARRAY_MEMORY_REQUIREMENTS()
    err = ccuda.cuArrayGetMemoryRequirements(memoryRequirements._ptr, carray, cdevice)
    return (CUresult(err), memoryRequirements)

@cython.embedsignature(True)
def cuMipmappedArrayGetMemoryRequirements(mipmap, device):
    """ Returns the memory requirements of a CUDA mipmapped array.

    Returns the memory requirements of a CUDA mipmapped array in
    `memoryRequirements` If the CUDA mipmapped array is not allocated with
    flag :py:obj:`~.CUDA_ARRAY3D_DEFERRED_MAPPING`
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned.

    The returned value in :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS.size`
    represents the total size of the CUDA mipmapped array. The returned
    value in :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS.alignment`
    represents the alignment necessary for mapping the CUDA mipmapped
    array.

    Parameters
    ----------
    mipmap : :py:obj:`~.CUmipmappedArray`
        CUDA mipmapped array to get the memory requirements of
    device : :py:obj:`~.CUdevice`
        Device to get the memory requirements for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS` :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    memoryRequirements : :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS`
        Pointer to :py:obj:`~.CUDA_ARRAY_MEMORY_REQUIREMENTS`

    See Also
    --------
    :py:obj:`~.cuArrayGetMemoryRequirements`, :py:obj:`~.cuMemMapArrayAsync`
    """
    cdef ccuda.CUdevice cdevice
    if device is None:
        cdevice = <ccuda.CUdevice>0
    elif isinstance(device, (CUdevice)):
        pdevice = int(device)
        cdevice = <ccuda.CUdevice>pdevice
    else:
        pdevice = int(CUdevice(device))
        cdevice = <ccuda.CUdevice>pdevice

    cdef ccuda.CUmipmappedArray cmipmap
    if mipmap is None:
        cmipmap = <ccuda.CUmipmappedArray><void_ptr>0
    elif isinstance(mipmap, (CUmipmappedArray)):
        pmipmap = int(mipmap)
        cmipmap = <ccuda.CUmipmappedArray><void_ptr>pmipmap
    else:
        pmipmap = int(CUmipmappedArray(mipmap))
        cmipmap = <ccuda.CUmipmappedArray><void_ptr>pmipmap

    cdef CUDA_ARRAY_MEMORY_REQUIREMENTS memoryRequirements = CUDA_ARRAY_MEMORY_REQUIREMENTS()
    err = ccuda.cuMipmappedArrayGetMemoryRequirements(memoryRequirements._ptr, cmipmap, cdevice)
    return (CUresult(err), memoryRequirements)

@cython.embedsignature(True)
def cuArrayGetPlane(hArray, unsigned int planeIdx):
    """ Gets a CUDA array plane from a CUDA array.

    Returns in `pPlaneArray` a CUDA array that represents a single format
    plane of the CUDA array `hArray`.

    If `planeIdx` is greater than the maximum number of planes in this
    array or if the array does not have a multi-planar format e.g:
    :py:obj:`~.CU_AD_FORMAT_NV12`, then
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

    Note that if the `hArray` has format :py:obj:`~.CU_AD_FORMAT_NV12`,
    then passing in 0 for `planeIdx` returns a CUDA array of the same size
    as `hArray` but with one channel and
    :py:obj:`~.CU_AD_FORMAT_UNSIGNED_INT8` as its format. If 1 is passed
    for `planeIdx`, then the returned CUDA array has half the height and
    width of `hArray` with two channels and
    :py:obj:`~.CU_AD_FORMAT_UNSIGNED_INT8` as its format.

    Parameters
    ----------
    hArray : :py:obj:`~.CUarray`
        Multiplanar CUDA array
    planeIdx : unsigned int
        Plane index

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    pPlaneArray : :py:obj:`~.CUarray`
        Returned CUDA array referenced by the `planeIdx`

    See Also
    --------
    :py:obj:`~.cuArrayCreate`, :py:obj:`~.cudaGetArrayPlane`
    """
    cdef ccuda.CUarray chArray
    if hArray is None:
        chArray = <ccuda.CUarray><void_ptr>0
    elif isinstance(hArray, (CUarray)):
        phArray = int(hArray)
        chArray = <ccuda.CUarray><void_ptr>phArray
    else:
        phArray = int(CUarray(hArray))
        chArray = <ccuda.CUarray><void_ptr>phArray

    cdef CUarray pPlaneArray = CUarray()
    err = ccuda.cuArrayGetPlane(pPlaneArray._ptr, chArray, planeIdx)
    return (CUresult(err), pPlaneArray)

@cython.embedsignature(True)
def cuArrayDestroy(hArray):
    """ Destroys a CUDA array.

    Destroys the CUDA array `hArray`.

    Parameters
    ----------
    hArray : :py:obj:`~.CUarray`
        Array to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ARRAY_IS_MAPPED`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaFreeArray`
    """
    cdef ccuda.CUarray chArray
    if hArray is None:
        chArray = <ccuda.CUarray><void_ptr>0
    elif isinstance(hArray, (CUarray)):
        phArray = int(hArray)
        chArray = <ccuda.CUarray><void_ptr>phArray
    else:
        phArray = int(CUarray(hArray))
        chArray = <ccuda.CUarray><void_ptr>phArray

    err = ccuda.cuArrayDestroy(chArray)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuArray3DCreate(pAllocateArray : CUDA_ARRAY3D_DESCRIPTOR):
    """ Creates a 3D CUDA array.

    Creates a CUDA array according to the
    :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR` structure `pAllocateArray` and
    returns a handle to the new CUDA array in `*pHandle`. The
    :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - `Width`, `Height`, and `Depth` are the width, height, and depth of
      the CUDA array (in elements); the following types of CUDA arrays can
      be allocated:

      - A 1D array is allocated if `Height` and `Depth` extents are both
        zero.

      - A 2D array is allocated if only `Depth` extent is zero.

      - A 3D array is allocated if all three extents are non-zero.

      - A 1D layered CUDA array is allocated if only `Height` is zero and
        the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is set. Each layer is a
        1D array. The number of layers is determined by the depth extent.

      - A 2D layered CUDA array is allocated if all three extents are non-
        zero and the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is set. Each
        layer is a 2D array. The number of layers is determined by the
        depth extent.

      - A cubemap CUDA array is allocated if all three extents are non-zero
        and the :py:obj:`~.CUDA_ARRAY3D_CUBEMAP` flag is set. `Width` must
        be equal to `Height`, and `Depth` must be six. A cubemap is a
        special type of 2D layered CUDA array, where the six layers
        represent the six faces of a cube. The order of the six layers in
        memory is the same as that listed in
        :py:obj:`~.CUarray_cubemap_face`.

      - A cubemap layered CUDA array is allocated if all three extents are
        non-zero, and both, :py:obj:`~.CUDA_ARRAY3D_CUBEMAP` and
        :py:obj:`~.CUDA_ARRAY3D_LAYERED` flags are set. `Width` must be
        equal to `Height`, and `Depth` must be a multiple of six. A cubemap
        layered CUDA array is a special type of 2D layered CUDA array that
        consists of a collection of cubemaps. The first six layers
        represent the first cubemap, the next six layers form the second
        cubemap, and so on.

    - :py:obj:`~.Format` specifies the format of the elements;
      :py:obj:`~.CUarray_format` is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - `NumChannels` specifies the number of packed components per CUDA
      array element; it may be 1, 2, or 4;

    - :py:obj:`~.Flags` may be set to

      - :py:obj:`~.CUDA_ARRAY3D_LAYERED` to enable creation of layered CUDA
        arrays. If this flag is set, `Depth` specifies the number of
        layers, not the depth of a 3D array.

      - :py:obj:`~.CUDA_ARRAY3D_SURFACE_LDST` to enable surface references
        to be bound to the CUDA array. If this flag is not set,
        :py:obj:`~.cuSurfRefSetArray` will fail when attempting to bind the
        CUDA array to a surface reference.

      - :py:obj:`~.CUDA_ARRAY3D_CUBEMAP` to enable creation of cubemaps. If
        this flag is set, `Width` must be equal to `Height`, and `Depth`
        must be six. If the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is also
        set, then `Depth` must be a multiple of six.

      - :py:obj:`~.CUDA_ARRAY3D_TEXTURE_GATHER` to indicate that the CUDA
        array will be used for texture gather. Texture gather can only be
        performed on 2D CUDA arrays.

    `Width`, `Height` and `Depth` must meet certain size requirements as
    listed in the following table. All values are specified in elements.
    Note that for brevity's sake, the full name of the device attribute is
    not specified. For ex., TEXTURE1D_WIDTH refers to the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH`.

    Note that 2D CUDA arrays have different size requirements if the
    :py:obj:`~.CUDA_ARRAY3D_TEXTURE_GATHER` flag is set. `Width` and
    `Height` must not be greater than
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH` and
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT`
    respectively, in that case.

    **View CUDA Toolkit Documentation for a table example**

    Here are examples of CUDA array descriptions:

    Description for a CUDA array of 2048 floats:

    **View CUDA Toolkit Documentation for a C++ code example**

    Description for a 64 x 64 CUDA array of floats:

    **View CUDA Toolkit Documentation for a C++ code example**

    Description for a `width` x `height` x `depth` CUDA array of 64-bit,
    4x16-bit float16's:

    **View CUDA Toolkit Documentation for a C++ code example**

    Parameters
    ----------
    pAllocateArray : :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR`
        3D array descriptor

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    pHandle : :py:obj:`~.CUarray`
        Returned array

    See Also
    --------
    :py:obj:`~.cuArray3DGetDescriptor`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaMalloc3DArray`
    """
    cdef CUarray pHandle = CUarray()
    cdef ccuda.CUDA_ARRAY3D_DESCRIPTOR* cpAllocateArray_ptr = pAllocateArray._ptr if pAllocateArray != None else NULL
    err = ccuda.cuArray3DCreate(pHandle._ptr, cpAllocateArray_ptr)
    return (CUresult(err), pHandle)

@cython.embedsignature(True)
def cuArray3DGetDescriptor(hArray):
    """ Get a 3D CUDA array descriptor.

    Returns in `*pArrayDescriptor` a descriptor containing information on
    the format and dimensions of the CUDA array `hArray`. It is useful for
    subroutines that have been passed a CUDA array, but need to know the
    CUDA array parameters for validation or other purposes.

    This function may be called on 1D and 2D arrays, in which case the
    `Height` and/or `Depth` members of the descriptor struct will be set to
    0.

    Parameters
    ----------
    hArray : :py:obj:`~.CUarray`
        3D array to get descriptor of

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`
    pArrayDescriptor : :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR`
        Returned 3D array descriptor

    See Also
    --------
    :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArrayDestroy`, :py:obj:`~.cuArrayGetDescriptor`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemAllocPitch`, :py:obj:`~.cuMemcpy2D`, :py:obj:`~.cuMemcpy2DAsync`, :py:obj:`~.cuMemcpy2DUnaligned`, :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuMemcpy3DAsync`, :py:obj:`~.cuMemcpyAtoA`, :py:obj:`~.cuMemcpyAtoD`, :py:obj:`~.cuMemcpyAtoH`, :py:obj:`~.cuMemcpyAtoHAsync`, :py:obj:`~.cuMemcpyDtoA`, :py:obj:`~.cuMemcpyDtoD`, :py:obj:`~.cuMemcpyDtoDAsync`, :py:obj:`~.cuMemcpyDtoH`, :py:obj:`~.cuMemcpyDtoHAsync`, :py:obj:`~.cuMemcpyHtoA`, :py:obj:`~.cuMemcpyHtoAAsync`, :py:obj:`~.cuMemcpyHtoD`, :py:obj:`~.cuMemcpyHtoDAsync`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemGetAddressRange`, :py:obj:`~.cuMemGetInfo`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostGetDevicePointer`, :py:obj:`~.cuMemsetD2D8`, :py:obj:`~.cuMemsetD2D16`, :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuMemsetD8`, :py:obj:`~.cuMemsetD16`, :py:obj:`~.cuMemsetD32`, :py:obj:`~.cudaArrayGetInfo`
    """
    cdef ccuda.CUarray chArray
    if hArray is None:
        chArray = <ccuda.CUarray><void_ptr>0
    elif isinstance(hArray, (CUarray)):
        phArray = int(hArray)
        chArray = <ccuda.CUarray><void_ptr>phArray
    else:
        phArray = int(CUarray(hArray))
        chArray = <ccuda.CUarray><void_ptr>phArray

    cdef CUDA_ARRAY3D_DESCRIPTOR pArrayDescriptor = CUDA_ARRAY3D_DESCRIPTOR()
    err = ccuda.cuArray3DGetDescriptor(pArrayDescriptor._ptr, chArray)
    return (CUresult(err), pArrayDescriptor)

@cython.embedsignature(True)
def cuMipmappedArrayCreate(pMipmappedArrayDesc : CUDA_ARRAY3D_DESCRIPTOR, unsigned int numMipmapLevels):
    """ Creates a CUDA mipmapped array.

    Creates a CUDA mipmapped array according to the
    :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR` structure `pMipmappedArrayDesc` and
    returns a handle to the new CUDA mipmapped array in `*pHandle`.
    `numMipmapLevels` specifies the number of mipmap levels to be
    allocated. This value is clamped to the range [1, 1 +
    floor(log2(max(width, height, depth)))].

    The :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - `Width`, `Height`, and `Depth` are the width, height, and depth of
      the CUDA array (in elements); the following types of CUDA arrays can
      be allocated:

      - A 1D mipmapped array is allocated if `Height` and `Depth` extents
        are both zero.

      - A 2D mipmapped array is allocated if only `Depth` extent is zero.

      - A 3D mipmapped array is allocated if all three extents are non-
        zero.

      - A 1D layered CUDA mipmapped array is allocated if only `Height` is
        zero and the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is set. Each
        layer is a 1D array. The number of layers is determined by the
        depth extent.

      - A 2D layered CUDA mipmapped array is allocated if all three extents
        are non-zero and the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is set.
        Each layer is a 2D array. The number of layers is determined by the
        depth extent.

      - A cubemap CUDA mipmapped array is allocated if all three extents
        are non-zero and the :py:obj:`~.CUDA_ARRAY3D_CUBEMAP` flag is set.
        `Width` must be equal to `Height`, and `Depth` must be six. A
        cubemap is a special type of 2D layered CUDA array, where the six
        layers represent the six faces of a cube. The order of the six
        layers in memory is the same as that listed in
        :py:obj:`~.CUarray_cubemap_face`.

      - A cubemap layered CUDA mipmapped array is allocated if all three
        extents are non-zero, and both, :py:obj:`~.CUDA_ARRAY3D_CUBEMAP`
        and :py:obj:`~.CUDA_ARRAY3D_LAYERED` flags are set. `Width` must be
        equal to `Height`, and `Depth` must be a multiple of six. A cubemap
        layered CUDA array is a special type of 2D layered CUDA array that
        consists of a collection of cubemaps. The first six layers
        represent the first cubemap, the next six layers form the second
        cubemap, and so on.

    - :py:obj:`~.Format` specifies the format of the elements;
      :py:obj:`~.CUarray_format` is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - `NumChannels` specifies the number of packed components per CUDA
      array element; it may be 1, 2, or 4;

    - :py:obj:`~.Flags` may be set to

      - :py:obj:`~.CUDA_ARRAY3D_LAYERED` to enable creation of layered CUDA
        mipmapped arrays. If this flag is set, `Depth` specifies the number
        of layers, not the depth of a 3D array.

      - :py:obj:`~.CUDA_ARRAY3D_SURFACE_LDST` to enable surface references
        to be bound to individual mipmap levels of the CUDA mipmapped
        array. If this flag is not set, :py:obj:`~.cuSurfRefSetArray` will
        fail when attempting to bind a mipmap level of the CUDA mipmapped
        array to a surface reference.

    - :py:obj:`~.CUDA_ARRAY3D_CUBEMAP` to enable creation of mipmapped
    cubemaps. If this flag is set, `Width` must be equal to `Height`, and
    `Depth` must be six. If the :py:obj:`~.CUDA_ARRAY3D_LAYERED` flag is
    also set, then `Depth` must be a multiple of six.

      - :py:obj:`~.CUDA_ARRAY3D_TEXTURE_GATHER` to indicate that the CUDA
        mipmapped array will be used for texture gather. Texture gather can
        only be performed on 2D CUDA mipmapped arrays.

    `Width`, `Height` and `Depth` must meet certain size requirements as
    listed in the following table. All values are specified in elements.
    Note that for brevity's sake, the full name of the device attribute is
    not specified. For ex., TEXTURE1D_MIPMAPPED_WIDTH refers to the device
    attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH`.

    **View CUDA Toolkit Documentation for a table example**

    Parameters
    ----------
    pMipmappedArrayDesc : :py:obj:`~.CUDA_ARRAY3D_DESCRIPTOR`
        mipmapped array descriptor
    numMipmapLevels : unsigned int
        Number of mipmap levels

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    pHandle : :py:obj:`~.CUmipmappedArray`
        Returned mipmapped array

    See Also
    --------
    :py:obj:`~.cuMipmappedArrayDestroy`, :py:obj:`~.cuMipmappedArrayGetLevel`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cudaMallocMipmappedArray`
    """
    cdef CUmipmappedArray pHandle = CUmipmappedArray()
    cdef ccuda.CUDA_ARRAY3D_DESCRIPTOR* cpMipmappedArrayDesc_ptr = pMipmappedArrayDesc._ptr if pMipmappedArrayDesc != None else NULL
    err = ccuda.cuMipmappedArrayCreate(pHandle._ptr, cpMipmappedArrayDesc_ptr, numMipmapLevels)
    return (CUresult(err), pHandle)

@cython.embedsignature(True)
def cuMipmappedArrayGetLevel(hMipmappedArray, unsigned int level):
    """ Gets a mipmap level of a CUDA mipmapped array.

    Returns in `*pLevelArray` a CUDA array that represents a single mipmap
    level of the CUDA mipmapped array `hMipmappedArray`.

    If `level` is greater than the maximum number of levels in this
    mipmapped array, :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

    Parameters
    ----------
    hMipmappedArray : :py:obj:`~.CUmipmappedArray`
        CUDA mipmapped array
    level : unsigned int
        Mipmap level

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    pLevelArray : :py:obj:`~.CUarray`
        Returned mipmap level CUDA array

    See Also
    --------
    :py:obj:`~.cuMipmappedArrayCreate`, :py:obj:`~.cuMipmappedArrayDestroy`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cudaGetMipmappedArrayLevel`
    """
    cdef ccuda.CUmipmappedArray chMipmappedArray
    if hMipmappedArray is None:
        chMipmappedArray = <ccuda.CUmipmappedArray><void_ptr>0
    elif isinstance(hMipmappedArray, (CUmipmappedArray)):
        phMipmappedArray = int(hMipmappedArray)
        chMipmappedArray = <ccuda.CUmipmappedArray><void_ptr>phMipmappedArray
    else:
        phMipmappedArray = int(CUmipmappedArray(hMipmappedArray))
        chMipmappedArray = <ccuda.CUmipmappedArray><void_ptr>phMipmappedArray

    cdef CUarray pLevelArray = CUarray()
    err = ccuda.cuMipmappedArrayGetLevel(pLevelArray._ptr, chMipmappedArray, level)
    return (CUresult(err), pLevelArray)

@cython.embedsignature(True)
def cuMipmappedArrayDestroy(hMipmappedArray):
    """ Destroys a CUDA mipmapped array.

    Destroys the CUDA mipmapped array `hMipmappedArray`.

    Parameters
    ----------
    hMipmappedArray : :py:obj:`~.CUmipmappedArray`
        Mipmapped array to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ARRAY_IS_MAPPED`, :py:obj:`~.CUDA_ERROR_CONTEXT_IS_DESTROYED`

    See Also
    --------
    :py:obj:`~.cuMipmappedArrayCreate`, :py:obj:`~.cuMipmappedArrayGetLevel`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cudaFreeMipmappedArray`
    """
    cdef ccuda.CUmipmappedArray chMipmappedArray
    if hMipmappedArray is None:
        chMipmappedArray = <ccuda.CUmipmappedArray><void_ptr>0
    elif isinstance(hMipmappedArray, (CUmipmappedArray)):
        phMipmappedArray = int(hMipmappedArray)
        chMipmappedArray = <ccuda.CUmipmappedArray><void_ptr>phMipmappedArray
    else:
        phMipmappedArray = int(CUmipmappedArray(hMipmappedArray))
        chMipmappedArray = <ccuda.CUmipmappedArray><void_ptr>phMipmappedArray

    err = ccuda.cuMipmappedArrayDestroy(chMipmappedArray)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemAddressReserve(size_t size, size_t alignment, addr, unsigned long long flags):
    """ Allocate an address range reservation.

    Reserves a virtual address range based on the given parameters, giving
    the starting address of the range in `ptr`. This API requires a system
    that supports UVA. The size and address parameters must be a multiple
    of the host page size and the alignment must be a power of two or zero
    for default alignment.

    Parameters
    ----------
    size : size_t
        Size of the reserved virtual address range requested
    alignment : size_t
        Alignment of the reserved virtual address range requested
    addr : :py:obj:`~.CUdeviceptr`
        Fixed starting address range requested
    flags : unsigned long long
        Currently unused, must be zero

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    ptr : :py:obj:`~.CUdeviceptr`
        Resulting pointer to start of virtual address range allocated

    See Also
    --------
    :py:obj:`~.cuMemAddressFree`
    """
    cdef ccuda.CUdeviceptr caddr
    if addr is None:
        caddr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(addr, (CUdeviceptr)):
        paddr = int(addr)
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr
    else:
        paddr = int(CUdeviceptr(addr))
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr

    cdef CUdeviceptr ptr = CUdeviceptr()
    err = ccuda.cuMemAddressReserve(ptr._ptr, size, alignment, caddr, flags)
    return (CUresult(err), ptr)

@cython.embedsignature(True)
def cuMemAddressFree(ptr, size_t size):
    """ Free an address range reservation.

    Frees a virtual address range reserved by cuMemAddressReserve. The size
    must match what was given to memAddressReserve and the ptr given must
    match what was returned from memAddressReserve.

    Parameters
    ----------
    ptr : :py:obj:`~.CUdeviceptr`
        Starting address of the virtual address range to free
    size : size_t
        Size of the virtual address region to free

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuMemAddressReserve`
    """
    cdef ccuda.CUdeviceptr cptr
    if ptr is None:
        cptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(ptr, (CUdeviceptr)):
        pptr = int(ptr)
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr
    else:
        pptr = int(CUdeviceptr(ptr))
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr

    err = ccuda.cuMemAddressFree(cptr, size)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemCreate(size_t size, prop : CUmemAllocationProp, unsigned long long flags):
    """ Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.

    This creates a memory allocation on the target device specified through
    the `prop` strcuture. The created allocation will not have any device
    or host mappings. The generic memory `handle` for the allocation can be
    mapped to the address space of calling process via
    :py:obj:`~.cuMemMap`. This handle cannot be transmitted directly to
    other processes (see :py:obj:`~.cuMemExportToShareableHandle`). On
    Windows, the caller must also pass an LPSECURITYATTRIBUTE in `prop` to
    be associated with this handle which limits or allows access to this
    handle for a recepient process (see
    :py:obj:`~.CUmemAllocationProp.win32HandleMetaData` for more). The
    `size` of this allocation must be a multiple of the the value given via
    :py:obj:`~.cuMemGetAllocationGranularity` with the
    :py:obj:`~.CU_MEM_ALLOC_GRANULARITY_MINIMUM` flag. If
    :py:obj:`~.CUmemAllocationProp`::allocFlags::usage contains
    :py:obj:`~.CU_MEM_CREATE_USAGE_TILE_POOL` flag then the memory
    allocation is intended only to be used as backing tile pool for sparse
    CUDA arrays and sparse CUDA mipmapped arrays. (see
    :py:obj:`~.cuMemMapArrayAsync`).

    Parameters
    ----------
    size : size_t
        Size of the allocation requested
    prop : :py:obj:`~.CUmemAllocationProp`
        Properties of the allocation to create.
    flags : unsigned long long
        flags for future use, must be zero now.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    handle : :py:obj:`~.CUmemGenericAllocationHandle`
        Value of handle returned. All operations on this allocation are to
        be performed using this handle.

    See Also
    --------
    :py:obj:`~.cuMemRelease`, :py:obj:`~.cuMemExportToShareableHandle`, :py:obj:`~.cuMemImportFromShareableHandle`
    """
    cdef CUmemGenericAllocationHandle handle = CUmemGenericAllocationHandle()
    cdef ccuda.CUmemAllocationProp* cprop_ptr = prop._ptr if prop != None else NULL
    err = ccuda.cuMemCreate(handle._ptr, size, cprop_ptr, flags)
    return (CUresult(err), handle)

@cython.embedsignature(True)
def cuMemRelease(handle):
    """ Release a memory handle representing a memory allocation which was previously allocated through cuMemCreate.

    Frees the memory that was allocated on a device through cuMemCreate.

    The memory allocation will be freed when all outstanding mappings to
    the memory are unmapped and when all outstanding references to the
    handle (including it's shareable counterparts) are also released. The
    generic memory handle can be freed when there are still outstanding
    mappings made with this handle. Each time a recepient process imports a
    shareable handle, it needs to pair it with :py:obj:`~.cuMemRelease` for
    the handle to be freed. If `handle` is not a valid handle the behavior
    is undefined.

    Parameters
    ----------
    handle : :py:obj:`~.CUmemGenericAllocationHandle`
        Value of handle which was returned previously by cuMemCreate.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuMemCreate`
    """
    cdef ccuda.CUmemGenericAllocationHandle chandle
    if handle is None:
        chandle = <ccuda.CUmemGenericAllocationHandle><void_ptr>0
    elif isinstance(handle, (CUmemGenericAllocationHandle)):
        phandle = int(handle)
        chandle = <ccuda.CUmemGenericAllocationHandle><void_ptr>phandle
    else:
        phandle = int(CUmemGenericAllocationHandle(handle))
        chandle = <ccuda.CUmemGenericAllocationHandle><void_ptr>phandle

    err = ccuda.cuMemRelease(chandle)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemMap(ptr, size_t size, size_t offset, handle, unsigned long long flags):
    """ Maps an allocation handle to a reserved virtual address range.

    Maps bytes of memory represented by `handle` starting from byte
    `offset` to `size` to address range [`addr`, `addr` + `size`]. This
    range must be an address reservation previously reserved with
    :py:obj:`~.cuMemAddressReserve`, and `offset` + `size` must be less
    than the size of the memory allocation. Both `ptr`, `size`, and
    `offset` must be a multiple of the value given via
    :py:obj:`~.cuMemGetAllocationGranularity` with the
    :py:obj:`~.CU_MEM_ALLOC_GRANULARITY_MINIMUM` flag.

    Please note calling :py:obj:`~.cuMemMap` does not make the address
    accessible, the caller needs to update accessibility of a contiguous
    mapped VA range by calling :py:obj:`~.cuMemSetAccess`.

    Once a recipient process obtains a shareable memory handle from
    :py:obj:`~.cuMemImportFromShareableHandle`, the process must use
    :py:obj:`~.cuMemMap` to map the memory into its address ranges before
    setting accessibility with :py:obj:`~.cuMemSetAccess`.

    :py:obj:`~.cuMemMap` can only create mappings on VA range reservations
    that are not currently mapped.

    Parameters
    ----------
    ptr : :py:obj:`~.CUdeviceptr`
        Address where memory will be mapped.
    size : size_t
        Size of the memory mapping.
    offset : size_t
        Offset into the memory represented by
    handle : :py:obj:`~.CUmemGenericAllocationHandle`
        Handle to a shareable memory
    flags : unsigned long long
        flags for future use, must be zero now.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuMemUnmap`, :py:obj:`~.cuMemSetAccess`, :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemAddressReserve`, :py:obj:`~.cuMemImportFromShareableHandle`
    """
    cdef ccuda.CUmemGenericAllocationHandle chandle
    if handle is None:
        chandle = <ccuda.CUmemGenericAllocationHandle><void_ptr>0
    elif isinstance(handle, (CUmemGenericAllocationHandle)):
        phandle = int(handle)
        chandle = <ccuda.CUmemGenericAllocationHandle><void_ptr>phandle
    else:
        phandle = int(CUmemGenericAllocationHandle(handle))
        chandle = <ccuda.CUmemGenericAllocationHandle><void_ptr>phandle

    cdef ccuda.CUdeviceptr cptr
    if ptr is None:
        cptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(ptr, (CUdeviceptr)):
        pptr = int(ptr)
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr
    else:
        pptr = int(CUdeviceptr(ptr))
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr

    err = ccuda.cuMemMap(cptr, size, offset, chandle, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemMapArrayAsync(mapInfoList : List[CUarrayMapInfo], unsigned int count, hStream):
    """ Maps or unmaps subregions of sparse CUDA arrays and sparse CUDA mipmapped arrays.

    Performs map or unmap operations on subregions of sparse CUDA arrays
    and sparse CUDA mipmapped arrays. Each operation is specified by a
    :py:obj:`~.CUarrayMapInfo` entry in the `mapInfoList` array of size
    `count`. The structure :py:obj:`~.CUarrayMapInfo` is defined as follow:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.CUarrayMapInfo.resourceType` specifies the type of
    resource to be operated on. If :py:obj:`~.CUarrayMapInfo.resourceType`
    is set to :py:obj:`~.CUresourcetype`::CU_RESOURCE_TYPE_ARRAY then
    :py:obj:`~.CUarrayMapInfo`::resource::array must be set to a valid
    sparse CUDA array handle. The CUDA array must be either a 2D, 2D
    layered or 3D CUDA array and must have been allocated using
    :py:obj:`~.cuArrayCreate` or :py:obj:`~.cuArray3DCreate` with the flag
    :py:obj:`~.CUDA_ARRAY3D_SPARSE`

    or :py:obj:`~.CUDA_ARRAY3D_DEFERRED_MAPPING`.

    For CUDA arrays obtained using :py:obj:`~.cuMipmappedArrayGetLevel`,
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned. If
    :py:obj:`~.CUarrayMapInfo.resourceType` is set to
    :py:obj:`~.CUresourcetype`::CU_RESOURCE_TYPE_MIPMAPPED_ARRAY then
    :py:obj:`~.CUarrayMapInfo`::resource::mipmap must be set to a valid
    sparse CUDA mipmapped array handle. The CUDA mipmapped array must be
    either a 2D, 2D layered or 3D CUDA mipmapped array and must have been
    allocated using :py:obj:`~.cuMipmappedArrayCreate` with the flag
    :py:obj:`~.CUDA_ARRAY3D_SPARSE`

    or :py:obj:`~.CUDA_ARRAY3D_DEFERRED_MAPPING`.

    :py:obj:`~.CUarrayMapInfo.subresourceType` specifies the type of
    subresource within the resource.
    :py:obj:`~.CUarraySparseSubresourceType_enum` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where
    :py:obj:`~.CUarraySparseSubresourceType`::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL
    indicates a sparse-miplevel which spans at least one tile in every
    dimension. The remaining miplevels which are too small to span at least
    one tile in any dimension constitute the mip tail region as indicated
    by
    :py:obj:`~.CUarraySparseSubresourceType`::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL
    subresource type.

    If :py:obj:`~.CUarrayMapInfo.subresourceType` is set to
    :py:obj:`~.CUarraySparseSubresourceType`::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL
    then :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel struct must
    contain valid array subregion offsets and extents. The
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::offsetX,
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::offsetY and
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::offsetZ must
    specify valid X, Y and Z offsets respectively. The
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::extentWidth,
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::extentHeight and
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::extentDepth must
    specify valid width, height and depth extents respectively. These
    offsets and extents must be aligned to the corresponding tile
    dimension. For CUDA mipmapped arrays
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::level must
    specify a valid mip level index. Otherwise, must be zero. For layered
    CUDA arrays and layered CUDA mipmapped arrays
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::layer must
    specify a valid layer index. Otherwise, must be zero.
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::offsetZ must be
    zero and
    :py:obj:`~.CUarrayMapInfo`::subresource::sparseLevel::extentDepth must
    be set to 1 for 2D and 2D layered CUDA arrays and CUDA mipmapped
    arrays. Tile extents can be obtained by calling
    :py:obj:`~.cuArrayGetSparseProperties` and
    :py:obj:`~.cuMipmappedArrayGetSparseProperties`

    If :py:obj:`~.CUarrayMapInfo.subresourceType` is set to
    :py:obj:`~.CUarraySparseSubresourceType`::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL
    then :py:obj:`~.CUarrayMapInfo`::subresource::miptail struct must
    contain valid mip tail offset in
    :py:obj:`~.CUarrayMapInfo`::subresource::miptail::offset and size in
    :py:obj:`~.CUarrayMapInfo`::subresource::miptail::size. Both, mip tail
    offset and mip tail size must be aligned to the tile size. For layered
    CUDA mipmapped arrays which don't have the flag
    :py:obj:`~.CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL` set in
    :py:obj:`~.CUDA_ARRAY_SPARSE_PROPERTIES.flags` as returned by
    :py:obj:`~.cuMipmappedArrayGetSparseProperties`,
    :py:obj:`~.CUarrayMapInfo`::subresource::miptail::layer must specify a
    valid layer index. Otherwise, must be zero.

    If :py:obj:`~.CUarrayMapInfo`::resource::array or
    :py:obj:`~.CUarrayMapInfo`::resource::mipmap was created with
    :py:obj:`~.CUDA_ARRAY3D_DEFERRED_MAPPING` flag set the
    :py:obj:`~.CUarrayMapInfo.subresourceType` and the contents of
    :py:obj:`~.CUarrayMapInfo`::subresource will be ignored.

    :py:obj:`~.CUarrayMapInfo.memOperationType` specifies the type of
    operation. :py:obj:`~.CUmemOperationType` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.CUarrayMapInfo.memOperationType` is set to
    :py:obj:`~.CUmemOperationType`::CU_MEM_OPERATION_TYPE_MAP then the
    subresource will be mapped onto the tile pool memory specified by
    :py:obj:`~.CUarrayMapInfo`::memHandle at offset
    :py:obj:`~.CUarrayMapInfo.offset`. The tile pool allocation has to be
    created by specifying the :py:obj:`~.CU_MEM_CREATE_USAGE_TILE_POOL`
    flag when calling :py:obj:`~.cuMemCreate`. Also,
    :py:obj:`~.CUarrayMapInfo.memHandleType` must be set to
    :py:obj:`~.CUmemHandleType`::CU_MEM_HANDLE_TYPE_GENERIC.

    If :py:obj:`~.CUarrayMapInfo.memOperationType` is set to
    :py:obj:`~.CUmemOperationType`::CU_MEM_OPERATION_TYPE_UNMAP then an
    unmapping operation is performed. :py:obj:`~.CUarrayMapInfo`::memHandle
    must be NULL.

    :py:obj:`~.CUarrayMapInfo.deviceBitMask` specifies the list of devices
    that must map or unmap physical memory. Currently, this mask must have
    exactly one bit set, and the corresponding device must match the device
    associated with the stream. If
    :py:obj:`~.CUarrayMapInfo.memOperationType` is set to
    :py:obj:`~.CUmemOperationType`::CU_MEM_OPERATION_TYPE_MAP, the device
    must also match the device associated with the tile pool memory
    allocation as specified by :py:obj:`~.CUarrayMapInfo`::memHandle.

    :py:obj:`~.CUarrayMapInfo.flags` and
    :py:obj:`~.CUarrayMapInfo.reserved`[] are unused and must be set to
    zero.

    Parameters
    ----------
    mapInfoList : List[:py:obj:`~.CUarrayMapInfo`]
        List of :py:obj:`~.CUarrayMapInfo`
    count : unsigned int
        Count of :py:obj:`~.CUarrayMapInfo` in `mapInfoList`
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier for the stream to use for map or unmap operations

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuMipmappedArrayCreate`, :py:obj:`~.cuArrayCreate`, :py:obj:`~.cuArray3DCreate`, :py:obj:`~.cuMemCreate`, :py:obj:`~.cuArrayGetSparseProperties`, :py:obj:`~.cuMipmappedArrayGetSparseProperties`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    mapInfoList = [] if mapInfoList is None else mapInfoList
    if not all(isinstance(_x, (CUarrayMapInfo)) for _x in mapInfoList):
        raise TypeError("Argument 'mapInfoList' is not instance of type (expected List[ccuda.CUarrayMapInfo]")

    cdef ccuda.CUarrayMapInfo* cmapInfoList = NULL
    if len(mapInfoList) > 0:
        cmapInfoList = <ccuda.CUarrayMapInfo*> calloc(len(mapInfoList), sizeof(ccuda.CUarrayMapInfo))
        if cmapInfoList is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(mapInfoList)) + 'x' + str(sizeof(ccuda.CUarrayMapInfo)))
        for idx in range(len(mapInfoList)):
            memcpy(&cmapInfoList[idx], (<CUarrayMapInfo>mapInfoList[idx])._ptr, sizeof(ccuda.CUarrayMapInfo))

    if count > len(mapInfoList): raise RuntimeError("List is too small: " + str(len(mapInfoList)) + " < " + str(count))
    err = ccuda.cuMemMapArrayAsync((<CUarrayMapInfo>mapInfoList[0])._ptr if len(mapInfoList) == 1 else cmapInfoList, count, chStream)
    if cmapInfoList is not NULL:
        free(cmapInfoList)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemUnmap(ptr, size_t size):
    """ Unmap the backing memory of a given address range.

    The range must be the entire contiguous address range that was mapped
    to. In other words, :py:obj:`~.cuMemUnmap` cannot unmap a sub-range of
    an address range mapped by :py:obj:`~.cuMemCreate` /
    :py:obj:`~.cuMemMap`. Any backing memory allocations will be freed if
    there are no existing mappings and there are no unreleased memory
    handles.

    When :py:obj:`~.cuMemUnmap` returns successfully the address range is
    converted to an address reservation and can be used for a future calls
    to :py:obj:`~.cuMemMap`. Any new mapping to this virtual address will
    need to have access granted through :py:obj:`~.cuMemSetAccess`, as all
    mappings start with no accessibility setup.

    Parameters
    ----------
    ptr : :py:obj:`~.CUdeviceptr`
        Starting address for the virtual address range to unmap
    size : size_t
        Size of the virtual address range to unmap

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemAddressReserve`
    """
    cdef ccuda.CUdeviceptr cptr
    if ptr is None:
        cptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(ptr, (CUdeviceptr)):
        pptr = int(ptr)
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr
    else:
        pptr = int(CUdeviceptr(ptr))
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr

    err = ccuda.cuMemUnmap(cptr, size)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemSetAccess(ptr, size_t size, desc : List[CUmemAccessDesc], size_t count):
    """ Set the access flags for each location specified in `desc` for the given virtual address range.

    Given the virtual address range via `ptr` and `size`, and the locations
    in the array given by `desc` and `count`, set the access flags for the
    target locations. The range must be a fully mapped address range
    containing all allocations created by :py:obj:`~.cuMemMap` /
    :py:obj:`~.cuMemCreate`.

    Parameters
    ----------
    ptr : :py:obj:`~.CUdeviceptr`
        Starting address for the virtual address range
    size : size_t
        Length of the virtual address range
    desc : List[:py:obj:`~.CUmemAccessDesc`]
        Array of :py:obj:`~.CUmemAccessDesc` that describe how to change
        the
    count : size_t
        Number of :py:obj:`~.CUmemAccessDesc` in `desc`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuMemSetAccess`, :py:obj:`~.cuMemCreate`, :py:obj:`~.py`:obj:`~.cuMemMap`
    """
    desc = [] if desc is None else desc
    if not all(isinstance(_x, (CUmemAccessDesc)) for _x in desc):
        raise TypeError("Argument 'desc' is not instance of type (expected List[ccuda.CUmemAccessDesc]")

    cdef ccuda.CUdeviceptr cptr
    if ptr is None:
        cptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(ptr, (CUdeviceptr)):
        pptr = int(ptr)
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr
    else:
        pptr = int(CUdeviceptr(ptr))
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr

    cdef ccuda.CUmemAccessDesc* cdesc = NULL
    if len(desc) > 0:
        cdesc = <ccuda.CUmemAccessDesc*> calloc(len(desc), sizeof(ccuda.CUmemAccessDesc))
        if cdesc is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(desc)) + 'x' + str(sizeof(ccuda.CUmemAccessDesc)))
        for idx in range(len(desc)):
            memcpy(&cdesc[idx], (<CUmemAccessDesc>desc[idx])._ptr, sizeof(ccuda.CUmemAccessDesc))

    if count > <size_t>len(desc): raise RuntimeError("List is too small: " + str(len(desc)) + " < " + str(count))
    err = ccuda.cuMemSetAccess(cptr, size, (<CUmemAccessDesc>desc[0])._ptr if len(desc) == 1 else cdesc, count)
    if cdesc is not NULL:
        free(cdesc)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemGetAccess(location : CUmemLocation, ptr):
    """ Get the access `flags` set for the given `location` and `ptr`.

    Parameters
    ----------
    location : :py:obj:`~.CUmemLocation`
        Location in which to check the flags for
    ptr : :py:obj:`~.CUdeviceptr`
        Address in which to check the access flags for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    flags : unsigned long long
        Flags set for this location

    See Also
    --------
    :py:obj:`~.cuMemSetAccess`
    """
    cdef ccuda.CUdeviceptr cptr
    if ptr is None:
        cptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(ptr, (CUdeviceptr)):
        pptr = int(ptr)
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr
    else:
        pptr = int(CUdeviceptr(ptr))
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr

    cdef unsigned long long flags = 0
    cdef ccuda.CUmemLocation* clocation_ptr = location._ptr if location != None else NULL
    err = ccuda.cuMemGetAccess(&flags, clocation_ptr, cptr)
    return (CUresult(err), flags)

@cython.embedsignature(True)
def cuMemExportToShareableHandle(handle, handleType not None : CUmemAllocationHandleType, unsigned long long flags):
    """ Exports an allocation to a requested shareable handle type.

    Given a CUDA memory handle, create a shareable memory allocation handle
    that can be used to share the memory with other processes. The
    recipient process can convert the shareable handle back into a CUDA
    memory handle using :py:obj:`~.cuMemImportFromShareableHandle` and map
    it with :py:obj:`~.cuMemMap`. The implementation of what this handle is
    and how it can be transferred is defined by the requested handle type
    in `handleType`

    Once all shareable handles are closed and the allocation is released,
    the allocated memory referenced will be released back to the OS and
    uses of the CUDA handle afterward will lead to undefined behavior.

    This API can also be used in conjunction with other APIs (e.g. Vulkan,
    OpenGL) that support importing memory from the shareable type

    Parameters
    ----------
    handle : :py:obj:`~.CUmemGenericAllocationHandle`
        CUDA handle for the memory allocation
    handleType : :py:obj:`~.CUmemAllocationHandleType`
        Type of shareable handle requested (defines type and size of the
        `shareableHandle` output parameter)
    flags : unsigned long long
        Reserved, must be zero

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    shareableHandle : Any
        Pointer to the location in which to store the requested handle type

    See Also
    --------
    :py:obj:`~.cuMemImportFromShareableHandle`
    """
    cdef ccuda.CUmemGenericAllocationHandle chandle
    if handle is None:
        chandle = <ccuda.CUmemGenericAllocationHandle><void_ptr>0
    elif isinstance(handle, (CUmemGenericAllocationHandle)):
        phandle = int(handle)
        chandle = <ccuda.CUmemGenericAllocationHandle><void_ptr>phandle
    else:
        phandle = int(CUmemGenericAllocationHandle(handle))
        chandle = <ccuda.CUmemGenericAllocationHandle><void_ptr>phandle

    cdef void_ptr shareableHandle = 0
    cdef void* cshareableHandle_ptr = <void*>shareableHandle
    cdef ccuda.CUmemAllocationHandleType chandleType = handleType.value
    err = ccuda.cuMemExportToShareableHandle(cshareableHandle_ptr, chandle, chandleType, flags)
    return (CUresult(err), shareableHandle)

@cython.embedsignature(True)
def cuMemImportFromShareableHandle(osHandle, shHandleType not None : CUmemAllocationHandleType):
    """ Imports an allocation from a requested shareable handle type.

    If the current process cannot support the memory described by this
    shareable handle, this API will error as CUDA_ERROR_NOT_SUPPORTED.

    Parameters
    ----------
    osHandle : Any
        Shareable Handle representing the memory allocation that is to be
        imported.
    shHandleType : :py:obj:`~.CUmemAllocationHandleType`
        handle type of the exported handle
        :py:obj:`~.CUmemAllocationHandleType`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    handle : :py:obj:`~.CUmemGenericAllocationHandle`
        CUDA Memory handle for the memory allocation.

    See Also
    --------
    :py:obj:`~.cuMemExportToShareableHandle`, :py:obj:`~.cuMemMap`, :py:obj:`~.cuMemRelease`

    Notes
    -----
    Importing shareable handles exported from some graphics APIs(VUlkan, OpenGL, etc) created on devices under an SLI group may not be supported, and thus this API will return CUDA_ERROR_NOT_SUPPORTED. There is no guarantee that the contents of `handle` will be the same CUDA memory handle for the same given OS shareable handle, or the same underlying allocation.
    """
    cdef CUmemGenericAllocationHandle handle = CUmemGenericAllocationHandle()
    cosHandle = utils.HelperInputVoidPtr(osHandle)
    cdef void* cosHandle_ptr = <void*><void_ptr>cosHandle.cptr
    cdef ccuda.CUmemAllocationHandleType cshHandleType = shHandleType.value
    err = ccuda.cuMemImportFromShareableHandle(handle._ptr, cosHandle_ptr, cshHandleType)
    return (CUresult(err), handle)

@cython.embedsignature(True)
def cuMemGetAllocationGranularity(prop : CUmemAllocationProp, option not None : CUmemAllocationGranularity_flags):
    """ Calculates either the minimal or recommended granularity.

    Calculates either the minimal or recommended granularity for a given
    allocation specification and returns it in granularity. This
    granularity can be used as a multiple for alignment, size, or address
    mapping.

    Parameters
    ----------
    prop : :py:obj:`~.CUmemAllocationProp`
        Property for which to determine the granularity for
    option : :py:obj:`~.CUmemAllocationGranularity_flags`
        Determines which granularity to return

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    granularity : int
        Returned granularity.

    See Also
    --------
    :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemMap`
    """
    cdef size_t granularity = 0
    cdef ccuda.CUmemAllocationProp* cprop_ptr = prop._ptr if prop != None else NULL
    cdef ccuda.CUmemAllocationGranularity_flags coption = option.value
    err = ccuda.cuMemGetAllocationGranularity(&granularity, cprop_ptr, coption)
    return (CUresult(err), granularity)

@cython.embedsignature(True)
def cuMemGetAllocationPropertiesFromHandle(handle):
    """ Retrieve the contents of the property structure defining properties for this handle.

    Parameters
    ----------
    handle : :py:obj:`~.CUmemGenericAllocationHandle`
        Handle which to perform the query on

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    prop : :py:obj:`~.CUmemAllocationProp`
        Pointer to a properties structure which will hold the information
        about this handle

    See Also
    --------
    :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemImportFromShareableHandle`
    """
    cdef ccuda.CUmemGenericAllocationHandle chandle
    if handle is None:
        chandle = <ccuda.CUmemGenericAllocationHandle><void_ptr>0
    elif isinstance(handle, (CUmemGenericAllocationHandle)):
        phandle = int(handle)
        chandle = <ccuda.CUmemGenericAllocationHandle><void_ptr>phandle
    else:
        phandle = int(CUmemGenericAllocationHandle(handle))
        chandle = <ccuda.CUmemGenericAllocationHandle><void_ptr>phandle

    cdef CUmemAllocationProp prop = CUmemAllocationProp()
    err = ccuda.cuMemGetAllocationPropertiesFromHandle(prop._ptr, chandle)
    return (CUresult(err), prop)

@cython.embedsignature(True)
def cuMemRetainAllocationHandle(addr):
    """ Given an address `addr`, returns the allocation handle of the backing memory allocation.

    The handle is guaranteed to be the same handle value used to map the
    memory. If the address requested is not mapped, the function will fail.
    The returned handle must be released with corresponding number of calls
    to :py:obj:`~.cuMemRelease`.

    Parameters
    ----------
    addr : Any
        Memory address to query, that has been mapped previously.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    handle : :py:obj:`~.CUmemGenericAllocationHandle`
        CUDA Memory handle for the backing memory allocation.

    See Also
    --------
    :py:obj:`~.cuMemCreate`, :py:obj:`~.cuMemRelease`, :py:obj:`~.cuMemMap`

    Notes
    -----
    The address `addr`, can be any address in a range previously mapped by :py:obj:`~.cuMemMap`, and not necessarily the start address.
    """
    cdef CUmemGenericAllocationHandle handle = CUmemGenericAllocationHandle()
    caddr = utils.HelperInputVoidPtr(addr)
    cdef void* caddr_ptr = <void*><void_ptr>caddr.cptr
    err = ccuda.cuMemRetainAllocationHandle(handle._ptr, caddr_ptr)
    return (CUresult(err), handle)

@cython.embedsignature(True)
def cuMemFreeAsync(dptr, hStream):
    """ Frees memory with stream ordered semantics.

    Inserts a free operation into `hStream`. The allocation must not be
    accessed after stream execution reaches the free. After this API
    returns, accessing the memory from any subsequent work launched on the
    GPU or querying its pointer attributes results in undefined behavior.

    Parameters
    ----------
    dptr : :py:obj:`~.CUdeviceptr`
        memory to free
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream establishing the stream ordering contract.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` (default stream specified with no current context), :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    Notes
    -----
    During stream capture, this function results in the creation of a free node and must therefore be passed the address of a graph allocation.
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUdeviceptr cdptr
    if dptr is None:
        cdptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dptr, (CUdeviceptr)):
        pdptr = int(dptr)
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr
    else:
        pdptr = int(CUdeviceptr(dptr))
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr

    err = ccuda.cuMemFreeAsync(cdptr, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemAllocAsync(size_t bytesize, hStream):
    """ Allocates memory with stream ordered semantics.

    Inserts an allocation operation into `hStream`. A pointer to the
    allocated memory is returned immediately in *dptr. The allocation must
    not be accessed until the the allocation operation completes. The
    allocation comes from the memory pool current to the stream's device.

    Parameters
    ----------
    bytesize : size_t
        Number of bytes to allocate
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream establishing the stream ordering contract and the memory
        pool to allocate from

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` (default stream specified with no current context), :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    dptr : :py:obj:`~.CUdeviceptr`
        Returned device pointer

    See Also
    --------
    :py:obj:`~.cuMemAllocFromPoolAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceSetMemPool`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuMemPoolSetAccess`, :py:obj:`~.cuMemPoolSetAttribute`

    Notes
    -----
    The default memory pool of a device contains device memory from that device.

    Basic stream ordering allows future work submitted into the same stream to use the allocation. Stream query, stream synchronize, and CUDA events can be used to guarantee that the allocation operation completes before work submitted in a separate stream runs.

    During stream capture, this function results in the creation of an allocation node. In this case, the allocation is owned by the graph instead of the memory pool. The memory pool's properties are used to set the node's creation parameters.
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef CUdeviceptr dptr = CUdeviceptr()
    err = ccuda.cuMemAllocAsync(dptr._ptr, bytesize, chStream)
    return (CUresult(err), dptr)

@cython.embedsignature(True)
def cuMemPoolTrimTo(pool, size_t minBytesToKeep):
    """ Tries to release memory back to the OS.

    Releases memory back to the OS until the pool contains fewer than
    minBytesToKeep reserved bytes, or there is no more memory that the
    allocator can safely release. The allocator cannot release OS
    allocations that back outstanding asynchronous allocations. The OS
    allocations may happen at different granularity from the user
    allocations.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        The memory pool to trim
    minBytesToKeep : size_t
        If the pool has less than minBytesToKeep reserved, the TrimTo
        operation is a no-op. Otherwise the pool will be guaranteed to have
        at least minBytesToKeep bytes reserved after the operation.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`

    Notes
    -----
    : Allocations that have not been freed count as outstanding.

    : Allocations that have been asynchronously freed but whose completion has not been observed on the host (eg. by a synchronize) can count as outstanding.
    """
    cdef ccuda.CUmemoryPool cpool
    if pool is None:
        cpool = <ccuda.CUmemoryPool><void_ptr>0
    elif isinstance(pool, (CUmemoryPool)):
        ppool = int(pool)
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool
    else:
        ppool = int(CUmemoryPool(pool))
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool

    err = ccuda.cuMemPoolTrimTo(cpool, minBytesToKeep)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemPoolSetAttribute(pool, attr not None : CUmemPool_attribute, value):
    """ Sets attributes of a memory pool.

    Supported attributes are:

    - :py:obj:`~.CU_MEMPOOL_ATTR_RELEASE_THRESHOLD`: (value type =
      cuuint64_t) Amount of reserved memory in bytes to hold onto before
      trying to release memory back to the OS. When more than the release
      threshold bytes of memory are held by the memory pool, the allocator
      will try to release memory back to the OS on the next call to stream,
      event or context synchronize. (default 0)

    - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES`: (value
      type = int) Allow :py:obj:`~.cuMemAllocAsync` to use memory
      asynchronously freed in another stream as long as a stream ordering
      dependency of the allocating stream on the free action exists. Cuda
      events and null stream interactions can create the required stream
      ordered dependencies. (default enabled)

    - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC`: (value type =
      int) Allow reuse of already completed frees when there is no
      dependency between the free and allocation. (default enabled)

    - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES`: (value
      type = int) Allow :py:obj:`~.cuMemAllocAsync` to insert new stream
      dependencies in order to establish the stream ordering required to
      reuse a piece of memory released by :py:obj:`~.cuMemFreeAsync`
      (default enabled).

    - :py:obj:`~.CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH`: (value type =
      cuuint64_t) Reset the high watermark that tracks the amount of
      backing memory that was allocated for the memory pool. It is illegal
      to set this attribute to a non-zero value.

    - :py:obj:`~.CU_MEMPOOL_ATTR_USED_MEM_HIGH`: (value type = cuuint64_t)
      Reset the high watermark that tracks the amount of used memory that
      was allocated for the memory pool.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        The memory pool to modify
    attr : :py:obj:`~.CUmemPool_attribute`
        The attribute to modify
    value : Any
        Pointer to the value to assign

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`
    """
    cdef ccuda.CUmemoryPool cpool
    if pool is None:
        cpool = <ccuda.CUmemoryPool><void_ptr>0
    elif isinstance(pool, (CUmemoryPool)):
        ppool = int(pool)
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool
    else:
        ppool = int(CUmemoryPool(pool))
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool

    cdef ccuda.CUmemPool_attribute cattr = attr.value
    cdef utils.HelperCUmemPool_attribute cvalue = utils.HelperCUmemPool_attribute(attr, value, is_getter=False)
    cdef void* cvalue_ptr = <void*><void_ptr>cvalue.cptr
    err = ccuda.cuMemPoolSetAttribute(cpool, cattr, cvalue_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemPoolGetAttribute(pool, attr not None : CUmemPool_attribute):
    """ Gets attributes of a memory pool.

    Supported attributes are:

    - :py:obj:`~.CU_MEMPOOL_ATTR_RELEASE_THRESHOLD`: (value type =
      cuuint64_t) Amount of reserved memory in bytes to hold onto before
      trying to release memory back to the OS. When more than the release
      threshold bytes of memory are held by the memory pool, the allocator
      will try to release memory back to the OS on the next call to stream,
      event or context synchronize. (default 0)

    - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES`: (value
      type = int) Allow :py:obj:`~.cuMemAllocAsync` to use memory
      asynchronously freed in another stream as long as a stream ordering
      dependency of the allocating stream on the free action exists. Cuda
      events and null stream interactions can create the required stream
      ordered dependencies. (default enabled)

    - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC`: (value type =
      int) Allow reuse of already completed frees when there is no
      dependency between the free and allocation. (default enabled)

    - :py:obj:`~.CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES`: (value
      type = int) Allow :py:obj:`~.cuMemAllocAsync` to insert new stream
      dependencies in order to establish the stream ordering required to
      reuse a piece of memory released by :py:obj:`~.cuMemFreeAsync`
      (default enabled).

    - :py:obj:`~.CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT`: (value type =
      cuuint64_t) Amount of backing memory currently allocated for the
      mempool

    - :py:obj:`~.CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH`: (value type =
      cuuint64_t) High watermark of backing memory allocated for the
      mempool since the last time it was reset.

    - :py:obj:`~.CU_MEMPOOL_ATTR_USED_MEM_CURRENT`: (value type =
      cuuint64_t) Amount of memory from the pool that is currently in use
      by the application.

    - :py:obj:`~.CU_MEMPOOL_ATTR_USED_MEM_HIGH`: (value type = cuuint64_t)
      High watermark of the amount of memory from the pool that was in use
      by the application.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        The memory pool to get attributes of
    attr : :py:obj:`~.CUmemPool_attribute`
        The attribute to get

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    value : Any
        Retrieved value

    See Also
    --------
    :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`
    """
    cdef ccuda.CUmemoryPool cpool
    if pool is None:
        cpool = <ccuda.CUmemoryPool><void_ptr>0
    elif isinstance(pool, (CUmemoryPool)):
        ppool = int(pool)
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool
    else:
        ppool = int(CUmemoryPool(pool))
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool

    cdef ccuda.CUmemPool_attribute cattr = attr.value
    cdef utils.HelperCUmemPool_attribute cvalue = utils.HelperCUmemPool_attribute(attr, 0, is_getter=True)
    cdef void* cvalue_ptr = <void*><void_ptr>cvalue.cptr
    err = ccuda.cuMemPoolGetAttribute(cpool, cattr, cvalue_ptr)
    return (CUresult(err), cvalue.pyObj())

@cython.embedsignature(True)
def cuMemPoolSetAccess(pool, map : List[CUmemAccessDesc], size_t count):
    """ Controls visibility of pools between devices.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        The pool being modified
    map : List[:py:obj:`~.CUmemAccessDesc`]
        Array of access descriptors. Each descriptor instructs the access
        to enable for a single gpu.
    count : size_t
        Number of descriptors in the map array.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`
    """
    map = [] if map is None else map
    if not all(isinstance(_x, (CUmemAccessDesc)) for _x in map):
        raise TypeError("Argument 'map' is not instance of type (expected List[ccuda.CUmemAccessDesc]")

    cdef ccuda.CUmemoryPool cpool
    if pool is None:
        cpool = <ccuda.CUmemoryPool><void_ptr>0
    elif isinstance(pool, (CUmemoryPool)):
        ppool = int(pool)
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool
    else:
        ppool = int(CUmemoryPool(pool))
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool

    cdef ccuda.CUmemAccessDesc* cmap = NULL
    if len(map) > 0:
        cmap = <ccuda.CUmemAccessDesc*> calloc(len(map), sizeof(ccuda.CUmemAccessDesc))
        if cmap is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(map)) + 'x' + str(sizeof(ccuda.CUmemAccessDesc)))
        for idx in range(len(map)):
            memcpy(&cmap[idx], (<CUmemAccessDesc>map[idx])._ptr, sizeof(ccuda.CUmemAccessDesc))

    if count > <size_t>len(map): raise RuntimeError("List is too small: " + str(len(map)) + " < " + str(count))
    err = ccuda.cuMemPoolSetAccess(cpool, (<CUmemAccessDesc>map[0])._ptr if len(map) == 1 else cmap, count)
    if cmap is not NULL:
        free(cmap)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemPoolGetAccess(memPool, location : CUmemLocation):
    """ Returns the accessibility of a pool from a device.

    Returns the accessibility of the pool's memory from the specified
    location.

    Parameters
    ----------
    memPool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        the pool being queried
    location : :py:obj:`~.CUmemLocation`
        the location accessing the pool

    Returns
    -------
    CUresult

    flags : :py:obj:`~.CUmemAccess_flags`
        the accessibility of the pool from the specified location

    See Also
    --------
    :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`
    """
    cdef ccuda.CUmemoryPool cmemPool
    if memPool is None:
        cmemPool = <ccuda.CUmemoryPool><void_ptr>0
    elif isinstance(memPool, (CUmemoryPool)):
        pmemPool = int(memPool)
        cmemPool = <ccuda.CUmemoryPool><void_ptr>pmemPool
    else:
        pmemPool = int(CUmemoryPool(memPool))
        cmemPool = <ccuda.CUmemoryPool><void_ptr>pmemPool

    cdef ccuda.CUmemAccess_flags flags
    cdef ccuda.CUmemLocation* clocation_ptr = location._ptr if location != None else NULL
    err = ccuda.cuMemPoolGetAccess(&flags, cmemPool, clocation_ptr)
    return (CUresult(err), CUmemAccess_flags(flags))

@cython.embedsignature(True)
def cuMemPoolCreate(poolProps : CUmemPoolProps):
    """ Creates a memory pool.

    Creates a CUDA memory pool and returns the handle in `pool`. The
    `poolProps` determines the properties of the pool such as the backing
    device and IPC capabilities.

    By default, the pool's memory will be accessible from the device it is
    allocated on.

    Parameters
    ----------
    poolProps : :py:obj:`~.CUmemPoolProps`
        None

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`
    pool : :py:obj:`~.CUmemoryPool`
        None

    See Also
    --------
    :py:obj:`~.cuDeviceSetMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuMemAllocFromPoolAsync`, :py:obj:`~.cuMemPoolExportToShareableHandle`

    Notes
    -----
    Specifying CU_MEM_HANDLE_TYPE_NONE creates a memory pool that will not support IPC.
    """
    cdef CUmemoryPool pool = CUmemoryPool()
    cdef ccuda.CUmemPoolProps* cpoolProps_ptr = poolProps._ptr if poolProps != None else NULL
    err = ccuda.cuMemPoolCreate(pool._ptr, cpoolProps_ptr)
    return (CUresult(err), pool)

@cython.embedsignature(True)
def cuMemPoolDestroy(pool):
    """ Destroys the specified memory pool.

    If any pointers obtained from this pool haven't been freed or the pool
    has free operations that haven't completed when
    :py:obj:`~.cuMemPoolDestroy` is invoked, the function will return
    immediately and the resources associated with the pool will be released
    automatically once there are no more outstanding allocations.

    Destroying the current mempool of a device sets the default mempool of
    that device as the current mempool for that device.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        None

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceSetMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuMemPoolCreate`

    Notes
    -----
    A device's default memory pool cannot be destroyed.
    """
    cdef ccuda.CUmemoryPool cpool
    if pool is None:
        cpool = <ccuda.CUmemoryPool><void_ptr>0
    elif isinstance(pool, (CUmemoryPool)):
        ppool = int(pool)
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool
    else:
        ppool = int(CUmemoryPool(pool))
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool

    err = ccuda.cuMemPoolDestroy(cpool)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemAllocFromPoolAsync(size_t bytesize, pool, hStream):
    """ Allocates memory from a specified pool with stream ordered semantics.

    Inserts an allocation operation into `hStream`. A pointer to the
    allocated memory is returned immediately in *dptr. The allocation must
    not be accessed until the the allocation operation completes. The
    allocation comes from the specified memory pool.

    Parameters
    ----------
    bytesize : size_t
        Number of bytes to allocate
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        The pool to allocate from
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream establishing the stream ordering semantic

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` (default stream specified with no current context), :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    dptr : :py:obj:`~.CUdeviceptr`
        Returned device pointer

    See Also
    --------
    :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuMemPoolSetAccess`, :py:obj:`~.cuMemPoolSetAttribute`

    Notes
    -----
    During stream capture, this function results in the creation of an allocation node. In this case, the allocation is owned by the graph instead of the memory pool. The memory pool's properties are used to set the node's creation parameters.
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUmemoryPool cpool
    if pool is None:
        cpool = <ccuda.CUmemoryPool><void_ptr>0
    elif isinstance(pool, (CUmemoryPool)):
        ppool = int(pool)
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool
    else:
        ppool = int(CUmemoryPool(pool))
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool

    cdef CUdeviceptr dptr = CUdeviceptr()
    err = ccuda.cuMemAllocFromPoolAsync(dptr._ptr, bytesize, cpool, chStream)
    return (CUresult(err), dptr)

@cython.embedsignature(True)
def cuMemPoolExportToShareableHandle(pool, handleType not None : CUmemAllocationHandleType, unsigned long long flags):
    """ Exports a memory pool to the requested handle type.

    Given an IPC capable mempool, create an OS handle to share the pool
    with another process. A recipient process can convert the shareable
    handle into a mempool with
    :py:obj:`~.cuMemPoolImportFromShareableHandle`. Individual pointers can
    then be shared with the :py:obj:`~.cuMemPoolExportPointer` and
    :py:obj:`~.cuMemPoolImportPointer` APIs. The implementation of what the
    shareable handle is and how it can be transferred is defined by the
    requested handle type.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        pool to export
    handleType : :py:obj:`~.CUmemAllocationHandleType`
        the type of handle to create
    flags : unsigned long long
        must be 0

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    handle_out : Any
        Returned OS handle

    See Also
    --------
    :py:obj:`~.cuMemPoolImportFromShareableHandle`, :py:obj:`~.cuMemPoolExportPointer`, :py:obj:`~.cuMemPoolImportPointer`, :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuDeviceGetDefaultMemPool`, :py:obj:`~.cuDeviceGetMemPool`, :py:obj:`~.cuMemPoolCreate`, :py:obj:`~.cuMemPoolSetAccess`, :py:obj:`~.cuMemPoolSetAttribute`

    Notes
    -----
    : To create an IPC capable mempool, create a mempool with a CUmemAllocationHandleType other than CU_MEM_HANDLE_TYPE_NONE.
    """
    cdef ccuda.CUmemoryPool cpool
    if pool is None:
        cpool = <ccuda.CUmemoryPool><void_ptr>0
    elif isinstance(pool, (CUmemoryPool)):
        ppool = int(pool)
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool
    else:
        ppool = int(CUmemoryPool(pool))
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool

    cdef void_ptr handle_out = 0
    cdef void* chandle_out_ptr = <void*>handle_out
    cdef ccuda.CUmemAllocationHandleType chandleType = handleType.value
    err = ccuda.cuMemPoolExportToShareableHandle(chandle_out_ptr, cpool, chandleType, flags)
    return (CUresult(err), handle_out)

@cython.embedsignature(True)
def cuMemPoolImportFromShareableHandle(handle, handleType not None : CUmemAllocationHandleType, unsigned long long flags):
    """ imports a memory pool from a shared handle.

    Specific allocations can be imported from the imported pool with
    cuMemPoolImportPointer.

    Parameters
    ----------
    handle : Any
        OS handle of the pool to open
    handleType : :py:obj:`~.CUmemAllocationHandleType`
        The type of handle being imported
    flags : unsigned long long
        must be 0

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    pool_out : :py:obj:`~.CUmemoryPool`
        Returned memory pool

    See Also
    --------
    :py:obj:`~.cuMemPoolExportToShareableHandle`, :py:obj:`~.cuMemPoolExportPointer`, :py:obj:`~.cuMemPoolImportPointer`

    Notes
    -----
    Imported memory pools do not support creating new allocations. As such imported memory pools may not be used in cuDeviceSetMemPool or :py:obj:`~.cuMemAllocFromPoolAsync` calls.
    """
    cdef CUmemoryPool pool_out = CUmemoryPool()
    chandle = utils.HelperInputVoidPtr(handle)
    cdef void* chandle_ptr = <void*><void_ptr>chandle.cptr
    cdef ccuda.CUmemAllocationHandleType chandleType = handleType.value
    err = ccuda.cuMemPoolImportFromShareableHandle(pool_out._ptr, chandle_ptr, chandleType, flags)
    return (CUresult(err), pool_out)

@cython.embedsignature(True)
def cuMemPoolExportPointer(ptr):
    """ Export data to share a memory pool allocation between processes.

    Constructs `shareData_out` for sharing a specific allocation from an
    already shared memory pool. The recipient process can import the
    allocation with the :py:obj:`~.cuMemPoolImportPointer` api. The data is
    not a handle and may be shared through any IPC mechanism.

    Parameters
    ----------
    ptr : :py:obj:`~.CUdeviceptr`
        pointer to memory being exported

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    shareData_out : :py:obj:`~.CUmemPoolPtrExportData`
        Returned export data

    See Also
    --------
    :py:obj:`~.cuMemPoolExportToShareableHandle`, :py:obj:`~.cuMemPoolImportFromShareableHandle`, :py:obj:`~.cuMemPoolImportPointer`
    """
    cdef ccuda.CUdeviceptr cptr
    if ptr is None:
        cptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(ptr, (CUdeviceptr)):
        pptr = int(ptr)
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr
    else:
        pptr = int(CUdeviceptr(ptr))
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr

    cdef CUmemPoolPtrExportData shareData_out = CUmemPoolPtrExportData()
    err = ccuda.cuMemPoolExportPointer(shareData_out._ptr, cptr)
    return (CUresult(err), shareData_out)

@cython.embedsignature(True)
def cuMemPoolImportPointer(pool, shareData : CUmemPoolPtrExportData):
    """ Import a memory pool allocation from another process.

    Returns in `ptr_out` a pointer to the imported memory. The imported
    memory must not be accessed before the allocation operation completes
    in the exporting process. The imported memory must be freed from all
    importing processes before being freed in the exporting process. The
    pointer may be freed with cuMemFree or cuMemFreeAsync. If
    cuMemFreeAsync is used, the free must be completed on the importing
    process before the free operation on the exporting process.

    Parameters
    ----------
    pool : :py:obj:`~.CUmemoryPool` or :py:obj:`~.cudaMemPool_t`
        pool from which to import
    shareData : :py:obj:`~.CUmemPoolPtrExportData`
        data specifying the memory to import

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    ptr_out : :py:obj:`~.CUdeviceptr`
        pointer to imported memory

    See Also
    --------
    :py:obj:`~.cuMemPoolExportToShareableHandle`, :py:obj:`~.cuMemPoolImportFromShareableHandle`, :py:obj:`~.cuMemPoolExportPointer`

    Notes
    -----
    The cuMemFreeAsync api may be used in the exporting process before the cuMemFreeAsync operation completes in its stream as long as the cuMemFreeAsync in the exporting process specifies a stream with a stream dependency on the importing process's cuMemFreeAsync.
    """
    cdef ccuda.CUmemoryPool cpool
    if pool is None:
        cpool = <ccuda.CUmemoryPool><void_ptr>0
    elif isinstance(pool, (CUmemoryPool)):
        ppool = int(pool)
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool
    else:
        ppool = int(CUmemoryPool(pool))
        cpool = <ccuda.CUmemoryPool><void_ptr>ppool

    cdef CUdeviceptr ptr_out = CUdeviceptr()
    cdef ccuda.CUmemPoolPtrExportData* cshareData_ptr = shareData._ptr if shareData != None else NULL
    err = ccuda.cuMemPoolImportPointer(ptr_out._ptr, cpool, cshareData_ptr)
    return (CUresult(err), ptr_out)

@cython.embedsignature(True)
def cuPointerGetAttribute(attribute not None : CUpointer_attribute, ptr):
    """ Returns information about a pointer.

    The supported attributes are:

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_CONTEXT`:

    - Returns in `*data` the :py:obj:`~.CUcontext` in which `ptr` was
      allocated or registered. The type of `data` must be
      :py:obj:`~.CUcontext` *.

    - If `ptr` was not allocated by, mapped by, or registered with a
      :py:obj:`~.CUcontext` which uses unified virtual addressing then
      :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_MEMORY_TYPE`:

    - Returns in `*data` the physical memory type of the memory that `ptr`
      addresses as a :py:obj:`~.CUmemorytype` enumerated value. The type of
      `data` must be unsigned int.

    - If `ptr` addresses device memory then `*data` is set to
      :py:obj:`~.CU_MEMORYTYPE_DEVICE`. The particular :py:obj:`~.CUdevice`
      on which the memory resides is the :py:obj:`~.CUdevice` of the
      :py:obj:`~.CUcontext` returned by the
      :py:obj:`~.CU_POINTER_ATTRIBUTE_CONTEXT` attribute of `ptr`.

    - If `ptr` addresses host memory then `*data` is set to
      :py:obj:`~.CU_MEMORYTYPE_HOST`.

    - If `ptr` was not allocated by, mapped by, or registered with a
      :py:obj:`~.CUcontext` which uses unified virtual addressing then
      :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

    - If the current :py:obj:`~.CUcontext` does not support unified virtual
      addressing then :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` is returned.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_DEVICE_POINTER`:

    - Returns in `*data` the device pointer value through which `ptr` may
      be accessed by kernels running in the current :py:obj:`~.CUcontext`.
      The type of `data` must be CUdeviceptr *.

    - If there exists no device pointer value through which kernels running
      in the current :py:obj:`~.CUcontext` may access `ptr` then
      :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

    - If there is no current :py:obj:`~.CUcontext` then
      :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` is returned.

    - Except in the exceptional disjoint addressing cases discussed below,
      the value returned in `*data` will equal the input value `ptr`.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_HOST_POINTER`:

    - Returns in `*data` the host pointer value through which `ptr` may be
      accessed by by the host program. The type of `data` must be void **.
      If there exists no host pointer value through which the host program
      may directly access `ptr` then :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
      is returned.

    - Except in the exceptional disjoint addressing cases discussed below,
      the value returned in `*data` will equal the input value `ptr`.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_P2P_TOKENS`:

    - Returns in `*data` two tokens for use with the nv-p2p.h Linux kernel
      interface. `data` must be a struct of type
      CUDA_POINTER_ATTRIBUTE_P2P_TOKENS.

    - `ptr` must be a pointer to memory obtained from
      :py:obj:`~.py`:obj:`~.cuMemAlloc()`. Note that p2pToken and
      vaSpaceToken are only valid for the lifetime of the source
      allocation. A subsequent allocation at the same address may return
      completely different tokens. Querying this attribute has a side
      effect of setting the attribute
      :py:obj:`~.CU_POINTER_ATTRIBUTE_SYNC_MEMOPS` for the region of memory
      that `ptr` points to.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_SYNC_MEMOPS`:

    - A boolean attribute which when set, ensures that synchronous memory
      operations initiated on the region of memory that `ptr` points to
      will always synchronize. See further documentation in the section
      titled "API synchronization behavior" to learn more about cases when
      synchronous memory operations can exhibit asynchronous behavior.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_BUFFER_ID`:

    - Returns in `*data` a buffer ID which is guaranteed to be unique
      within the process. `data` must point to an unsigned long long.

    - `ptr` must be a pointer to memory obtained from a CUDA memory
      allocation API. Every memory allocation from any of the CUDA memory
      allocation APIs will have a unique ID over a process lifetime.
      Subsequent allocations do not reuse IDs from previous freed
      allocations. IDs are only unique within a single process.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_MANAGED`:

    - Returns in `*data` a boolean that indicates whether the pointer
      points to managed memory or not.

    - If `ptr` is not a valid CUDA pointer then
      :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL`:

    - Returns in `*data` an integer representing a device ordinal of a
      device against which the memory was allocated or registered.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE`:

    - Returns in `*data` a boolean that indicates if this pointer maps to
      an allocation that is suitable for :py:obj:`~.cudaIpcGetMemHandle`.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_RANGE_START_ADDR`:

    - Returns in `*data` the starting address for the allocation referenced
      by the device pointer `ptr`. Note that this is not necessarily the
      address of the mapped region, but the address of the mappable address
      range `ptr` references (e.g. from :py:obj:`~.cuMemAddressReserve`).

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_RANGE_SIZE`:

    - Returns in `*data` the size for the allocation referenced by the
      device pointer `ptr`. Note that this is not necessarily the size of
      the mapped region, but the size of the mappable address range `ptr`
      references (e.g. from :py:obj:`~.cuMemAddressReserve`). To retrieve
      the size of the mapped region, see :py:obj:`~.cuMemGetAddressRange`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_MAPPED`:

    - Returns in `*data` a boolean that indicates if this pointer is in a
      valid address range that is mapped to a backing allocation.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES`:

    - Returns a bitmask of the allowed handle types for an allocation that
      may be passed to :py:obj:`~.cuMemExportToShareableHandle`.

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE`:

    - Returns in `*data` the handle to the mempool that the allocation was
      obtained from.

    Note that for most allocations in the unified virtual address space the
    host and device pointer for accessing the allocation will be the same.
    The exceptions to this are

    - user memory registered using :py:obj:`~.cuMemHostRegister`

    - host memory allocated using :py:obj:`~.cuMemHostAlloc` with the
      :py:obj:`~.CU_MEMHOSTALLOC_WRITECOMBINED` flag For these types of
      allocation there will exist separate, disjoint host and device
      addresses for accessing the allocation. In particular

    - The host address will correspond to an invalid unmapped device
      address (which will result in an exception if accessed from the
      device)

    - The device address will correspond to an invalid unmapped host
      address (which will result in an exception if accessed from the
      host). For these types of allocations, querying
      :py:obj:`~.CU_POINTER_ATTRIBUTE_HOST_POINTER` and
      :py:obj:`~.CU_POINTER_ATTRIBUTE_DEVICE_POINTER` may be used to
      retrieve the host and device addresses from either address.

    Parameters
    ----------
    attribute : :py:obj:`~.CUpointer_attribute`
        Pointer attribute to query
    ptr : :py:obj:`~.CUdeviceptr`
        Pointer

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    data : Any
        Returned pointer attribute value

    See Also
    --------
    :py:obj:`~.cuPointerSetAttribute`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuMemHostUnregister`, :py:obj:`~.cudaPointerGetAttributes`
    """
    cdef ccuda.CUdeviceptr cptr
    if ptr is None:
        cptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(ptr, (CUdeviceptr)):
        pptr = int(ptr)
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr
    else:
        pptr = int(CUdeviceptr(ptr))
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr

    cdef utils.HelperCUpointer_attribute cdata = utils.HelperCUpointer_attribute(attribute, 0, is_getter=True)
    cdef void* cdata_ptr = <void*><void_ptr>cdata.cptr
    cdef ccuda.CUpointer_attribute cattribute = attribute.value
    err = ccuda.cuPointerGetAttribute(cdata_ptr, cattribute, cptr)
    return (CUresult(err), cdata.pyObj())

@cython.embedsignature(True)
def cuMemPrefetchAsync(devPtr, size_t count, dstDevice, hStream):
    """ Prefetches memory to the specified destination device.

    Prefetches memory to the specified destination device. `devPtr` is the
    base device pointer of the memory to be prefetched and `dstDevice` is
    the destination device. `count` specifies the number of bytes to copy.
    `hStream` is the stream in which the operation is enqueued. The memory
    range must refer to managed memory allocated via
    :py:obj:`~.cuMemAllocManaged` or declared via managed variables.

    Passing in CU_DEVICE_CPU for `dstDevice` will prefetch the data to host
    memory. If `dstDevice` is a GPU, then the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` must be non-
    zero. Additionally, `hStream` must be associated with a device that has
    a non-zero value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`.

    The start address and end address of the memory range will be rounded
    down and rounded up respectively to be aligned to CPU page size before
    the prefetch operation is enqueued in the stream.

    If no physical memory has been allocated for this region, then this
    memory region will be populated and mapped on the destination device.
    If there's insufficient memory to prefetch the desired region, the
    Unified Memory driver may evict pages from other
    :py:obj:`~.cuMemAllocManaged` allocations to host memory in order to
    make room. Device memory allocated using :py:obj:`~.cuMemAlloc` or
    :py:obj:`~.cuArrayCreate` will not be evicted.

    By default, any mappings to the previous location of the migrated pages
    are removed and mappings for the new location are only setup on
    `dstDevice`. The exact behavior however also depends on the settings
    applied to this memory range via :py:obj:`~.cuMemAdvise` as described
    below:

    If :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY` was set on any subset of
    this memory range, then that subset will create a read-only copy of the
    pages on `dstDevice`.

    If :py:obj:`~.CU_MEM_ADVISE_SET_PREFERRED_LOCATION` was called on any
    subset of this memory range, then the pages will be migrated to
    `dstDevice` even if `dstDevice` is not the preferred location of any
    pages in the memory range.

    If :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY` was called on any subset
    of this memory range, then mappings to those pages from all the
    appropriate processors are updated to refer to the new location if
    establishing such a mapping is possible. Otherwise, those mappings are
    cleared.

    Note that this API is not required for functionality and only serves to
    improve performance by allowing the application to migrate data to a
    suitable location before it is accessed. Memory accesses to this range
    are always coherent and are allowed even when the data is actively
    being migrated.

    Note that this function is asynchronous with respect to the host and
    all work on other devices.

    Parameters
    ----------
    devPtr : :py:obj:`~.CUdeviceptr`
        Pointer to be prefetched
    count : size_t
        Size in bytes
    dstDevice : :py:obj:`~.CUdevice`
        Destination device to prefetch to
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to enqueue prefetch operation

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`

    See Also
    --------
    :py:obj:`~.cuMemcpy`, :py:obj:`~.cuMemcpyPeer`, :py:obj:`~.cuMemcpyAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cuMemAdvise`, :py:obj:`~.cudaMemPrefetchAsync`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUdevice cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdevice>0
    elif isinstance(dstDevice, (CUdevice)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdevice>pdstDevice
    else:
        pdstDevice = int(CUdevice(dstDevice))
        cdstDevice = <ccuda.CUdevice>pdstDevice

    cdef ccuda.CUdeviceptr cdevPtr
    if devPtr is None:
        cdevPtr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(devPtr, (CUdeviceptr)):
        pdevPtr = int(devPtr)
        cdevPtr = <ccuda.CUdeviceptr><void_ptr>pdevPtr
    else:
        pdevPtr = int(CUdeviceptr(devPtr))
        cdevPtr = <ccuda.CUdeviceptr><void_ptr>pdevPtr

    err = ccuda.cuMemPrefetchAsync(cdevPtr, count, cdstDevice, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemAdvise(devPtr, size_t count, advice not None : CUmem_advise, device):
    """ Advise about the usage of a given memory range.

    Advise the Unified Memory subsystem about the usage pattern for the
    memory range starting at `devPtr` with a size of `count` bytes. The
    start address and end address of the memory range will be rounded down
    and rounded up respectively to be aligned to CPU page size before the
    advice is applied. The memory range must refer to managed memory
    allocated via :py:obj:`~.cuMemAllocManaged` or declared via managed
    variables. The memory range could also refer to system-allocated
    pageable memory provided it represents a valid, host-accessible region
    of memory and all additional constraints imposed by `advice` as
    outlined below are also satisfied. Specifying an invalid system-
    allocated pageable memory range results in an error being returned.

    The `advice` parameter can take the following values:

    - :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY`: This implies that the data
      is mostly going to be read from and only occasionally written to. Any
      read accesses from any processor to this region will create a read-
      only copy of at least the accessed pages in that processor's memory.
      Additionally, if :py:obj:`~.cuMemPrefetchAsync` is called on this
      region, it will create a read-only copy of the data on the
      destination processor. If any processor writes to this region, all
      copies of the corresponding page will be invalidated except for the
      one where the write occurred. The `device` argument is ignored for
      this advice. Note that for a page to be read-duplicated, the
      accessing processor must either be the CPU or a GPU that has a non-
      zero value for the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. Also, if a
      context is created on a device that does not have the device
      attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`
      set, then read-duplication will not occur until all such contexts are
      destroyed. If the memory region refers to valid system-allocated
      pageable memory, then the accessing device must have a non-zero value
      for the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS` for a read-
      only copy to be created on that device. Note however that if the
      accessing device also has a non-zero value for the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
      then setting this advice will not create a read-only copy when that
      device accesses this memory region.

    - :py:obj:`~.CU_MEM_ADVISE_UNSET_READ_MOSTLY`: Undoes the effect of
      :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY` and also prevents the
      Unified Memory driver from attempting heuristic read-duplication on
      the memory range. Any read-duplicated copies of the data will be
      collapsed into a single copy. The location for the collapsed copy
      will be the preferred location if the page has a preferred location
      and one of the read-duplicated copies was resident at that location.
      Otherwise, the location chosen is arbitrary.

    - :py:obj:`~.CU_MEM_ADVISE_SET_PREFERRED_LOCATION`: This advice sets
      the preferred location for the data to be the memory belonging to
      `device`. Passing in CU_DEVICE_CPU for `device` sets the preferred
      location as host memory. If `device` is a GPU, then it must have a
      non-zero value for the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. Setting
      the preferred location does not cause data to migrate to that
      location immediately. Instead, it guides the migration policy when a
      fault occurs on that memory region. If the data is already in its
      preferred location and the faulting processor can establish a mapping
      without requiring the data to be migrated, then data migration will
      be avoided. On the other hand, if the data is not in its preferred
      location or if a direct mapping cannot be established, then it will
      be migrated to the processor accessing it. It is important to note
      that setting the preferred location does not prevent data prefetching
      done using :py:obj:`~.cuMemPrefetchAsync`. Having a preferred
      location can override the page thrash detection and resolution logic
      in the Unified Memory driver. Normally, if a page is detected to be
      constantly thrashing between for example host and device memory, the
      page may eventually be pinned to host memory by the Unified Memory
      driver. But if the preferred location is set as device memory, then
      the page will continue to thrash indefinitely. If
      :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY` is also set on this memory
      region or any subset of it, then the policies associated with that
      advice will override the policies of this advice, unless read
      accesses from `device` will not result in a read-only copy being
      created on that device as outlined in description for the advice
      :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY`. If the memory region
      refers to valid system-allocated pageable memory, then `device` must
      have a non-zero value for the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`. Additionally,
      if `device` has a non-zero value for the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
      then this call has no effect. Note however that this behavior may
      change in the future.

    - :py:obj:`~.CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION`: Undoes the effect
      of :py:obj:`~.CU_MEM_ADVISE_SET_PREFERRED_LOCATION` and changes the
      preferred location to none.

    - :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY`: This advice implies that
      the data will be accessed by `device`. Passing in
      :py:obj:`~.CU_DEVICE_CPU` for `device` will set the advice for the
      CPU. If `device` is a GPU, then the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS` must be
      non-zero. This advice does not cause data migration and has no impact
      on the location of the data per se. Instead, it causes the data to
      always be mapped in the specified processor's page tables, as long as
      the location of the data permits a mapping to be established. If the
      data gets migrated for any reason, the mappings are updated
      accordingly. This advice is recommended in scenarios where data
      locality is not important, but avoiding faults is. Consider for
      example a system containing multiple GPUs with peer-to-peer access
      enabled, where the data located on one GPU is occasionally accessed
      by peer GPUs. In such scenarios, migrating data over to the other
      GPUs is not as important because the accesses are infrequent and the
      overhead of migration may be too high. But preventing faults can
      still help improve performance, and so having a mapping set up in
      advance is useful. Note that on CPU access of this data, the data may
      be migrated to host memory because the CPU typically cannot access
      device memory directly. Any GPU that had the
      :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY` flag set for this data will
      now have its mapping updated to point to the page in host memory. If
      :py:obj:`~.CU_MEM_ADVISE_SET_READ_MOSTLY` is also set on this memory
      region or any subset of it, then the policies associated with that
      advice will override the policies of this advice. Additionally, if
      the preferred location of this memory region or any subset of it is
      also `device`, then the policies associated with
      :py:obj:`~.CU_MEM_ADVISE_SET_PREFERRED_LOCATION` will override the
      policies of this advice. If the memory region refers to valid system-
      allocated pageable memory, then `device` must have a non-zero value
      for the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`. Additionally,
      if `device` has a non-zero value for the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
      then this call has no effect.

    - :py:obj:`~.CU_MEM_ADVISE_UNSET_ACCESSED_BY`: Undoes the effect of
      :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY`. Any mappings to the data
      from `device` may be removed at any time causing accesses to result
      in non-fatal page faults. If the memory region refers to valid
      system-allocated pageable memory, then `device` must have a non-zero
      value for the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`. Additionally,
      if `device` has a non-zero value for the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES`,
      then this call has no effect.

    Parameters
    ----------
    devPtr : :py:obj:`~.CUdeviceptr`
        Pointer to memory to set the advice for
    count : size_t
        Size in bytes of the memory range
    advice : :py:obj:`~.CUmem_advise`
        Advice to be applied for the specified memory range
    device : :py:obj:`~.CUdevice`
        Device to apply the advice for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`

    See Also
    --------
    :py:obj:`~.cuMemcpy`, :py:obj:`~.cuMemcpyPeer`, :py:obj:`~.cuMemcpyAsync`, :py:obj:`~.cuMemcpy3DPeerAsync`, :py:obj:`~.cuMemPrefetchAsync`, :py:obj:`~.cudaMemAdvise`
    """
    cdef ccuda.CUdevice cdevice
    if device is None:
        cdevice = <ccuda.CUdevice>0
    elif isinstance(device, (CUdevice)):
        pdevice = int(device)
        cdevice = <ccuda.CUdevice>pdevice
    else:
        pdevice = int(CUdevice(device))
        cdevice = <ccuda.CUdevice>pdevice

    cdef ccuda.CUdeviceptr cdevPtr
    if devPtr is None:
        cdevPtr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(devPtr, (CUdeviceptr)):
        pdevPtr = int(devPtr)
        cdevPtr = <ccuda.CUdeviceptr><void_ptr>pdevPtr
    else:
        pdevPtr = int(CUdeviceptr(devPtr))
        cdevPtr = <ccuda.CUdeviceptr><void_ptr>pdevPtr

    cdef ccuda.CUmem_advise cadvice = advice.value
    err = ccuda.cuMemAdvise(cdevPtr, count, cadvice, cdevice)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuMemRangeGetAttribute(size_t dataSize, attribute not None : CUmem_range_attribute, devPtr, size_t count):
    """ Query an attribute of a given memory range.

    Query an attribute about the memory range starting at `devPtr` with a
    size of `count` bytes. The memory range must refer to managed memory
    allocated via :py:obj:`~.cuMemAllocManaged` or declared via managed
    variables.

    The `attribute` parameter can take the following values:

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY`: If this attribute is
      specified, `data` will be interpreted as a 32-bit integer, and
      `dataSize` must be 4. The result returned will be 1 if all pages in
      the given memory range have read-duplication enabled, or 0 otherwise.

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION`: If this
      attribute is specified, `data` will be interpreted as a 32-bit
      integer, and `dataSize` must be 4. The result returned will be a GPU
      device id if all pages in the memory range have that GPU as their
      preferred location, or it will be CU_DEVICE_CPU if all pages in the
      memory range have the CPU as their preferred location, or it will be
      CU_DEVICE_INVALID if either all the pages don't have the same
      preferred location or some of the pages don't have a preferred
      location at all. Note that the actual location of the pages in the
      memory range at the time of the query may be different from the
      preferred location.

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY`: If this attribute is
      specified, `data` will be interpreted as an array of 32-bit integers,
      and `dataSize` must be a non-zero multiple of 4. The result returned
      will be a list of device ids that had
      :py:obj:`~.CU_MEM_ADVISE_SET_ACCESSED_BY` set for that entire memory
      range. If any device does not have that advice set for the entire
      memory range, that device will not be included. If `data` is larger
      than the number of devices that have that advice set for that memory
      range, CU_DEVICE_INVALID will be returned in all the extra space
      provided. For ex., if `dataSize` is 12 (i.e. `data` has 3 elements)
      and only device 0 has the advice set, then the result returned will
      be { 0, CU_DEVICE_INVALID, CU_DEVICE_INVALID }. If `data` is smaller
      than the number of devices that have that advice set, then only as
      many devices will be returned as can fit in the array. There is no
      guarantee on which specific devices will be returned, however.

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION`: If this
      attribute is specified, `data` will be interpreted as a 32-bit
      integer, and `dataSize` must be 4. The result returned will be the
      last location to which all pages in the memory range were prefetched
      explicitly via :py:obj:`~.cuMemPrefetchAsync`. This will either be a
      GPU id or CU_DEVICE_CPU depending on whether the last location for
      prefetch was a GPU or the CPU respectively. If any page in the memory
      range was never explicitly prefetched or if all pages were not
      prefetched to the same location, CU_DEVICE_INVALID will be returned.
      Note that this simply returns the last location that the applicaton
      requested to prefetch the memory range to. It gives no indication as
      to whether the prefetch operation to that location has completed or
      even begun.

    Parameters
    ----------
    dataSize : size_t
        Array containing the size of data
    attribute : :py:obj:`~.CUmem_range_attribute`
        The attribute to query
    devPtr : :py:obj:`~.CUdeviceptr`
        Start of the range to query
    count : size_t
        Size of the range to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    data : Any
        A pointers to a memory location where the result of each attribute
        query will be written to.

    See Also
    --------
    :py:obj:`~.cuMemRangeGetAttributes`, :py:obj:`~.cuMemPrefetchAsync`, :py:obj:`~.cuMemAdvise`, :py:obj:`~.cudaMemRangeGetAttribute`
    """
    cdef ccuda.CUdeviceptr cdevPtr
    if devPtr is None:
        cdevPtr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(devPtr, (CUdeviceptr)):
        pdevPtr = int(devPtr)
        cdevPtr = <ccuda.CUdeviceptr><void_ptr>pdevPtr
    else:
        pdevPtr = int(CUdeviceptr(devPtr))
        cdevPtr = <ccuda.CUdeviceptr><void_ptr>pdevPtr

    cdef utils.HelperCUmem_range_attribute cdata = utils.HelperCUmem_range_attribute(attribute, dataSize)
    cdef void* cdata_ptr = <void*><void_ptr>cdata.cptr
    cdef ccuda.CUmem_range_attribute cattribute = attribute.value
    err = ccuda.cuMemRangeGetAttribute(cdata_ptr, dataSize, cattribute, cdevPtr, count)
    return (CUresult(err), cdata.pyObj())

@cython.embedsignature(True)
def cuMemRangeGetAttributes(dataSizes : List[int], attributes : List[CUmem_range_attribute], size_t numAttributes, devPtr, size_t count):
    """ Query attributes of a given memory range.

    Query attributes of the memory range starting at `devPtr` with a size
    of `count` bytes. The memory range must refer to managed memory
    allocated via :py:obj:`~.cuMemAllocManaged` or declared via managed
    variables. The `attributes` array will be interpreted to have
    `numAttributes` entries. The `dataSizes` array will also be interpreted
    to have `numAttributes` entries. The results of the query will be
    stored in `data`.

    The list of supported attributes are given below. Please refer to
    :py:obj:`~.cuMemRangeGetAttribute` for attribute descriptions and
    restrictions.

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY`

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION`

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY`

    - :py:obj:`~.CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION`

    Parameters
    ----------
    dataSizes : List[int]
        Array containing the sizes of each result
    attributes : List[:py:obj:`~.CUmem_range_attribute`]
        An array of attributes to query (numAttributes and the number of
        attributes in this array should match)
    numAttributes : size_t
        Number of attributes to query
    devPtr : :py:obj:`~.CUdeviceptr`
        Start of the range to query
    count : size_t
        Size of the range to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    data : List[Any]
        A two-dimensional array containing pointers to memory locations
        where the result of each attribute query will be written to.

    See Also
    --------
    :py:obj:`~.cuMemRangeGetAttribute`, :py:obj:`~.cuMemAdvise`, :py:obj:`~.cuMemPrefetchAsync`, :py:obj:`~.cudaMemRangeGetAttributes`
    """
    cdef ccuda.CUdeviceptr cdevPtr
    if devPtr is None:
        cdevPtr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(devPtr, (CUdeviceptr)):
        pdevPtr = int(devPtr)
        cdevPtr = <ccuda.CUdeviceptr><void_ptr>pdevPtr
    else:
        pdevPtr = int(CUdeviceptr(devPtr))
        cdevPtr = <ccuda.CUdeviceptr><void_ptr>pdevPtr

    attributes = [] if attributes is None else attributes
    if not all(isinstance(_x, (CUmem_range_attribute)) for _x in attributes):
        raise TypeError("Argument 'attributes' is not instance of type (expected List[ccuda.CUmem_range_attribute]")

    if not all(isinstance(_x, (int)) for _x in dataSizes):
        raise TypeError("Argument 'dataSizes' is not instance of type (expected List[int]")

    pylist = [utils.HelperCUmem_range_attribute(pyattributes, pydataSizes) for (pyattributes, pydataSizes) in zip(attributes, dataSizes)]
    cdef utils.InputVoidPtrPtrHelper voidStarHelper = utils.InputVoidPtrPtrHelper(pylist)
    cdef void** cvoidStarHelper_ptr = <void**><void_ptr>voidStarHelper.cptr
    cdef vector[size_t] cdataSizes = dataSizes
    cdef vector[ccuda.CUmem_range_attribute] cattributes = [pyattributes.value for pyattributes in (attributes)]
    if numAttributes > <size_t>len(dataSizes): raise RuntimeError("List is too small: " + str(len(dataSizes)) + " < " + str(numAttributes))
    if numAttributes > <size_t>len(attributes): raise RuntimeError("List is too small: " + str(len(attributes)) + " < " + str(numAttributes))
    err = ccuda.cuMemRangeGetAttributes(cvoidStarHelper_ptr, cdataSizes.data(), cattributes.data(), numAttributes, cdevPtr, count)
    return (CUresult(err), [obj.pyObj() for obj in pylist])

@cython.embedsignature(True)
def cuPointerSetAttribute(value, attribute not None : CUpointer_attribute, ptr):
    """ Set attributes on a previously allocated memory region.

    The supported attributes are:

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_SYNC_MEMOPS`:

    - A boolean attribute that can either be set (1) or unset (0). When
      set, the region of memory that `ptr` points to is guaranteed to
      always synchronize memory operations that are synchronous. If there
      are some previously initiated synchronous memory operations that are
      pending when this attribute is set, the function does not return
      until those memory operations are complete. See further documentation
      in the section titled "API synchronization behavior" to learn more
      about cases when synchronous memory operations can exhibit
      asynchronous behavior. `value` will be considered as a pointer to an
      unsigned integer to which this attribute is to be set.

    Parameters
    ----------
    value : Any
        Pointer to memory containing the value to be set
    attribute : :py:obj:`~.CUpointer_attribute`
        Pointer attribute to set
    ptr : :py:obj:`~.CUdeviceptr`
        Pointer to a memory region allocated using CUDA memory allocation
        APIs

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`

    See Also
    --------
    :py:obj:`~.cuPointerGetAttribute`, :py:obj:`~.cuPointerGetAttributes`, :py:obj:`~.cuMemAlloc`, :py:obj:`~.cuMemFree`, :py:obj:`~.cuMemAllocHost`, :py:obj:`~.cuMemFreeHost`, :py:obj:`~.cuMemHostAlloc`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuMemHostUnregister`
    """
    cdef ccuda.CUdeviceptr cptr
    if ptr is None:
        cptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(ptr, (CUdeviceptr)):
        pptr = int(ptr)
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr
    else:
        pptr = int(CUdeviceptr(ptr))
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr

    cdef utils.HelperCUpointer_attribute cvalue = utils.HelperCUpointer_attribute(attribute, value, is_getter=False)
    cdef void* cvalue_ptr = <void*><void_ptr>cvalue.cptr
    cdef ccuda.CUpointer_attribute cattribute = attribute.value
    err = ccuda.cuPointerSetAttribute(cvalue_ptr, cattribute, cptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuPointerGetAttributes(unsigned int numAttributes, attributes : List[CUpointer_attribute], ptr):
    """ Returns information about a pointer.

    The supported attributes are (refer to
    :py:obj:`~.cuPointerGetAttribute` for attribute descriptions and
    restrictions):

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_CONTEXT`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_MEMORY_TYPE`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_DEVICE_POINTER`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_HOST_POINTER`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_SYNC_MEMOPS`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_BUFFER_ID`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_MANAGED`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_RANGE_START_ADDR`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_RANGE_SIZE`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_MAPPED`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES`

    - :py:obj:`~.CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE`

    Unlike :py:obj:`~.cuPointerGetAttribute`, this function will not return
    an error when the `ptr` encountered is not a valid CUDA pointer.
    Instead, the attributes are assigned default NULL values and
    CUDA_SUCCESS is returned.

    If `ptr` was not allocated by, mapped by, or registered with a
    :py:obj:`~.CUcontext` which uses UVA (Unified Virtual Addressing),
    :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` is returned.

    Parameters
    ----------
    numAttributes : unsigned int
        Number of attributes to query
    attributes : List[:py:obj:`~.CUpointer_attribute`]
        An array of attributes to query (numAttributes and the number of
        attributes in this array should match)
    ptr : :py:obj:`~.CUdeviceptr`
        Pointer to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    data : List[Any]
        A two-dimensional array containing pointers to memory locations
        where the result of each attribute query will be written to.

    See Also
    --------
    :py:obj:`~.cuPointerGetAttribute`, :py:obj:`~.cuPointerSetAttribute`, :py:obj:`~.cudaPointerGetAttributes`
    """
    cdef ccuda.CUdeviceptr cptr
    if ptr is None:
        cptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(ptr, (CUdeviceptr)):
        pptr = int(ptr)
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr
    else:
        pptr = int(CUdeviceptr(ptr))
        cptr = <ccuda.CUdeviceptr><void_ptr>pptr

    attributes = [] if attributes is None else attributes
    if not all(isinstance(_x, (CUpointer_attribute)) for _x in attributes):
        raise TypeError("Argument 'attributes' is not instance of type (expected List[ccuda.CUpointer_attribute]")

    if numAttributes > len(attributes): raise RuntimeError("List is too small: " + str(len(attributes)) + " < " + str(numAttributes))
    cdef vector[ccuda.CUpointer_attribute] cattributes = [pyattributes.value for pyattributes in (attributes)]
    pylist = [utils.HelperCUpointer_attribute(pyattributes, 0, is_getter=True) for pyattributes in attributes]
    cdef utils.InputVoidPtrPtrHelper voidStarHelper = utils.InputVoidPtrPtrHelper(pylist)
    cdef void** cvoidStarHelper_ptr = <void**><void_ptr>voidStarHelper.cptr
    err = ccuda.cuPointerGetAttributes(numAttributes, cattributes.data(), cvoidStarHelper_ptr, cptr)
    return (CUresult(err), [obj.pyObj() for obj in pylist])

@cython.embedsignature(True)
def cuStreamCreate(unsigned int Flags):
    """ Create a stream.

    Creates a stream and returns a handle in `phStream`. The `Flags`
    argument determines behaviors of the stream.

    Valid values for `Flags` are:

    - :py:obj:`~.CU_STREAM_DEFAULT`: Default stream creation flag.

    - :py:obj:`~.CU_STREAM_NON_BLOCKING`: Specifies that work running in
      the created stream may run concurrently with work in stream 0 (the
      NULL stream), and that the created stream should perform no implicit
      synchronization with stream 0.

    Parameters
    ----------
    Flags : unsigned int
        Parameters for stream creation

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    phStream : :py:obj:`~.CUstream`
        Returned newly created stream

    See Also
    --------
    :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreateWithPriority`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithFlags`
    """
    cdef CUstream phStream = CUstream()
    err = ccuda.cuStreamCreate(phStream._ptr, Flags)
    return (CUresult(err), phStream)

@cython.embedsignature(True)
def cuStreamCreateWithPriority(unsigned int flags, int priority):
    """ Create a stream with the given priority.

    Creates a stream with the specified priority and returns a handle in
    `phStream`. This API alters the scheduler priority of work in the
    stream. Work in a higher priority stream may preempt work already
    executing in a low priority stream.

    `priority` follows a convention where lower numbers represent higher
    priorities. '0' represents default priority. The range of meaningful
    numerical priorities can be queried using
    :py:obj:`~.cuCtxGetStreamPriorityRange`. If the specified priority is
    outside the numerical range returned by
    :py:obj:`~.cuCtxGetStreamPriorityRange`, it will automatically be
    clamped to the lowest or the highest number in the range.

    Parameters
    ----------
    flags : unsigned int
        Flags for stream creation. See :py:obj:`~.cuStreamCreate` for a
        list of valid flags
    priority : int
        Stream priority. Lower numbers represent higher priorities. See
        :py:obj:`~.cuCtxGetStreamPriorityRange` for more information about
        meaningful stream priorities that can be passed.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    phStream : :py:obj:`~.CUstream`
        Returned newly created stream

    See Also
    --------
    :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuCtxGetStreamPriorityRange`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamCreateWithPriority`

    Notes
    -----
    Stream priorities are supported only on GPUs with compute capability 3.5 or higher.

    In the current implementation, only compute kernels launched in priority streams are affected by the stream's priority. Stream priorities have no effect on host-to-device and device-to-host memory operations.
    """
    cdef CUstream phStream = CUstream()
    err = ccuda.cuStreamCreateWithPriority(phStream._ptr, flags, priority)
    return (CUresult(err), phStream)

@cython.embedsignature(True)
def cuStreamGetPriority(hStream):
    """ Query the priority of a given stream.

    Query the priority of a stream created using :py:obj:`~.cuStreamCreate`
    or :py:obj:`~.cuStreamCreateWithPriority` and return the priority in
    `priority`. Note that if the stream was created with a priority outside
    the numerical range returned by
    :py:obj:`~.cuCtxGetStreamPriorityRange`, this function returns the
    clamped priority. See :py:obj:`~.cuStreamCreateWithPriority` for
    details about priority clamping.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Handle to the stream to be queried

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    priority : int
        Pointer to a signed integer in which the stream's priority is
        returned

    See Also
    --------
    :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamCreateWithPriority`, :py:obj:`~.cuCtxGetStreamPriorityRange`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cudaStreamGetPriority`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef int priority = 0
    err = ccuda.cuStreamGetPriority(chStream, &priority)
    return (CUresult(err), priority)

@cython.embedsignature(True)
def cuStreamGetFlags(hStream):
    """ Query the flags of a given stream.

    Query the flags of a stream created using :py:obj:`~.cuStreamCreate` or
    :py:obj:`~.cuStreamCreateWithPriority` and return the flags in `flags`.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Handle to the stream to be queried

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    flags : unsigned int
        Pointer to an unsigned integer in which the stream's flags are
        returned The value returned in `flags` is a logical 'OR' of all
        flags that were used while creating this stream. See
        :py:obj:`~.cuStreamCreate` for the list of valid flags

    See Also
    --------
    :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cudaStreamGetFlags`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef unsigned int flags = 0
    err = ccuda.cuStreamGetFlags(chStream, &flags)
    return (CUresult(err), flags)

@cython.embedsignature(True)
def cuStreamGetCtx(hStream):
    """ Query the context associated with a stream.

    Returns the CUDA context that the stream is associated with.

    The stream handle `hStream` can refer to any of the following:

    - a stream created via any of the CUDA driver APIs such as
      :py:obj:`~.cuStreamCreate` and
      :py:obj:`~.cuStreamCreateWithPriority`, or their runtime API
      equivalents such as :py:obj:`~.cudaStreamCreate`,
      :py:obj:`~.cudaStreamCreateWithFlags` and
      :py:obj:`~.cudaStreamCreateWithPriority`. The returned context is the
      context that was active in the calling thread when the stream was
      created. Passing an invalid handle will result in undefined behavior.

    - any of the special streams such as the NULL stream,
      :py:obj:`~.CU_STREAM_LEGACY` and :py:obj:`~.CU_STREAM_PER_THREAD`.
      The runtime API equivalents of these are also accepted, which are
      NULL, :py:obj:`~.cudaStreamLegacy` and
      :py:obj:`~.cudaStreamPerThread` respectively. Specifying any of the
      special handles will return the context current to the calling
      thread. If no context is current to the calling thread,
      :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` is returned.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Handle to the stream to be queried

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`,
    pctx : :py:obj:`~.CUcontext`
        Returned context associated with the stream

    See Also
    --------
    :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamCreateWithPriority`, :py:obj:`~.cuStreamGetPriority`, :py:obj:`~.cuStreamGetFlags`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamCreate`, :py:obj:`~.cudaStreamCreateWithFlags`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef CUcontext pctx = CUcontext()
    err = ccuda.cuStreamGetCtx(chStream, pctx._ptr)
    return (CUresult(err), pctx)

@cython.embedsignature(True)
def cuStreamWaitEvent(hStream, hEvent, unsigned int Flags):
    """ Make a compute stream wait on an event.

    Makes all future work submitted to `hStream` wait for all work captured
    in `hEvent`. See :py:obj:`~.cuEventRecord()` for details on what is
    captured by an event. The synchronization will be performed efficiently
    on the device when applicable. `hEvent` may be from a different context
    or device than `hStream`.

    flags include:

    - :py:obj:`~.CU_EVENT_WAIT_DEFAULT`: Default event creation flag.

    - :py:obj:`~.CU_EVENT_WAIT_EXTERNAL`: Event is captured in the graph as
      an external event node when performing stream capture. This flag is
      invalid outside of stream capture.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to wait
    hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to wait on (may not be NULL)
    Flags : unsigned int
        See :py:obj:`~.CUevent_capture_flags`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`,

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cudaStreamWaitEvent`
    """
    cdef ccuda.CUevent chEvent
    if hEvent is None:
        chEvent = <ccuda.CUevent><void_ptr>0
    elif isinstance(hEvent, (CUevent)):
        phEvent = int(hEvent)
        chEvent = <ccuda.CUevent><void_ptr>phEvent
    else:
        phEvent = int(CUevent(hEvent))
        chEvent = <ccuda.CUevent><void_ptr>phEvent

    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    err = ccuda.cuStreamWaitEvent(chStream, chEvent, Flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamAddCallback(hStream, callback, userData, unsigned int flags):
    """ Add a callback to a compute stream.

    Adds a callback to be called on the host after all currently enqueued
    items in the stream have completed. For each cuStreamAddCallback call,
    the callback will be executed exactly once. The callback will block
    later work in the stream until it is finished.

    The callback may be passed :py:obj:`~.CUDA_SUCCESS` or an error code.
    In the event of a device error, all subsequently executed callbacks
    will receive an appropriate :py:obj:`~.CUresult`.

    Callbacks must not make any CUDA API calls. Attempting to use a CUDA
    API will result in :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`. Callbacks must
    not perform any synchronization that may depend on outstanding device
    work or other callbacks that are not mandated to run earlier. Callbacks
    without a mandated order (in independent streams) execute in undefined
    order and may be serialized.

    For the purposes of Unified Memory, callback execution makes a number
    of guarantees:

    - The callback stream is considered idle for the duration of the
      callback. Thus, for example, a callback may always use memory
      attached to the callback stream.

    - The start of execution of a callback has the same effect as
      synchronizing an event recorded in the same stream immediately prior
      to the callback. It thus synchronizes streams which have been
      "joined" prior to the callback.

    - Adding device work to any stream does not have the effect of making
      the stream active until all preceding host functions and stream
      callbacks have executed. Thus, for example, a callback might use
      global attached memory even if work has been added to another stream,
      if the work has been ordered behind the callback with an event.

    - Completion of a callback does not cause a stream to become active
      except as described above. The callback stream will remain idle if no
      device work follows the callback, and will remain idle across
      consecutive callbacks without device work in between. Thus, for
      example, stream synchronization can be done by signaling from a
      callback at the end of the stream.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to add callback to
    callback : :py:obj:`~.CUstreamCallback`
        The function to call once preceding stream operations are complete
    userData : Any
        User specified data to be passed to the callback function
    flags : unsigned int
        Reserved for future use, must be 0

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuMemAllocManaged`, :py:obj:`~.cuStreamAttachMemAsync`, :py:obj:`~.cuStreamLaunchHostFunc`, :py:obj:`~.cudaStreamAddCallback`

    Notes
    -----
    This function is slated for eventual deprecation and removal. If you do not require the callback to execute in case of a device error, consider using :py:obj:`~.cuLaunchHostFunc`. Additionally, this function is not supported with :py:obj:`~.cuStreamBeginCapture` and :py:obj:`~.cuStreamEndCapture`, unlike :py:obj:`~.cuLaunchHostFunc`.
    """
    cdef ccuda.CUstreamCallback ccallback
    if callback is None:
        ccallback = <ccuda.CUstreamCallback><void_ptr>0
    elif isinstance(callback, (CUstreamCallback)):
        pcallback = int(callback)
        ccallback = <ccuda.CUstreamCallback><void_ptr>pcallback
    else:
        pcallback = int(CUstreamCallback(callback))
        ccallback = <ccuda.CUstreamCallback><void_ptr>pcallback

    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cuserData = utils.HelperInputVoidPtr(userData)
    cdef void* cuserData_ptr = <void*><void_ptr>cuserData.cptr
    err = ccuda.cuStreamAddCallback(chStream, ccallback, cuserData_ptr, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamBeginCapture(hStream, mode not None : CUstreamCaptureMode):
    """ Begins graph capture on a stream.

    Begin graph capture on `hStream`. When a stream is in capture mode, all
    operations pushed into the stream will not be executed, but will
    instead be captured into a graph, which will be returned via
    :py:obj:`~.cuStreamEndCapture`. Capture may not be initiated if
    `stream` is CU_STREAM_LEGACY. Capture must be ended on the same stream
    in which it was initiated, and it may only be initiated if the stream
    is not already in capture mode. The capture mode may be queried via
    :py:obj:`~.cuStreamIsCapturing`. A unique id representing the capture
    sequence may be queried via :py:obj:`~.cuStreamGetCaptureInfo`.

    If `mode` is not :py:obj:`~.CU_STREAM_CAPTURE_MODE_RELAXED`,
    :py:obj:`~.cuStreamEndCapture` must be called on this stream from the
    same thread.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream in which to initiate capture
    mode : :py:obj:`~.CUstreamCaptureMode`
        Controls the interaction of this capture sequence with other API
        calls that are potentially unsafe. For more details see
        :py:obj:`~.cuThreadExchangeStreamCaptureMode`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamIsCapturing`, :py:obj:`~.cuStreamEndCapture`, :py:obj:`~.cuThreadExchangeStreamCaptureMode`

    Notes
    -----
    Kernels captured using this API must not use texture and surface references. Reading or writing through any texture or surface reference is undefined behavior. This restriction does not apply to texture and surface objects.
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUstreamCaptureMode cmode = mode.value
    err = ccuda.cuStreamBeginCapture(chStream, cmode)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuThreadExchangeStreamCaptureMode(mode not None : CUstreamCaptureMode):
    """ Swaps the stream capture interaction mode for a thread.

    Sets the calling thread's stream capture interaction mode to the value
    contained in `*mode`, and overwrites `*mode` with the previous mode for
    the thread. To facilitate deterministic behavior across function or
    module boundaries, callers are encouraged to use this API in a push-pop
    fashion:

    **View CUDA Toolkit Documentation for a C++ code example**

    During stream capture (see :py:obj:`~.cuStreamBeginCapture`), some
    actions, such as a call to :py:obj:`~.cudaMalloc`, may be unsafe. In
    the case of :py:obj:`~.cudaMalloc`, the operation is not enqueued
    asynchronously to a stream, and is not observed by stream capture.
    Therefore, if the sequence of operations captured via
    :py:obj:`~.cuStreamBeginCapture` depended on the allocation being
    replayed whenever the graph is launched, the captured graph would be
    invalid.

    Therefore, stream capture places restrictions on API calls that can be
    made within or concurrently to a
    :py:obj:`~.cuStreamBeginCapture`-:py:obj:`~.cuStreamEndCapture`
    sequence. This behavior can be controlled via this API and flags to
    :py:obj:`~.cuStreamBeginCapture`.

    A thread's mode is one of the following:

    - `CU_STREAM_CAPTURE_MODE_GLOBAL:` This is the default mode. If the
      local thread has an ongoing capture sequence that was not initiated
      with `CU_STREAM_CAPTURE_MODE_RELAXED` at `cuStreamBeginCapture`, or
      if any other thread has a concurrent capture sequence initiated with
      `CU_STREAM_CAPTURE_MODE_GLOBAL`, this thread is prohibited from
      potentially unsafe API calls.

    - `CU_STREAM_CAPTURE_MODE_THREAD_LOCAL:` If the local thread has an
      ongoing capture sequence not initiated with
      `CU_STREAM_CAPTURE_MODE_RELAXED`, it is prohibited from potentially
      unsafe API calls. Concurrent capture sequences in other threads are
      ignored.

    - `CU_STREAM_CAPTURE_MODE_RELAXED:` The local thread is not prohibited
      from potentially unsafe API calls. Note that the thread is still
      prohibited from API calls which necessarily conflict with stream
      capture, for example, attempting :py:obj:`~.cuEventQuery` on an event
      that was last recorded inside a capture sequence.

    Parameters
    ----------
    mode : :py:obj:`~.CUstreamCaptureMode`
        Pointer to mode value to swap with the current mode

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    mode : :py:obj:`~.CUstreamCaptureMode`
        Pointer to mode value to swap with the current mode

    See Also
    --------
    :py:obj:`~.cuStreamBeginCapture`
    """
    cdef ccuda.CUstreamCaptureMode cmode = mode.value
    err = ccuda.cuThreadExchangeStreamCaptureMode(&cmode)
    return (CUresult(err), CUstreamCaptureMode(cmode))

@cython.embedsignature(True)
def cuStreamEndCapture(hStream):
    """ Ends capture on a stream, returning the captured graph.

    End capture on `hStream`, returning the captured graph via `phGraph`.
    Capture must have been initiated on `hStream` via a call to
    :py:obj:`~.cuStreamBeginCapture`. If capture was invalidated, due to a
    violation of the rules of stream capture, then a NULL graph will be
    returned.

    If the `mode` argument to :py:obj:`~.cuStreamBeginCapture` was not
    :py:obj:`~.CU_STREAM_CAPTURE_MODE_RELAXED`, this call must be from the
    same thread as :py:obj:`~.cuStreamBeginCapture`.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD`
    phGraph : :py:obj:`~.CUgraph`
        The captured graph

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamBeginCapture`, :py:obj:`~.cuStreamIsCapturing`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef CUgraph phGraph = CUgraph()
    err = ccuda.cuStreamEndCapture(chStream, phGraph._ptr)
    return (CUresult(err), phGraph)

@cython.embedsignature(True)
def cuStreamIsCapturing(hStream):
    """ Returns a stream's capture status.

    Return the capture status of `hStream` via `captureStatus`. After a
    successful call, `*captureStatus` will contain one of the following:

    - :py:obj:`~.CU_STREAM_CAPTURE_STATUS_NONE`: The stream is not
      capturing.

    - :py:obj:`~.CU_STREAM_CAPTURE_STATUS_ACTIVE`: The stream is capturing.

    - :py:obj:`~.CU_STREAM_CAPTURE_STATUS_INVALIDATED`: The stream was
      capturing but an error has invalidated the capture sequence. The
      capture sequence must be terminated with
      :py:obj:`~.cuStreamEndCapture` on the stream where it was initiated
      in order to continue using `hStream`.

    Note that, if this is called on :py:obj:`~.CU_STREAM_LEGACY` (the "null
    stream") while a blocking stream in the same context is capturing, it
    will return :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT` and
    `*captureStatus` is unspecified after the call. The blocking stream
    capture is not invalidated.

    When a blocking stream is capturing, the legacy stream is in an
    unusable state until the blocking stream capture is terminated. The
    legacy stream is not supported for stream capture, but attempted use
    would have an implicit dependency on the capturing stream(s).

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT`
    captureStatus : :py:obj:`~.CUstreamCaptureStatus`
        Returns the stream's capture status

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamBeginCapture`, :py:obj:`~.cuStreamEndCapture`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUstreamCaptureStatus captureStatus
    err = ccuda.cuStreamIsCapturing(chStream, &captureStatus)
    return (CUresult(err), CUstreamCaptureStatus(captureStatus))

@cython.embedsignature(True)
def cuStreamGetCaptureInfo(hStream):
    """ Query capture status of a stream.

    Note there is a later version of this API,
    :py:obj:`~.cuStreamGetCaptureInfo_v2`. It will supplant this version in
    12.0, which is retained for minor version compatibility.

    Query the capture status of a stream and and get an id for the capture
    sequence, which is unique over the lifetime of the process.

    If called on :py:obj:`~.CU_STREAM_LEGACY` (the "null stream") while a
    stream not created with :py:obj:`~.CU_STREAM_NON_BLOCKING` is
    capturing, returns :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT`.

    A valid id is returned only if both of the following are true:

    - the call returns CUDA_SUCCESS

    - captureStatus is set to :py:obj:`~.CU_STREAM_CAPTURE_STATUS_ACTIVE`

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        None

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT`
    captureStatus_out : :py:obj:`~.CUstreamCaptureStatus`
        None
    id_out : :py:obj:`~.cuuint64_t`
        None

    See Also
    --------
    :py:obj:`~.cuStreamGetCaptureInfo_v2`, :py:obj:`~.cuStreamBeginCapture`, :py:obj:`~.cuStreamIsCapturing`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUstreamCaptureStatus captureStatus_out
    cdef cuuint64_t id_out = cuuint64_t()
    err = ccuda.cuStreamGetCaptureInfo(chStream, &captureStatus_out, id_out._ptr)
    return (CUresult(err), CUstreamCaptureStatus(captureStatus_out), id_out)

@cython.embedsignature(True)
def cuStreamGetCaptureInfo_v2(hStream):
    """ Query a stream's capture state (11.3+)

    Query stream state related to stream capture.

    If called on :py:obj:`~.CU_STREAM_LEGACY` (the "null stream") while a
    stream not created with :py:obj:`~.CU_STREAM_NON_BLOCKING` is
    capturing, returns :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT`.

    Valid data (other than capture status) is returned only if both of the
    following are true:

    - the call returns CUDA_SUCCESS

    - the returned capture status is
      :py:obj:`~.CU_STREAM_CAPTURE_STATUS_ACTIVE`

    This version of cuStreamGetCaptureInfo is introduced in CUDA 11.3 and
    will supplant the previous version in 12.0. Developers requiring
    compatibility across minor versions to CUDA 11.0 (driver version 445)
    should use :py:obj:`~.cuStreamGetCaptureInfo` or include a fallback
    path.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_IMPLICIT`
    captureStatus_out : :py:obj:`~.CUstreamCaptureStatus`
        Location to return the capture status of the stream; required
    id_out : :py:obj:`~.cuuint64_t`
        Optional location to return an id for the capture sequence, which
        is unique over the lifetime of the process
    graph_out : :py:obj:`~.CUgraph`
        Optional location to return the graph being captured into. All
        operations other than destroy and node removal are permitted on the
        graph while the capture sequence is in progress. This API does not
        transfer ownership of the graph, which is transferred or destroyed
        at :py:obj:`~.cuStreamEndCapture`. Note that the graph handle may
        be invalidated before end of capture for certain errors. Nodes that
        are or become unreachable from the original stream at
        :py:obj:`~.cuStreamEndCapture` due to direct actions on the graph
        do not trigger :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNJOINED`.
    dependencies_out : List[:py:obj:`~.CUgraphNode`]
        Optional location to store a pointer to an array of nodes. The next
        node to be captured in the stream will depend on this set of nodes,
        absent operations such as event wait which modify this set. The
        array pointer is valid until the next API call which operates on
        the stream or until end of capture. The node handles may be copied
        out and are valid until they or the graph is destroyed. The driver-
        owned array may also be passed directly to APIs that operate on the
        graph (not the stream) without copying.
    numDependencies_out : int
        Optional location to store the size of the array returned in
        dependencies_out.

    See Also
    --------
    :py:obj:`~.cuStreamGetCaptureInfo`, :py:obj:`~.cuStreamBeginCapture`, :py:obj:`~.cuStreamIsCapturing`, :py:obj:`~.cuStreamUpdateCaptureDependencies`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUstreamCaptureStatus captureStatus_out
    cdef cuuint64_t id_out = cuuint64_t()
    cdef CUgraph graph_out = CUgraph()
    cdef const ccuda.CUgraphNode* cdependencies_out = NULL
    pydependencies_out = []
    cdef size_t numDependencies_out = 0
    err = ccuda.cuStreamGetCaptureInfo_v2(chStream, &captureStatus_out, id_out._ptr, graph_out._ptr, &cdependencies_out, &numDependencies_out)
    if CUresult(err) == CUresult(0):
        pydependencies_out = [CUgraphNode(init_value=<void_ptr>cdependencies_out[idx]) for idx in range(numDependencies_out)]
    return (CUresult(err), CUstreamCaptureStatus(captureStatus_out), id_out, graph_out, pydependencies_out, numDependencies_out)

@cython.embedsignature(True)
def cuStreamUpdateCaptureDependencies(hStream, dependencies : List[CUgraphNode], size_t numDependencies, unsigned int flags):
    """ Update the set of dependencies in a capturing stream (11.3+)

    Modifies the dependency set of a capturing stream. The dependency set
    is the set of nodes that the next captured node in the stream will
    depend on.

    Valid flags are :py:obj:`~.CU_STREAM_ADD_CAPTURE_DEPENDENCIES` and
    :py:obj:`~.CU_STREAM_SET_CAPTURE_DEPENDENCIES`. These control whether
    the set passed to the API is added to the existing set or replaces it.
    A flags value of 0 defaults to
    :py:obj:`~.CU_STREAM_ADD_CAPTURE_DEPENDENCIES`.

    Nodes that are removed from the dependency set via this API do not
    result in :py:obj:`~.CUDA_ERROR_STREAM_CAPTURE_UNJOINED` if they are
    unreachable from the stream at :py:obj:`~.cuStreamEndCapture`.

    Returns :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE` if the stream is not
    capturing.

    This API is new in CUDA 11.3. Developers requiring compatibility across
    minor versions to CUDA 11.0 should not use this API or provide a
    fallback.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        None
    dependencies : List[:py:obj:`~.CUgraphNode`]
        None
    numDependencies : size_t
        None
    flags : unsigned int
        None

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_ILLEGAL_STATE`

    See Also
    --------
    :py:obj:`~.cuStreamBeginCapture`, :py:obj:`~.cuStreamGetCaptureInfo`, :py:obj:`~.cuStreamGetCaptureInfo_v2`
    """
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[ccuda.CUgraphNode]")

    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    err = ccuda.cuStreamUpdateCaptureDependencies(chStream, (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, flags)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamAttachMemAsync(hStream, dptr, size_t length, unsigned int flags):
    """ Attach memory to a stream asynchronously.

    Enqueues an operation in `hStream` to specify stream association of
    `length` bytes of memory starting from `dptr`. This function is a
    stream-ordered operation, meaning that it is dependent on, and will
    only take effect when, previous work in stream has completed. Any
    previous association is automatically replaced.

    `dptr` must point to one of the following types of memories:

    - managed memory declared using the managed keyword or allocated with
      :py:obj:`~.cuMemAllocManaged`.

    - a valid host-accessible region of system-allocated pageable memory.
      This type of memory may only be specified if the device associated
      with the stream reports a non-zero value for the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS`.

    For managed allocations, `length` must be either zero or the entire
    allocation's size. Both indicate that the entire allocation's stream
    association is being changed. Currently, it is not possible to change
    stream association for a portion of a managed allocation.

    For pageable host allocations, `length` must be non-zero.

    The stream association is specified using `flags` which must be one of
    :py:obj:`~.CUmemAttach_flags`. If the :py:obj:`~.CU_MEM_ATTACH_GLOBAL`
    flag is specified, the memory can be accessed by any stream on any
    device. If the :py:obj:`~.CU_MEM_ATTACH_HOST` flag is specified, the
    program makes a guarantee that it won't access the memory on the device
    from any stream on a device that has a zero value for the device
    attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. If
    the :py:obj:`~.CU_MEM_ATTACH_SINGLE` flag is specified and `hStream` is
    associated with a device that has a zero value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`, the program
    makes a guarantee that it will only access the memory on the device
    from `hStream`. It is illegal to attach singly to the NULL stream,
    because the NULL stream is a virtual global stream and not a specific
    stream. An error will be returned in this case.

    When memory is associated with a single stream, the Unified Memory
    system will allow CPU access to this memory region so long as all
    operations in `hStream` have completed, regardless of whether other
    streams are active. In effect, this constrains exclusive ownership of
    the managed memory region by an active GPU to per-stream activity
    instead of whole-GPU activity.

    Accessing memory on the device from streams that are not associated
    with it will produce undefined results. No error checking is performed
    by the Unified Memory system to ensure that kernels launched into other
    streams do not access this region.

    It is a program's responsibility to order calls to
    :py:obj:`~.cuStreamAttachMemAsync` via events, synchronization or other
    means to ensure legal access to memory at all times. Data visibility
    and coherency will be changed appropriately for all kernels which
    follow a stream-association change.

    If `hStream` is destroyed while data is associated with it, the
    association is removed and the association reverts to the default
    visibility of the allocation as specified at
    :py:obj:`~.cuMemAllocManaged`. For managed variables, the default
    association is always :py:obj:`~.CU_MEM_ATTACH_GLOBAL`. Note that
    destroying a stream is an asynchronous operation, and as a result, the
    change to default association won't happen until all work in the stream
    has completed.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream in which to enqueue the attach operation
    dptr : :py:obj:`~.CUdeviceptr`
        Pointer to memory (must be a pointer to managed memory or to a
        valid host-accessible region of system-allocated pageable memory)
    length : size_t
        Length of memory
    flags : unsigned int
        Must be one of :py:obj:`~.CUmemAttach_flags`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuMemAllocManaged`, :py:obj:`~.cudaStreamAttachMemAsync`
    """
    cdef ccuda.CUdeviceptr cdptr
    if dptr is None:
        cdptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dptr, (CUdeviceptr)):
        pdptr = int(dptr)
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr
    else:
        pdptr = int(CUdeviceptr(dptr))
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr

    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    err = ccuda.cuStreamAttachMemAsync(chStream, cdptr, length, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamQuery(hStream):
    """ Determine status of a compute stream.

    Returns :py:obj:`~.CUDA_SUCCESS` if all operations in the stream
    specified by `hStream` have completed, or
    :py:obj:`~.CUDA_ERROR_NOT_READY` if not.

    For the purposes of Unified Memory, a return value of
    :py:obj:`~.CUDA_SUCCESS` is equivalent to having called
    :py:obj:`~.cuStreamSynchronize()`.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to query status of

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_READY`

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamQuery`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    err = ccuda.cuStreamQuery(chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamSynchronize(hStream):
    """ Wait until a stream's tasks are completed.

    Waits until the device has completed all operations in the stream
    specified by `hStream`. If the context was created with the
    :py:obj:`~.CU_CTX_SCHED_BLOCKING_SYNC` flag, the CPU thread will block
    until the stream is finished with all of its tasks.

    \note_null_stream

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to wait for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamSynchronize`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    err = ccuda.cuStreamSynchronize(chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamDestroy(hStream):
    """ Destroys a stream.

    Destroys the stream specified by `hStream`.

    In case the device is still doing work in the stream `hStream` when
    :py:obj:`~.cuStreamDestroy()` is called, the function will return
    immediately and the resources associated with `hStream` will be
    released automatically once the device has completed all work in
    `hStream`.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamAddCallback`, :py:obj:`~.cudaStreamDestroy`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    err = ccuda.cuStreamDestroy(chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamCopyAttributes(dst, src):
    """ Copies attributes from source stream to destination stream.

    Copies attributes from source stream `src` to destination stream `dst`.
    Both streams must have the same context.

    Parameters
    ----------
    dst : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Destination stream
    src : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Source stream For list of attributes see :py:obj:`~.CUstreamAttrID`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.CUaccessPolicyWindow`
    """
    cdef ccuda.CUstream csrc
    if src is None:
        csrc = <ccuda.CUstream><void_ptr>0
    elif isinstance(src, (CUstream)):
        psrc = int(src)
        csrc = <ccuda.CUstream><void_ptr>psrc
    else:
        psrc = int(CUstream(src))
        csrc = <ccuda.CUstream><void_ptr>psrc

    cdef ccuda.CUstream cdst
    if dst is None:
        cdst = <ccuda.CUstream><void_ptr>0
    elif isinstance(dst, (CUstream)):
        pdst = int(dst)
        cdst = <ccuda.CUstream><void_ptr>pdst
    else:
        pdst = int(CUstream(dst))
        cdst = <ccuda.CUstream><void_ptr>pdst

    err = ccuda.cuStreamCopyAttributes(cdst, csrc)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamGetAttribute(hStream, attr not None : CUstreamAttrID):
    """ Queries stream attribute.

    Queries attribute `attr` from `hStream` and stores it in corresponding
    member of `value_out`.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`

    attr : :py:obj:`~.CUstreamAttrID`


    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    value_out : :py:obj:`~.CUstreamAttrValue`


    See Also
    --------
    :py:obj:`~.CUaccessPolicyWindow`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUstreamAttrID cattr = attr.value
    cdef CUstreamAttrValue value_out = CUstreamAttrValue()
    err = ccuda.cuStreamGetAttribute(chStream, cattr, value_out._ptr)
    return (CUresult(err), value_out)

@cython.embedsignature(True)
def cuStreamSetAttribute(hStream, attr not None : CUstreamAttrID, value : CUstreamAttrValue):
    """ Sets stream attribute.

    Sets attribute `attr` on `hStream` from corresponding attribute of
    `value`. The updated attribute will be applied to subsequent work
    submitted to the stream. It will not affect previously submitted work.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`

    attr : :py:obj:`~.CUstreamAttrID`

    value : :py:obj:`~.CUstreamAttrValue`


    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.CUaccessPolicyWindow`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUstreamAttrID cattr = attr.value
    cdef ccuda.CUstreamAttrValue* cvalue_ptr = value._ptr if value != None else NULL
    err = ccuda.cuStreamSetAttribute(chStream, cattr, cvalue_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuEventCreate(unsigned int Flags):
    """ Creates an event.

    Creates an event *phEvent for the current context with the flags
    specified via `Flags`. Valid flags include:

    - :py:obj:`~.CU_EVENT_DEFAULT`: Default event creation flag.

    - :py:obj:`~.CU_EVENT_BLOCKING_SYNC`: Specifies that the created event
      should use blocking synchronization. A CPU thread that uses
      :py:obj:`~.cuEventSynchronize()` to wait on an event created with
      this flag will block until the event has actually been recorded.

    - :py:obj:`~.CU_EVENT_DISABLE_TIMING`: Specifies that the created event
      does not need to record timing data. Events created with this flag
      specified and the :py:obj:`~.CU_EVENT_BLOCKING_SYNC` flag not
      specified will provide the best performance when used with
      :py:obj:`~.cuStreamWaitEvent()` and :py:obj:`~.cuEventQuery()`.

    - :py:obj:`~.CU_EVENT_INTERPROCESS`: Specifies that the created event
      may be used as an interprocess event by
      :py:obj:`~.cuIpcGetEventHandle()`. :py:obj:`~.CU_EVENT_INTERPROCESS`
      must be specified along with :py:obj:`~.CU_EVENT_DISABLE_TIMING`.

    Parameters
    ----------
    Flags : unsigned int
        Event creation flags

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    phEvent : :py:obj:`~.CUevent`
        Returns newly created event

    See Also
    --------
    :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cudaEventCreate`, :py:obj:`~.cudaEventCreateWithFlags`
    """
    cdef CUevent phEvent = CUevent()
    err = ccuda.cuEventCreate(phEvent._ptr, Flags)
    return (CUresult(err), phEvent)

@cython.embedsignature(True)
def cuEventRecord(hEvent, hStream):
    """ Records an event.

    Captures in `hEvent` the contents of `hStream` at the time of this
    call. `hEvent` and `hStream` must be from the same context. Calls such
    as :py:obj:`~.cuEventQuery()` or :py:obj:`~.cuStreamWaitEvent()` will
    then examine or wait for completion of the work that was captured. Uses
    of `hStream` after this call do not modify `hEvent`. See note on
    default stream behavior for what is captured in the default case.

    :py:obj:`~.cuEventRecord()` can be called multiple times on the same
    event and will overwrite the previously captured state. Other APIs such
    as :py:obj:`~.cuStreamWaitEvent()` use the most recently captured state
    at the time of the API call, and are not affected by later calls to
    :py:obj:`~.cuEventRecord()`. Before the first call to
    :py:obj:`~.cuEventRecord()`, an event represents an empty set of work,
    so for example :py:obj:`~.cuEventQuery()` would return
    :py:obj:`~.CUDA_SUCCESS`.

    Parameters
    ----------
    hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to record
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to record event for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cudaEventRecord`, :py:obj:`~.cuEventRecordWithFlags`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUevent chEvent
    if hEvent is None:
        chEvent = <ccuda.CUevent><void_ptr>0
    elif isinstance(hEvent, (CUevent)):
        phEvent = int(hEvent)
        chEvent = <ccuda.CUevent><void_ptr>phEvent
    else:
        phEvent = int(CUevent(hEvent))
        chEvent = <ccuda.CUevent><void_ptr>phEvent

    err = ccuda.cuEventRecord(chEvent, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuEventRecordWithFlags(hEvent, hStream, unsigned int flags):
    """ Records an event.

    Captures in `hEvent` the contents of `hStream` at the time of this
    call. `hEvent` and `hStream` must be from the same context. Calls such
    as :py:obj:`~.cuEventQuery()` or :py:obj:`~.cuStreamWaitEvent()` will
    then examine or wait for completion of the work that was captured. Uses
    of `hStream` after this call do not modify `hEvent`. See note on
    default stream behavior for what is captured in the default case.

    :py:obj:`~.cuEventRecordWithFlags()` can be called multiple times on
    the same event and will overwrite the previously captured state. Other
    APIs such as :py:obj:`~.cuStreamWaitEvent()` use the most recently
    captured state at the time of the API call, and are not affected by
    later calls to :py:obj:`~.cuEventRecordWithFlags()`. Before the first
    call to :py:obj:`~.cuEventRecordWithFlags()`, an event represents an
    empty set of work, so for example :py:obj:`~.cuEventQuery()` would
    return :py:obj:`~.CUDA_SUCCESS`.

    flags include:

    - :py:obj:`~.CU_EVENT_RECORD_DEFAULT`: Default event creation flag.

    - :py:obj:`~.CU_EVENT_RECORD_EXTERNAL`: Event is captured in the graph
      as an external event node when performing stream capture. This flag
      is invalid outside of stream capture.

    Parameters
    ----------
    hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to record
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to record event for
    flags : unsigned int
        See :py:obj:`~.CUevent_capture_flags`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cudaEventRecord`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUevent chEvent
    if hEvent is None:
        chEvent = <ccuda.CUevent><void_ptr>0
    elif isinstance(hEvent, (CUevent)):
        phEvent = int(hEvent)
        chEvent = <ccuda.CUevent><void_ptr>phEvent
    else:
        phEvent = int(CUevent(hEvent))
        chEvent = <ccuda.CUevent><void_ptr>phEvent

    err = ccuda.cuEventRecordWithFlags(chEvent, chStream, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuEventQuery(hEvent):
    """ Queries an event's status.

    Queries the status of all work currently captured by `hEvent`. See
    :py:obj:`~.cuEventRecord()` for details on what is captured by an
    event.

    Returns :py:obj:`~.CUDA_SUCCESS` if all captured work has been
    completed, or :py:obj:`~.CUDA_ERROR_NOT_READY` if any captured work is
    incomplete.

    For the purposes of Unified Memory, a return value of
    :py:obj:`~.CUDA_SUCCESS` is equivalent to having called
    :py:obj:`~.cuEventSynchronize()`.

    Parameters
    ----------
    hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_READY`

    See Also
    --------
    :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cudaEventQuery`
    """
    cdef ccuda.CUevent chEvent
    if hEvent is None:
        chEvent = <ccuda.CUevent><void_ptr>0
    elif isinstance(hEvent, (CUevent)):
        phEvent = int(hEvent)
        chEvent = <ccuda.CUevent><void_ptr>phEvent
    else:
        phEvent = int(CUevent(hEvent))
        chEvent = <ccuda.CUevent><void_ptr>phEvent

    err = ccuda.cuEventQuery(chEvent)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuEventSynchronize(hEvent):
    """ Waits for an event to complete.

    Waits until the completion of all work currently captured in `hEvent`.
    See :py:obj:`~.cuEventRecord()` for details on what is captured by an
    event.

    Waiting for an event that was created with the
    :py:obj:`~.CU_EVENT_BLOCKING_SYNC` flag will cause the calling CPU
    thread to block until the event has been completed by the device. If
    the :py:obj:`~.CU_EVENT_BLOCKING_SYNC` flag has not been set, then the
    CPU thread will busy-wait until the event has been completed by the
    device.

    Parameters
    ----------
    hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to wait for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cudaEventSynchronize`
    """
    cdef ccuda.CUevent chEvent
    if hEvent is None:
        chEvent = <ccuda.CUevent><void_ptr>0
    elif isinstance(hEvent, (CUevent)):
        phEvent = int(hEvent)
        chEvent = <ccuda.CUevent><void_ptr>phEvent
    else:
        phEvent = int(CUevent(hEvent))
        chEvent = <ccuda.CUevent><void_ptr>phEvent

    err = ccuda.cuEventSynchronize(chEvent)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuEventDestroy(hEvent):
    """ Destroys an event.

    Destroys the event specified by `hEvent`.

    An event may be destroyed before it is complete (i.e., while
    :py:obj:`~.cuEventQuery()` would return
    :py:obj:`~.CUDA_ERROR_NOT_READY`). In this case, the call does not
    block on completion of the event, and any associated resources will
    automatically be released asynchronously at completion.

    Parameters
    ----------
    hEvent : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventElapsedTime`, :py:obj:`~.cudaEventDestroy`
    """
    cdef ccuda.CUevent chEvent
    if hEvent is None:
        chEvent = <ccuda.CUevent><void_ptr>0
    elif isinstance(hEvent, (CUevent)):
        phEvent = int(hEvent)
        chEvent = <ccuda.CUevent><void_ptr>phEvent
    else:
        phEvent = int(CUevent(hEvent))
        chEvent = <ccuda.CUevent><void_ptr>phEvent

    err = ccuda.cuEventDestroy(chEvent)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuEventElapsedTime(hStart, hEnd):
    """ Computes the elapsed time between two events.

    Computes the elapsed time between two events (in milliseconds with a
    resolution of around 0.5 microseconds).

    If either event was last recorded in a non-NULL stream, the resulting
    time may be greater than expected (even if both used the same stream
    handle). This happens because the :py:obj:`~.cuEventRecord()` operation
    takes place asynchronously and there is no guarantee that the measured
    latency is actually just between the two events. Any number of other
    different stream operations could execute in between the two measured
    events, thus altering the timing in a significant way.

    If :py:obj:`~.cuEventRecord()` has not been called on either event then
    :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is returned. If
    :py:obj:`~.cuEventRecord()` has been called on both events but one or
    both of them has not yet been completed (that is,
    :py:obj:`~.cuEventQuery()` would return
    :py:obj:`~.CUDA_ERROR_NOT_READY` on at least one of the events),
    :py:obj:`~.CUDA_ERROR_NOT_READY` is returned. If either event was
    created with the :py:obj:`~.CU_EVENT_DISABLE_TIMING` flag, then this
    function will return :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`.

    Parameters
    ----------
    hStart : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Starting event
    hEnd : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Ending event

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_READY`
    pMilliseconds : float
        Time between `hStart` and `hEnd` in ms

    See Also
    --------
    :py:obj:`~.cuEventCreate`, :py:obj:`~.cuEventRecord`, :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventDestroy`, :py:obj:`~.cudaEventElapsedTime`
    """
    cdef ccuda.CUevent chEnd
    if hEnd is None:
        chEnd = <ccuda.CUevent><void_ptr>0
    elif isinstance(hEnd, (CUevent)):
        phEnd = int(hEnd)
        chEnd = <ccuda.CUevent><void_ptr>phEnd
    else:
        phEnd = int(CUevent(hEnd))
        chEnd = <ccuda.CUevent><void_ptr>phEnd

    cdef ccuda.CUevent chStart
    if hStart is None:
        chStart = <ccuda.CUevent><void_ptr>0
    elif isinstance(hStart, (CUevent)):
        phStart = int(hStart)
        chStart = <ccuda.CUevent><void_ptr>phStart
    else:
        phStart = int(CUevent(hStart))
        chStart = <ccuda.CUevent><void_ptr>phStart

    cdef float pMilliseconds = 0
    err = ccuda.cuEventElapsedTime(&pMilliseconds, chStart, chEnd)
    return (CUresult(err), pMilliseconds)

@cython.embedsignature(True)
def cuImportExternalMemory(memHandleDesc : CUDA_EXTERNAL_MEMORY_HANDLE_DESC):
    """ Imports an external memory object.

    Imports an externally allocated memory object and returns a handle to
    that in `extMem_out`.

    The properties of the handle being imported must be described in
    `memHandleDesc`. The :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`
    structure is defined as follows:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` specifies the
    type of handle being imported. :py:obj:`~.CUexternalMemoryHandleType`
    is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD`, then
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::fd must be a
    valid file descriptor referencing a memory object. Ownership of the
    file descriptor is transferred to the CUDA driver when the handle is
    imported successfully. Performing any operations on the file descriptor
    after it is imported results in undefined behavior.

    If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32`, then exactly
    one of
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle and
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name must
    not be NULL. If
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle is
    not NULL, then it must represent a valid shared NT handle that
    references a memory object. Ownership of this handle is not transferred
    to CUDA after the import operation, so the application must release the
    handle using the appropriate system call. If
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must point to a NULL-terminated array of UTF-16
    characters that refers to a memory object.

    If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT`, then
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle
    must be non-NULL and
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name must
    be NULL. The handle specified must be a globally shared KMT handle.
    This handle does not hold a reference to the underlying object, and
    thus will be invalid when all references to the memory object are
    destroyed.

    If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP`, then exactly one
    of :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle
    and :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name
    must not be NULL. If
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle is
    not NULL, then it must represent a valid shared NT handle that is
    returned by ID3D12Device::CreateSharedHandle when referring to a
    ID3D12Heap object. This handle holds a reference to the underlying
    object. If
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must point to a NULL-terminated array of UTF-16
    characters that refers to a ID3D12Heap object.

    If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE`, then exactly
    one of
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle and
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name must
    not be NULL. If
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle is
    not NULL, then it must represent a valid shared NT handle that is
    returned by ID3D12Device::CreateSharedHandle when referring to a
    ID3D12Resource object. This handle holds a reference to the underlying
    object. If
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must point to a NULL-terminated array of UTF-16
    characters that refers to a ID3D12Resource object.

    If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE`, then
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle
    must represent a valid shared NT handle that is returned by
    IDXGIResource1::CreateSharedHandle when referring to a ID3D11Resource
    object. If
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must point to a NULL-terminated array of UTF-16
    characters that refers to a ID3D11Resource object.

    If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT`, then
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::handle
    must represent a valid shared KMT handle that is returned by
    IDXGIResource::GetSharedHandle when referring to a ID3D11Resource
    object and
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::win32::name must
    be NULL.

    If :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF`, then
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`::handle::nvSciBufObject
    must be non-NULL and reference a valid NvSciBuf object. If the NvSciBuf
    object imported into CUDA is also mapped by other drivers, then the
    application must use :py:obj:`~.cuWaitExternalSemaphoresAsync` or
    :py:obj:`~.cuSignalExternalSemaphoresAsync` as appropriate barriers to
    maintain coherence between CUDA and the other drivers. See
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC` and
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC` for
    memory synchronization.

    The size of the memory object must be specified in
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.size`.

    Specifying the flag :py:obj:`~.CUDA_EXTERNAL_MEMORY_DEDICATED` in
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.flags` indicates that the
    resource is a dedicated resource. The definition of what a dedicated
    resource is outside the scope of this extension. This flag must be set
    if :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC.type` is one of the
    following: :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE`
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE`
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT`

    Parameters
    ----------
    memHandleDesc : :py:obj:`~.CUDA_EXTERNAL_MEMORY_HANDLE_DESC`
        Memory import handle descriptor

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    extMem_out : :py:obj:`~.CUexternalMemory`
        Returned handle to an external memory object

    See Also
    --------
    :py:obj:`~.cuDestroyExternalMemory`, :py:obj:`~.cuExternalMemoryGetMappedBuffer`, :py:obj:`~.cuExternalMemoryGetMappedMipmappedArray`

    Notes
    -----
    If the Vulkan memory imported into CUDA is mapped on the CPU then the application must use vkInvalidateMappedMemoryRanges/vkFlushMappedMemoryRanges as well as appropriate Vulkan pipeline barriers to maintain coherence between CPU and GPU. For more information on these APIs, please refer to "Synchronization
    and Cache Control" chapter from Vulkan specification.
    """
    cdef CUexternalMemory extMem_out = CUexternalMemory()
    cdef ccuda.CUDA_EXTERNAL_MEMORY_HANDLE_DESC* cmemHandleDesc_ptr = memHandleDesc._ptr if memHandleDesc != None else NULL
    err = ccuda.cuImportExternalMemory(extMem_out._ptr, cmemHandleDesc_ptr)
    return (CUresult(err), extMem_out)

@cython.embedsignature(True)
def cuExternalMemoryGetMappedBuffer(extMem, bufferDesc : CUDA_EXTERNAL_MEMORY_BUFFER_DESC):
    """ Maps a buffer onto an imported memory object.

    Maps a buffer onto an imported memory object and returns a device
    pointer in `devPtr`.

    The properties of the buffer being mapped must be described in
    `bufferDesc`. The :py:obj:`~.CUDA_EXTERNAL_MEMORY_BUFFER_DESC`
    structure is defined as follows:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.CUDA_EXTERNAL_MEMORY_BUFFER_DESC.offset` is the offset
    in the memory object where the buffer's base address is.
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_BUFFER_DESC.size` is the size of the
    buffer. :py:obj:`~.CUDA_EXTERNAL_MEMORY_BUFFER_DESC.flags` must be
    zero.

    The offset and size have to be suitably aligned to match the
    requirements of the external API. Mapping two buffers whose ranges
    overlap may or may not result in the same virtual address being
    returned for the overlapped portion. In such cases, the application
    must ensure that all accesses to that region from the GPU are volatile.
    Otherwise writes made via one address are not guaranteed to be visible
    via the other address, even if they're issued by the same thread. It is
    recommended that applications map the combined range instead of mapping
    separate buffers and then apply the appropriate offsets to the returned
    pointer to derive the individual buffers.

    The returned pointer `devPtr` must be freed using
    :py:obj:`~.cuMemFree`.

    Parameters
    ----------
    extMem : :py:obj:`~.CUexternalMemory`
        Handle to external memory object
    bufferDesc : :py:obj:`~.CUDA_EXTERNAL_MEMORY_BUFFER_DESC`
        Buffer descriptor

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    devPtr : :py:obj:`~.CUdeviceptr`
        Returned device pointer to buffer

    See Also
    --------
    :py:obj:`~.cuImportExternalMemory`, :py:obj:`~.cuDestroyExternalMemory`, :py:obj:`~.cuExternalMemoryGetMappedMipmappedArray`
    """
    cdef ccuda.CUexternalMemory cextMem
    if extMem is None:
        cextMem = <ccuda.CUexternalMemory><void_ptr>0
    elif isinstance(extMem, (CUexternalMemory)):
        pextMem = int(extMem)
        cextMem = <ccuda.CUexternalMemory><void_ptr>pextMem
    else:
        pextMem = int(CUexternalMemory(extMem))
        cextMem = <ccuda.CUexternalMemory><void_ptr>pextMem

    cdef CUdeviceptr devPtr = CUdeviceptr()
    cdef ccuda.CUDA_EXTERNAL_MEMORY_BUFFER_DESC* cbufferDesc_ptr = bufferDesc._ptr if bufferDesc != None else NULL
    err = ccuda.cuExternalMemoryGetMappedBuffer(devPtr._ptr, cextMem, cbufferDesc_ptr)
    return (CUresult(err), devPtr)

@cython.embedsignature(True)
def cuExternalMemoryGetMappedMipmappedArray(extMem, mipmapDesc : CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC):
    """ Maps a CUDA mipmapped array onto an external memory object.

    Maps a CUDA mipmapped array onto an external object and returns a
    handle to it in `mipmap`.

    The properties of the CUDA mipmapped array being mapped must be
    described in `mipmapDesc`. The structure
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC` is defined as
    follows:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC.offset` is
    the offset in the memory object where the base level of the mipmap
    chain is.
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC.arrayDesc`
    describes the format, dimensions and type of the base level of the
    mipmap chain. For further details on these parameters, please refer to
    the documentation for :py:obj:`~.cuMipmappedArrayCreate`. Note that if
    the mipmapped array is bound as a color target in the graphics API,
    then the flag :py:obj:`~.CUDA_ARRAY3D_COLOR_ATTACHMENT` must be
    specified in
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC`::arrayDesc::Flags.
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC.numLevels`
    specifies the total number of levels in the mipmap chain.

    If `extMem` was imported from a handle of type
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF`, then
    :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC.numLevels` must be
    equal to 1.

    The returned CUDA mipmapped array must be freed using
    :py:obj:`~.cuMipmappedArrayDestroy`.

    Parameters
    ----------
    extMem : :py:obj:`~.CUexternalMemory`
        Handle to external memory object
    mipmapDesc : :py:obj:`~.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC`
        CUDA array descriptor

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    mipmap : :py:obj:`~.CUmipmappedArray`
        Returned CUDA mipmapped array

    See Also
    --------
    :py:obj:`~.cuImportExternalMemory`, :py:obj:`~.cuDestroyExternalMemory`, :py:obj:`~.cuExternalMemoryGetMappedBuffer`

    Notes
    -----
    On Tegra devices, this API will always attempt to do a compressed mapping when the `extMem` is imported from a handle of type :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD`
    """
    cdef ccuda.CUexternalMemory cextMem
    if extMem is None:
        cextMem = <ccuda.CUexternalMemory><void_ptr>0
    elif isinstance(extMem, (CUexternalMemory)):
        pextMem = int(extMem)
        cextMem = <ccuda.CUexternalMemory><void_ptr>pextMem
    else:
        pextMem = int(CUexternalMemory(extMem))
        cextMem = <ccuda.CUexternalMemory><void_ptr>pextMem

    cdef CUmipmappedArray mipmap = CUmipmappedArray()
    cdef ccuda.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC* cmipmapDesc_ptr = mipmapDesc._ptr if mipmapDesc != None else NULL
    err = ccuda.cuExternalMemoryGetMappedMipmappedArray(mipmap._ptr, cextMem, cmipmapDesc_ptr)
    return (CUresult(err), mipmap)

@cython.embedsignature(True)
def cuDestroyExternalMemory(extMem):
    """ Destroys an external memory object.

    Destroys the specified external memory object. Any existing buffers and
    CUDA mipmapped arrays mapped onto this object must no longer be used
    and must be explicitly freed using :py:obj:`~.cuMemFree` and
    :py:obj:`~.cuMipmappedArrayDestroy` respectively.

    Parameters
    ----------
    extMem : :py:obj:`~.CUexternalMemory`
        External memory object to be destroyed

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuImportExternalMemory`, :py:obj:`~.cuExternalMemoryGetMappedBuffer`, :py:obj:`~.cuExternalMemoryGetMappedMipmappedArray`
    """
    cdef ccuda.CUexternalMemory cextMem
    if extMem is None:
        cextMem = <ccuda.CUexternalMemory><void_ptr>0
    elif isinstance(extMem, (CUexternalMemory)):
        pextMem = int(extMem)
        cextMem = <ccuda.CUexternalMemory><void_ptr>pextMem
    else:
        pextMem = int(CUexternalMemory(extMem))
        cextMem = <ccuda.CUexternalMemory><void_ptr>pextMem

    err = ccuda.cuDestroyExternalMemory(cextMem)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuImportExternalSemaphore(semHandleDesc : CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC):
    """ Imports an external semaphore.

    Imports an externally allocated synchronization object and returns a
    handle to that in `extSem_out`.

    The properties of the handle being imported must be described in
    `semHandleDesc`. The :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC` is
    defined as follows:

    **View CUDA Toolkit Documentation for a C++ code example**

    where :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` specifies
    the type of handle being imported.
    :py:obj:`~.CUexternalSemaphoreHandleType` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD`, then
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::fd must be a
    valid file descriptor referencing a synchronization object. Ownership
    of the file descriptor is transferred to the CUDA driver when the
    handle is imported successfully. Performing any operations on the file
    descriptor after it is imported results in undefined behavior.

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32`, then
    exactly one of
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    and
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name
    must not be NULL. If
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    is not NULL, then it must represent a valid shared NT handle that
    references a synchronization object. Ownership of this handle is not
    transferred to CUDA after the import operation, so the application must
    release the handle using the appropriate system call. If
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must name a valid synchronization object.

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT`, then
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    must be non-NULL and
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name
    must be NULL. The handle specified must be a globally shared KMT
    handle. This handle does not hold a reference to the underlying object,
    and thus will be invalid when all references to the synchronization
    object are destroyed.

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE`, then exactly
    one of
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    and
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name
    must not be NULL. If
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    is not NULL, then it must represent a valid shared NT handle that is
    returned by ID3D12Device::CreateSharedHandle when referring to a
    ID3D12Fence object. This handle holds a reference to the underlying
    object. If
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must name a valid synchronization object that refers
    to a valid ID3D12Fence object.

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE`, then
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    represents a valid shared NT handle that is returned by
    ID3D11Fence::CreateSharedHandle. If
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must name a valid synchronization object that refers
    to a valid ID3D11Fence object.

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC`, then
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::nvSciSyncObj
    represents a valid NvSciSyncObj.

    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX`, then
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    represents a valid shared NT handle that is returned by
    IDXGIResource1::CreateSharedHandle when referring to a IDXGIKeyedMutex
    object. If
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must name a valid synchronization object that refers
    to a valid IDXGIKeyedMutex object.

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT`,
    then
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    represents a valid shared KMT handle that is returned by
    IDXGIResource::GetSharedHandle when referring to a IDXGIKeyedMutex
    object and
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name
    must be NULL.

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD`,
    then :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::fd must
    be a valid file descriptor referencing a synchronization object.
    Ownership of the file descriptor is transferred to the CUDA driver when
    the handle is imported successfully. Performing any operations on the
    file descriptor after it is imported results in undefined behavior.

    If :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC.type` is
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32`,
    then exactly one of
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    and
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name
    must not be NULL. If
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::handle
    is not NULL, then it must represent a valid shared NT handle that
    references a synchronization object. Ownership of this handle is not
    transferred to CUDA after the import operation, so the application must
    release the handle using the appropriate system call. If
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`::handle::win32::name is
    not NULL, then it must name a valid synchronization object.

    Parameters
    ----------
    semHandleDesc : :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC`
        Semaphore import handle descriptor

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    extSem_out : :py:obj:`~.CUexternalSemaphore`
        Returned handle to an external semaphore

    See Also
    --------
    :py:obj:`~.cuDestroyExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """
    cdef CUexternalSemaphore extSem_out = CUexternalSemaphore()
    cdef ccuda.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC* csemHandleDesc_ptr = semHandleDesc._ptr if semHandleDesc != None else NULL
    err = ccuda.cuImportExternalSemaphore(extSem_out._ptr, csemHandleDesc_ptr)
    return (CUresult(err), extSem_out)

@cython.embedsignature(True)
def cuSignalExternalSemaphoresAsync(extSemArray : List[CUexternalSemaphore], paramsArray : List[CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS], unsigned int numExtSems, stream):
    """ Signals a set of external semaphore objects.

    Enqueues a signal operation on a set of externally allocated semaphore
    object in the specified stream. The operations will be executed when
    all prior operations in the stream complete.

    The exact semantics of signaling a semaphore depends on the type of the
    object.

    If the semaphore object is any one of the following types:
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT` then
    signaling the semaphore will set it to the signaled state.

    If the semaphore object is any one of the following types:
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32`
    then the semaphore will be set to the value specified in
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS`::params::fence::value.

    If the semaphore object is of the type
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC` this API sets
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS`::params::nvSciSync::fence
    to a value that can be used by subsequent waiters of the same NvSciSync
    object to order operations with those currently submitted in `stream`.
    Such an update will overwrite previous contents of
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS`::params::nvSciSync::fence.
    By default, signaling such an external semaphore object causes
    appropriate memory synchronization operations to be performed over all
    external memory objects that are imported as
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF`. This ensures that
    any subsequent accesses made by other importers of the same set of
    NvSciBuf memory object(s) are coherent. These operations can be skipped
    by specifying the flag
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC`, which
    can be used as a performance optimization when data coherency is not
    required. But specifying this flag in scenarios where data coherency is
    required results in undefined behavior. Also, for semaphore object of
    the type :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC`, if
    the NvSciSyncAttrList used to create the NvSciSyncObj had not set the
    flags in :py:obj:`~.cuDeviceGetNvSciSyncAttributes` to
    CUDA_NVSCISYNC_ATTR_SIGNAL, this API will return
    CUDA_ERROR_NOT_SUPPORTED.

    If the semaphore object is any one of the following types:
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT`
    then the keyed mutex will be released with the key specified in
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_PARAMS`::params::keyedmutex::key.

    Parameters
    ----------
    extSemArray : List[:py:obj:`~.CUexternalSemaphore`]
        Set of external semaphores to be signaled
    paramsArray : List[:py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS`]
        Array of semaphore parameters
    numExtSems : unsigned int
        Number of semaphores to signal
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to enqueue the signal operations in

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuDestroyExternalSemaphore`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """
    cdef ccuda.CUstream cstream
    if stream is None:
        cstream = <ccuda.CUstream><void_ptr>0
    elif isinstance(stream, (CUstream)):
        pstream = int(stream)
        cstream = <ccuda.CUstream><void_ptr>pstream
    else:
        pstream = int(CUstream(stream))
        cstream = <ccuda.CUstream><void_ptr>pstream

    paramsArray = [] if paramsArray is None else paramsArray
    if not all(isinstance(_x, (CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS)) for _x in paramsArray):
        raise TypeError("Argument 'paramsArray' is not instance of type (expected List[ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS]")

    extSemArray = [] if extSemArray is None else extSemArray
    if not all(isinstance(_x, (CUexternalSemaphore)) for _x in extSemArray):
        raise TypeError("Argument 'extSemArray' is not instance of type (expected List[ccuda.CUexternalSemaphore]")

    cdef ccuda.CUexternalSemaphore* cextSemArray = NULL
    if len(extSemArray) > 0:
        cextSemArray = <ccuda.CUexternalSemaphore*> calloc(len(extSemArray), sizeof(ccuda.CUexternalSemaphore))
        if cextSemArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(extSemArray)) + 'x' + str(sizeof(ccuda.CUexternalSemaphore)))
        else:
            for idx in range(len(extSemArray)):
                cextSemArray[idx] = (<CUexternalSemaphore>extSemArray[idx])._ptr[0]

    cdef ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS* cparamsArray = NULL
    if len(paramsArray) > 0:
        cparamsArray = <ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS*> calloc(len(paramsArray), sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS))
        if cparamsArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(paramsArray)) + 'x' + str(sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS)))
        for idx in range(len(paramsArray)):
            memcpy(&cparamsArray[idx], (<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS>paramsArray[idx])._ptr, sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS))

    if numExtSems > len(extSemArray): raise RuntimeError("List is too small: " + str(len(extSemArray)) + " < " + str(numExtSems))
    if numExtSems > len(paramsArray): raise RuntimeError("List is too small: " + str(len(paramsArray)) + " < " + str(numExtSems))
    err = ccuda.cuSignalExternalSemaphoresAsync((<CUexternalSemaphore>extSemArray[0])._ptr if len(extSemArray) == 1 else cextSemArray, (<CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS>paramsArray[0])._ptr if len(paramsArray) == 1 else cparamsArray, numExtSems, cstream)
    if cextSemArray is not NULL:
        free(cextSemArray)
    if cparamsArray is not NULL:
        free(cparamsArray)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuWaitExternalSemaphoresAsync(extSemArray : List[CUexternalSemaphore], paramsArray : List[CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS], unsigned int numExtSems, stream):
    """ Waits on a set of external semaphore objects.

    Enqueues a wait operation on a set of externally allocated semaphore
    object in the specified stream. The operations will be executed when
    all prior operations in the stream complete.

    The exact semantics of waiting on a semaphore depends on the type of
    the object.

    If the semaphore object is any one of the following types:
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT` then
    waiting on the semaphore will wait until the semaphore reaches the
    signaled state. The semaphore will then be reset to the unsignaled
    state. Therefore for every signal operation, there can only be one wait
    operation.

    If the semaphore object is any one of the following types:
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32`
    then waiting on the semaphore will wait until the value of the
    semaphore is greater than or equal to
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS`::params::fence::value.

    If the semaphore object is of the type
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC` then, waiting
    on the semaphore will wait until the
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS`::params::nvSciSync::fence
    is signaled by the signaler of the NvSciSyncObj that was associated
    with this semaphore object. By default, waiting on such an external
    semaphore object causes appropriate memory synchronization operations
    to be performed over all external memory objects that are imported as
    :py:obj:`~.CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF`. This ensures that
    any subsequent accesses made by other importers of the same set of
    NvSciBuf memory object(s) are coherent. These operations can be skipped
    by specifying the flag
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC`, which
    can be used as a performance optimization when data coherency is not
    required. But specifying this flag in scenarios where data coherency is
    required results in undefined behavior. Also, for semaphore object of
    the type :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC`, if
    the NvSciSyncAttrList used to create the NvSciSyncObj had not set the
    flags in :py:obj:`~.cuDeviceGetNvSciSyncAttributes` to
    CUDA_NVSCISYNC_ATTR_WAIT, this API will return
    CUDA_ERROR_NOT_SUPPORTED.

    If the semaphore object is any one of the following types:
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX`,
    :py:obj:`~.CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT`
    then the keyed mutex will be acquired when it is released with the key
    specified in
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS`::params::keyedmutex::key
    or until the timeout specified by
    :py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS`::params::keyedmutex::timeoutMs
    has lapsed. The timeout interval can either be a finite value specified
    in milliseconds or an infinite value. In case an infinite value is
    specified the timeout never elapses. The windows INFINITE macro must be
    used to specify infinite timeout.

    Parameters
    ----------
    extSemArray : List[:py:obj:`~.CUexternalSemaphore`]
        External semaphores to be waited on
    paramsArray : List[:py:obj:`~.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS`]
        Array of semaphore parameters
    numExtSems : unsigned int
        Number of semaphores to wait on
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to enqueue the wait operations in

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_TIMEOUT`

    See Also
    --------
    :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuDestroyExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`
    """
    cdef ccuda.CUstream cstream
    if stream is None:
        cstream = <ccuda.CUstream><void_ptr>0
    elif isinstance(stream, (CUstream)):
        pstream = int(stream)
        cstream = <ccuda.CUstream><void_ptr>pstream
    else:
        pstream = int(CUstream(stream))
        cstream = <ccuda.CUstream><void_ptr>pstream

    paramsArray = [] if paramsArray is None else paramsArray
    if not all(isinstance(_x, (CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS)) for _x in paramsArray):
        raise TypeError("Argument 'paramsArray' is not instance of type (expected List[ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS]")

    extSemArray = [] if extSemArray is None else extSemArray
    if not all(isinstance(_x, (CUexternalSemaphore)) for _x in extSemArray):
        raise TypeError("Argument 'extSemArray' is not instance of type (expected List[ccuda.CUexternalSemaphore]")

    cdef ccuda.CUexternalSemaphore* cextSemArray = NULL
    if len(extSemArray) > 0:
        cextSemArray = <ccuda.CUexternalSemaphore*> calloc(len(extSemArray), sizeof(ccuda.CUexternalSemaphore))
        if cextSemArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(extSemArray)) + 'x' + str(sizeof(ccuda.CUexternalSemaphore)))
        else:
            for idx in range(len(extSemArray)):
                cextSemArray[idx] = (<CUexternalSemaphore>extSemArray[idx])._ptr[0]

    cdef ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS* cparamsArray = NULL
    if len(paramsArray) > 0:
        cparamsArray = <ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS*> calloc(len(paramsArray), sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS))
        if cparamsArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(paramsArray)) + 'x' + str(sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS)))
        for idx in range(len(paramsArray)):
            memcpy(&cparamsArray[idx], (<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS>paramsArray[idx])._ptr, sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS))

    if numExtSems > len(extSemArray): raise RuntimeError("List is too small: " + str(len(extSemArray)) + " < " + str(numExtSems))
    if numExtSems > len(paramsArray): raise RuntimeError("List is too small: " + str(len(paramsArray)) + " < " + str(numExtSems))
    err = ccuda.cuWaitExternalSemaphoresAsync((<CUexternalSemaphore>extSemArray[0])._ptr if len(extSemArray) == 1 else cextSemArray, (<CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS>paramsArray[0])._ptr if len(paramsArray) == 1 else cparamsArray, numExtSems, cstream)
    if cextSemArray is not NULL:
        free(cextSemArray)
    if cparamsArray is not NULL:
        free(cparamsArray)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuDestroyExternalSemaphore(extSem):
    """ Destroys an external semaphore.

    Destroys an external semaphore object and releases any references to
    the underlying resource. Any outstanding signals or waits must have
    completed before the semaphore is destroyed.

    Parameters
    ----------
    extSem : :py:obj:`~.CUexternalSemaphore`
        External semaphore to be destroyed

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """
    cdef ccuda.CUexternalSemaphore cextSem
    if extSem is None:
        cextSem = <ccuda.CUexternalSemaphore><void_ptr>0
    elif isinstance(extSem, (CUexternalSemaphore)):
        pextSem = int(extSem)
        cextSem = <ccuda.CUexternalSemaphore><void_ptr>pextSem
    else:
        pextSem = int(CUexternalSemaphore(extSem))
        cextSem = <ccuda.CUexternalSemaphore><void_ptr>pextSem

    err = ccuda.cuDestroyExternalSemaphore(cextSem)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamWaitValue32(stream, addr, value, unsigned int flags):
    """ Wait on a memory location.

    Enqueues a synchronization of the stream on the given memory location.
    Work ordered after the operation will block until the given condition
    on the memory is satisfied. By default, the condition is to wait for
    (int32_t)(*addr - value) >= 0, a cyclic greater-or-equal. Other
    condition types can be specified via `flags`.

    If the memory was registered via :py:obj:`~.cuMemHostRegister()`, the
    device pointer should be obtained with
    :py:obj:`~.cuMemHostGetDevicePointer()`. This function cannot be used
    with managed memory (:py:obj:`~.cuMemAllocManaged`).

    Support for this can be queried with :py:obj:`~.cuDeviceGetAttribute()`
    and :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS`.

    Support for CU_STREAM_WAIT_VALUE_NOR can be queried with
    :py:obj:`~.cuDeviceGetAttribute()` and
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR`.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to synchronize on the memory location.
    addr : :py:obj:`~.CUdeviceptr`
        The memory location to wait on.
    value : Any
        The value to compare with the memory location.
    flags : unsigned int
        See :py:obj:`~.CUstreamWaitValue_flags`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamWaitValue64`, :py:obj:`~.cuStreamWriteValue32`, :py:obj:`~.cuStreamWriteValue64`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuStreamWaitEvent`

    Notes
    -----
    Warning: Improper use of this API may deadlock the application. Synchronization ordering established through this API is not visible to CUDA. CUDA tasks that are (even indirectly) ordered by this API should also have that order expressed with CUDA-visible dependencies such as events. This ensures that the scheduler does not serialize them in an improper order. For more information, see the Stream Memory Operations section in the programming guide(https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html).
    """
    cdef ccuda.cuuint32_t cvalue
    if value is None:
        cvalue = <ccuda.cuuint32_t><void_ptr>0
    elif isinstance(value, (cuuint32_t)):
        pvalue = int(value)
        cvalue = <ccuda.cuuint32_t><void_ptr>pvalue
    else:
        pvalue = int(cuuint32_t(value))
        cvalue = <ccuda.cuuint32_t><void_ptr>pvalue

    cdef ccuda.CUdeviceptr caddr
    if addr is None:
        caddr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(addr, (CUdeviceptr)):
        paddr = int(addr)
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr
    else:
        paddr = int(CUdeviceptr(addr))
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr

    cdef ccuda.CUstream cstream
    if stream is None:
        cstream = <ccuda.CUstream><void_ptr>0
    elif isinstance(stream, (CUstream)):
        pstream = int(stream)
        cstream = <ccuda.CUstream><void_ptr>pstream
    else:
        pstream = int(CUstream(stream))
        cstream = <ccuda.CUstream><void_ptr>pstream

    err = ccuda.cuStreamWaitValue32(cstream, caddr, cvalue, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamWaitValue64(stream, addr, value, unsigned int flags):
    """ Wait on a memory location.

    Enqueues a synchronization of the stream on the given memory location.
    Work ordered after the operation will block until the given condition
    on the memory is satisfied. By default, the condition is to wait for
    (int64_t)(*addr - value) >= 0, a cyclic greater-or-equal. Other
    condition types can be specified via `flags`.

    If the memory was registered via :py:obj:`~.cuMemHostRegister()`, the
    device pointer should be obtained with
    :py:obj:`~.cuMemHostGetDevicePointer()`.

    Support for this can be queried with :py:obj:`~.cuDeviceGetAttribute()`
    and :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS`.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to synchronize on the memory location.
    addr : :py:obj:`~.CUdeviceptr`
        The memory location to wait on.
    value : Any
        The value to compare with the memory location.
    flags : unsigned int
        See :py:obj:`~.CUstreamWaitValue_flags`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamWaitValue32`, :py:obj:`~.cuStreamWriteValue32`, :py:obj:`~.cuStreamWriteValue64`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuStreamWaitEvent`

    Notes
    -----
    Warning: Improper use of this API may deadlock the application. Synchronization ordering established through this API is not visible to CUDA. CUDA tasks that are (even indirectly) ordered by this API should also have that order expressed with CUDA-visible dependencies such as events. This ensures that the scheduler does not serialize them in an improper order. For more information, see the Stream Memory Operations section in the programming guide(https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html).
    """
    cdef ccuda.cuuint64_t cvalue
    if value is None:
        cvalue = <ccuda.cuuint64_t><void_ptr>0
    elif isinstance(value, (cuuint64_t)):
        pvalue = int(value)
        cvalue = <ccuda.cuuint64_t><void_ptr>pvalue
    else:
        pvalue = int(cuuint64_t(value))
        cvalue = <ccuda.cuuint64_t><void_ptr>pvalue

    cdef ccuda.CUdeviceptr caddr
    if addr is None:
        caddr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(addr, (CUdeviceptr)):
        paddr = int(addr)
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr
    else:
        paddr = int(CUdeviceptr(addr))
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr

    cdef ccuda.CUstream cstream
    if stream is None:
        cstream = <ccuda.CUstream><void_ptr>0
    elif isinstance(stream, (CUstream)):
        pstream = int(stream)
        cstream = <ccuda.CUstream><void_ptr>pstream
    else:
        pstream = int(CUstream(stream))
        cstream = <ccuda.CUstream><void_ptr>pstream

    err = ccuda.cuStreamWaitValue64(cstream, caddr, cvalue, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamWriteValue32(stream, addr, value, unsigned int flags):
    """ Write a value to memory.

    Write a value to memory. Unless the
    :py:obj:`~.CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER` flag is passed, the
    write is preceded by a system-wide memory fence, equivalent to a
    __threadfence_system() but scoped to the stream rather than a CUDA
    thread.

    If the memory was registered via :py:obj:`~.cuMemHostRegister()`, the
    device pointer should be obtained with
    :py:obj:`~.cuMemHostGetDevicePointer()`. This function cannot be used
    with managed memory (:py:obj:`~.cuMemAllocManaged`).

    Support for this can be queried with :py:obj:`~.cuDeviceGetAttribute()`
    and :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS`.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to do the write in.
    addr : :py:obj:`~.CUdeviceptr`
        The device address to write to.
    value : Any
        The value to write.
    flags : unsigned int
        See :py:obj:`~.CUstreamWriteValue_flags`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamWriteValue64`, :py:obj:`~.cuStreamWaitValue32`, :py:obj:`~.cuStreamWaitValue64`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuEventRecord`
    """
    cdef ccuda.cuuint32_t cvalue
    if value is None:
        cvalue = <ccuda.cuuint32_t><void_ptr>0
    elif isinstance(value, (cuuint32_t)):
        pvalue = int(value)
        cvalue = <ccuda.cuuint32_t><void_ptr>pvalue
    else:
        pvalue = int(cuuint32_t(value))
        cvalue = <ccuda.cuuint32_t><void_ptr>pvalue

    cdef ccuda.CUdeviceptr caddr
    if addr is None:
        caddr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(addr, (CUdeviceptr)):
        paddr = int(addr)
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr
    else:
        paddr = int(CUdeviceptr(addr))
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr

    cdef ccuda.CUstream cstream
    if stream is None:
        cstream = <ccuda.CUstream><void_ptr>0
    elif isinstance(stream, (CUstream)):
        pstream = int(stream)
        cstream = <ccuda.CUstream><void_ptr>pstream
    else:
        pstream = int(CUstream(stream))
        cstream = <ccuda.CUstream><void_ptr>pstream

    err = ccuda.cuStreamWriteValue32(cstream, caddr, cvalue, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamWriteValue64(stream, addr, value, unsigned int flags):
    """ Write a value to memory.

    Write a value to memory. Unless the
    :py:obj:`~.CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER` flag is passed, the
    write is preceded by a system-wide memory fence, equivalent to a
    __threadfence_system() but scoped to the stream rather than a CUDA
    thread.

    If the memory was registered via :py:obj:`~.cuMemHostRegister()`, the
    device pointer should be obtained with
    :py:obj:`~.cuMemHostGetDevicePointer()`.

    Support for this can be queried with :py:obj:`~.cuDeviceGetAttribute()`
    and :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS`.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to do the write in.
    addr : :py:obj:`~.CUdeviceptr`
        The device address to write to.
    value : Any
        The value to write.
    flags : unsigned int
        See :py:obj:`~.CUstreamWriteValue_flags`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamWriteValue32`, :py:obj:`~.cuStreamWaitValue32`, :py:obj:`~.cuStreamWaitValue64`, :py:obj:`~.cuStreamBatchMemOp`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuEventRecord`
    """
    cdef ccuda.cuuint64_t cvalue
    if value is None:
        cvalue = <ccuda.cuuint64_t><void_ptr>0
    elif isinstance(value, (cuuint64_t)):
        pvalue = int(value)
        cvalue = <ccuda.cuuint64_t><void_ptr>pvalue
    else:
        pvalue = int(cuuint64_t(value))
        cvalue = <ccuda.cuuint64_t><void_ptr>pvalue

    cdef ccuda.CUdeviceptr caddr
    if addr is None:
        caddr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(addr, (CUdeviceptr)):
        paddr = int(addr)
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr
    else:
        paddr = int(CUdeviceptr(addr))
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr

    cdef ccuda.CUstream cstream
    if stream is None:
        cstream = <ccuda.CUstream><void_ptr>0
    elif isinstance(stream, (CUstream)):
        pstream = int(stream)
        cstream = <ccuda.CUstream><void_ptr>pstream
    else:
        pstream = int(CUstream(stream))
        cstream = <ccuda.CUstream><void_ptr>pstream

    err = ccuda.cuStreamWriteValue64(cstream, caddr, cvalue, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamBatchMemOp(stream, unsigned int count, paramArray : List[CUstreamBatchMemOpParams], unsigned int flags):
    """ Batch operations to synchronize the stream via memory operations.

    This is a batch version of :py:obj:`~.cuStreamWaitValue32()` and
    :py:obj:`~.cuStreamWriteValue32()`. Batching operations may avoid some
    performance overhead in both the API call and the device execution
    versus adding them to the stream in separate API calls. The operations
    are enqueued in the order they appear in the array.

    See :py:obj:`~.CUstreamBatchMemOpType` for the full set of supported
    operations, and :py:obj:`~.cuStreamWaitValue32()`,
    :py:obj:`~.cuStreamWaitValue64()`, :py:obj:`~.cuStreamWriteValue32()`,
    and :py:obj:`~.cuStreamWriteValue64()` for details of specific
    operations.

    Basic support for this can be queried with
    :py:obj:`~.cuDeviceGetAttribute()` and
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS`. See related
    APIs for details on querying support for specific operations.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to enqueue the operations in.
    count : unsigned int
        The number of operations in the array. Must be less than 256.
    paramArray : List[:py:obj:`~.CUstreamBatchMemOpParams`]
        The types and parameters of the individual operations.
    flags : unsigned int
        Reserved for future expansion; must be 0.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamWaitValue32`, :py:obj:`~.cuStreamWaitValue64`, :py:obj:`~.cuStreamWriteValue32`, :py:obj:`~.cuStreamWriteValue64`, :py:obj:`~.cuMemHostRegister`

    Notes
    -----
    Warning: Improper use of this API may deadlock the application. Synchronization ordering established through this API is not visible to CUDA. CUDA tasks that are (even indirectly) ordered by this API should also have that order expressed with CUDA-visible dependencies such as events. This ensures that the scheduler does not serialize them in an improper order. For more information, see the Stream Memory Operations section in the programming guide(https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html).
    """
    paramArray = [] if paramArray is None else paramArray
    if not all(isinstance(_x, (CUstreamBatchMemOpParams)) for _x in paramArray):
        raise TypeError("Argument 'paramArray' is not instance of type (expected List[ccuda.CUstreamBatchMemOpParams]")

    cdef ccuda.CUstream cstream
    if stream is None:
        cstream = <ccuda.CUstream><void_ptr>0
    elif isinstance(stream, (CUstream)):
        pstream = int(stream)
        cstream = <ccuda.CUstream><void_ptr>pstream
    else:
        pstream = int(CUstream(stream))
        cstream = <ccuda.CUstream><void_ptr>pstream

    if count > len(paramArray): raise RuntimeError("List is too small: " + str(len(paramArray)) + " < " + str(count))
    cdef ccuda.CUstreamBatchMemOpParams* cparamArray = NULL
    if len(paramArray) > 0:
        cparamArray = <ccuda.CUstreamBatchMemOpParams*> calloc(len(paramArray), sizeof(ccuda.CUstreamBatchMemOpParams))
        if cparamArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(paramArray)) + 'x' + str(sizeof(ccuda.CUstreamBatchMemOpParams)))
        for idx in range(len(paramArray)):
            memcpy(&cparamArray[idx], (<CUstreamBatchMemOpParams>paramArray[idx])._ptr, sizeof(ccuda.CUstreamBatchMemOpParams))

    err = ccuda.cuStreamBatchMemOp(cstream, count, (<CUstreamBatchMemOpParams>paramArray[0])._ptr if len(paramArray) == 1 else cparamArray, flags)
    if cparamArray is not NULL:
        free(cparamArray)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamWaitValue32_v2(stream, addr, value, unsigned int flags):
    """ Wait on a memory location.

    Enqueues a synchronization of the stream on the given memory location.
    Work ordered after the operation will block until the given condition
    on the memory is satisfied. By default, the condition is to wait for
    (int32_t)(*addr - value) >= 0, a cyclic greater-or-equal. Other
    condition types can be specified via `flags`.

    If the memory was registered via :py:obj:`~.cuMemHostRegister()`, the
    device pointer should be obtained with
    :py:obj:`~.cuMemHostGetDevicePointer()`. This function cannot be used
    with managed memory (:py:obj:`~.cuMemAllocManaged`).

    Support for CU_STREAM_WAIT_VALUE_NOR can be queried with
    :py:obj:`~.cuDeviceGetAttribute()` and
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V2`.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to synchronize on the memory location.
    addr : :py:obj:`~.CUdeviceptr`
        The memory location to wait on.
    value : Any
        The value to compare with the memory location.
    flags : unsigned int
        See :py:obj:`~.CUstreamWaitValue_flags`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamWaitValue64_v2`, :py:obj:`~.cuStreamWriteValue32_v2`, :py:obj:`~.cuStreamWriteValue64_v2`, :py:obj:`~.cuStreamBatchMemOp_v2`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuStreamWaitEvent`

    Notes
    -----
    Warning: Improper use of this API may deadlock the application. Synchronization ordering established through this API is not visible to CUDA. CUDA tasks that are (even indirectly) ordered by this API should also have that order expressed with CUDA-visible dependencies such as events. This ensures that the scheduler does not serialize them in an improper order. For more information, see the Stream Memory Operations section in the programming guide(https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html).
    """
    cdef ccuda.cuuint32_t cvalue
    if value is None:
        cvalue = <ccuda.cuuint32_t><void_ptr>0
    elif isinstance(value, (cuuint32_t)):
        pvalue = int(value)
        cvalue = <ccuda.cuuint32_t><void_ptr>pvalue
    else:
        pvalue = int(cuuint32_t(value))
        cvalue = <ccuda.cuuint32_t><void_ptr>pvalue

    cdef ccuda.CUdeviceptr caddr
    if addr is None:
        caddr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(addr, (CUdeviceptr)):
        paddr = int(addr)
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr
    else:
        paddr = int(CUdeviceptr(addr))
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr

    cdef ccuda.CUstream cstream
    if stream is None:
        cstream = <ccuda.CUstream><void_ptr>0
    elif isinstance(stream, (CUstream)):
        pstream = int(stream)
        cstream = <ccuda.CUstream><void_ptr>pstream
    else:
        pstream = int(CUstream(stream))
        cstream = <ccuda.CUstream><void_ptr>pstream

    err = ccuda.cuStreamWaitValue32_v2(cstream, caddr, cvalue, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamWaitValue64_v2(stream, addr, value, unsigned int flags):
    """ Wait on a memory location.

    Enqueues a synchronization of the stream on the given memory location.
    Work ordered after the operation will block until the given condition
    on the memory is satisfied. By default, the condition is to wait for
    (int64_t)(*addr - value) >= 0, a cyclic greater-or-equal. Other
    condition types can be specified via `flags`.

    If the memory was registered via :py:obj:`~.cuMemHostRegister()`, the
    device pointer should be obtained with
    :py:obj:`~.cuMemHostGetDevicePointer()`.

    Support for this can be queried with :py:obj:`~.cuDeviceGetAttribute()`
    and :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V2`.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to synchronize on the memory location.
    addr : :py:obj:`~.CUdeviceptr`
        The memory location to wait on.
    value : Any
        The value to compare with the memory location.
    flags : unsigned int
        See :py:obj:`~.CUstreamWaitValue_flags`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamWaitValue32_v2`, :py:obj:`~.cuStreamWriteValue32_v2`, :py:obj:`~.cuStreamWriteValue64_v2`, :py:obj:`~.cuStreamBatchMemOp_v2`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuStreamWaitEvent`

    Notes
    -----
    Warning: Improper use of this API may deadlock the application. Synchronization ordering established through this API is not visible to CUDA. CUDA tasks that are (even indirectly) ordered by this API should also have that order expressed with CUDA-visible dependencies such as events. This ensures that the scheduler does not serialize them in an improper order. For more information, see the Stream Memory Operations section in the programming guide(https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html).
    """
    cdef ccuda.cuuint64_t cvalue
    if value is None:
        cvalue = <ccuda.cuuint64_t><void_ptr>0
    elif isinstance(value, (cuuint64_t)):
        pvalue = int(value)
        cvalue = <ccuda.cuuint64_t><void_ptr>pvalue
    else:
        pvalue = int(cuuint64_t(value))
        cvalue = <ccuda.cuuint64_t><void_ptr>pvalue

    cdef ccuda.CUdeviceptr caddr
    if addr is None:
        caddr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(addr, (CUdeviceptr)):
        paddr = int(addr)
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr
    else:
        paddr = int(CUdeviceptr(addr))
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr

    cdef ccuda.CUstream cstream
    if stream is None:
        cstream = <ccuda.CUstream><void_ptr>0
    elif isinstance(stream, (CUstream)):
        pstream = int(stream)
        cstream = <ccuda.CUstream><void_ptr>pstream
    else:
        pstream = int(CUstream(stream))
        cstream = <ccuda.CUstream><void_ptr>pstream

    err = ccuda.cuStreamWaitValue64_v2(cstream, caddr, cvalue, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamWriteValue32_v2(stream, addr, value, unsigned int flags):
    """ Write a value to memory.

    Write a value to memory.

    If the memory was registered via :py:obj:`~.cuMemHostRegister()`, the
    device pointer should be obtained with
    :py:obj:`~.cuMemHostGetDevicePointer()`. This function cannot be used
    with managed memory (:py:obj:`~.cuMemAllocManaged`).

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to do the write in.
    addr : :py:obj:`~.CUdeviceptr`
        The device address to write to.
    value : Any
        The value to write.
    flags : unsigned int
        See :py:obj:`~.CUstreamWriteValue_flags`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamWriteValue64_v2`, :py:obj:`~.cuStreamWaitValue32_v2`, :py:obj:`~.cuStreamWaitValue64_v2`, :py:obj:`~.cuStreamBatchMemOp_v2`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuEventRecord`
    """
    cdef ccuda.cuuint32_t cvalue
    if value is None:
        cvalue = <ccuda.cuuint32_t><void_ptr>0
    elif isinstance(value, (cuuint32_t)):
        pvalue = int(value)
        cvalue = <ccuda.cuuint32_t><void_ptr>pvalue
    else:
        pvalue = int(cuuint32_t(value))
        cvalue = <ccuda.cuuint32_t><void_ptr>pvalue

    cdef ccuda.CUdeviceptr caddr
    if addr is None:
        caddr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(addr, (CUdeviceptr)):
        paddr = int(addr)
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr
    else:
        paddr = int(CUdeviceptr(addr))
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr

    cdef ccuda.CUstream cstream
    if stream is None:
        cstream = <ccuda.CUstream><void_ptr>0
    elif isinstance(stream, (CUstream)):
        pstream = int(stream)
        cstream = <ccuda.CUstream><void_ptr>pstream
    else:
        pstream = int(CUstream(stream))
        cstream = <ccuda.CUstream><void_ptr>pstream

    err = ccuda.cuStreamWriteValue32_v2(cstream, caddr, cvalue, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamWriteValue64_v2(stream, addr, value, unsigned int flags):
    """ Write a value to memory.

    Write a value to memory.

    If the memory was registered via :py:obj:`~.cuMemHostRegister()`, the
    device pointer should be obtained with
    :py:obj:`~.cuMemHostGetDevicePointer()`.

    Support for this can be queried with :py:obj:`~.cuDeviceGetAttribute()`
    and :py:obj:`~.CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V2`.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to do the write in.
    addr : :py:obj:`~.CUdeviceptr`
        The device address to write to.
    value : Any
        The value to write.
    flags : unsigned int
        See :py:obj:`~.CUstreamWriteValue_flags`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamWriteValue32_v2`, :py:obj:`~.cuStreamWaitValue32_v2`, :py:obj:`~.cuStreamWaitValue64_v2`, :py:obj:`~.cuStreamBatchMemOp_v2`, :py:obj:`~.cuMemHostRegister`, :py:obj:`~.cuEventRecord`
    """
    cdef ccuda.cuuint64_t cvalue
    if value is None:
        cvalue = <ccuda.cuuint64_t><void_ptr>0
    elif isinstance(value, (cuuint64_t)):
        pvalue = int(value)
        cvalue = <ccuda.cuuint64_t><void_ptr>pvalue
    else:
        pvalue = int(cuuint64_t(value))
        cvalue = <ccuda.cuuint64_t><void_ptr>pvalue

    cdef ccuda.CUdeviceptr caddr
    if addr is None:
        caddr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(addr, (CUdeviceptr)):
        paddr = int(addr)
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr
    else:
        paddr = int(CUdeviceptr(addr))
        caddr = <ccuda.CUdeviceptr><void_ptr>paddr

    cdef ccuda.CUstream cstream
    if stream is None:
        cstream = <ccuda.CUstream><void_ptr>0
    elif isinstance(stream, (CUstream)):
        pstream = int(stream)
        cstream = <ccuda.CUstream><void_ptr>pstream
    else:
        pstream = int(CUstream(stream))
        cstream = <ccuda.CUstream><void_ptr>pstream

    err = ccuda.cuStreamWriteValue64_v2(cstream, caddr, cvalue, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuStreamBatchMemOp_v2(stream, unsigned int count, paramArray : List[CUstreamBatchMemOpParams], unsigned int flags):
    """ Batch operations to synchronize the stream via memory operations.

    This is a batch version of :py:obj:`~.cuStreamWaitValue32_v2()` and
    :py:obj:`~.cuStreamWriteValue32_v2()`. Batching operations may avoid
    some performance overhead in both the API call and the device execution
    versus adding them to the stream in separate API calls. The operations
    are enqueued in the order they appear in the array.

    See :py:obj:`~.CUstreamBatchMemOpType` for the full set of supported
    operations, and :py:obj:`~.cuStreamWaitValue32_v2()`,
    :py:obj:`~.cuStreamWaitValue64_v2()`,
    :py:obj:`~.cuStreamWriteValue32_v2()`, and
    :py:obj:`~.cuStreamWriteValue64_v2()` for details of specific
    operations.

    See related APIs for details on querying support for specific
    operations.

    Parameters
    ----------
    stream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        The stream to enqueue the operations in.
    count : unsigned int
        The number of operations in the array. Must be less than 256.
    paramArray : List[:py:obj:`~.CUstreamBatchMemOpParams`]
        The types and parameters of the individual operations.
    flags : unsigned int
        Reserved for future expansion; must be 0.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamWaitValue32_v2`, :py:obj:`~.cuStreamWaitValue64_v2`, :py:obj:`~.cuStreamWriteValue32_v2`, :py:obj:`~.cuStreamWriteValue64_v2`, :py:obj:`~.cuMemHostRegister`

    Notes
    -----
    Warning: Improper use of this API may deadlock the application. Synchronization ordering established through this API is not visible to CUDA. CUDA tasks that are (even indirectly) ordered by this API should also have that order expressed with CUDA-visible dependencies such as events. This ensures that the scheduler does not serialize them in an improper order. For more information, see the Stream Memory Operations section in the programming guide(https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html).
    """
    paramArray = [] if paramArray is None else paramArray
    if not all(isinstance(_x, (CUstreamBatchMemOpParams)) for _x in paramArray):
        raise TypeError("Argument 'paramArray' is not instance of type (expected List[ccuda.CUstreamBatchMemOpParams]")

    cdef ccuda.CUstream cstream
    if stream is None:
        cstream = <ccuda.CUstream><void_ptr>0
    elif isinstance(stream, (CUstream)):
        pstream = int(stream)
        cstream = <ccuda.CUstream><void_ptr>pstream
    else:
        pstream = int(CUstream(stream))
        cstream = <ccuda.CUstream><void_ptr>pstream

    if count > len(paramArray): raise RuntimeError("List is too small: " + str(len(paramArray)) + " < " + str(count))
    cdef ccuda.CUstreamBatchMemOpParams* cparamArray = NULL
    if len(paramArray) > 0:
        cparamArray = <ccuda.CUstreamBatchMemOpParams*> calloc(len(paramArray), sizeof(ccuda.CUstreamBatchMemOpParams))
        if cparamArray is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(paramArray)) + 'x' + str(sizeof(ccuda.CUstreamBatchMemOpParams)))
        for idx in range(len(paramArray)):
            memcpy(&cparamArray[idx], (<CUstreamBatchMemOpParams>paramArray[idx])._ptr, sizeof(ccuda.CUstreamBatchMemOpParams))

    err = ccuda.cuStreamBatchMemOp_v2(cstream, count, (<CUstreamBatchMemOpParams>paramArray[0])._ptr if len(paramArray) == 1 else cparamArray, flags)
    if cparamArray is not NULL:
        free(cparamArray)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuFuncGetAttribute(attrib not None : CUfunction_attribute, hfunc):
    """ Returns information about a function.

    Returns in `*pi` the integer value of the attribute `attrib` on the
    kernel given by `hfunc`. The supported attributes are:

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK`: The maximum
      number of threads per block, beyond which a launch of the function
      would fail. This number depends on both the function and the device
      on which the function is currently loaded.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES`: The size in bytes of
      statically-allocated shared memory per block required by this
      function. This does not include dynamically-allocated shared memory
      requested by the user at runtime.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES`: The size in bytes of
      user-allocated constant memory required by this function.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES`: The size in bytes of
      local memory used by each thread of this function.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_NUM_REGS`: The number of registers used
      by each thread of this function.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_PTX_VERSION`: The PTX virtual
      architecture version for which the function was compiled. This value
      is the major PTX version * 10

      - the minor PTX version, so a PTX version 1.3 function would return
        the value 13. Note that this may return the undefined value of 0
        for cubins compiled prior to CUDA 3.0.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_BINARY_VERSION`: The binary architecture
      version for which the function was compiled. This value is the major
      binary version * 10 + the minor binary version, so a binary version
      1.3 function would return the value 13. Note that this will return a
      value of 10 for legacy cubins that do not have a properly-encoded
      binary architecture version.

    - :py:obj:`~.CU_FUNC_CACHE_MODE_CA`: The attribute to indicate whether
      the function has been compiled with user specified option "-Xptxas
      --dlcm=ca" set .

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES`: The
      maximum size in bytes of dynamically-allocated shared memory.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT`:
      Preferred shared memory-L1 cache split ratio in percent of total
      shared memory.

    Parameters
    ----------
    attrib : :py:obj:`~.CUfunction_attribute`
        Attribute requested
    hfunc : :py:obj:`~.CUfunction`
        Function to query attribute of

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pi : int
        Returned attribute value

    See Also
    --------
    :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cudaFuncGetAttributes`, :py:obj:`~.cudaFuncSetAttribute`
    """
    cdef ccuda.CUfunction chfunc
    if hfunc is None:
        chfunc = <ccuda.CUfunction><void_ptr>0
    elif isinstance(hfunc, (CUfunction)):
        phfunc = int(hfunc)
        chfunc = <ccuda.CUfunction><void_ptr>phfunc
    else:
        phfunc = int(CUfunction(hfunc))
        chfunc = <ccuda.CUfunction><void_ptr>phfunc

    cdef int pi = 0
    cdef ccuda.CUfunction_attribute cattrib = attrib.value
    err = ccuda.cuFuncGetAttribute(&pi, cattrib, chfunc)
    return (CUresult(err), pi)

@cython.embedsignature(True)
def cuFuncSetAttribute(hfunc, attrib not None : CUfunction_attribute, int value):
    """ Sets information about a function.

    This call sets the value of a specified attribute `attrib` on the
    kernel given by `hfunc` to an integer value specified by `val` This
    function returns CUDA_SUCCESS if the new value of the attribute could
    be successfully set. If the set fails, this call will return an error.
    Not all attributes can have values set. Attempting to set a value on a
    read-only attribute will result in an error (CUDA_ERROR_INVALID_VALUE)

    Supported attributes for the cuFuncSetAttribute call are:

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES`: This
      maximum size in bytes of dynamically-allocated shared memory. The
      value should contain the requested maximum size of dynamically-
      allocated shared memory. The sum of this value and the function
      attribute :py:obj:`~.CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES` cannot
      exceed the device attribute
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN`.
      The maximal size of requestable dynamic shared memory may differ by
      GPU architecture.

    - :py:obj:`~.CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT`: On
      devices where the L1 cache and shared memory use the same hardware
      resources, this sets the shared memory carveout preference, in
      percent of the total shared memory. See
      :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR`
      This is only a hint, and the driver can choose a different ratio if
      required to execute the function.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Function to query attribute of
    attrib : :py:obj:`~.CUfunction_attribute`
        Attribute requested
    value : int
        The value to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cudaFuncGetAttributes`, :py:obj:`~.cudaFuncSetAttribute`
    """
    cdef ccuda.CUfunction chfunc
    if hfunc is None:
        chfunc = <ccuda.CUfunction><void_ptr>0
    elif isinstance(hfunc, (CUfunction)):
        phfunc = int(hfunc)
        chfunc = <ccuda.CUfunction><void_ptr>phfunc
    else:
        phfunc = int(CUfunction(hfunc))
        chfunc = <ccuda.CUfunction><void_ptr>phfunc

    cdef ccuda.CUfunction_attribute cattrib = attrib.value
    err = ccuda.cuFuncSetAttribute(chfunc, cattrib, value)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuFuncSetCacheConfig(hfunc, config not None : CUfunc_cache):
    """ Sets the preferred cache configuration for a device function.

    On devices where the L1 cache and shared memory use the same hardware
    resources, this sets through `config` the preferred cache configuration
    for the device function `hfunc`. This is only a preference. The driver
    will use the requested configuration if possible, but it is free to
    choose a different configuration if required to execute `hfunc`. Any
    context-wide preference set via :py:obj:`~.cuCtxSetCacheConfig()` will
    be overridden by this per-function setting unless the per-function
    setting is :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE`. In that case, the
    current context-wide setting will be used.

    This setting does nothing on devices where the size of the L1 cache and
    shared memory are fixed.

    Launching a kernel with a different preference than the most recent
    preference setting may insert a device-side synchronization point.

    The supported cache configurations are:

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_NONE`: no preference for shared
      memory or L1 (default)

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_SHARED`: prefer larger shared memory
      and smaller L1 cache

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_L1`: prefer larger L1 cache and
      smaller shared memory

    - :py:obj:`~.CU_FUNC_CACHE_PREFER_EQUAL`: prefer equal sized L1 cache
      and shared memory

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Kernel to configure cache for
    config : :py:obj:`~.CUfunc_cache`
        Requested cache configuration

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cudaFuncSetCacheConfig`
    """
    cdef ccuda.CUfunction chfunc
    if hfunc is None:
        chfunc = <ccuda.CUfunction><void_ptr>0
    elif isinstance(hfunc, (CUfunction)):
        phfunc = int(hfunc)
        chfunc = <ccuda.CUfunction><void_ptr>phfunc
    else:
        phfunc = int(CUfunction(hfunc))
        chfunc = <ccuda.CUfunction><void_ptr>phfunc

    cdef ccuda.CUfunc_cache cconfig = config.value
    err = ccuda.cuFuncSetCacheConfig(chfunc, cconfig)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuFuncSetSharedMemConfig(hfunc, config not None : CUsharedconfig):
    """ Sets the shared memory configuration for a device function.

    On devices with configurable shared memory banks, this function will
    force all subsequent launches of the specified device function to have
    the given shared memory bank size configuration. On any given launch of
    the function, the shared memory configuration of the device will be
    temporarily changed if needed to suit the function's preferred
    configuration. Changes in shared memory configuration between
    subsequent launches of functions, may introduce a device side
    synchronization point.

    Any per-function setting of shared memory bank size set via
    :py:obj:`~.cuFuncSetSharedMemConfig` will override the context wide
    setting set with :py:obj:`~.cuCtxSetSharedMemConfig`.

    Changing the shared memory bank size will not increase shared memory
    usage or affect occupancy of kernels, but may have major effects on
    performance. Larger bank sizes will allow for greater potential
    bandwidth to shared memory, but will change what kinds of accesses to
    shared memory will result in bank conflicts.

    This function will do nothing on devices with fixed shared memory bank
    size.

    The supported bank configurations are:

    - :py:obj:`~.CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE`: use the context's
      shared memory configuration when launching this function.

    - :py:obj:`~.CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE`: set shared
      memory bank width to be natively four bytes when launching this
      function.

    - :py:obj:`~.CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE`: set shared
      memory bank width to be natively eight bytes when launching this
      function.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        kernel to be given a shared memory config
    config : :py:obj:`~.CUsharedconfig`
        requested shared memory configuration

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuCtxGetSharedMemConfig`, :py:obj:`~.cuCtxSetSharedMemConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cudaFuncSetSharedMemConfig`
    """
    cdef ccuda.CUfunction chfunc
    if hfunc is None:
        chfunc = <ccuda.CUfunction><void_ptr>0
    elif isinstance(hfunc, (CUfunction)):
        phfunc = int(hfunc)
        chfunc = <ccuda.CUfunction><void_ptr>phfunc
    else:
        phfunc = int(CUfunction(hfunc))
        chfunc = <ccuda.CUfunction><void_ptr>phfunc

    cdef ccuda.CUsharedconfig cconfig = config.value
    err = ccuda.cuFuncSetSharedMemConfig(chfunc, cconfig)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuFuncGetModule(hfunc):
    """ Returns a module handle.

    Returns in `*hmod` the handle of the module that function `hfunc` is
    located in. The lifetime of the module corresponds to the lifetime of
    the context it was loaded in or until the module is explicitly
    unloaded.

    The CUDA runtime manages its own modules loaded into the primary
    context. If the handle returned by this API refers to a module loaded
    by the CUDA runtime, calling :py:obj:`~.cuModuleUnload()` on that
    module will result in undefined behavior.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Function to retrieve module for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
    hmod : :py:obj:`~.CUmodule`
        Returned module handle
    """
    cdef ccuda.CUfunction chfunc
    if hfunc is None:
        chfunc = <ccuda.CUfunction><void_ptr>0
    elif isinstance(hfunc, (CUfunction)):
        phfunc = int(hfunc)
        chfunc = <ccuda.CUfunction><void_ptr>phfunc
    else:
        phfunc = int(CUfunction(hfunc))
        chfunc = <ccuda.CUfunction><void_ptr>phfunc

    cdef CUmodule hmod = CUmodule()
    err = ccuda.cuFuncGetModule(hmod._ptr, chfunc)
    return (CUresult(err), hmod)

@cython.embedsignature(True)
def cuLaunchKernel(f, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, hStream, kernelParams, void_ptr extra):
    """ Launches a CUDA function.

    Invokes the kernel `f` on a `gridDimX` x `gridDimY` x `gridDimZ` grid
    of blocks. Each block contains `blockDimX` x `blockDimY` x `blockDimZ`
    threads.

    `sharedMemBytes` sets the amount of dynamic shared memory that will be
    available to each thread block.

    Kernel parameters to `f` can be specified in one of two ways:

    1) Kernel parameters can be specified via `kernelParams`. If `f` has N
    parameters, then `kernelParams` needs to be an array of N pointers.
    Each of `kernelParams`[0] through `kernelParams`[N-1] must point to a
    region of memory from which the actual kernel parameter will be copied.
    The number of kernel parameters and their offsets and sizes do not need
    to be specified as that information is retrieved directly from the
    kernel's image.

    2) Kernel parameters can also be packaged by the application into a
    single buffer that is passed in via the `extra` parameter. This places
    the burden on the application of knowing each kernel parameter's size
    and alignment/padding within the buffer. Here is an example of using
    the `extra` parameter in this manner:

    **View CUDA Toolkit Documentation for a C++ code example**

    The `extra` parameter exists to allow :py:obj:`~.cuLaunchKernel` to
    take additional less commonly used arguments. `extra` specifies a list
    of names of extra settings and their corresponding values. Each extra
    setting name is immediately followed by the corresponding value. The
    list must be terminated with either NULL or
    :py:obj:`~.CU_LAUNCH_PARAM_END`.

    - :py:obj:`~.CU_LAUNCH_PARAM_END`, which indicates the end of the
      `extra` array;

    - :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER`, which specifies that the
      next value in `extra` will be a pointer to a buffer containing all
      the kernel parameters for launching kernel `f`;

    - :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_SIZE`, which specifies that the
      next value in `extra` will be a pointer to a size_t containing the
      size of the buffer specified with
      :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER`;

    The error :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned if
    kernel parameters are specified with both `kernelParams` and `extra`
    (i.e. both `kernelParams` and `extra` are non-NULL).

    Calling :py:obj:`~.cuLaunchKernel()` invalidates the persistent
    function state set through the following deprecated APIs:
    :py:obj:`~.cuFuncSetBlockShape()`, :py:obj:`~.cuFuncSetSharedSize()`,
    :py:obj:`~.cuParamSetSize()`, :py:obj:`~.cuParamSeti()`,
    :py:obj:`~.cuParamSetf()`, :py:obj:`~.cuParamSetv()`.

    Note that to use :py:obj:`~.cuLaunchKernel()`, the kernel `f` must
    either have been compiled with toolchain version 3.2 or later so that
    it will contain kernel parameter information, or have no kernel
    parameters. If either of these conditions is not met, then
    :py:obj:`~.cuLaunchKernel()` will return
    :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`.

    Parameters
    ----------
    f : :py:obj:`~.CUfunction`
        Kernel to launch
    gridDimX : unsigned int
        Width of grid in blocks
    gridDimY : unsigned int
        Height of grid in blocks
    gridDimZ : unsigned int
        Depth of grid in blocks
    blockDimX : unsigned int
        X dimension of each thread block
    blockDimY : unsigned int
        Y dimension of each thread block
    blockDimZ : unsigned int
        Z dimension of each thread block
    sharedMemBytes : unsigned int
        Dynamic shared-memory size per thread block in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier
    kernelParams : Any
        Array of pointers to kernel parameters
    extra : List[Any]
        Extra options

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`

    See Also
    --------
    :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cudaLaunchKernel`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUfunction cf
    if f is None:
        cf = <ccuda.CUfunction><void_ptr>0
    elif isinstance(f, (CUfunction)):
        pf = int(f)
        cf = <ccuda.CUfunction><void_ptr>pf
    else:
        pf = int(CUfunction(f))
        cf = <ccuda.CUfunction><void_ptr>pf

    ckernelParams = utils.HelperKernelParams(kernelParams)
    err = ccuda.cuLaunchKernel(cf, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, chStream, <void**><void_ptr>ckernelParams.ckernelParams, <void**>extra)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuLaunchCooperativeKernel(f, unsigned int gridDimX, unsigned int gridDimY, unsigned int gridDimZ, unsigned int blockDimX, unsigned int blockDimY, unsigned int blockDimZ, unsigned int sharedMemBytes, hStream, kernelParams):
    """ Launches a CUDA function where thread blocks can cooperate and synchronize as they execute.

    Invokes the kernel `f` on a `gridDimX` x `gridDimY` x `gridDimZ` grid
    of blocks. Each block contains `blockDimX` x `blockDimY` x `blockDimZ`
    threads.

    `sharedMemBytes` sets the amount of dynamic shared memory that will be
    available to each thread block.

    The device on which this kernel is invoked must have a non-zero value
    for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH`.

    The total number of blocks launched cannot exceed the maximum number of
    blocks per multiprocessor as returned by
    :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessor` (or
    :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags`) times
    the number of multiprocessors as specified by the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT`.

    The kernel cannot make use of CUDA dynamic parallelism.

    Kernel parameters must be specified via `kernelParams`. If `f` has N
    parameters, then `kernelParams` needs to be an array of N pointers.
    Each of `kernelParams`[0] through `kernelParams`[N-1] must point to a
    region of memory from which the actual kernel parameter will be copied.
    The number of kernel parameters and their offsets and sizes do not need
    to be specified as that information is retrieved directly from the
    kernel's image.

    Calling :py:obj:`~.cuLaunchCooperativeKernel()` sets persistent
    function state that is the same as function state set through
    :py:obj:`~.cuLaunchKernel` API

    When the kernel `f` is launched via
    :py:obj:`~.cuLaunchCooperativeKernel()`, the previous block shape,
    shared size and parameter info associated with `f` is overwritten.

    Note that to use :py:obj:`~.cuLaunchCooperativeKernel()`, the kernel
    `f` must either have been compiled with toolchain version 3.2 or later
    so that it will contain kernel parameter information, or have no kernel
    parameters. If either of these conditions is not met, then
    :py:obj:`~.cuLaunchCooperativeKernel()` will return
    :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`.

    Parameters
    ----------
    f : :py:obj:`~.CUfunction`
        Kernel to launch
    gridDimX : unsigned int
        Width of grid in blocks
    gridDimY : unsigned int
        Height of grid in blocks
    gridDimZ : unsigned int
        Depth of grid in blocks
    blockDimX : unsigned int
        X dimension of each thread block
    blockDimY : unsigned int
        Y dimension of each thread block
    blockDimZ : unsigned int
        Z dimension of each thread block
    sharedMemBytes : unsigned int
        Dynamic shared-memory size per thread block in bytes
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier
    kernelParams : Any
        Array of pointers to kernel parameters

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`

    See Also
    --------
    :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuLaunchCooperativeKernelMultiDevice`, :py:obj:`~.cudaLaunchCooperativeKernel`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUfunction cf
    if f is None:
        cf = <ccuda.CUfunction><void_ptr>0
    elif isinstance(f, (CUfunction)):
        pf = int(f)
        cf = <ccuda.CUfunction><void_ptr>pf
    else:
        pf = int(CUfunction(f))
        cf = <ccuda.CUfunction><void_ptr>pf

    ckernelParams = utils.HelperKernelParams(kernelParams)
    err = ccuda.cuLaunchCooperativeKernel(cf, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, chStream, <void**><void_ptr>ckernelParams.ckernelParams)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuLaunchCooperativeKernelMultiDevice(launchParamsList : List[CUDA_LAUNCH_PARAMS], unsigned int numDevices, unsigned int flags):
    """ Launches CUDA functions on multiple devices where thread blocks can cooperate and synchronize as they execute.

    [Deprecated]

    Invokes kernels as specified in the `launchParamsList` array where each
    element of the array specifies all the parameters required to perform a
    single kernel launch. These kernels can cooperate and synchronize as
    they execute. The size of the array is specified by `numDevices`.

    No two kernels can be launched on the same device. All the devices
    targeted by this multi-device launch must be identical. All devices
    must have a non-zero value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH`.

    All kernels launched must be identical with respect to the compiled
    code. Note that any device, constant or managed variables present in
    the module that owns the kernel launched on each device, are
    independently instantiated on every device. It is the application's
    responsiblity to ensure these variables are initialized and used
    appropriately.

    The size of the grids as specified in blocks, the size of the blocks
    themselves and the amount of shared memory used by each thread block
    must also match across all launched kernels.

    The streams used to launch these kernels must have been created via
    either :py:obj:`~.cuStreamCreate` or
    :py:obj:`~.cuStreamCreateWithPriority`. The NULL stream or
    :py:obj:`~.CU_STREAM_LEGACY` or :py:obj:`~.CU_STREAM_PER_THREAD` cannot
    be used.

    The total number of blocks launched per kernel cannot exceed the
    maximum number of blocks per multiprocessor as returned by
    :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessor` (or
    :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags`) times
    the number of multiprocessors as specified by the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT`. Since the total
    number of blocks launched per device has to match across all devices,
    the maximum number of blocks that can be launched per device will be
    limited by the device with the least number of multiprocessors.

    The kernels cannot make use of CUDA dynamic parallelism.

    The :py:obj:`~.CUDA_LAUNCH_PARAMS` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.function` specifies the kernel to be
      launched. All functions must be identical with respect to the
      compiled code.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.gridDimX` is the width of the grid in
      blocks. This must match across all kernels launched.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.gridDimY` is the height of the grid in
      blocks. This must match across all kernels launched.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.gridDimZ` is the depth of the grid in
      blocks. This must match across all kernels launched.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.blockDimX` is the X dimension of each
      thread block. This must match across all kernels launched.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.blockDimX` is the Y dimension of each
      thread block. This must match across all kernels launched.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.blockDimZ` is the Z dimension of each
      thread block. This must match across all kernels launched.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.sharedMemBytes` is the dynamic shared-
      memory size per thread block in bytes. This must match across all
      kernels launched.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.hStream` is the handle to the stream to
      perform the launch in. This cannot be the NULL stream or
      :py:obj:`~.CU_STREAM_LEGACY` or :py:obj:`~.CU_STREAM_PER_THREAD`. The
      CUDA context associated with this stream must match that associated
      with :py:obj:`~.CUDA_LAUNCH_PARAMS.function`.

    - :py:obj:`~.CUDA_LAUNCH_PARAMS.kernelParams` is an array of pointers
      to kernel parameters. If :py:obj:`~.CUDA_LAUNCH_PARAMS.function` has
      N parameters, then :py:obj:`~.CUDA_LAUNCH_PARAMS.kernelParams` needs
      to be an array of N pointers. Each of
      :py:obj:`~.CUDA_LAUNCH_PARAMS.kernelParams`[0] through
      :py:obj:`~.CUDA_LAUNCH_PARAMS.kernelParams`[N-1] must point to a
      region of memory from which the actual kernel parameter will be
      copied. The number of kernel parameters and their offsets and sizes
      do not need to be specified as that information is retrieved directly
      from the kernel's image.

    By default, the kernel won't begin execution on any GPU until all prior
    work in all the specified streams has completed. This behavior can be
    overridden by specifying the flag
    :py:obj:`~.CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC`.
    When this flag is specified, each kernel will only wait for prior work
    in the stream corresponding to that GPU to complete before it begins
    execution.

    Similarly, by default, any subsequent work pushed in any of the
    specified streams will not begin execution until the kernels on all
    GPUs have completed. This behavior can be overridden by specifying the
    flag
    :py:obj:`~.CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC`.
    When this flag is specified, any subsequent work pushed in any of the
    specified streams will only wait for the kernel launched on the GPU
    corresponding to that stream to complete before it begins execution.

    Calling :py:obj:`~.cuLaunchCooperativeKernelMultiDevice()` sets
    persistent function state that is the same as function state set
    through :py:obj:`~.cuLaunchKernel` API when called individually for
    each element in `launchParamsList`.

    When kernels are launched via
    :py:obj:`~.cuLaunchCooperativeKernelMultiDevice()`, the previous block
    shape, shared size and parameter info associated with each
    :py:obj:`~.CUDA_LAUNCH_PARAMS.function` in `launchParamsList` is
    overwritten.

    Note that to use :py:obj:`~.cuLaunchCooperativeKernelMultiDevice()`,
    the kernels must either have been compiled with toolchain version 3.2
    or later so that it will contain kernel parameter information, or have
    no kernel parameters. If either of these conditions is not met, then
    :py:obj:`~.cuLaunchCooperativeKernelMultiDevice()` will return
    :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`.

    Parameters
    ----------
    launchParamsList : List[:py:obj:`~.CUDA_LAUNCH_PARAMS`]
        List of launch parameters, one per device
    numDevices : unsigned int
        Size of the `launchParamsList` array
    flags : unsigned int
        Flags to control launch behavior

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_IMAGE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`

    See Also
    --------
    :py:obj:`~.cuCtxGetCacheConfig`, :py:obj:`~.cuCtxSetCacheConfig`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuLaunchCooperativeKernel`, :py:obj:`~.cudaLaunchCooperativeKernelMultiDevice`
    """
    launchParamsList = [] if launchParamsList is None else launchParamsList
    if not all(isinstance(_x, (CUDA_LAUNCH_PARAMS)) for _x in launchParamsList):
        raise TypeError("Argument 'launchParamsList' is not instance of type (expected List[ccuda.CUDA_LAUNCH_PARAMS]")

    cdef ccuda.CUDA_LAUNCH_PARAMS* claunchParamsList = NULL
    if len(launchParamsList) > 0:
        claunchParamsList = <ccuda.CUDA_LAUNCH_PARAMS*> calloc(len(launchParamsList), sizeof(ccuda.CUDA_LAUNCH_PARAMS))
        if claunchParamsList is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(launchParamsList)) + 'x' + str(sizeof(ccuda.CUDA_LAUNCH_PARAMS)))
        for idx in range(len(launchParamsList)):
            memcpy(&claunchParamsList[idx], (<CUDA_LAUNCH_PARAMS>launchParamsList[idx])._ptr, sizeof(ccuda.CUDA_LAUNCH_PARAMS))

    if numDevices > len(launchParamsList): raise RuntimeError("List is too small: " + str(len(launchParamsList)) + " < " + str(numDevices))
    err = ccuda.cuLaunchCooperativeKernelMultiDevice((<CUDA_LAUNCH_PARAMS>launchParamsList[0])._ptr if len(launchParamsList) == 1 else claunchParamsList, numDevices, flags)
    if claunchParamsList is not NULL:
        free(claunchParamsList)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuLaunchHostFunc(hStream, fn, userData):
    """ Enqueues a host function call in a stream.

    Enqueues a host function to run in a stream. The function will be
    called after currently enqueued work and will block work added after
    it.

    The host function must not make any CUDA API calls. Attempting to use a
    CUDA API may result in :py:obj:`~.CUDA_ERROR_NOT_PERMITTED`, but this
    is not required. The host function must not perform any synchronization
    that may depend on outstanding CUDA work not mandated to run earlier.
    Host functions without a mandated order (such as in independent
    streams) execute in undefined order and may be serialized.

    For the purposes of Unified Memory, execution makes a number of
    guarantees:

    - The stream is considered idle for the duration of the function's
      execution. Thus, for example, the function may always use memory
      attached to the stream it was enqueued in.

    - The start of execution of the function has the same effect as
      synchronizing an event recorded in the same stream immediately prior
      to the function. It thus synchronizes streams which have been
      "joined" prior to the function.

    - Adding device work to any stream does not have the effect of making
      the stream active until all preceding host functions and stream
      callbacks have executed. Thus, for example, a function might use
      global attached memory even if work has been added to another stream,
      if the work has been ordered behind the function call with an event.

    - Completion of the function does not cause a stream to become active
      except as described above. The stream will remain idle if no device
      work follows the function, and will remain idle across consecutive
      host functions or stream callbacks without device work in between.
      Thus, for example, stream synchronization can be done by signaling
      from a host function at the end of the stream.

    Note that, in contrast to :py:obj:`~.cuStreamAddCallback`, the function
    will not be called in the event of an error in the CUDA context.

    Parameters
    ----------
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream to enqueue function call in
    fn : :py:obj:`~.CUhostFn`
        The function to call once preceding stream operations are complete
    userData : Any
        User-specified data to be passed to the function

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`

    See Also
    --------
    :py:obj:`~.cuStreamCreate`, :py:obj:`~.cuStreamQuery`, :py:obj:`~.cuStreamSynchronize`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuStreamDestroy`, :py:obj:`~.cuMemAllocManaged`, :py:obj:`~.cuStreamAttachMemAsync`, :py:obj:`~.cuStreamAddCallback`
    """
    cdef ccuda.CUhostFn cfn
    if fn is None:
        cfn = <ccuda.CUhostFn><void_ptr>0
    elif isinstance(fn, (CUhostFn)):
        pfn = int(fn)
        cfn = <ccuda.CUhostFn><void_ptr>pfn
    else:
        pfn = int(CUhostFn(fn))
        cfn = <ccuda.CUhostFn><void_ptr>pfn

    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cuserData = utils.HelperInputVoidPtr(userData)
    cdef void* cuserData_ptr = <void*><void_ptr>cuserData.cptr
    err = ccuda.cuLaunchHostFunc(chStream, cfn, cuserData_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuFuncSetBlockShape(hfunc, int x, int y, int z):
    """ Sets the block-dimensions for the function.

    [Deprecated]

    Specifies the `x`, `y`, and `z` dimensions of the thread blocks that
    are created when the kernel given by `hfunc` is launched.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Kernel to specify dimensions of
    x : int
        X dimension
    y : int
        Y dimension
    z : int
        Z dimension

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """
    cdef ccuda.CUfunction chfunc
    if hfunc is None:
        chfunc = <ccuda.CUfunction><void_ptr>0
    elif isinstance(hfunc, (CUfunction)):
        phfunc = int(hfunc)
        chfunc = <ccuda.CUfunction><void_ptr>phfunc
    else:
        phfunc = int(CUfunction(hfunc))
        chfunc = <ccuda.CUfunction><void_ptr>phfunc

    err = ccuda.cuFuncSetBlockShape(chfunc, x, y, z)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuFuncSetSharedSize(hfunc, unsigned int numbytes):
    """ Sets the dynamic shared-memory size for the function.

    [Deprecated]

    Sets through `numbytes` the amount of dynamic shared memory that will
    be available to each thread block when the kernel given by `hfunc` is
    launched.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Kernel to specify dynamic shared-memory size for
    numbytes : unsigned int
        Dynamic shared-memory size per thread in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetCacheConfig`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """
    cdef ccuda.CUfunction chfunc
    if hfunc is None:
        chfunc = <ccuda.CUfunction><void_ptr>0
    elif isinstance(hfunc, (CUfunction)):
        phfunc = int(hfunc)
        chfunc = <ccuda.CUfunction><void_ptr>phfunc
    else:
        phfunc = int(CUfunction(hfunc))
        chfunc = <ccuda.CUfunction><void_ptr>phfunc

    err = ccuda.cuFuncSetSharedSize(chfunc, numbytes)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuParamSetSize(hfunc, unsigned int numbytes):
    """ Sets the parameter size for the function.

    [Deprecated]

    Sets through `numbytes` the total size in bytes needed by the function
    parameters of the kernel corresponding to `hfunc`.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Kernel to set parameter size for
    numbytes : unsigned int
        Size of parameter list in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """
    cdef ccuda.CUfunction chfunc
    if hfunc is None:
        chfunc = <ccuda.CUfunction><void_ptr>0
    elif isinstance(hfunc, (CUfunction)):
        phfunc = int(hfunc)
        chfunc = <ccuda.CUfunction><void_ptr>phfunc
    else:
        phfunc = int(CUfunction(hfunc))
        chfunc = <ccuda.CUfunction><void_ptr>phfunc

    err = ccuda.cuParamSetSize(chfunc, numbytes)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuParamSeti(hfunc, int offset, unsigned int value):
    """ Adds an integer parameter to the function's argument list.

    [Deprecated]

    Sets an integer parameter that will be specified the next time the
    kernel corresponding to `hfunc` will be invoked. `offset` is a byte
    offset.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Kernel to add parameter to
    offset : int
        Offset to add parameter to argument list
    value : unsigned int
        Value of parameter

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """
    cdef ccuda.CUfunction chfunc
    if hfunc is None:
        chfunc = <ccuda.CUfunction><void_ptr>0
    elif isinstance(hfunc, (CUfunction)):
        phfunc = int(hfunc)
        chfunc = <ccuda.CUfunction><void_ptr>phfunc
    else:
        phfunc = int(CUfunction(hfunc))
        chfunc = <ccuda.CUfunction><void_ptr>phfunc

    err = ccuda.cuParamSeti(chfunc, offset, value)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuParamSetf(hfunc, int offset, float value):
    """ Adds a floating-point parameter to the function's argument list.

    [Deprecated]

    Sets a floating-point parameter that will be specified the next time
    the kernel corresponding to `hfunc` will be invoked. `offset` is a byte
    offset.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Kernel to add parameter to
    offset : int
        Offset to add parameter to argument list
    value : float
        Value of parameter

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """
    cdef ccuda.CUfunction chfunc
    if hfunc is None:
        chfunc = <ccuda.CUfunction><void_ptr>0
    elif isinstance(hfunc, (CUfunction)):
        phfunc = int(hfunc)
        chfunc = <ccuda.CUfunction><void_ptr>phfunc
    else:
        phfunc = int(CUfunction(hfunc))
        chfunc = <ccuda.CUfunction><void_ptr>phfunc

    err = ccuda.cuParamSetf(chfunc, offset, value)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuParamSetv(hfunc, int offset, ptr, unsigned int numbytes):
    """ Adds arbitrary data to the function's argument list.

    [Deprecated]

    Copies an arbitrary amount of data (specified in `numbytes`) from `ptr`
    into the parameter space of the kernel corresponding to `hfunc`.
    `offset` is a byte offset.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Kernel to add data to
    offset : int
        Offset to add data to argument list
    ptr : Any
        Pointer to arbitrary data
    numbytes : unsigned int
        Size of data to copy in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """
    cdef ccuda.CUfunction chfunc
    if hfunc is None:
        chfunc = <ccuda.CUfunction><void_ptr>0
    elif isinstance(hfunc, (CUfunction)):
        phfunc = int(hfunc)
        chfunc = <ccuda.CUfunction><void_ptr>phfunc
    else:
        phfunc = int(CUfunction(hfunc))
        chfunc = <ccuda.CUfunction><void_ptr>phfunc

    cptr = utils.HelperInputVoidPtr(ptr)
    cdef void* cptr_ptr = <void*><void_ptr>cptr.cptr
    err = ccuda.cuParamSetv(chfunc, offset, cptr_ptr, numbytes)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuLaunch(f):
    """ Launches a CUDA function.

    [Deprecated]

    Invokes the kernel `f` on a 1 x 1 x 1 grid of blocks. The block
    contains the number of threads specified by a previous call to
    :py:obj:`~.cuFuncSetBlockShape()`.

    The block shape, dynamic shared memory size, and parameter information
    must be set using :py:obj:`~.cuFuncSetBlockShape()`,
    :py:obj:`~.cuFuncSetSharedSize()`, :py:obj:`~.cuParamSetSize()`,
    :py:obj:`~.cuParamSeti()`, :py:obj:`~.cuParamSetf()`, and
    :py:obj:`~.cuParamSetv()` prior to calling this function.

    Launching a function via :py:obj:`~.cuLaunchKernel()` invalidates the
    function's block shape, dynamic shared memory size, and parameter
    information. After launching via cuLaunchKernel, this state must be re-
    initialized prior to calling this function. Failure to do so results in
    undefined behavior.

    Parameters
    ----------
    f : :py:obj:`~.CUfunction`
        Kernel to launch

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`

    See Also
    --------
    :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """
    cdef ccuda.CUfunction cf
    if f is None:
        cf = <ccuda.CUfunction><void_ptr>0
    elif isinstance(f, (CUfunction)):
        pf = int(f)
        cf = <ccuda.CUfunction><void_ptr>pf
    else:
        pf = int(CUfunction(f))
        cf = <ccuda.CUfunction><void_ptr>pf

    err = ccuda.cuLaunch(cf)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuLaunchGrid(f, int grid_width, int grid_height):
    """ Launches a CUDA function.

    [Deprecated]

    Invokes the kernel `f` on a `grid_width` x `grid_height` grid of
    blocks. Each block contains the number of threads specified by a
    previous call to :py:obj:`~.cuFuncSetBlockShape()`.

    The block shape, dynamic shared memory size, and parameter information
    must be set using :py:obj:`~.cuFuncSetBlockShape()`,
    :py:obj:`~.cuFuncSetSharedSize()`, :py:obj:`~.cuParamSetSize()`,
    :py:obj:`~.cuParamSeti()`, :py:obj:`~.cuParamSetf()`, and
    :py:obj:`~.cuParamSetv()` prior to calling this function.

    Launching a function via :py:obj:`~.cuLaunchKernel()` invalidates the
    function's block shape, dynamic shared memory size, and parameter
    information. After launching via cuLaunchKernel, this state must be re-
    initialized prior to calling this function. Failure to do so results in
    undefined behavior.

    Parameters
    ----------
    f : :py:obj:`~.CUfunction`
        Kernel to launch
    grid_width : int
        Width of grid in blocks
    grid_height : int
        Height of grid in blocks

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`

    See Also
    --------
    :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGridAsync`, :py:obj:`~.cuLaunchKernel`
    """
    cdef ccuda.CUfunction cf
    if f is None:
        cf = <ccuda.CUfunction><void_ptr>0
    elif isinstance(f, (CUfunction)):
        pf = int(f)
        cf = <ccuda.CUfunction><void_ptr>pf
    else:
        pf = int(CUfunction(f))
        cf = <ccuda.CUfunction><void_ptr>pf

    err = ccuda.cuLaunchGrid(cf, grid_width, grid_height)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuLaunchGridAsync(f, int grid_width, int grid_height, hStream):
    """ Launches a CUDA function.

    [Deprecated]

    Invokes the kernel `f` on a `grid_width` x `grid_height` grid of
    blocks. Each block contains the number of threads specified by a
    previous call to :py:obj:`~.cuFuncSetBlockShape()`.

    The block shape, dynamic shared memory size, and parameter information
    must be set using :py:obj:`~.cuFuncSetBlockShape()`,
    :py:obj:`~.cuFuncSetSharedSize()`, :py:obj:`~.cuParamSetSize()`,
    :py:obj:`~.cuParamSeti()`, :py:obj:`~.cuParamSetf()`, and
    :py:obj:`~.cuParamSetv()` prior to calling this function.

    Launching a function via :py:obj:`~.cuLaunchKernel()` invalidates the
    function's block shape, dynamic shared memory size, and parameter
    information. After launching via cuLaunchKernel, this state must be re-
    initialized prior to calling this function. Failure to do so results in
    undefined behavior.

    \note_null_stream

    Parameters
    ----------
    f : :py:obj:`~.CUfunction`
        Kernel to launch
    grid_width : int
        Width of grid in blocks
    grid_height : int
        Height of grid in blocks
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream identifier

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_LAUNCH_FAILED`, :py:obj:`~.CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`, :py:obj:`~.CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING`, :py:obj:`~.CUDA_ERROR_SHARED_OBJECT_INIT_FAILED`

    See Also
    --------
    :py:obj:`~.cuFuncSetBlockShape`, :py:obj:`~.cuFuncSetSharedSize`, :py:obj:`~.cuFuncGetAttribute`, :py:obj:`~.cuParamSetSize`, :py:obj:`~.cuParamSetf`, :py:obj:`~.cuParamSeti`, :py:obj:`~.cuParamSetv`, :py:obj:`~.cuLaunch`, :py:obj:`~.cuLaunchGrid`, :py:obj:`~.cuLaunchKernel`

    Notes
    -----
    In certain cases where cubins are created with no ABI (i.e., using `ptxas` `None` `no`), this function may serialize kernel launches. The CUDA driver retains asynchronous behavior by growing the per-thread stack as needed per launch and not shrinking it afterwards.
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUfunction cf
    if f is None:
        cf = <ccuda.CUfunction><void_ptr>0
    elif isinstance(f, (CUfunction)):
        pf = int(f)
        cf = <ccuda.CUfunction><void_ptr>pf
    else:
        pf = int(CUfunction(f))
        cf = <ccuda.CUfunction><void_ptr>pf

    err = ccuda.cuLaunchGridAsync(cf, grid_width, grid_height, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuParamSetTexRef(hfunc, int texunit, hTexRef):
    """ Adds a texture-reference to the function's argument list.

    [Deprecated]

    Makes the CUDA array or linear memory bound to the texture reference
    `hTexRef` available to a device program as a texture. In this version
    of CUDA, the texture-reference must be obtained via
    :py:obj:`~.cuModuleGetTexRef()` and the `texunit` parameter must be set
    to :py:obj:`~.CU_PARAM_TR_DEFAULT`.

    Parameters
    ----------
    hfunc : :py:obj:`~.CUfunction`
        Kernel to add texture-reference to
    texunit : int
        Texture unit (must be :py:obj:`~.CU_PARAM_TR_DEFAULT`)
    hTexRef : :py:obj:`~.CUtexref`
        Texture-reference to add to argument list

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef ccuda.CUfunction chfunc
    if hfunc is None:
        chfunc = <ccuda.CUfunction><void_ptr>0
    elif isinstance(hfunc, (CUfunction)):
        phfunc = int(hfunc)
        chfunc = <ccuda.CUfunction><void_ptr>phfunc
    else:
        phfunc = int(CUfunction(hfunc))
        chfunc = <ccuda.CUfunction><void_ptr>phfunc

    err = ccuda.cuParamSetTexRef(chfunc, texunit, chTexRef)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphCreate(unsigned int flags):
    """ Creates a graph.

    Creates an empty graph, which is returned via `phGraph`.

    Parameters
    ----------
    flags : unsigned int
        Graph creation flags, must be 0

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    phGraph : :py:obj:`~.CUgraph`
        Returns newly created graph

    See Also
    --------
    :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`, :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphDestroy`, :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphClone`
    """
    cdef CUgraph phGraph = CUgraph()
    err = ccuda.cuGraphCreate(phGraph._ptr, flags)
    return (CUresult(err), phGraph)

@cython.embedsignature(True)
def cuGraphAddKernelNode(hGraph, dependencies : List[CUgraphNode], size_t numDependencies, nodeParams : CUDA_KERNEL_NODE_PARAMS):
    """ Creates a kernel execution node and adds it to a graph.

    Creates a new kernel execution node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and
    arguments specified in `nodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `dependencies` may not have any duplicate entries. A
    handle to the new node will be returned in `phGraphNode`.

    The CUDA_KERNEL_NODE_PARAMS structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    When the graph is launched, the node will invoke kernel `func` on a
    (`gridDimX` x `gridDimY` x `gridDimZ`) grid of blocks. Each block
    contains (`blockDimX` x `blockDimY` x `blockDimZ`) threads.

    `sharedMemBytes` sets the amount of dynamic shared memory that will be
    available to each thread block.

    Kernel parameters to `func` can be specified in one of two ways:

    1) Kernel parameters can be specified via `kernelParams`. If the kernel
    has N parameters, then `kernelParams` needs to be an array of N
    pointers. Each pointer, from `kernelParams`[0] to `kernelParams`[N-1],
    points to the region of memory from which the actual parameter will be
    copied. The number of kernel parameters and their offsets and sizes do
    not need to be specified as that information is retrieved directly from
    the kernel's image.

    2) Kernel parameters for non-cooperative kernels can also be packaged
    by the application into a single buffer that is passed in via `extra`.
    This places the burden on the application of knowing each kernel
    parameter's size and alignment/padding within the buffer. The `extra`
    parameter exists to allow this function to take additional less
    commonly used arguments. `extra` specifies a list of names of extra
    settings and their corresponding values. Each extra setting name is
    immediately followed by the corresponding value. The list must be
    terminated with either NULL or CU_LAUNCH_PARAM_END.

    - :py:obj:`~.CU_LAUNCH_PARAM_END`, which indicates the end of the
      `extra` array;

    - :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER`, which specifies that the
      next value in `extra` will be a pointer to a buffer containing all
      the kernel parameters for launching kernel `func`;

    - :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_SIZE`, which specifies that the
      next value in `extra` will be a pointer to a size_t containing the
      size of the buffer specified with
      :py:obj:`~.CU_LAUNCH_PARAM_BUFFER_POINTER`;

    The error :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned if
    kernel parameters are specified with both `kernelParams` and `extra`
    (i.e. both `kernelParams` and `extra` are non-NULL).
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` will be returned if `extra` is
    used for a cooperative kernel.

    The `kernelParams` or `extra` array, as well as the argument values it
    points to, are copied during this call.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : List[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    nodeParams : :py:obj:`~.CUDA_KERNEL_NODE_PARAMS`
        Parameters for the GPU execution node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuLaunchCooperativeKernel`, :py:obj:`~.cuGraphKernelNodeGetParams`, :py:obj:`~.cuGraphKernelNodeSetParams`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`

    Notes
    -----
    Kernels launched using graphs must not use texture and surface references. Reading or writing through any texture or surface reference is undefined behavior. This restriction does not apply to texture and surface objects.
    """
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[ccuda.CUgraphNode]")

    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef ccuda.CUDA_KERNEL_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphAddKernelNode(phGraphNode._ptr, chGraph, (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, cnodeParams_ptr)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphKernelNodeGetParams(hNode):
    """ Returns a kernel node's parameters.

    Returns the parameters of kernel node `hNode` in `nodeParams`. The
    `kernelParams` or `extra` array returned in `nodeParams`, as well as
    the argument values it points to, are owned by the node. This memory
    remains valid until the node is destroyed or its parameters are
    modified, and should not be modified directly. Use
    :py:obj:`~.cuGraphKernelNodeSetParams` to update the parameters of this
    node.

    The params will contain either `kernelParams` or `extra`, according to
    which of these was most recently set on the node.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    nodeParams : :py:obj:`~.CUDA_KERNEL_NODE_PARAMS`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphKernelNodeSetParams`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef CUDA_KERNEL_NODE_PARAMS nodeParams = CUDA_KERNEL_NODE_PARAMS()
    err = ccuda.cuGraphKernelNodeGetParams(chNode, nodeParams._ptr)
    return (CUresult(err), nodeParams)

@cython.embedsignature(True)
def cuGraphKernelNodeSetParams(hNode, nodeParams : CUDA_KERNEL_NODE_PARAMS):
    """ Sets a kernel node's parameters.

    Sets the parameters of kernel node `hNode` to `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.CUDA_KERNEL_NODE_PARAMS`
        Parameters to copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

    See Also
    --------
    :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphKernelNodeGetParams`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUDA_KERNEL_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphKernelNodeSetParams(chNode, cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphAddMemcpyNode(hGraph, dependencies : List[CUgraphNode], size_t numDependencies, copyParams : CUDA_MEMCPY3D, ctx):
    """ Creates a memcpy node and adds it to a graph.

    Creates a new memcpy node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies`. It is
    possible for `numDependencies` to be 0, in which case the node will be
    placed at the root of the graph. `dependencies` may not have any
    duplicate entries. A handle to the new node will be returned in
    `phGraphNode`.

    When the graph is launched, the node will perform the memcpy described
    by `copyParams`. See :py:obj:`~.cuMemcpy3D()` for a description of the
    structure and its restrictions.

    Memcpy nodes have some additional restrictions with regards to managed
    memory, if the system contains at least one device which has a zero
    value for the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS`. If one or
    more of the operands refer to managed memory, then using the memory
    type :py:obj:`~.CU_MEMORYTYPE_UNIFIED` is disallowed for those
    operand(s). The managed memory will be treated as residing on either
    the host or the device, depending on which memory type is specified.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : List[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    copyParams : :py:obj:`~.CUDA_MEMCPY3D`
        Parameters for the memory copy
    ctx : :py:obj:`~.CUcontext`
        Context on which to run the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuGraphMemcpyNodeGetParams`, :py:obj:`~.cuGraphMemcpyNodeSetParams`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """
    cdef ccuda.CUcontext cctx
    if ctx is None:
        cctx = <ccuda.CUcontext><void_ptr>0
    elif isinstance(ctx, (CUcontext)):
        pctx = int(ctx)
        cctx = <ccuda.CUcontext><void_ptr>pctx
    else:
        pctx = int(CUcontext(ctx))
        cctx = <ccuda.CUcontext><void_ptr>pctx

    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[ccuda.CUgraphNode]")

    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef ccuda.CUDA_MEMCPY3D* ccopyParams_ptr = copyParams._ptr if copyParams != None else NULL
    err = ccuda.cuGraphAddMemcpyNode(phGraphNode._ptr, chGraph, (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, ccopyParams_ptr, cctx)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphMemcpyNodeGetParams(hNode):
    """ Returns a memcpy node's parameters.

    Returns the parameters of memcpy node `hNode` in `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    nodeParams : :py:obj:`~.CUDA_MEMCPY3D`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphMemcpyNodeSetParams`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef CUDA_MEMCPY3D nodeParams = CUDA_MEMCPY3D()
    err = ccuda.cuGraphMemcpyNodeGetParams(chNode, nodeParams._ptr)
    return (CUresult(err), nodeParams)

@cython.embedsignature(True)
def cuGraphMemcpyNodeSetParams(hNode, nodeParams : CUDA_MEMCPY3D):
    """ Sets a memcpy node's parameters.

    Sets the parameters of memcpy node `hNode` to `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.CUDA_MEMCPY3D`
        Parameters to copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuMemcpy3D`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphMemcpyNodeGetParams`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUDA_MEMCPY3D* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphMemcpyNodeSetParams(chNode, cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphAddMemsetNode(hGraph, dependencies : List[CUgraphNode], size_t numDependencies, memsetParams : CUDA_MEMSET_NODE_PARAMS, ctx):
    """ Creates a memset node and adds it to a graph.

    Creates a new memset node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies`. It is
    possible for `numDependencies` to be 0, in which case the node will be
    placed at the root of the graph. `dependencies` may not have any
    duplicate entries. A handle to the new node will be returned in
    `phGraphNode`.

    The element size must be 1, 2, or 4 bytes. When the graph is launched,
    the node will perform the memset described by `memsetParams`.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : List[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    memsetParams : :py:obj:`~.CUDA_MEMSET_NODE_PARAMS`
        Parameters for the memory set
    ctx : :py:obj:`~.CUcontext`
        Context on which to run the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuGraphMemsetNodeGetParams`, :py:obj:`~.cuGraphMemsetNodeSetParams`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`
    """
    cdef ccuda.CUcontext cctx
    if ctx is None:
        cctx = <ccuda.CUcontext><void_ptr>0
    elif isinstance(ctx, (CUcontext)):
        pctx = int(ctx)
        cctx = <ccuda.CUcontext><void_ptr>pctx
    else:
        pctx = int(CUcontext(ctx))
        cctx = <ccuda.CUcontext><void_ptr>pctx

    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[ccuda.CUgraphNode]")

    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef ccuda.CUDA_MEMSET_NODE_PARAMS* cmemsetParams_ptr = memsetParams._ptr if memsetParams != None else NULL
    err = ccuda.cuGraphAddMemsetNode(phGraphNode._ptr, chGraph, (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, cmemsetParams_ptr, cctx)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphMemsetNodeGetParams(hNode):
    """ Returns a memset node's parameters.

    Returns the parameters of memset node `hNode` in `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    nodeParams : :py:obj:`~.CUDA_MEMSET_NODE_PARAMS`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuGraphAddMemsetNode`, :py:obj:`~.cuGraphMemsetNodeSetParams`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef CUDA_MEMSET_NODE_PARAMS nodeParams = CUDA_MEMSET_NODE_PARAMS()
    err = ccuda.cuGraphMemsetNodeGetParams(chNode, nodeParams._ptr)
    return (CUresult(err), nodeParams)

@cython.embedsignature(True)
def cuGraphMemsetNodeSetParams(hNode, nodeParams : CUDA_MEMSET_NODE_PARAMS):
    """ Sets a memset node's parameters.

    Sets the parameters of memset node `hNode` to `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.CUDA_MEMSET_NODE_PARAMS`
        Parameters to copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuMemsetD2D32`, :py:obj:`~.cuGraphAddMemsetNode`, :py:obj:`~.cuGraphMemsetNodeGetParams`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUDA_MEMSET_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphMemsetNodeSetParams(chNode, cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphAddHostNode(hGraph, dependencies : List[CUgraphNode], size_t numDependencies, nodeParams : CUDA_HOST_NODE_PARAMS):
    """ Creates a host execution node and adds it to a graph.

    Creates a new CPU execution node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and
    arguments specified in `nodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `dependencies` may not have any duplicate entries. A
    handle to the new node will be returned in `phGraphNode`.

    When the graph is launched, the node will invoke the specified CPU
    function. Host nodes are not supported under MPS with pre-Volta GPUs.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : List[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    nodeParams : :py:obj:`~.CUDA_HOST_NODE_PARAMS`
        Parameters for the host node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuLaunchHostFunc`, :py:obj:`~.cuGraphHostNodeGetParams`, :py:obj:`~.cuGraphHostNodeSetParams`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[ccuda.CUgraphNode]")

    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef ccuda.CUDA_HOST_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphAddHostNode(phGraphNode._ptr, chGraph, (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, cnodeParams_ptr)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphHostNodeGetParams(hNode):
    """ Returns a host node's parameters.

    Returns the parameters of host node `hNode` in `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    nodeParams : :py:obj:`~.CUDA_HOST_NODE_PARAMS`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cuLaunchHostFunc`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphHostNodeSetParams`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef CUDA_HOST_NODE_PARAMS nodeParams = CUDA_HOST_NODE_PARAMS()
    err = ccuda.cuGraphHostNodeGetParams(chNode, nodeParams._ptr)
    return (CUresult(err), nodeParams)

@cython.embedsignature(True)
def cuGraphHostNodeSetParams(hNode, nodeParams : CUDA_HOST_NODE_PARAMS):
    """ Sets a host node's parameters.

    Sets the parameters of host node `hNode` to `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.CUDA_HOST_NODE_PARAMS`
        Parameters to copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuLaunchHostFunc`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphHostNodeGetParams`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUDA_HOST_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphHostNodeSetParams(chNode, cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphAddChildGraphNode(hGraph, dependencies : List[CUgraphNode], size_t numDependencies, childGraph):
    """ Creates a child graph node and adds it to a graph.

    Creates a new node which executes an embedded graph, and adds it to
    `hGraph` with `numDependencies` dependencies specified via
    `dependencies`. It is possible for `numDependencies` to be 0, in which
    case the node will be placed at the root of the graph. `dependencies`
    may not have any duplicate entries. A handle to the new node will be
    returned in `phGraphNode`.

    If `hGraph` contains allocation or free nodes, this call will return an
    error.

    The node executes an embedded child graph. The child graph is cloned in
    this call.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : List[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    childGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph to clone into this node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphChildGraphNodeGetGraph`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`, :py:obj:`~.cuGraphClone`
    """
    cdef ccuda.CUgraph cchildGraph
    if childGraph is None:
        cchildGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(childGraph, (CUgraph)):
        pchildGraph = int(childGraph)
        cchildGraph = <ccuda.CUgraph><void_ptr>pchildGraph
    else:
        pchildGraph = int(CUgraph(childGraph))
        cchildGraph = <ccuda.CUgraph><void_ptr>pchildGraph

    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[ccuda.CUgraphNode]")

    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    err = ccuda.cuGraphAddChildGraphNode(phGraphNode._ptr, chGraph, (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, cchildGraph)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphChildGraphNodeGetGraph(hNode):
    """ Gets a handle to the embedded graph of a child graph node.

    Gets a handle to the embedded graph in a child graph node. This call
    does not clone the graph. Changes to the graph will be reflected in the
    node, and the node retains ownership of the graph.

    Allocation and free nodes cannot be added to the returned graph.
    Attempting to do so will return an error.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the embedded graph for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    phGraph : :py:obj:`~.CUgraph`
        Location to store a handle to the graph

    See Also
    --------
    :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphNodeFindInClone`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef CUgraph phGraph = CUgraph()
    err = ccuda.cuGraphChildGraphNodeGetGraph(chNode, phGraph._ptr)
    return (CUresult(err), phGraph)

@cython.embedsignature(True)
def cuGraphAddEmptyNode(hGraph, dependencies : List[CUgraphNode], size_t numDependencies):
    """ Creates an empty node and adds it to a graph.

    Creates a new node which performs no operation, and adds it to `hGraph`
    with `numDependencies` dependencies specified via `dependencies`. It is
    possible for `numDependencies` to be 0, in which case the node will be
    placed at the root of the graph. `dependencies` may not have any
    duplicate entries. A handle to the new node will be returned in
    `phGraphNode`.

    An empty node performs no operation during execution, but can be used
    for transitive ordering. For example, a phased execution graph with 2
    groups of n nodes with a barrier between them can be represented using
    an empty node and 2*n dependency edges, rather than no empty node and
    n^2 dependency edges.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : List[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[ccuda.CUgraphNode]")

    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    err = ccuda.cuGraphAddEmptyNode(phGraphNode._ptr, chGraph, (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphAddEventRecordNode(hGraph, dependencies : List[CUgraphNode], size_t numDependencies, event):
    """ Creates an event record node and adds it to a graph.

    Creates a new event record node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and event
    specified in `event`. It is possible for `numDependencies` to be 0, in
    which case the node will be placed at the root of the graph.
    `dependencies` may not have any duplicate entries. A handle to the new
    node will be returned in `phGraphNode`.

    Each launch of the graph will record `event` to capture execution of
    the node's dependencies.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : List[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event for the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`,
    """
    cdef ccuda.CUevent cevent
    if event is None:
        cevent = <ccuda.CUevent><void_ptr>0
    elif isinstance(event, (CUevent)):
        pevent = int(event)
        cevent = <ccuda.CUevent><void_ptr>pevent
    else:
        pevent = int(CUevent(event))
        cevent = <ccuda.CUevent><void_ptr>pevent

    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[ccuda.CUgraphNode]")

    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    err = ccuda.cuGraphAddEventRecordNode(phGraphNode._ptr, chGraph, (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, cevent)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphEventRecordNodeGetEvent(hNode):
    """ Returns the event associated with an event record node.

    Returns the event of event record node `hNode` in `event_out`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the event for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    event_out : :py:obj:`~.CUevent`
        Pointer to return the event

    See Also
    --------
    :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphEventRecordNodeSetEvent`, :py:obj:`~.cuGraphEventWaitNodeGetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef CUevent event_out = CUevent()
    err = ccuda.cuGraphEventRecordNodeGetEvent(chNode, event_out._ptr)
    return (CUresult(err), event_out)

@cython.embedsignature(True)
def cuGraphEventRecordNodeSetEvent(hNode, event):
    """ Sets an event record node's event.

    Sets the event of event record node `hNode` to `event`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the event for
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to use

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

    See Also
    --------
    :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphEventRecordNodeGetEvent`, :py:obj:`~.cuGraphEventWaitNodeSetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`
    """
    cdef ccuda.CUevent cevent
    if event is None:
        cevent = <ccuda.CUevent><void_ptr>0
    elif isinstance(event, (CUevent)):
        pevent = int(event)
        cevent = <ccuda.CUevent><void_ptr>pevent
    else:
        pevent = int(CUevent(event))
        cevent = <ccuda.CUevent><void_ptr>pevent

    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    err = ccuda.cuGraphEventRecordNodeSetEvent(chNode, cevent)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphAddEventWaitNode(hGraph, dependencies : List[CUgraphNode], size_t numDependencies, event):
    """ Creates an event wait node and adds it to a graph.

    Creates a new event wait node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and event
    specified in `event`. It is possible for `numDependencies` to be 0, in
    which case the node will be placed at the root of the graph.
    `dependencies` may not have any duplicate entries. A handle to the new
    node will be returned in `phGraphNode`.

    The graph node will wait for all work captured in `event`. See
    :py:obj:`~.cuEventRecord()` for details on what is captured by an
    event. `event` may be from a different context or device than the
    launch stream.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : List[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event for the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`,
    """
    cdef ccuda.CUevent cevent
    if event is None:
        cevent = <ccuda.CUevent><void_ptr>0
    elif isinstance(event, (CUevent)):
        pevent = int(event)
        cevent = <ccuda.CUevent><void_ptr>pevent
    else:
        pevent = int(CUevent(event))
        cevent = <ccuda.CUevent><void_ptr>pevent

    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[ccuda.CUgraphNode]")

    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    err = ccuda.cuGraphAddEventWaitNode(phGraphNode._ptr, chGraph, (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, cevent)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphEventWaitNodeGetEvent(hNode):
    """ Returns the event associated with an event wait node.

    Returns the event of event wait node `hNode` in `event_out`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the event for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    event_out : :py:obj:`~.CUevent`
        Pointer to return the event

    See Also
    --------
    :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphEventWaitNodeSetEvent`, :py:obj:`~.cuGraphEventRecordNodeGetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef CUevent event_out = CUevent()
    err = ccuda.cuGraphEventWaitNodeGetEvent(chNode, event_out._ptr)
    return (CUresult(err), event_out)

@cython.embedsignature(True)
def cuGraphEventWaitNodeSetEvent(hNode, event):
    """ Sets an event wait node's event.

    Sets the event of event wait node `hNode` to `event`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the event for
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Event to use

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

    See Also
    --------
    :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphEventWaitNodeGetEvent`, :py:obj:`~.cuGraphEventRecordNodeSetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`
    """
    cdef ccuda.CUevent cevent
    if event is None:
        cevent = <ccuda.CUevent><void_ptr>0
    elif isinstance(event, (CUevent)):
        pevent = int(event)
        cevent = <ccuda.CUevent><void_ptr>pevent
    else:
        pevent = int(CUevent(event))
        cevent = <ccuda.CUevent><void_ptr>pevent

    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    err = ccuda.cuGraphEventWaitNodeSetEvent(chNode, cevent)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphAddExternalSemaphoresSignalNode(hGraph, dependencies : List[CUgraphNode], size_t numDependencies, nodeParams : CUDA_EXT_SEM_SIGNAL_NODE_PARAMS):
    """ Creates an external semaphore signal node and adds it to a graph.

    Creates a new external semaphore signal node and adds it to `hGraph`
    with `numDependencies` dependencies specified via `dependencies` and
    arguments specified in `nodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `dependencies` may not have any duplicate entries. A
    handle to the new node will be returned in `phGraphNode`.

    Performs a signal operation on a set of externally allocated semaphore
    objects when the node is launched. The operation(s) will occur after
    all of the node's dependencies have completed.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : List[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    nodeParams : :py:obj:`~.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS`
        Parameters for the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphExternalSemaphoresSignalNodeGetParams`, :py:obj:`~.cuGraphExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`,
    """
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[ccuda.CUgraphNode]")

    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef ccuda.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphAddExternalSemaphoresSignalNode(phGraphNode._ptr, chGraph, (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, cnodeParams_ptr)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphExternalSemaphoresSignalNodeGetParams(hNode):
    """ Returns an external semaphore signal node's parameters.

    Returns the parameters of an external semaphore signal node `hNode` in
    `params_out`. The `extSemArray` and `paramsArray` returned in
    `params_out`, are owned by the node. This memory remains valid until
    the node is destroyed or its parameters are modified, and should not be
    modified directly. Use
    :py:obj:`~.cuGraphExternalSemaphoresSignalNodeSetParams` to update the
    parameters of this node.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    params_out : :py:obj:`~.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuGraphExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef CUDA_EXT_SEM_SIGNAL_NODE_PARAMS params_out = CUDA_EXT_SEM_SIGNAL_NODE_PARAMS()
    err = ccuda.cuGraphExternalSemaphoresSignalNodeGetParams(chNode, params_out._ptr)
    return (CUresult(err), params_out)

@cython.embedsignature(True)
def cuGraphExternalSemaphoresSignalNodeSetParams(hNode, nodeParams : CUDA_EXT_SEM_SIGNAL_NODE_PARAMS):
    """ Sets an external semaphore signal node's parameters.

    Sets the parameters of an external semaphore signal node `hNode` to
    `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS`
        Parameters to copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

    See Also
    --------
    :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuGraphExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphExternalSemaphoresSignalNodeSetParams(chNode, cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphAddExternalSemaphoresWaitNode(hGraph, dependencies : List[CUgraphNode], size_t numDependencies, nodeParams : CUDA_EXT_SEM_WAIT_NODE_PARAMS):
    """ Creates an external semaphore wait node and adds it to a graph.

    Creates a new external semaphore wait node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and
    arguments specified in `nodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `dependencies` may not have any duplicate entries. A
    handle to the new node will be returned in `phGraphNode`.

    Performs a wait operation on a set of externally allocated semaphore
    objects when the node is launched. The node's dependencies will not be
    launched until the wait operation has completed.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : List[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    nodeParams : :py:obj:`~.CUDA_EXT_SEM_WAIT_NODE_PARAMS`
        Parameters for the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphExternalSemaphoresWaitNodeGetParams`, :py:obj:`~.cuGraphExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`,
    """
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[ccuda.CUgraphNode]")

    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef ccuda.CUDA_EXT_SEM_WAIT_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphAddExternalSemaphoresWaitNode(phGraphNode._ptr, chGraph, (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, cnodeParams_ptr)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphExternalSemaphoresWaitNodeGetParams(hNode):
    """ Returns an external semaphore wait node's parameters.

    Returns the parameters of an external semaphore wait node `hNode` in
    `params_out`. The `extSemArray` and `paramsArray` returned in
    `params_out`, are owned by the node. This memory remains valid until
    the node is destroyed or its parameters are modified, and should not be
    modified directly. Use
    :py:obj:`~.cuGraphExternalSemaphoresSignalNodeSetParams` to update the
    parameters of this node.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    params_out : :py:obj:`~.CUDA_EXT_SEM_WAIT_NODE_PARAMS`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cuLaunchKernel`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuGraphExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef CUDA_EXT_SEM_WAIT_NODE_PARAMS params_out = CUDA_EXT_SEM_WAIT_NODE_PARAMS()
    err = ccuda.cuGraphExternalSemaphoresWaitNodeGetParams(chNode, params_out._ptr)
    return (CUresult(err), params_out)

@cython.embedsignature(True)
def cuGraphExternalSemaphoresWaitNodeSetParams(hNode, nodeParams : CUDA_EXT_SEM_WAIT_NODE_PARAMS):
    """ Sets an external semaphore wait node's parameters.

    Sets the parameters of an external semaphore wait node `hNode` to
    `nodeParams`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.CUDA_EXT_SEM_WAIT_NODE_PARAMS`
        Parameters to copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

    See Also
    --------
    :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuGraphExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUDA_EXT_SEM_WAIT_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphExternalSemaphoresWaitNodeSetParams(chNode, cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphAddBatchMemOpNode(hGraph, dependencies : List[CUgraphNode], size_t numDependencies, nodeParams : CUDA_BATCH_MEM_OP_NODE_PARAMS):
    """ Creates a batch memory operation node and adds it to a graph.

    Creates a new batch memory operation node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and
    arguments specified in `nodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `dependencies` may not have any duplicate entries. A
    handle to the new node will be returned in `phGraphNode`.

    When the node is added, the paramArray inside `nodeParams` is copied
    and therefore it can be freed after the call returns.

    These nodes may not be used in loops or conditionals.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : List[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    nodeParams : :py:obj:`~.CUDA_BATCH_MEM_OP_NODE_PARAMS`
        Parameters for the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuStreamBatchMemOp_v2`, :py:obj:`~.cuStreamWaitValue32_v2`, :py:obj:`~.cuStreamWriteValue32_v2`, :py:obj:`~.cuStreamWaitValue64_v2`, :py:obj:`~.cuStreamWriteValue64_v2`, :py:obj:`~.cuGraphBatchMemOpNodeGetParams`, :py:obj:`~.cuGraphBatchMemOpNodeSetParams`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`,

    Notes
    -----
    Warning: Improper use of this API may deadlock the application. Synchronization ordering established through this API is not visible to CUDA. CUDA tasks that are (even indirectly) ordered by this API should also have that order expressed with CUDA-visible dependencies such as events. This ensures that the scheduler does not serialize them in an improper order. For more information, see the Stream Memory Operations section in the programming guide(https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html).
    """
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[ccuda.CUgraphNode]")

    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef ccuda.CUDA_BATCH_MEM_OP_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphAddBatchMemOpNode(phGraphNode._ptr, chGraph, (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, cnodeParams_ptr)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphBatchMemOpNodeGetParams(hNode):
    """ Returns a batch mem op node's parameters.

    Returns the parameters of batch mem op node `hNode` in
    `nodeParams_out`. The `paramArray` returned in `nodeParams_out` is
    owned by the node. This memory remains valid until the node is
    destroyed or its parameters are modified, and should not be modified
    directly. Use :py:obj:`~.cuGraphBatchMemOpNodeSetParams` to update the
    parameters of this node.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    nodeParams_out : :py:obj:`~.CUDA_BATCH_MEM_OP_NODE_PARAMS`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cuStreamBatchMemOp_v2`, :py:obj:`~.cuGraphAddBatchMemOpNode`, :py:obj:`~.cuGraphBatchMemOpNodeSetParams`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef CUDA_BATCH_MEM_OP_NODE_PARAMS nodeParams_out = CUDA_BATCH_MEM_OP_NODE_PARAMS()
    err = ccuda.cuGraphBatchMemOpNodeGetParams(chNode, nodeParams_out._ptr)
    return (CUresult(err), nodeParams_out)

@cython.embedsignature(True)
def cuGraphBatchMemOpNodeSetParams(hNode, nodeParams : CUDA_BATCH_MEM_OP_NODE_PARAMS):
    """ Sets a batch mem op node's parameters.

    Sets the parameters of batch mem op node `hNode` to `nodeParams`.

    The paramArray inside `nodeParams` is copied and therefore it can be
    freed after the call returns.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to set the parameters for
    nodeParams : :py:obj:`~.CUDA_BATCH_MEM_OP_NODE_PARAMS`
        Parameters to copy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`

    See Also
    --------
    :py:obj:`~.cuStreamBatchMemOp_v2`, :py:obj:`~.cuGraphAddBatchMemOpNode`, :py:obj:`~.cuGraphBatchMemOpNodeGetParams`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUDA_BATCH_MEM_OP_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphBatchMemOpNodeSetParams(chNode, cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecBatchMemOpNodeSetParams(hGraphExec, hNode, nodeParams : CUDA_BATCH_MEM_OP_NODE_PARAMS):
    """ Sets the parameters for a batch mem op node in the given graphExec.

    Sets the parameters of a batch mem op node in an executable graph
    `hGraphExec`. The node is identified by the corresponding node `hNode`
    in the non-executable graph, from which the executable graph was
    instantiated.

    The following fields on operations may be modified on an executable
    graph:

    op.waitValue.address op.waitValue.value[64] op.waitValue.flags bits
    corresponding to wait type (i.e. CU_STREAM_WAIT_VALUE_FLUSH bit cannot
    be modified) op.writeValue.address op.writeValue.value[64]

    Other fields, such as the context, count or type of operations, and
    other types of operations such as membars, may not be modified.

    `hNode` must not have been removed from the original graph.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    The paramArray inside `nodeParams` is copied and therefore it can be
    freed after the call returns.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Batch mem op node from the graph from which graphExec was
        instantiated
    nodeParams : :py:obj:`~.CUDA_BATCH_MEM_OP_NODE_PARAMS`
        Updated Parameters to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuStreamBatchMemOp_v2`, :py:obj:`~.cuGraphAddBatchMemOpNode`, :py:obj:`~.cuGraphBatchMemOpNodeGetParams`, :py:obj:`~.cuGraphBatchMemOpNodeSetParams`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUgraphExec chGraphExec
    if hGraphExec is None:
        chGraphExec = <ccuda.CUgraphExec><void_ptr>0
    elif isinstance(hGraphExec, (CUgraphExec)):
        phGraphExec = int(hGraphExec)
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec

    cdef ccuda.CUDA_BATCH_MEM_OP_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphExecBatchMemOpNodeSetParams(chGraphExec, chNode, cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphAddMemAllocNode(hGraph, dependencies : List[CUgraphNode], size_t numDependencies, nodeParams : CUDA_MEM_ALLOC_NODE_PARAMS):
    """ Creates an allocation node and adds it to a graph.

    Creates a new allocation node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and
    arguments specified in `nodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `dependencies` may not have any duplicate entries. A
    handle to the new node will be returned in `phGraphNode`.

    When :py:obj:`~.cuGraphAddMemAllocNode` creates an allocation node, it
    returns the address of the allocation in `nodeParams.dptr`. The
    allocation's address remains fixed across instantiations and launches.

    If the allocation is freed in the same graph, by creating a free node
    using :py:obj:`~.cuGraphAddMemFreeNode`, the allocation can be accessed
    by nodes ordered after the allocation node but before the free node.
    These allocations cannot be freed outside the owning graph, and they
    can only be freed once in the owning graph.

    If the allocation is not freed in the same graph, then it can be
    accessed not only by nodes in the graph which are ordered after the
    allocation node, but also by stream operations ordered after the
    graph's execution but before the allocation is freed.

    Allocations which are not freed in the same graph can be freed by:

    - passing the allocation to :py:obj:`~.cuMemFreeAsync` or
      :py:obj:`~.cuMemFree`;

    - launching a graph with a free node for that allocation; or

    - specifying
      :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH` during
      instantiation, which makes each launch behave as though it called
      :py:obj:`~.cuMemFreeAsync` for every unfreed allocation.

    It is not possible to free an allocation in both the owning graph and
    another graph. If the allocation is freed in the same graph, a free
    node cannot be added to another graph. If the allocation is freed in
    another graph, a free node can no longer be added to the owning graph.

    The following restrictions apply to graphs which contain allocation
    and/or memory free nodes:

    - Nodes and edges of the graph cannot be deleted.

    - The graph cannot be used in a child node.

    - Only one instantiation of the graph may exist at any point in time.

    - The graph cannot be cloned.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : List[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    nodeParams : :py:obj:`~.CUDA_MEM_ALLOC_NODE_PARAMS`
        Parameters for the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphAddMemFreeNode`, :py:obj:`~.cuGraphMemAllocNodeGetParams`, :py:obj:`~.cuDeviceGraphMemTrim`, :py:obj:`~.cuDeviceGetGraphMemAttribute`, :py:obj:`~.cuDeviceSetGraphMemAttribute`, :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """
    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[ccuda.CUgraphNode]")

    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    cdef ccuda.CUDA_MEM_ALLOC_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphAddMemAllocNode(phGraphNode._ptr, chGraph, (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, cnodeParams_ptr)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphMemAllocNodeGetParams(hNode):
    """ Returns a memory alloc node's parameters.

    Returns the parameters of a memory alloc node `hNode` in `params_out`.
    The `poolProps` and `accessDescs` returned in `params_out`, are owned
    by the node. This memory remains valid until the node is destroyed. The
    returned parameters must not be modified.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    params_out : :py:obj:`~.CUDA_MEM_ALLOC_NODE_PARAMS`
        Pointer to return the parameters

    See Also
    --------
    :py:obj:`~.cuGraphAddMemAllocNode`, :py:obj:`~.cuGraphMemFreeNodeGetParams`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef CUDA_MEM_ALLOC_NODE_PARAMS params_out = CUDA_MEM_ALLOC_NODE_PARAMS()
    err = ccuda.cuGraphMemAllocNodeGetParams(chNode, params_out._ptr)
    return (CUresult(err), params_out)

@cython.embedsignature(True)
def cuGraphAddMemFreeNode(hGraph, dependencies : List[CUgraphNode], size_t numDependencies, dptr):
    """ Creates a memory free node and adds it to a graph.

    Creates a new memory free node and adds it to `hGraph` with
    `numDependencies` dependencies specified via `dependencies` and
    arguments specified in `nodeParams`. It is possible for
    `numDependencies` to be 0, in which case the node will be placed at the
    root of the graph. `dependencies` may not have any duplicate entries. A
    handle to the new node will be returned in `phGraphNode`.

    :py:obj:`~.cuGraphAddMemFreeNode` will return
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if the user attempts to free:

    - an allocation twice in the same graph.

    - an address that was not returned by an allocation node.

    - an invalid address.

    The following restrictions apply to graphs which contain allocation
    and/or memory free nodes:

    - Nodes and edges of the graph cannot be deleted.

    - The graph cannot be used in a child node.

    - Only one instantiation of the graph may exist at any point in time.

    - The graph cannot be cloned.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which to add the node
    dependencies : List[:py:obj:`~.CUgraphNode`]
        Dependencies of the node
    numDependencies : size_t
        Number of dependencies
    dptr : :py:obj:`~.CUdeviceptr`
        Address of memory to free

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphNode : :py:obj:`~.CUgraphNode`
        Returns newly created node

    See Also
    --------
    :py:obj:`~.cuGraphAddMemAllocNode`, :py:obj:`~.cuGraphMemFreeNodeGetParams`, :py:obj:`~.cuDeviceGraphMemTrim`, :py:obj:`~.cuDeviceGetGraphMemAttribute`, :py:obj:`~.cuDeviceSetGraphMemAttribute`, :py:obj:`~.cuMemAllocAsync`, :py:obj:`~.cuMemFreeAsync`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphDestroyNode`, :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """
    cdef ccuda.CUdeviceptr cdptr
    if dptr is None:
        cdptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dptr, (CUdeviceptr)):
        pdptr = int(dptr)
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr
    else:
        pdptr = int(CUdeviceptr(dptr))
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr

    dependencies = [] if dependencies is None else dependencies
    if not all(isinstance(_x, (CUgraphNode)) for _x in dependencies):
        raise TypeError("Argument 'dependencies' is not instance of type (expected List[ccuda.CUgraphNode]")

    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef CUgraphNode phGraphNode = CUgraphNode()
    cdef ccuda.CUgraphNode* cdependencies = NULL
    if len(dependencies) > 0:
        cdependencies = <ccuda.CUgraphNode*> calloc(len(dependencies), sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(dependencies)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(dependencies)):
                cdependencies[idx] = (<CUgraphNode>dependencies[idx])._ptr[0]

    if numDependencies > <size_t>len(dependencies): raise RuntimeError("List is too small: " + str(len(dependencies)) + " < " + str(numDependencies))
    err = ccuda.cuGraphAddMemFreeNode(phGraphNode._ptr, chGraph, (<CUgraphNode>dependencies[0])._ptr if len(dependencies) == 1 else cdependencies, numDependencies, cdptr)
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), phGraphNode)

@cython.embedsignature(True)
def cuGraphMemFreeNodeGetParams(hNode):
    """ Returns a memory free node's parameters.

    Returns the address of a memory free node `hNode` in `dptr_out`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to get the parameters for

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    dptr_out : :py:obj:`~.CUdeviceptr`
        Pointer to return the device address

    See Also
    --------
    :py:obj:`~.cuGraphAddMemFreeNode`, :py:obj:`~.cuGraphMemAllocNodeGetParams`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef CUdeviceptr dptr_out = CUdeviceptr()
    err = ccuda.cuGraphMemFreeNodeGetParams(chNode, dptr_out._ptr)
    return (CUresult(err), dptr_out)

@cython.embedsignature(True)
def cuDeviceGraphMemTrim(device):
    """ Free unused memory that was cached on the specified device for use with graphs back to the OS.

    Blocks which are not in use by a graph that is either currently
    executing or scheduled to execute are freed back to the operating
    system.

    Parameters
    ----------
    device : :py:obj:`~.CUdevice`
        The device for which cached memory should be freed.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`

    See Also
    --------
    :py:obj:`~.cuGraphAddMemAllocNode`, :py:obj:`~.cuGraphAddMemFreeNode`, :py:obj:`~.cuDeviceSetGraphMemAttribute`, :py:obj:`~.cuDeviceGetGraphMemAttribute`
    """
    cdef ccuda.CUdevice cdevice
    if device is None:
        cdevice = <ccuda.CUdevice>0
    elif isinstance(device, (CUdevice)):
        pdevice = int(device)
        cdevice = <ccuda.CUdevice>pdevice
    else:
        pdevice = int(CUdevice(device))
        cdevice = <ccuda.CUdevice>pdevice

    err = ccuda.cuDeviceGraphMemTrim(cdevice)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuDeviceGetGraphMemAttribute(device, attr not None : CUgraphMem_attribute):
    """ Query asynchronous allocation attributes related to graphs.

    Valid attributes are:

    - :py:obj:`~.CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT`: Amount of memory, in
      bytes, currently associated with graphs

    - :py:obj:`~.CU_GRAPH_MEM_ATTR_USED_MEM_HIGH`: High watermark of
      memory, in bytes, associated with graphs since the last time it was
      reset. High watermark can only be reset to zero.

    - :py:obj:`~.CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT`: Amount of memory,
      in bytes, currently allocated for use by the CUDA graphs asynchronous
      allocator.

    - :py:obj:`~.CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH`: High watermark of
      memory, in bytes, currently allocated for use by the CUDA graphs
      asynchronous allocator.

    Parameters
    ----------
    device : :py:obj:`~.CUdevice`
        Specifies the scope of the query
    attr : :py:obj:`~.CUgraphMem_attribute`
        attribute to get

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    value : Any
        retrieved value

    See Also
    --------
    :py:obj:`~.cuDeviceSetGraphMemAttribute`, :py:obj:`~.cuGraphAddMemAllocNode`, :py:obj:`~.cuGraphAddMemFreeNode`
    """
    cdef ccuda.CUdevice cdevice
    if device is None:
        cdevice = <ccuda.CUdevice>0
    elif isinstance(device, (CUdevice)):
        pdevice = int(device)
        cdevice = <ccuda.CUdevice>pdevice
    else:
        pdevice = int(CUdevice(device))
        cdevice = <ccuda.CUdevice>pdevice

    cdef ccuda.CUgraphMem_attribute cattr = attr.value
    cdef utils.HelperCUgraphMem_attribute cvalue = utils.HelperCUgraphMem_attribute(attr, 0, is_getter=True)
    cdef void* cvalue_ptr = <void*><void_ptr>cvalue.cptr
    err = ccuda.cuDeviceGetGraphMemAttribute(cdevice, cattr, cvalue_ptr)
    return (CUresult(err), cvalue.pyObj())

@cython.embedsignature(True)
def cuDeviceSetGraphMemAttribute(device, attr not None : CUgraphMem_attribute, value):
    """ Set asynchronous allocation attributes related to graphs.

    Valid attributes are:

    - :py:obj:`~.CU_GRAPH_MEM_ATTR_USED_MEM_HIGH`: High watermark of
      memory, in bytes, associated with graphs since the last time it was
      reset. High watermark can only be reset to zero.

    - :py:obj:`~.CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH`: High watermark of
      memory, in bytes, currently allocated for use by the CUDA graphs
      asynchronous allocator.

    Parameters
    ----------
    device : :py:obj:`~.CUdevice`
        Specifies the scope of the query
    attr : :py:obj:`~.CUgraphMem_attribute`
        attribute to get
    value : Any
        pointer to value to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`

    See Also
    --------
    :py:obj:`~.cuDeviceGetGraphMemAttribute`, :py:obj:`~.cuGraphAddMemAllocNode`, :py:obj:`~.cuGraphAddMemFreeNode`
    """
    cdef ccuda.CUdevice cdevice
    if device is None:
        cdevice = <ccuda.CUdevice>0
    elif isinstance(device, (CUdevice)):
        pdevice = int(device)
        cdevice = <ccuda.CUdevice>pdevice
    else:
        pdevice = int(CUdevice(device))
        cdevice = <ccuda.CUdevice>pdevice

    cdef ccuda.CUgraphMem_attribute cattr = attr.value
    cdef utils.HelperCUgraphMem_attribute cvalue = utils.HelperCUgraphMem_attribute(attr, value, is_getter=False)
    cdef void* cvalue_ptr = <void*><void_ptr>cvalue.cptr
    err = ccuda.cuDeviceSetGraphMemAttribute(cdevice, cattr, cvalue_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphClone(originalGraph):
    """ Clones a graph.

    This function creates a copy of `originalGraph` and returns it in
    `phGraphClone`. All parameters are copied into the cloned graph. The
    original graph may be modified after this call without affecting the
    clone.

    Child graph nodes in the original graph are recursively copied into the
    clone.

    Parameters
    ----------
    originalGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to clone

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    phGraphClone : :py:obj:`~.CUgraph`
        Returns newly created cloned graph

    See Also
    --------
    :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphNodeFindInClone`
    """
    cdef ccuda.CUgraph coriginalGraph
    if originalGraph is None:
        coriginalGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(originalGraph, (CUgraph)):
        poriginalGraph = int(originalGraph)
        coriginalGraph = <ccuda.CUgraph><void_ptr>poriginalGraph
    else:
        poriginalGraph = int(CUgraph(originalGraph))
        coriginalGraph = <ccuda.CUgraph><void_ptr>poriginalGraph

    cdef CUgraph phGraphClone = CUgraph()
    err = ccuda.cuGraphClone(phGraphClone._ptr, coriginalGraph)
    return (CUresult(err), phGraphClone)

@cython.embedsignature(True)
def cuGraphNodeFindInClone(hOriginalNode, hClonedGraph):
    """ Finds a cloned version of a node.

    This function returns the node in `hClonedGraph` corresponding to
    `hOriginalNode` in the original graph.

    `hClonedGraph` must have been cloned from `hOriginalGraph` via
    :py:obj:`~.cuGraphClone`. `hOriginalNode` must have been in
    `hOriginalGraph` at the time of the call to :py:obj:`~.cuGraphClone`,
    and the corresponding cloned node in `hClonedGraph` must not have been
    removed. The cloned node is then returned via `phClonedNode`.

    Parameters
    ----------
    hOriginalNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Handle to the original node
    hClonedGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Cloned graph to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    phNode : :py:obj:`~.CUgraphNode`
        Returns handle to the cloned node

    See Also
    --------
    :py:obj:`~.cuGraphClone`
    """
    cdef ccuda.CUgraph chClonedGraph
    if hClonedGraph is None:
        chClonedGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hClonedGraph, (CUgraph)):
        phClonedGraph = int(hClonedGraph)
        chClonedGraph = <ccuda.CUgraph><void_ptr>phClonedGraph
    else:
        phClonedGraph = int(CUgraph(hClonedGraph))
        chClonedGraph = <ccuda.CUgraph><void_ptr>phClonedGraph

    cdef ccuda.CUgraphNode chOriginalNode
    if hOriginalNode is None:
        chOriginalNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hOriginalNode, (CUgraphNode)):
        phOriginalNode = int(hOriginalNode)
        chOriginalNode = <ccuda.CUgraphNode><void_ptr>phOriginalNode
    else:
        phOriginalNode = int(CUgraphNode(hOriginalNode))
        chOriginalNode = <ccuda.CUgraphNode><void_ptr>phOriginalNode

    cdef CUgraphNode phNode = CUgraphNode()
    err = ccuda.cuGraphNodeFindInClone(phNode._ptr, chOriginalNode, chClonedGraph)
    return (CUresult(err), phNode)

@cython.embedsignature(True)
def cuGraphNodeGetType(hNode):
    """ Returns a node's type.

    Returns the node type of `hNode` in `typename`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to query

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    typename : :py:obj:`~.CUgraphNodeType`
        Pointer to return the node type

    See Also
    --------
    :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphChildGraphNodeGetGraph`, :py:obj:`~.cuGraphKernelNodeGetParams`, :py:obj:`~.cuGraphKernelNodeSetParams`, :py:obj:`~.cuGraphHostNodeGetParams`, :py:obj:`~.cuGraphHostNodeSetParams`, :py:obj:`~.cuGraphMemcpyNodeGetParams`, :py:obj:`~.cuGraphMemcpyNodeSetParams`, :py:obj:`~.cuGraphMemsetNodeGetParams`, :py:obj:`~.cuGraphMemsetNodeSetParams`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUgraphNodeType typename
    err = ccuda.cuGraphNodeGetType(chNode, &typename)
    return (CUresult(err), CUgraphNodeType(typename))

@cython.embedsignature(True)
def cuGraphGetNodes(hGraph, size_t numNodes = 0):
    """ Returns a graph's nodes.

    Returns a list of `hGraph's` nodes. `nodes` may be NULL, in which case
    this function will return the number of nodes in `numNodes`. Otherwise,
    `numNodes` entries will be filled in. If `numNodes` is higher than the
    actual number of nodes, the remaining entries in `nodes` will be set to
    NULL, and the number of nodes actually obtained will be returned in
    `numNodes`.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to query
    numNodes : int
        See description

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    nodes : List[:py:obj:`~.CUgraphNode`]
        Pointer to return the nodes
    numNodes : int
        See description

    See Also
    --------
    :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphNodeGetType`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """
    cdef size_t _graph_length = numNodes
    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef ccuda.CUgraphNode* cnodes = NULL
    pynodes = []
    if _graph_length != 0:
        cnodes = <ccuda.CUgraphNode*>calloc(_graph_length, sizeof(ccuda.CUgraphNode))
        if cnodes is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(ccuda.CUgraphNode)))
    err = ccuda.cuGraphGetNodes(chGraph, cnodes, &numNodes)
    if CUresult(err) == CUresult(0):
        pynodes = [CUgraphNode(init_value=<void_ptr>cnodes[idx]) for idx in range(_graph_length)]
    if cnodes is not NULL:
        free(cnodes)
    return (CUresult(err), pynodes, numNodes)

@cython.embedsignature(True)
def cuGraphGetRootNodes(hGraph, size_t numRootNodes = 0):
    """ Returns a graph's root nodes.

    Returns a list of `hGraph's` root nodes. `rootNodes` may be NULL, in
    which case this function will return the number of root nodes in
    `numRootNodes`. Otherwise, `numRootNodes` entries will be filled in. If
    `numRootNodes` is higher than the actual number of root nodes, the
    remaining entries in `rootNodes` will be set to NULL, and the number of
    nodes actually obtained will be returned in `numRootNodes`.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to query
    numRootNodes : int
        See description

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    rootNodes : List[:py:obj:`~.CUgraphNode`]
        Pointer to return the root nodes
    numRootNodes : int
        See description

    See Also
    --------
    :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphNodeGetType`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """
    cdef size_t _graph_length = numRootNodes
    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef ccuda.CUgraphNode* crootNodes = NULL
    pyrootNodes = []
    if _graph_length != 0:
        crootNodes = <ccuda.CUgraphNode*>calloc(_graph_length, sizeof(ccuda.CUgraphNode))
        if crootNodes is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(ccuda.CUgraphNode)))
    err = ccuda.cuGraphGetRootNodes(chGraph, crootNodes, &numRootNodes)
    if CUresult(err) == CUresult(0):
        pyrootNodes = [CUgraphNode(init_value=<void_ptr>crootNodes[idx]) for idx in range(_graph_length)]
    if crootNodes is not NULL:
        free(crootNodes)
    return (CUresult(err), pyrootNodes, numRootNodes)

@cython.embedsignature(True)
def cuGraphGetEdges(hGraph, size_t numEdges = 0):
    """ Returns a graph's dependency edges.

    Returns a list of `hGraph's` dependency edges. Edges are returned via
    corresponding indices in `from` and `to`; that is, the node in `to`[i]
    has a dependency on the node in `from`[i]. `from` and `to` may both be
    NULL, in which case this function only returns the number of edges in
    `numEdges`. Otherwise, `numEdges` entries will be filled in. If
    `numEdges` is higher than the actual number of edges, the remaining
    entries in `from` and `to` will be set to NULL, and the number of edges
    actually returned will be written to `numEdges`.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to get the edges from
    numEdges : int
        See description

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    from : List[:py:obj:`~.CUgraphNode`]
        Location to return edge endpoints
    to : List[:py:obj:`~.CUgraphNode`]
        Location to return edge endpoints
    numEdges : int
        See description

    See Also
    --------
    :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphAddDependencies`, :py:obj:`~.cuGraphRemoveDependencies`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """
    cdef size_t _graph_length = numEdges
    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef ccuda.CUgraphNode* cfrom_ = NULL
    pyfrom_ = []
    if _graph_length != 0:
        cfrom_ = <ccuda.CUgraphNode*>calloc(_graph_length, sizeof(ccuda.CUgraphNode))
        if cfrom_ is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(ccuda.CUgraphNode)))
    cdef ccuda.CUgraphNode* cto = NULL
    pyto = []
    if _graph_length != 0:
        cto = <ccuda.CUgraphNode*>calloc(_graph_length, sizeof(ccuda.CUgraphNode))
        if cto is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(ccuda.CUgraphNode)))
    err = ccuda.cuGraphGetEdges(chGraph, cfrom_, cto, &numEdges)
    if CUresult(err) == CUresult(0):
        pyfrom_ = [CUgraphNode(init_value=<void_ptr>cfrom_[idx]) for idx in range(_graph_length)]
    if cfrom_ is not NULL:
        free(cfrom_)
    if CUresult(err) == CUresult(0):
        pyto = [CUgraphNode(init_value=<void_ptr>cto[idx]) for idx in range(_graph_length)]
    if cto is not NULL:
        free(cto)
    return (CUresult(err), pyfrom_, pyto, numEdges)

@cython.embedsignature(True)
def cuGraphNodeGetDependencies(hNode, size_t numDependencies = 0):
    """ Returns a node's dependencies.

    Returns a list of `node's` dependencies. `dependencies` may be NULL, in
    which case this function will return the number of dependencies in
    `numDependencies`. Otherwise, `numDependencies` entries will be filled
    in. If `numDependencies` is higher than the actual number of
    dependencies, the remaining entries in `dependencies` will be set to
    NULL, and the number of nodes actually obtained will be returned in
    `numDependencies`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to query
    numDependencies : int
        See description

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    dependencies : List[:py:obj:`~.CUgraphNode`]
        Pointer to return the dependencies
    numDependencies : int
        See description

    See Also
    --------
    :py:obj:`~.cuGraphNodeGetDependentNodes`, :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphAddDependencies`, :py:obj:`~.cuGraphRemoveDependencies`
    """
    cdef size_t _graph_length = numDependencies
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUgraphNode* cdependencies = NULL
    pydependencies = []
    if _graph_length != 0:
        cdependencies = <ccuda.CUgraphNode*>calloc(_graph_length, sizeof(ccuda.CUgraphNode))
        if cdependencies is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(ccuda.CUgraphNode)))
    err = ccuda.cuGraphNodeGetDependencies(chNode, cdependencies, &numDependencies)
    if CUresult(err) == CUresult(0):
        pydependencies = [CUgraphNode(init_value=<void_ptr>cdependencies[idx]) for idx in range(_graph_length)]
    if cdependencies is not NULL:
        free(cdependencies)
    return (CUresult(err), pydependencies, numDependencies)

@cython.embedsignature(True)
def cuGraphNodeGetDependentNodes(hNode, size_t numDependentNodes = 0):
    """ Returns a node's dependent nodes.

    Returns a list of `node's` dependent nodes. `dependentNodes` may be
    NULL, in which case this function will return the number of dependent
    nodes in `numDependentNodes`. Otherwise, `numDependentNodes` entries
    will be filled in. If `numDependentNodes` is higher than the actual
    number of dependent nodes, the remaining entries in `dependentNodes`
    will be set to NULL, and the number of nodes actually obtained will be
    returned in `numDependentNodes`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to query
    numDependentNodes : int
        See description

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    dependentNodes : List[:py:obj:`~.CUgraphNode`]
        Pointer to return the dependent nodes
    numDependentNodes : int
        See description

    See Also
    --------
    :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphGetNodes`, :py:obj:`~.cuGraphGetRootNodes`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphAddDependencies`, :py:obj:`~.cuGraphRemoveDependencies`
    """
    cdef size_t _graph_length = numDependentNodes
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUgraphNode* cdependentNodes = NULL
    pydependentNodes = []
    if _graph_length != 0:
        cdependentNodes = <ccuda.CUgraphNode*>calloc(_graph_length, sizeof(ccuda.CUgraphNode))
        if cdependentNodes is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(_graph_length) + 'x' + str(sizeof(ccuda.CUgraphNode)))
    err = ccuda.cuGraphNodeGetDependentNodes(chNode, cdependentNodes, &numDependentNodes)
    if CUresult(err) == CUresult(0):
        pydependentNodes = [CUgraphNode(init_value=<void_ptr>cdependentNodes[idx]) for idx in range(_graph_length)]
    if cdependentNodes is not NULL:
        free(cdependentNodes)
    return (CUresult(err), pydependentNodes, numDependentNodes)

@cython.embedsignature(True)
def cuGraphAddDependencies(hGraph, from_ : List[CUgraphNode], to : List[CUgraphNode], size_t numDependencies):
    """ Adds dependency edges to a graph.

    The number of dependencies to be added is defined by `numDependencies`
    Elements in `from` and `to` at corresponding indices define a
    dependency. Each node in `from` and `to` must belong to `hGraph`.

    If `numDependencies` is 0, elements in `from` and `to` will be ignored.
    Specifying an existing dependency will return an error.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to which dependencies are added
    from : List[:py:obj:`~.CUgraphNode`]
        Array of nodes that provide the dependencies
    to : List[:py:obj:`~.CUgraphNode`]
        Array of dependent nodes
    numDependencies : size_t
        Number of dependencies to be added

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuGraphRemoveDependencies`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """
    to = [] if to is None else to
    if not all(isinstance(_x, (CUgraphNode)) for _x in to):
        raise TypeError("Argument 'to' is not instance of type (expected List[ccuda.CUgraphNode]")

    from_ = [] if from_ is None else from_
    if not all(isinstance(_x, (CUgraphNode)) for _x in from_):
        raise TypeError("Argument 'from_' is not instance of type (expected List[ccuda.CUgraphNode]")

    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef ccuda.CUgraphNode* cfrom_ = NULL
    if len(from_) > 0:
        cfrom_ = <ccuda.CUgraphNode*> calloc(len(from_), sizeof(ccuda.CUgraphNode))
        if cfrom_ is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(from_)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(from_)):
                cfrom_[idx] = (<CUgraphNode>from_[idx])._ptr[0]

    cdef ccuda.CUgraphNode* cto = NULL
    if len(to) > 0:
        cto = <ccuda.CUgraphNode*> calloc(len(to), sizeof(ccuda.CUgraphNode))
        if cto is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(to)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(to)):
                cto[idx] = (<CUgraphNode>to[idx])._ptr[0]

    err = ccuda.cuGraphAddDependencies(chGraph, (<CUgraphNode>from_[0])._ptr if len(from_) == 1 else cfrom_, (<CUgraphNode>to[0])._ptr if len(to) == 1 else cto, numDependencies)
    if cfrom_ is not NULL:
        free(cfrom_)
    if cto is not NULL:
        free(cto)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphRemoveDependencies(hGraph, from_ : List[CUgraphNode], to : List[CUgraphNode], size_t numDependencies):
    """ Removes dependency edges from a graph.

    The number of `dependencies` to be removed is defined by
    `numDependencies`. Elements in `from` and `to` at corresponding indices
    define a dependency. Each node in `from` and `to` must belong to
    `hGraph`.

    If `numDependencies` is 0, elements in `from` and `to` will be ignored.
    Specifying a non-existing dependency will return an error.

    Dependencies cannot be removed from graphs which contain allocation or
    free nodes. Any attempt to do so will return an error.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph from which to remove dependencies
    from : List[:py:obj:`~.CUgraphNode`]
        Array of nodes that provide the dependencies
    to : List[:py:obj:`~.CUgraphNode`]
        Array of dependent nodes
    numDependencies : size_t
        Number of dependencies to be removed

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuGraphAddDependencies`, :py:obj:`~.cuGraphGetEdges`, :py:obj:`~.cuGraphNodeGetDependencies`, :py:obj:`~.cuGraphNodeGetDependentNodes`
    """
    to = [] if to is None else to
    if not all(isinstance(_x, (CUgraphNode)) for _x in to):
        raise TypeError("Argument 'to' is not instance of type (expected List[ccuda.CUgraphNode]")

    from_ = [] if from_ is None else from_
    if not all(isinstance(_x, (CUgraphNode)) for _x in from_):
        raise TypeError("Argument 'from_' is not instance of type (expected List[ccuda.CUgraphNode]")

    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef ccuda.CUgraphNode* cfrom_ = NULL
    if len(from_) > 0:
        cfrom_ = <ccuda.CUgraphNode*> calloc(len(from_), sizeof(ccuda.CUgraphNode))
        if cfrom_ is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(from_)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(from_)):
                cfrom_[idx] = (<CUgraphNode>from_[idx])._ptr[0]

    cdef ccuda.CUgraphNode* cto = NULL
    if len(to) > 0:
        cto = <ccuda.CUgraphNode*> calloc(len(to), sizeof(ccuda.CUgraphNode))
        if cto is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(len(to)) + 'x' + str(sizeof(ccuda.CUgraphNode)))
        else:
            for idx in range(len(to)):
                cto[idx] = (<CUgraphNode>to[idx])._ptr[0]

    err = ccuda.cuGraphRemoveDependencies(chGraph, (<CUgraphNode>from_[0])._ptr if len(from_) == 1 else cfrom_, (<CUgraphNode>to[0])._ptr if len(to) == 1 else cto, numDependencies)
    if cfrom_ is not NULL:
        free(cfrom_)
    if cto is not NULL:
        free(cto)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphDestroyNode(hNode):
    """ Remove a node from the graph.

    Removes `hNode` from its graph. This operation also severs any
    dependencies of other nodes on `hNode` and vice versa.

    Nodes which belong to a graph which contains allocation or free nodes
    cannot be destroyed. Any attempt to do so will return an error.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node to remove

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphAddEmptyNode`, :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphAddMemsetNode`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    err = ccuda.cuGraphDestroyNode(chNode)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphInstantiate(hGraph, char* logBuffer, size_t bufferSize):
    """ Creates an executable graph from a graph.

    Instantiates `hGraph` as an executable graph. The graph is validated
    for any structural constraints or intra-node constraints which were not
    previously validated. If instantiation is successful, a handle to the
    instantiated graph is returned in `phGraphExec`.

    If there are any errors, diagnostic information may be returned in
    `errorNode` and `logBuffer`. This is the primary way to inspect
    instantiation errors. The output will be null terminated unless the
    diagnostics overflow the buffer. In this case, they will be truncated,
    and the last byte can be inspected to determine if truncation occurred.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to instantiate
    logBuffer : bytes
        A character buffer to store diagnostic messages
    bufferSize : size_t
        Size of the log buffer in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphExec : :py:obj:`~.CUgraphExec`
        Returns instantiated graph
    phErrorNode : :py:obj:`~.CUgraphNode`
        In case of an instantiation error, this may be modified to indicate
        a node contributing to the error

    See Also
    --------
    :py:obj:`~.cuGraphInstantiateWithFlags`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphUpload`, :py:obj:`~.cuGraphLaunch`, :py:obj:`~.cuGraphExecDestroy`
    """
    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef CUgraphExec phGraphExec = CUgraphExec()
    cdef CUgraphNode phErrorNode = CUgraphNode()
    err = ccuda.cuGraphInstantiate(phGraphExec._ptr, chGraph, phErrorNode._ptr, logBuffer, bufferSize)
    return (CUresult(err), phGraphExec, phErrorNode)

@cython.embedsignature(True)
def cuGraphInstantiateWithFlags(hGraph, unsigned long long flags):
    """ Creates an executable graph from a graph.

    Instantiates `hGraph` as an executable graph. The graph is validated
    for any structural constraints or intra-node constraints which were not
    previously validated. If instantiation is successful, a handle to the
    instantiated graph is returned in `phGraphExec`.

    The `flags` parameter controls the behavior of instantiation and
    subsequent graph launches. Valid flags are:

    - :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH`, which
      configures a graph containing memory allocation nodes to
      automatically free any unfreed memory allocations before the graph is
      relaunched.

    If `hGraph` contains any allocation or free nodes, there can be at most
    one executable graph in existence for that graph at a time.

    An attempt to instantiate a second executable graph before destroying
    the first with :py:obj:`~.cuGraphExecDestroy` will result in an error.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to instantiate
    flags : unsigned long long
        Flags to control instantiation. See
        :py:obj:`~.CUgraphInstantiate_flags`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phGraphExec : :py:obj:`~.CUgraphExec`
        Returns instantiated graph

    See Also
    --------
    :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphCreate`, :py:obj:`~.cuGraphUpload`, :py:obj:`~.cuGraphLaunch`, :py:obj:`~.cuGraphExecDestroy`
    """
    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef CUgraphExec phGraphExec = CUgraphExec()
    err = ccuda.cuGraphInstantiateWithFlags(phGraphExec._ptr, chGraph, flags)
    return (CUresult(err), phGraphExec)

@cython.embedsignature(True)
def cuGraphExecKernelNodeSetParams(hGraphExec, hNode, nodeParams : CUDA_KERNEL_NODE_PARAMS):
    """ Sets the parameters for a kernel node in the given graphExec.

    Sets the parameters of a kernel node in an executable graph
    `hGraphExec`. The node is identified by the corresponding node `hNode`
    in the non-executable graph, from which the executable graph was
    instantiated.

    `hNode` must not have been removed from the original graph. All
    `nodeParams` fields may change, but the following restrictions apply to
    `func` updates:

    - The owning context of the function cannot change.

    - A node whose function originally did not use CUDA dynamic parallelism
      cannot be updated to a function which uses CDP

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        kernel node from the graph from which graphExec was instantiated
    nodeParams : :py:obj:`~.CUDA_KERNEL_NODE_PARAMS`
        Updated Parameters to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphAddKernelNode`, :py:obj:`~.cuGraphKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUgraphExec chGraphExec
    if hGraphExec is None:
        chGraphExec = <ccuda.CUgraphExec><void_ptr>0
    elif isinstance(hGraphExec, (CUgraphExec)):
        phGraphExec = int(hGraphExec)
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec

    cdef ccuda.CUDA_KERNEL_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphExecKernelNodeSetParams(chGraphExec, chNode, cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecMemcpyNodeSetParams(hGraphExec, hNode, copyParams : CUDA_MEMCPY3D, ctx):
    """ Sets the parameters for a memcpy node in the given graphExec.

    Updates the work represented by `hNode` in `hGraphExec` as though
    `hNode` had contained `copyParams` at instantiation. hNode must remain
    in the graph which was used to instantiate `hGraphExec`. Changed edges
    to and from hNode are ignored.

    The source and destination memory in `copyParams` must be allocated
    from the same contexts as the original source and destination memory.
    Both the instantiation-time memory operands and the memory operands in
    `copyParams` must be 1-dimensional. Zero-length operations are not
    supported.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. hNode is also not modified by this call.

    Returns CUDA_ERROR_INVALID_VALUE if the memory operands' mappings
    changed or either the original or new memory operands are
    multidimensional.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Memcpy node from the graph which was used to instantiate graphExec
    copyParams : :py:obj:`~.CUDA_MEMCPY3D`
        The updated parameters to set
    ctx : :py:obj:`~.CUcontext`
        Context on which to run the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphAddMemcpyNode`, :py:obj:`~.cuGraphMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef ccuda.CUcontext cctx
    if ctx is None:
        cctx = <ccuda.CUcontext><void_ptr>0
    elif isinstance(ctx, (CUcontext)):
        pctx = int(ctx)
        cctx = <ccuda.CUcontext><void_ptr>pctx
    else:
        pctx = int(CUcontext(ctx))
        cctx = <ccuda.CUcontext><void_ptr>pctx

    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUgraphExec chGraphExec
    if hGraphExec is None:
        chGraphExec = <ccuda.CUgraphExec><void_ptr>0
    elif isinstance(hGraphExec, (CUgraphExec)):
        phGraphExec = int(hGraphExec)
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec

    cdef ccuda.CUDA_MEMCPY3D* ccopyParams_ptr = copyParams._ptr if copyParams != None else NULL
    err = ccuda.cuGraphExecMemcpyNodeSetParams(chGraphExec, chNode, ccopyParams_ptr, cctx)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecMemsetNodeSetParams(hGraphExec, hNode, memsetParams : CUDA_MEMSET_NODE_PARAMS, ctx):
    """ Sets the parameters for a memset node in the given graphExec.

    Updates the work represented by `hNode` in `hGraphExec` as though
    `hNode` had contained `memsetParams` at instantiation. hNode must
    remain in the graph which was used to instantiate `hGraphExec`. Changed
    edges to and from hNode are ignored.

    The destination memory in `memsetParams` must be allocated from the
    same contexts as the original destination memory. Both the
    instantiation-time memory operand and the memory operand in
    `memsetParams` must be 1-dimensional. Zero-length operations are not
    supported.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. hNode is also not modified by this call.

    Returns CUDA_ERROR_INVALID_VALUE if the memory operand's mappings
    changed or either the original or new memory operand are
    multidimensional.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Memset node from the graph which was used to instantiate graphExec
    memsetParams : :py:obj:`~.CUDA_MEMSET_NODE_PARAMS`
        The updated parameters to set
    ctx : :py:obj:`~.CUcontext`
        Context on which to run the node

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphAddMemsetNode`, :py:obj:`~.cuGraphMemsetNodeSetParams`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef ccuda.CUcontext cctx
    if ctx is None:
        cctx = <ccuda.CUcontext><void_ptr>0
    elif isinstance(ctx, (CUcontext)):
        pctx = int(ctx)
        cctx = <ccuda.CUcontext><void_ptr>pctx
    else:
        pctx = int(CUcontext(ctx))
        cctx = <ccuda.CUcontext><void_ptr>pctx

    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUgraphExec chGraphExec
    if hGraphExec is None:
        chGraphExec = <ccuda.CUgraphExec><void_ptr>0
    elif isinstance(hGraphExec, (CUgraphExec)):
        phGraphExec = int(hGraphExec)
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec

    cdef ccuda.CUDA_MEMSET_NODE_PARAMS* cmemsetParams_ptr = memsetParams._ptr if memsetParams != None else NULL
    err = ccuda.cuGraphExecMemsetNodeSetParams(chGraphExec, chNode, cmemsetParams_ptr, cctx)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecHostNodeSetParams(hGraphExec, hNode, nodeParams : CUDA_HOST_NODE_PARAMS):
    """ Sets the parameters for a host node in the given graphExec.

    Updates the work represented by `hNode` in `hGraphExec` as though
    `hNode` had contained `nodeParams` at instantiation. hNode must remain
    in the graph which was used to instantiate `hGraphExec`. Changed edges
    to and from hNode are ignored.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. hNode is also not modified by this call.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Host node from the graph which was used to instantiate graphExec
    nodeParams : :py:obj:`~.CUDA_HOST_NODE_PARAMS`
        The updated parameters to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphAddHostNode`, :py:obj:`~.cuGraphHostNodeSetParams`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUgraphExec chGraphExec
    if hGraphExec is None:
        chGraphExec = <ccuda.CUgraphExec><void_ptr>0
    elif isinstance(hGraphExec, (CUgraphExec)):
        phGraphExec = int(hGraphExec)
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec

    cdef ccuda.CUDA_HOST_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphExecHostNodeSetParams(chGraphExec, chNode, cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecChildGraphNodeSetParams(hGraphExec, hNode, childGraph):
    """ Updates node parameters in the child graph node in the given graphExec.

    Updates the work represented by `hNode` in `hGraphExec` as though the
    nodes contained in `hNode's` graph had the parameters contained in
    `childGraph's` nodes at instantiation. `hNode` must remain in the graph
    which was used to instantiate `hGraphExec`. Changed edges to and from
    `hNode` are ignored.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    The topology of `childGraph`, as well as the node insertion order, must
    match that of the graph contained in `hNode`. See
    :py:obj:`~.cuGraphExecUpdate()` for a list of restrictions on what can
    be updated in an instantiated graph. The update is recursive, so child
    graph nodes contained within the top level child graph will also be
    updated.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Host node from the graph which was used to instantiate graphExec
    childGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph supplying the updated parameters

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphAddChildGraphNode`, :py:obj:`~.cuGraphChildGraphNodeGetGraph`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef ccuda.CUgraph cchildGraph
    if childGraph is None:
        cchildGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(childGraph, (CUgraph)):
        pchildGraph = int(childGraph)
        cchildGraph = <ccuda.CUgraph><void_ptr>pchildGraph
    else:
        pchildGraph = int(CUgraph(childGraph))
        cchildGraph = <ccuda.CUgraph><void_ptr>pchildGraph

    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUgraphExec chGraphExec
    if hGraphExec is None:
        chGraphExec = <ccuda.CUgraphExec><void_ptr>0
    elif isinstance(hGraphExec, (CUgraphExec)):
        phGraphExec = int(hGraphExec)
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec

    err = ccuda.cuGraphExecChildGraphNodeSetParams(chGraphExec, chNode, cchildGraph)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecEventRecordNodeSetEvent(hGraphExec, hNode, event):
    """ Sets the event for an event record node in the given graphExec.

    Sets the event of an event record node in an executable graph
    `hGraphExec`. The node is identified by the corresponding node `hNode`
    in the non-executable graph, from which the executable graph was
    instantiated.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        event record node from the graph from which graphExec was
        instantiated
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Updated event to use

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphAddEventRecordNode`, :py:obj:`~.cuGraphEventRecordNodeGetEvent`, :py:obj:`~.cuGraphEventWaitNodeSetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef ccuda.CUevent cevent
    if event is None:
        cevent = <ccuda.CUevent><void_ptr>0
    elif isinstance(event, (CUevent)):
        pevent = int(event)
        cevent = <ccuda.CUevent><void_ptr>pevent
    else:
        pevent = int(CUevent(event))
        cevent = <ccuda.CUevent><void_ptr>pevent

    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUgraphExec chGraphExec
    if hGraphExec is None:
        chGraphExec = <ccuda.CUgraphExec><void_ptr>0
    elif isinstance(hGraphExec, (CUgraphExec)):
        phGraphExec = int(hGraphExec)
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec

    err = ccuda.cuGraphExecEventRecordNodeSetEvent(chGraphExec, chNode, cevent)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecEventWaitNodeSetEvent(hGraphExec, hNode, event):
    """ Sets the event for an event wait node in the given graphExec.

    Sets the event of an event wait node in an executable graph
    `hGraphExec`. The node is identified by the corresponding node `hNode`
    in the non-executable graph, from which the executable graph was
    instantiated.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        event wait node from the graph from which graphExec was
        instantiated
    event : :py:obj:`~.CUevent` or :py:obj:`~.cudaEvent_t`
        Updated event to use

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphAddEventWaitNode`, :py:obj:`~.cuGraphEventWaitNodeGetEvent`, :py:obj:`~.cuGraphEventRecordNodeSetEvent`, :py:obj:`~.cuEventRecordWithFlags`, :py:obj:`~.cuStreamWaitEvent`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef ccuda.CUevent cevent
    if event is None:
        cevent = <ccuda.CUevent><void_ptr>0
    elif isinstance(event, (CUevent)):
        pevent = int(event)
        cevent = <ccuda.CUevent><void_ptr>pevent
    else:
        pevent = int(CUevent(event))
        cevent = <ccuda.CUevent><void_ptr>pevent

    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUgraphExec chGraphExec
    if hGraphExec is None:
        chGraphExec = <ccuda.CUgraphExec><void_ptr>0
    elif isinstance(hGraphExec, (CUgraphExec)):
        phGraphExec = int(hGraphExec)
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec

    err = ccuda.cuGraphExecEventWaitNodeSetEvent(chGraphExec, chNode, cevent)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecExternalSemaphoresSignalNodeSetParams(hGraphExec, hNode, nodeParams : CUDA_EXT_SEM_SIGNAL_NODE_PARAMS):
    """ Sets the parameters for an external semaphore signal node in the given graphExec.

    Sets the parameters of an external semaphore signal node in an
    executable graph `hGraphExec`. The node is identified by the
    corresponding node `hNode` in the non-executable graph, from which the
    executable graph was instantiated.

    `hNode` must not have been removed from the original graph.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    Changing `nodeParams->numExtSems` is not supported.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        semaphore signal node from the graph from which graphExec was
        instantiated
    nodeParams : :py:obj:`~.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS`
        Updated Parameters to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphAddExternalSemaphoresSignalNode`, :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresWaitNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUgraphExec chGraphExec
    if hGraphExec is None:
        chGraphExec = <ccuda.CUgraphExec><void_ptr>0
    elif isinstance(hGraphExec, (CUgraphExec)):
        phGraphExec = int(hGraphExec)
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec

    cdef ccuda.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphExecExternalSemaphoresSignalNodeSetParams(chGraphExec, chNode, cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecExternalSemaphoresWaitNodeSetParams(hGraphExec, hNode, nodeParams : CUDA_EXT_SEM_WAIT_NODE_PARAMS):
    """ Sets the parameters for an external semaphore wait node in the given graphExec.

    Sets the parameters of an external semaphore wait node in an executable
    graph `hGraphExec`. The node is identified by the corresponding node
    `hNode` in the non-executable graph, from which the executable graph
    was instantiated.

    `hNode` must not have been removed from the original graph.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    Changing `nodeParams->numExtSems` is not supported.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        semaphore wait node from the graph from which graphExec was
        instantiated
    nodeParams : :py:obj:`~.CUDA_EXT_SEM_WAIT_NODE_PARAMS`
        Updated Parameters to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphAddExternalSemaphoresWaitNode`, :py:obj:`~.cuImportExternalSemaphore`, :py:obj:`~.cuSignalExternalSemaphoresAsync`, :py:obj:`~.cuWaitExternalSemaphoresAsync`, :py:obj:`~.cuGraphExecKernelNodeSetParams`, :py:obj:`~.cuGraphExecMemcpyNodeSetParams`, :py:obj:`~.cuGraphExecMemsetNodeSetParams`, :py:obj:`~.cuGraphExecHostNodeSetParams`, :py:obj:`~.cuGraphExecChildGraphNodeSetParams`, :py:obj:`~.cuGraphExecEventRecordNodeSetEvent`, :py:obj:`~.cuGraphExecEventWaitNodeSetEvent`, :py:obj:`~.cuGraphExecExternalSemaphoresSignalNodeSetParams`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUgraphExec chGraphExec
    if hGraphExec is None:
        chGraphExec = <ccuda.CUgraphExec><void_ptr>0
    elif isinstance(hGraphExec, (CUgraphExec)):
        phGraphExec = int(hGraphExec)
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec

    cdef ccuda.CUDA_EXT_SEM_WAIT_NODE_PARAMS* cnodeParams_ptr = nodeParams._ptr if nodeParams != None else NULL
    err = ccuda.cuGraphExecExternalSemaphoresWaitNodeSetParams(chGraphExec, chNode, cnodeParams_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphNodeSetEnabled(hGraphExec, hNode, unsigned int isEnabled):
    """ Enables or disables the specified node in the given graphExec.

    Sets `hNode` to be either enabled or disabled. Disabled nodes are
    functionally equivalent to empty nodes until they are reenabled.
    Existing node parameters are not affected by disabling/enabling the
    node.

    The node is identified by the corresponding node `hNode` in the non-
    executable graph, from which the executable graph was instantiated.

    `hNode` must not have been removed from the original graph.

    The modifications only affect future launches of `hGraphExec`. Already
    enqueued or running launches of `hGraphExec` are not affected by this
    call. `hNode` is also not modified by this call.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node from the graph from which graphExec was instantiated
    isEnabled : unsigned int
        Node is enabled if != 0, otherwise the node is disabled

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,

    See Also
    --------
    :py:obj:`~.cuGraphNodeGetEnabled`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate` :py:obj:`~.cuGraphLaunch`

    Notes
    -----
    Currently only kernel, memset and memcpy nodes are supported.
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUgraphExec chGraphExec
    if hGraphExec is None:
        chGraphExec = <ccuda.CUgraphExec><void_ptr>0
    elif isinstance(hGraphExec, (CUgraphExec)):
        phGraphExec = int(hGraphExec)
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec

    err = ccuda.cuGraphNodeSetEnabled(chGraphExec, chNode, isEnabled)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphNodeGetEnabled(hGraphExec, hNode):
    """ Query whether a node in the given graphExec is enabled.

    Sets isEnabled to 1 if `hNode` is enabled, or 0 if `hNode` is disabled.

    The node is identified by the corresponding node `hNode` in the non-
    executable graph, from which the executable graph was instantiated.

    `hNode` must not have been removed from the original graph.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The executable graph in which to set the specified node
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Node from the graph from which graphExec was instantiated

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    isEnabled : unsigned int
        Location to return the enabled status of the node

    See Also
    --------
    :py:obj:`~.cuGraphNodeSetEnabled`, :py:obj:`~.cuGraphExecUpdate`, :py:obj:`~.cuGraphInstantiate` :py:obj:`~.cuGraphLaunch`

    Notes
    -----
    Currently only kernel, memset and memcpy nodes are supported.
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUgraphExec chGraphExec
    if hGraphExec is None:
        chGraphExec = <ccuda.CUgraphExec><void_ptr>0
    elif isinstance(hGraphExec, (CUgraphExec)):
        phGraphExec = int(hGraphExec)
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec

    cdef unsigned int isEnabled = 0
    err = ccuda.cuGraphNodeGetEnabled(chGraphExec, chNode, &isEnabled)
    return (CUresult(err), isEnabled)

@cython.embedsignature(True)
def cuGraphUpload(hGraphExec, hStream):
    """ Uploads an executable graph in a stream.

    Uploads `hGraphExec` to the device in `hStream` without executing it.
    Uploads of the same `hGraphExec` will be serialized. Each upload is
    ordered behind both any previous work in `hStream` and any previous
    launches of `hGraphExec`. Uses memory cached by `stream` to back the
    allocations owned by `hGraphExec`.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        Executable graph to upload
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream in which to upload the graph

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphLaunch`, :py:obj:`~.cuGraphExecDestroy`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUgraphExec chGraphExec
    if hGraphExec is None:
        chGraphExec = <ccuda.CUgraphExec><void_ptr>0
    elif isinstance(hGraphExec, (CUgraphExec)):
        phGraphExec = int(hGraphExec)
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec

    err = ccuda.cuGraphUpload(chGraphExec, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphLaunch(hGraphExec, hStream):
    """ Launches an executable graph in a stream.

    Executes `hGraphExec` in `hStream`. Only one instance of `hGraphExec`
    may be executing at a time. Each launch is ordered behind both any
    previous work in `hStream` and any previous launches of `hGraphExec`.
    To execute a graph concurrently, it must be instantiated multiple times
    into multiple executable graphs.

    If any allocations created by `hGraphExec` remain unfreed (from a
    previous launch) and `hGraphExec` was not instantiated with
    :py:obj:`~.CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH`, the launch
    will fail with :py:obj:`~.CUDA_ERROR_INVALID_VALUE`.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        Executable graph to launch
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream in which to launch the graph

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphUpload`, :py:obj:`~.cuGraphExecDestroy`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUgraphExec chGraphExec
    if hGraphExec is None:
        chGraphExec = <ccuda.CUgraphExec><void_ptr>0
    elif isinstance(hGraphExec, (CUgraphExec)):
        phGraphExec = int(hGraphExec)
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec

    err = ccuda.cuGraphLaunch(chGraphExec, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecDestroy(hGraphExec):
    """ Destroys an executable graph.

    Destroys the executable graph specified by `hGraphExec`, as well as all
    of its executable nodes. If the executable graph is in-flight, it will
    not be terminated, but rather freed asynchronously on completion.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        Executable graph to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuGraphInstantiate`, :py:obj:`~.cuGraphUpload`, :py:obj:`~.cuGraphLaunch`
    """
    cdef ccuda.CUgraphExec chGraphExec
    if hGraphExec is None:
        chGraphExec = <ccuda.CUgraphExec><void_ptr>0
    elif isinstance(hGraphExec, (CUgraphExec)):
        phGraphExec = int(hGraphExec)
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec

    err = ccuda.cuGraphExecDestroy(chGraphExec)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphDestroy(hGraph):
    """ Destroys a graph.

    Destroys the graph specified by `hGraph`, as well as all of its nodes.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        Graph to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuGraphCreate`
    """
    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    err = ccuda.cuGraphDestroy(chGraph)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphExecUpdate(hGraphExec, hGraph):
    """ Check whether an executable graph can be updated with a graph and perform the update if possible.

    Updates the node parameters in the instantiated graph specified by
    `hGraphExec` with the node parameters in a topologically identical
    graph specified by `hGraph`.

    Limitations:

    - Kernel nodes:

      - The owning context of the function cannot change.

      - A node whose function originally did not use CUDA dynamic
        parallelism cannot be updated to a function which uses CDP.

      - A cooperative node cannot be updated to a non-cooperative node, and
        vice-versa.

    - Memset and memcpy nodes:

      - The CUDA device(s) to which the operand(s) was allocated/mapped
        cannot change.

      - The source/destination memory must be allocated from the same
        contexts as the original source/destination memory.

      - Only 1D memsets can be changed.

    - Additional memcpy node restrictions:

      - Changing either the source or destination memory type(i.e.
        CU_MEMORYTYPE_DEVICE, CU_MEMORYTYPE_ARRAY, etc.) is not supported.

    - External semaphore wait nodes and record nodes:

      - Changing the number of semaphores is not supported.

    Note: The API may add further restrictions in future releases. The
    return code should always be checked.

    cuGraphExecUpdate sets `updateResult_out` to
    CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED under the following
    conditions:

    - The count of nodes directly in `hGraphExec` and `hGraph` differ, in
      which case `hErrorNode_out` is NULL.

    - A node is deleted in `hGraph` but not not its pair from `hGraphExec`,
      in which case `hErrorNode_out` is NULL.

    - A node is deleted in `hGraphExec` but not its pair from `hGraph`, in
      which case `hErrorNode_out` is the pairless node from `hGraph`.

    - The dependent nodes of a pair differ, in which case `hErrorNode_out`
      is the node from `hGraph`.

    cuGraphExecUpdate sets `updateResult_out` to:

    - CU_GRAPH_EXEC_UPDATE_ERROR if passed an invalid value.

    - CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED if the graph topology
      changed

    - CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED if the type of a node
      changed, in which case `hErrorNode_out` is set to the node from
      `hGraph`.

    - CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE if the
      function changed in an unsupported way(see note above), in which case
      `hErrorNode_out` is set to the node from `hGraph`

    - CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED if any parameters to a
      node changed in a way that is not supported, in which case
      `hErrorNode_out` is set to the node from `hGraph`.

    - CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED if any attributes of a
      node changed in a way that is not supported, in which case
      `hErrorNode_out` is set to the node from `hGraph`.

    - CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED if something about a node is
      unsupported, like the node's type or configuration, in which case
      `hErrorNode_out` is set to the node from `hGraph`

    If `updateResult_out` isn't set in one of the situations described
    above, the update check passes and cuGraphExecUpdate updates
    `hGraphExec` to match the contents of `hGraph`. If an error happens
    during the update, `updateResult_out` will be set to
    CU_GRAPH_EXEC_UPDATE_ERROR; otherwise, `updateResult_out` is set to
    CU_GRAPH_EXEC_UPDATE_SUCCESS.

    cuGraphExecUpdate returns CUDA_SUCCESS when the updated was performed
    successfully. It returns CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE if the
    graph update was not performed because it included changes which
    violated constraints specific to instantiated graph update.

    Parameters
    ----------
    hGraphExec : :py:obj:`~.CUgraphExec` or :py:obj:`~.cudaGraphExec_t`
        The instantiated graph to be updated
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph containing the updated parameters

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE`,
    hErrorNode_out : :py:obj:`~.CUgraphNode`
        The node which caused the permissibility check to forbid the
        update, if any
    updateResult_out : :py:obj:`~.CUgraphExecUpdateResult`
        Whether the graph update was permitted. If was forbidden, the
        reason why

    See Also
    --------
    :py:obj:`~.cuGraphInstantiate`,
    """
    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    cdef ccuda.CUgraphExec chGraphExec
    if hGraphExec is None:
        chGraphExec = <ccuda.CUgraphExec><void_ptr>0
    elif isinstance(hGraphExec, (CUgraphExec)):
        phGraphExec = int(hGraphExec)
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec
    else:
        phGraphExec = int(CUgraphExec(hGraphExec))
        chGraphExec = <ccuda.CUgraphExec><void_ptr>phGraphExec

    cdef CUgraphNode hErrorNode_out = CUgraphNode()
    cdef ccuda.CUgraphExecUpdateResult updateResult_out
    err = ccuda.cuGraphExecUpdate(chGraphExec, chGraph, hErrorNode_out._ptr, &updateResult_out)
    return (CUresult(err), hErrorNode_out, CUgraphExecUpdateResult(updateResult_out))

@cython.embedsignature(True)
def cuGraphKernelNodeCopyAttributes(dst, src):
    """ Copies attributes from source node to destination node.

    Copies attributes from source node `src` to destination node `dst`.
    Both node must have the same context.

    Parameters
    ----------
    dst : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Destination node
    src : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`
        Source node For list of attributes see
        :py:obj:`~.CUkernelNodeAttrID`

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.CUaccessPolicyWindow`
    """
    cdef ccuda.CUgraphNode csrc
    if src is None:
        csrc = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(src, (CUgraphNode)):
        psrc = int(src)
        csrc = <ccuda.CUgraphNode><void_ptr>psrc
    else:
        psrc = int(CUgraphNode(src))
        csrc = <ccuda.CUgraphNode><void_ptr>psrc

    cdef ccuda.CUgraphNode cdst
    if dst is None:
        cdst = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(dst, (CUgraphNode)):
        pdst = int(dst)
        cdst = <ccuda.CUgraphNode><void_ptr>pdst
    else:
        pdst = int(CUgraphNode(dst))
        cdst = <ccuda.CUgraphNode><void_ptr>pdst

    err = ccuda.cuGraphKernelNodeCopyAttributes(cdst, csrc)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphKernelNodeGetAttribute(hNode, attr not None : CUkernelNodeAttrID):
    """ Queries node attribute.

    Queries attribute `attr` from node `hNode` and stores it in
    corresponding member of `value_out`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`

    attr : :py:obj:`~.CUkernelNodeAttrID`


    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`
    value_out : :py:obj:`~.CUkernelNodeAttrValue`


    See Also
    --------
    :py:obj:`~.CUaccessPolicyWindow`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUkernelNodeAttrID cattr = attr.value
    cdef CUkernelNodeAttrValue value_out = CUkernelNodeAttrValue()
    err = ccuda.cuGraphKernelNodeGetAttribute(chNode, cattr, value_out._ptr)
    return (CUresult(err), value_out)

@cython.embedsignature(True)
def cuGraphKernelNodeSetAttribute(hNode, attr not None : CUkernelNodeAttrID, value : CUkernelNodeAttrValue):
    """ Sets node attribute.

    Sets attribute `attr` on node `hNode` from corresponding attribute of
    `value`.

    Parameters
    ----------
    hNode : :py:obj:`~.CUgraphNode` or :py:obj:`~.cudaGraphNode_t`

    attr : :py:obj:`~.CUkernelNodeAttrID`

    value : :py:obj:`~.CUkernelNodeAttrValue`


    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`

    See Also
    --------
    :py:obj:`~.CUaccessPolicyWindow`
    """
    cdef ccuda.CUgraphNode chNode
    if hNode is None:
        chNode = <ccuda.CUgraphNode><void_ptr>0
    elif isinstance(hNode, (CUgraphNode)):
        phNode = int(hNode)
        chNode = <ccuda.CUgraphNode><void_ptr>phNode
    else:
        phNode = int(CUgraphNode(hNode))
        chNode = <ccuda.CUgraphNode><void_ptr>phNode

    cdef ccuda.CUkernelNodeAttrID cattr = attr.value
    cdef ccuda.CUkernelNodeAttrValue* cvalue_ptr = value._ptr if value != None else NULL
    err = ccuda.cuGraphKernelNodeSetAttribute(chNode, cattr, cvalue_ptr)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphDebugDotPrint(hGraph, char* path, unsigned int flags):
    """ Write a DOT file describing graph structure.

    Using the provided `hGraph`, write to `path` a DOT formatted
    description of the graph. By default this includes the graph topology,
    node types, node id, kernel names and memcpy direction. `flags` can be
    specified to write more detailed information about each node type such
    as parameter values, kernel attributes, node and function handles.

    Parameters
    ----------
    hGraph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph to create a DOT file from
    path : bytes
        The path to write the DOT file to
    flags : unsigned int
        Flags from CUgraphDebugDot_flags for specifying which additional
        node information to write

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OPERATING_SYSTEM`
    """
    cdef ccuda.CUgraph chGraph
    if hGraph is None:
        chGraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(hGraph, (CUgraph)):
        phGraph = int(hGraph)
        chGraph = <ccuda.CUgraph><void_ptr>phGraph
    else:
        phGraph = int(CUgraph(hGraph))
        chGraph = <ccuda.CUgraph><void_ptr>phGraph

    err = ccuda.cuGraphDebugDotPrint(chGraph, path, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuUserObjectCreate(ptr, destroy, unsigned int initialRefcount, unsigned int flags):
    """ Create a user object.

    Create a user object with the specified destructor callback and initial
    reference count. The initial references are owned by the caller.

    Destructor callbacks cannot make CUDA API calls and should avoid
    blocking behavior, as they are executed by a shared internal thread.
    Another thread may be signaled to perform such actions, if it does not
    block forward progress of tasks scheduled through CUDA.

    See CUDA User Objects in the CUDA C++ Programming Guide for more
    information on user objects.

    Parameters
    ----------
    ptr : Any
        The pointer to pass to the destroy function
    destroy : :py:obj:`~.CUhostFn`
        Callback to free the user object when it is no longer in use
    initialRefcount : unsigned int
        The initial refcount to create the object with, typically 1. The
        initial references are owned by the calling thread.
    flags : unsigned int
        Currently it is required to pass
        :py:obj:`~.CU_USER_OBJECT_NO_DESTRUCTOR_SYNC`, which is the only
        defined flag. This indicates that the destroy callback cannot be
        waited on by any CUDA API. Users requiring synchronization of the
        callback should signal its completion manually.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    object_out : :py:obj:`~.CUuserObject`
        Location to return the user object handle

    See Also
    --------
    :py:obj:`~.cuUserObjectRetain`, :py:obj:`~.cuUserObjectRelease`, :py:obj:`~.cuGraphRetainUserObject`, :py:obj:`~.cuGraphReleaseUserObject`, :py:obj:`~.cuGraphCreate`
    """
    cdef ccuda.CUhostFn cdestroy
    if destroy is None:
        cdestroy = <ccuda.CUhostFn><void_ptr>0
    elif isinstance(destroy, (CUhostFn)):
        pdestroy = int(destroy)
        cdestroy = <ccuda.CUhostFn><void_ptr>pdestroy
    else:
        pdestroy = int(CUhostFn(destroy))
        cdestroy = <ccuda.CUhostFn><void_ptr>pdestroy

    cdef CUuserObject object_out = CUuserObject()
    cptr = utils.HelperInputVoidPtr(ptr)
    cdef void* cptr_ptr = <void*><void_ptr>cptr.cptr
    err = ccuda.cuUserObjectCreate(object_out._ptr, cptr_ptr, cdestroy, initialRefcount, flags)
    return (CUresult(err), object_out)

@cython.embedsignature(True)
def cuUserObjectRetain(object, unsigned int count):
    """ Retain a reference to a user object.

    Retains new references to a user object. The new references are owned
    by the caller.

    See CUDA User Objects in the CUDA C++ Programming Guide for more
    information on user objects.

    Parameters
    ----------
    object : :py:obj:`~.CUuserObject`
        The object to retain
    count : unsigned int
        The number of references to retain, typically 1. Must be nonzero
        and not larger than INT_MAX.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuUserObjectCreate`, :py:obj:`~.cuUserObjectRelease`, :py:obj:`~.cuGraphRetainUserObject`, :py:obj:`~.cuGraphReleaseUserObject`, :py:obj:`~.cuGraphCreate`
    """
    cdef ccuda.CUuserObject cobject
    if object is None:
        cobject = <ccuda.CUuserObject><void_ptr>0
    elif isinstance(object, (CUuserObject)):
        pobject = int(object)
        cobject = <ccuda.CUuserObject><void_ptr>pobject
    else:
        pobject = int(CUuserObject(object))
        cobject = <ccuda.CUuserObject><void_ptr>pobject

    err = ccuda.cuUserObjectRetain(cobject, count)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuUserObjectRelease(object, unsigned int count):
    """ Release a reference to a user object.

    Releases user object references owned by the caller. The object's
    destructor is invoked if the reference count reaches zero.

    It is undefined behavior to release references not owned by the caller,
    or to use a user object handle after all references are released.

    See CUDA User Objects in the CUDA C++ Programming Guide for more
    information on user objects.

    Parameters
    ----------
    object : :py:obj:`~.CUuserObject`
        The object to release
    count : unsigned int
        The number of references to release, typically 1. Must be nonzero
        and not larger than INT_MAX.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuUserObjectCreate`, :py:obj:`~.cuUserObjectRetain`, :py:obj:`~.cuGraphRetainUserObject`, :py:obj:`~.cuGraphReleaseUserObject`, :py:obj:`~.cuGraphCreate`
    """
    cdef ccuda.CUuserObject cobject
    if object is None:
        cobject = <ccuda.CUuserObject><void_ptr>0
    elif isinstance(object, (CUuserObject)):
        pobject = int(object)
        cobject = <ccuda.CUuserObject><void_ptr>pobject
    else:
        pobject = int(CUuserObject(object))
        cobject = <ccuda.CUuserObject><void_ptr>pobject

    err = ccuda.cuUserObjectRelease(cobject, count)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphRetainUserObject(graph, object, unsigned int count, unsigned int flags):
    """ Retain a reference to a user object from a graph.

    Creates or moves user object references that will be owned by a CUDA
    graph.

    See CUDA User Objects in the CUDA C++ Programming Guide for more
    information on user objects.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph to associate the reference with
    object : :py:obj:`~.CUuserObject`
        The user object to retain a reference for
    count : unsigned int
        The number of references to add to the graph, typically 1. Must be
        nonzero and not larger than INT_MAX.
    flags : unsigned int
        The optional flag :py:obj:`~.CU_GRAPH_USER_OBJECT_MOVE` transfers
        references from the calling thread, rather than create new
        references. Pass 0 to create new references.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuUserObjectCreate`, :py:obj:`~.cuUserObjectRetain`, :py:obj:`~.cuUserObjectRelease`, :py:obj:`~.cuGraphReleaseUserObject`, :py:obj:`~.cuGraphCreate`
    """
    cdef ccuda.CUuserObject cobject
    if object is None:
        cobject = <ccuda.CUuserObject><void_ptr>0
    elif isinstance(object, (CUuserObject)):
        pobject = int(object)
        cobject = <ccuda.CUuserObject><void_ptr>pobject
    else:
        pobject = int(CUuserObject(object))
        cobject = <ccuda.CUuserObject><void_ptr>pobject

    cdef ccuda.CUgraph cgraph
    if graph is None:
        cgraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(graph, (CUgraph)):
        pgraph = int(graph)
        cgraph = <ccuda.CUgraph><void_ptr>pgraph
    else:
        pgraph = int(CUgraph(graph))
        cgraph = <ccuda.CUgraph><void_ptr>pgraph

    err = ccuda.cuGraphRetainUserObject(cgraph, cobject, count, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphReleaseUserObject(graph, object, unsigned int count):
    """ Release a user object reference from a graph.

    Releases user object references owned by a graph.

    See CUDA User Objects in the CUDA C++ Programming Guide for more
    information on user objects.

    Parameters
    ----------
    graph : :py:obj:`~.CUgraph` or :py:obj:`~.cudaGraph_t`
        The graph that will release the reference
    object : :py:obj:`~.CUuserObject`
        The user object to release a reference for
    count : unsigned int
        The number of references to release, typically 1. Must be nonzero
        and not larger than INT_MAX.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuUserObjectCreate`, :py:obj:`~.cuUserObjectRetain`, :py:obj:`~.cuUserObjectRelease`, :py:obj:`~.cuGraphRetainUserObject`, :py:obj:`~.cuGraphCreate`
    """
    cdef ccuda.CUuserObject cobject
    if object is None:
        cobject = <ccuda.CUuserObject><void_ptr>0
    elif isinstance(object, (CUuserObject)):
        pobject = int(object)
        cobject = <ccuda.CUuserObject><void_ptr>pobject
    else:
        pobject = int(CUuserObject(object))
        cobject = <ccuda.CUuserObject><void_ptr>pobject

    cdef ccuda.CUgraph cgraph
    if graph is None:
        cgraph = <ccuda.CUgraph><void_ptr>0
    elif isinstance(graph, (CUgraph)):
        pgraph = int(graph)
        cgraph = <ccuda.CUgraph><void_ptr>pgraph
    else:
        pgraph = int(CUgraph(graph))
        cgraph = <ccuda.CUgraph><void_ptr>pgraph

    err = ccuda.cuGraphReleaseUserObject(cgraph, cobject, count)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuOccupancyMaxActiveBlocksPerMultiprocessor(func, int blockSize, size_t dynamicSMemSize):
    """ Returns occupancy of a function.

    Returns in `*numBlocks` the number of the maximum active blocks per
    streaming multiprocessor.

    Parameters
    ----------
    func : :py:obj:`~.CUfunction`
        Kernel for which occupancy is calculated
    blockSize : int
        Block size the kernel is intended to be launched with
    dynamicSMemSize : size_t
        Per-block dynamic shared memory usage intended, in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    numBlocks : int
        Returned occupancy

    See Also
    --------
    :py:obj:`~.cudaOccupancyMaxActiveBlocksPerMultiprocessor`
    """
    cdef ccuda.CUfunction cfunc
    if func is None:
        cfunc = <ccuda.CUfunction><void_ptr>0
    elif isinstance(func, (CUfunction)):
        pfunc = int(func)
        cfunc = <ccuda.CUfunction><void_ptr>pfunc
    else:
        pfunc = int(CUfunction(func))
        cfunc = <ccuda.CUfunction><void_ptr>pfunc

    cdef int numBlocks = 0
    err = ccuda.cuOccupancyMaxActiveBlocksPerMultiprocessor(&numBlocks, cfunc, blockSize, dynamicSMemSize)
    return (CUresult(err), numBlocks)

@cython.embedsignature(True)
def cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(func, int blockSize, size_t dynamicSMemSize, unsigned int flags):
    """ Returns occupancy of a function.

    Returns in `*numBlocks` the number of the maximum active blocks per
    streaming multiprocessor.

    The `Flags` parameter controls how special cases are handled. The valid
    flags are:

    - :py:obj:`~.CU_OCCUPANCY_DEFAULT`, which maintains the default
      behavior as :py:obj:`~.cuOccupancyMaxActiveBlocksPerMultiprocessor`;

    - :py:obj:`~.CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE`, which suppresses
      the default behavior on platform where global caching affects
      occupancy. On such platforms, if caching is enabled, but per-block SM
      resource usage would result in zero occupancy, the occupancy
      calculator will calculate the occupancy as if caching is disabled.
      Setting :py:obj:`~.CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE` makes the
      occupancy calculator to return 0 in such cases. More information can
      be found about this feature in the "Unified L1/Texture Cache" section
      of the Maxwell tuning guide.

    Parameters
    ----------
    func : :py:obj:`~.CUfunction`
        Kernel for which occupancy is calculated
    blockSize : int
        Block size the kernel is intended to be launched with
    dynamicSMemSize : size_t
        Per-block dynamic shared memory usage intended, in bytes
    flags : unsigned int
        Requested behavior for the occupancy calculator

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    numBlocks : int
        Returned occupancy

    See Also
    --------
    :py:obj:`~.cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags`
    """
    cdef ccuda.CUfunction cfunc
    if func is None:
        cfunc = <ccuda.CUfunction><void_ptr>0
    elif isinstance(func, (CUfunction)):
        pfunc = int(func)
        cfunc = <ccuda.CUfunction><void_ptr>pfunc
    else:
        pfunc = int(CUfunction(func))
        cfunc = <ccuda.CUfunction><void_ptr>pfunc

    cdef int numBlocks = 0
    err = ccuda.cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(&numBlocks, cfunc, blockSize, dynamicSMemSize, flags)
    return (CUresult(err), numBlocks)

@cython.embedsignature(True)
def cuOccupancyMaxPotentialBlockSize(func, blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit):
    """ Suggest a launch configuration with reasonable occupancy.

    Returns in `*blockSize` a reasonable block size that can achieve the
    maximum occupancy (or, the maximum number of active warps with the
    fewest blocks per multiprocessor), and in `*minGridSize` the minimum
    grid size to achieve the maximum occupancy.

    If `blockSizeLimit` is 0, the configurator will use the maximum block
    size permitted by the device / function instead.

    If per-block dynamic shared memory allocation is not needed, the user
    should leave both `blockSizeToDynamicSMemSize` and `dynamicSMemSize` as
    0.

    If per-block dynamic shared memory allocation is needed, then if the
    dynamic shared memory size is constant regardless of block size, the
    size should be passed through `dynamicSMemSize`, and
    `blockSizeToDynamicSMemSize` should be NULL.

    Otherwise, if the per-block dynamic shared memory size varies with
    different block sizes, the user needs to provide a unary function
    through `blockSizeToDynamicSMemSize` that computes the dynamic shared
    memory needed by `func` for any given block size. `dynamicSMemSize` is
    ignored. An example signature is:

    **View CUDA Toolkit Documentation for a C++ code example**

    Parameters
    ----------
    func : :py:obj:`~.CUfunction`
        Kernel for which launch configuration is calculated
    blockSizeToDynamicSMemSize : :py:obj:`~.CUoccupancyB2DSize`
        A function that calculates how much per-block dynamic shared memory
        `func` uses based on the block size
    dynamicSMemSize : size_t
        Dynamic shared memory usage intended, in bytes
    blockSizeLimit : int
        The maximum block size `func` is designed to handle

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    minGridSize : int
        Returned minimum grid size needed to achieve the maximum occupancy
    blockSize : int
        Returned maximum block size that can achieve the maximum occupancy

    See Also
    --------
    :py:obj:`~.cudaOccupancyMaxPotentialBlockSize`
    """
    cdef ccuda.CUoccupancyB2DSize cblockSizeToDynamicSMemSize
    if blockSizeToDynamicSMemSize is None:
        cblockSizeToDynamicSMemSize = <ccuda.CUoccupancyB2DSize><void_ptr>0
    elif isinstance(blockSizeToDynamicSMemSize, (CUoccupancyB2DSize)):
        pblockSizeToDynamicSMemSize = int(blockSizeToDynamicSMemSize)
        cblockSizeToDynamicSMemSize = <ccuda.CUoccupancyB2DSize><void_ptr>pblockSizeToDynamicSMemSize
    else:
        pblockSizeToDynamicSMemSize = int(CUoccupancyB2DSize(blockSizeToDynamicSMemSize))
        cblockSizeToDynamicSMemSize = <ccuda.CUoccupancyB2DSize><void_ptr>pblockSizeToDynamicSMemSize

    cdef ccuda.CUfunction cfunc
    if func is None:
        cfunc = <ccuda.CUfunction><void_ptr>0
    elif isinstance(func, (CUfunction)):
        pfunc = int(func)
        cfunc = <ccuda.CUfunction><void_ptr>pfunc
    else:
        pfunc = int(CUfunction(func))
        cfunc = <ccuda.CUfunction><void_ptr>pfunc

    cdef int minGridSize = 0
    cdef int blockSize = 0
    err = ccuda.cuOccupancyMaxPotentialBlockSize(&minGridSize, &blockSize, cfunc, cblockSizeToDynamicSMemSize, dynamicSMemSize, blockSizeLimit)
    return (CUresult(err), minGridSize, blockSize)

@cython.embedsignature(True)
def cuOccupancyMaxPotentialBlockSizeWithFlags(func, blockSizeToDynamicSMemSize, size_t dynamicSMemSize, int blockSizeLimit, unsigned int flags):
    """ Suggest a launch configuration with reasonable occupancy.

    An extended version of :py:obj:`~.cuOccupancyMaxPotentialBlockSize`. In
    addition to arguments passed to
    :py:obj:`~.cuOccupancyMaxPotentialBlockSize`,
    :py:obj:`~.cuOccupancyMaxPotentialBlockSizeWithFlags` also takes a
    `Flags` parameter.

    The `Flags` parameter controls how special cases are handled. The valid
    flags are:

    - :py:obj:`~.CU_OCCUPANCY_DEFAULT`, which maintains the default
      behavior as :py:obj:`~.cuOccupancyMaxPotentialBlockSize`;

    - :py:obj:`~.CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE`, which suppresses
      the default behavior on platform where global caching affects
      occupancy. On such platforms, the launch configurations that produces
      maximal occupancy might not support global caching. Setting
      :py:obj:`~.CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE` guarantees that the
      the produced launch configuration is global caching compatible at a
      potential cost of occupancy. More information can be found about this
      feature in the "Unified L1/Texture Cache" section of the Maxwell
      tuning guide.

    Parameters
    ----------
    func : :py:obj:`~.CUfunction`
        Kernel for which launch configuration is calculated
    blockSizeToDynamicSMemSize : :py:obj:`~.CUoccupancyB2DSize`
        A function that calculates how much per-block dynamic shared memory
        `func` uses based on the block size
    dynamicSMemSize : size_t
        Dynamic shared memory usage intended, in bytes
    blockSizeLimit : int
        The maximum block size `func` is designed to handle
    flags : unsigned int
        Options

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    minGridSize : int
        Returned minimum grid size needed to achieve the maximum occupancy
    blockSize : int
        Returned maximum block size that can achieve the maximum occupancy

    See Also
    --------
    :py:obj:`~.cudaOccupancyMaxPotentialBlockSizeWithFlags`
    """
    cdef ccuda.CUoccupancyB2DSize cblockSizeToDynamicSMemSize
    if blockSizeToDynamicSMemSize is None:
        cblockSizeToDynamicSMemSize = <ccuda.CUoccupancyB2DSize><void_ptr>0
    elif isinstance(blockSizeToDynamicSMemSize, (CUoccupancyB2DSize)):
        pblockSizeToDynamicSMemSize = int(blockSizeToDynamicSMemSize)
        cblockSizeToDynamicSMemSize = <ccuda.CUoccupancyB2DSize><void_ptr>pblockSizeToDynamicSMemSize
    else:
        pblockSizeToDynamicSMemSize = int(CUoccupancyB2DSize(blockSizeToDynamicSMemSize))
        cblockSizeToDynamicSMemSize = <ccuda.CUoccupancyB2DSize><void_ptr>pblockSizeToDynamicSMemSize

    cdef ccuda.CUfunction cfunc
    if func is None:
        cfunc = <ccuda.CUfunction><void_ptr>0
    elif isinstance(func, (CUfunction)):
        pfunc = int(func)
        cfunc = <ccuda.CUfunction><void_ptr>pfunc
    else:
        pfunc = int(CUfunction(func))
        cfunc = <ccuda.CUfunction><void_ptr>pfunc

    cdef int minGridSize = 0
    cdef int blockSize = 0
    err = ccuda.cuOccupancyMaxPotentialBlockSizeWithFlags(&minGridSize, &blockSize, cfunc, cblockSizeToDynamicSMemSize, dynamicSMemSize, blockSizeLimit, flags)
    return (CUresult(err), minGridSize, blockSize)

@cython.embedsignature(True)
def cuOccupancyAvailableDynamicSMemPerBlock(func, int numBlocks, int blockSize):
    """ Returns dynamic shared memory available per block when launching `numBlocks` blocks on SM.

    Returns in `*dynamicSmemSize` the maximum size of dynamic shared memory
    to allow `numBlocks` blocks per SM.

    Parameters
    ----------
    func : :py:obj:`~.CUfunction`
        Kernel function for which occupancy is calculated
    numBlocks : int
        Number of blocks to fit on SM
    blockSize : int
        Size of the blocks

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`
    dynamicSmemSize : int
        Returned maximum dynamic shared memory
    """
    cdef ccuda.CUfunction cfunc
    if func is None:
        cfunc = <ccuda.CUfunction><void_ptr>0
    elif isinstance(func, (CUfunction)):
        pfunc = int(func)
        cfunc = <ccuda.CUfunction><void_ptr>pfunc
    else:
        pfunc = int(CUfunction(func))
        cfunc = <ccuda.CUfunction><void_ptr>pfunc

    cdef size_t dynamicSmemSize = 0
    err = ccuda.cuOccupancyAvailableDynamicSMemPerBlock(&dynamicSmemSize, cfunc, numBlocks, blockSize)
    return (CUresult(err), dynamicSmemSize)

@cython.embedsignature(True)
def cuTexRefSetArray(hTexRef, hArray, unsigned int Flags):
    """ Binds an array as a texture reference.

    [Deprecated]

    Binds the CUDA array `hArray` to the texture reference `hTexRef`. Any
    previous address or CUDA array state associated with the texture
    reference is superseded by this function. `Flags` must be set to
    :py:obj:`~.CU_TRSA_OVERRIDE_FORMAT`. Any CUDA array previously bound to
    `hTexRef` is unbound.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference to bind
    hArray : :py:obj:`~.CUarray`
        Array to bind
    Flags : unsigned int
        Options (must be :py:obj:`~.CU_TRSA_OVERRIDE_FORMAT`)

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`, :py:obj:`~.cudaBindTextureToArray`
    """
    cdef ccuda.CUarray chArray
    if hArray is None:
        chArray = <ccuda.CUarray><void_ptr>0
    elif isinstance(hArray, (CUarray)):
        phArray = int(hArray)
        chArray = <ccuda.CUarray><void_ptr>phArray
    else:
        phArray = int(CUarray(hArray))
        chArray = <ccuda.CUarray><void_ptr>phArray

    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    err = ccuda.cuTexRefSetArray(chTexRef, chArray, Flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetMipmappedArray(hTexRef, hMipmappedArray, unsigned int Flags):
    """ Binds a mipmapped array to a texture reference.

    [Deprecated]

    Binds the CUDA mipmapped array `hMipmappedArray` to the texture
    reference `hTexRef`. Any previous address or CUDA array state
    associated with the texture reference is superseded by this function.
    `Flags` must be set to :py:obj:`~.CU_TRSA_OVERRIDE_FORMAT`. Any CUDA
    array previously bound to `hTexRef` is unbound.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference to bind
    hMipmappedArray : :py:obj:`~.CUmipmappedArray`
        Mipmapped array to bind
    Flags : unsigned int
        Options (must be :py:obj:`~.CU_TRSA_OVERRIDE_FORMAT`)

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`, :py:obj:`~.cudaBindTextureToMipmappedArray`
    """
    cdef ccuda.CUmipmappedArray chMipmappedArray
    if hMipmappedArray is None:
        chMipmappedArray = <ccuda.CUmipmappedArray><void_ptr>0
    elif isinstance(hMipmappedArray, (CUmipmappedArray)):
        phMipmappedArray = int(hMipmappedArray)
        chMipmappedArray = <ccuda.CUmipmappedArray><void_ptr>phMipmappedArray
    else:
        phMipmappedArray = int(CUmipmappedArray(hMipmappedArray))
        chMipmappedArray = <ccuda.CUmipmappedArray><void_ptr>phMipmappedArray

    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    err = ccuda.cuTexRefSetMipmappedArray(chTexRef, chMipmappedArray, Flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetAddress(hTexRef, dptr, size_t numbytes):
    """ Binds an address as a texture reference.

    [Deprecated]

    Binds a linear address range to the texture reference `hTexRef`. Any
    previous address or CUDA array state associated with the texture
    reference is superseded by this function. Any memory previously bound
    to `hTexRef` is unbound.

    Since the hardware enforces an alignment requirement on texture base
    addresses, :py:obj:`~.cuTexRefSetAddress()` passes back a byte offset
    in `*ByteOffset` that must be applied to texture fetches in order to
    read from the desired memory. This offset must be divided by the texel
    size and passed to kernels that read from the texture so they can be
    applied to the :py:obj:`~.tex1Dfetch()` function.

    If the device memory pointer was returned from
    :py:obj:`~.cuMemAlloc()`, the offset is guaranteed to be 0 and NULL may
    be passed as the `ByteOffset` parameter.

    The total number of elements (or texels) in the linear address range
    cannot exceed
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH`. The
    number of elements is computed as (`numbytes` / bytesPerElement), where
    bytesPerElement is determined from the data format and number of
    components set using :py:obj:`~.cuTexRefSetFormat()`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference to bind
    dptr : :py:obj:`~.CUdeviceptr`
        Device pointer to bind
    numbytes : size_t
        Size of memory to bind in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    ByteOffset : int
        Returned byte offset

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`, :py:obj:`~.cudaBindTexture`
    """
    cdef ccuda.CUdeviceptr cdptr
    if dptr is None:
        cdptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dptr, (CUdeviceptr)):
        pdptr = int(dptr)
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr
    else:
        pdptr = int(CUdeviceptr(dptr))
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr

    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef size_t ByteOffset = 0
    err = ccuda.cuTexRefSetAddress(&ByteOffset, chTexRef, cdptr, numbytes)
    return (CUresult(err), ByteOffset)

@cython.embedsignature(True)
def cuTexRefSetAddress2D(hTexRef, desc : CUDA_ARRAY_DESCRIPTOR, dptr, size_t Pitch):
    """ Binds an address as a 2D texture reference.

    [Deprecated]

    Binds a linear address range to the texture reference `hTexRef`. Any
    previous address or CUDA array state associated with the texture
    reference is superseded by this function. Any memory previously bound
    to `hTexRef` is unbound.

    Using a :py:obj:`~.tex2D()` function inside a kernel requires a call to
    either :py:obj:`~.cuTexRefSetArray()` to bind the corresponding texture
    reference to an array, or :py:obj:`~.cuTexRefSetAddress2D()` to bind
    the texture reference to linear memory.

    Function calls to :py:obj:`~.cuTexRefSetFormat()` cannot follow calls
    to :py:obj:`~.cuTexRefSetAddress2D()` for the same texture reference.

    It is required that `dptr` be aligned to the appropriate hardware-
    specific texture alignment. You can query this value using the device
    attribute :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT`. If an
    unaligned `dptr` is supplied, :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is
    returned.

    `Pitch` has to be aligned to the hardware-specific texture pitch
    alignment. This value can be queried using the device attribute
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT`. If an
    unaligned `Pitch` is supplied, :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is
    returned.

    Width and Height, which are specified in elements (or texels), cannot
    exceed :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH`
    and :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT`
    respectively. `Pitch`, which is specified in bytes, cannot exceed
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference to bind
    desc : :py:obj:`~.CUDA_ARRAY_DESCRIPTOR`
        Descriptor of CUDA array
    dptr : :py:obj:`~.CUdeviceptr`
        Device pointer to bind
    Pitch : size_t
        Line pitch in bytes

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`, :py:obj:`~.cudaBindTexture2D`
    """
    cdef ccuda.CUdeviceptr cdptr
    if dptr is None:
        cdptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dptr, (CUdeviceptr)):
        pdptr = int(dptr)
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr
    else:
        pdptr = int(CUdeviceptr(dptr))
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr

    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef ccuda.CUDA_ARRAY_DESCRIPTOR* cdesc_ptr = desc._ptr if desc != None else NULL
    err = ccuda.cuTexRefSetAddress2D(chTexRef, cdesc_ptr, cdptr, Pitch)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetFormat(hTexRef, fmt not None : CUarray_format, int NumPackedComponents):
    """ Sets the format for a texture reference.

    [Deprecated]

    Specifies the format of the data to be read by the texture reference
    `hTexRef`. `fmt` and `NumPackedComponents` are exactly analogous to the
    :py:obj:`~.Format` and :py:obj:`~.NumChannels` members of the
    :py:obj:`~.CUDA_ARRAY_DESCRIPTOR` structure: They specify the format of
    each component and the number of components per array element.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    fmt : :py:obj:`~.CUarray_format`
        Format to set
    NumPackedComponents : int
        Number of components per array element

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`, :py:obj:`~.cudaCreateChannelDesc`, :py:obj:`~.cudaBindTexture`, :py:obj:`~.cudaBindTexture2D`, :py:obj:`~.cudaBindTextureToArray`, :py:obj:`~.cudaBindTextureToMipmappedArray`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef ccuda.CUarray_format cfmt = fmt.value
    err = ccuda.cuTexRefSetFormat(chTexRef, cfmt, NumPackedComponents)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetAddressMode(hTexRef, int dim, am not None : CUaddress_mode):
    """ Sets the addressing mode for a texture reference.

    [Deprecated]

    Specifies the addressing mode `am` for the given dimension `dim` of the
    texture reference `hTexRef`. If `dim` is zero, the addressing mode is
    applied to the first parameter of the functions used to fetch from the
    texture; if `dim` is 1, the second, and so on.
    :py:obj:`~.CUaddress_mode` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    Note that this call has no effect if `hTexRef` is bound to linear
    memory. Also, if the flag, :py:obj:`~.CU_TRSF_NORMALIZED_COORDINATES`,
    is not set, the only supported address mode is
    :py:obj:`~.CU_TR_ADDRESS_MODE_CLAMP`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    dim : int
        Dimension
    am : :py:obj:`~.CUaddress_mode`
        Addressing mode to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`, :py:obj:`~.cudaBindTexture`, :py:obj:`~.cudaBindTexture2D`, :py:obj:`~.cudaBindTextureToArray`, :py:obj:`~.cudaBindTextureToMipmappedArray`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef ccuda.CUaddress_mode cam = am.value
    err = ccuda.cuTexRefSetAddressMode(chTexRef, dim, cam)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetFilterMode(hTexRef, fm not None : CUfilter_mode):
    """ Sets the filtering mode for a texture reference.

    [Deprecated]

    Specifies the filtering mode `fm` to be used when reading memory
    through the texture reference `hTexRef`. :py:obj:`~.CUfilter_mode_enum`
    is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    Note that this call has no effect if `hTexRef` is bound to linear
    memory.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    fm : :py:obj:`~.CUfilter_mode`
        Filtering mode to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`, :py:obj:`~.cudaBindTextureToArray`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef ccuda.CUfilter_mode cfm = fm.value
    err = ccuda.cuTexRefSetFilterMode(chTexRef, cfm)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetMipmapFilterMode(hTexRef, fm not None : CUfilter_mode):
    """ Sets the mipmap filtering mode for a texture reference.

    [Deprecated]

    Specifies the mipmap filtering mode `fm` to be used when reading memory
    through the texture reference `hTexRef`. :py:obj:`~.CUfilter_mode_enum`
    is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    Note that this call has no effect if `hTexRef` is not bound to a
    mipmapped array.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    fm : :py:obj:`~.CUfilter_mode`
        Filtering mode to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`, :py:obj:`~.cudaBindTextureToMipmappedArray`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef ccuda.CUfilter_mode cfm = fm.value
    err = ccuda.cuTexRefSetMipmapFilterMode(chTexRef, cfm)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetMipmapLevelBias(hTexRef, float bias):
    """ Sets the mipmap level bias for a texture reference.

    [Deprecated]

    Specifies the mipmap level bias `bias` to be added to the specified
    mipmap level when reading memory through the texture reference
    `hTexRef`.

    Note that this call has no effect if `hTexRef` is not bound to a
    mipmapped array.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    bias : float
        Mipmap level bias

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`, :py:obj:`~.cudaBindTextureToMipmappedArray`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    err = ccuda.cuTexRefSetMipmapLevelBias(chTexRef, bias)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetMipmapLevelClamp(hTexRef, float minMipmapLevelClamp, float maxMipmapLevelClamp):
    """ Sets the mipmap min/max mipmap level clamps for a texture reference.

    [Deprecated]

    Specifies the min/max mipmap level clamps, `minMipmapLevelClamp` and
    `maxMipmapLevelClamp` respectively, to be used when reading memory
    through the texture reference `hTexRef`.

    Note that this call has no effect if `hTexRef` is not bound to a
    mipmapped array.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    minMipmapLevelClamp : float
        Mipmap min level clamp
    maxMipmapLevelClamp : float
        Mipmap max level clamp

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`, :py:obj:`~.cudaBindTextureToMipmappedArray`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    err = ccuda.cuTexRefSetMipmapLevelClamp(chTexRef, minMipmapLevelClamp, maxMipmapLevelClamp)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetMaxAnisotropy(hTexRef, unsigned int maxAniso):
    """ Sets the maximum anisotropy for a texture reference.

    [Deprecated]

    Specifies the maximum anisotropy `maxAniso` to be used when reading
    memory through the texture reference `hTexRef`.

    Note that this call has no effect if `hTexRef` is bound to linear
    memory.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    maxAniso : unsigned int
        Maximum anisotropy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`, :py:obj:`~.cudaBindTextureToArray`, :py:obj:`~.cudaBindTextureToMipmappedArray`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    err = ccuda.cuTexRefSetMaxAnisotropy(chTexRef, maxAniso)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetBorderColor(hTexRef, float pBorderColor):
    """ Sets the border color for a texture reference.

    [Deprecated]

    Specifies the value of the RGBA color via the `pBorderColor` to the
    texture reference `hTexRef`. The color value supports only float type
    and holds color components in the following sequence: pBorderColor[0]
    holds 'R' component pBorderColor[1] holds 'G' component pBorderColor[2]
    holds 'B' component pBorderColor[3] holds 'A' component

    Note that the color values can be set only when the Address mode is set
    to CU_TR_ADDRESS_MODE_BORDER using :py:obj:`~.cuTexRefSetAddressMode`.
    Applications using integer border color values have to
    "reinterpret_cast" their values to float.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    pBorderColor : float
        RGBA color

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetBorderColor`, :py:obj:`~.cudaBindTexture`, :py:obj:`~.cudaBindTexture2D`, :py:obj:`~.cudaBindTextureToArray`, :py:obj:`~.cudaBindTextureToMipmappedArray`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    err = ccuda.cuTexRefSetBorderColor(chTexRef, &pBorderColor)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefSetFlags(hTexRef, unsigned int Flags):
    """ Sets the flags for a texture reference.

    [Deprecated]

    Specifies optional flags via `Flags` to specify the behavior of data
    returned through the texture reference `hTexRef`. The valid flags are:

    - :py:obj:`~.CU_TRSF_READ_AS_INTEGER`, which suppresses the default
      behavior of having the texture promote integer data to floating point
      data in the range [0, 1]. Note that texture with 32-bit integer
      format would not be promoted, regardless of whether or not this flag
      is specified;

    - :py:obj:`~.CU_TRSF_NORMALIZED_COORDINATES`, which suppresses the
      default behavior of having the texture coordinates range from [0,
      Dim) where Dim is the width or height of the CUDA array. Instead, the
      texture coordinates [0, 1.0) reference the entire breadth of the
      array dimension;

    - :py:obj:`~.CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION`, which disables
      any trilinear filtering optimizations. Trilinear optimizations
      improve texture filtering performance by allowing bilinear filtering
      on textures in scenarios where it can closely approximate the
      expected results.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    Flags : unsigned int
        Optional flags to set

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`, :py:obj:`~.cudaBindTexture`, :py:obj:`~.cudaBindTexture2D`, :py:obj:`~.cudaBindTextureToArray`, :py:obj:`~.cudaBindTextureToMipmappedArray`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    err = ccuda.cuTexRefSetFlags(chTexRef, Flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexRefGetAddress(hTexRef):
    """ Gets the address associated with a texture reference.

    [Deprecated]

    Returns in `*pdptr` the base address bound to the texture reference
    `hTexRef`, or returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if the
    texture reference is not bound to any device memory range.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pdptr : :py:obj:`~.CUdeviceptr`
        Returned device address

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef CUdeviceptr pdptr = CUdeviceptr()
    err = ccuda.cuTexRefGetAddress(pdptr._ptr, chTexRef)
    return (CUresult(err), pdptr)

@cython.embedsignature(True)
def cuTexRefGetArray(hTexRef):
    """ Gets the array bound to a texture reference.

    [Deprecated]

    Returns in `*phArray` the CUDA array bound to the texture reference
    `hTexRef`, or returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if the
    texture reference is not bound to any CUDA array.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phArray : :py:obj:`~.CUarray`
        Returned array

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef CUarray phArray = CUarray()
    err = ccuda.cuTexRefGetArray(phArray._ptr, chTexRef)
    return (CUresult(err), phArray)

@cython.embedsignature(True)
def cuTexRefGetMipmappedArray(hTexRef):
    """ Gets the mipmapped array bound to a texture reference.

    [Deprecated]

    Returns in `*phMipmappedArray` the CUDA mipmapped array bound to the
    texture reference `hTexRef`, or returns
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if the texture reference is not
    bound to any CUDA mipmapped array.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phMipmappedArray : :py:obj:`~.CUmipmappedArray`
        Returned mipmapped array

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef CUmipmappedArray phMipmappedArray = CUmipmappedArray()
    err = ccuda.cuTexRefGetMipmappedArray(phMipmappedArray._ptr, chTexRef)
    return (CUresult(err), phMipmappedArray)

@cython.embedsignature(True)
def cuTexRefGetAddressMode(hTexRef, int dim):
    """ Gets the addressing mode used by a texture reference.

    [Deprecated]

    Returns in `*pam` the addressing mode corresponding to the dimension
    `dim` of the texture reference `hTexRef`. Currently, the only valid
    value for `dim` are 0 and 1.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference
    dim : int
        Dimension

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pam : :py:obj:`~.CUaddress_mode`
        Returned addressing mode

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef ccuda.CUaddress_mode pam
    err = ccuda.cuTexRefGetAddressMode(&pam, chTexRef, dim)
    return (CUresult(err), CUaddress_mode(pam))

@cython.embedsignature(True)
def cuTexRefGetFilterMode(hTexRef):
    """ Gets the filter-mode used by a texture reference.

    [Deprecated]

    Returns in `*pfm` the filtering mode of the texture reference
    `hTexRef`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pfm : :py:obj:`~.CUfilter_mode`
        Returned filtering mode

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef ccuda.CUfilter_mode pfm
    err = ccuda.cuTexRefGetFilterMode(&pfm, chTexRef)
    return (CUresult(err), CUfilter_mode(pfm))

@cython.embedsignature(True)
def cuTexRefGetFormat(hTexRef):
    """ Gets the format used by a texture reference.

    [Deprecated]

    Returns in `*pFormat` and `*pNumChannels` the format and number of
    components of the CUDA array bound to the texture reference `hTexRef`.
    If `pFormat` or `pNumChannels` is NULL, it will be ignored.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pFormat : :py:obj:`~.CUarray_format`
        Returned format
    pNumChannels : int
        Returned number of components

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef ccuda.CUarray_format pFormat
    cdef int pNumChannels = 0
    err = ccuda.cuTexRefGetFormat(&pFormat, &pNumChannels, chTexRef)
    return (CUresult(err), CUarray_format(pFormat), pNumChannels)

@cython.embedsignature(True)
def cuTexRefGetMipmapFilterMode(hTexRef):
    """ Gets the mipmap filtering mode for a texture reference.

    [Deprecated]

    Returns the mipmap filtering mode in `pfm` that's used when reading
    memory through the texture reference `hTexRef`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pfm : :py:obj:`~.CUfilter_mode`
        Returned mipmap filtering mode

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef ccuda.CUfilter_mode pfm
    err = ccuda.cuTexRefGetMipmapFilterMode(&pfm, chTexRef)
    return (CUresult(err), CUfilter_mode(pfm))

@cython.embedsignature(True)
def cuTexRefGetMipmapLevelBias(hTexRef):
    """ Gets the mipmap level bias for a texture reference.

    [Deprecated]

    Returns the mipmap level bias in `pBias` that's added to the specified
    mipmap level when reading memory through the texture reference
    `hTexRef`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pbias : float
        Returned mipmap level bias

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef float pbias = 0
    err = ccuda.cuTexRefGetMipmapLevelBias(&pbias, chTexRef)
    return (CUresult(err), pbias)

@cython.embedsignature(True)
def cuTexRefGetMipmapLevelClamp(hTexRef):
    """ Gets the min/max mipmap level clamps for a texture reference.

    [Deprecated]

    Returns the min/max mipmap level clamps in `pminMipmapLevelClamp` and
    `pmaxMipmapLevelClamp` that's used when reading memory through the
    texture reference `hTexRef`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pminMipmapLevelClamp : float
        Returned mipmap min level clamp
    pmaxMipmapLevelClamp : float
        Returned mipmap max level clamp

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef float pminMipmapLevelClamp = 0
    cdef float pmaxMipmapLevelClamp = 0
    err = ccuda.cuTexRefGetMipmapLevelClamp(&pminMipmapLevelClamp, &pmaxMipmapLevelClamp, chTexRef)
    return (CUresult(err), pminMipmapLevelClamp, pmaxMipmapLevelClamp)

@cython.embedsignature(True)
def cuTexRefGetMaxAnisotropy(hTexRef):
    """ Gets the maximum anisotropy for a texture reference.

    [Deprecated]

    Returns the maximum anisotropy in `pmaxAniso` that's used when reading
    memory through the texture reference `hTexRef`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pmaxAniso : int
        Returned maximum anisotropy

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFlags`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef int pmaxAniso = 0
    err = ccuda.cuTexRefGetMaxAnisotropy(&pmaxAniso, chTexRef)
    return (CUresult(err), pmaxAniso)

@cython.embedsignature(True)
def cuTexRefGetBorderColor(hTexRef):
    """ Gets the border color used by a texture reference.

    [Deprecated]

    Returns in `pBorderColor`, values of the RGBA color used by the texture
    reference `hTexRef`. The color value is of type float and holds color
    components in the following sequence: pBorderColor[0] holds 'R'
    component pBorderColor[1] holds 'G' component pBorderColor[2] holds 'B'
    component pBorderColor[3] holds 'A' component

    Parameters
    ----------
    pBorderColor : :py:obj:`~.CUtexref`
        Returned Type and Value of RGBA color

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    hTexRef : float
        Texture reference

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetBorderColor`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef float pBorderColor = 0
    err = ccuda.cuTexRefGetBorderColor(&pBorderColor, chTexRef)
    return (CUresult(err), pBorderColor)

@cython.embedsignature(True)
def cuTexRefGetFlags(hTexRef):
    """ Gets the flags used by a texture reference.

    [Deprecated]

    Returns in `*pFlags` the flags of the texture reference `hTexRef`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pFlags : unsigned int
        Returned flags

    See Also
    --------
    :py:obj:`~.cuTexRefSetAddress`, :py:obj:`~.cuTexRefSetAddress2D`, :py:obj:`~.cuTexRefSetAddressMode`, :py:obj:`~.cuTexRefSetArray`, :py:obj:`~.cuTexRefSetFilterMode`, :py:obj:`~.cuTexRefSetFlags`, :py:obj:`~.cuTexRefSetFormat`, :py:obj:`~.cuTexRefGetAddress`, :py:obj:`~.cuTexRefGetAddressMode`, :py:obj:`~.cuTexRefGetArray`, :py:obj:`~.cuTexRefGetFilterMode`, :py:obj:`~.cuTexRefGetFormat`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    cdef unsigned int pFlags = 0
    err = ccuda.cuTexRefGetFlags(&pFlags, chTexRef)
    return (CUresult(err), pFlags)

@cython.embedsignature(True)
def cuTexRefCreate():
    """ Creates a texture reference.

    [Deprecated]

    Creates a texture reference and returns its handle in `*pTexRef`. Once
    created, the application must call :py:obj:`~.cuTexRefSetArray()` or
    :py:obj:`~.cuTexRefSetAddress()` to associate the reference with
    allocated memory. Other texture reference functions are used to specify
    the format and interpretation (addressing, filtering, etc.) to be used
    when the memory is read through this texture reference.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pTexRef : :py:obj:`~.CUtexref`
        Returned texture reference

    See Also
    --------
    :py:obj:`~.cuTexRefDestroy`
    """
    cdef CUtexref pTexRef = CUtexref()
    err = ccuda.cuTexRefCreate(pTexRef._ptr)
    return (CUresult(err), pTexRef)

@cython.embedsignature(True)
def cuTexRefDestroy(hTexRef):
    """ Destroys a texture reference.

    [Deprecated]

    Destroys the texture reference specified by `hTexRef`.

    Parameters
    ----------
    hTexRef : :py:obj:`~.CUtexref`
        Texture reference to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexRefCreate`
    """
    cdef ccuda.CUtexref chTexRef
    if hTexRef is None:
        chTexRef = <ccuda.CUtexref><void_ptr>0
    elif isinstance(hTexRef, (CUtexref)):
        phTexRef = int(hTexRef)
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef
    else:
        phTexRef = int(CUtexref(hTexRef))
        chTexRef = <ccuda.CUtexref><void_ptr>phTexRef

    err = ccuda.cuTexRefDestroy(chTexRef)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuSurfRefSetArray(hSurfRef, hArray, unsigned int Flags):
    """ Sets the CUDA array for a surface reference.

    [Deprecated]

    Sets the CUDA array `hArray` to be read and written by the surface
    reference `hSurfRef`. Any previous CUDA array state associated with the
    surface reference is superseded by this function. `Flags` must be set
    to 0. The :py:obj:`~.CUDA_ARRAY3D_SURFACE_LDST` flag must have been set
    for the CUDA array. Any CUDA array previously bound to `hSurfRef` is
    unbound.

    Parameters
    ----------
    hSurfRef : :py:obj:`~.CUsurfref`
        Surface reference handle
    hArray : :py:obj:`~.CUarray`
        CUDA array handle
    Flags : unsigned int
        set to 0

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuModuleGetSurfRef`, :py:obj:`~.cuSurfRefGetArray`, :py:obj:`~.cudaBindSurfaceToArray`
    """
    cdef ccuda.CUarray chArray
    if hArray is None:
        chArray = <ccuda.CUarray><void_ptr>0
    elif isinstance(hArray, (CUarray)):
        phArray = int(hArray)
        chArray = <ccuda.CUarray><void_ptr>phArray
    else:
        phArray = int(CUarray(hArray))
        chArray = <ccuda.CUarray><void_ptr>phArray

    cdef ccuda.CUsurfref chSurfRef
    if hSurfRef is None:
        chSurfRef = <ccuda.CUsurfref><void_ptr>0
    elif isinstance(hSurfRef, (CUsurfref)):
        phSurfRef = int(hSurfRef)
        chSurfRef = <ccuda.CUsurfref><void_ptr>phSurfRef
    else:
        phSurfRef = int(CUsurfref(hSurfRef))
        chSurfRef = <ccuda.CUsurfref><void_ptr>phSurfRef

    err = ccuda.cuSurfRefSetArray(chSurfRef, chArray, Flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuSurfRefGetArray(hSurfRef):
    """ Passes back the CUDA array bound to a surface reference.

    [Deprecated]

    Returns in `*phArray` the CUDA array bound to the surface reference
    `hSurfRef`, or returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if the
    surface reference is not bound to any CUDA array.

    Parameters
    ----------
    hSurfRef : :py:obj:`~.CUsurfref`
        Surface reference handle

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    phArray : :py:obj:`~.CUarray`
        Surface reference handle

    See Also
    --------
    :py:obj:`~.cuModuleGetSurfRef`, :py:obj:`~.cuSurfRefSetArray`
    """
    cdef ccuda.CUsurfref chSurfRef
    if hSurfRef is None:
        chSurfRef = <ccuda.CUsurfref><void_ptr>0
    elif isinstance(hSurfRef, (CUsurfref)):
        phSurfRef = int(hSurfRef)
        chSurfRef = <ccuda.CUsurfref><void_ptr>phSurfRef
    else:
        phSurfRef = int(CUsurfref(hSurfRef))
        chSurfRef = <ccuda.CUsurfref><void_ptr>phSurfRef

    cdef CUarray phArray = CUarray()
    err = ccuda.cuSurfRefGetArray(phArray._ptr, chSurfRef)
    return (CUresult(err), phArray)

@cython.embedsignature(True)
def cuTexObjectCreate(pResDesc : CUDA_RESOURCE_DESC, pTexDesc : CUDA_TEXTURE_DESC, pResViewDesc : CUDA_RESOURCE_VIEW_DESC):
    """ Creates a texture object.

    Creates a texture object and returns it in `pTexObject`. `pResDesc`
    describes the data to texture from. `pTexDesc` describes how the data
    should be sampled. `pResViewDesc` is an optional argument that
    specifies an alternate format for the data described by `pResDesc`, and
    also describes the subresource region to restrict access to when
    texturing. `pResViewDesc` can only be specified if the type of resource
    is a CUDA array or a CUDA mipmapped array.

    Texture objects are only supported on devices of compute capability 3.0
    or higher. Additionally, a texture object is an opaque value, and, as
    such, should only be accessed through CUDA API calls.

    The :py:obj:`~.CUDA_RESOURCE_DESC` structure is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.CUDA_RESOURCE_DESC.resType` specifies the type of resource
      to texture from. CUresourceType is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    If :py:obj:`~.CUDA_RESOURCE_DESC.resType` is set to
    :py:obj:`~.CU_RESOURCE_TYPE_ARRAY`,
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::array::hArray must be set to a
    valid CUDA array handle.

    If :py:obj:`~.CUDA_RESOURCE_DESC.resType` is set to
    :py:obj:`~.CU_RESOURCE_TYPE_MIPMAPPED_ARRAY`,
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::mipmap::hMipmappedArray must be
    set to a valid CUDA mipmapped array handle.

    If :py:obj:`~.CUDA_RESOURCE_DESC.resType` is set to
    :py:obj:`~.CU_RESOURCE_TYPE_LINEAR`,
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::linear::devPtr must be set to a
    valid device pointer, that is aligned to
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT`.
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::linear::format and
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::linear::numChannels describe the
    format of each component and the number of components per array
    element. :py:obj:`~.CUDA_RESOURCE_DESC`::res::linear::sizeInBytes
    specifies the size of the array in bytes. The total number of elements
    in the linear address range cannot exceed
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH`. The
    number of elements is computed as (sizeInBytes / (sizeof(format) *
    numChannels)).

    If :py:obj:`~.CUDA_RESOURCE_DESC.resType` is set to
    :py:obj:`~.CU_RESOURCE_TYPE_PITCH2D`,
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::devPtr must be set to a
    valid device pointer, that is aligned to
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT`.
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::format and
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::numChannels describe the
    format of each component and the number of components per array
    element. :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::width and
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::height specify the width
    and height of the array in elements, and cannot exceed
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH` and
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT`
    respectively.
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::pitch2D::pitchInBytes specifies
    the pitch between two rows in bytes and has to be aligned to
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT`. Pitch cannot
    exceed :py:obj:`~.CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH`.

    - :py:obj:`~.flags` must be set to zero.

    The :py:obj:`~.CUDA_TEXTURE_DESC` struct is defined as

    **View CUDA Toolkit Documentation for a C++ code example**

    where

    - :py:obj:`~.CUDA_TEXTURE_DESC.addressMode` specifies the addressing
      mode for each dimension of the texture data.
      :py:obj:`~.CUaddress_mode` is defined as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - This is ignored if :py:obj:`~.CUDA_RESOURCE_DESC.resType` is
      :py:obj:`~.CU_RESOURCE_TYPE_LINEAR`. Also, if the flag,
      :py:obj:`~.CU_TRSF_NORMALIZED_COORDINATES` is not set, the only
      supported address mode is :py:obj:`~.CU_TR_ADDRESS_MODE_CLAMP`.

    - :py:obj:`~.CUDA_TEXTURE_DESC.filterMode` specifies the filtering mode
      to be used when fetching from the texture. CUfilter_mode is defined
      as:

    - **View CUDA Toolkit Documentation for a C++ code example**

    - This is ignored if :py:obj:`~.CUDA_RESOURCE_DESC.resType` is
      :py:obj:`~.CU_RESOURCE_TYPE_LINEAR`.

    - :py:obj:`~.CUDA_TEXTURE_DESC.flags` can be any combination of the
      following:

      - :py:obj:`~.CU_TRSF_READ_AS_INTEGER`, which suppresses the default
        behavior of having the texture promote integer data to floating
        point data in the range [0, 1]. Note that texture with 32-bit
        integer format would not be promoted, regardless of whether or not
        this flag is specified.

      - :py:obj:`~.CU_TRSF_NORMALIZED_COORDINATES`, which suppresses the
        default behavior of having the texture coordinates range from [0,
        Dim) where Dim is the width or height of the CUDA array. Instead,
        the texture coordinates [0, 1.0) reference the entire breadth of
        the array dimension; Note that for CUDA mipmapped arrays, this flag
        has to be set.

      - :py:obj:`~.CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION`, which disables
        any trilinear filtering optimizations. Trilinear optimizations
        improve texture filtering performance by allowing bilinear
        filtering on textures in scenarios where it can closely approximate
        the expected results.

      - :py:obj:`~.CU_TRSF_SEAMLESS_CUBEMAP`, which enables seamless cube
        map filtering. This flag can only be specified if the underlying
        resource is a CUDA array or a CUDA mipmapped array that was created
        with the flag :py:obj:`~.CUDA_ARRAY3D_CUBEMAP`. When seamless cube
        map filtering is enabled, texture address modes specified by
        :py:obj:`~.CUDA_TEXTURE_DESC.addressMode` are ignored. Instead, if
        the :py:obj:`~.CUDA_TEXTURE_DESC.filterMode` is set to
        :py:obj:`~.CU_TR_FILTER_MODE_POINT` the address mode
        :py:obj:`~.CU_TR_ADDRESS_MODE_CLAMP` will be applied for all
        dimensions. If the :py:obj:`~.CUDA_TEXTURE_DESC.filterMode` is set
        to :py:obj:`~.CU_TR_FILTER_MODE_LINEAR` seamless cube map filtering
        will be performed when sampling along the cube face borders.

    - :py:obj:`~.CUDA_TEXTURE_DESC.maxAnisotropy` specifies the maximum
      anisotropy ratio to be used when doing anisotropic filtering. This
      value will be clamped to the range [1,16].

    - :py:obj:`~.CUDA_TEXTURE_DESC.mipmapFilterMode` specifies the filter
      mode when the calculated mipmap level lies between two defined mipmap
      levels.

    - :py:obj:`~.CUDA_TEXTURE_DESC.mipmapLevelBias` specifies the offset to
      be applied to the calculated mipmap level.

    - :py:obj:`~.CUDA_TEXTURE_DESC.minMipmapLevelClamp` specifies the lower
      end of the mipmap level range to clamp access to.

    - :py:obj:`~.CUDA_TEXTURE_DESC.maxMipmapLevelClamp` specifies the upper
      end of the mipmap level range to clamp access to.

    The :py:obj:`~.CUDA_RESOURCE_VIEW_DESC` struct is defined as

    **View CUDA Toolkit Documentation for a C++ code example**

    where:

    - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.format` specifies how the data
      contained in the CUDA array or CUDA mipmapped array should be
      interpreted. Note that this can incur a change in size of the texture
      data. If the resource view format is a block compressed format, then
      the underlying CUDA array or CUDA mipmapped array has to have a base
      of format :py:obj:`~.CU_AD_FORMAT_UNSIGNED_INT32`. with 2 or 4
      channels, depending on the block compressed format. For ex., BC1 and
      BC4 require the underlying CUDA array to have a format of
      :py:obj:`~.CU_AD_FORMAT_UNSIGNED_INT32` with 2 channels. The other BC
      formats require the underlying resource to have the same base format
      but with 4 channels.

    - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.width` specifies the new width of
      the texture data. If the resource view format is a block compressed
      format, this value has to be 4 times the original width of the
      resource. For non block compressed formats, this value has to be
      equal to that of the original resource.

    - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.height` specifies the new height
      of the texture data. If the resource view format is a block
      compressed format, this value has to be 4 times the original height
      of the resource. For non block compressed formats, this value has to
      be equal to that of the original resource.

    - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.depth` specifies the new depth of
      the texture data. This value has to be equal to that of the original
      resource.

    - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.firstMipmapLevel` specifies the
      most detailed mipmap level. This will be the new mipmap level zero.
      For non-mipmapped resources, this value has to be
      zero.:py:obj:`~.CUDA_TEXTURE_DESC.minMipmapLevelClamp` and
      :py:obj:`~.CUDA_TEXTURE_DESC.maxMipmapLevelClamp` will be relative to
      this value. For ex., if the firstMipmapLevel is set to 2, and a
      minMipmapLevelClamp of 1.2 is specified, then the actual minimum
      mipmap level clamp will be 3.2.

    - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.lastMipmapLevel` specifies the
      least detailed mipmap level. For non-mipmapped resources, this value
      has to be zero.

    - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.firstLayer` specifies the first
      layer index for layered textures. This will be the new layer zero.
      For non-layered resources, this value has to be zero.

    - :py:obj:`~.CUDA_RESOURCE_VIEW_DESC.lastLayer` specifies the last
      layer index for layered textures. For non-layered resources, this
      value has to be zero.

    Parameters
    ----------
    pResDesc : :py:obj:`~.CUDA_RESOURCE_DESC`
        Resource descriptor
    pTexDesc : :py:obj:`~.CUDA_TEXTURE_DESC`
        Texture descriptor
    pResViewDesc : :py:obj:`~.CUDA_RESOURCE_VIEW_DESC`
        Resource view descriptor

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pTexObject : :py:obj:`~.CUtexObject`
        Texture object to create

    See Also
    --------
    :py:obj:`~.cuTexObjectDestroy`, :py:obj:`~.cudaCreateTextureObject`
    """
    cdef CUtexObject pTexObject = CUtexObject()
    cdef ccuda.CUDA_RESOURCE_DESC* cpResDesc_ptr = pResDesc._ptr if pResDesc != None else NULL
    cdef ccuda.CUDA_TEXTURE_DESC* cpTexDesc_ptr = pTexDesc._ptr if pTexDesc != None else NULL
    cdef ccuda.CUDA_RESOURCE_VIEW_DESC* cpResViewDesc_ptr = pResViewDesc._ptr if pResViewDesc != None else NULL
    err = ccuda.cuTexObjectCreate(pTexObject._ptr, cpResDesc_ptr, cpTexDesc_ptr, cpResViewDesc_ptr)
    return (CUresult(err), pTexObject)

@cython.embedsignature(True)
def cuTexObjectDestroy(texObject):
    """ Destroys a texture object.

    Destroys the texture object specified by `texObject`.

    Parameters
    ----------
    texObject : :py:obj:`~.CUtexObject`
        Texture object to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuTexObjectCreate`, :py:obj:`~.cudaDestroyTextureObject`
    """
    cdef ccuda.CUtexObject ctexObject
    if texObject is None:
        ctexObject = <ccuda.CUtexObject><void_ptr>0
    elif isinstance(texObject, (CUtexObject)):
        ptexObject = int(texObject)
        ctexObject = <ccuda.CUtexObject><void_ptr>ptexObject
    else:
        ptexObject = int(CUtexObject(texObject))
        ctexObject = <ccuda.CUtexObject><void_ptr>ptexObject

    err = ccuda.cuTexObjectDestroy(ctexObject)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuTexObjectGetResourceDesc(texObject):
    """ Returns a texture object's resource descriptor.

    Returns the resource descriptor for the texture object specified by
    `texObject`.

    Parameters
    ----------
    texObject : :py:obj:`~.CUtexObject`
        Texture object

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pResDesc : :py:obj:`~.CUDA_RESOURCE_DESC`
        Resource descriptor

    See Also
    --------
    :py:obj:`~.cuTexObjectCreate`, :py:obj:`~.cudaGetTextureObjectResourceDesc`,
    """
    cdef ccuda.CUtexObject ctexObject
    if texObject is None:
        ctexObject = <ccuda.CUtexObject><void_ptr>0
    elif isinstance(texObject, (CUtexObject)):
        ptexObject = int(texObject)
        ctexObject = <ccuda.CUtexObject><void_ptr>ptexObject
    else:
        ptexObject = int(CUtexObject(texObject))
        ctexObject = <ccuda.CUtexObject><void_ptr>ptexObject

    cdef CUDA_RESOURCE_DESC pResDesc = CUDA_RESOURCE_DESC()
    err = ccuda.cuTexObjectGetResourceDesc(pResDesc._ptr, ctexObject)
    return (CUresult(err), pResDesc)

@cython.embedsignature(True)
def cuTexObjectGetTextureDesc(texObject):
    """ Returns a texture object's texture descriptor.

    Returns the texture descriptor for the texture object specified by
    `texObject`.

    Parameters
    ----------
    texObject : :py:obj:`~.CUtexObject`
        Texture object

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pTexDesc : :py:obj:`~.CUDA_TEXTURE_DESC`
        Texture descriptor

    See Also
    --------
    :py:obj:`~.cuTexObjectCreate`, :py:obj:`~.cudaGetTextureObjectTextureDesc`
    """
    cdef ccuda.CUtexObject ctexObject
    if texObject is None:
        ctexObject = <ccuda.CUtexObject><void_ptr>0
    elif isinstance(texObject, (CUtexObject)):
        ptexObject = int(texObject)
        ctexObject = <ccuda.CUtexObject><void_ptr>ptexObject
    else:
        ptexObject = int(CUtexObject(texObject))
        ctexObject = <ccuda.CUtexObject><void_ptr>ptexObject

    cdef CUDA_TEXTURE_DESC pTexDesc = CUDA_TEXTURE_DESC()
    err = ccuda.cuTexObjectGetTextureDesc(pTexDesc._ptr, ctexObject)
    return (CUresult(err), pTexDesc)

@cython.embedsignature(True)
def cuTexObjectGetResourceViewDesc(texObject):
    """ Returns a texture object's resource view descriptor.

    Returns the resource view descriptor for the texture object specified
    by `texObject`. If no resource view was set for `texObject`, the
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned.

    Parameters
    ----------
    texObject : :py:obj:`~.CUtexObject`
        Texture object

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pResViewDesc : :py:obj:`~.CUDA_RESOURCE_VIEW_DESC`
        Resource view descriptor

    See Also
    --------
    :py:obj:`~.cuTexObjectCreate`, :py:obj:`~.cudaGetTextureObjectResourceViewDesc`
    """
    cdef ccuda.CUtexObject ctexObject
    if texObject is None:
        ctexObject = <ccuda.CUtexObject><void_ptr>0
    elif isinstance(texObject, (CUtexObject)):
        ptexObject = int(texObject)
        ctexObject = <ccuda.CUtexObject><void_ptr>ptexObject
    else:
        ptexObject = int(CUtexObject(texObject))
        ctexObject = <ccuda.CUtexObject><void_ptr>ptexObject

    cdef CUDA_RESOURCE_VIEW_DESC pResViewDesc = CUDA_RESOURCE_VIEW_DESC()
    err = ccuda.cuTexObjectGetResourceViewDesc(pResViewDesc._ptr, ctexObject)
    return (CUresult(err), pResViewDesc)

@cython.embedsignature(True)
def cuSurfObjectCreate(pResDesc : CUDA_RESOURCE_DESC):
    """ Creates a surface object.

    Creates a surface object and returns it in `pSurfObject`. `pResDesc`
    describes the data to perform surface load/stores on.
    :py:obj:`~.CUDA_RESOURCE_DESC.resType` must be
    :py:obj:`~.CU_RESOURCE_TYPE_ARRAY` and
    :py:obj:`~.CUDA_RESOURCE_DESC`::res::array::hArray must be set to a
    valid CUDA array handle. :py:obj:`~.CUDA_RESOURCE_DESC.flags` must be
    set to zero.

    Surface objects are only supported on devices of compute capability 3.0
    or higher. Additionally, a surface object is an opaque value, and, as
    such, should only be accessed through CUDA API calls.

    Parameters
    ----------
    pResDesc : :py:obj:`~.CUDA_RESOURCE_DESC`
        Resource descriptor

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pSurfObject : :py:obj:`~.CUsurfObject`
        Surface object to create

    See Also
    --------
    :py:obj:`~.cuSurfObjectDestroy`, :py:obj:`~.cudaCreateSurfaceObject`
    """
    cdef CUsurfObject pSurfObject = CUsurfObject()
    cdef ccuda.CUDA_RESOURCE_DESC* cpResDesc_ptr = pResDesc._ptr if pResDesc != None else NULL
    err = ccuda.cuSurfObjectCreate(pSurfObject._ptr, cpResDesc_ptr)
    return (CUresult(err), pSurfObject)

@cython.embedsignature(True)
def cuSurfObjectDestroy(surfObject):
    """ Destroys a surface object.

    Destroys the surface object specified by `surfObject`.

    Parameters
    ----------
    surfObject : :py:obj:`~.CUsurfObject`
        Surface object to destroy

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuSurfObjectCreate`, :py:obj:`~.cudaDestroySurfaceObject`
    """
    cdef ccuda.CUsurfObject csurfObject
    if surfObject is None:
        csurfObject = <ccuda.CUsurfObject><void_ptr>0
    elif isinstance(surfObject, (CUsurfObject)):
        psurfObject = int(surfObject)
        csurfObject = <ccuda.CUsurfObject><void_ptr>psurfObject
    else:
        psurfObject = int(CUsurfObject(surfObject))
        csurfObject = <ccuda.CUsurfObject><void_ptr>psurfObject

    err = ccuda.cuSurfObjectDestroy(csurfObject)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuSurfObjectGetResourceDesc(surfObject):
    """ Returns a surface object's resource descriptor.

    Returns the resource descriptor for the surface object specified by
    `surfObject`.

    Parameters
    ----------
    surfObject : :py:obj:`~.CUsurfObject`
        Surface object

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pResDesc : :py:obj:`~.CUDA_RESOURCE_DESC`
        Resource descriptor

    See Also
    --------
    :py:obj:`~.cuSurfObjectCreate`, :py:obj:`~.cudaGetSurfaceObjectResourceDesc`
    """
    cdef ccuda.CUsurfObject csurfObject
    if surfObject is None:
        csurfObject = <ccuda.CUsurfObject><void_ptr>0
    elif isinstance(surfObject, (CUsurfObject)):
        psurfObject = int(surfObject)
        csurfObject = <ccuda.CUsurfObject><void_ptr>psurfObject
    else:
        psurfObject = int(CUsurfObject(surfObject))
        csurfObject = <ccuda.CUsurfObject><void_ptr>psurfObject

    cdef CUDA_RESOURCE_DESC pResDesc = CUDA_RESOURCE_DESC()
    err = ccuda.cuSurfObjectGetResourceDesc(pResDesc._ptr, csurfObject)
    return (CUresult(err), pResDesc)

@cython.embedsignature(True)
def cuDeviceCanAccessPeer(dev, peerDev):
    """ Queries if a device may directly access a peer device's memory.

    Returns in `*canAccessPeer` a value of 1 if contexts on `dev` are
    capable of directly accessing memory from contexts on `peerDev` and 0
    otherwise. If direct access of `peerDev` from `dev` is possible, then
    access may be enabled on two specific contexts by calling
    :py:obj:`~.cuCtxEnablePeerAccess()`.

    Parameters
    ----------
    dev : :py:obj:`~.CUdevice`
        Device from which allocations on `peerDev` are to be directly
        accessed.
    peerDev : :py:obj:`~.CUdevice`
        Device on which the allocations to be directly accessed by `dev`
        reside.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`
    canAccessPeer : int
        Returned access capability

    See Also
    --------
    :py:obj:`~.cuCtxEnablePeerAccess`, :py:obj:`~.cuCtxDisablePeerAccess`, :py:obj:`~.cudaDeviceCanAccessPeer`
    """
    cdef ccuda.CUdevice cpeerDev
    if peerDev is None:
        cpeerDev = <ccuda.CUdevice>0
    elif isinstance(peerDev, (CUdevice)):
        ppeerDev = int(peerDev)
        cpeerDev = <ccuda.CUdevice>ppeerDev
    else:
        ppeerDev = int(CUdevice(peerDev))
        cpeerDev = <ccuda.CUdevice>ppeerDev

    cdef ccuda.CUdevice cdev
    if dev is None:
        cdev = <ccuda.CUdevice>0
    elif isinstance(dev, (CUdevice)):
        pdev = int(dev)
        cdev = <ccuda.CUdevice>pdev
    else:
        pdev = int(CUdevice(dev))
        cdev = <ccuda.CUdevice>pdev

    cdef int canAccessPeer = 0
    err = ccuda.cuDeviceCanAccessPeer(&canAccessPeer, cdev, cpeerDev)
    return (CUresult(err), canAccessPeer)

@cython.embedsignature(True)
def cuCtxEnablePeerAccess(peerContext, unsigned int Flags):
    """ Enables direct access to memory allocations in a peer context.

    If both the current context and `peerContext` are on devices which
    support unified addressing (as may be queried using
    :py:obj:`~.CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING`) and same major
    compute capability, then on success all allocations from `peerContext`
    will immediately be accessible by the current context. See
    :py:obj:`~.Unified Addressing` for additional details.

    Note that access granted by this call is unidirectional and that in
    order to access memory from the current context in `peerContext`, a
    separate symmetric call to :py:obj:`~.cuCtxEnablePeerAccess()` is
    required.

    Note that there are both device-wide and system-wide limitations per
    system configuration, as noted in the CUDA Programming Guide under the
    section "Peer-to-Peer Memory Access".

    Returns :py:obj:`~.CUDA_ERROR_PEER_ACCESS_UNSUPPORTED` if
    :py:obj:`~.cuDeviceCanAccessPeer()` indicates that the
    :py:obj:`~.CUdevice` of the current context cannot directly access
    memory from the :py:obj:`~.CUdevice` of `peerContext`.

    Returns :py:obj:`~.CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED` if direct
    access of `peerContext` from the current context has already been
    enabled.

    Returns :py:obj:`~.CUDA_ERROR_TOO_MANY_PEERS` if direct peer access is
    not possible because hardware resources required for peer access have
    been exhausted.

    Returns :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` if there is no current
    context, `peerContext` is not a valid context, or if the current
    context is `peerContext`.

    Returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if `Flags` is not 0.

    Parameters
    ----------
    peerContext : :py:obj:`~.CUcontext`
        Peer context to enable direct access to from the current context
    Flags : unsigned int
        Reserved for future use and must be set to 0

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED`, :py:obj:`~.CUDA_ERROR_TOO_MANY_PEERS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_PEER_ACCESS_UNSUPPORTED`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`

    See Also
    --------
    :py:obj:`~.cuDeviceCanAccessPeer`, :py:obj:`~.cuCtxDisablePeerAccess`, :py:obj:`~.cudaDeviceEnablePeerAccess`
    """
    cdef ccuda.CUcontext cpeerContext
    if peerContext is None:
        cpeerContext = <ccuda.CUcontext><void_ptr>0
    elif isinstance(peerContext, (CUcontext)):
        ppeerContext = int(peerContext)
        cpeerContext = <ccuda.CUcontext><void_ptr>ppeerContext
    else:
        ppeerContext = int(CUcontext(peerContext))
        cpeerContext = <ccuda.CUcontext><void_ptr>ppeerContext

    err = ccuda.cuCtxEnablePeerAccess(cpeerContext, Flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuCtxDisablePeerAccess(peerContext):
    """ Disables direct access to memory allocations in a peer context and unregisters any registered allocations.

    Returns :py:obj:`~.CUDA_ERROR_PEER_ACCESS_NOT_ENABLED` if direct peer
    access has not yet been enabled from `peerContext` to the current
    context.

    Returns :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT` if there is no current
    context, or if `peerContext` is not a valid context.

    Parameters
    ----------
    peerContext : :py:obj:`~.CUcontext`
        Peer context to disable direct access to

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_PEER_ACCESS_NOT_ENABLED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,

    See Also
    --------
    :py:obj:`~.cuDeviceCanAccessPeer`, :py:obj:`~.cuCtxEnablePeerAccess`, :py:obj:`~.cudaDeviceDisablePeerAccess`
    """
    cdef ccuda.CUcontext cpeerContext
    if peerContext is None:
        cpeerContext = <ccuda.CUcontext><void_ptr>0
    elif isinstance(peerContext, (CUcontext)):
        ppeerContext = int(peerContext)
        cpeerContext = <ccuda.CUcontext><void_ptr>ppeerContext
    else:
        ppeerContext = int(CUcontext(peerContext))
        cpeerContext = <ccuda.CUcontext><void_ptr>ppeerContext

    err = ccuda.cuCtxDisablePeerAccess(cpeerContext)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuDeviceGetP2PAttribute(attrib not None : CUdevice_P2PAttribute, srcDevice, dstDevice):
    """ Queries attributes of the link between two devices.

    Returns in `*value` the value of the requested attribute `attrib` of
    the link between `srcDevice` and `dstDevice`. The supported attributes
    are:

    - :py:obj:`~.CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK`: A relative
      value indicating the performance of the link between two devices.

    - :py:obj:`~.CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED` P2P: 1 if P2P
      Access is enable.

    - :py:obj:`~.CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED`: 1 if
      Atomic operations over the link are supported.

    - :py:obj:`~.CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED`: 1 if
      cudaArray can be accessed over the link.

    Returns :py:obj:`~.CUDA_ERROR_INVALID_DEVICE` if `srcDevice` or
    `dstDevice` are not valid or if they represent the same device.

    Returns :py:obj:`~.CUDA_ERROR_INVALID_VALUE` if `attrib` is not valid
    or if `value` is a null pointer.

    Parameters
    ----------
    attrib : :py:obj:`~.CUdevice_P2PAttribute`
        The requested attribute of the link between `srcDevice` and
        `dstDevice`.
    srcDevice : :py:obj:`~.CUdevice`
        The source device of the target link.
    dstDevice : :py:obj:`~.CUdevice`
        The destination device of the target link.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_DEVICE`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    value : int
        Returned value of the requested attribute

    See Also
    --------
    :py:obj:`~.cuCtxEnablePeerAccess`, :py:obj:`~.cuCtxDisablePeerAccess`, :py:obj:`~.cuDeviceCanAccessPeer`, :py:obj:`~.cudaDeviceGetP2PAttribute`
    """
    cdef ccuda.CUdevice cdstDevice
    if dstDevice is None:
        cdstDevice = <ccuda.CUdevice>0
    elif isinstance(dstDevice, (CUdevice)):
        pdstDevice = int(dstDevice)
        cdstDevice = <ccuda.CUdevice>pdstDevice
    else:
        pdstDevice = int(CUdevice(dstDevice))
        cdstDevice = <ccuda.CUdevice>pdstDevice

    cdef ccuda.CUdevice csrcDevice
    if srcDevice is None:
        csrcDevice = <ccuda.CUdevice>0
    elif isinstance(srcDevice, (CUdevice)):
        psrcDevice = int(srcDevice)
        csrcDevice = <ccuda.CUdevice>psrcDevice
    else:
        psrcDevice = int(CUdevice(srcDevice))
        csrcDevice = <ccuda.CUdevice>psrcDevice

    cdef int value = 0
    cdef ccuda.CUdevice_P2PAttribute cattrib = attrib.value
    err = ccuda.cuDeviceGetP2PAttribute(&value, cattrib, csrcDevice, cdstDevice)
    return (CUresult(err), value)

@cython.embedsignature(True)
def cuGraphicsUnregisterResource(resource):
    """ Unregisters a graphics resource for access by CUDA.

    Unregisters the graphics resource `resource` so it is not accessible by
    CUDA unless registered again.

    If `resource` is invalid then :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is
    returned.

    Parameters
    ----------
    resource : :py:obj:`~.CUgraphicsResource`
        Resource to unregister

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_UNKNOWN`

    See Also
    --------
    :py:obj:`~.cuGraphicsD3D9RegisterResource`, :py:obj:`~.cuGraphicsD3D10RegisterResource`, :py:obj:`~.cuGraphicsD3D11RegisterResource`, :py:obj:`~.cuGraphicsGLRegisterBuffer`, :py:obj:`~.cuGraphicsGLRegisterImage`, :py:obj:`~.cudaGraphicsUnregisterResource`
    """
    cdef ccuda.CUgraphicsResource cresource
    if resource is None:
        cresource = <ccuda.CUgraphicsResource><void_ptr>0
    elif isinstance(resource, (CUgraphicsResource)):
        presource = int(resource)
        cresource = <ccuda.CUgraphicsResource><void_ptr>presource
    else:
        presource = int(CUgraphicsResource(resource))
        cresource = <ccuda.CUgraphicsResource><void_ptr>presource

    err = ccuda.cuGraphicsUnregisterResource(cresource)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphicsSubResourceGetMappedArray(resource, unsigned int arrayIndex, unsigned int mipLevel):
    """ Get an array through which to access a subresource of a mapped graphics resource.

    Returns in `*pArray` an array through which the subresource of the
    mapped graphics resource `resource` which corresponds to array index
    `arrayIndex` and mipmap level `mipLevel` may be accessed. The value set
    in `*pArray` may change every time that `resource` is mapped.

    If `resource` is not a texture then it cannot be accessed via an array
    and :py:obj:`~.CUDA_ERROR_NOT_MAPPED_AS_ARRAY` is returned. If
    `arrayIndex` is not a valid array index for `resource` then
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned. If `mipLevel` is not
    a valid mipmap level for `resource` then
    :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is returned. If `resource` is not
    mapped then :py:obj:`~.CUDA_ERROR_NOT_MAPPED` is returned.

    Parameters
    ----------
    resource : :py:obj:`~.CUgraphicsResource`
        Mapped resource to access
    arrayIndex : unsigned int
        Array index for array textures or cubemap face index as defined by
        :py:obj:`~.CUarray_cubemap_face` for cubemap textures for the
        subresource to access
    mipLevel : unsigned int
        Mipmap level for the subresource to access

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_MAPPED`, :py:obj:`~.CUDA_ERROR_NOT_MAPPED_AS_ARRAY`
    pArray : :py:obj:`~.CUarray`
        Returned array through which a subresource of `resource` may be
        accessed

    See Also
    --------
    :py:obj:`~.cuGraphicsResourceGetMappedPointer`, :py:obj:`~.cudaGraphicsSubResourceGetMappedArray`
    """
    cdef ccuda.CUgraphicsResource cresource
    if resource is None:
        cresource = <ccuda.CUgraphicsResource><void_ptr>0
    elif isinstance(resource, (CUgraphicsResource)):
        presource = int(resource)
        cresource = <ccuda.CUgraphicsResource><void_ptr>presource
    else:
        presource = int(CUgraphicsResource(resource))
        cresource = <ccuda.CUgraphicsResource><void_ptr>presource

    cdef CUarray pArray = CUarray()
    err = ccuda.cuGraphicsSubResourceGetMappedArray(pArray._ptr, cresource, arrayIndex, mipLevel)
    return (CUresult(err), pArray)

@cython.embedsignature(True)
def cuGraphicsResourceGetMappedMipmappedArray(resource):
    """ Get a mipmapped array through which to access a mapped graphics resource.

    Returns in `*pMipmappedArray` a mipmapped array through which the
    mapped graphics resource `resource`. The value set in
    `*pMipmappedArray` may change every time that `resource` is mapped.

    If `resource` is not a texture then it cannot be accessed via a
    mipmapped array and :py:obj:`~.CUDA_ERROR_NOT_MAPPED_AS_ARRAY` is
    returned. If `resource` is not mapped then
    :py:obj:`~.CUDA_ERROR_NOT_MAPPED` is returned.

    Parameters
    ----------
    resource : :py:obj:`~.CUgraphicsResource`
        Mapped resource to access

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_MAPPED`, :py:obj:`~.CUDA_ERROR_NOT_MAPPED_AS_ARRAY`
    pMipmappedArray : :py:obj:`~.CUmipmappedArray`
        Returned mipmapped array through which `resource` may be accessed

    See Also
    --------
    :py:obj:`~.cuGraphicsResourceGetMappedPointer`, :py:obj:`~.cudaGraphicsResourceGetMappedMipmappedArray`
    """
    cdef ccuda.CUgraphicsResource cresource
    if resource is None:
        cresource = <ccuda.CUgraphicsResource><void_ptr>0
    elif isinstance(resource, (CUgraphicsResource)):
        presource = int(resource)
        cresource = <ccuda.CUgraphicsResource><void_ptr>presource
    else:
        presource = int(CUgraphicsResource(resource))
        cresource = <ccuda.CUgraphicsResource><void_ptr>presource

    cdef CUmipmappedArray pMipmappedArray = CUmipmappedArray()
    err = ccuda.cuGraphicsResourceGetMappedMipmappedArray(pMipmappedArray._ptr, cresource)
    return (CUresult(err), pMipmappedArray)

@cython.embedsignature(True)
def cuGraphicsResourceGetMappedPointer(resource):
    """ Get a device pointer through which to access a mapped graphics resource.

    Returns in `*pDevPtr` a pointer through which the mapped graphics
    resource `resource` may be accessed. Returns in `pSize` the size of the
    memory in bytes which may be accessed from that pointer. The value set
    in `pPointer` may change every time that `resource` is mapped.

    If `resource` is not a buffer then it cannot be accessed via a pointer
    and :py:obj:`~.CUDA_ERROR_NOT_MAPPED_AS_POINTER` is returned. If
    `resource` is not mapped then :py:obj:`~.CUDA_ERROR_NOT_MAPPED` is
    returned.

    Parameters
    ----------
    resource : :py:obj:`~.CUgraphicsResource`
        None

    Returns
    -------
    CUresult

    pDevPtr : :py:obj:`~.CUdeviceptr`
        None
    pSize : int
        None
    """
    cdef ccuda.CUgraphicsResource cresource
    if resource is None:
        cresource = <ccuda.CUgraphicsResource><void_ptr>0
    elif isinstance(resource, (CUgraphicsResource)):
        presource = int(resource)
        cresource = <ccuda.CUgraphicsResource><void_ptr>presource
    else:
        presource = int(CUgraphicsResource(resource))
        cresource = <ccuda.CUgraphicsResource><void_ptr>presource

    cdef CUdeviceptr pDevPtr = CUdeviceptr()
    cdef size_t pSize = 0
    err = ccuda.cuGraphicsResourceGetMappedPointer(pDevPtr._ptr, &pSize, cresource)
    return (CUresult(err), pDevPtr, pSize)

@cython.embedsignature(True)
def cuGraphicsResourceSetMapFlags(resource, unsigned int flags):
    """ Set usage flags for mapping a graphics resource.

    Set `flags` for mapping the graphics resource `resource`.

    Changes to `flags` will take effect the next time `resource` is mapped.
    The `flags` argument may be any of the following:

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE`: Specifies no hints
      about how this resource will be used. It is therefore assumed that
      this resource will be read from and written to by CUDA kernels. This
      is the default value.

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_READONLY`: Specifies that
      CUDA kernels which access this resource will not write to this
      resource.

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITEDISCARD`: Specifies
      that CUDA kernels which access this resource will not read from this
      resource and will write over the entire contents of the resource, so
      none of the data previously stored in the resource will be preserved.

    If `resource` is presently mapped for access by CUDA then
    :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED` is returned. If `flags` is not
    one of the above values then :py:obj:`~.CUDA_ERROR_INVALID_VALUE` is
    returned.

    Parameters
    ----------
    resource : :py:obj:`~.CUgraphicsResource`
        Registered resource to set flags for
    flags : unsigned int
        Parameters for resource mapping

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`

    See Also
    --------
    :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cudaGraphicsResourceSetMapFlags`
    """
    cdef ccuda.CUgraphicsResource cresource
    if resource is None:
        cresource = <ccuda.CUgraphicsResource><void_ptr>0
    elif isinstance(resource, (CUgraphicsResource)):
        presource = int(resource)
        cresource = <ccuda.CUgraphicsResource><void_ptr>presource
    else:
        presource = int(CUgraphicsResource(resource))
        cresource = <ccuda.CUgraphicsResource><void_ptr>presource

    err = ccuda.cuGraphicsResourceSetMapFlags(cresource, flags)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphicsMapResources(unsigned int count, resources, hStream):
    """ Map graphics resources for access by CUDA.

    Maps the `count` graphics resources in `resources` for access by CUDA.

    The resources in `resources` may be accessed by CUDA until they are
    unmapped. The graphics API from which `resources` were registered
    should not access any resources while they are mapped by CUDA. If an
    application does so, the results are undefined.

    This function provides the synchronization guarantee that any graphics
    calls issued before :py:obj:`~.cuGraphicsMapResources()` will complete
    before any subsequent CUDA work issued in `stream` begins.

    If `resources` includes any duplicate entries then
    :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is returned. If any of
    `resources` are presently mapped for access by CUDA then
    :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED` is returned.

    Parameters
    ----------
    count : unsigned int
        Number of resources to map
    resources : :py:obj:`~.CUgraphicsResource`
        Resources to map for CUDA usage
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream with which to synchronize

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_UNKNOWN`

    See Also
    --------
    :py:obj:`~.cuGraphicsResourceGetMappedPointer`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cudaGraphicsMapResources`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUgraphicsResource *cresources
    if resources is None:
        cresources = <ccuda.CUgraphicsResource*><void_ptr>NULL
    elif isinstance(resources, (CUgraphicsResource)):
        presources = resources.getPtr()
        cresources = <ccuda.CUgraphicsResource*><void_ptr>presources
    elif isinstance(resources, (int)):
        cresources = <ccuda.CUgraphicsResource*><void_ptr>resources
    else:
        raise TypeError("Argument 'resources' is not instance of type (expected <class 'int, cuda.CUgraphicsResource'>, found " + str(type(resources)))

    err = ccuda.cuGraphicsMapResources(count, cresources, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphicsUnmapResources(unsigned int count, resources, hStream):
    """ Unmap graphics resources.

    Unmaps the `count` graphics resources in `resources`.

    Once unmapped, the resources in `resources` may not be accessed by CUDA
    until they are mapped again.

    This function provides the synchronization guarantee that any CUDA work
    issued in `stream` before :py:obj:`~.cuGraphicsUnmapResources()` will
    complete before any subsequently issued graphics work begins.

    If `resources` includes any duplicate entries then
    :py:obj:`~.CUDA_ERROR_INVALID_HANDLE` is returned. If any of
    `resources` are not presently mapped for access by CUDA then
    :py:obj:`~.CUDA_ERROR_NOT_MAPPED` is returned.

    Parameters
    ----------
    count : unsigned int
        Number of resources to unmap
    resources : :py:obj:`~.CUgraphicsResource`
        Resources to unmap
    hStream : :py:obj:`~.CUstream` or :py:obj:`~.cudaStream_t`
        Stream with which to synchronize

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_NOT_MAPPED`, :py:obj:`~.CUDA_ERROR_UNKNOWN`

    See Also
    --------
    :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cudaGraphicsUnmapResources`
    """
    cdef ccuda.CUstream chStream
    if hStream is None:
        chStream = <ccuda.CUstream><void_ptr>0
    elif isinstance(hStream, (CUstream)):
        phStream = int(hStream)
        chStream = <ccuda.CUstream><void_ptr>phStream
    else:
        phStream = int(CUstream(hStream))
        chStream = <ccuda.CUstream><void_ptr>phStream

    cdef ccuda.CUgraphicsResource *cresources
    if resources is None:
        cresources = <ccuda.CUgraphicsResource*><void_ptr>NULL
    elif isinstance(resources, (CUgraphicsResource)):
        presources = resources.getPtr()
        cresources = <ccuda.CUgraphicsResource*><void_ptr>presources
    elif isinstance(resources, (int)):
        cresources = <ccuda.CUgraphicsResource*><void_ptr>resources
    else:
        raise TypeError("Argument 'resources' is not instance of type (expected <class 'int, cuda.CUgraphicsResource'>, found " + str(type(resources)))

    err = ccuda.cuGraphicsUnmapResources(count, cresources, chStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGetProcAddress(char* symbol, int cudaVersion, flags):
    """ Returns the requested driver API function pointer.

    Returns in `**pfn` the address of the CUDA driver function for the
    requested CUDA version and flags.

    The CUDA version is specified as (1000 * major + 10 * minor), so CUDA
    11.2 should be specified as 11020. For a requested driver symbol, if
    the specified CUDA version is greater than or equal to the CUDA version
    in which the driver symbol was introduced, this API will return the
    function pointer to the corresponding versioned function.

    The pointer returned by the API should be cast to a function pointer
    matching the requested driver function's definition in the API header
    file. The function pointer typedef can be picked up from the
    corresponding typedefs header file. For example, cudaTypedefs.h
    consists of function pointer typedefs for driver APIs defined in
    :py:obj:`~.cuda.h`.

    The API will return :py:obj:`~.CUDA_ERROR_NOT_FOUND` if the requested
    driver function is not supported on the platform, no ABI compatible
    driver function exists for the specified `cudaVersion` or if the driver
    symbol is invalid.

    The requested flags can be:

    - :py:obj:`~.CU_GET_PROC_ADDRESS_DEFAULT`: This is the default mode.
      This is equivalent to
      :py:obj:`~.CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM` if the code
      is compiled with --default-stream per-thread compilation flag or the
      macro CUDA_API_PER_THREAD_DEFAULT_STREAM is defined;
      :py:obj:`~.CU_GET_PROC_ADDRESS_LEGACY_STREAM` otherwise.

    - :py:obj:`~.CU_GET_PROC_ADDRESS_LEGACY_STREAM`: This will enable the
      search for all driver symbols that match the requested driver symbol
      name except the corresponding per-thread versions.

    - :py:obj:`~.CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM`: This will
      enable the search for all driver symbols that match the requested
      driver symbol name including the per-thread versions. If a per-thread
      version is not found, the API will return the legacy version of the
      driver function.

    Parameters
    ----------
    symbol : bytes
        The base name of the driver API function to look for. As an
        example, for the driver API :py:obj:`~.cuMemAlloc_v2`, `symbol`
        would be cuMemAlloc and `cudaVersion` would be the ABI compatible
        CUDA version for the _v2 variant.
    cudaVersion : int
        The CUDA version to look for the requested driver symbol
    flags : Any
        Flags to specify search options.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_NOT_SUPPORTED`, :py:obj:`~.CUDA_ERROR_NOT_FOUND`
    pfn : Any
        Location to return the function pointer to the requested driver
        function

    See Also
    --------
    :py:obj:`~.cudaGetDriverEntryPoint`
    """
    cdef ccuda.cuuint64_t cflags
    if flags is None:
        cflags = <ccuda.cuuint64_t><void_ptr>0
    elif isinstance(flags, (cuuint64_t)):
        pflags = int(flags)
        cflags = <ccuda.cuuint64_t><void_ptr>pflags
    else:
        pflags = int(cuuint64_t(flags))
        cflags = <ccuda.cuuint64_t><void_ptr>pflags

    cdef void_ptr pfn = 0
    err = ccuda.cuGetProcAddress(symbol, <void**>&pfn, cudaVersion, cflags)
    return (CUresult(err), pfn)

@cython.embedsignature(True)
def cuModuleGetLoadingMode():
    """ Query lazy loading mode.

    Returns lazy loading mode Module loading mode is controlled by
    CUDA_MODULE_LOADING env variable

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`,
    mode : :py:obj:`~.CUmoduleLoadingMode`
        Returns the lazy loading mode

    See Also
    --------
    :py:obj:`~.cuModuleLoad`,
    """
    cdef ccuda.CUmoduleLoadingMode mode
    err = ccuda.cuModuleGetLoadingMode(&mode)
    return (CUresult(err), CUmoduleLoadingMode(mode))

@cython.embedsignature(True)
def cuMemGetHandleForAddressRange(dptr, size_t size, handleType not None : CUmemRangeHandleType, unsigned long long flags):
    """ 

    Parameters
    ----------
    dptr : :py:obj:`~.CUdeviceptr`
        None
    size : size_t
        None
    handleType : :py:obj:`~.CUmemRangeHandleType`
        None
    flags : unsigned long long
        None

    Returns
    -------
    CUresult

    handle : Any
        None
    """
    cdef ccuda.CUdeviceptr cdptr
    if dptr is None:
        cdptr = <ccuda.CUdeviceptr><void_ptr>0
    elif isinstance(dptr, (CUdeviceptr)):
        pdptr = int(dptr)
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr
    else:
        pdptr = int(CUdeviceptr(dptr))
        cdptr = <ccuda.CUdeviceptr><void_ptr>pdptr

    cdef void_ptr handle = 0
    cdef void* chandle_ptr = <void*>handle
    cdef ccuda.CUmemRangeHandleType chandleType = handleType.value
    err = ccuda.cuMemGetHandleForAddressRange(chandle_ptr, cdptr, size, chandleType, flags)
    return (CUresult(err), handle)

@cython.embedsignature(True)
def cuGetExportTable(pExportTableId : CUuuid):
    """ 

    Parameters
    ----------
    pExportTableId : :py:obj:`~.CUuuid`
        None

    Returns
    -------
    CUresult

    ppExportTable : Any
        None
    """
    cdef void_ptr ppExportTable = 0
    cdef ccuda.CUuuid* cpExportTableId_ptr = pExportTableId._ptr if pExportTableId != None else NULL
    err = ccuda.cuGetExportTable(<const void**>&ppExportTable, cpExportTableId_ptr)
    return (CUresult(err), ppExportTable)

@cython.embedsignature(True)
def cuProfilerInitialize(char* configFile, char* outputFile, outputMode not None : CUoutput_mode):
    """ Initialize the profiling.

    [Deprecated]

    Using this API user can initialize the CUDA profiler by specifying the
    configuration file, output file and output file format. This API is
    generally used to profile different set of counters by looping the
    kernel launch. The `configFile` parameter can be used to select
    profiling options including profiler counters. Refer to the "Compute
    Command Line Profiler User Guide" for supported profiler options and
    counters.

    Limitation: The CUDA profiler cannot be initialized with this API if
    another profiling tool is already active, as indicated by the
    :py:obj:`~.CUDA_ERROR_PROFILER_DISABLED` return code.

    Typical usage of the profiling APIs is as follows:

    for each set of counters/options {  :py:obj:`~.cuProfilerInitialize()`;
    //Initialize profiling, set the counters or options in the config file
    ...  :py:obj:`~.cuProfilerStart()`;   // code to be profiled
    :py:obj:`~.cuProfilerStop()`;   ...  :py:obj:`~.cuProfilerStart()`;
    // code to be profiled   :py:obj:`~.cuProfilerStop()`;   ... }

    Parameters
    ----------
    configFile : bytes
        Name of the config file that lists the counters/options for
        profiling.
    outputFile : bytes
        Name of the outputFile where the profiling results will be stored.
    outputMode : :py:obj:`~.CUoutput_mode`
        outputMode, can be :py:obj:`~.CU_OUT_KEY_VALUE_PAIR` or
        :py:obj:`~.CU_OUT_CSV`.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_PROFILER_DISABLED`

    See Also
    --------
    :py:obj:`~.cuProfilerStart`, :py:obj:`~.cuProfilerStop`, :py:obj:`~.cudaProfilerInitialize`
    """
    cdef ccuda.CUoutput_mode coutputMode = outputMode.value
    err = ccuda.cuProfilerInitialize(configFile, outputFile, coutputMode)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuProfilerStart():
    """ Enable profiling.

    Enables profile collection by the active profiling tool for the current
    context. If profiling is already enabled, then
    :py:obj:`~.cuProfilerStart()` has no effect.

    cuProfilerStart and cuProfilerStop APIs are used to programmatically
    control the profiling granularity by allowing profiling to be done only
    on selective pieces of code.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuProfilerInitialize`, :py:obj:`~.cuProfilerStop`, :py:obj:`~.cudaProfilerStart`
    """
    err = ccuda.cuProfilerStart()
    return (CUresult(err),)

@cython.embedsignature(True)
def cuProfilerStop():
    """ Disable profiling.

    Disables profile collection by the active profiling tool for the
    current context. If profiling is already disabled, then
    :py:obj:`~.cuProfilerStop()` has no effect.

    cuProfilerStart and cuProfilerStop APIs are used to programmatically
    control the profiling granularity by allowing profiling to be done only
    on selective pieces of code.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`

    See Also
    --------
    :py:obj:`~.cuProfilerInitialize`, :py:obj:`~.cuProfilerStart`, :py:obj:`~.cudaProfilerStop`
    """
    err = ccuda.cuProfilerStop()
    return (CUresult(err),)

@cython.embedsignature(True)
def cuVDPAUGetDevice(vdpDevice, vdpGetProcAddress):
    """ Gets the CUDA device associated with a VDPAU device.

    Returns in `*pDevice` the CUDA device associated with a `vdpDevice`, if
    applicable.

    Parameters
    ----------
    vdpDevice : :py:obj:`~.VdpDevice`
        A VdpDevice handle
    vdpGetProcAddress : :py:obj:`~.VdpGetProcAddress`
        VDPAU's VdpGetProcAddress function pointer

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`
    pDevice : :py:obj:`~.CUdevice`
        Device associated with vdpDevice

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuVDPAUCtxCreate`, :py:obj:`~.cuGraphicsVDPAURegisterVideoSurface`, :py:obj:`~.cuGraphicsVDPAURegisterOutputSurface`, :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsResourceSetMapFlags`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cudaVDPAUGetDevice`
    """
    cdef ccuda.VdpGetProcAddress *cvdpGetProcAddress
    if vdpGetProcAddress is None:
        cvdpGetProcAddress = <ccuda.VdpGetProcAddress*><void_ptr>NULL
    elif isinstance(vdpGetProcAddress, (VdpGetProcAddress)):
        pvdpGetProcAddress = vdpGetProcAddress.getPtr()
        cvdpGetProcAddress = <ccuda.VdpGetProcAddress*><void_ptr>pvdpGetProcAddress
    elif isinstance(vdpGetProcAddress, (int)):
        cvdpGetProcAddress = <ccuda.VdpGetProcAddress*><void_ptr>vdpGetProcAddress
    else:
        raise TypeError("Argument 'vdpGetProcAddress' is not instance of type (expected <class 'int, cuda.VdpGetProcAddress'>, found " + str(type(vdpGetProcAddress)))

    cdef ccuda.VdpDevice cvdpDevice
    if vdpDevice is None:
        cvdpDevice = <ccuda.VdpDevice><void_ptr>0
    elif isinstance(vdpDevice, (VdpDevice)):
        pvdpDevice = int(vdpDevice)
        cvdpDevice = <ccuda.VdpDevice><void_ptr>pvdpDevice
    else:
        pvdpDevice = int(VdpDevice(vdpDevice))
        cvdpDevice = <ccuda.VdpDevice><void_ptr>pvdpDevice

    cdef CUdevice pDevice = CUdevice()
    err = ccuda.cuVDPAUGetDevice(pDevice._ptr, cvdpDevice, cvdpGetProcAddress)
    return (CUresult(err), pDevice)

@cython.embedsignature(True)
def cuVDPAUCtxCreate(unsigned int flags, device, vdpDevice, vdpGetProcAddress):
    """ Create a CUDA context for interoperability with VDPAU.

    Creates a new CUDA context, initializes VDPAU interoperability, and
    associates the CUDA context with the calling thread. It must be called
    before performing any other VDPAU interoperability operations. It may
    fail if the needed VDPAU driver facilities are not available. For usage
    of the `flags` parameter, see :py:obj:`~.cuCtxCreate()`.

    Parameters
    ----------
    flags : unsigned int
        Options for CUDA context creation
    device : :py:obj:`~.CUdevice`
        Device on which to create the context
    vdpDevice : :py:obj:`~.VdpDevice`
        The VdpDevice to interop with
    vdpGetProcAddress : :py:obj:`~.VdpGetProcAddress`
        VDPAU's VdpGetProcAddress function pointer

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    pCtx : :py:obj:`~.CUcontext`
        Returned CUDA context

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuGraphicsVDPAURegisterVideoSurface`, :py:obj:`~.cuGraphicsVDPAURegisterOutputSurface`, :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsResourceSetMapFlags`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cuVDPAUGetDevice`
    """
    cdef ccuda.VdpGetProcAddress *cvdpGetProcAddress
    if vdpGetProcAddress is None:
        cvdpGetProcAddress = <ccuda.VdpGetProcAddress*><void_ptr>NULL
    elif isinstance(vdpGetProcAddress, (VdpGetProcAddress)):
        pvdpGetProcAddress = vdpGetProcAddress.getPtr()
        cvdpGetProcAddress = <ccuda.VdpGetProcAddress*><void_ptr>pvdpGetProcAddress
    elif isinstance(vdpGetProcAddress, (int)):
        cvdpGetProcAddress = <ccuda.VdpGetProcAddress*><void_ptr>vdpGetProcAddress
    else:
        raise TypeError("Argument 'vdpGetProcAddress' is not instance of type (expected <class 'int, cuda.VdpGetProcAddress'>, found " + str(type(vdpGetProcAddress)))

    cdef ccuda.VdpDevice cvdpDevice
    if vdpDevice is None:
        cvdpDevice = <ccuda.VdpDevice><void_ptr>0
    elif isinstance(vdpDevice, (VdpDevice)):
        pvdpDevice = int(vdpDevice)
        cvdpDevice = <ccuda.VdpDevice><void_ptr>pvdpDevice
    else:
        pvdpDevice = int(VdpDevice(vdpDevice))
        cvdpDevice = <ccuda.VdpDevice><void_ptr>pvdpDevice

    cdef ccuda.CUdevice cdevice
    if device is None:
        cdevice = <ccuda.CUdevice>0
    elif isinstance(device, (CUdevice)):
        pdevice = int(device)
        cdevice = <ccuda.CUdevice>pdevice
    else:
        pdevice = int(CUdevice(device))
        cdevice = <ccuda.CUdevice>pdevice

    cdef CUcontext pCtx = CUcontext()
    err = ccuda.cuVDPAUCtxCreate(pCtx._ptr, flags, cdevice, cvdpDevice, cvdpGetProcAddress)
    return (CUresult(err), pCtx)

@cython.embedsignature(True)
def cuGraphicsVDPAURegisterVideoSurface(vdpSurface, unsigned int flags):
    """ Registers a VDPAU VdpVideoSurface object.

    Registers the VdpVideoSurface specified by `vdpSurface` for access by
    CUDA. A handle to the registered object is returned as `pCudaResource`.
    The surface's intended usage is specified using `flags`, as follows:

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE`: Specifies no hints
      about how this resource will be used. It is therefore assumed that
      this resource will be read from and written to by CUDA. This is the
      default value.

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY`: Specifies that
      CUDA will not write to this resource.

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD`: Specifies
      that CUDA will not read from this resource and will write over the
      entire contents of the resource, so none of the data previously
      stored in the resource will be preserved.

    The VdpVideoSurface is presented as an array of subresources that may
    be accessed using pointers returned by
    :py:obj:`~.cuGraphicsSubResourceGetMappedArray`. The exact number of
    valid `arrayIndex` values depends on the VDPAU surface format. The
    mapping is shown in the table below. `mipLevel` must be 0.

    Parameters
    ----------
    vdpSurface : :py:obj:`~.VdpVideoSurface`
        The VdpVideoSurface to be registered
    flags : unsigned int
        Map flags

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
    pCudaResource : :py:obj:`~.CUgraphicsResource`
        Pointer to the returned object handle

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuVDPAUCtxCreate`, :py:obj:`~.cuGraphicsVDPAURegisterOutputSurface`, :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsResourceSetMapFlags`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cuVDPAUGetDevice`, :py:obj:`~.cudaGraphicsVDPAURegisterVideoSurface`
    """
    cdef ccuda.VdpVideoSurface cvdpSurface
    if vdpSurface is None:
        cvdpSurface = <ccuda.VdpVideoSurface><void_ptr>0
    elif isinstance(vdpSurface, (VdpVideoSurface)):
        pvdpSurface = int(vdpSurface)
        cvdpSurface = <ccuda.VdpVideoSurface><void_ptr>pvdpSurface
    else:
        pvdpSurface = int(VdpVideoSurface(vdpSurface))
        cvdpSurface = <ccuda.VdpVideoSurface><void_ptr>pvdpSurface

    cdef CUgraphicsResource pCudaResource = CUgraphicsResource()
    err = ccuda.cuGraphicsVDPAURegisterVideoSurface(pCudaResource._ptr, cvdpSurface, flags)
    return (CUresult(err), pCudaResource)

@cython.embedsignature(True)
def cuGraphicsVDPAURegisterOutputSurface(vdpSurface, unsigned int flags):
    """ Registers a VDPAU VdpOutputSurface object.

    Registers the VdpOutputSurface specified by `vdpSurface` for access by
    CUDA. A handle to the registered object is returned as `pCudaResource`.
    The surface's intended usage is specified using `flags`, as follows:

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE`: Specifies no hints
      about how this resource will be used. It is therefore assumed that
      this resource will be read from and written to by CUDA. This is the
      default value.

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY`: Specifies that
      CUDA will not write to this resource.

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD`: Specifies
      that CUDA will not read from this resource and will write over the
      entire contents of the resource, so none of the data previously
      stored in the resource will be preserved.

    The VdpOutputSurface is presented as an array of subresources that may
    be accessed using pointers returned by
    :py:obj:`~.cuGraphicsSubResourceGetMappedArray`. The exact number of
    valid `arrayIndex` values depends on the VDPAU surface format. The
    mapping is shown in the table below. `mipLevel` must be 0.

    Parameters
    ----------
    vdpSurface : :py:obj:`~.VdpOutputSurface`
        The VdpOutputSurface to be registered
    flags : unsigned int
        Map flags

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
    pCudaResource : :py:obj:`~.CUgraphicsResource`
        Pointer to the returned object handle

    See Also
    --------
    :py:obj:`~.cuCtxCreate`, :py:obj:`~.cuVDPAUCtxCreate`, :py:obj:`~.cuGraphicsVDPAURegisterVideoSurface`, :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsResourceSetMapFlags`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cuVDPAUGetDevice`, :py:obj:`~.cudaGraphicsVDPAURegisterOutputSurface`
    """
    cdef ccuda.VdpOutputSurface cvdpSurface
    if vdpSurface is None:
        cvdpSurface = <ccuda.VdpOutputSurface><void_ptr>0
    elif isinstance(vdpSurface, (VdpOutputSurface)):
        pvdpSurface = int(vdpSurface)
        cvdpSurface = <ccuda.VdpOutputSurface><void_ptr>pvdpSurface
    else:
        pvdpSurface = int(VdpOutputSurface(vdpSurface))
        cvdpSurface = <ccuda.VdpOutputSurface><void_ptr>pvdpSurface

    cdef CUgraphicsResource pCudaResource = CUgraphicsResource()
    err = ccuda.cuGraphicsVDPAURegisterOutputSurface(pCudaResource._ptr, cvdpSurface, flags)
    return (CUresult(err), pCudaResource)

@cython.embedsignature(True)
def cuGraphicsEGLRegisterImage(image, unsigned int flags):
    """ Registers an EGL image.

    Registers the EGLImageKHR specified by `image` for access by CUDA. A
    handle to the registered object is returned as `pCudaResource`.
    Additional Mapping/Unmapping is not required for the registered
    resource and :py:obj:`~.cuGraphicsResourceGetMappedEglFrame` can be
    directly called on the `pCudaResource`.

    The application will be responsible for synchronizing access to shared
    objects. The application must ensure that any pending operation which
    access the objects have completed before passing control to CUDA. This
    may be accomplished by issuing and waiting for glFinish command on all
    GLcontexts (for OpenGL and likewise for other APIs). The application
    will be also responsible for ensuring that any pending operation on the
    registered CUDA resource has completed prior to executing subsequent
    commands in other APIs accesing the same memory objects. This can be
    accomplished by calling cuCtxSynchronize or cuEventSynchronize
    (preferably).

    The surface's intended usage is specified using `flags`, as follows:

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE`: Specifies no hints
      about how this resource will be used. It is therefore assumed that
      this resource will be read from and written to by CUDA. This is the
      default value.

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY`: Specifies that
      CUDA will not write to this resource.

    - :py:obj:`~.CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD`: Specifies
      that CUDA will not read from this resource and will write over the
      entire contents of the resource, so none of the data previously
      stored in the resource will be preserved.

    The EGLImageKHR is an object which can be used to create EGLImage
    target resource. It is defined as a void pointer. typedef void*
    EGLImageKHR

    Parameters
    ----------
    image : :py:obj:`~.EGLImageKHR`
        An EGLImageKHR image which can be used to create target resource.
    flags : unsigned int
        Map flags

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
    pCudaResource : :py:obj:`~.CUgraphicsResource`
        Pointer to the returned object handle

    See Also
    --------
    :py:obj:`~.cuGraphicsEGLRegisterImage`, :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsResourceSetMapFlags`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsUnmapResources`, :py:obj:`~.cudaGraphicsEGLRegisterImage`
    """
    cdef ccuda.EGLImageKHR cimage
    if image is None:
        cimage = <ccuda.EGLImageKHR><void_ptr>0
    elif isinstance(image, (EGLImageKHR)):
        pimage = int(image)
        cimage = <ccuda.EGLImageKHR><void_ptr>pimage
    else:
        pimage = int(EGLImageKHR(image))
        cimage = <ccuda.EGLImageKHR><void_ptr>pimage

    cdef CUgraphicsResource pCudaResource = CUgraphicsResource()
    err = ccuda.cuGraphicsEGLRegisterImage(pCudaResource._ptr, cimage, flags)
    return (CUresult(err), pCudaResource)

@cython.embedsignature(True)
def cuEGLStreamConsumerConnect(stream):
    """ Connect CUDA to EGLStream as a consumer.

    Connect CUDA as a consumer to EGLStreamKHR specified by `stream`.

    The EGLStreamKHR is an EGL object that transfers a sequence of image
    frames from one API to another.

    Parameters
    ----------
    stream : :py:obj:`~.EGLStreamKHR`
        EGLStreamKHR handle

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
    conn : :py:obj:`~.CUeglStreamConnection`
        Pointer to the returned connection handle

    See Also
    --------
    :py:obj:`~.cuEGLStreamConsumerConnect`, :py:obj:`~.cuEGLStreamConsumerDisconnect`, :py:obj:`~.cuEGLStreamConsumerAcquireFrame`, :py:obj:`~.cuEGLStreamConsumerReleaseFrame`, :py:obj:`~.cudaEGLStreamConsumerConnect`
    """
    cdef ccuda.EGLStreamKHR cstream
    if stream is None:
        cstream = <ccuda.EGLStreamKHR><void_ptr>0
    elif isinstance(stream, (EGLStreamKHR)):
        pstream = int(stream)
        cstream = <ccuda.EGLStreamKHR><void_ptr>pstream
    else:
        pstream = int(EGLStreamKHR(stream))
        cstream = <ccuda.EGLStreamKHR><void_ptr>pstream

    cdef CUeglStreamConnection conn = CUeglStreamConnection()
    err = ccuda.cuEGLStreamConsumerConnect(conn._ptr, cstream)
    return (CUresult(err), conn)

@cython.embedsignature(True)
def cuEGLStreamConsumerConnectWithFlags(stream, unsigned int flags):
    """ Connect CUDA to EGLStream as a consumer with given flags.

    Connect CUDA as a consumer to EGLStreamKHR specified by `stream` with
    specified `flags` defined by CUeglResourceLocationFlags.

    The flags specify whether the consumer wants to access frames from
    system memory or video memory. Default is
    :py:obj:`~.CU_EGL_RESOURCE_LOCATION_VIDMEM`.

    Parameters
    ----------
    stream : :py:obj:`~.EGLStreamKHR`
        EGLStreamKHR handle
    flags : unsigned int
        Flags denote intended location - system or video.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
    conn : :py:obj:`~.CUeglStreamConnection`
        Pointer to the returned connection handle

    See Also
    --------
    :py:obj:`~.cuEGLStreamConsumerConnect`, :py:obj:`~.cuEGLStreamConsumerDisconnect`, :py:obj:`~.cuEGLStreamConsumerAcquireFrame`, :py:obj:`~.cuEGLStreamConsumerReleaseFrame`, :py:obj:`~.cudaEGLStreamConsumerConnectWithFlags`
    """
    cdef ccuda.EGLStreamKHR cstream
    if stream is None:
        cstream = <ccuda.EGLStreamKHR><void_ptr>0
    elif isinstance(stream, (EGLStreamKHR)):
        pstream = int(stream)
        cstream = <ccuda.EGLStreamKHR><void_ptr>pstream
    else:
        pstream = int(EGLStreamKHR(stream))
        cstream = <ccuda.EGLStreamKHR><void_ptr>pstream

    cdef CUeglStreamConnection conn = CUeglStreamConnection()
    err = ccuda.cuEGLStreamConsumerConnectWithFlags(conn._ptr, cstream, flags)
    return (CUresult(err), conn)

@cython.embedsignature(True)
def cuEGLStreamConsumerDisconnect(conn):
    """ Disconnect CUDA as a consumer to EGLStream .

    Disconnect CUDA as a consumer to EGLStreamKHR.

    Parameters
    ----------
    conn : :py:obj:`~.CUeglStreamConnection`
        Conection to disconnect.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,

    See Also
    --------
    :py:obj:`~.cuEGLStreamConsumerConnect`, :py:obj:`~.cuEGLStreamConsumerDisconnect`, :py:obj:`~.cuEGLStreamConsumerAcquireFrame`, :py:obj:`~.cuEGLStreamConsumerReleaseFrame`, :py:obj:`~.cudaEGLStreamConsumerDisconnect`
    """
    cdef ccuda.CUeglStreamConnection *cconn
    if conn is None:
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (CUeglStreamConnection)):
        pconn = conn.getPtr()
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, cuda.CUeglStreamConnection'>, found " + str(type(conn)))

    err = ccuda.cuEGLStreamConsumerDisconnect(cconn)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuEGLStreamConsumerAcquireFrame(conn, pCudaResource, pStream, unsigned int timeout):
    """ Acquire an image frame from the EGLStream with CUDA as a consumer.

    Acquire an image frame from EGLStreamKHR. This API can also acquire an
    old frame presented by the producer unless explicitly disabled by
    setting EGL_SUPPORT_REUSE_NV flag to EGL_FALSE during stream
    initialization. By default, EGLStream is created with this flag set to
    EGL_TRUE. :py:obj:`~.cuGraphicsResourceGetMappedEglFrame` can be called
    on `pCudaResource` to get :py:obj:`~.CUeglFrame`.

    Parameters
    ----------
    conn : :py:obj:`~.CUeglStreamConnection`
        Connection on which to acquire
    pCudaResource : :py:obj:`~.CUgraphicsResource`
        CUDA resource on which the stream frame will be mapped for use.
    pStream : :py:obj:`~.CUstream`
        CUDA stream for synchronization and any data migrations implied by
        :py:obj:`~.CUeglResourceLocationFlags`.
    timeout : unsigned int
        Desired timeout in usec for a new frame to be acquired. If set as
        :py:obj:`~.CUDA_EGL_INFINITE_TIMEOUT`, acquire waits infinitely.
        After timeout occurs CUDA consumer tries to acquire an old frame if
        available and EGL_SUPPORT_REUSE_NV flag is set.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`,

    See Also
    --------
    :py:obj:`~.cuEGLStreamConsumerConnect`, :py:obj:`~.cuEGLStreamConsumerDisconnect`, :py:obj:`~.cuEGLStreamConsumerAcquireFrame`, :py:obj:`~.cuEGLStreamConsumerReleaseFrame`, :py:obj:`~.cudaEGLStreamConsumerAcquireFrame`
    """
    cdef ccuda.CUstream *cpStream
    if pStream is None:
        cpStream = <ccuda.CUstream*><void_ptr>NULL
    elif isinstance(pStream, (CUstream)):
        ppStream = pStream.getPtr()
        cpStream = <ccuda.CUstream*><void_ptr>ppStream
    elif isinstance(pStream, (int)):
        cpStream = <ccuda.CUstream*><void_ptr>pStream
    else:
        raise TypeError("Argument 'pStream' is not instance of type (expected <class 'int, cuda.CUstream'>, found " + str(type(pStream)))

    cdef ccuda.CUgraphicsResource *cpCudaResource
    if pCudaResource is None:
        cpCudaResource = <ccuda.CUgraphicsResource*><void_ptr>NULL
    elif isinstance(pCudaResource, (CUgraphicsResource)):
        ppCudaResource = pCudaResource.getPtr()
        cpCudaResource = <ccuda.CUgraphicsResource*><void_ptr>ppCudaResource
    elif isinstance(pCudaResource, (int)):
        cpCudaResource = <ccuda.CUgraphicsResource*><void_ptr>pCudaResource
    else:
        raise TypeError("Argument 'pCudaResource' is not instance of type (expected <class 'int, cuda.CUgraphicsResource'>, found " + str(type(pCudaResource)))

    cdef ccuda.CUeglStreamConnection *cconn
    if conn is None:
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (CUeglStreamConnection)):
        pconn = conn.getPtr()
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, cuda.CUeglStreamConnection'>, found " + str(type(conn)))

    err = ccuda.cuEGLStreamConsumerAcquireFrame(cconn, cpCudaResource, cpStream, timeout)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuEGLStreamConsumerReleaseFrame(conn, pCudaResource, pStream):
    """ Releases the last frame acquired from the EGLStream.

    Release the acquired image frame specified by `pCudaResource` to
    EGLStreamKHR. If EGL_SUPPORT_REUSE_NV flag is set to EGL_TRUE, at the
    time of EGL creation this API doesn't release the last frame acquired
    on the EGLStream. By default, EGLStream is created with this flag set
    to EGL_TRUE.

    Parameters
    ----------
    conn : :py:obj:`~.CUeglStreamConnection`
        Connection on which to release
    pCudaResource : :py:obj:`~.CUgraphicsResource`
        CUDA resource whose corresponding frame is to be released
    pStream : :py:obj:`~.CUstream`
        CUDA stream on which release will be done.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`,

    See Also
    --------
    :py:obj:`~.cuEGLStreamConsumerConnect`, :py:obj:`~.cuEGLStreamConsumerDisconnect`, :py:obj:`~.cuEGLStreamConsumerAcquireFrame`, :py:obj:`~.cuEGLStreamConsumerReleaseFrame`, :py:obj:`~.cudaEGLStreamConsumerReleaseFrame`
    """
    cdef ccuda.CUstream *cpStream
    if pStream is None:
        cpStream = <ccuda.CUstream*><void_ptr>NULL
    elif isinstance(pStream, (CUstream)):
        ppStream = pStream.getPtr()
        cpStream = <ccuda.CUstream*><void_ptr>ppStream
    elif isinstance(pStream, (int)):
        cpStream = <ccuda.CUstream*><void_ptr>pStream
    else:
        raise TypeError("Argument 'pStream' is not instance of type (expected <class 'int, cuda.CUstream'>, found " + str(type(pStream)))

    cdef ccuda.CUgraphicsResource cpCudaResource
    if pCudaResource is None:
        cpCudaResource = <ccuda.CUgraphicsResource><void_ptr>0
    elif isinstance(pCudaResource, (CUgraphicsResource)):
        ppCudaResource = int(pCudaResource)
        cpCudaResource = <ccuda.CUgraphicsResource><void_ptr>ppCudaResource
    else:
        ppCudaResource = int(CUgraphicsResource(pCudaResource))
        cpCudaResource = <ccuda.CUgraphicsResource><void_ptr>ppCudaResource

    cdef ccuda.CUeglStreamConnection *cconn
    if conn is None:
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (CUeglStreamConnection)):
        pconn = conn.getPtr()
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, cuda.CUeglStreamConnection'>, found " + str(type(conn)))

    err = ccuda.cuEGLStreamConsumerReleaseFrame(cconn, cpCudaResource, cpStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuEGLStreamProducerConnect(stream, width, height):
    """ Connect CUDA to EGLStream as a producer.

    Connect CUDA as a producer to EGLStreamKHR specified by `stream`.

    The EGLStreamKHR is an EGL object that transfers a sequence of image
    frames from one API to another.

    Parameters
    ----------
    stream : :py:obj:`~.EGLStreamKHR`
        EGLStreamKHR handle
    width : :py:obj:`~.EGLint`
        width of the image to be submitted to the stream
    height : :py:obj:`~.EGLint`
        height of the image to be submitted to the stream

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
    conn : :py:obj:`~.CUeglStreamConnection`
        Pointer to the returned connection handle

    See Also
    --------
    :py:obj:`~.cuEGLStreamProducerConnect`, :py:obj:`~.cuEGLStreamProducerDisconnect`, :py:obj:`~.cuEGLStreamProducerPresentFrame`, :py:obj:`~.cudaEGLStreamProducerConnect`
    """
    cdef ccuda.EGLint cheight
    if height is None:
        cheight = <ccuda.EGLint><void_ptr>0
    elif isinstance(height, (EGLint)):
        pheight = int(height)
        cheight = <ccuda.EGLint><void_ptr>pheight
    else:
        pheight = int(EGLint(height))
        cheight = <ccuda.EGLint><void_ptr>pheight

    cdef ccuda.EGLint cwidth
    if width is None:
        cwidth = <ccuda.EGLint><void_ptr>0
    elif isinstance(width, (EGLint)):
        pwidth = int(width)
        cwidth = <ccuda.EGLint><void_ptr>pwidth
    else:
        pwidth = int(EGLint(width))
        cwidth = <ccuda.EGLint><void_ptr>pwidth

    cdef ccuda.EGLStreamKHR cstream
    if stream is None:
        cstream = <ccuda.EGLStreamKHR><void_ptr>0
    elif isinstance(stream, (EGLStreamKHR)):
        pstream = int(stream)
        cstream = <ccuda.EGLStreamKHR><void_ptr>pstream
    else:
        pstream = int(EGLStreamKHR(stream))
        cstream = <ccuda.EGLStreamKHR><void_ptr>pstream

    cdef CUeglStreamConnection conn = CUeglStreamConnection()
    err = ccuda.cuEGLStreamProducerConnect(conn._ptr, cstream, cwidth, cheight)
    return (CUresult(err), conn)

@cython.embedsignature(True)
def cuEGLStreamProducerDisconnect(conn):
    """ Disconnect CUDA as a producer to EGLStream .

    Disconnect CUDA as a producer to EGLStreamKHR.

    Parameters
    ----------
    conn : :py:obj:`~.CUeglStreamConnection`
        Conection to disconnect.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,

    See Also
    --------
    :py:obj:`~.cuEGLStreamProducerConnect`, :py:obj:`~.cuEGLStreamProducerDisconnect`, :py:obj:`~.cuEGLStreamProducerPresentFrame`, :py:obj:`~.cudaEGLStreamProducerDisconnect`
    """
    cdef ccuda.CUeglStreamConnection *cconn
    if conn is None:
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (CUeglStreamConnection)):
        pconn = conn.getPtr()
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, cuda.CUeglStreamConnection'>, found " + str(type(conn)))

    err = ccuda.cuEGLStreamProducerDisconnect(cconn)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuEGLStreamProducerPresentFrame(conn, eglframe not None : CUeglFrame, pStream):
    """ Present a CUDA eglFrame to the EGLStream with CUDA as a producer.

    When a frame is presented by the producer, it gets associated with the
    EGLStream and thus it is illegal to free the frame before the producer
    is disconnected. If a frame is freed and reused it may lead to
    undefined behavior.

    If producer and consumer are on different GPUs (iGPU and dGPU) then
    frametype :py:obj:`~.CU_EGL_FRAME_TYPE_ARRAY` is not supported.
    :py:obj:`~.CU_EGL_FRAME_TYPE_PITCH` can be used for such cross-device
    applications.

    The :py:obj:`~.CUeglFrame` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    For :py:obj:`~.CUeglFrame` of type :py:obj:`~.CU_EGL_FRAME_TYPE_PITCH`,
    the application may present sub-region of a memory allocation. In that
    case, the pitched pointer will specify the start address of the sub-
    region in the allocation and corresponding :py:obj:`~.CUeglFrame`
    fields will specify the dimensions of the sub-region.

    Parameters
    ----------
    conn : :py:obj:`~.CUeglStreamConnection`
        Connection on which to present the CUDA array
    eglframe : :py:obj:`~.CUeglFrame`
        CUDA Eglstream Proucer Frame handle to be sent to the consumer over
        EglStream.
    pStream : :py:obj:`~.CUstream`
        CUDA stream on which to present the frame.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`,

    See Also
    --------
    :py:obj:`~.cuEGLStreamProducerConnect`, :py:obj:`~.cuEGLStreamProducerDisconnect`, :py:obj:`~.cuEGLStreamProducerReturnFrame`, :py:obj:`~.cudaEGLStreamProducerPresentFrame`
    """
    cdef ccuda.CUstream *cpStream
    if pStream is None:
        cpStream = <ccuda.CUstream*><void_ptr>NULL
    elif isinstance(pStream, (CUstream)):
        ppStream = pStream.getPtr()
        cpStream = <ccuda.CUstream*><void_ptr>ppStream
    elif isinstance(pStream, (int)):
        cpStream = <ccuda.CUstream*><void_ptr>pStream
    else:
        raise TypeError("Argument 'pStream' is not instance of type (expected <class 'int, cuda.CUstream'>, found " + str(type(pStream)))

    cdef ccuda.CUeglStreamConnection *cconn
    if conn is None:
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (CUeglStreamConnection)):
        pconn = conn.getPtr()
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, cuda.CUeglStreamConnection'>, found " + str(type(conn)))

    err = ccuda.cuEGLStreamProducerPresentFrame(cconn, eglframe._ptr[0], cpStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuEGLStreamProducerReturnFrame(conn, eglframe : CUeglFrame, pStream):
    """ Return the CUDA eglFrame to the EGLStream released by the consumer.

    This API can potentially return CUDA_ERROR_LAUNCH_TIMEOUT if the
    consumer has not returned a frame to EGL stream. If timeout is returned
    the application can retry.

    Parameters
    ----------
    conn : :py:obj:`~.CUeglStreamConnection`
        Connection on which to return
    eglframe : :py:obj:`~.CUeglFrame`
        CUDA Eglstream Proucer Frame handle returned from the consumer over
        EglStream.
    pStream : :py:obj:`~.CUstream`
        CUDA stream on which to return the frame.

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_LAUNCH_TIMEOUT`

    See Also
    --------
    :py:obj:`~.cuEGLStreamProducerConnect`, :py:obj:`~.cuEGLStreamProducerDisconnect`, :py:obj:`~.cuEGLStreamProducerPresentFrame`, :py:obj:`~.cudaEGLStreamProducerReturnFrame`
    """
    cdef ccuda.CUstream *cpStream
    if pStream is None:
        cpStream = <ccuda.CUstream*><void_ptr>NULL
    elif isinstance(pStream, (CUstream)):
        ppStream = pStream.getPtr()
        cpStream = <ccuda.CUstream*><void_ptr>ppStream
    elif isinstance(pStream, (int)):
        cpStream = <ccuda.CUstream*><void_ptr>pStream
    else:
        raise TypeError("Argument 'pStream' is not instance of type (expected <class 'int, cuda.CUstream'>, found " + str(type(pStream)))

    cdef ccuda.CUeglStreamConnection *cconn
    if conn is None:
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>NULL
    elif isinstance(conn, (CUeglStreamConnection)):
        pconn = conn.getPtr()
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>pconn
    elif isinstance(conn, (int)):
        cconn = <ccuda.CUeglStreamConnection*><void_ptr>conn
    else:
        raise TypeError("Argument 'conn' is not instance of type (expected <class 'int, cuda.CUeglStreamConnection'>, found " + str(type(conn)))

    cdef ccuda.CUeglFrame* ceglframe_ptr = eglframe._ptr if eglframe != None else NULL
    err = ccuda.cuEGLStreamProducerReturnFrame(cconn, ceglframe_ptr, cpStream)
    return (CUresult(err),)

@cython.embedsignature(True)
def cuGraphicsResourceGetMappedEglFrame(resource, unsigned int index, unsigned int mipLevel):
    """ Get an eglFrame through which to access a registered EGL graphics resource.

    Returns in `*eglFrame` an eglFrame pointer through which the registered
    graphics resource `resource` may be accessed. This API can only be
    called for registered EGL graphics resources.

    The :py:obj:`~.CUeglFrame` is defined as:

    **View CUDA Toolkit Documentation for a C++ code example**

    If `resource` is not registered then :py:obj:`~.CUDA_ERROR_NOT_MAPPED`
    is returned.

    Parameters
    ----------
    resource : :py:obj:`~.CUgraphicsResource`
        None
    index : unsigned int
        None
    mipLevel : unsigned int
        None

    Returns
    -------
    CUresult

    eglFrame : :py:obj:`~.CUeglFrame`
        None
    """
    cdef ccuda.CUgraphicsResource cresource
    if resource is None:
        cresource = <ccuda.CUgraphicsResource><void_ptr>0
    elif isinstance(resource, (CUgraphicsResource)):
        presource = int(resource)
        cresource = <ccuda.CUgraphicsResource><void_ptr>presource
    else:
        presource = int(CUgraphicsResource(resource))
        cresource = <ccuda.CUgraphicsResource><void_ptr>presource

    cdef CUeglFrame eglFrame = CUeglFrame()
    err = ccuda.cuGraphicsResourceGetMappedEglFrame(eglFrame._ptr, cresource, index, mipLevel)
    return (CUresult(err), eglFrame)

@cython.embedsignature(True)
def cuEventCreateFromEGLSync(eglSync, unsigned int flags):
    """ Creates an event from EGLSync object.

    Creates an event *phEvent from an EGLSyncKHR eglSync with the flags
    specified via `flags`. Valid flags include:

    - :py:obj:`~.CU_EVENT_DEFAULT`: Default event creation flag.

    - :py:obj:`~.CU_EVENT_BLOCKING_SYNC`: Specifies that the created event
      should use blocking synchronization. A CPU thread that uses
      :py:obj:`~.cuEventSynchronize()` to wait on an event created with
      this flag will block until the event has actually been completed.

    Once the `eglSync` gets destroyed, :py:obj:`~.cuEventDestroy` is the
    only API that can be invoked on the event.

    :py:obj:`~.cuEventRecord` and TimingData are not supported for events
    created from EGLSync.

    The EGLSyncKHR is an opaque handle to an EGL sync object. typedef void*
    EGLSyncKHR

    Parameters
    ----------
    eglSync : :py:obj:`~.EGLSyncKHR`
        Opaque handle to EGLSync object
    flags : unsigned int
        Event creation flags

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_DEINITIALIZED`, :py:obj:`~.CUDA_ERROR_NOT_INITIALIZED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`, :py:obj:`~.CUDA_ERROR_INVALID_VALUE`, :py:obj:`~.CUDA_ERROR_OUT_OF_MEMORY`
    phEvent : :py:obj:`~.CUevent`
        Returns newly created event

    See Also
    --------
    :py:obj:`~.cuEventQuery`, :py:obj:`~.cuEventSynchronize`, :py:obj:`~.cuEventDestroy`
    """
    cdef ccuda.EGLSyncKHR ceglSync
    if eglSync is None:
        ceglSync = <ccuda.EGLSyncKHR><void_ptr>0
    elif isinstance(eglSync, (EGLSyncKHR)):
        peglSync = int(eglSync)
        ceglSync = <ccuda.EGLSyncKHR><void_ptr>peglSync
    else:
        peglSync = int(EGLSyncKHR(eglSync))
        ceglSync = <ccuda.EGLSyncKHR><void_ptr>peglSync

    cdef CUevent phEvent = CUevent()
    err = ccuda.cuEventCreateFromEGLSync(phEvent._ptr, ceglSync, flags)
    return (CUresult(err), phEvent)

@cython.embedsignature(True)
def cuGraphicsGLRegisterBuffer(buffer, unsigned int Flags):
    """ Registers an OpenGL buffer object.

    Registers the buffer object specified by `buffer` for access by CUDA. A
    handle to the registered object is returned as `pCudaResource`. The
    register flags `Flags` specify the intended usage, as follows:

    - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_NONE`: Specifies no hints about
      how this resource will be used. It is therefore assumed that this
      resource will be read from and written to by CUDA. This is the
      default value.

    - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY`: Specifies that CUDA
      will not write to this resource.

    - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD`: Specifies that
      CUDA will not read from this resource and will write over the entire
      contents of the resource, so none of the data previously stored in
      the resource will be preserved.

    Parameters
    ----------
    buffer : :py:obj:`~.GLuint`
        name of buffer object to be registered
    Flags : unsigned int
        Register flags

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
    pCudaResource : :py:obj:`~.CUgraphicsResource`
        Pointer to the returned object handle

    See Also
    --------
    :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsResourceGetMappedPointer`, :py:obj:`~.cudaGraphicsGLRegisterBuffer`
    """
    cdef ccuda.GLuint cbuffer
    if buffer is None:
        cbuffer = <ccuda.GLuint><void_ptr>0
    elif isinstance(buffer, (GLuint)):
        pbuffer = int(buffer)
        cbuffer = <ccuda.GLuint><void_ptr>pbuffer
    else:
        pbuffer = int(GLuint(buffer))
        cbuffer = <ccuda.GLuint><void_ptr>pbuffer

    cdef CUgraphicsResource pCudaResource = CUgraphicsResource()
    err = ccuda.cuGraphicsGLRegisterBuffer(pCudaResource._ptr, cbuffer, Flags)
    return (CUresult(err), pCudaResource)

@cython.embedsignature(True)
def cuGraphicsGLRegisterImage(image, target, unsigned int Flags):
    """ Register an OpenGL texture or renderbuffer object.

    Registers the texture or renderbuffer object specified by `image` for
    access by CUDA.   A handle to the registered object is returned as
    `pCudaResource`.

    `target` must match the type of the object, and must be one of
    :py:obj:`~.GL_TEXTURE_2D`, :py:obj:`~.GL_TEXTURE_RECTANGLE`,
    :py:obj:`~.GL_TEXTURE_CUBE_MAP`, :py:obj:`~.GL_TEXTURE_3D`,
    :py:obj:`~.GL_TEXTURE_2D_ARRAY`, or :py:obj:`~.GL_RENDERBUFFER`.

    The register flags `Flags` specify the intended usage, as follows:

    - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_NONE`: Specifies no hints about
      how this resource will be used. It is therefore assumed that this
      resource will be read from and written to by CUDA. This is the
      default value.

    - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY`: Specifies that CUDA
      will not write to this resource.

    - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD`: Specifies that
      CUDA will not read from this resource and will write over the entire
      contents of the resource, so none of the data previously stored in
      the resource will be preserved.

    - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST`: Specifies that
      CUDA will bind this resource to a surface reference.

    - :py:obj:`~.CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER`: Specifies that
      CUDA will perform texture gather operations on this resource.

    The following image formats are supported. For brevity's sake, the list
    is abbreviated. For ex., {GL_R, GL_RG} X {8, 16} would expand to the
    following 4 formats {GL_R8, GL_R16, GL_RG8, GL_RG16} :

    - GL_RED, GL_RG, GL_RGBA, GL_LUMINANCE, GL_ALPHA, GL_LUMINANCE_ALPHA,
      GL_INTENSITY

    - {GL_R, GL_RG, GL_RGBA} X {8, 16, 16F, 32F, 8UI, 16UI, 32UI, 8I, 16I,
      32I}

    - {GL_LUMINANCE, GL_ALPHA, GL_LUMINANCE_ALPHA, GL_INTENSITY} X {8, 16,
      16F_ARB, 32F_ARB, 8UI_EXT, 16UI_EXT, 32UI_EXT, 8I_EXT, 16I_EXT,
      32I_EXT}

    The following image classes are currently disallowed:

    - Textures with borders

    - Multisampled renderbuffers

    Parameters
    ----------
    image : :py:obj:`~.GLuint`
        name of texture or renderbuffer object to be registered
    target : :py:obj:`~.GLenum`
        Identifies the type of object specified by `image`
    Flags : unsigned int
        Register flags

    Returns
    -------
    CUresult
        :py:obj:`~.CUDA_SUCCESS`, :py:obj:`~.CUDA_ERROR_INVALID_HANDLE`, :py:obj:`~.CUDA_ERROR_ALREADY_MAPPED`, :py:obj:`~.CUDA_ERROR_INVALID_CONTEXT`,
    pCudaResource : :py:obj:`~.CUgraphicsResource`
        Pointer to the returned object handle

    See Also
    --------
    :py:obj:`~.cuGraphicsUnregisterResource`, :py:obj:`~.cuGraphicsMapResources`, :py:obj:`~.cuGraphicsSubResourceGetMappedArray`, :py:obj:`~.cudaGraphicsGLRegisterImage`
    """
    cdef ccuda.GLenum ctarget
    if target is None:
        ctarget = <ccuda.GLenum><void_ptr>0
    elif isinstance(target, (GLenum)):
        ptarget = int(target)
        ctarget = <ccuda.GLenum><void_ptr>ptarget
    else:
        ptarget = int(GLenum(target))
        ctarget = <ccuda.GLenum><void_ptr>ptarget

    cdef ccuda.GLuint cimage
    if image is None:
        cimage = <ccuda.GLuint><void_ptr>0
    elif isinstance(image, (GLuint)):
        pimage = int(image)
        cimage = <ccuda.GLuint><void_ptr>pimage
    else:
        pimage = int(GLuint(image))
        cimage = <ccuda.GLuint><void_ptr>pimage

    cdef CUgraphicsResource pCudaResource = CUgraphicsResource()
    err = ccuda.cuGraphicsGLRegisterImage(pCudaResource._ptr, cimage, ctarget, Flags)
    return (CUresult(err), pCudaResource)

@cython.embedsignature(True)
def cuGLGetDevices(unsigned int cudaDeviceCount, deviceList not None : CUGLDeviceList):
    """ Gets the CUDA devices associated with the current OpenGL context.

    Returns in `*pCudaDeviceCount` the number of CUDA-compatible devices
    corresponding to the current OpenGL context. Also returns in
    `*pCudaDevices` at most cudaDeviceCount of the CUDA-compatible devices
    corresponding to the current OpenGL context. If any of the GPUs being
    used by the current OpenGL context are not CUDA capable then the call
    will return CUDA_ERROR_NO_DEVICE.

    The `deviceList` argument may be any of the following:
    CU_GL_DEVICE_LIST_ALL: Query all devices used by the current OpenGL
    context. CU_GL_DEVICE_LIST_CURRENT_FRAME: Query the devices used by the
    current OpenGL context to render the current frame (in SLI).
    CU_GL_DEVICE_LIST_NEXT_FRAME: Query the devices used by the current
    OpenGL context to render the next frame (in SLI). Note that this is a
    prediction, it can't be guaranteed that this is correct in all cases.

    Parameters
    ----------
    cudaDeviceCount : unsigned int
        The size of the output device array pCudaDevices.
    deviceList : CUGLDeviceList
        The set of devices to return.

    Returns
    -------
    CUresult
        CUDA_SUCCESS
        CUDA_ERROR_NO_DEVICE
        CUDA_ERROR_INVALID_VALUE
        CUDA_ERROR_INVALID_CONTEXT
        CUDA_ERROR_INVALID_GRAPHICS_CONTEXT
    pCudaDeviceCount : unsigned int
        Returned number of CUDA devices.
    pCudaDevices : List[CUdevice]
        Returned CUDA devices.

    See Also
    --------
    ~.cudaGLGetDevices

    Notes
    -----
    This function is not supported on Mac OS X.

    """
    cdef unsigned int pCudaDeviceCount = 0
    cdef ccuda.CUdevice* cpCudaDevices = NULL
    pypCudaDevices = []
    if cudaDeviceCount != 0:
        cpCudaDevices = <ccuda.CUdevice*>calloc(cudaDeviceCount, sizeof(ccuda.CUdevice))
        if cpCudaDevices is NULL:
            raise MemoryError('Failed to allocate length x size memory: ' + str(cudaDeviceCount) + 'x' + str(sizeof(ccuda.CUdevice)))
    cdef ccuda.CUGLDeviceList cdeviceList = deviceList.value
    err = ccuda.cuGLGetDevices(&pCudaDeviceCount, cpCudaDevices, cudaDeviceCount, cdeviceList)
    if CUresult(err) == CUresult(0):
        pypCudaDevices = [CUdevice(init_value=<void_ptr>cpCudaDevices[idx]) for idx in range(cudaDeviceCount)]
    if cpCudaDevices is not NULL:
        free(cpCudaDevices)
    return (CUresult(err), pCudaDeviceCount, pypCudaDevices)

@cython.embedsignature(True)
def sizeof(objType):
    """ Returns the size of provided CUDA Python structure in bytes

    Parameters
    ----------
    objType : Any
        CUDA Python object

    Returns
    -------
    lowered_name : int
        The size of `objType` in bytes
    """
    if objType == CUuuid_st:
        return sizeof(ccuda.CUuuid_st)
    if objType == CUipcEventHandle_st:
        return sizeof(ccuda.CUipcEventHandle_st)
    if objType == CUipcMemHandle_st:
        return sizeof(ccuda.CUipcMemHandle_st)
    if objType == CUstreamMemOpWaitValueParams_st:
        return sizeof(ccuda.CUstreamMemOpWaitValueParams_st)
    if objType == CUstreamMemOpWriteValueParams_st:
        return sizeof(ccuda.CUstreamMemOpWriteValueParams_st)
    if objType == CUstreamMemOpFlushRemoteWritesParams_st:
        return sizeof(ccuda.CUstreamMemOpFlushRemoteWritesParams_st)
    if objType == CUstreamMemOpMemoryBarrierParams_st:
        return sizeof(ccuda.CUstreamMemOpMemoryBarrierParams_st)
    if objType == CUstreamBatchMemOpParams_union:
        return sizeof(ccuda.CUstreamBatchMemOpParams_union)
    if objType == CUDA_BATCH_MEM_OP_NODE_PARAMS_st:
        return sizeof(ccuda.CUDA_BATCH_MEM_OP_NODE_PARAMS_st)
    if objType == CUdevprop_st:
        return sizeof(ccuda.CUdevprop_st)
    if objType == CUaccessPolicyWindow_st:
        return sizeof(ccuda.CUaccessPolicyWindow_st)
    if objType == CUDA_KERNEL_NODE_PARAMS_st:
        return sizeof(ccuda.CUDA_KERNEL_NODE_PARAMS_st)
    if objType == CUDA_MEMSET_NODE_PARAMS_st:
        return sizeof(ccuda.CUDA_MEMSET_NODE_PARAMS_st)
    if objType == CUDA_HOST_NODE_PARAMS_st:
        return sizeof(ccuda.CUDA_HOST_NODE_PARAMS_st)
    if objType == CUkernelNodeAttrValue_union:
        return sizeof(ccuda.CUkernelNodeAttrValue_union)
    if objType == CUstreamAttrValue_union:
        return sizeof(ccuda.CUstreamAttrValue_union)
    if objType == CUexecAffinitySmCount_st:
        return sizeof(ccuda.CUexecAffinitySmCount_st)
    if objType == CUexecAffinityParam_st:
        return sizeof(ccuda.CUexecAffinityParam_st)
    if objType == CUDA_MEMCPY2D_st:
        return sizeof(ccuda.CUDA_MEMCPY2D_st)
    if objType == CUDA_MEMCPY3D_st:
        return sizeof(ccuda.CUDA_MEMCPY3D_st)
    if objType == CUDA_MEMCPY3D_PEER_st:
        return sizeof(ccuda.CUDA_MEMCPY3D_PEER_st)
    if objType == CUDA_ARRAY_DESCRIPTOR_st:
        return sizeof(ccuda.CUDA_ARRAY_DESCRIPTOR_st)
    if objType == CUDA_ARRAY3D_DESCRIPTOR_st:
        return sizeof(ccuda.CUDA_ARRAY3D_DESCRIPTOR_st)
    if objType == CUDA_ARRAY_SPARSE_PROPERTIES_st:
        return sizeof(ccuda.CUDA_ARRAY_SPARSE_PROPERTIES_st)
    if objType == CUDA_ARRAY_MEMORY_REQUIREMENTS_st:
        return sizeof(ccuda.CUDA_ARRAY_MEMORY_REQUIREMENTS_st)
    if objType == CUDA_RESOURCE_DESC_st:
        return sizeof(ccuda.CUDA_RESOURCE_DESC_st)
    if objType == CUDA_TEXTURE_DESC_st:
        return sizeof(ccuda.CUDA_TEXTURE_DESC_st)
    if objType == CUDA_RESOURCE_VIEW_DESC_st:
        return sizeof(ccuda.CUDA_RESOURCE_VIEW_DESC_st)
    if objType == CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st:
        return sizeof(ccuda.CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_st)
    if objType == CUDA_LAUNCH_PARAMS_st:
        return sizeof(ccuda.CUDA_LAUNCH_PARAMS_st)
    if objType == CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st)
    if objType == CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st)
    if objType == CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st)
    if objType == CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st)
    if objType == CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_st)
    if objType == CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_st)
    if objType == CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st:
        return sizeof(ccuda.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_st)
    if objType == CUDA_EXT_SEM_WAIT_NODE_PARAMS_st:
        return sizeof(ccuda.CUDA_EXT_SEM_WAIT_NODE_PARAMS_st)
    if objType == CUarrayMapInfo_st:
        return sizeof(ccuda.CUarrayMapInfo_st)
    if objType == CUmemLocation_st:
        return sizeof(ccuda.CUmemLocation_st)
    if objType == CUmemAllocationProp_st:
        return sizeof(ccuda.CUmemAllocationProp_st)
    if objType == CUmemAccessDesc_st:
        return sizeof(ccuda.CUmemAccessDesc_st)
    if objType == CUmemPoolProps_st:
        return sizeof(ccuda.CUmemPoolProps_st)
    if objType == CUmemPoolPtrExportData_st:
        return sizeof(ccuda.CUmemPoolPtrExportData_st)
    if objType == CUDA_MEM_ALLOC_NODE_PARAMS_st:
        return sizeof(ccuda.CUDA_MEM_ALLOC_NODE_PARAMS_st)
    if objType == CUeglFrame_st:
        return sizeof(ccuda.CUeglFrame_st)
    if objType == CUcontext:
        return sizeof(ccuda.CUcontext)
    if objType == CUmodule:
        return sizeof(ccuda.CUmodule)
    if objType == CUfunction:
        return sizeof(ccuda.CUfunction)
    if objType == CUarray:
        return sizeof(ccuda.CUarray)
    if objType == CUmipmappedArray:
        return sizeof(ccuda.CUmipmappedArray)
    if objType == CUtexref:
        return sizeof(ccuda.CUtexref)
    if objType == CUsurfref:
        return sizeof(ccuda.CUsurfref)
    if objType == CUevent:
        return sizeof(ccuda.CUevent)
    if objType == CUstream:
        return sizeof(ccuda.CUstream)
    if objType == CUgraphicsResource:
        return sizeof(ccuda.CUgraphicsResource)
    if objType == CUexternalMemory:
        return sizeof(ccuda.CUexternalMemory)
    if objType == CUexternalSemaphore:
        return sizeof(ccuda.CUexternalSemaphore)
    if objType == CUgraph:
        return sizeof(ccuda.CUgraph)
    if objType == CUgraphNode:
        return sizeof(ccuda.CUgraphNode)
    if objType == CUgraphExec:
        return sizeof(ccuda.CUgraphExec)
    if objType == CUmemoryPool:
        return sizeof(ccuda.CUmemoryPool)
    if objType == CUuserObject:
        return sizeof(ccuda.CUuserObject)
    if objType == CUlinkState:
        return sizeof(ccuda.CUlinkState)
    if objType == EGLImageKHR:
        return sizeof(ccuda.EGLImageKHR)
    if objType == EGLStreamKHR:
        return sizeof(ccuda.EGLStreamKHR)
    if objType == EGLSyncKHR:
        return sizeof(ccuda.EGLSyncKHR)
    if objType == CUeglStreamConnection:
        return sizeof(ccuda.CUeglStreamConnection)
    if objType == CUhostFn:
        return sizeof(ccuda.CUhostFn)
    if objType == CUstreamCallback:
        return sizeof(ccuda.CUstreamCallback)
    if objType == CUoccupancyB2DSize:
        return sizeof(ccuda.CUoccupancyB2DSize)
    if objType == CUuuid:
        return sizeof(ccuda.CUuuid)
    if objType == CUipcEventHandle_v1:
        return sizeof(ccuda.CUipcEventHandle_v1)
    if objType == CUipcEventHandle:
        return sizeof(ccuda.CUipcEventHandle)
    if objType == CUipcMemHandle_v1:
        return sizeof(ccuda.CUipcMemHandle_v1)
    if objType == CUipcMemHandle:
        return sizeof(ccuda.CUipcMemHandle)
    if objType == CUstreamBatchMemOpParams_v1:
        return sizeof(ccuda.CUstreamBatchMemOpParams_v1)
    if objType == CUstreamBatchMemOpParams:
        return sizeof(ccuda.CUstreamBatchMemOpParams)
    if objType == CUDA_BATCH_MEM_OP_NODE_PARAMS:
        return sizeof(ccuda.CUDA_BATCH_MEM_OP_NODE_PARAMS)
    if objType == CUdevprop_v1:
        return sizeof(ccuda.CUdevprop_v1)
    if objType == CUdevprop:
        return sizeof(ccuda.CUdevprop)
    if objType == CUaccessPolicyWindow_v1:
        return sizeof(ccuda.CUaccessPolicyWindow_v1)
    if objType == CUaccessPolicyWindow:
        return sizeof(ccuda.CUaccessPolicyWindow)
    if objType == CUDA_KERNEL_NODE_PARAMS_v1:
        return sizeof(ccuda.CUDA_KERNEL_NODE_PARAMS_v1)
    if objType == CUDA_KERNEL_NODE_PARAMS:
        return sizeof(ccuda.CUDA_KERNEL_NODE_PARAMS)
    if objType == CUDA_MEMSET_NODE_PARAMS_v1:
        return sizeof(ccuda.CUDA_MEMSET_NODE_PARAMS_v1)
    if objType == CUDA_MEMSET_NODE_PARAMS:
        return sizeof(ccuda.CUDA_MEMSET_NODE_PARAMS)
    if objType == CUDA_HOST_NODE_PARAMS_v1:
        return sizeof(ccuda.CUDA_HOST_NODE_PARAMS_v1)
    if objType == CUDA_HOST_NODE_PARAMS:
        return sizeof(ccuda.CUDA_HOST_NODE_PARAMS)
    if objType == CUkernelNodeAttrValue_v1:
        return sizeof(ccuda.CUkernelNodeAttrValue_v1)
    if objType == CUkernelNodeAttrValue:
        return sizeof(ccuda.CUkernelNodeAttrValue)
    if objType == CUstreamAttrValue_v1:
        return sizeof(ccuda.CUstreamAttrValue_v1)
    if objType == CUstreamAttrValue:
        return sizeof(ccuda.CUstreamAttrValue)
    if objType == CUexecAffinitySmCount_v1:
        return sizeof(ccuda.CUexecAffinitySmCount_v1)
    if objType == CUexecAffinitySmCount:
        return sizeof(ccuda.CUexecAffinitySmCount)
    if objType == CUexecAffinityParam_v1:
        return sizeof(ccuda.CUexecAffinityParam_v1)
    if objType == CUexecAffinityParam:
        return sizeof(ccuda.CUexecAffinityParam)
    if objType == CUDA_MEMCPY2D_v2:
        return sizeof(ccuda.CUDA_MEMCPY2D_v2)
    if objType == CUDA_MEMCPY2D:
        return sizeof(ccuda.CUDA_MEMCPY2D)
    if objType == CUDA_MEMCPY3D_v2:
        return sizeof(ccuda.CUDA_MEMCPY3D_v2)
    if objType == CUDA_MEMCPY3D:
        return sizeof(ccuda.CUDA_MEMCPY3D)
    if objType == CUDA_MEMCPY3D_PEER_v1:
        return sizeof(ccuda.CUDA_MEMCPY3D_PEER_v1)
    if objType == CUDA_MEMCPY3D_PEER:
        return sizeof(ccuda.CUDA_MEMCPY3D_PEER)
    if objType == CUDA_ARRAY_DESCRIPTOR_v2:
        return sizeof(ccuda.CUDA_ARRAY_DESCRIPTOR_v2)
    if objType == CUDA_ARRAY_DESCRIPTOR:
        return sizeof(ccuda.CUDA_ARRAY_DESCRIPTOR)
    if objType == CUDA_ARRAY3D_DESCRIPTOR_v2:
        return sizeof(ccuda.CUDA_ARRAY3D_DESCRIPTOR_v2)
    if objType == CUDA_ARRAY3D_DESCRIPTOR:
        return sizeof(ccuda.CUDA_ARRAY3D_DESCRIPTOR)
    if objType == CUDA_ARRAY_SPARSE_PROPERTIES_v1:
        return sizeof(ccuda.CUDA_ARRAY_SPARSE_PROPERTIES_v1)
    if objType == CUDA_ARRAY_SPARSE_PROPERTIES:
        return sizeof(ccuda.CUDA_ARRAY_SPARSE_PROPERTIES)
    if objType == CUDA_ARRAY_MEMORY_REQUIREMENTS_v1:
        return sizeof(ccuda.CUDA_ARRAY_MEMORY_REQUIREMENTS_v1)
    if objType == CUDA_ARRAY_MEMORY_REQUIREMENTS:
        return sizeof(ccuda.CUDA_ARRAY_MEMORY_REQUIREMENTS)
    if objType == CUDA_RESOURCE_DESC_v1:
        return sizeof(ccuda.CUDA_RESOURCE_DESC_v1)
    if objType == CUDA_RESOURCE_DESC:
        return sizeof(ccuda.CUDA_RESOURCE_DESC)
    if objType == CUDA_TEXTURE_DESC_v1:
        return sizeof(ccuda.CUDA_TEXTURE_DESC_v1)
    if objType == CUDA_TEXTURE_DESC:
        return sizeof(ccuda.CUDA_TEXTURE_DESC)
    if objType == CUDA_RESOURCE_VIEW_DESC_v1:
        return sizeof(ccuda.CUDA_RESOURCE_VIEW_DESC_v1)
    if objType == CUDA_RESOURCE_VIEW_DESC:
        return sizeof(ccuda.CUDA_RESOURCE_VIEW_DESC)
    if objType == CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1:
        return sizeof(ccuda.CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1)
    if objType == CUDA_POINTER_ATTRIBUTE_P2P_TOKENS:
        return sizeof(ccuda.CUDA_POINTER_ATTRIBUTE_P2P_TOKENS)
    if objType == CUDA_LAUNCH_PARAMS_v1:
        return sizeof(ccuda.CUDA_LAUNCH_PARAMS_v1)
    if objType == CUDA_LAUNCH_PARAMS:
        return sizeof(ccuda.CUDA_LAUNCH_PARAMS)
    if objType == CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1)
    if objType == CUDA_EXTERNAL_MEMORY_HANDLE_DESC:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_HANDLE_DESC)
    if objType == CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1)
    if objType == CUDA_EXTERNAL_MEMORY_BUFFER_DESC:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_BUFFER_DESC)
    if objType == CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1)
    if objType == CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC:
        return sizeof(ccuda.CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC)
    if objType == CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1)
    if objType == CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC)
    if objType == CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1)
    if objType == CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS)
    if objType == CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1)
    if objType == CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS:
        return sizeof(ccuda.CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS)
    if objType == CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1:
        return sizeof(ccuda.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1)
    if objType == CUDA_EXT_SEM_SIGNAL_NODE_PARAMS:
        return sizeof(ccuda.CUDA_EXT_SEM_SIGNAL_NODE_PARAMS)
    if objType == CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1:
        return sizeof(ccuda.CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1)
    if objType == CUDA_EXT_SEM_WAIT_NODE_PARAMS:
        return sizeof(ccuda.CUDA_EXT_SEM_WAIT_NODE_PARAMS)
    if objType == CUarrayMapInfo_v1:
        return sizeof(ccuda.CUarrayMapInfo_v1)
    if objType == CUarrayMapInfo:
        return sizeof(ccuda.CUarrayMapInfo)
    if objType == CUmemLocation_v1:
        return sizeof(ccuda.CUmemLocation_v1)
    if objType == CUmemLocation:
        return sizeof(ccuda.CUmemLocation)
    if objType == CUmemAllocationProp_v1:
        return sizeof(ccuda.CUmemAllocationProp_v1)
    if objType == CUmemAllocationProp:
        return sizeof(ccuda.CUmemAllocationProp)
    if objType == CUmemAccessDesc_v1:
        return sizeof(ccuda.CUmemAccessDesc_v1)
    if objType == CUmemAccessDesc:
        return sizeof(ccuda.CUmemAccessDesc)
    if objType == CUmemPoolProps_v1:
        return sizeof(ccuda.CUmemPoolProps_v1)
    if objType == CUmemPoolProps:
        return sizeof(ccuda.CUmemPoolProps)
    if objType == CUmemPoolPtrExportData_v1:
        return sizeof(ccuda.CUmemPoolPtrExportData_v1)
    if objType == CUmemPoolPtrExportData:
        return sizeof(ccuda.CUmemPoolPtrExportData)
    if objType == CUDA_MEM_ALLOC_NODE_PARAMS:
        return sizeof(ccuda.CUDA_MEM_ALLOC_NODE_PARAMS)
    if objType == CUeglFrame_v1:
        return sizeof(ccuda.CUeglFrame_v1)
    if objType == CUeglFrame:
        return sizeof(ccuda.CUeglFrame)
    if objType == cuuint32_t:
        return sizeof(ccuda.cuuint32_t)
    if objType == cuuint64_t:
        return sizeof(ccuda.cuuint64_t)
    if objType == CUdeviceptr_v2:
        return sizeof(ccuda.CUdeviceptr_v2)
    if objType == CUdeviceptr:
        return sizeof(ccuda.CUdeviceptr)
    if objType == CUdevice_v1:
        return sizeof(ccuda.CUdevice_v1)
    if objType == CUdevice:
        return sizeof(ccuda.CUdevice)
    if objType == CUtexObject_v1:
        return sizeof(ccuda.CUtexObject_v1)
    if objType == CUtexObject:
        return sizeof(ccuda.CUtexObject)
    if objType == CUsurfObject_v1:
        return sizeof(ccuda.CUsurfObject_v1)
    if objType == CUsurfObject:
        return sizeof(ccuda.CUsurfObject)
    if objType == CUmemGenericAllocationHandle_v1:
        return sizeof(ccuda.CUmemGenericAllocationHandle_v1)
    if objType == CUmemGenericAllocationHandle:
        return sizeof(ccuda.CUmemGenericAllocationHandle)
    if objType == GLenum:
        return sizeof(ccuda.GLenum)
    if objType == GLuint:
        return sizeof(ccuda.GLuint)
    if objType == EGLint:
        return sizeof(ccuda.EGLint)
    if objType == VdpDevice:
        return sizeof(ccuda.VdpDevice)
    if objType == VdpGetProcAddress:
        return sizeof(ccuda.VdpGetProcAddress)
    if objType == VdpVideoSurface:
        return sizeof(ccuda.VdpVideoSurface)
    if objType == VdpOutputSurface:
        return sizeof(ccuda.VdpOutputSurface)
    raise TypeError("Unknown type: " + str(objType))
